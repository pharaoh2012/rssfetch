{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "成为高级 PHP 开发者需要的思维转变",
      "link": "https://www.cnblogs.com/catchadmin/p/19407447",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19407447\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 08:14\">\n    <span>成为高级 PHP 开发者需要的思维转变</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"成为高级-php-开发者需要的思维转变\">成为高级 PHP 开发者需要的思维转变</h1>\n<p>想成为 PHP 高手?先从调整思维开始</p>\n<p>想成为专业的 PHP 开发者?这很好。但在深入研究 PHP 语法或最新框架之前,有一件事你需要明确:你的思维方式。</p>\n<p>事实上,这不仅仅是写代码——成为 PHP 专业人士意味着用不同的方式思考。这关乎你如何处理问题、如何与他人协作,以及如何成长。当然,深入了解 PHP 很重要,但正确的思维方式才是在 PHP 领域脱颖而出的真正关键。</p>\n<p>本文将讨论能让你从 PHP 新手成长为专业开发者的关键思维转变。准备好提升了吗?开始吧。</p>\n<p><a href=\"https://catchadmin.com/post/2025-12/the-mindset-shifts-you-need-to-become-a-rockstar-php-developer\" rel=\"noopener nofollow\" target=\"_blank\">原文链接 成为高级 PHP 开发者需要的思维转变</a></p>\n<h2 id=\"转变-1从只是写代码到解决实际问题\">转变 1:从\"只是写代码\"到\"解决实际问题\"</h2>\n<p>写代码很酷,但解决问题更酷</p>\n<p>说实话:任何人都能写代码。但写出能解决实际问题的代码?这才是关键所在。作为初学者,很容易迷失在语法细节和函数调用中,但重点是:编码只是工具。作为 PHP 开发者,你的工作不仅仅是敲代码——而是以最佳方式解决问题。</p>\n<p><strong>技术实践:在编码前先分解问题</strong></p>\n<p>在打开代码编辑器之前,先将问题分解成可管理的小块。使用流程图或伪代码等工具来规划逻辑。这种方法不仅能理清思路,还能帮你尽早发现边界情况和潜在陷阱。</p>\n<p>示例:<br />\n构建购物车时,先为添加商品、计算总价和管理会话持久化编写伪代码。然后在 PHP 中有条不紊地实现每一步。例如:</p>\n<pre><code class=\"language-php\">// Pseudocode: Add item to cart\nif (!isset($_SESSION['cart'])) {\n    $_SESSION['cart'] = array();\n}\narray_push($_SESSION['cart'], $item);\n</code></pre>\n<p>这种结构化方法将编码转变为解决问题,而不仅仅是随意写代码。</p>\n<h2 id=\"转变-2从复制粘贴编码到理解并掌控你的代码\">转变 2:从\"复制粘贴编码\"到\"理解并掌控你的代码\"</h2>\n<p>别再偷懒复制粘贴了(我们都经历过)</p>\n<p>这很诱人,对吧?在 Stack Overflow 上找到快速解决方案,复制粘贴代码,然后收工。但现实是:这在短期内可能有效,但从长远来看是灾难。如果你不理解正在使用的代码,就会遇到无法修复的问题——更糟的是,你会错过学习如何编写真正适合你的代码的机会。</p>\n<p><strong>技术实践:阅读文档并在本地测试</strong></p>\n<p>不要直接复制粘贴,而是先阅读文档。这对理解函数和库的工作原理至关重要。一旦掌握了概念,就在隔离环境中测试它(使用 PHP FPM 或 Xdebug 等工具)来观察它的行为。</p>\n<p>示例:<br />\n在使用第三方 API 之前,彻底阅读其文档。尝试简单的 curl 请求来查看数据格式以及 PHP 如何处理它。不要只依赖教程——自己动手试试。以下是在 PHP 中向 API 发起请求的快速示例:</p>\n<pre><code class=\"language-php\">// Example: Using cURL to send a GET request\n$ch = curl_init();\ncurl_setopt($ch, CURLOPT_URL, \"https://api.example.com/data\");\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n$response = curl_exec($ch);\ncurl_close($ch);\n$data = json_decode($response, true);\nprint_r($data);\n</code></pre>\n<p>现在,你理解了请求过程以及 API 如何响应。</p>\n<h2 id=\"转变-3从独立开发到团队协作\">转变 3:从\"独立开发\"到\"团队协作\"</h2>\n<p>你不是一个人在战斗</p>\n<p>是的,独自完成小项目一开始感觉很好。但一旦进入专业领域,编码就变成了团队运动。作为 PHP 开发者,你经常会与前端开发者、数据库管理员、设计师,有时甚至是项目经理一起工作。你不再是一支单人军队——你是更大图景的一部分。</p>\n<p><strong>技术实践:认真使用版本控制(Git)</strong></p>\n<p>协作意味着共享代码和跟踪变更。这就是版本控制的用武之地。学习 Git 并使用 GitHub 或 GitLab 等平台将使你的代码协作顺畅高效。使用 Git,你可以跟踪变更、回退到以前的版本,并合并多个开发者的代码而不会混乱。</p>\n<p>示例:</p>\n<pre><code class=\"language-bash\"># Initialize a new Git repository\ngit init\n# Add files to the staging area\ngit add .\n# Commit changes with a message\ngit commit -m \"Initial commit\"\n# Push changes to a remote repository\ngit push origin main\n</code></pre>\n<p>Git 不仅适用于大型团队——它对个人项目也至关重要,因为它能帮你有效管理变更。与他人合作时,拉取请求和代码审查对于维护高质量代码至关重要。</p>\n<h2 id=\"转变-4从追逐流行框架到掌握基础\">转变 4:从\"追逐流行框架\"到\"掌握基础\"</h2>\n<p>框架很有趣,但基础才是永恒的</p>\n<p>Laravel、Symfony 和 CodeIgniter 等 PHP 框架很棒,但问题是:在深入研究任何框架之前,你需要对 PHP 本身有扎实的理解。在不理解基础的情况下直接跳入框架,就像在学会走路之前就想跑步。</p>\n<p><strong>技术实践:从零开始构建项目</strong></p>\n<p>在深入研究 Laravel 等框架之前,花时间使用纯 PHP 从零开始构建一个简单项目。例如,构建一个简单的 CRUD(创建、读取、更新、删除)应用,而不依赖任何框架。这将巩固你对以下内容的理解:</p>\n<ul>\n<li>路由</li>\n<li>数据库交互</li>\n<li>会话处理</li>\n<li>用户认证</li>\n</ul>\n<p>示例:<br />\n以下是如何使用 PHP 和 MySQL 设置基本 CRUD 应用:</p>\n<ol>\n<li>创建数据库表:</li>\n</ol>\n<pre><code class=\"language-sql\">CREATE TABLE users (\n  id INT AUTO_INCREMENT PRIMARY KEY,\n  name VARCHAR(100),\n  email VARCHAR(100)\n);\n</code></pre>\n<ol start=\"2\">\n<li>使用 PHP 插入数据:</li>\n</ol>\n<pre><code class=\"language-php\">// Establish a connection\n$conn = new mysqli(\"localhost\", \"username\", \"password\", \"database\");\n// Check for connection error\nif ($conn-&gt;connect_error) {\n    die(\"Connection failed: \" . $conn-&gt;connect_error);\n}\n// Insert data\n$sql = \"INSERT INTO users (name, email) VALUES ('John Doe', 'john@example.com')\";\nif ($conn-&gt;query($sql) === TRUE) {\n    echo \"New record created successfully\";\n} else {\n    echo \"Error: \" . $sql . \"&lt;br&gt;\" . $conn-&gt;error;\n}\n$conn-&gt;close();\n</code></pre>\n<p>在不使用框架的情况下构建项目将让你深入理解底层工作原理,这会让你在之后使用 Laravel 等框架时感觉轻松许多。</p>\n<h2 id=\"转变-5从一次性学习到持续学习\">转变 5:从\"一次性学习\"到\"持续学习\"</h2>\n<p>学习永无止境</p>\n<p>如果你认为学完 PHP 和几个框架就\"完成\"了,那就再想想。技术世界发展迅速,作为专业开发者,你需要跟上步伐。优秀的 PHP 开发者不仅仅是知道如何写代码的人;而是不断进化、适应并保持好奇心的人。</p>\n<p><strong>技术实践:关注 PHP 变更日志和博客</strong></p>\n<p>及时了解 PHP 版本和最佳实践。订阅博客,关注 PHP 相关新闻,并阅读每个新版本发布的官方 PHP 变更日志。了解 PHP 8 中的新特性(如 JIT 和属性)将使你的代码保持现代和高效。</p>\n<p>示例:<br />\n在 PHP 8 中,match 表达式可以成为 switch-case 的更简洁替代方案。如果你还没试过,现在就试试!</p>\n<pre><code class=\"language-php\">$fruit = 'apple';\necho match($fruit) {\n    'apple' =&gt; 'It's an apple!',\n    'banana' =&gt; 'It's a banana!',\n    default =&gt; 'Unknown fruit',\n};\n</code></pre>\n<p>这种新语法更紧凑,消除了多个 case 语句的需要。</p>\n<h2 id=\"转变-6从快速修复到长期解决方案\">转变 6:从\"快速修复\"到\"长期解决方案\"</h2>\n<p>写出你会引以为豪的代码(而不仅仅是能用的代码)</p>\n<p>我们都经历过。紧迫的截止日期、压力,以及随便拼凑点东西的诱惑。但问题是:编写快速而粗糙的代码现在可能完成工作,但以后会反噬你。糟糕的代码会导致 bug、性能问题和巨大的麻烦。</p>\n<p><strong>技术实践:编写可测试、可扩展的代码</strong></p>\n<p>确保代码保持整洁和可扩展的一种方法是编写测试。使用 PHPUnit 进行单元测试来验证代码的每个部分是否按预期工作。</p>\n<p>示例:<br />\n以下是一个简单的 PHPUnit 测试,用于测试计算购物车中商品总价的方法:</p>\n<pre><code class=\"language-php\">use PHPUnit\\Framework\\TestCase;\nclass ShoppingCartTest extends TestCase\n{\n    public function testTotalPrice()\n    {\n        $cart = new ShoppingCart();\n        $cart-&gt;addItem('Apple', 1.50);\n        $cart-&gt;addItem('Banana', 1.00);\n        \n        $this-&gt;assertEquals(2.50, $cart-&gt;getTotalPrice());\n    }\n}\n</code></pre>\n<p>单元测试有助于尽早发现 bug,并确保在添加新功能时,现有功能不会出问题。</p>\n<h2 id=\"结语转变思维让你的-php-职业生涯腾飞\">结语:转变思维,让你的 PHP 职业生涯腾飞</h2>\n<p>成为 PHP 专业人士远不止于写代码——这关乎像问题解决者一样思考、深入理解你的工具、与他人协作,以及致力于持续成长。如果你今天开始进行这些思维转变,你将顺利成为一名抢手的 PHP 开发者。</p>\n<p>所以,下次坐下来编码时,记住:这不仅仅是完成工作——而是以正确的方式、专业的方式去做。祝编码愉快!</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-27 08:14</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">9</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一阶低通滤波器（LPF）使用详讲",
      "link": "https://www.cnblogs.com/lsksp/p/19406964",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lsksp/p/19406964\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 00:10\">\n    <span>一阶低通滤波器（LPF）使用详讲</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        一阶低通滤波器（Low Pass Filter，LPF）的核心作用是：允许输入信号中频率低于设定截止频率的成分通过（衰减极小），阻隔或大幅衰减高于截止频率的高频噪声，从而获得更纯净的目标信号。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>一阶低通滤波器（Low Pass Filter，LPF）的核心作用是：允许输入信号中频率低于设定截止频率的成分通过（衰减极小），阻隔或大幅衰减高于截止频率的高频噪声，从而获得更纯净的目标信号。</p>\n<hr />\n<h3 id=\"一一阶低通滤波器定义\">一、一阶低通滤波器定义</h3>\n<p>对于一阶低通滤波而言，从控制模型上分析就是一个一阶惯性环节，其描述形式如式所示：</p>\n<p></p><div class=\"math display\">\\[H\\left( s \\right) =\\frac{1}{Ts+1}\n\\]</div><p></p><p></p><div class=\"math display\">\\[\\text{注：}T=\\frac{1}{w_c}\\text{，}w_c=2\\pi \\cdot f_c\\text{；}\n\\text{其中，}T\\text{为时间常数，}w_c\\text{为角频率，}f_c\\text{为截止频率}\n\\]</div><p></p><p><img alt=\"bode图\" class=\"lazyload\" /></p>\n<p>幅频响应：</p>\n<p></p><div class=\"math display\">\\[\\begin{equation}\n\n|H(j\\omega)| = \\frac{1}{\\sqrt{1+(\\omega T)^2}} = \\frac{1}{\\sqrt{1+\\left(\\frac{\\omega}{\\omega_c}\\right)^2}}\n\n\\end{equation}\n\\]</div><p></p><p>相频响应：</p>\n<p></p><div class=\"math display\">\\[\\begin{equation}\n\\angle H(j\\omega) = -\\arctan(\\omega T) = -\\arctan\\left(\\frac{\\omega}{\\omega_c}\\right)\n\\end{equation}\n\\]</div><p></p><p>简单来说，一阶低通滤波器就做了一件事：<strong>让慢的变化通过，阻隔快的变化。</strong> 在实际工程中使用一阶低通滤波器时，需特别注意以下特点：</p>\n<ol>\n<li><strong>平滑效果</strong>：它能滤除高频噪声（如 ADC 抖动、电源纹波）。截止频率设得越低，对输入信号变化的响应越慢。</li>\n<li><strong>相位滞后</strong>：输出信号总是比输入信号“慢半拍”。在闭环控制系统（如 PID）中，如果滤波强度过大，会导致系统响应迟钝甚至震荡。</li>\n<li><strong>衰减特性</strong>：在截止频率 <code>fc</code> 处，信号幅度衰减至<code> -3dB</code>（约为 0.707 倍），相位滞后<code> -45°</code></li>\n</ol>\n<p>滤波效果对比图如下：</p>\n<p><img alt=\"lpf_cutoff_freq_comparison\" class=\"lazyload\" /></p>\n<h3 id=\"二一阶低通滤波器的使用\">二、一阶低通滤波器的使用</h3>\n<p>在使用滤波器前，需厘清四个核心概念（以车载 IMU 为例）：</p>\n<ul>\n<li><strong>信号频率</strong>：车辆加速度的变化（你想测的，较慢）；</li>\n<li><strong>噪声频率</strong>：发动机的震动（你想滤的，较快）；</li>\n<li><strong>采样频率</strong>：你采集数据的频率（干活速度，必须足够快以看清噪声并滤除）；</li>\n<li><strong>截止频率</strong>：设定的“分界线”，应介于信号和噪声之间。</li>\n</ul>\n<p>在实际工程中，我们设计滤波器主要有两个方向：</p>\n<h4 id=\"1设计传感器为了达到目标去选硬件\">1、设计传感器（为了达到目标去选硬件）</h4>\n<p>这是<strong>自顶向下</strong>的设计思路。当我们明确了需要测量的信号和需要滤除的噪声时，反过来推算硬件需求。</p>\n<ul>\n<li><strong>确定范围</strong>：已知信号频率（如 5 Hz）和噪声频率（如 50 Hz）。</li>\n<li><strong>设定分界线</strong>：选择截止频率<code> fc</code> 介于二者之间（如 10 Hz）。</li>\n<li><strong>推算采样频率</strong>：为了保证数字滤波算法的准确性，工程上通常要求采样频率大于 10 倍的截止频率（经验值，确保滤波精度）。因此，我们需要选择采样频率至少为 100 Hz 的传感器。</li>\n</ul>\n<h4 id=\"2使用传感器有了硬件去调参数\">2、使用传感器（有了硬件去调参数）</h4>\n<p>这是<strong>自底向上</strong>的调试思路。在硬件采样频率固定（如 IMU 锁定在 100 Hz）的情况下，寻找截止频率的最佳设置区间。</p>\n<ul>\n<li><strong>算上限</strong>：工程上通常要求采样频率大于 10 倍的截止频率（经验值，确保滤波精度），即截止频率小于 10 Hz。</li>\n<li><strong>看下限</strong>：为了保留有效信号，截止频率必须大于信号频率（如 5 Hz）。</li>\n<li><strong>定参数</strong>：在“上限”和“下限”的夹缝中选择一个值（如 8 Hz）。如果信号频率高于上限（如想测 50 Hz 震动），则说明该传感器采样频率不足，无法胜任。</li>\n</ul>\n<h3 id=\"三c语言实现\">三、C语言实现</h3>\n<p>使用以下代码，请包含以下公共内容</p>\n<pre><code class=\"language-C\">#include &lt;stdint.h&gt;\n#include &lt;math.h&gt;  /* 双线性变换法需要用到 tanf */\n\n#ifndef PI\n#define PI 3.14159265358979323846f\n#endif\n\n</code></pre>\n<h4 id=\"1后向差分方法backward-difference\">1、后向差分方法（Backward Difference）</h4>\n<p>这是最经典、最稳健的实现方式。它利用上一时刻的输出值进行递推，数值稳定性高，<strong>无条件稳定</strong>。适用于绝大多数传感器滤波、电机控制等通用场景。若调试中发现数据有明显的相位滞后，可适当增大截止频率。</p>\n<pre><code class=\"language-C\">#include &lt;stdint.h&gt; /* 推荐包含标准类型定义 */\n\n\n/**\n * @brief       后向差分法一阶低通滤波器结构体\n */\ntypedef struct\n{\n\tfloat alpha;           /* 滤波系数 */\n\tfloat one_minus_alpha; /* 预计算的 (1 - alpha) */\n\tfloat last_output;     /* 上一次滤波输出值 */\n\tfloat cutoff_freq;     /* 截止频率 */\n\tfloat sample_freq;     /* 采样频率 */\n} LPF_BackwardEuler;\n\n/**\n * @brief       后向差分法一阶低通滤波器初始化函数\n * @param       filter : 滤波器结构体指针\n * @param       cutoff_freq : 截止频率\n * @param       sample_freq : 采样频率\n * @retval      0:成功, -1:参数错误\n * @note        建议 sample_freq 至少为 cutoff_freq 的 10 倍以获得较好的效果\n */\nint lpf_backward_euler_init(LPF_BackwardEuler *filter, float cutoff_freq, float sample_freq)\n{\n\tif (filter == NULL || cutoff_freq &lt;= 0.0f || sample_freq &lt;= 0.0f)\n\t{\n\t\treturn -1;\n\t}\n    \n\t/* \n\t* 限制采样率不得低于奈奎斯特频率 (2倍)，否则无法重构信号。\n\t* 实际工程中为了滤波效果，通常建议 10 倍以上。\n\t*/\n\tif (sample_freq &lt; 2.0f * cutoff_freq)\n\t{\n\t\treturn -1; \n\t}\n\t\n\n\tfloat tau = 1.0f / (2.0f * PI * cutoff_freq);\n\tfloat ts = 1.0f / sample_freq;\n\tfilter-&gt;alpha = ts / (tau + ts);\n\t\n\tfilter-&gt;one_minus_alpha = 1.0f - filter-&gt;alpha;\n\t\n\t/* 初始化结构体成员 */\n\tfilter-&gt;cutoff_freq = cutoff_freq;\n\tfilter-&gt;sample_freq = sample_freq;\n\tfilter-&gt;last_output = 0.0f;\n\t\n\treturn 0;\n}\n\n/**\n * @brief       后向差分法一阶低通滤波器计算函数\n * @param       filter : 滤波器结构体指针\n * @param       input : 当前输入值\n * @retval      滤波后的输出值\n */\nfloat lpf_backward_euler_update(LPF_BackwardEuler *filter, float input)\n{\n\tfloat output;\n\t\n\tif (filter == NULL)\n\t{\n\t\treturn input; \n\t}\n\t\n\t/* 核心公式：y[n] = alpha * x[n] + (1 - alpha) * y[n-1] */\n\toutput = filter-&gt;alpha * input + filter-&gt;one_minus_alpha * filter-&gt;last_output;\n\t\n\tfilter-&gt;last_output = output;\n\t\n\treturn output;\n}\n\n/**\n * @brief       重置后向差分法一阶低通滤波器状态\n * @param       filter : 滤波器结构体指针\n * @param       init_val : 重置后的初始输出值\n * @retval      0:成功, -1:参数错误\n */\nint lpf_backward_euler_reset(LPF_BackwardEuler *filter, float init_val)\n{\n\tif (filter == NULL)\n\t{\n\t\treturn -1;\n\t}\n\t\n\tfilter-&gt;last_output = init_val;\n\treturn 0;\n}\n\n</code></pre>\n<h4 id=\"2前向差分法forward-difference\">2、前向差分法（Forward Difference）</h4>\n<p>公式简单，但属于<strong>显式欧拉法</strong>，只有在特定情况下才稳定。由于对采样频率和截止频率的比例敏感，容易出现发散。除非有特殊的极低频需求或对代码极其简化，否则一般不推荐。</p>\n<pre><code class=\"language-c\">/**\n * @brief       前向差分法一阶低通滤波器结构体\n */\ntypedef struct\n{\n\tfloat alpha;           /* 滤波系数 (omega * Ts) */\n\tfloat one_minus_alpha; /* 预计算的 (1 - alpha) */\n\tfloat last_input;      /* 上一次滤波输入值 x[n-1] */\n\tfloat last_output;     /* 上一次滤波输出值 y[n-1] */\n\tfloat cutoff_freq;     /* 截止频率 */\n\tfloat sample_freq;     /* 采样频率 */\n} LPF_ForwardDifference;\n\n/**\n * @brief       前向差分法一阶低通滤波器初始化函数\n * @param       filter : 滤波器结构体指针\n * @param       cutoff_freq : 截止频率\n * @param       sample_freq : 采样频率\n * @retval      0:成功, -1:参数错误\n */\nint lpf_forward_difference_init(LPF_ForwardDifference *filter, float cutoff_freq, float sample_freq)\n{\n\tif (filter == NULL || cutoff_freq &lt;= 0.0f || sample_freq &lt;= 0.0f)\n\t{\n\t\treturn -1;\n\t}\n\t\n\t/* \n\t* 前向差分法虽然有理论稳定极限 (PI * fc)，但在接近极限时误差极大。\n\t* 此处强制执行 10 倍规则，确保工程应用的可靠性。\n\t*/\n\tif (sample_freq &lt; 10.0f * cutoff_freq)\n\t{\n\t\treturn -1; \n\t}\n\t\n\t/* 计算过程系数 */\n\tfloat tau = 1.0f / (2.0f * PI * cutoff_freq);\n\tfloat ts = 1.0f / sample_freq;\n\tfilter-&gt;alpha = ts / tau;\n\tfilter-&gt;one_minus_alpha = 1.0f - filter-&gt;alpha;\n\t\n\t/* 初始化结构体成员 */\n\tfilter-&gt;cutoff_freq = cutoff_freq;\n\tfilter-&gt;sample_freq = sample_freq;\n\tfilter-&gt;last_input = 0.0f;\n\tfilter-&gt;last_output = 0.0f;\n\t\n\treturn 0;\n}\n\n/**\n * @brief       前向差分法一阶低通滤波器计算函数\n * @param       filter : 滤波器结构体指针\n * @param       input : 当前输入值\n * @retval      滤波后的输出值\n */\nfloat lpf_forward_difference_update(LPF_ForwardDifference *filter, float input)\n{\n\tfloat output;\n\t\n\tif (filter == NULL)\n\t{\n\t\treturn input; \n\t}\n\t\n\t/* y[n] = (1 - Ts/Tau)y[n-1] + (Ts/Tau)x[n-1] */\n\toutput = filter-&gt;one_minus_alpha * filter-&gt;last_output + filter-&gt;alpha * filter-&gt;last_input;\n\t\n\t/* 更新历史值：当前输入作为下一次的历史输入 */\n\tfilter-&gt;last_input = input;\n\tfilter-&gt;last_output = output;\n\t\n\treturn output;\n}\n\n/**\n * @brief       重置前向差分法一阶低通滤波器状态\n * @param       filter : 滤波器结构体指针\n * @param       init_val : 重置后的初始输出值\n * @retval      0:成功, -1:参数错误\n */\nint lpf_forward_difference_reset(LPF_ForwardDifference *filter, float init_val)\n{\n\tif (filter == NULL)\n\t{\n\t\treturn -1;\n\t}\n\t\n\tfilter-&gt;last_input = init_val;\n\tfilter-&gt;last_output = init_val;\n\t\n\treturn 0;\n}\n</code></pre>\n<h4 id=\"3双线性变换法tustin--bilinear\">3、双线性变换法（Tustin / Bilinear）</h4>\n<p>通过双线性变换将模拟域映射到数字域。它不仅能利用当前输入，还利用了历史输入和输出，其<strong>频率响应特性最接近</strong>理论模拟滤波器。适用于对幅频特性要求较高的音频处理、信号分析，或采样频率相对较低的精密控制场合。</p>\n<pre><code class=\"language-C\">/**\n * @brief       双线性变换法一阶低通滤波器结构体\n */\ntypedef struct\n{\n\tfloat b0;             /* 输入系数 b0 */\n\tfloat b1;             /* 输入系数 b1 */\n\tfloat a1;             /* 反馈系数 a1 */\n\tfloat last_input;     /* 上一次滤波输入值 x[n-1] */\n\tfloat last_output;    /* 上一次滤波输出值 y[n-1] */\n\tfloat cutoff_freq;    /* 截止频率 */\n\tfloat sample_freq;    /* 采样频率 */\n} LPF_BilinearTransform;\n\n/**\n * @brief       双线性变换法一阶低通滤波器初始化函数\n * @param       filter : 滤波器结构体指针\n * @param       cutoff_freq : 截止频率\n * @param       sample_freq : 采样频率\n * @retval      0:成功, -1:参数错误\n */\nint lpf_bilinear_transform_init(LPF_BilinearTransform *filter, float cutoff_freq, float sample_freq)\n{\n\tif (filter == NULL || cutoff_freq &lt;= 0.0f || sample_freq &lt;= 0.0f)\n\t{\n\t\treturn -1;\n\t}\n\t\n\t/* 奈奎斯特频率限制 */\n\tif (sample_freq &lt; 2.0f * cutoff_freq)\n\t{\n\t\treturn -1; \n\t}\n\t\n\tfloat wc = 2.0f * PI * cutoff_freq;\n\tfloat T = 1.0f / sample_freq;\n\t\n\t/* 频率预扭曲，目的是消除双线性变换在高频处的非线性频率畸变，确保截止频率准确 */\n\tfloat wc_twisted = (2.0f / T) * tanf((wc * T) / 2.0f);\n\t\n\t/* 计算双线性变换系数 */\n\tfloat K = (wc_twisted * T) / 2.0f;\n\tfloat denominator = 1.0f + K;\n\t\n\tfilter-&gt;b0 = K / denominator;\n\tfilter-&gt;b1 = filter-&gt;b0;  \n\tfilter-&gt;a1 = (K - 1.0f) / denominator;\n\t\n\t/* 初始化结构体成员 */\n\tfilter-&gt;cutoff_freq = cutoff_freq;\n\tfilter-&gt;sample_freq = sample_freq;\n\tfilter-&gt;last_input = 0.0f;\n\tfilter-&gt;last_output = 0.0f;\n\t\n\treturn 0;\n}\n\n/**\n * @brief       双线性变换法一阶低通滤波器计算函数\n * @param       filter : 滤波器结构体指针\n * @param       input : 当前输入值\n * @retval      滤波后的输出值\n */\nfloat lpf_bilinear_transform_update(LPF_BilinearTransform *filter, float input)\n{\n\tfloat output;\n\t\n\tif (filter == NULL)\n\t{\n\t\treturn input; \n\t}\n\t\n\t/* 核心公式：y[n] = b0*x[n] + b1*x[n-1] - a1*y[n-1] */\n\toutput = filter-&gt;b0 * input \n\t+ filter-&gt;b1 * filter-&gt;last_input \n\t- filter-&gt;a1 * filter-&gt;last_output;\n\t\n\t/* 更新历史状态 */\n\tfilter-&gt;last_input = input;\n\tfilter-&gt;last_output = output;\n\t\n\treturn output;\n}\n\n/**\n * @brief       重置双线性变换法一阶低通滤波器状态\n * @param       filter : 滤波器结构体指针\n * @param       init_val : 重置后的初始输出值\n * @retval      0:成功, -1:参数错误\n */\nint lpf_bilinear_transform_reset(LPF_BilinearTransform *filter, float init_val)\n{\n\tif (filter == NULL)\n\t{\n\t\treturn -1;\n\t}\n\t\n\tfilter-&gt;last_input = init_val;\n\tfilter-&gt;last_output = init_val;\n\t\n\treturn 0;\n}\n</code></pre>\n<h4 id=\"4工程选择速查表\">4、工程选择速查表</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">方法</th>\n<th style=\"text-align: left;\">稳定性</th>\n<th style=\"text-align: left;\">计算量</th>\n<th style=\"text-align: left;\">相位/延迟特性</th>\n<th style=\"text-align: left;\">核心特点</th>\n<th style=\"text-align: left;\">适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>后向差分法</strong></td>\n<td style=\"text-align: left;\"><strong>无条件稳定</strong></td>\n<td style=\"text-align: left;\"><strong>极低</strong> (1次乘法 + 1次乘加)</td>\n<td style=\"text-align: left;\">存在相位滞后 (隐式欧拉)</td>\n<td style=\"text-align: left;\">最常用，最稳健。系数计算简单，不涉及三角函数。</td>\n<td style=\"text-align: left;\"><strong>绝大多数场景</strong>。 电机控制、传感器去噪、PID滤波。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>双线性变换法</strong></td>\n<td style=\"text-align: left;\"><strong>无条件稳定</strong></td>\n<td style=\"text-align: left;\">中等 ( 3 次乘加)</td>\n<td style=\"text-align: left;\">频率响应最准 (需预扭曲)</td>\n<td style=\"text-align: left;\"><strong>精度最高</strong>。在截止频率处的幅值衰减最准确（-3dB），频率映射保真度最好。</td>\n<td style=\"text-align: left;\"><strong>高精度要求</strong>。 音频处理、精密仪器、精密测量、电源闭环控制。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>前向差分法</strong></td>\n<td style=\"text-align: left;\"><strong>有条件稳定</strong> (需 fs &gt; π·fc)</td>\n<td style=\"text-align: left;\">极低</td>\n<td style=\"text-align: left;\"><strong>延迟最大</strong> (显式，多拍滞后)</td>\n<td style=\"text-align: left;\">算法简单，但天然引入 1 个采样周期的纯延迟，且易发散。</td>\n<td style=\"text-align: left;\">极少推荐。 仅在处理极低频信号且计算资源极其受限时考虑。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"四总结\">四、总结</h3>\n<p>一阶低通滤波器是嵌入式信号处理中最基础、最常用的工具。正确使用它的关键，在于理解<strong>信号频率、噪声频率、采样频率与截止频率</strong>之间的制约关系。在实际开发中，建议优先采用<strong>后向差分法</strong>进行实现，根据实际的采样频率和信号带宽，灵活调整截止频率，以达到去噪与响应速度的最佳平衡。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-27 00:10</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lsksp\">比特向阳</a>&nbsp;\n阅读(<span id=\"post_view_count\">26</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一款由字节跳动推出的 AI 提示词生成和优化工具，为你提供更精准，专业，可持续迭代提示词！",
      "link": "https://www.cnblogs.com/Can-daydayup/p/19406862",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Can-daydayup/p/19406862\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 23:11\">\n    <span>一款由字节跳动推出的 AI 提示词生成和优化工具，为你提供更精准，专业，可持续迭代提示词！</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2><span>前言</span></h2>\n<p><span>在AI技术迅猛发展的当下，高效且精准的提示词成为与AI模型有效交互的关键。今天大姚给大家分享一款由字节跳动推出的 AI 提示词生成和优化工具，为你提供更精准，专业，可持续迭代提示词！</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226230859325-1349637768.png\" /></p>\n<h2><span>工具介绍</span></h2>\n<p><span>PromptPilot 是由字节跳动推出的一款专注于 AI 提示词优化与提示词生成的实用工具。该工具旨在帮助用户更高效地生成和优化 AI 提示词，提升与 AI 模型的交互效率和质量。通过 PromptPilot，用户可以轻松地创建、调试和管理提示词，以满足多样化的应用场景需求。</span></p>\n<ul class=\"list-paddingleft-1\">\n<li><strong><span>在线访问地址：<span class=\"wx_text_underline\">https://promptpilot.volcengine.com</span></span></strong></li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226230911909-2106687661.png\" /></p>\n<h2><span>应用场景</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>内容创作</strong><span>：在自媒体、广告、营销等领域，PromptPilot 可帮助创作者快速生成吸引人的文案提示词，提升内容质量和吸引力。</span></li>\n<li><strong>数据分析</strong><span>：在数据分析场景中，PromptPilot 可辅助分析师生成精准的查询提示词，提高数据检索和分析效率。</span></li>\n<li><strong>客户服务</strong><span>：在客户服务领域，PromptPilot 可用于生成自动化回复的提示词，提升客户响应速度和满意度。</span></li>\n<li><strong>教育行业</strong><span>：教师和学生可利用 PromptPilot 生成教学和学习相关的提示词，促进知识的有效传递和学习效果的提升。</span></li>\n</ul>\n<h2><span>提示词生成</span></h2>\n<h3><span>任务描述：</span></h3>\n<pre><span><code><span>给我写一个企业优秀员工获奖感言。<br /></span></code></span></pre>\n<h3><span>生成后的 Prompt：</span></h3>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226230930602-605100114.png\" /></p>\n<p>&nbsp;</p>\n<pre><span><code># 获奖感言创作指南<br /><br />## 一、身份设定<br /><span>你是企业行政部门的资深文案专员，负责为获奖员工撰写符合公司文化的正式获奖感言。核心职责是：结合员工岗位特性与贡献亮点，打造情感真挚、逻辑清晰、贴合场景的发言内容，帮助员工在颁奖仪式上展现专业形象与团队精神。<br /><br />## 二、创作准则<br />### 必做事项<br /><span>1. 必须包含获奖员工姓名、所获奖项全称、公司名称<br /><span>2. 必须突出员工岗位核心职责与关键贡献数据<br /><span>3. 必须体现对公司、团队、家人的感谢层次<br /><span>4. 必须包含对未来工作的承诺与展望<br /><br />### 约束条件<br /><span>1. 禁止使用夸张不实的表述，所有贡献需基于提供的事实<br /><span>2. 禁止出现敏感词汇或不当表述<br /><span>3. 禁止遗漏指定的感谢对象<br /><span>4. 禁止超过规定字数限制<br /><br />## 三、变量说明<br /><span>&lt;员工姓名&gt;{{EMPLOYEE_NAME}}&lt;/员工姓名&gt; - 获奖员工的完整姓名<br /><span>&lt;奖项类型&gt;{{AWARD_TYPE}}&lt;/奖项类型&gt; - 具体获奖名称（如：年度优秀员工、季度创新之星）<br /><span>&lt;公司名称&gt;{{COMPANY_NAME}}&lt;/公司名称&gt; - 员工所在企业全称<br /><span>&lt;工作职责&gt;{{WORK_DUTIES}}&lt;/工作职责&gt; - 员工日常工作内容概述<br /><span>&lt;核心贡献&gt;{{KEY_CONTRIBUTIONS}}&lt;/核心贡献&gt; - 员工获奖的关键业绩或突出表现<br /><span>&lt;感谢对象&gt;{{THANKS_OBJECTS}}&lt;/感谢对象&gt; - 需要特别致谢的个人或团队<br /><br />## 四、创作流程<br />### 第一步：内容架构搭建<br /><span>1. 开场问候：礼貌性称呼在场人员<br /><span>2. 获奖致谢：表达获奖的荣幸与激动心情<br /><span>3. 工作回顾：简述岗位价值与核心贡献<br /><span>4. 感恩环节：分层次感谢公司、团队、家人<br /><span>5. 未来展望：承诺未来工作方向与目标<br /><br />### 第二步：细节填充<br /><span>1. 将 &lt;员工姓名&gt;{{EMPLOYEE_NAME}}&lt;/员工姓名&gt; 自然融入开场与落款<br /><span>2. 准确引用 &lt;奖项类型&gt;{{AWARD_TYPE}}&lt;/奖项类型&gt; 全称<br /><span>3. 结合 &lt;工作职责&gt;{{WORK_DUTIES}}&lt;/工作职责&gt; 说明岗位价值<br /><span>4. 用数据化语言呈现 &lt;核心贡献&gt;{{KEY_CONTRIBUTIONS}}&lt;/核心贡献&gt;<br /><span>5. 按重要性排序提及 &lt;感谢对象&gt;{{THANKS_OBJECTS}}&lt;/感谢对象&gt;<br /><br />### 第三步：风格润色<br /><span>1. 语言风格：正式中带有温度，避免过于口语化<br /><span>2. 情感表达：控制情绪尺度，保持专业得体<br /><span>3. 时间控制：按3分钟发言长度调整内容详略（约500-600字）<br /><br />## 五、输出规范<br />### 内容结构<br /><span>1. 标题：[奖项名称]获奖感言<br /><span>2. 称呼：尊敬的各位领导、亲爱的同事们：<br /><span>3. 正文：按创作流程顺序展开<br /><span>4. 落款：[员工姓名] [日期]<br /><br />### 格式要求<br /><span>1. 使用标准宋体四号字，1.5倍行距<br /><span>2. 关键贡献部分加粗显示<br /><span>3. 感谢对象单独分段<br /><span>4. 结尾部分需包含对公司未来的美好祝愿<br /><br />### 质量标准<br /><span>1. 符合公司文化价值观<br /><span>2. 突出个人贡献同时体现团队精神<br /><span>3. 避免空话套话，用具体事例支撑<br /><span>4. 语言流畅，逻辑清晰，情感真挚<br /><br />## 六、创作示例<br /><span>（此处省略示例内容，实际创作时需根据变量填充）<br /><br /><span>请严格按照以上要求，结合提供的变量信息，创作一篇完整的获奖感言。<br /><br /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>\n<h2><span>调试 Prompt</span></h2>\n<h3><span>文本理解</span></h3>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226230958750-1911894887.png\" /></p>\n<h3><span>视觉理解</span></h3>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226231016417-194421412.png\" /></p>\n<h3><span>多轮对话</span></h3>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226231026956-1766318256.png\" /></p>\n<h2><span>优化 Prompt</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226231045050-1953776592.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226231052086-1099494036.png\" /></p>\n</div>\n<div id=\"MySignature\">\n    <blockquote>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者名称：</span><a href=\"https://www.cnblogs.com/Can-daydayup/\" target=\"_blank\">追逐时光者</a></p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者简介：</span>一个热爱编程、善于分享、喜欢学习、探索、尝试新事物和新技术的全栈软件工程师。</p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\">\n本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。如果该篇文章对您有帮助的话，可以点一下右下角的<a href=\"\" style=\"color: red;\">【♥推荐♥】</a>，希望能够持续的为大家带来好的技术文章，文中可能存在描述不正确的地方，欢迎指正或补充，不胜感激。\n</p>\n</blockquote>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 23:11</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Can-daydayup\">追逐时光者</a>&nbsp;\n阅读(<span id=\"post_view_count\">60</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "go-zero rest 源码学习笔记",
      "link": "https://www.cnblogs.com/xingzheanan/p/19404672",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xingzheanan/p/19404672\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 22:19\">\n    <span>go-zero rest 源码学习笔记</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<hr />\n<h1 id=\"概述\">概述</h1>\n<p><code>go-zero</code> 基于 <code>net/http</code> 标准库实现了一套 <code>rest</code> web 框架。在使用 <code>goctl</code> 快速开发的同时，也需要了解 <code>go-zero</code> 内部做了什么。本文结合 <a href=\"https://zeromicro.github.io/go-zero.dev/docs/component/rest\" rel=\"noopener nofollow\" target=\"_blank\">go-zero rest</a>学习其中的源码，力图做到知其所以然。</p>\n<h1 id=\"源码\">源码</h1>\n<h2 id=\"流程图\">流程图</h2>\n<p><img alt=\"image\" class=\"lazyload\" height=\"650\" width=\"640\" /></p>\n<p>在阅读源码之前，先看下流程图有个印象。从流程图大致可以看出来：</p>\n<ul>\n<li>go-zero 会创建路由组，其中按顺序注册了几类 handler（中间件），最后在 business handler 处理业务逻辑。</li>\n</ul>\n<p>大致有个印象后开始源码走读。</p>\n<h2 id=\"源码走读\">源码走读</h2>\n<p>启动 api 服务：</p>\n<pre><code class=\"language-go\">func main() {  \n    ...\n    server := rest.MustNewServer(c.RestConf)  \n    defer server.Stop()  \n  \n    ctx := svc.NewServiceContext(c)  \n    handler.RegisterHandlers(server, ctx)  \n  \n    fmt.Printf(\"Starting server at %s:%d...\\n\", c.Host, c.Port)  \n    server.Start()  \n}\n</code></pre>\n<p>启动服务主要做了三件事：</p>\n<ul>\n<li>创建服务端 server</li>\n<li>注册 handler 到 server</li>\n<li>启动服务端 server</li>\n</ul>\n<p>按顺序介绍。</p>\n<h3 id=\"创建服务端-server\">创建服务端 server</h3>\n<pre><code class=\"language-go\">func MustNewServer(c RestConf, opts ...RunOption) *Server {  \n    // NewServer 创建 server\n    server, err := NewServer(c, opts...)  \n    if err != nil {  \n       logx.Must(err)  \n    }  \n  \n    return server  \n}\n\nfunc NewServer(c RestConf, opts ...RunOption) (*Server, error) {\n\t// c.SetUp 启动 Prometheus，tracing, profiling 等服务\n    if err := c.SetUp(); err != nil {  \n       return nil, err  \n    }  \n  \n    server := &amp;Server{  \n       ngin:   newEngine(c),  \n       router: router.NewRouter(),  \n    }  \n  \n    ...\n    return server, nil  \n}\n</code></pre>\n<p>创建 server 实际创建的是 server 的 engine 和 router。</p>\n<p>engine 主要结构如下：</p>\n<pre><code class=\"language-go\">type engine struct {  \n    // server 的配置\n    conf   RestConf  \n    routes []featuredRoutes  // 业务路由\n    // 调用链\n    chain                chain.Chain \n    // 中间件 \n    middlewares          []Middleware  \n    ...\n}\n\nfunc newEngine(c RestConf) *engine {  \n    svr := &amp;engine{  \n       conf:    c,  \n       timeout: time.Duration(c.Timeout) * time.Millisecond,  \n    }\n    ...\n}\n</code></pre>\n<p>router 结构如下：</p>\n<pre><code class=\"language-go\">func NewRouter() httpx.Router {  \n    return &amp;patRouter{  \n       trees: make(map[string]*search.Tree),  \n    }  \n}\n\ntype Router interface {  \n    http.Handler  \n    Handle(method, path string, handler http.Handler) error  \n    SetNotFoundHandler(handler http.Handler)  \n    SetNotAllowedHandler(handler http.Handler)  \n}\n</code></pre>\n<p><code>patRouter</code> 包含路由信息，其实现了 <code>Router</code> 接口。</p>\n<p>创建了 server 后还需要注册路由 handler 到 server，这样服务端才能根据路由找到对应的 handler 处理。</p>\n<h3 id=\"注册路由-handler\">注册路由 handler</h3>\n<pre><code class=\"language-go\">func RegisterHandlers(server *rest.Server, serverCtx *svc.ServiceContext) {  \n    // server.AddRoutes 注册路由 handler\n    server.AddRoutes(  \n       []rest.Route{  \n          {  \n             Method:  http.MethodGet,  \n             Path:    \"/ping\",  \n             Handler: pingHandler(serverCtx),  \n          },  \n       },  \n    )\n}\n\nfunc (s *Server) AddRoutes(rs []Route, opts ...RouteOption) {  \n    // 自定义的业务路由将被封装到 featuredRoutes 对象\n    r := featuredRoutes{  \n       routes: rs,  \n    }  \n    for _, opt := range opts {  \n       opt(&amp;r)  \n    }  \n    \n    // 将 featuredRoutes 添加到 Server.engine\n    s.ngin.addRoutes(r)  \n}\n\nfunc (ng *engine) addRoutes(r featuredRoutes) {  \n    ...\n    // 实际是将路由组添加到 engine.routes 中  \n    ng.routes = append(ng.routes, r) \n}\n</code></pre>\n<p>业务路由注册完，接下来将进入启动 server，这是需要关注的重点。</p>\n<h3 id=\"启动-server\">启动 server</h3>\n<pre><code class=\"language-go\">func (s *Server) Start() {  \n    // 调用 Server.engine.start 启动服务端 server\n    handleError(s.ngin.start(s.router))  \n}\n\nfunc (ng *engine) start(router httpx.Router, opts ...StartOption) error {     // engine.bindRoutes 绑定路由到 router\n    if err := ng.bindRoutes(router); err != nil {  \n       return err  \n    }  \n\n    ...\n    return internal.StartHttps(ng.conf.Host, ng.conf.Port, ng.conf.CertFile,  \n       ng.conf.KeyFile, router, opts...)  \n}\n\nfunc (ng *engine) bindRoutes(router httpx.Router) error {  \n    // engine.routes \n    for _, fr := range ng.routes {  \n       // 绑定 rest.featuredRoutes \n       if err := ng.bindFeaturedRoutes(router, fr, metrics); err != nil { \n          return err  \n       }  \n    }  \n  \n    return nil  \n}\n\nfunc (ng *engine) bindFeaturedRoutes(router httpx.Router, fr featuredRoutes, metrics *stat.Metrics) error {  \n    ...\n    for _, route := range fr.routes {  \n       if err := ng.bindRoute(fr, router, metrics, route, verifier); err != nil {  \n          return err  \n       }  \n    }  \n  \n    return nil  \n}\n\nfunc (ng *engine) bindRoute(fr featuredRoutes, router httpx.Router, metrics *stat.Metrics,  \n    route Route, verifier func(chain.Chain) chain.Chain) error {  \n    // engine.chain，初始化为 nil\n    chn := ng.chain  \n    if chn == nil {  \n       // engine.buildChainWithNativeMiddlewares 注册自带中间件到 engine.chain\n       chn = ng.buildChainWithNativeMiddlewares(fr, route, metrics)  \n    }  \n  \n    // 添加 AuthHandler 到 engine.chain 中\n    chn = ng.appendAuthHandler(fr, chn, verifier)  \n  \n    // 将自定义中间件注册到 engine.chain\n    for _, middleware := range ng.middlewares {  \n       chn = chn.Append(convertMiddleware(middleware))  \n    }  \n    \n    // engine.chain.ThenFunc 将 handler 串联成 handler\n    handle := chn.ThenFunc(route.Handler)  \n  \n    return router.Handle(route.Method, route.Path, handle)  \n}\n</code></pre>\n<p>启动 server 的重点在 <code>engine.bindRoute</code>。<br />\n其中，<code>engine.buildChainWithNativeMiddlewares</code> 注册 <code>go-zero</code> 自带中间件：</p>\n<pre><code class=\"language-go\">func (ng *engine) buildChainWithNativeMiddlewares(fr featuredRoutes, route Route,  \n    metrics *stat.Metrics) chain.Chain {  \n    chn := chain.New()\n    ...\n    // MaxConns 用于并发控制\n    if ng.conf.Middlewares.MaxConns {  \n        chn = chn.Append(handler.MaxConnsHandler(ng.conf.MaxConns))  \n    }  \n    if ng.conf.Middlewares.Breaker {  \n        chn = chn.Append(handler.BreakerHandler(route.Method, route.Path, metrics))  \n    }\n    ...\n}\n</code></pre>\n<p>类似的，自定义中间件通过 <code>chn.Append(convertMiddleware(middleware))</code> 注册到 <code>engine.chain</code> 中。</p>\n<p>接着调用 <code>chain.ThenFunc</code> 串联中间件成 <code>handler</code>：</p>\n<pre><code class=\"language-go\">func (c chain) ThenFunc(fn http.HandlerFunc) http.Handler {  \n    ...\n    return c.Then(fn)  \n}\n\nfunc (c chain) Then(h http.Handler) http.Handler {  \n    if h == nil {  \n       h = http.DefaultServeMux  \n    }  \n  \n    // 这段代码很有意思，它将所有中间件按顺序串联起来组成一个 handler\n    // 调用这个 handler 处理时会经过后续一系列的中间件，最终到业务 handler 处理\n    // 具体可参考 https://github.com/zeromicro/go-zero/blob/master/rest/chain/chain.go#L81\n    for i := range c.middlewares {  \n       h = c.middlewares[len(c.middlewares)-1-i](h)  \n    }  \n  \n    return h  \n}\n</code></pre>\n<p>最后将该 handler 和路由信息注册到 <code>router</code> 中，后续服务端根据请求在 <code>router</code> 中查找对应的 <code>handler</code> 处理。</p>\n<pre><code class=\"language-go\">func (pr *patRouter) Handle(method, reqPath string, handler http.Handler) error {  \n    ...\n    \n    tree, ok := pr.trees[method]  \n    if ok {  \n       return tree.Add(cleanPath, handler)  \n    }  \n  \n    tree = search.NewTree()  \n    pr.trees[method] = tree  \n    return tree.Add(cleanPath, handler)  \n}\n</code></pre>\n<p>详细流程如下图：</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"570\" width=\"661\" /></p>\n<h1 id=\"小结\">小结</h1>\n<p>本文介绍了 go-zero rest 的源码是怎么处理请求的。从源码也可以看出每个请求背后是一系列中间件 handler 在处理，并且 server 启动了 Prometheus，Trace 等服务负责监控，链路追踪等，使得开发微服务时只需要关注业务逻辑即可，非常方便。</p>\n<h1 id=\"参考资料\">参考资料</h1>\n<ul>\n<li><a href=\"https://zeromicro.github.io/go-zero.dev/docs/component/rest\" rel=\"noopener nofollow\" target=\"_blank\">go-zero rest</a></li>\n<li><a href=\"https://refactoringguru.cn/design-patterns/chain-of-responsibility/go/example\" rel=\"noopener nofollow\" target=\"_blank\">Go 责任链模式</a></li>\n</ul>\n<hr />\n\n</div>\n<div id=\"MySignature\">\n    芝兰生于空谷，不以无人而不芳。\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 22:19</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xingzheanan\">胡云Troy</a>&nbsp;\n阅读(<span id=\"post_view_count\">27</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "分库分表数据源ShardingSphereDataSource的Connection元数据误用问题分析",
      "link": "https://www.cnblogs.com/wuyuegb2312/p/19405814",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wuyuegb2312/p/19405814\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 22:00\">\n    <span>分库分表数据源ShardingSphereDataSource的Connection元数据误用问题分析</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"背景\">背景</h1>\n<p>对于分库分表应用来说，使用org.apache.shardingsphere.driver.jdbc.core.datasource.ShardingSphereDataSource是一个不错的解决方案，你可以通过配置文件编写分库分表规则，从而在编码时透明地使用分表（当然，路由规则的相关字段还是要传的，之前也有文章分析过这些字段的处理过程：<a href=\"https://www.cnblogs.com/wuyuegb2312/p/18685884\" target=\"_blank\">深入理解Mybatis分库分表执行原理</a>）。</p>\n<p>但是，在一些场景中是需要绕过mybatis直接做一些操作的，特别是和数据库元数据相关的操作（包括表的结构变更）。</p>\n<p>比如我遇到的场景：先查询各个分库中有哪些前缀为<code>table_</code>的表，并给这些表加一列<code>col_x</code>。</p>\n<p>我结合现有代码和大语言模型，先写了一版，线下运行良好，但是线上的某些分库死活找不到对应的分表，没法进行后续的处理。这个问题查了很久，昨天终于解决了，因此分享出来。</p>\n<h1 id=\"存在问题的代码\">存在问题的代码</h1>\n<pre><code class=\"language-Java\">@Componet\npublic class TableAlterHandler {\n    @Resource private ShardingSphereDataSource dataSource;\n    \n    public List&lt;String&gt; findTablesByPrefix(String prefix, String physicalSchemaName) {\n        if (StringUtils.isBlank(prefix) || StringUtils.isBlank(physicalSchemaName)) {\n            throw new RuntimeException(\"分表前缀或分库名为空\");\n        }\n        List&lt;String&gt; tableNames = Lists.newArrayList();\n        try (HintManager hintManager = HintManager.getInstance();\n             Connection conn = dataSource.getConnection()) {\n             hintManager.setDataSourceName(DBUtil.queryLogicalSchemaName(physicalSchemaName));\n            DatabaseMetaData metaData = conn.getMetaData();\n            try (ResultSet rs = metaData.getTables(physicalSchemaName, null, prefix + \"%\", new String[] {\"TABLE\"})) {\n                while (rs.next()) {\n                    String tableName = rs.getString(\"TABLE_NAME\");\n                    tableNames.add(tableName);\n                }\n            }\n        } catch (SQLException e) {\n            throw new RuntimeException(\"处理大结果集失败\", e);\n        }\n        return tableNames;\n    }\n}\n</code></pre>\n<h2 id=\"逻辑库和物理库\">逻辑库和物理库</h2>\n<p>在分析问题之前，首先要明确两个概念：物理库名physicalSchemaName和逻辑库名logicalSchemaName，如果用错了，可能会让你没办法发现后续问题的本质原因。上面的代码，hintManager必须用逻辑库名，而metaData.getTables必须用物理库名。</p>\n<p>所谓物理库和逻辑库，可以看作是我定义的概念。正如其名，物理库名就是你jdbcUrl里的库名，比如一个典型的阿里云Mysql的JDBC链接<code>jdbc:mysql://``rm-bpxxxx.mysql.rds.aliyuncs.com/bizcenter_1?useSSL=false&amp;autoReconnect=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai</code></p>\n<p>其中的bizcenter_1就是物理库名。这个名称也会在MySql元数据中出现，比如</p>\n<pre><code class=\"language-SQL\">select * from information_schema.tables;\n</code></pre>\n<p>可以看到这个库的所有表，而TABLE_SCHEMA列就是物理库名。</p>\n<p>而逻辑库，则是ShardingSphereDataSource对物理库的映射，在application的配置文件(properties或yml)里，spring.shardingsphere.datasource配置下，你需要配置逻辑库名以及对应的JDBC链接。</p>\n<p>你可以将多个逻辑库配置为同一个物理库，这是一种实践方式，可以用于后续的扩容。</p>\n<h1 id=\"问题现象\">问题现象</h1>\n<p>线下的三个逻辑库分别对应一个物理库，而这三个物理库在同一个阿里云RDS实例上，可以找到每个库对应的表。</p>\n<p>而线上的仍然是三个逻辑库对应各自的物理库，每个物理库在不同的阿里云RDS实例上，会出现有时候能找到某个库对应的表，而另外两个库一个表都找不到的情况。</p>\n<h1 id=\"排查\">排查</h1>\n<p>遇到问题后，百思不得其解，因为线下环境一切正常，线上却总能复现问题。由于线上环境管控比较严，既不能远程debug，又不能直连线上库，很难定位原因。</p>\n<p>第一阶段排查，我反复确认了上面代码中需要传数据库名的地方到底是逻辑库还是物理库。中间某个版本的确搞错了，但是为何在写错的前提下还能运行，没有做记录。</p>\n<p>然后，我删掉了<code>connection.setAutoCommit(false)</code>、<code>resultSet.setFetchSize(batchSize)</code>这样的用于降低每次查询元数据结果数量的代码，也没效果。</p>\n<p>最后，我把代码移到了另一个连接同样数据库的应用中，因为那个应用有我之前类似的代码。移过去以后倒是歪打正着地解决了。</p>\n<p>第二阶段的排查，是在一段时间后，我在原先的应用中开发新的功能，对原先代码进行改动，自以为修复好了，但是上线后发现还是和之前一样。</p>\n<h1 id=\"分析\">分析</h1>\n<p>线下线上最大的区别就是线下几个库是同一个MySql实例，而线上分属三个。我的代码里，疑点最大的是查询元数据<code>metaData.getTables()</code>这段。</p>\n<p>好巧不巧，在我排查的第一阶段和第二阶段中间，我写了一个迁移表的功能，完全新写了查询表名的代码，并且为了不再犯物理库和逻辑库搞混的错误，特别地写了对应的工具类：</p>\n<pre><code class=\"language-Java\">/**\n * 数据源持有组件，便于应用直接访问数据源\n *\n */\n@Component\npublic class DataSourceHolder {\n\n  @Resource protected ShardingSphereDataSource dataSource;\n\n  /** 物理库名(jdbc链接里的库名)和数据源的关系 */\n  private Map&lt;String, HikariDataSource&gt; hikariDataSourceMap;\n\n  /** 逻辑库名-物理库名关系 多个逻辑库可能对应同一个物理库 */\n  private Map&lt;String, String&gt; dsNameMap;\n\n  /**\n   * 通过物理库名获取ds\n   *\n   * @param physicalSchemaName\n   * @return\n   */\n  public HikariDataSource getDataSourceByPhysicalSchemaName(String physicalSchemaName) {\n    return hikariDataSourceMap.get(physicalSchemaName);\n  }\n\n  /**\n   * 通过逻辑库名获取对应物理库名\n   *\n   * @param dsName\n   * @return\n   */\n  public String getPhysicalSchemaName(String dsName) {\n    return dsNameMap.get(dsName);\n  }\n\n  /**\n   * 通过逻辑库名获取ds\n   *\n   * @param logicalSchemaName\n   * @return\n   */\n  public HikariDataSource getDataSourceByLogicalSchemaName(String logicalSchemaName) {\n    String physicalSchemaName = getPhysicalSchemaName(logicalSchemaName);\n    if (StringUtils.isBlank(physicalSchemaName)) {\n      throw new RuntimeException(\"逻辑库名找不到对应物理库, logicalSchemaName=\" + logicalSchemaName);\n    }\n    return hikariDataSourceMap.get(physicalSchemaName);\n  }\n\n  @PostConstruct\n  public void initHikariDataSourceMap() {\n    dsNameMap = Maps.newHashMap();\n    hikariDataSourceMap = Maps.newHashMap();\n    Map&lt;String, DataSource&gt; dataSourceMap =\n        dataSource.getContextManager().getDataSourceMap(dataSource.getSchemaName());\n    dataSourceMap.forEach(\n        (dsName, ds) -&gt; {\n          HikariDataSource hds = (HikariDataSource) ds;\n          try (Connection connection = hds.getConnection(); ) {\n            hikariDataSourceMap.put(connection.getCatalog(), hds);\n            dsNameMap.put(dsName, connection.getCatalog());\n          } catch (SQLException e) {\n            throw new RuntimeException(\"组装数据源map失败\", e);\n          }\n        });\n  }\n}\n</code></pre>\n<p>对应地，获取数据库Connection的方法是：</p>\n<pre><code class=\"language-Java\">HikariDataSource hikariDataSource = dataSourceHolder.getDataSourceByPhysicalSchemaName(dsName);\nConnection connection = hikariDataSource.getConnection();\n</code></pre>\n<p>并且也不再使用HintManager指定逻辑库。</p>\n<p>联想到线上线下MySql实例的差异，我猜测是因为：</p>\n<p>线下三个库是同一个MySql实例，那么元数据information_schema.tables是一样的，在哪个库都能查到对应表。</p>\n<p>线上则是不同的实例，直接使用ShardingSphereDataSource对应Connection的元数据，并不总是预期的库。</p>\n<p>这个猜测原因，也在之前第一阶段的排查吻合，能正常工作的代码所在应用，获取数据源的方式实际是</p>\n<pre><code class=\"language-Java\">Map&lt;String, DataSource&gt; allDataSource =\n    shardingSphereDataSource.getContextManager().getDataSourceMap(\"logic_db\");\nConnection connection = allDataSouce.get(logicalSchemaName).getConnection();\n</code></pre>\n<p>虽然它也用了HintManger，但我认为是没有意义的。</p>\n<h1 id=\"修复\">修复</h1>\n<p>综合以上的分析，最终的修复代码如下</p>\n<pre><code class=\"language-Java\">    List&lt;String&gt; tableNames = Lists.newArrayList();\n    try (Connection conn =\n        dataSourceHolder.getDataSourceByPhysicalSchemaName(physicalSchemaName).getConnection()) {\n      DatabaseMetaData metaData = conn.getMetaData();\n      try (ResultSet rs =\n          metaData.getTables(physicalSchemaName, null, prefix + \"%\", new String[] {\"TABLE\"})) {\n        while (rs.next()) {\n          String tableName = rs.getString(\"TABLE_NAME\");\n          tableNames.add(tableName);\n        }\n      }\n    } catch (SQLException e) {\n      throw new RuntimeException(\"处理大结果集失败\", e);\n    }\n    return tableNames;\n</code></pre>\n<p>这次再部署到生产环境，运行符合预期。</p>\n<p>可见，当你需要实际分库对应的元数据时，不要用shardingSphereDataSource，而是应该用它关联具体分库的dataSource，也即shardingSphereDataSource.getContextManager().getDataSourceMap()，再用这个分库dataSource获取元数据。</p>\n<p>否则，线下线上不同的MySql实例配置，会导致不同的现象，难以排查真正的原因。</p>\n\n</div>\n<div id=\"MySignature\">\n    <div id=\"AllanboltSignature\">\n        <p id=\"PSignature\">\n            <br />\n            作者：<a href=\"http://www.cnblogs.com/wuyuegb2312\" target=\"_blank\">五岳</a>\n            <br />\n            出处：<a href=\"http://www.cnblogs.com/wuyuegb2312\" target=\"_blank\">http://www.cnblogs.com/wuyuegb2312</a>\n            <br />\n            对于标题未标注为“转载”的文章均为原创，其版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。\n        </p>\n    　</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 22:00</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wuyuegb2312\">五岳</a>&nbsp;\n阅读(<span id=\"post_view_count\">30</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "搜索数据库表的性能优化过程",
      "link": "https://www.cnblogs.com/yadelei/p/19406737/the-performance-optimization-process-of-searching-database-tables",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yadelei/p/19406737/the-performance-optimization-process-of-searching-database-tables\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 21:54\">\n    <span>搜索数据库表的性能优化过程</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"问题背景\">问题背景</h2>\n<p>做一个数据库表查看、标注与分析的工具软件。</p>\n<p><span class=\"math inline\">\\(Table\\)</span>是数据库中表的信息（<code>information_schema.tables</code>）；<span class=\"math inline\">\\(Documentation\\)</span>是<span class=\"math inline\">\\(Table\\)</span>的数据字典文档，存储在本地文件中；<span class=\"math inline\">\\(Annotation\\)</span>是对<span class=\"math inline\">\\(Table\\)</span>的额外标注信息，存储在另一个数据库中。每一条<span class=\"math inline\">\\(Table\\)</span>，最多关联到一条<span class=\"math inline\">\\(Documentation\\)</span>和一条<span class=\"math inline\">\\(Annotation\\)</span>。</p>\n<p>现在想搜索<span class=\"math inline\">\\(Table\\)</span>。前端向后端提供3个参数，搜索关键词列表、当前页码、每页条数；后端的搜索逻辑是，如果一条完整数据（<span class=\"math inline\">\\(Table\\)</span>+<span class=\"math inline\">\\(Documentation\\)</span>+<span class=\"math inline\">\\(Annotation\\)</span>）包含所有搜索关键词，则将<span class=\"math inline\">\\(Table\\)</span>加入搜索结果中。</p>\n<p><span class=\"math inline\">\\(Table\\)</span>的数量目前为6000+，要做到秒级搜索。</p>\n<h2 id=\"初步实现\">初步实现</h2>\n<p>因为跨数据源，所以不能简单连表查询。</p>\n<p>对于每个<span class=\"math inline\">\\(Table\\)</span>，查出<span class=\"math inline\">\\(Documentation\\)</span>、<span class=\"math inline\">\\(Annotation\\)</span>，然后将<span class=\"math inline\">\\(Table\\)</span>、<span class=\"math inline\">\\(Documentation\\)</span>、<span class=\"math inline\">\\(Annotation\\)</span>中要搜索的字段值取出来，用空格隔开拼接为字符串，形如<code>\"Table字段值 Documentation字段值 Annotation字段值\"</code>，我们称之为<span class=\"math inline\">\\(SearchKey\\)</span>（搜索键）。如果每个关键词都包含在<span class=\"math inline\">\\(SearchKey\\)</span>中，则将<span class=\"math inline\">\\(Table\\)</span>加入搜索结果。</p>\n<p>搜索时，先获取所有<span class=\"math inline\">\\(Table\\)</span>，然后遍历每个<span class=\"math inline\">\\(Table\\)</span>，获取<span class=\"math inline\">\\(SearchKey\\)</span>并判断是否加入搜索结果。</p>\n<p>为了提高速度，用Redis缓存<span class=\"math inline\">\\(Table\\)</span>对应的<span class=\"math inline\">\\(SearchKey\\)</span>。</p>\n<p>分析数据情况：</p>\n<ul>\n<li><span class=\"math inline\">\\(Table\\)</span>只增、不删、不改，因此，搜索时要重新获取所有<span class=\"math inline\">\\(Table\\)</span>，确保搜索到新<span class=\"math inline\">\\(Table\\)</span>；不必考虑驱逐（evict）<span class=\"math inline\">\\(SearchKey\\)</span>的缓存。</li>\n<li><span class=\"math inline\">\\(Documentation\\)</span>不增、不删、不改，因此，不必考虑驱逐<span class=\"math inline\">\\(SearchKey\\)</span>的缓存。</li>\n<li><span class=\"math inline\">\\(Annotation\\)</span>增、删、改，因此，要在<span class=\"math inline\">\\(Annotation\\)</span>增删改之后驱逐对应<span class=\"math inline\">\\(SearchKey\\)</span>的缓存，确保搜索到<span class=\"math inline\">\\(Annotation\\)</span>的最新信息。</li>\n</ul>\n<p>实测结果：</p>\n<ul>\n<li>实现了功能，支持同时按<span class=\"math inline\">\\(Table\\)</span>、<span class=\"math inline\">\\(Documentation\\)</span>、<span class=\"math inline\">\\(Annotation\\)</span>的字段搜索。</li>\n<li>有性能问题，即使缓存已经全部完成，但每次搜索都要耗时30s左右，原因是6000+个<span class=\"math inline\">\\(Table\\)</span>遍历从Redis获取<span class=\"math inline\">\\(SearchKey\\)</span>，每次耗时1~15ms，累计耗时非常长。</li>\n</ul>\n<h2 id=\"第一次性能优化\">第一次性能优化</h2>\n<p>优化缓存策略。</p>\n<p>获取所有<span class=\"math inline\">\\(Table\\)</span>后，构建<span class=\"math inline\">\\(SearchKeyMap\\)</span>（<span class=\"math inline\">\\(Table\\)</span>→<span class=\"math inline\">\\(SearchKey\\)</span>），然后将<span class=\"math inline\">\\(SearchKeyMap\\)</span>缓存，这样，下一次搜索时，只需要从Redis获取一次，提高传输效率。</p>\n<p>为了确保搜索到新<span class=\"math inline\">\\(Table\\)</span>，缓存<span class=\"math inline\">\\(SearchKeyMap\\)</span>时将<span class=\"math inline\">\\(Table\\)</span>列表的长度作为缓存键，如果新增了<span class=\"math inline\">\\(Table\\)</span>，则<span class=\"math inline\">\\(SearchKeyMap\\)</span>不会命中缓存，而是重新构建。</p>\n<p>为了减少构建<span class=\"math inline\">\\(SearchKeyMap\\)</span>的时间，仍然保留单个<span class=\"math inline\">\\(SearchKey\\)</span>的缓存，仍然在<span class=\"math inline\">\\(Annotation\\)</span>增删改之后驱逐单个<span class=\"math inline\">\\(SearchKey\\)</span>的缓存，但不同的是，还要同时驱逐<span class=\"math inline\">\\(SearchKeyMap\\)</span>的缓存。</p>\n<p>实测结果：</p>\n<ul>\n<li>性能提升明显，在缓存全部完成的情况下，搜索耗时降至1.3s左右。</li>\n<li>仍然有性能问题，对一个<span class=\"math inline\">\\(Annotation\\)</span>做了增删改，会驱逐整个<span class=\"math inline\">\\(SearchKeyMap\\)</span>缓存，重建<span class=\"math inline\">\\(SearchKeyMap\\)</span>就又回到了遍历<span class=\"math inline\">\\(Table\\)</span>的情况，仍然要耗时30s左右。</li>\n</ul>\n<h2 id=\"第二次性能优化\">第二次性能优化</h2>\n<p>优化缓存策略。</p>\n<p>取消单个<span class=\"math inline\">\\(SearchKey\\)</span>的缓存，只缓存<span class=\"math inline\">\\(SearchKeyMap\\)</span>。</p>\n<p>搜索<span class=\"math inline\">\\(Table\\)</span>时，要获取<span class=\"math inline\">\\(SearchKeyMap\\)</span>。先获取现有的<span class=\"math inline\">\\(SearchKeyMap\\)</span>缓存（固定缓存键，不再使用列表长度作为缓存键；没有缓存则取得空Map），然后遍历<span class=\"math inline\">\\(Table\\)</span>，如果<span class=\"math inline\">\\(Table\\)</span>不在<span class=\"math inline\">\\(SearchKeyMap\\)</span>中，则计算<span class=\"math inline\">\\(SearchKey\\)</span>并放入<span class=\"math inline\">\\(SearchKeyMap\\)</span>。这样，第一次搜索时会计算每个<span class=\"math inline\">\\(Table\\)</span>的<span class=\"math inline\">\\(SearchKey\\)</span>，后续搜索就只需要计算新<span class=\"math inline\">\\(Table\\)</span>的<span class=\"math inline\">\\(SearchKey\\)</span>。</p>\n<p><span class=\"math inline\">\\(Annotation\\)</span>增删改后，要更新<span class=\"math inline\">\\(SearchKeyMap\\)</span>。先获取现有的<span class=\"math inline\">\\(SearchKeyMap\\)</span>缓存，然后重新计算指定<span class=\"math inline\">\\(Table\\)</span>的<span class=\"math inline\">\\(SearchKey\\)</span>并放入<span class=\"math inline\">\\(SearchKeyMap\\)</span>。这样，无需每次都重建整个<span class=\"math inline\">\\(SearchKeyMap\\)</span>。</p>\n<p>实测结果：<span class=\"math inline\">\\(Annotation\\)</span>增删改后再搜索，耗时降至1.3s左右。</p>\n<h2 id=\"第三次性能优化\">第三次性能优化</h2>\n<p>优化缓存实现方式。</p>\n<p>既然现在只需要简单地缓存一个<span class=\"math inline\">\\(SearchKeyMap\\)</span>，那么不一定要用Redis。</p>\n<p>使用Redis作为缓存（<code>RedisCacheManager</code>），虽然内网通信快，但仍有网络开销。实测平均1092.9ms。</p>\n<p>使用Map作为缓存（<code>ConcurrentMapCacheManager</code>），其他代码完全不变。实测平均968.3ms。</p>\n<p>修改代码，直接用类中的<code>Map</code>字段作为缓存，省去缓存管理器的开销。实测平均915.2ms。</p>\n<p>可见，性能有提升，但幅度不大。由于软件在开发中，要频繁重新运行，Redis能保持缓存，Map不能，因此保持上一版方案不做修改。</p>\n<h2 id=\"第四次性能优化\">第四次性能优化</h2>\n<p>第三次优化其实是盲目的，应该要用事实找出性能瓶颈。</p>\n<p>对搜索过程计时分析发现，一次耗时1105ms的搜索，其中获取所有<span class=\"math inline\">\\(Table\\)</span>耗时1028ms，占比93%，是绝对的性能瓶颈。</p>\n<p>思路1：先只获取所有表名，而不是<span class=\"math inline\">\\(Table\\)</span>对象，如果表名对应的<span class=\"math inline\">\\(SearchKey\\)</span>匹配，再获取<span class=\"math inline\">\\(Table\\)</span>。实测发现，如果匹配的表名很多（例如关键词列表为空时），则即使有表名→<span class=\"math inline\">\\(Table\\)</span>的缓存（Redis实现），逐个获取也远远慢于直接从数据库一次性获取。因此，此思路<strong>不可行</strong>。</p>\n<p>思路2：<span class=\"math inline\">\\(Table\\)</span>只增、不删、不改，因此可以考虑增量获取。缓存<span class=\"math inline\">\\(Table\\)</span>列表，每次获取时跳过缓存的长度，只获取增量部分。然而，<code>information_schema.tables</code>中没有<code>id</code>，无法保证新<span class=\"math inline\">\\(Table\\)</span>一定排在最后。因此，此思路<strong>不可行</strong>。</p>\n<p>思路3：获取所有<span class=\"math inline\">\\(Table\\)</span>说到底只是为了搜索到新<span class=\"math inline\">\\(Table\\)</span>，如果能知道什么时候新增了<span class=\"math inline\">\\(Table\\)</span>，就可以放心地使用<span class=\"math inline\">\\(Table\\)</span>列表的缓存，或者从数据库重新获取。那么怎么知道？由于<span class=\"math inline\">\\(Table\\)</span>只增，所以可以用<span class=\"math inline\">\\(Table\\)</span>的数量判断。缓存<span class=\"math inline\">\\(Table\\)</span>列表，每次先从数据库查出数量（比直接查出<span class=\"math inline\">\\(Table\\)</span>列表明显更快），如果数量与缓存一致，则用缓存，否则查库。实测，此思路<strong>可行</strong>。</p>\n<p>实现思路3后，再次计时分析。无新增<span class=\"math inline\">\\(Table\\)</span>时，搜索耗时降至360ms左右（只查库数量）；有新增时，耗时升至1.5s左右（查库数量+列表）。由于搜索<span class=\"math inline\">\\(Table\\)</span>的频率远远高于新增<span class=\"math inline\">\\(Table\\)</span>，因此，总体性能提升显著。</p>\n<h2 id=\"总结\">总结</h2>\n<p>经过数次性能优化，在满足功能的前提下，搜索时间从30s左右降至稳定0.4s左右，效果显著。0.4s已经没有缓慢感，性能优化工作可以结束了。</p>\n<p>从上述优化过程可见，做优化要因地制宜，具体问题具体分析，选择合适的策略；优化效果的衡量要以实测结果为准。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 21:54</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yadelei\">亚德雷</a>&nbsp;\n阅读(<span id=\"post_view_count\">47</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "使用Gradio构建AI前端 - RAG召回测试",
      "link": "https://www.cnblogs.com/aspnetx/p/19406675",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aspnetx/p/19406675\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 21:27\">\n    <span>使用Gradio构建AI前端 - RAG召回测试</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        构建AI应用的前端方案有很多，这里介绍一个开源前端库---Gradio，通过它可以使用简短的代码就可以快速的实现简单的AI应用前端。这里我们选择的场景为做RAG召回测试，通过调用先前封装好的LangChain代码，来快速的搭建这个前端页面。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"使用gradio构建ai前端---rag召回测试\">使用Gradio构建AI前端 - RAG召回测试</h1>\n<h2 id=\"一摘要\">一、摘要</h2>\n<p>构建AI应用的前端方案有很多，这里介绍一个开源前端库---Gradio，通过它可以使用简短的代码就可以快速的实现简单的AI应用前端。这里我们选择的场景为做RAG召回测试，通过调用先前封装好的LangChain代码，来快速的搭建这个前端页面。</p>\n<h2 id=\"二ai项目前端方案的对比\">二、AI项目前端方案的对比</h2>\n<p>可以做AI的前端方案很多，这里主要介绍比较热门的三个方案：</p>\n<ul>\n<li>Gradio 是一款开源的 Python 库，核心定位是快速构建机器学习 / 深度学习模型的交互式 Web 演示界面，无需前端开发经验，一行代码即可将模型（或任意 Python 函数）转化为可通过浏览器访问的交互页面，方便开发者、研究者快速展示、测试和分享模型。</li>\n<li>Streamlit 是一款开源的 Python 库，主打快速构建数据科学 / 机器学习领域的交互式 Web 应用，无需前端开发经验，以 “脚本即应用” 为核心理念 —— 普通的 Python 脚本只需添加少量 Streamlit 语法，就能一键转化为可交互的 Web 应用，是数据分析师、算法工程师快速落地可视化 / 分析工具的首选。</li>\n<li>Vue（读音 /vjuː/，类似 view）是一款渐进式 JavaScript 框架，核心聚焦于前端视图层（UI）开发，由尤雨溪开发并开源，是目前最主流的前端框架之一（与 React、Angular 并称）。<br />\n相对三种方案，Gradio是直接被设计成AI的前端的，Streamlit适合做数据科学的前端。而Vue是一个更专业的前端框架。<br />\n这里我们介绍的就是Gradio。所以我们使用Gradio构建了一个RAG（检索增强生成）召回测试系统界面，主要功能是通过调用<code>LC_RAG_02_RecallTest.py</code>中的<code>recall</code>函数实现相似度检索，用户可以输入查询文本并设置返回结果数量，系统会展示检索到的最相似文档。</li>\n</ul>\n<h2 id=\"三环境介绍\">三、环境介绍</h2>\n<p>这里基于我另外一篇笔记：<br />\n<a href=\"https://www.cnblogs.com/aspnetx/p/19173914\" target=\"_blank\">https://www.cnblogs.com/aspnetx/p/19173914</a><br />\n在这个笔记中，介绍了如何使用python构建RAG系统，使用的是LangChain1.0的库。<br />\n整个项目可以在以下仓库中找到：<br />\n<a href=\"https://github.com/microsoftbi/Langchain_DEMO/tree/main/RAG\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/microsoftbi/Langchain_DEMO/tree/main/RAG</a><br />\n我会用到在其中的一个文件中封装好的做RAG召回测试的代码，来构建前端应用，借此展示Gradio环境中如何快速的搭建前端页面。<br />\n本文创建的代码文件名为：LC_RAG_07b_Gradio.py<br />\n调用先前召回测试的代码文件为：LC_RAG_02_RecallTest.py</p>\n<h2 id=\"四主要功能模块\">四、主要功能模块</h2>\n<h3 id=\"1-召回测试函数-run_recall_test\">1. 召回测试函数 <code>run_recall_test</code></h3>\n<ul>\n<li>功能：调用LC_RAG_02_RecallTest.py文件中封装好的<code>recall</code>函数执行检索并捕获输出结果。</li>\n</ul>\n<pre><code class=\"language-Python\">def run_recall_test(query, top_k):\n    \"\"\"运行召回测试并返回结果\"\"\"\n    try:\n        # 调用recall函数，但需要捕获其输出\n        import io\n        from contextlib import redirect_stdout\n        \n        # 创建一个字符串IO对象来捕获输出\n        f = io.StringIO()\n        with redirect_stdout(f):\n            recall(\n                query=query,\n                top_k=top_k,\n                vectorstore_dir=\"./RAG/chroma_db\",\n                embedding_model=\"text-embedding-v4\"\n            )\n        \n        # 获取捕获的输出\n        output = f.getvalue()\n        return output\n    except Exception as e:\n        return f\"错误: {str(e)}\"\n</code></pre>\n<ul>\n<li>实现要点：\n<ul>\n<li>使用<code>io.StringIO()</code>创建字符串缓冲区</li>\n<li>通过<code>redirect_stdout</code>上下文管理器捕获<code>recall</code>函数的打印输出</li>\n<li>调用<code>recall</code>函数时指定参数：查询文本、返回数量、向量存储目录和嵌入模型<br />\n因为在先前封装好的代码中并没有返回值，而是直接通过print来输出结果，所以这里需要调用相关的包来读取这些输出。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-gradio界面构建\">2. Gradio界面构建</h3>\n<p>首先需要确保Gradio的库已经被安装：</p>\n<pre><code>pip install gradio \n</code></pre>\n<p>然后在代码中引入这个库。</p>\n<pre><code>import gradio as gr \n</code></pre>\n<p>随后使用<code>gr.Blocks</code>创建结构化界面，在其下再通过gr.Row()以及gr.Column()，就可以往这个框架下分割出来不同的行和列来堆放需要的组件。<br />\n顺便说一下，Gradid有两种方式的布局，一个是interface, 通过绑定的函数自动生成界面，另一个就是Block，通过行列的方式自己组织界面。这里用到的就是Blocks方式。</p>\n<p>以下是几种常用的设置前端界面的方法：</p>\n<h4 id=\"1页面标题与说明\">（1）页面标题与说明</h4>\n<p>直接做markdown格式的输出：</p>\n<pre><code class=\"language-python\">gr.Markdown(\"# RAG召回测试系统\")\ngr.Markdown(\"使用Gradio构建的RAG召回测试界面，调用LC_RAG_02_RecallTest.py实现相似度检索\")\n</code></pre>\n<h4 id=\"2输入区域左侧\">（2）输入区域（左侧）</h4>\n<p>也就是在gr.Row()的第一个gr.Column()</p>\n<pre><code class=\"language-Python\">        with gr.Column(scale=1):\n            gr.Markdown(\"## 查询设置\")\n            \n            # 查询文本输入\n            query_input = gr.Textbox(\n                label=\"查询文本\",\n                placeholder=\"请输入您要检索的问题或关键词\",\n                lines=3,\n                info=\"例如: '什么是未成年?' 或 '哪些节假日应该安排休假?'\"\n            )\n            \n            # Top-K设置\n            top_k_slider = gr.Slider(\n                label=\"Top-K检索数量\",\n                minimum=1,\n                maximum=10,\n                value=5,\n                step=1,\n                info=\"设置返回的最相似文档数量\"\n            )\n            \n            # 提交按钮\n            submit_btn = gr.Button(\n                \"执行召回测试\",\n                variant=\"primary\",\n                size=\"lg\"\n            )\n            \n            # 重置按钮\n            clear_btn = gr.Button(\"重置\", variant=\"secondary\")\n</code></pre>\n<p>这段代码包括创建以下界面：</p>\n<ul>\n<li>查询文本输入框：<code>gr.Textbox</code>，支持多行输入</li>\n<li>Top-K设置滑块：<code>gr.Slider</code>，范围1-10，默认值5</li>\n<li>操作按钮：\"执行召回测试\"（主按钮）和\"重置\"（次要按钮）</li>\n</ul>\n<p>可以看到通过gr.对应的方法，就可以创建不同的组件。</p>\n<h4 id=\"3输出区域右侧\">（3）输出区域（右侧）</h4>\n<p>gr.Row()的第二个gr.Column()</p>\n<pre><code class=\"language-Python\">        # 右侧：输出区域\n        with gr.Column(scale=2):\n            gr.Markdown(\"## 召回结果\")\n            \n            # 结果输出\n            result_output = gr.Textbox(\n                label=\"相似度检索结果\",\n                lines=20,\n                interactive=False,\n                placeholder=\"召回结果将显示在这里...\"\n            )\n            \n            # 状态信息\n            status_info = gr.Markdown(\"状态: 就绪\")\n</code></pre>\n<ul>\n<li>结果输出框：<code>gr.Textbox</code>，展示检索结果</li>\n<li>状态信息：<code>gr.Markdown</code>，显示系统当前状态</li>\n</ul>\n<h3 id=\"3-按钮事件\">3. 按钮事件</h3>\n<p>这里主要是调用前面定义的方法：run_recall_test<br />\n然后下面封装了一个响应按钮的方法：</p>\n<pre><code class=\"language-Python\"># 按钮事件\ndef on_submit(query, top_k):\n    if not query:\n        return \"请输入查询文本\", \"状态: 错误 - 查询文本不能为空\"\n        \n    status_info.value = \"状态: 正在执行召回测试...\"\n    result = run_recall_test(query, top_k)\n    return result, \"状态: 测试完成\"\n</code></pre>\n<p>最后挂载按钮的click方法：</p>\n<pre><code># 绑定事件\nsubmit_btn.click(\n    fn=lambda query, top_k: on_submit(query, top_k),\n    inputs=[query_input, top_k_slider],\n    outputs=[result_output, status_info]\n</code></pre>\n<p>需要留意的是这里的事件响应的方法跟其它编程语言的会有些不同。</p>\n<h3 id=\"5-应用启动\">5. 应用启动</h3>\n<pre><code class=\"language-python\">demo.launch(\n    server_name=\"0.0.0.0\",  # 允许外部访问\n    server_port=7860,       # 端口号\n    share=False,            # 不生成公共链接\n    debug=False             # 非调试模式\n)\n</code></pre>\n<p>指定端口号和其它信息，直接运行这个代码就可以在浏览器里访问了。<br />\n以下是代码所构建的界面。</p>\n<p><img alt=\"img\" src=\"https://img2024.cnblogs.com/blog/8622/202512/8622-20251226211747483-484824576.png\" /></p>\n<p>可以看到相比用Vue来封装，代码量就少了很多，尤其是不需要创建，构建项目，以及为前端去专门写API。<br />\n所以对于快速的开发来说，Gradio是非常合适的。但是对于企业级的专业开发，还是建议选择Vue。<br />\n还有一种建议就是，通过Gradio来做快速的原型开发，然后用Vue来做生产开发。</p>\n<details>\n以下是代码的全部内容，点击展开。\n<pre><code class=\"language-Python\">import os\nimport gradio as gr\nfrom dotenv import load_dotenv\nfrom LC_RAG_02_RecallTest import recall\n\n# 加载环境变量\nload_dotenv()\n\ndef run_recall_test(query, top_k):\n    \"\"\"运行召回测试并返回结果\"\"\"\n    try:\n        # 调用recall函数，但需要捕获其输出\n        import io\n        from contextlib import redirect_stdout\n        \n        # 创建一个字符串IO对象来捕获输出\n        f = io.StringIO()\n        with redirect_stdout(f):\n            recall(\n                query=query,\n                top_k=top_k,\n                vectorstore_dir=\"./RAG/chroma_db\",\n                embedding_model=\"text-embedding-v4\"\n            )\n        \n        # 获取捕获的输出\n        output = f.getvalue()\n        return output\n    except Exception as e:\n        return f\"错误: {str(e)}\"\n\n# 创建界面\nwith gr.Blocks(title=\"RAG召回测试系统\", theme=gr.themes.Soft()) as demo:\n    # 页面标题\n    gr.Markdown(\"# RAG召回测试系统\")\n    gr.Markdown(\"使用Gradio构建的RAG召回测试界面，调用LC_RAG_02_RecallTest.py实现相似度检索\")\n    \n    with gr.Row():\n        # 左侧：输入区域\n        with gr.Column(scale=1):\n            gr.Markdown(\"## 查询设置\")\n            \n            # 查询文本输入\n            query_input = gr.Textbox(\n                label=\"查询文本\",\n                placeholder=\"请输入您要检索的问题或关键词\",\n                lines=3,\n                info=\"例如: '什么是未成年?' 或 '哪些节假日应该安排休假?'\"\n            )\n            \n            # Top-K设置\n            top_k_slider = gr.Slider(\n                label=\"Top-K检索数量\",\n                minimum=1,\n                maximum=10,\n                value=5,\n                step=1,\n                info=\"设置返回的最相似文档数量\"\n            )\n            \n            # 提交按钮\n            submit_btn = gr.Button(\n                \"执行召回测试\",\n                variant=\"primary\",\n                size=\"lg\"\n            )\n            \n            # 重置按钮\n            clear_btn = gr.Button(\"重置\", variant=\"secondary\")\n        \n        # 右侧：输出区域\n        with gr.Column(scale=2):\n            gr.Markdown(\"## 召回结果\")\n            \n            # 结果输出\n            result_output = gr.Textbox(\n                label=\"相似度检索结果\",\n                lines=20,\n                interactive=False,\n                placeholder=\"召回结果将显示在这里...\"\n            )\n            \n            # 状态信息\n            status_info = gr.Markdown(\"状态: 就绪\")\n    \n    # 按钮事件\n    def on_submit(query, top_k):\n        if not query:\n            return \"请输入查询文本\", \"状态: 错误 - 查询文本不能为空\"\n        \n        status_info.value = \"状态: 正在执行召回测试...\"\n        result = run_recall_test(query, top_k)\n        return result, \"状态: 测试完成\"\n    \n    def on_clear():\n        return \"\", 5, \"\", \"状态: 已重置\"\n    \n    # 绑定事件\n    submit_btn.click(\n        fn=lambda query, top_k: on_submit(query, top_k),\n        inputs=[query_input, top_k_slider],\n        outputs=[result_output, status_info]\n    )\n    \n    clear_btn.click(\n        fn=on_clear,\n        inputs=[],\n        outputs=[query_input, top_k_slider, result_output, status_info]\n    )\n    \n    # 示例查询\n    gr.Markdown(\"## 示例查询\")\n    with gr.Row():\n        example1 = gr.Button(\"什么是未成年?\")\n        example2 = gr.Button(\"哪些节假日应该安排休假?\")\n        example3 = gr.Button(\"足球比赛的基本规则是什么?\")\n    \n    def set_example(example_text):\n        return example_text, 5, \"\", \"状态: 就绪\"\n    \n    example1.click(fn=lambda: set_example(\"什么是未成年?\"), inputs=[], outputs=[query_input, top_k_slider, result_output, status_info])\n    example2.click(fn=lambda: set_example(\"哪些节假日应该安排休假?\"), inputs=[], outputs=[query_input, top_k_slider, result_output, status_info])\n    example3.click(fn=lambda: set_example(\"足球比赛的基本规则是什么?\"), inputs=[], outputs=[query_input, top_k_slider, result_output, status_info])\n\n# 启动应用\nif __name__ == \"__main__\":\n    demo.launch(\n        server_name=\"0.0.0.0\",\n        server_port=7860,\n        share=False,\n        debug=False\n    )\n</code></pre>\n</details>\n</div>\n<div id=\"MySignature\">\n    <p>&nbsp;</p>\n<p>---------------------------------------------------------------</p>\n<p style=\"margin: 0in 0in 10pt;\">aspnetx<span style=\"font-family: SimSun;\">的</span>BI<span style=\"font-family: SimSun;\">笔记系列索引：</span></p>\n<p style=\"margin: 0in 0in 10pt;\"><a href=\"http://www.cnblogs.com/aspnetx/archive/2013/02/25/2931603.html\" target=\"_blank\">使用SQL Server Analysis Services数据挖掘的关联规则实现商品推荐功能</a></p> \n<p style=\"margin: 0in 0in 10pt;\"><a href=\"http://www.cnblogs.com/aspnetx/archive/2013/03/24/2978347.html\" target=\"_blank\">一起玩转SQL Server 2012 下的分析服务</a></p> \n<p style=\"margin: 0in 0in 10pt;\"><a href=\"http://www.cnblogs.com/aspnetx/archive/2013/04/05/3000448.html\" target=\"_blank\">使用SQL Server分析服务定位目标用户  </a></p> \n\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>---------------------------------------------------------------<br /></p>\n<p>来自<a href=\"http://www.cnblogs.com/\" target=\"_blank\">博客园</a>的<a href=\"http://aspnetx.cnblogs.com/\" target=\"_blank\">aspnetx</a><font color=\"white\">宋卫东</font></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 21:27</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aspnetx\">哥本哈士奇(aspnetx)</a>&nbsp;\n阅读(<span id=\"post_view_count\">33</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "虚拟机操作系统选择指南（2025）",
      "link": "https://www.cnblogs.com/zyh-828/p/19400492",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zyh-828/p/19400492\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 21:23\">\n    <span>虚拟机操作系统选择指南（2025）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"虚拟机操作系统选择指南\">虚拟机操作系统选择指南</h2>\n<p>*<em>为刚入门的新手准备的简明指南，不深究技术细节，只关注\"哪个更适合我\"</em></p>\n<p>• <a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BA%86%E8%A7%A3%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F\" rel=\"noopener nofollow\">为什么要了解虚拟机操作系统？</a><br />\n• <a href=\"#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B\" rel=\"noopener nofollow\">虚拟机操作系统简介</a><br />\n• <a href=\"#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E9%80%82%E5%90%88%E4%BD%A0%E7%9A%84%E7%B3%BB%E7%BB%9F\" rel=\"noopener nofollow\">如何选择适合你的系统</a></p>\n<p><a id=\"为什么要了解虚拟机操作系统\"></a></p>\n<h3 id=\"为什么要了解虚拟机操作系统\">为什么要了解虚拟机操作系统？</h3>\n<p>想象一下，你有一台物理电脑，但想在里面运行多个\"虚拟电脑\"，每个\"虚拟电脑\"都有自己独立的操作系统。这就是虚拟机！而选择哪个操作系统安装在虚拟机里，就像选择给不同的房间布置不同的装修风格。</p>\n<p>对新手来说，了解这些系统能帮你：<br />\n• 找到最适合学习的系统<br />\n• 避免不必要的安装麻烦<br />\n• 快速上手实践</p>\n<p><a id=\"主流虚拟机操作系统简介\"></a></p>\n<h3 id=\"虚拟机操作系统简介\">虚拟机操作系统简介</h3>\n<h4 id=\"rocky-linux\">Rocky Linux</h4>\n<p>你可以把它看作是CentOS的\"接班人\"。CentOS官方支持已转向CentOS Stream，而Rocky Linux完美接替了原先CentOS的稳定位置。就像你习惯用的某个经典产品停产了，它的\"官方继承者\"出现了。</p>\n<p><strong>特点：</strong><br />\n• 与CentOS几乎一样的使用体验<br />\n• 非常稳定，适合长期运行<br />\n• 社区活跃，资料越来越多</p>\n<p><strong>适合谁：</strong> 以前用过CentOS，或者需要稳定服务器环境的新手</p>\n<h4 id=\"centos-7经典稳定版\">CentOS 7（经典稳定版）</h4>\n<p>虽然\"年纪\"有点大了（2014年发布），但依然有很多教程和环境基于它。就像Windows 7虽然老了，但很多人还在用。</p>\n<p><strong>注意：</strong> 官方主流支持已结束，但还有部分扩展支持</p>\n<p><strong>适合谁：</strong><br />\n• 跟着老教程学习的新手<br />\n• 运行特定老旧软件<br />\n• 只是想在虚拟机里\"体验一下\"的人</p>\n<h4 id=\"ubuntu-server新手友好之选\">Ubuntu Server（新手友好之选）</h4>\n<p>如果你想找最容易上手的Linux服务器系统，这可能是最佳选择。它就像\"智能手机\"中的iPhone——开箱即用，设置简单，遇到问题一搜就有答案。</p>\n<p><strong>特点：</strong><br />\n• 安装过程图形化，像安装普通软件<br />\n• 庞大的社区，海量中文教程<br />\n• 软件更新快，能用到最新技术</p>\n<p><strong>适合谁：</strong> 完全零基础，想快速上手Linux服务器的新手</p>\n<h4 id=\"debian稳定可靠之选\">Debian（稳定可靠之选）</h4>\n<p>如果说Ubuntu是\"时尚快消品\"，Debian就是\"经典工艺品\"。它不追求最新，但追求最稳定。很多企业服务器都使用它。</p>\n<p><strong>特点：</strong><br />\n• 极其稳定，运行几个月不用重启<br />\n• 软件包管理优秀<br />\n• 安全性很好</p>\n<p><strong>适合谁：</strong> 希望系统稳定，不追求最新功能的学习者</p>\n<h4 id=\"-openeuler国产新星\">🐉 openEuler（国产新星）</h4>\n<p>华为推出的开源系统，近年来发展迅速。如果你是IT相关专业，或者关注国产化技术，值得了解。</p>\n<p><strong>特点：</strong><br />\n• 中文支持好<br />\n• 针对服务器优化<br />\n• 国内社区活跃</p>\n<p><strong>适合谁：</strong> 对国产技术感兴趣，或需要中文环境支持的新手</p>\n<h3 id=\"如何选择适合你的系统\">如何选择适合你的系统？</h3>\n<h4 id=\"根据你的目标选择\">根据你的目标选择</h4>\n<ul>\n<li><strong>\"我只想试试Linux是什么\"</strong> → 选 Ubuntu Server，安装简单，跟着教程一步步来就行</li>\n<li><strong>\"我要学运维，以后找工作\"</strong> → 新手从 Ubuntu Server 入门，然后学 Rocky Linux</li>\n<li><strong>\"我要搭建一个长期运行的个人网站/服务\"</strong> → 选 Debian 或 Rocky Linux</li>\n<li><strong>\"我学校的教程/实验室用的都是CentOS 7\"</strong> → 跟着学校走，用 CentOS 7</li>\n<li><strong>\"我想了解国产操作系统\"</strong> → 选 openEuler</li>\n</ul>\n<h4 id=\"系统配置要求对比\">系统配置要求对比</h4>\n<p>所有系统的基本要求都差不多：<br />\n• 内存：至少2GB（4GB更流畅）<br />\n• 硬盘：20GB以上<br />\n• CPU：现代CPU都没问题</p>\n<p>Ubuntu Server 对新手最友好，安装过程中会有很多提示和帮助。</p>\n<p><strong>最终建议：</strong> 从 <strong>Ubuntu Server 22.04 LTS</strong> 开始。它就像学开车时用的教练车——安全、友好、有辅助。等你熟悉了，再尝试其他系统，就知道它们的区别和特点了。</p>\n<p>虚拟机操作系统的世界很广阔，但第一步总是最简单的：下载一个，装上试试。动手操作半小时，比看十篇教程都有用。</p>\n<hr />\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 21:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zyh-828\">七分之一月</a>&nbsp;\n阅读(<span id=\"post_view_count\">66</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "迈向 MCP 集群化：Solon AI （支持 Java8+）在解决 MCP 服务可扩展性上的探索与实践",
      "link": "https://www.cnblogs.com/noear/p/19406655",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/noear/p/19406655\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 21:15\">\n    <span>迈向 MCP 集群化：Solon AI （支持 Java8+）在解决 MCP 服务可扩展性上的探索与实践</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        Solon AI v3.8推出STREAMABLE_STATELESS通道，解决MCP服务集群化难题。该无状态设计放弃反向调用功能，采用短链接通讯，实现真正的水平扩展能力。同时新增CompletableFuture和Publisher异步支持，提升IO密集型任务处理效率。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>随着 Model Context Protocol (MCP) 的快速普及，开发者已经不再满足于简单的本地 Stdio 进程通讯。在生产环境中，如何构建高可用、可水平扩展的 MCP 服务集群成为了核心挑战。</p>\n<p>Solon AI 在最近的 v3.8 版本更新中，针对 MCP 服务集群化痛点，推出了一系列重磅特性，特别是 STREAMABLE_STATELESS（无状态流传输） 通道的引入，为 MCP 迈向云原生集群时代铺平了道路。</p>\n<h2 id=\"一-mcp-集群化的拦路虎状态依赖\">一、 MCP 集群化的拦路虎：状态依赖</h2>\n<p>传统的 MCP 传输协议（如 SSE 或标准的 STREAMABLE）通常是有状态的。</p>\n<h3 id=\"1-为什么有状态难以集群\">1. 为什么“有状态”难以集群？</h3>\n<p>在 MCP 协议中，为了支持反向调用（Server 调用 Client 的采样请求 Sampling）或原语变更通知（Notifications），Server 和 Client 之间必须建立长链接。</p>\n<ul>\n<li>连接绑定：Client 的短链接请求（发送指令）必须与长链接（接收通知）路由到同一台服务器。</li>\n<li>运维复杂：在负载均衡器（如 Nginx）上，必须配置 ip_hash 或粘性会话（Sticky Sessions），否则请求会因为找不到上下文而失败。</li>\n</ul>\n<h3 id=\"2-solon-ai-的解题思路\">2. Solon AI 的解题思路</h3>\n<p>Solon AI v3.8 引入了 McpChannel.STREAMABLE_STATELESS，其核心理念是：放弃不常用的反向调用，换取极致的水平扩展能力。</p>\n<h2 id=\"二-核心突破streamable_stateless-通道\">二、 核心突破：STREAMABLE_STATELESS 通道</h2>\n<p>这是 Solon AI 为集群友好性专门设计的模式。它通过将长链接转变为短链接通讯，彻底消除了服务端的状态依赖。</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>STREAMABLE (有状态)</th>\n<th>STREAMABLE_STATELESS (无状态)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>链接类型</td>\n<td>有长链接 (Long Connection)</td>\n<td>只用短链接 (Short Connection)</td>\n</tr>\n<tr>\n<td>集群路由</td>\n<td>需要 ip_hash</td>\n<td>任意路由</td>\n</tr>\n<tr>\n<td>反向通讯</td>\n<td>支持 (Server -&gt; Client)</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>需要实时监控 Tool 变化的复杂应用</td>\n<td>80% 的标准工具调用、高并发集群</td>\n</tr>\n</tbody>\n</table>\n<p>开发者体验一致性： 无论底层通道如何变化，Solon AI 的开发代码几乎不需要修改，仅需在注解中切换 channel：</p>\n<pre><code class=\"language-java\">@McpServerEndpoint(channel = McpChannel.STREAMABLE_STATELESS, mcpEndpoint = \"/mcp/weather\")\npublic class McpServerTool {\n    @ToolMapping(description = \"查询天气预报\")\n    public String getWeather(@Param(description = \"城市位置\") String location) {\n        return \"晴，14度\";\n    }\n}\n</code></pre>\n<h2 id=\"三-异步性能优化completablefuture-与-publisher\">三、 异步性能优化：CompletableFuture 与 Publisher</h2>\n<p>在集群环境下，IO 密集型任务（如请求第三方 API）如果阻塞线程，会极大降低集群的吞吐量。Solon AI v3.8.0 全面增强了 异步支持。</p>\n<h3 id=\"1-completablefuture-支持\">1. CompletableFuture 支持</h3>\n<p>现在，MCP 工具可以直接返回异步结果，完美适配现代 Java 的异步编程模型：</p>\n<pre><code class=\"language-java\">@ToolMapping(description = \"异步查询天气\", returnDirect = true)\npublic CompletableFuture&lt;String&gt; getWeatherAsync(String location) {\n    return CompletableFuture.supplyAsync(() -&gt; \"异步返回：多云\");\n}\n</code></pre>\n<h3 id=\"2-响应式流支持\">2. 响应式流支持</h3>\n<p>针对更高级的场景，Solon AI 适配了 org.reactivestreams.Publisher，使得 MCP 工具、资源（Resource）和提示词（Prompt）都能以非阻塞的方式工作。</p>\n<pre><code class=\"language-java\">@ToolMapping(description = \"异步查询天气\", returnDirect = true)\npublic Publisher&lt;String&gt; getWeatherAsync(String location) {\n    return Mono.just(\"异步返回：多云\");\n}\n</code></pre>\n<h2 id=\"四-传输方式全景对比\">四、 传输方式全景对比</h2>\n<p>Solon AI 目前支持四种主流传输通道，覆盖了从本地到云端的全场景：</p>\n<table>\n<thead>\n<tr>\n<th>服务端通道</th>\n<th>客户端通道</th>\n<th>通讯方式</th>\n<th>集群友好度</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>STDIO</td>\n<td>STDIO</td>\n<td>进程间管道</td>\n<td>N/A</td>\n<td>本地开发首选</td>\n</tr>\n<tr>\n<td>SSE</td>\n<td>SSE</td>\n<td>HTTP</td>\n<td>需 ip_hash</td>\n<td>官方已标记弃用</td>\n</tr>\n<tr>\n<td>STREAMABLE</td>\n<td>STREAMABLE</td>\n<td>HTTP</td>\n<td>需 ip_hash</td>\n<td>用于替代 SSE</td>\n</tr>\n<tr>\n<td>STREAMABLE_STATELESS</td>\n<td>STREAMABLE</td>\n<td>HTTP</td>\n<td>极高</td>\n<td>集群推荐</td>\n</tr>\n</tbody>\n</table>\n<p>注意：使用 STREAMABLE_STATELESS 时，客户端依然配置为 STREAMABLE 即可，服务端会自动处理握手降级。</p>\n<h2 id=\"五-总结与展望\">五、 总结与展望</h2>\n<p>Solon AI 通过对 MCP 协议的深度解耦，不仅实现了对最新 2025-06-18 版本协议的支持，更通过无状态通道和全链路异步化，解决了 MCP 服务在大规模并发下的“落地难”问题。</p>\n<p>对于追求高性能和易扩展的 AI 应用架构师来说，Solon AI 提供了一套“开发一致、部署灵活”的工具链，让 MCP 服务真正具备了工业级集群的能力。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 21:15</span>&nbsp;\n<a href=\"https://www.cnblogs.com/noear\">带刺的坐椅</a>&nbsp;\n阅读(<span id=\"post_view_count\">28</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "[从程序员到架构师] 微服务场景实战 - 注册发现",
      "link": "https://www.cnblogs.com/yhup/p/19406648",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yhup/p/19406648\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 21:12\">\n    <span>[从程序员到架构师] 微服务场景实战 - 注册发现</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"[从程序员到架构师] 微服务场景实战 - 注册发现\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/2428649/202512/2428649-20251226211113233-1714412455.png\" />\n        各位，咱们继续盘微服务这个“硬核玩具”。上回说到要从接地气的场景开始，今天这个场景，那可太“接地气”了——接地气到让人脚趾抠地。业务场景：如何对几十个后台服务进行高效管理\n**给50个“娃”当保姆是种什么体验？ **想象一下，你手底下有50多个后台服务，个个都是亲生的（Java、Go、Node.js 什么语言都有）。它们关系复杂，互相调用，活像一个大型幼儿园。这时候，Spring Cloud、Dubbo 这些“名牌家教”只教 Java 娃，其他娃咋办？\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>各位，咱们继续盘微服务这个“硬核玩具”。上回说到要从接地气的场景开始，今天这个场景，那可太“接地气”了——接地气到让人脚趾抠地。</p>\n<h1 id=\"1-业务场景如何对几十个后台服务进行高效管理\">1. 业务场景：如何对几十个后台服务进行高效管理</h1>\n<p>**给50个“娃”当保姆是种什么体验？ **想象一下，你手底下有50多个后台服务，个个都是亲生的（Java、Go、Node.js 什么语言都有）。它们关系复杂，互相调用，活像一个大型幼儿园。这时候，Spring Cloud、Dubbo 这些“名牌家教”只教 Java 娃，其他娃咋办？</p>\n<p>我们当时的做法，非常质朴，质朴得像用记事本管理一支舰队。</p>\n<p><strong>第一步：把所有的“娃”（服务）的住址（IP+端口）和接送规则（负载均衡），全手工登记在一本巨大的“花名册”上——也就是 Nginx 配置文件。</strong> 就像下面这样：</p>\n<pre><code class=\"language-nginx\"># ==================== 负载均衡配置 ====================\n# 定义名为 user_servers 的服务器集群\nupstream user_servers {\n    # 用户服务实例1\n    server 192.168.5.150:80;\n    # 用户服务实例2\n    server 192.168.5.151:80;\n    # nginx会自动在这两个实例间轮询分发请求，实现负载均衡\n}\n\n# 定义名为 order_servers 的服务器集群\nupstream order_servers {\n    # 订单服务实例1\n    server 192.168.5.153:80;\n    # 订单服务实例2\n    server 192.168.5.152:80;\n    # 同理，这两个订单服务实例也会被均衡调度\n}\n\n# ==================== 用户服务代理配置 ====================\nserver {\n    # 监听80端口（HTTP默认端口）\n    listen 80;\n    # 当访问 user-servers 域名时会进入此配置块\n    server_name user-servers;\n    # 所有路径请求都走这个规则\n    location / {\n        # 关键操作：把请求转发给上面定义的 user_servers 集群\n        proxy_pass http://user_servers;\n        # 以下是三个重要的请求头设置，让后端服务知道\"谁真的在访问\"\n        # 1. 把原始请求的Host头传给后端（有些服务靠这个识别虚拟主机）\n        proxy_set_header Host $host;\n        # 2. 把真实客户端的IP传给后端（否则后端只能看到nginx的IP）\n        proxy_set_header X-Real-Ip $remote_addr;\n        # 3. 记录完整的代理链IP（防止客户IP被中间代理\"吃掉\"）\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    }\n}\n\n# ==================== 订单服务代理配置 ====================\nserver {\n    listen 80;\n    # 当访问 order-servers 域名时会进入此配置块\n    server_name order-servers;\n    location / {\n        # 将请求转发给 order_servers 集群\n        proxy_pass http://order_servers;\n        \n        # 同样传递这三个重要头部\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-Ip $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    }\n}\n\n# ==================== 配置亮点总结 ====================\n# 1. 高可用：两个实例互为备份，一个挂掉另一个顶上\n# 2. 负载均衡：请求被均匀分发，防止单实例过载\n# 3. 透明代理：后端服务能获取真实的客户端信息\n# 4. 解耦：前端无需知道后端具体有几个实例、IP是多少\n</code></pre>\n<p><strong>第二步：让“娃”们自己记通讯录。</strong> 在每个服务的本地配置文件里，写下它要联系的其他“娃”的地址：</p>\n<pre><code class=\"language-properties\">user.api.host  = https://user-servers/  # 用户服务家地址\norder.api.host = https://order-servers/ # 订单服务家地址\n</code></pre>\n<p>想找谁玩（调用谁），就先查这本本地通讯录，拼出完整地址，然后所有“社交活动”都必须通过<strong>中央调度员 Nginx</strong> 来安排。</p>\n<p><strong>那么，这套质朴的架构长啥样呢？</strong></p>\n<pre><code class=\"language-plain\">    [ 服务A ]  [ 服务B ]  [ 服务C ]  ... (超过50个异构服务)\n        |          |          |\n        |          |          |\n        +----------+----------+\n                   |\n                   v\n             [ 中心 Nginx ]\n             (巨型花名册)\n                   |\n        +----------+----------+\n        |          |          |\n        v          v          v\n    [ 服务X ]  [ 服务Y ]  [ 服务Z ]\n</code></pre>\n<p><strong>本质就是：所有服务间的“通话”，都必须先打到中央总机（Nginx），由总机查“花名册”后转接。</strong> 网络拓扑瞬间变成一个以 Nginx 为中心的“星型”结构，或者更形象地说，像个“八爪鱼”，所有触手都连着同一个大脑。</p>\n<h1 id=\"2-传统架构会出现的问题血泪史开始了\">2. 传统架构会出现的问题（血泪史开始了）</h1>\n<p>这套架构运行起来后，我们迅速收获了“四重痛苦大礼包”：</p>\n<h2 id=\"21配置烦琐上线容易出错\">2.1配置烦琐，上线容易出错</h2>\n<p>** 配置如履薄冰，上线心惊胆战。**<br />\n每次加新“娃”、给“娃”搬新家（扩缩容），都得手动更新那本巨大的 Nginx 花名册。更刺激的是，我们有<strong>4台</strong> Nginx 兄弟（前面还有个商业负载均衡器 NetScaler 挡着）。这意味着，改一个地方，同样的配置要小心翼翼、毫不出错地复制四遍。但凡漏了一台，这个错误就像潜伏的雷，NetScaler 不把流量导到那台出错的 Nginx，你就发现不了。等它哪天爆发？自求多福吧。</p>\n<h2 id=\"22-加机器要重启\">2.2 加机器要重启</h2>\n<p><strong>扩缩容如同“拆弹”，重启需要勇气。</strong></p>\n<p>流量大了要加机器？恭喜你，获得一次“运维心跳挑战赛”参赛资格。你需要：1. 准确无误地修改配置。2. <strong>重启 Nginx</strong> 让配置生效。在半夜，面对一个承载所有流量的核心代理，你敢点下重启吗？万一失败，全站瘫痪。时间紧、压力大、不能错，这简直是在钢丝上给飞机换引擎。</p>\n<h2 id=\"23-负载均衡单点\">2.3 负载均衡单点</h2>\n<p><strong>中心大脑成了性能与故障的“单点”。</strong></p>\n<p>所有流量都挤过 Nginx 这一个“独木桥”，它理所当然地成了瓶颈和最大的故障风险点。后来我们加了 NetScaler 在前面做高可用，虽然缓解了单点风险，但代价是：<strong>网络路径变长了</strong>（服务 -&gt; NetScaler -&gt; Nginx -&gt; 服务），延迟增加，架构更复杂。</p>\n<h2 id=\"24-管理困难\">2.4 管理困难</h2>\n<p>** 服务治理全靠“人肉”，清单维护苦不堪言。**<br />\n合规审计要升级某个公共库？你得先知道到底有哪些服务用了它。于是，维护一份准确的全服务清单，成了定期开展的、纯手工的“考古”工作。费时、费力、易出错。</p>\n<h1 id=\"3-三条出路\">3. 三条出路</h1>\n<p>被折磨得够呛后，我们琢磨了三条路：</p>\n<ol>\n<li><strong>服务自注册 + 清单广播（Spring Cloud/Dubbo 模式）</strong>：让每个“娃”自己到“学校布告栏”（如 ZooKeeper）注册。布告栏有更新（有新娃来或旧娃走），就广播给所有“娃”。这样每个“娃”自己就有一份实时通讯录，想找谁直接联系，绕过中央总机。</li>\n<li><strong>容器化 + Kubernetes Service（降维打击）</strong>：直接把所有“娃”送进“自动化托管幼儿园”（K8s）。给同类型的“娃”贴上统一标签（如 <code>app: user</code>），K8s 的 Service 会自动为它们提供稳定的访问入口和负载均衡。这是现代的、终极的解决方案。</li>\n</ol>\n<p><strong>具体操作如下：</strong></p>\n<p>** ① **先在部署User服务的Pod上打上“User-App”标签，部署Order服务的Pod上打上“Order-App”标签。\t**\t**</p>\n<p>** ② **在Kubernetes上启动多个User的Pod和多个Order的Pod，然后启动两个Service（类似于Nginx的负载均衡），一个Service叫UserService，专门处理标签为“User-App”的Pod；另一个Service叫OrderService，专门处理标签为“Order-App”的Pod。</p>\n<p>** ③ **从Client发出的请求首先会到达OrderService，再自动负载均衡到某个Order服务的Pod。当Order的服务要调用User的服务时，它就会调用UserService，UserService会负载均衡到User其中的一个Pod。</p>\n<p><img alt=\"基于Service的服务注册发现示意图\" src=\"https://img2024.cnblogs.com/blog/2428649/202512/2428649-20251226210951407-1008683054.jpg\" /></p>\n<ol start=\"3\">\n<li><strong>自动化配置生成（给旧系统打补丁）</strong>：用工具监听“布告栏”的变化，自动去更新 Nginx 的配置并重启。这相当于给“中央总机”配了个自动秘书。</li>\n</ol>\n<p><strong>我们当时的选择是第一条路。</strong> 原因很现实：多年前容器生产环境还不成熟，全量迁移风险太高；第三条路只是自动化了痛苦，没解决 Nginx 单点和重启的根本问题。所以，我们决定“造个轮子”。最终的解决方案如图所示。可以发现，整个解决过程分为以下几个步骤。</p>\n<p>1）每个后台服务自动把服务类型和IP注册到中心存储。</p>\n<p>2）中心存储将服务列表推送到每个后台服务。</p>\n<p>3）后台服务在本地做负载均衡，轮流访问同服务的不同节点。</p>\n<p><img alt=\"基于协调服务的服务注册发现\" src=\"https://img2024.cnblogs.com/blog/2428649/202512/2428649-20251226210951425-207080574.jpg\" /></p>\n<h1 id=\"4-新架构要点与深度思考\">4. 新架构要点与深度思考</h1>\n<p>定下方向后，具体怎么走？有几个关键决策：</p>\n<h2 id=\"41-使用哪个分布式协调服务布告栏\">4.1 使用哪个分布式协调服务（布告栏）</h2>\n<p>我们需要一个能实时推送变更、能监听节点存活的“布告栏”。普通的 Redis 不太适合这种高频、实时同步的场景。<strong>分布式协调服务</strong>（如 ZooKeeper、etcd、Nacos）生来就是干这个的，它们提供了我们需要的“观察-通知”机制。</p>\n<p><img alt=\"常见分布式协调服务对比\" src=\"https://img2024.cnblogs.com/blog/2428649/202512/2428649-20251226210951439-892338048.jpg\" /></p>\n<h2 id=\"42-具体用哪个技术选型里的潜规则\">4.2 具体用哪个？——技术选型里的“潜规则”</h2>\n<pre><code>理想很丰满，现实有约束。当时公司运维团队已经在全力维护 **ZooKeeper** 了。从组织成本考虑，引入一个全新的中间件（如 etcd）意味着运维要付出双倍学习和管理成本。所以，**“团队熟悉什么”** 这个非技术因素，往往成为决定性的一票。\n</code></pre>\n<p>当然，如果今天从头选型，我会大力推荐 <strong>Nacos</strong>。理由很实在：</p>\n<ol>\n<li>\n<p><strong>性价比高</strong>，它集服务发现和配置中心于一身；</p>\n</li>\n<li>\n<p><strong>模式灵活</strong>，在微服务场景下，<strong>可用性（A）通常比强一致性（C）更重要</strong>（后面详说），Nacos 允许你在 AP 和 CP 间切换，而 ZooKeeper 是坚定的 CP 派。</p>\n</li>\n</ol>\n<h2 id=\"43-基于-zookeeper-要做什么核心四步\">4.3 基于 ZooKeeper 要做什么？——核心四步</h2>\n<p>实现起来并不复杂：</p>\n<ol>\n<li><strong>服务注册</strong>：启动时，到 ZooKeeper 上“签到”。</li>\n<li><strong>服务拉取</strong>：从 ZooKeeper 拉取全量服务列表缓存到本地。</li>\n<li><strong>监听变化</strong>：订阅 ZooKeeper 节点，列表一变，本地立刻更新。</li>\n<li><strong>本地负载均衡</strong>：调用时，本地缓存里轮询（或其他策略）选一个实例直接通信。<strong>至此，中央 Nginx 被成功“拆解”掉了。</strong></li>\n</ol>\n<h1 id=\"5-灵魂拷问如果-zookeeper-自己挂了怎么办\">5. 灵魂拷问：如果 ZooKeeper 自己挂了怎么办？</h1>\n<p>这是所有 CP 系统（如 ZooKeeper）在微服务场景下最经典的质疑。这里必须搬出 <strong>CAP 三角</strong>理论来解释了：</p>\n<ul>\n<li><strong>C（一致性）</strong>：所有节点看到的数据在同一时刻是相同的。</li>\n<li><strong>A（可用性）</strong>：每个请求都能得到响应（不保证数据最新）。</li>\n<li><strong>P（分区容错性）</strong>：系统能在网络分区时继续工作。</li>\n</ul>\n<p>ZooKeeper 是 <strong>CP</strong> 系统。当集群 Leader 宕机或网络发生分区时，它会为了保证数据一致性（C）而进入选举状态，<strong>在此期间拒绝服务（牺牲了 A）</strong>。这对微服务发现来说，可能有点“过”了。</p>\n<p>想想看：微服务之间每分钟成千上万的调用，如果因为 ZooKeeper 选举导致<strong>所有服务都无法获取新地址</strong>，整个系统就僵住了。相比之下，我们更愿意接受一种“温和”的错误：比如，新上线的服务地址<strong>短暂地</strong>没有被所有节点感知（<strong>牺牲一点点 C</strong>），导致少量请求可能打到旧IP而失败（客户端应有重试），但这<strong>远好过全体罢工</strong>。这就是为什么像 Eureka 这样的 <strong>AP</strong> 系统，或 Nacos（可配 AP 模式）在微服务领域更受青睐。</p>\n<p><strong>那当时我们用 ZooKeeper 怎么办？</strong> 我们采用了“兜底方案”：</p>\n<ol>\n<li><strong>本地缓存保底</strong>：服务本地有缓存列表，ZooKeeper 短期宕机，大家继续用旧列表通信，基本没事。</li>\n<li><strong>配置中心备份</strong>：定期把完整的服务列表同步一份到配置中心。万一有新服务在 ZooKeeper 宕机期间启动，它还能从配置中心拉取到一个“虽不是最新但基本可用”的列表，不至于完全“失明”。</li>\n</ol>\n<h1 id=\"6小结回头看轻舟已过万重山\">6.小结：回头看，轻舟已过万重山</h1>\n<p>用上新架构后，再回头看那“四宗罪”，已然烟消云散：</p>\n<ul>\n<li><strong>配置繁琐？</strong> 无需再碰 Nginx，服务自动注册。</li>\n<li><strong>加机器要重启？</strong> 新实例上线自动加入，无缝衔接。</li>\n<li><strong>负载均衡单点？</strong> 流量直接从调用方到被调用方，路径最短，性能更优。</li>\n<li><strong>管理困难？</strong> 服务清单实时可查，一目了然。</li>\n</ul>\n<p>当然，我们承认这是在“重复造轮子”。，因为注册发现是Spring Cloud或Dubbo已经实现的功能。有时候新人会问，为什么要自研？这时只要给他们看一下Go和Node.js的服务，他们就容易理解了。但对于一个多语言技术栈的团队来说，这却是最贴合实际的解决方案。这个过程也让我们把“服务注册与发现”的原理，从里到外摸了个门儿清。这大概就是“被迫造轮子”带来的意外收获吧。</p>\n<p>好了，微服务的“通讯录”问题我们就盘到这里。下次，我们来盘另一个让人头疼的玩意：当一次请求穿过几十个服务，出了问题时，<strong>日志散落在天涯海角，我们该怎么把它拼凑回一个完整的故事？</strong></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 21:12</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yhup\">yihuiComeOn</a>&nbsp;\n阅读(<span id=\"post_view_count\">38</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}