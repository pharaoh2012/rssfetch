{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "CodeSpirit CRUD开发完整指南",
      "link": "https://www.cnblogs.com/codelove/p/19388153",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/codelove/p/19388153\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 00:15\">\n    <span>CodeSpirit CRUD开发完整指南</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"概述\">概述</h2>\n<p>本文档通过<strong>职工管理</strong>（Employee）的实际代码示例，展示如何使用CodeSpirit框架快速开发CRUD功能。该示例来自身份认证系统（IdentityApi），是一个标准的关联型CRUD模块，包含完整的验证逻辑、业务处理和关联关系管理。</p>\n<p><strong>最后更新</strong>: 2025年12月22日<br />\n<strong>框架版本</strong>: v2.0.0<br />\n<strong>示例来源</strong>: <code>CodeSpirit.IdentityApi</code> - 职工管理模块</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251223170219569-281479304.png\" /></p>\n<h2 id=\"开发流程概览\">开发流程概览</h2>\n<div class=\"mermaid\">graph LR\n    A[\"1. 创建实体模型\"] --&gt; B[\"2. 创建DTO类\"]\n    B --&gt; C[\"3. 配置AutoMapper\"]\n    C --&gt; D[\"4. 创建服务层\"]\n    D --&gt; E[\"5. 创建控制器\"]\n    E --&gt; F[\"6. 配置数据库\"]\n    F --&gt; G[\"7. 创建迁移\"]\n    G --&gt; H[\"完成\"]\n</div><h2 id=\"示例模块说明\">示例模块说明</h2>\n<p><strong>职工管理</strong>（Employee）是一个典型的关联型CRUD模块，具有以下特点：</p>\n<ul>\n<li>✅ 关联关系管理（部门、用户账号）</li>\n<li>✅ 完整的CRUD操作</li>\n<li>✅ 业务验证（工号唯一性、部门存在性、身份证格式等）</li>\n<li>✅ 多条件查询（关键字、部门、状态、日期范围等）</li>\n<li>✅ 表单分组展示（基本信息、联系方式、工作信息等）</li>\n<li>✅ 多租户支持</li>\n<li>✅ 审计字段自动记录</li>\n<li>✅ 软删除支持</li>\n</ul>\n<h2 id=\"1-创建实体模型\">1. 创建实体模型</h2>\n<p>在<code>Data/Models</code>目录下创建实体类：</p>\n<pre><code class=\"language-csharp\">// Data/Models/Employee.cs\nusing CodeSpirit.Shared.Entities.Interfaces;\nusing CodeSpirit.MultiTenant.Abstractions;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace CodeSpirit.IdentityApi.Data.Models;\n\n/// &lt;summary&gt;\n/// 职工信息\n/// &lt;/summary&gt;\npublic class Employee : IFullAuditable, IMultiTenant, IIsActive\n{\n    /// &lt;summary&gt;\n    /// 职工ID\n    /// &lt;/summary&gt;\n    public long Id { get; set; }\n\n    /// &lt;summary&gt;\n    /// 租户ID（多租户支持）\n    /// &lt;/summary&gt;\n    [Required]\n    [MaxLength(50)]\n    public string TenantId { get; set; } = string.Empty;\n\n    /// &lt;summary&gt;\n    /// 工号（租户内唯一）\n    /// &lt;/summary&gt;\n    [Required]\n    [MaxLength(50)]\n    public string EmployeeNo { get; set; } = string.Empty;\n\n    /// &lt;summary&gt;\n    /// 姓名\n    /// &lt;/summary&gt;\n    [Required]\n    [MaxLength(100)]\n    public string Name { get; set; } = string.Empty;\n\n    /// &lt;summary&gt;\n    /// 性别\n    /// &lt;/summary&gt;\n    public Gender Gender { get; set; }\n\n    /// &lt;summary&gt;\n    /// 身份证号码\n    /// &lt;/summary&gt;\n    [MaxLength(18)]\n    public string? IdNo { get; set; }\n\n    /// &lt;summary&gt;\n    /// 出生日期\n    /// &lt;/summary&gt;\n    public DateTime? BirthDate { get; set; }\n\n    /// &lt;summary&gt;\n    /// 手机号码\n    /// &lt;/summary&gt;\n    [MaxLength(15)]\n    public string? PhoneNumber { get; set; }\n\n    /// &lt;summary&gt;\n    /// 电子邮箱\n    /// &lt;/summary&gt;\n    [MaxLength(100)]\n    [EmailAddress]\n    public string? Email { get; set; }\n\n    /// &lt;summary&gt;\n    /// 部门ID\n    /// &lt;/summary&gt;\n    public long? DepartmentId { get; set; }\n\n    /// &lt;summary&gt;\n    /// 所属部门（导航属性）\n    /// &lt;/summary&gt;\n    public Department? Department { get; set; }\n\n    /// &lt;summary&gt;\n    /// 职位\n    /// &lt;/summary&gt;\n    [MaxLength(100)]\n    public string? Position { get; set; }\n\n    /// &lt;summary&gt;\n    /// 职级\n    /// &lt;/summary&gt;\n    [MaxLength(50)]\n    public string? JobLevel { get; set; }\n\n    /// &lt;summary&gt;\n    /// 入职日期\n    /// &lt;/summary&gt;\n    public DateTime? HireDate { get; set; }\n\n    /// &lt;summary&gt;\n    /// 离职日期\n    /// &lt;/summary&gt;\n    public DateTime? TerminationDate { get; set; }\n\n    /// &lt;summary&gt;\n    /// 在职状态\n    /// &lt;/summary&gt;\n    public EmploymentStatus EmploymentStatus { get; set; }\n\n    /// &lt;summary&gt;\n    /// 关联的用户ID\n    /// &lt;/summary&gt;\n    public long? UserId { get; set; }\n\n    /// &lt;summary&gt;\n    /// 关联的用户账号（导航属性）\n    /// &lt;/summary&gt;\n    public ApplicationUser? User { get; set; }\n\n    /// &lt;summary&gt;\n    /// 紧急联系人\n    /// &lt;/summary&gt;\n    [MaxLength(100)]\n    public string? EmergencyContact { get; set; }\n\n    /// &lt;summary&gt;\n    /// 紧急联系电话\n    /// &lt;/summary&gt;\n    [MaxLength(15)]\n    public string? EmergencyPhone { get; set; }\n\n    /// &lt;summary&gt;\n    /// 地址\n    /// &lt;/summary&gt;\n    [MaxLength(500)]\n    public string? Address { get; set; }\n\n    /// &lt;summary&gt;\n    /// 备注\n    /// &lt;/summary&gt;\n    [MaxLength(1000)]\n    public string? Remarks { get; set; }\n\n    /// &lt;summary&gt;\n    /// 是否激活\n    /// &lt;/summary&gt;\n    public bool IsActive { get; set; } = true;\n\n    /// &lt;summary&gt;\n    /// 头像地址\n    /// &lt;/summary&gt;\n    [MaxLength(255)]\n    [DataType(DataType.ImageUrl)]\n    public string? AvatarUrl { get; set; }\n\n    // 审计字段（实现IFullAuditable接口）\n    public long CreatedBy { get; set; }\n    public DateTime CreatedAt { get; set; }\n    public long? UpdatedBy { get; set; }\n    public DateTime? UpdatedAt { get; set; }\n    public long? DeletedBy { get; set; }\n    public DateTime? DeletedAt { get; set; }\n    public bool IsDeleted { get; set; }\n}\n</code></pre>\n<p><strong>说明</strong>：</p>\n<ul>\n<li>实现<code>IFullAuditable</code>接口，自动包含完整的审计字段（创建、更新、删除）</li>\n<li>实现<code>IMultiTenant</code>接口，支持多租户数据隔离</li>\n<li>实现<code>IIsActive</code>接口，支持激活状态管理</li>\n<li>使用<code>long</code>作为主键类型</li>\n<li>包含关联关系的导航属性（部门、用户账号）</li>\n<li>支持软删除（<code>IsDeleted</code>字段）</li>\n</ul>\n<h2 id=\"2-创建dto类\">2. 创建DTO类</h2>\n<p>在<code>Dtos/Employee</code>目录下创建DTO类：</p>\n<h3 id=\"21-employeedto展示dto\">2.1 EmployeeDto（展示DTO）</h3>\n<pre><code class=\"language-csharp\">// Dtos/Employee/EmployeeDto.cs\nusing CodeSpirit.Amis.Attributes.Columns;\nusing CodeSpirit.Core.Attributes;\nusing CodeSpirit.IdentityApi.Data.Models;\nusing System.ComponentModel;\n\nnamespace CodeSpirit.IdentityApi.Dtos.Employee;\n\n/// &lt;summary&gt;\n/// 职工数据传输对象\n/// &lt;/summary&gt;\npublic class EmployeeDto\n{\n    /// &lt;summary&gt;\n    /// 职工ID\n    /// &lt;/summary&gt;\n    public long Id { get; set; }\n\n    /// &lt;summary&gt;\n    /// 工号\n    /// &lt;/summary&gt;\n    [DisplayName(\"工号\")]\n    public string EmployeeNo { get; set; } = string.Empty;\n\n    /// &lt;summary&gt;\n    /// 姓名\n    /// &lt;/summary&gt;\n    [DisplayName(\"姓名\")]\n    [TplColumn(template: \"${name}\")]\n    public string Name { get; set; } = string.Empty;\n\n    /// &lt;summary&gt;\n    /// 头像地址\n    /// &lt;/summary&gt;\n    [DisplayName(\"头像\")]\n    [AvatarColumn(Text = \"${name}\", Src = \"${avatarUrl}\")]\n    [Badge(Animation = true, VisibleOn = \"isActive\", Level = \"info\")]\n    public string? AvatarUrl { get; set; }\n\n    /// &lt;summary&gt;\n    /// 性别\n    /// &lt;/summary&gt;\n    [DisplayName(\"性别\")]\n    public Gender Gender { get; set; }\n\n    /// &lt;summary&gt;\n    /// 手机号码\n    /// &lt;/summary&gt;\n    [DisplayName(\"手机号码\")]\n    public string? PhoneNumber { get; set; }\n\n    /// &lt;summary&gt;\n    /// 电子邮箱\n    /// &lt;/summary&gt;\n    [DisplayName(\"电子邮箱\")]\n    public string? Email { get; set; }\n\n    /// &lt;summary&gt;\n    /// 部门ID\n    /// &lt;/summary&gt;\n    [AmisColumn(Hidden = true)]\n    public long? DepartmentId { get; set; }\n\n    /// &lt;summary&gt;\n    /// 部门名称\n    /// &lt;/summary&gt;\n    [DisplayName(\"部门\")]\n    public string? DepartmentName { get; set; }\n\n    /// &lt;summary&gt;\n    /// 职位\n    /// &lt;/summary&gt;\n    [DisplayName(\"职位\")]\n    public string? Position { get; set; }\n\n    /// &lt;summary&gt;\n    /// 职级\n    /// &lt;/summary&gt;\n    [DisplayName(\"职级\")]\n    public string? JobLevel { get; set; }\n\n    /// &lt;summary&gt;\n    /// 入职日期\n    /// &lt;/summary&gt;\n    [DisplayName(\"入职日期\")]\n    [DateColumn(Format = \"YYYY-MM-DD\")]\n    public DateTime? HireDate { get; set; }\n\n    /// &lt;summary&gt;\n    /// 在职状态\n    /// &lt;/summary&gt;\n    [DisplayName(\"在职状态\")]\n    public EmploymentStatus EmploymentStatus { get; set; }\n\n    /// &lt;summary&gt;\n    /// 是否激活\n    /// &lt;/summary&gt;\n    [DisplayName(\"是否激活\")]\n    public bool IsActive { get; set; }\n\n    /// &lt;summary&gt;\n    /// 创建时间\n    /// &lt;/summary&gt;\n    [DisplayName(\"创建时间\")]\n    [DateColumn(FromNow = true)]\n    public DateTime CreatedAt { get; set; }\n\n    /// &lt;summary&gt;\n    /// 更新时间\n    /// &lt;/summary&gt;\n    [DisplayName(\"更新时间\")]\n    [DateColumn(FromNow = true)]\n    public DateTime? UpdatedAt { get; set; }\n}\n</code></pre>\n<p><strong>说明</strong>：</p>\n<p><strong>列特性（Columns）</strong>：用于控制前端表格列的显示和格式</p>\n<ul>\n<li>\n<p><code>AmisColumn</code>：基础列特性，控制列的显示、排序、隐藏等</p>\n<ul>\n<li><code>Hidden</code>：是否隐藏列</li>\n<li><code>Sortable</code>：是否支持排序</li>\n<li><code>Copyable</code>：是否可复制</li>\n<li><code>Fixed</code>：是否固定列（left/right/none）</li>\n<li><code>StatusMapping</code>：状态映射（支持预定义映射如Boolean、HttpStatusCode等）</li>\n</ul>\n</li>\n<li>\n<p><code>TplColumn</code>：自定义列显示模板，使用模板语法自定义列内容</p>\n<ul>\n<li><code>template</code>：模板字符串，支持变量插值（如<code>${name}</code>）</li>\n</ul>\n</li>\n<li>\n<p><code>AvatarColumn</code>：头像列，显示头像图片</p>\n<ul>\n<li><code>Text</code>：头像下方显示的文本</li>\n<li><code>Src</code>：头像图片地址</li>\n</ul>\n</li>\n<li>\n<p><code>DateColumn</code>：日期列，格式化日期显示</p>\n<ul>\n<li><code>Format</code>：日期格式（如<code>YYYY-MM-DD</code>、<code>YYYY-MM-DD HH:mm</code>）</li>\n<li><code>FromNow</code>：是否显示相对时间（如\"2小时前\"）</li>\n</ul>\n</li>\n<li>\n<p><code>IgnoreColumn</code>：忽略列，该字段不在表格中显示</p>\n</li>\n<li>\n<p><code>TagsColumn</code>：标签列，以标签形式显示数组数据</p>\n</li>\n<li>\n<p><code>LinkColumn</code>：链接列，显示可点击的链接</p>\n</li>\n<li>\n<p><code>AmisStatusColumn</code>：状态列，显示状态标签和图标</p>\n</li>\n<li>\n<p><code>LongTextColumn</code>：长文本列，支持展开/收起</p>\n</li>\n<li>\n<p><code>ListColumn</code>：列表列，显示列表数据</p>\n</li>\n<li>\n<p><code>IconColumn</code>：图标列，显示图标</p>\n</li>\n</ul>\n<h3 id=\"22-createemployeedto创建dto\">2.2 CreateEmployeeDto（创建DTO）</h3>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251223170338569-581617099.png\" /></p>\n<pre><code class=\"language-csharp\">// Dtos/Employee/CreateEmployeeDto.cs\nusing CodeSpirit.Amis.Attributes.FormFields;\nusing CodeSpirit.IdentityApi.Data.Models;\nusing System.ComponentModel;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace CodeSpirit.IdentityApi.Dtos.Employee;\n\n/// &lt;summary&gt;\n/// 创建职工数据传输对象\n/// &lt;/summary&gt;\n[FormGroup(\"basic\", \"基本信息\", \"EmployeeNo,Name,Gender,IdNo,BirthDate\", Order = 1)]\n[FormGroup(\"contact\", \"联系方式\", \"PhoneNumber,Email,Address\", Order = 2)]\n[FormGroup(\"work\", \"工作信息\", \"DepartmentId,Position,JobLevel,HireDate,EmploymentStatus\", Order = 3)]\n[FormGroup(\"relation\", \"关联信息\", \"UserId\", Order = 4)]\n[FormGroup(\"emergency\", \"紧急联系人\", \"EmergencyContact,EmergencyPhone\", Order = 5)]\n[FormGroup(\"other\", \"其他信息\", \"AvatarUrl,Remarks,IsActive\", Order = 6)]\npublic class CreateEmployeeDto\n{\n    /// &lt;summary&gt;\n    /// 工号\n    /// &lt;/summary&gt;\n    [Required(ErrorMessage = \"工号不能为空\")]\n    [MaxLength(50, ErrorMessage = \"工号长度不能超过50个字符\")]\n    [DisplayName(\"工号\")]\n    [AmisInputTextField(ColumnRatio = 6)]\n    public string EmployeeNo { get; set; } = string.Empty;\n\n    /// &lt;summary&gt;\n    /// 姓名\n    /// &lt;/summary&gt;\n    [Required(ErrorMessage = \"姓名不能为空\")]\n    [MaxLength(100, ErrorMessage = \"姓名长度不能超过100个字符\")]\n    [DisplayName(\"姓名\")]\n    [AmisInputTextField(ColumnRatio = 6)]\n    public string Name { get; set; } = string.Empty;\n\n    /// &lt;summary&gt;\n    /// 性别\n    /// &lt;/summary&gt;\n    [DisplayName(\"性别\")]\n    [AmisFormField(ColumnRatio = 6)]\n    public Gender Gender { get; set; }\n\n    /// &lt;summary&gt;\n    /// 身份证号码\n    /// &lt;/summary&gt;\n    [MaxLength(18, ErrorMessage = \"身份证号码长度不能超过18个字符\")]\n    [DisplayName(\"身份证号\")]\n    [AmisInputTextField(ColumnRatio = 6)]\n    public string? IdNo { get; set; }\n\n    /// &lt;summary&gt;\n    /// 出生日期\n    /// &lt;/summary&gt;\n    [DisplayName(\"出生日期\")]\n    [AmisDateFieldAttribute(ColumnRatio = 6)]\n    public DateTime? BirthDate { get; set; }\n\n    /// &lt;summary&gt;\n    /// 手机号码\n    /// &lt;/summary&gt;\n    [MaxLength(15, ErrorMessage = \"手机号码长度不能超过15个字符\")]\n    [Phone(ErrorMessage = \"手机号码格式不正确\")]\n    [DisplayName(\"手机号码\")]\n    [AmisInputTextField(ColumnRatio = 6)]\n    public string? PhoneNumber { get; set; }\n\n    /// &lt;summary&gt;\n    /// 电子邮箱\n    /// &lt;/summary&gt;\n    [MaxLength(100, ErrorMessage = \"电子邮箱长度不能超过100个字符\")]\n    [EmailAddress(ErrorMessage = \"电子邮箱格式不正确\")]\n    [DisplayName(\"电子邮箱\")]\n    [AmisInputTextField(ColumnRatio = 6)]\n    public string? Email { get; set; }\n\n    /// &lt;summary&gt;\n    /// 部门ID\n    /// &lt;/summary&gt;\n    [DisplayName(\"部门\")]\n    [AmisInputTreeField(\n        DataSource = \"${ROOT_API}/api/identity/Departments/tree\",\n        LabelField = \"name\",\n        ValueField = \"id\",\n        Multiple = false,\n        Searchable = true,\n        ColumnRatio = 12\n    )]\n    public long? DepartmentId { get; set; }\n\n    /// &lt;summary&gt;\n    /// 职位\n    /// &lt;/summary&gt;\n    [MaxLength(100, ErrorMessage = \"职位长度不能超过100个字符\")]\n    [DisplayName(\"职位\")]\n    [AmisInputTextField(ColumnRatio = 6)]\n    public string? Position { get; set; }\n\n    /// &lt;summary&gt;\n    /// 职级\n    /// &lt;/summary&gt;\n    [MaxLength(50, ErrorMessage = \"职级长度不能超过50个字符\")]\n    [DisplayName(\"职级\")]\n    [AmisInputTextField(ColumnRatio = 6)]\n    public string? JobLevel { get; set; }\n\n    /// &lt;summary&gt;\n    /// 入职日期\n    /// &lt;/summary&gt;\n    [DisplayName(\"入职日期\")]\n    [AmisDateFieldAttribute(ColumnRatio = 6)]\n    public DateTime? HireDate { get; set; }\n\n    /// &lt;summary&gt;\n    /// 在职状态\n    /// &lt;/summary&gt;\n    [DisplayName(\"在职状态\")]\n    [AmisFormField(ColumnRatio = 6)]\n    public EmploymentStatus EmploymentStatus { get; set; } = EmploymentStatus.Active;\n\n    /// &lt;summary&gt;\n    /// 关联的用户ID\n    /// &lt;/summary&gt;\n    [DisplayName(\"关联用户\")]\n    [AmisSelectField(\n        Source = \"${ROOT_API}/api/identity/Users\",\n        ValueField = \"id\",\n        LabelField = \"name\",\n        Multiple = false,\n        Searchable = true,\n        ColumnRatio = 12\n    )]\n    public long? UserId { get; set; }\n\n    /// &lt;summary&gt;\n    /// 紧急联系人\n    /// &lt;/summary&gt;\n    [MaxLength(100, ErrorMessage = \"紧急联系人长度不能超过100个字符\")]\n    [DisplayName(\"紧急联系人\")]\n    [AmisInputTextField(ColumnRatio = 6)]\n    public string? EmergencyContact { get; set; }\n\n    /// &lt;summary&gt;\n    /// 紧急联系电话\n    /// &lt;/summary&gt;\n    [MaxLength(15, ErrorMessage = \"紧急联系电话长度不能超过15个字符\")]\n    [Phone(ErrorMessage = \"紧急联系电话格式不正确\")]\n    [DisplayName(\"紧急联系电话\")]\n    [AmisInputTextField(ColumnRatio = 6)]\n    public string? EmergencyPhone { get; set; }\n\n    /// &lt;summary&gt;\n    /// 地址\n    /// &lt;/summary&gt;\n    [MaxLength(500, ErrorMessage = \"地址长度不能超过500个字符\")]\n    [DisplayName(\"地址\")]\n    [AmisTextareaField(ColumnRatio = 12)]\n    public string? Address { get; set; }\n\n    /// &lt;summary&gt;\n    /// 头像地址\n    /// &lt;/summary&gt;\n    [MaxLength(255, ErrorMessage = \"头像地址长度不能超过255个字符\")]\n    [DisplayName(\"头像\")]\n    [AmisInputImageField(\n        Receiver = \"/file/api/file/images/upload?BucketName=avatar\",\n        Accept = \"image/png,image/jpeg,image/jpg\",\n        MaxSize = 2097152,\n        Multiple = false,\n        ColumnRatio = 12\n    )]\n    public string? AvatarUrl { get; set; }\n\n    /// &lt;summary&gt;\n    /// 备注\n    /// &lt;/summary&gt;\n    [MaxLength(1000, ErrorMessage = \"备注长度不能超过1000个字符\")]\n    [DisplayName(\"备注\")]\n    [AmisTextareaField(ColumnRatio = 12)]\n    public string? Remarks { get; set; }\n\n    /// &lt;summary&gt;\n    /// 是否激活\n    /// &lt;/summary&gt;\n    [DisplayName(\"是否激活\")]\n    [AmisFormField(ColumnRatio = 6)]\n    public bool IsActive { get; set; } = true;\n}\n</code></pre>\n<p><strong>说明</strong>：</p>\n<p><strong>表单特性（FormFields）</strong>：用于控制前端表单字段的显示和交互</p>\n<ul>\n<li>\n<p><code>FormGroup</code>：表单分组特性，将相关字段组织成组</p>\n<ul>\n<li><code>Name</code>：组名称</li>\n<li><code>Title</code>：组标题</li>\n<li><code>Fields</code>：包含的字段名称（逗号分隔）</li>\n<li><code>Order</code>：显示顺序（数值越小越靠前）</li>\n<li><code>Mode</code>：显示模式（Normal/Inline/Horizontal）</li>\n</ul>\n</li>\n<li>\n<p><code>AmisInputTextField</code>：文本输入框</p>\n<ul>\n<li><code>ColumnRatio</code>：字段宽度比例（12为全宽，6为半宽）</li>\n<li><code>EnableAddOn</code>：是否启用右侧附加组件</li>\n<li><code>AddOnLabel</code>：附加组件标签</li>\n<li><code>AddOnApi</code>：附加组件API地址</li>\n</ul>\n</li>\n<li>\n<p><code>AmisInputTreeField</code>：树形选择组件</p>\n<ul>\n<li><code>DataSource</code>：数据源URL</li>\n<li><code>ValueField</code>：值字段名</li>\n<li><code>LabelField</code>：标签字段名</li>\n<li><code>Multiple</code>：是否多选</li>\n<li><code>Searchable</code>：是否可搜索</li>\n<li><code>ShowOutline</code>：是否显示轮廓</li>\n<li><code>SubmitOnChange</code>：选择后是否自动提交</li>\n</ul>\n</li>\n<li>\n<p><code>AmisSelectField</code>：下拉选择组件</p>\n<ul>\n<li><code>Source</code>：数据源URL</li>\n<li><code>ValueField</code>：值字段名</li>\n<li><code>LabelField</code>：标签字段名</li>\n<li><code>Multiple</code>：是否多选</li>\n<li><code>Searchable</code>：是否可搜索</li>\n<li><code>Clearable</code>：是否可清除</li>\n</ul>\n</li>\n<li>\n<p><code>AmisInputImageField</code>：图片上传组件</p>\n<ul>\n<li><code>Receiver</code>：上传接口地址</li>\n<li><code>Accept</code>：接受的文件类型</li>\n<li><code>MaxSize</code>：最大文件大小（字节）</li>\n<li><code>Multiple</code>：是否支持多文件</li>\n</ul>\n</li>\n<li>\n<p><code>AmisDateFieldAttribute</code>：日期选择组件</p>\n<ul>\n<li><code>Format</code>：日期格式</li>\n<li><code>Placeholder</code>：占位符</li>\n<li><code>MinDate</code>：最小日期</li>\n<li><code>MaxDate</code>：最大日期</li>\n</ul>\n</li>\n<li>\n<p><code>AmisTextareaField</code>：多行文本输入框</p>\n<ul>\n<li><code>MaxLength</code>：最大长度</li>\n<li><code>ShowCounter</code>：是否显示字符计数</li>\n<li><code>Rows</code>：行数</li>\n</ul>\n</li>\n</ul>\n<p><strong>通用属性</strong>：</p>\n<ul>\n<li><code>ColumnRatio</code>：字段宽度比例（12为全宽，6为半宽，4为1/3宽）</li>\n<li><code>Required</code>：是否必填</li>\n<li><code>Placeholder</code>：占位符文本</li>\n<li><code>Disabled</code>：是否禁用</li>\n<li><code>VisibleOn</code>：显示条件表达式</li>\n<li><code>DisabledOn</code>：禁用条件表达式</li>\n</ul>\n<h3 id=\"23-updateemployeedto更新dto\">2.3 UpdateEmployeeDto（更新DTO）</h3>\n<pre><code class=\"language-csharp\">// Dtos/Employee/UpdateEmployeeDto.cs\nusing CodeSpirit.Amis.Attributes.FormFields;\nusing CodeSpirit.IdentityApi.Data.Models;\nusing System.ComponentModel;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace CodeSpirit.IdentityApi.Dtos.Employee;\n\n/// &lt;summary&gt;\n/// 更新职工数据传输对象\n/// &lt;/summary&gt;\n[FormGroup(\"basic\", \"基本信息\", \"EmployeeNo,Name,Gender,IdNo,BirthDate\", Order = 1)]\n[FormGroup(\"contact\", \"联系方式\", \"PhoneNumber,Email,Address\", Order = 2)]\n[FormGroup(\"work\", \"工作信息\", \"DepartmentId,Position,JobLevel,HireDate,TerminationDate,EmploymentStatus\", Order = 3)]\n[FormGroup(\"relation\", \"关联信息\", \"UserId\", Order = 4)]\n[FormGroup(\"emergency\", \"紧急联系人\", \"EmergencyContact,EmergencyPhone\", Order = 5)]\n[FormGroup(\"other\", \"其他信息\", \"AvatarUrl,Remarks,IsActive\", Order = 6)]\npublic class UpdateEmployeeDto\n{\n    /// &lt;summary&gt;\n    /// 工号\n    /// &lt;/summary&gt;\n    [Required(ErrorMessage = \"工号不能为空\")]\n    [MaxLength(50, ErrorMessage = \"工号长度不能超过50个字符\")]\n    [DisplayName(\"工号\")]\n    [AmisInputTextField(ColumnRatio = 6)]\n    public string EmployeeNo { get; set; } = string.Empty;\n\n    /// &lt;summary&gt;\n    /// 姓名\n    /// &lt;/summary&gt;\n    [Required(ErrorMessage = \"姓名不能为空\")]\n    [MaxLength(100, ErrorMessage = \"姓名长度不能超过100个字符\")]\n    [DisplayName(\"姓名\")]\n    [AmisInputTextField(ColumnRatio = 6)]\n    public string Name { get; set; } = string.Empty;\n\n    /// &lt;summary&gt;\n    /// 性别\n    /// &lt;/summary&gt;\n    [DisplayName(\"性别\")]\n    [AmisFormField(ColumnRatio = 6)]\n    public Gender Gender { get; set; }\n\n    /// &lt;summary&gt;\n    /// 身份证号码\n    /// &lt;/summary&gt;\n    [MaxLength(18, ErrorMessage = \"身份证号码长度不能超过18个字符\")]\n    [DisplayName(\"身份证号\")]\n    [AmisInputTextField(ColumnRatio = 6)]\n    public string? IdNo { get; set; }\n\n    /// &lt;summary&gt;\n    /// 出生日期\n    /// &lt;/summary&gt;\n    [DisplayName(\"出生日期\")]\n    [AmisDateFieldAttribute(ColumnRatio = 6)]\n    public DateTime? BirthDate { get; set; }\n\n    /// &lt;summary&gt;\n    /// 手机号码\n    /// &lt;/summary&gt;\n    [MaxLength(15, ErrorMessage = \"手机号码长度不能超过15个字符\")]\n    [Phone(ErrorMessage = \"手机号码格式不正确\")]\n    [DisplayName(\"手机号码\")]\n    [AmisInputTextField(ColumnRatio = 6)]\n    public string? PhoneNumber { get; set; }\n\n    /// &lt;summary&gt;\n    /// 电子邮箱\n    /// &lt;/summary&gt;\n    [MaxLength(100, ErrorMessage = \"电子邮箱长度不能超过100个字符\")]\n    [EmailAddress(ErrorMessage = \"电子邮箱格式不正确\")]\n    [DisplayName(\"电子邮箱\")]\n    [AmisInputTextField(ColumnRatio = 6)]\n    public string? Email { get; set; }\n\n    /// &lt;summary&gt;\n    /// 部门ID\n    /// &lt;/summary&gt;\n    [DisplayName(\"部门\")]\n    [AmisInputTreeField(\n        DataSource = \"${ROOT_API}/api/identity/Departments/tree\",\n        LabelField = \"name\",\n        ValueField = \"id\",\n        Multiple = false,\n        Searchable = true,\n        ColumnRatio = 12\n    )]\n    public long? DepartmentId { get; set; }\n\n    /// &lt;summary&gt;\n    /// 职位\n    /// &lt;/summary&gt;\n    [MaxLength(100, ErrorMessage = \"职位长度不能超过100个字符\")]\n    [DisplayName(\"职位\")]\n    [AmisInputTextField(ColumnRatio = 6)]\n    public string? Position { get; set; }\n\n    /// &lt;summary&gt;\n    /// 职级\n    /// &lt;/summary&gt;\n    [MaxLength(50, ErrorMessage = \"职级长度不能超过50个字符\")]\n    [DisplayName(\"职级\")]\n    [AmisInputTextField(ColumnRatio = 6)]\n    public string? JobLevel { get; set; }\n\n    /// &lt;summary&gt;\n    /// 入职日期\n    /// &lt;/summary&gt;\n    [DisplayName(\"入职日期\")]\n    [AmisDateFieldAttribute(ColumnRatio = 6)]\n    public DateTime? HireDate { get; set; }\n\n    /// &lt;summary&gt;\n    /// 离职日期\n    /// &lt;/summary&gt;\n    [DisplayName(\"离职日期\")]\n    [AmisDateFieldAttribute(ColumnRatio = 6)]\n    public DateTime? TerminationDate { get; set; }\n\n    /// &lt;summary&gt;\n    /// 在职状态\n    /// &lt;/summary&gt;\n    [DisplayName(\"在职状态\")]\n    [AmisFormField(ColumnRatio = 12)]\n    public EmploymentStatus EmploymentStatus { get; set; }\n\n    /// &lt;summary&gt;\n    /// 关联的用户ID\n    /// &lt;/summary&gt;\n    [DisplayName(\"关联用户\")]\n    [AmisSelectField(\n        Source = \"${ROOT_API}/api/identity/Users\",\n        ValueField = \"id\",\n        LabelField = \"name\",\n        Multiple = false,\n        Searchable = true,\n        ColumnRatio = 12\n    )]\n    public long? UserId { get; set; }\n\n    /// &lt;summary&gt;\n    /// 紧急联系人\n    /// &lt;/summary&gt;\n    [MaxLength(100, ErrorMessage = \"紧急联系人长度不能超过100个字符\")]\n    [DisplayName(\"紧急联系人\")]\n    [AmisInputTextField(ColumnRatio = 6)]\n    public string? EmergencyContact { get; set; }\n\n    /// &lt;summary&gt;\n    /// 紧急联系电话\n    /// &lt;/summary&gt;\n    [MaxLength(15, ErrorMessage = \"紧急联系电话长度不能超过15个字符\")]\n    [Phone(ErrorMessage = \"紧急联系电话格式不正确\")]\n    [DisplayName(\"紧急联系电话\")]\n    [AmisInputTextField(ColumnRatio = 6)]\n    public string? EmergencyPhone { get; set; }\n\n    /// &lt;summary&gt;\n    /// 地址\n    /// &lt;/summary&gt;\n    [MaxLength(500, ErrorMessage = \"地址长度不能超过500个字符\")]\n    [DisplayName(\"地址\")]\n    [AmisTextareaField(ColumnRatio = 12)]\n    public string? Address { get; set; }\n\n    /// &lt;summary&gt;\n    /// 头像地址\n    /// &lt;/summary&gt;\n    [MaxLength(255, ErrorMessage = \"头像地址长度不能超过255个字符\")]\n    [DisplayName(\"头像\")]\n    [AmisInputImageField(\n        Receiver = \"/file/api/file/images/upload?BucketName=avatar\",\n        Accept = \"image/png,image/jpeg,image/jpg\",\n        MaxSize = 2097152,\n        Multiple = false,\n        ColumnRatio = 12\n    )]\n    public string? AvatarUrl { get; set; }\n\n    /// &lt;summary&gt;\n    /// 备注\n    /// &lt;/summary&gt;\n    [MaxLength(1000, ErrorMessage = \"备注长度不能超过1000个字符\")]\n    [DisplayName(\"备注\")]\n    [AmisTextareaField(ColumnRatio = 12)]\n    public string? Remarks { get; set; }\n\n    /// &lt;summary&gt;\n    /// 是否激活\n    /// &lt;/summary&gt;\n    [DisplayName(\"是否激活\")]\n    [AmisFormField(ColumnRatio = 6)]\n    public bool IsActive { get; set; }\n}\n</code></pre>\n<h3 id=\"24-employeequerydto查询dto\">2.4 EmployeeQueryDto（查询DTO）</h3>\n<pre><code class=\"language-csharp\">// Dtos/Employee/EmployeeQueryDto.cs\nusing CodeSpirit.Amis.Attributes.FormFields;\nusing CodeSpirit.Core.Dtos;\nusing CodeSpirit.IdentityApi.Data.Models;\nusing System.ComponentModel;\n\nnamespace CodeSpirit.IdentityApi.Dtos.Employee;\n\n/// &lt;summary&gt;\n/// 职工查询数据传输对象\n/// &lt;/summary&gt;\npublic class EmployeeQueryDto : QueryDtoBase\n{\n    /// &lt;summary&gt;\n    /// 关键字搜索（姓名、工号、身份证、手机、邮箱）\n    /// &lt;/summary&gt;\n    [DisplayName(\"关键字\")]\n    public string? Keywords { get; set; }\n\n    /// &lt;summary&gt;\n    /// 是否激活\n    /// &lt;/summary&gt;\n    [DisplayName(\"是否激活\")]\n    public bool? IsActive { get; set; }\n\n    /// &lt;summary&gt;\n    /// 性别筛选\n    /// &lt;/summary&gt;\n    [DisplayName(\"性别\")]\n    public Gender? Gender { get; set; }\n\n    /// &lt;summary&gt;\n    /// 部门ID筛选\n    /// &lt;/summary&gt;\n    [DisplayName(\"部门\")]\n    [AmisInputTreeField(\n        DataSource = \"${ROOT_API}/api/identity/Departments/tree\",\n        Multiple = false,\n        JoinValues = true,\n        ExtractValue = false,\n        ShowOutline = true,\n        LabelField = \"name\",\n        ValueField = \"id\",\n        Required = false,\n        Clearable = true,\n        SubmitOnChange = true,\n        HeightAuto = true,\n        SelectFirst = false,\n        InputOnly = true,\n        ShowIcon = true\n    )]\n    [PageAside()]\n    public long? DepartmentId { get; set; }\n\n    /// &lt;summary&gt;\n    /// 在职状态筛选\n    /// &lt;/summary&gt;\n    [DisplayName(\"在职状态\")]\n    public EmploymentStatus? EmploymentStatus { get; set; }\n\n    /// &lt;summary&gt;\n    /// 入职日期范围\n    /// &lt;/summary&gt;\n    [DisplayName(\"入职日期\")]\n    public DateTime[]? HireDate { get; set; }\n\n    /// &lt;summary&gt;\n    /// 职位\n    /// &lt;/summary&gt;\n    [DisplayName(\"职位\")]\n    public string? Position { get; set; }\n\n    /// &lt;summary&gt;\n    /// 职级\n    /// &lt;/summary&gt;\n    [DisplayName(\"职级\")]\n    public string? JobLevel { get; set; }\n}\n</code></pre>\n<p><strong>说明</strong>：</p>\n<p><strong>查询DTO特性</strong>：</p>\n<ul>\n<li>\n<p><code>QueryDtoBase</code>：基础查询DTO，提供了<code>Page</code>、<code>PerPage</code>、<code>OrderBy</code>、<code>OrderDir</code>、<code>Keywords</code>等分页和排序属性</p>\n</li>\n<li>\n<p><code>AmisInputTreeField</code>：树形选择组件（用于查询表单）</p>\n<ul>\n<li><code>DataSource</code>：数据源URL</li>\n<li><code>SubmitOnChange</code>：选择后自动提交查询</li>\n<li><code>Searchable</code>：是否可搜索</li>\n<li><code>Clearable</code>：是否可清除</li>\n<li><code>ShowOutline</code>：是否显示轮廓</li>\n<li><code>HeightAuto</code>：高度自适应</li>\n</ul>\n</li>\n<li>\n<p><strong><code>PageAside()</code>特性</strong>：标记该字段在页面侧边栏显示</p>\n<ul>\n<li>标记了此特性的字段会自动从主查询表单中排除，避免重复显示</li>\n<li>特别适用于树形选择、分类筛选等需要独立展示的字段</li>\n<li>侧边栏字段的变化会自动触发主内容区域的查询刷新（通过<code>SubmitOnChange</code>配置）</li>\n<li>可以配置侧边栏的位置（左侧/右侧）、宽度、是否固定等属性</li>\n</ul>\n</li>\n</ul>\n<p><strong>查询字段特性</strong>：</p>\n<ul>\n<li>查询DTO中的字段可以使用表单特性（如<code>AmisInputTreeField</code>、<code>AmisSelectField</code>等）来配置查询表单的显示</li>\n<li>支持多条件组合查询，提升查询灵活性</li>\n<li>枚举类型字段会自动生成下拉选择组件</li>\n<li>日期类型字段可以使用<code>AmisDateFieldAttribute</code>配置日期范围选择</li>\n</ul>\n<h2 id=\"3-配置automapper映射\">3. 配置AutoMapper映射</h2>\n<p>在<code>MappingProfiles</code>目录下创建映射配置：</p>\n<pre><code class=\"language-csharp\">// MappingProfiles/EmployeeProfile.cs\nusing AutoMapper;\nusing CodeSpirit.IdentityApi.Data.Models;\nusing CodeSpirit.IdentityApi.Dtos.Employee;\nusing CodeSpirit.Shared.Extensions;\n\nnamespace CodeSpirit.IdentityApi.MappingProfiles;\n\n/// &lt;summary&gt;\n/// 职工映射配置\n/// &lt;/summary&gt;\npublic class EmployeeProfile : Profile\n{\n    /// &lt;summary&gt;\n    /// 构造函数\n    /// &lt;/summary&gt;\n    public EmployeeProfile()\n    {\n        // 使用扩展方法配置基本CRUD映射（自动处理Include导航属性）\n        this.ConfigureBaseCRUDIMappings&lt;\n            Employee, \n            EmployeeDto, \n            long, \n            CreateEmployeeDto, \n            UpdateEmployeeDto,\n            CreateEmployeeDto&gt;();\n            \n        // 自定义映射：映射部门名称和用户名\n        CreateMap&lt;Employee, EmployeeDto&gt;()\n            .ForMember(dest =&gt; dest.DepartmentName, opt =&gt; opt.MapFrom(src =&gt; src.Department != null ? src.Department.Name : null))\n            .ForMember(dest =&gt; dest.UserName, opt =&gt; opt.MapFrom(src =&gt; src.User != null ? src.User.UserName : null));\n    }\n}\n</code></pre>\n<p><strong>说明</strong>：</p>\n<ul>\n<li><code>ConfigureBaseCRUDIMappings</code>扩展方法自动配置基本的CRUD映射</li>\n<li>使用<code>ForMember</code>自定义字段映射逻辑，将导航属性映射到DTO</li>\n<li>支持多个DTO类型的映射配置</li>\n</ul>\n<h2 id=\"4-创建服务接口和实现\">4. 创建服务接口和实现</h2>\n<h3 id=\"41-服务接口\">4.1 服务接口</h3>\n<pre><code class=\"language-csharp\">// Services/IEmployeeService.cs\nusing CodeSpirit.Core;\nusing CodeSpirit.IdentityApi.Data.Models;\nusing CodeSpirit.IdentityApi.Dtos.Employee;\nusing CodeSpirit.Shared.Services;\n\nnamespace CodeSpirit.IdentityApi.Services;\n\n/// &lt;summary&gt;\n/// 职工服务接口\n/// &lt;/summary&gt;\npublic interface IEmployeeService : IBaseCRUDIService&lt;Employee, EmployeeDto, long, CreateEmployeeDto, UpdateEmployeeDto, EmployeeBatchImportItemDto&gt;, IScopedDependency\n{\n    /// &lt;summary&gt;\n    /// 获取职工列表（分页）\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"queryDto\"&gt;查询条件&lt;/param&gt;\n    /// &lt;returns&gt;职工分页列表&lt;/returns&gt;\n    Task&lt;PageList&lt;EmployeeDto&gt;&gt; GetEmployeesAsync(EmployeeQueryDto queryDto);\n\n    /// &lt;summary&gt;\n    /// 根据部门获取职工列表\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"departmentId\"&gt;部门ID&lt;/param&gt;\n    /// &lt;param name=\"includeSubDepartments\"&gt;是否包含子部门&lt;/param&gt;\n    /// &lt;returns&gt;职工列表&lt;/returns&gt;\n    Task&lt;List&lt;EmployeeDto&gt;&gt; GetEmployeesByDepartmentAsync(long departmentId, bool includeSubDepartments = false);\n\n    /// &lt;summary&gt;\n    /// 设置职工激活状态\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"id\"&gt;职工ID&lt;/param&gt;\n    /// &lt;param name=\"isActive\"&gt;是否激活&lt;/param&gt;\n    Task SetActiveStatusAsync(long id, bool isActive);\n\n    /// &lt;summary&gt;\n    /// 转移职工到新部门\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"employeeId\"&gt;职工ID&lt;/param&gt;\n    /// &lt;param name=\"newDepartmentId\"&gt;新部门ID&lt;/param&gt;\n    Task TransferEmployeeAsync(long employeeId, long? newDepartmentId);\n\n    /// &lt;summary&gt;\n    /// 办理职工离职\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"employeeId\"&gt;职工ID&lt;/param&gt;\n    /// &lt;param name=\"terminationDate\"&gt;离职日期&lt;/param&gt;\n    Task TerminateEmployeeAsync(long employeeId, DateTime terminationDate);\n\n    /// &lt;summary&gt;\n    /// 验证工号是否唯一\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"employeeNo\"&gt;工号&lt;/param&gt;\n    /// &lt;param name=\"excludeId\"&gt;排除的职工ID（用于更新时验证）&lt;/param&gt;\n    /// &lt;returns&gt;是否唯一&lt;/returns&gt;\n    Task&lt;bool&gt; IsEmployeeNoUniqueAsync(string employeeNo, long? excludeId = null);\n}\n</code></pre>\n<h3 id=\"42-服务实现\">4.2 服务实现</h3>\n<pre><code class=\"language-csharp\">// Services/EmployeeService.cs\nusing AutoMapper;\nusing CodeSpirit.Core;\nusing CodeSpirit.Core.IdGenerator;\nusing CodeSpirit.IdentityApi.Data;\nusing CodeSpirit.IdentityApi.Data.Models;\nusing CodeSpirit.IdentityApi.Dtos.Employee;\nusing CodeSpirit.IdentityApi.Utilities;\nusing CodeSpirit.Shared.Repositories;\nusing CodeSpirit.Shared.Services;\nusing CodeSpirit.Shared.Dtos.Common;\nusing LinqKit;\nusing Microsoft.AspNetCore.Identity;\nusing Microsoft.EntityFrameworkCore;\n\nnamespace CodeSpirit.IdentityApi.Services;\n\n/// &lt;summary&gt;\n/// 职工服务实现\n/// &lt;/summary&gt;\npublic class EmployeeService : BaseCRUDIService&lt;Employee, EmployeeDto, long, CreateEmployeeDto, UpdateEmployeeDto, EmployeeBatchImportItemDto&gt;, IEmployeeService\n{\n    private readonly IRepository&lt;Employee&gt; _employeeRepository;\n    private readonly IRepository&lt;Department&gt; _departmentRepository;\n    private readonly IRepository&lt;ApplicationUser&gt; _userRepository;\n    private readonly ILogger&lt;EmployeeService&gt; _logger;\n    private readonly IIdGenerator _idGenerator;\n    private readonly ICurrentUser _currentUser;\n    private readonly ApplicationDbContext _dbContext;\n    private readonly IDepartmentService _departmentService;\n    private readonly UserManager&lt;ApplicationUser&gt; _userManager;\n\n    /// &lt;summary&gt;\n    /// 构造函数\n    /// &lt;/summary&gt;\n    public EmployeeService(\n        IRepository&lt;Employee&gt; employeeRepository,\n        IRepository&lt;Department&gt; departmentRepository,\n        IRepository&lt;ApplicationUser&gt; userRepository,\n        IMapper mapper,\n        ILogger&lt;EmployeeService&gt; logger,\n        IIdGenerator idGenerator,\n        ICurrentUser currentUser,\n        ApplicationDbContext dbContext,\n        IDepartmentService departmentService,\n        UserManager&lt;ApplicationUser&gt; userManager,\n        EnhancedBatchImportHelper&lt;EmployeeBatchImportItemDto&gt; importHelper)\n        : base(employeeRepository, mapper, importHelper)\n    {\n        _employeeRepository = employeeRepository;\n        _departmentRepository = departmentRepository;\n        _userRepository = userRepository;\n        _logger = logger;\n        _idGenerator = idGenerator;\n        _currentUser = currentUser;\n        _dbContext = dbContext;\n        _departmentService = departmentService;\n        _userManager = userManager;\n    }\n\n    /// &lt;summary&gt;\n    /// 获取职工列表（分页）\n    /// &lt;/summary&gt;\n    public async Task&lt;PageList&lt;EmployeeDto&gt;&gt; GetEmployeesAsync(EmployeeQueryDto queryDto)\n    {\n        var predicate = PredicateBuilder.New&lt;Employee&gt;(true);\n\n        // 应用搜索关键词过滤\n        if (!string.IsNullOrWhiteSpace(queryDto.Keywords))\n        {\n            string searchLower = queryDto.Keywords.ToLower();\n            predicate = predicate.Or(e =&gt; e.Name.ToLower().Contains(searchLower));\n            predicate = predicate.Or(e =&gt; e.EmployeeNo.ToLower().Contains(searchLower));\n            predicate = predicate.Or(e =&gt; e.IdNo.Contains(queryDto.Keywords));\n            predicate = predicate.Or(e =&gt; e.PhoneNumber.Contains(queryDto.Keywords));\n            predicate = predicate.Or(e =&gt; e.Email.ToLower().Contains(searchLower));\n        }\n\n        // 应用其他过滤条件\n        if (queryDto.IsActive.HasValue)\n        {\n            predicate = predicate.And(e =&gt; e.IsActive == queryDto.IsActive.Value);\n        }\n\n        if (queryDto.Gender.HasValue)\n        {\n            predicate = predicate.And(e =&gt; e.Gender == queryDto.Gender.Value);\n        }\n\n        if (queryDto.DepartmentId.HasValue)\n        {\n            predicate = predicate.And(e =&gt; e.DepartmentId == queryDto.DepartmentId.Value);\n        }\n\n        if (queryDto.EmploymentStatus.HasValue)\n        {\n            predicate = predicate.And(e =&gt; e.EmploymentStatus == queryDto.EmploymentStatus.Value);\n        }\n\n        if (!string.IsNullOrWhiteSpace(queryDto.Position))\n        {\n            predicate = predicate.And(e =&gt; e.Position == queryDto.Position);\n        }\n\n        if (!string.IsNullOrWhiteSpace(queryDto.JobLevel))\n        {\n            predicate = predicate.And(e =&gt; e.JobLevel == queryDto.JobLevel);\n        }\n\n        if (queryDto.HireDate != null &amp;&amp; queryDto.HireDate.Length == 2)\n        {\n            predicate = predicate.And(e =&gt; e.HireDate &gt;= queryDto.HireDate[0]);\n            predicate = predicate.And(e =&gt; e.HireDate &lt;= queryDto.HireDate[1]);\n        }\n\n        // 创建查询\n        var query = _employeeRepository.CreateQuery()\n            .Include(e =&gt; e.Department)\n            .Include(e =&gt; e.User)\n            .Where(predicate);\n\n        // 执行分页查询\n        var totalCount = await query.CountAsync();\n        var employees = await query\n            .OrderByDescending(e =&gt; e.CreatedAt)\n            .Skip((queryDto.Page - 1) * queryDto.PerPage)\n            .Take(queryDto.PerPage)\n            .ToListAsync();\n\n        // 映射到DTO\n        var employeeDtos = Mapper.Map&lt;List&lt;EmployeeDto&gt;&gt;(employees);\n\n        // 设置关联数据\n        foreach (var dto in employeeDtos)\n        {\n            var employee = employees.First(e =&gt; e.Id == dto.Id);\n            dto.DepartmentName = employee.Department?.Name;\n            dto.UserName = employee.User?.UserName;\n        }\n\n        return new PageList&lt;EmployeeDto&gt;(employeeDtos, totalCount);\n    }\n\n    /// &lt;summary&gt;\n    /// 根据部门获取职工列表\n    /// &lt;/summary&gt;\n    public async Task&lt;List&lt;EmployeeDto&gt;&gt; GetEmployeesByDepartmentAsync(long departmentId, bool includeSubDepartments = false)\n    {\n        var departmentIds = new List&lt;long&gt; { departmentId };\n        \n        if (includeSubDepartments)\n        {\n            var subDepartments = await _departmentService.GetSubDepartmentsAsync(departmentId);\n            departmentIds.AddRange(subDepartments.Select(d =&gt; d.Id));\n        }\n\n        var employees = await _employeeRepository.CreateQuery()\n            .Include(e =&gt; e.Department)\n            .Include(e =&gt; e.User)\n            .Where(e =&gt; departmentIds.Contains(e.DepartmentId ?? 0))\n            .ToListAsync();\n\n        return Mapper.Map&lt;List&lt;EmployeeDto&gt;&gt;(employees);\n    }\n\n    /// &lt;summary&gt;\n    /// 设置职工激活状态\n    /// &lt;/summary&gt;\n    public async Task SetActiveStatusAsync(long id, bool isActive)\n    {\n        var employee = await _employeeRepository.GetByIdAsync(id);\n        if (employee == null)\n        {\n            throw new AppServiceException(404, \"职工不存在\");\n        }\n\n        employee.IsActive = isActive;\n        await _employeeRepository.UpdateAsync(employee);\n    }\n\n    /// &lt;summary&gt;\n    /// 转移职工到新部门\n    /// &lt;/summary&gt;\n    public async Task TransferEmployeeAsync(long employeeId, long? newDepartmentId)\n    {\n        var employee = await _employeeRepository.GetByIdAsync(employeeId);\n        if (employee == null)\n        {\n            throw new AppServiceException(404, \"职工不存在\");\n        }\n\n        if (newDepartmentId.HasValue)\n        {\n            var departmentExists = await _departmentRepository.ExistsAsync(d =&gt; d.Id == newDepartmentId.Value);\n            if (!departmentExists)\n            {\n                throw new AppServiceException(400, \"部门不存在\");\n            }\n        }\n\n        employee.DepartmentId = newDepartmentId;\n        await _employeeRepository.UpdateAsync(employee);\n    }\n\n    /// &lt;summary&gt;\n    /// 办理职工离职\n    /// &lt;/summary&gt;\n    public async Task TerminateEmployeeAsync(long employeeId, DateTime terminationDate)\n    {\n        var employee = await _employeeRepository.GetByIdAsync(employeeId);\n        if (employee == null)\n        {\n            throw new AppServiceException(404, \"职工不存在\");\n        }\n\n        employee.EmploymentStatus = EmploymentStatus.Resigned;\n        employee.TerminationDate = terminationDate;\n        employee.IsActive = false;\n        \n        await _employeeRepository.UpdateAsync(employee);\n    }\n\n    /// &lt;summary&gt;\n    /// 验证工号是否唯一\n    /// &lt;/summary&gt;\n    public async Task&lt;bool&gt; IsEmployeeNoUniqueAsync(string employeeNo, long? excludeId = null)\n    {\n        var query = _employeeRepository.CreateQuery()\n            .Where(e =&gt; e.EmployeeNo == employeeNo &amp;&amp; e.TenantId == _currentUser.TenantId);\n\n        if (excludeId.HasValue)\n        {\n            query = query.Where(e =&gt; e.Id != excludeId.Value);\n        }\n\n        return !await query.AnyAsync();\n    }\n\n    /// &lt;summary&gt;\n    /// 验证创建DTO\n    /// &lt;/summary&gt;\n    protected override async Task ValidateCreateDto(CreateEmployeeDto createDto)\n    {\n        await base.ValidateCreateDto(createDto);\n\n        // 验证工号唯一性\n        bool isUnique = await IsEmployeeNoUniqueAsync(createDto.EmployeeNo);\n        if (!isUnique)\n        {\n            throw new AppServiceException(400, $\"工号 {createDto.EmployeeNo} 已存在，请使用其他工号\");\n        }\n\n        // 验证部门是否存在\n        if (createDto.DepartmentId.HasValue)\n        {\n            var departmentExists = await _departmentRepository.ExistsAsync(d =&gt; d.Id == createDto.DepartmentId.Value);\n            if (!departmentExists)\n            {\n                throw new AppServiceException(400, \"部门不存在\");\n            }\n        }\n\n        // 验证用户是否存在（如果指定了用户ID）\n        if (createDto.UserId.HasValue)\n        {\n            var userExists = await _userRepository.ExistsAsync(u =&gt; u.Id == createDto.UserId.Value);\n            if (!userExists)\n            {\n                throw new AppServiceException(400, \"用户不存在\");\n            }\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// 验证更新DTO\n    /// &lt;/summary&gt;\n    protected override async Task ValidateUpdateDto(long id, UpdateEmployeeDto updateDto)\n    {\n        await base.ValidateUpdateDto(id, updateDto);\n\n        // 验证工号唯一性（排除当前记录）\n        bool isUnique = await IsEmployeeNoUniqueAsync(updateDto.EmployeeNo, id);\n        if (!isUnique)\n        {\n            throw new AppServiceException(400, $\"工号 {updateDto.EmployeeNo} 已存在，请使用其他工号\");\n        }\n\n        // 验证部门是否存在\n        if (updateDto.DepartmentId.HasValue)\n        {\n            var departmentExists = await _departmentRepository.ExistsAsync(d =&gt; d.Id == updateDto.DepartmentId.Value);\n            if (!departmentExists)\n            {\n                throw new AppServiceException(400, \"部门不存在\");\n            }\n        }\n\n        // 验证用户是否存在（如果指定了用户ID）\n        if (updateDto.UserId.HasValue)\n        {\n            var userExists = await _userRepository.ExistsAsync(u =&gt; u.Id == updateDto.UserId.Value);\n            if (!userExists)\n            {\n                throw new AppServiceException(400, \"用户不存在\");\n            }\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// 创建实体前的处理\n    /// &lt;/summary&gt;\n    protected override async Task&lt;Employee&gt; OnCreating(CreateEmployeeDto createDto)\n    {\n        var employee = await base.OnCreating(createDto);\n        \n        // 设置租户ID\n        employee.TenantId = _currentUser.TenantId;\n        \n        // 生成ID（如果需要）\n        if (employee.Id == 0)\n        {\n            employee.Id = await _idGenerator.GenerateIdAsync();\n        }\n\n        return employee;\n    }\n}\n</code></pre>\n<p><strong>说明</strong>：</p>\n<ul>\n<li>继承自<code>BaseCRUDIService</code>，自动获得标准的CRUD方法和批量导入功能</li>\n<li>实现<code>IScopedDependency</code>接口，服务会自动注册</li>\n<li>重写<code>ValidateCreateDto</code>和<code>ValidateUpdateDto</code>方法实现业务验证（工号唯一性、部门存在性等）</li>\n<li>重写<code>OnCreating</code>方法设置租户ID和生成ID</li>\n<li>使用<code>LinqKit</code>的<code>PredicateBuilder</code>构建动态查询条件</li>\n<li>提供额外的业务方法（设置激活状态、转移部门、办理离职等）</li>\n</ul>\n<h2 id=\"5-创建控制器\">5. 创建控制器</h2>\n<p>在<code>Controllers</code>目录下创建控制器：</p>\n<pre><code class=\"language-csharp\">// Controllers/EmployeesController.cs\nusing CodeSpirit.Core;\nusing CodeSpirit.Core.Attributes;\nusing CodeSpirit.Core.Dtos;\nusing CodeSpirit.Core.Enums;\nusing CodeSpirit.IdentityApi.Dtos.Employee;\nusing CodeSpirit.IdentityApi.Services;\nusing CodeSpirit.Shared.Dtos.Common;\nusing Microsoft.AspNetCore.Mvc;\nusing System.ComponentModel;\n\nnamespace CodeSpirit.IdentityApi.Controllers;\n\n/// &lt;summary&gt;\n/// 职工管理控制器\n/// &lt;/summary&gt;\n[DisplayName(\"职工管理\")]\n[Navigation(Icon = \"fa-solid fa-user-tie\", PlatformType = PlatformType.Tenant)]\npublic class EmployeesController : ApiControllerBase\n{\n    private readonly IEmployeeService _employeeService;\n\n    /// &lt;summary&gt;\n    /// 构造函数\n    /// &lt;/summary&gt;\n    public EmployeesController(IEmployeeService employeeService)\n    {\n        _employeeService = employeeService;\n    }\n\n    /// &lt;summary&gt;\n    /// 获取职工列表\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"queryDto\"&gt;查询条件&lt;/param&gt;\n    /// &lt;returns&gt;职工列表结果&lt;/returns&gt;\n    [HttpGet]\n    [DisplayName(\"获取职工列表\")]\n    public async Task&lt;ActionResult&lt;ApiResponse&lt;PageList&lt;EmployeeDto&gt;&gt;&gt;&gt; GetEmployees([FromQuery] EmployeeQueryDto queryDto)\n    {\n        var employees = await _employeeService.GetEmployeesAsync(queryDto);\n        return SuccessResponse(employees);\n    }\n\n    /// &lt;summary&gt;\n    /// 根据部门获取职工列表\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"departmentId\"&gt;部门ID&lt;/param&gt;\n    /// &lt;param name=\"includeSubDepartments\"&gt;是否包含子部门&lt;/param&gt;\n    /// &lt;returns&gt;职工列表&lt;/returns&gt;\n    [HttpGet(\"department/{departmentId}\")]\n    [DisplayName(\"根据部门获取职工\")]\n    public async Task&lt;ActionResult&lt;ApiResponse&lt;List&lt;EmployeeDto&gt;&gt;&gt;&gt; GetEmployeesByDepartment(\n        long departmentId, \n        [FromQuery] bool includeSubDepartments = false)\n    {\n        var employees = await _employeeService.GetEmployeesByDepartmentAsync(departmentId, includeSubDepartments);\n        return SuccessResponse(employees);\n    }\n\n    /// &lt;summary&gt;\n    /// 获取职工详情\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"id\"&gt;职工ID&lt;/param&gt;\n    /// &lt;returns&gt;职工详细信息&lt;/returns&gt;\n    [HttpGet(\"{id:long}\")]\n    [DisplayName(\"获取职工详情\")]\n    public async Task&lt;ActionResult&lt;ApiResponse&lt;EmployeeDto&gt;&gt;&gt; GetEmployee(long id)\n    {\n        var employee = await _employeeService.GetAsync(id);\n        return SuccessResponse(employee);\n    }\n\n    /// &lt;summary&gt;\n    /// 创建职工\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"createDto\"&gt;创建职工请求数据&lt;/param&gt;\n    /// &lt;returns&gt;创建的职工信息&lt;/returns&gt;\n    [HttpPost]\n    [DisplayName(\"创建职工\")]\n    public async Task&lt;ActionResult&lt;ApiResponse&lt;EmployeeDto&gt;&gt;&gt; CreateEmployee(CreateEmployeeDto createDto)\n    {\n        ArgumentNullException.ThrowIfNull(createDto);\n        var employeeDto = await _employeeService.CreateAsync(createDto);\n        return SuccessResponse(employeeDto);\n    }\n\n    /// &lt;summary&gt;\n    /// 更新职工\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"id\"&gt;职工ID&lt;/param&gt;\n    /// &lt;param name=\"updateDto\"&gt;更新职工请求数据&lt;/param&gt;\n    /// &lt;returns&gt;更新操作结果&lt;/returns&gt;\n    [HttpPut(\"{id:long}\")]\n    [DisplayName(\"更新职工\")]\n    public async Task&lt;ActionResult&lt;ApiResponse&gt;&gt; UpdateEmployee(long id, UpdateEmployeeDto updateDto)\n    {\n        await _employeeService.UpdateAsync(id, updateDto);\n        return SuccessResponse();\n    }\n\n    /// &lt;summary&gt;\n    /// 删除职工\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"id\"&gt;职工ID&lt;/param&gt;\n    /// &lt;returns&gt;删除操作结果&lt;/returns&gt;\n    [HttpDelete(\"{id:long}\")]\n    [Operation(\"删除\", \"ajax\", null, \"确定要删除此职工吗？\")]\n    [DisplayName(\"删除职工\")]\n    public async Task&lt;ActionResult&lt;ApiResponse&gt;&gt; DeleteEmployee(long id)\n    {\n        await _employeeService.DeleteAsync(id);\n        return SuccessResponse();\n    }\n\n    /// &lt;summary&gt;\n    /// 批量删除职工\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"request\"&gt;批量删除请求&lt;/param&gt;\n    /// &lt;returns&gt;批量删除操作结果&lt;/returns&gt;\n    [HttpPost(\"batch-delete\")]\n    [Operation(\"批量删除\", \"ajax\", null, \"确定要批量删除选中的职工吗？\", isBulkOperation: true)]\n    [DisplayName(\"批量删除职工\")]\n    public async Task&lt;ActionResult&lt;ApiResponse&gt;&gt; BatchDeleteEmployees([FromBody] BatchOperationDto&lt;long&gt; request)\n    {\n        ArgumentNullException.ThrowIfNull(request);\n        (int successCount, List&lt;long&gt; failedIds) = await _employeeService.BatchDeleteAsync(request.Ids);\n        \n        return failedIds.Any()\n            ? SuccessResponse($\"成功删除 {successCount} 个职工，但以下职工删除失败: {string.Join(\", \", failedIds)}\")\n            : SuccessResponse($\"成功删除 {successCount} 个职工！\");\n    }\n\n    /// &lt;summary&gt;\n    /// 设置职工激活状态\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"id\"&gt;职工ID&lt;/param&gt;\n    /// &lt;param name=\"isActive\"&gt;是否激活&lt;/param&gt;\n    /// &lt;returns&gt;操作结果&lt;/returns&gt;\n    [HttpPut(\"{id:long}/active\")]\n    [DisplayName(\"设置激活状态\")]\n    public async Task&lt;ActionResult&lt;ApiResponse&gt;&gt; SetActiveStatus(long id, [FromBody] bool isActive)\n    {\n        await _employeeService.SetActiveStatusAsync(id, isActive);\n        return SuccessResponse();\n    }\n\n    /// &lt;summary&gt;\n    /// 转移职工到新部门\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"id\"&gt;职工ID&lt;/param&gt;\n    /// &lt;param name=\"request\"&gt;转移请求&lt;/param&gt;\n    /// &lt;returns&gt;操作结果&lt;/returns&gt;\n    [HttpPut(\"{id:long}/transfer\")]\n    [DisplayName(\"转移部门\")]\n    public async Task&lt;ActionResult&lt;ApiResponse&gt;&gt; TransferEmployee(long id, [FromBody] TransferEmployeeRequest request)\n    {\n        await _employeeService.TransferEmployeeAsync(id, request.DepartmentId);\n        return SuccessResponse();\n    }\n\n    /// &lt;summary&gt;\n    /// 办理职工离职\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"id\"&gt;职工ID&lt;/param&gt;\n    /// &lt;param name=\"request\"&gt;离职请求&lt;/param&gt;\n    /// &lt;returns&gt;操作结果&lt;/returns&gt;\n    [HttpPut(\"{id:long}/terminate\")]\n    [DisplayName(\"办理离职\")]\n    public async Task&lt;ActionResult&lt;ApiResponse&gt;&gt; TerminateEmployee(long id, [FromBody] TerminateEmployeeRequest request)\n    {\n        await _employeeService.TerminateEmployeeAsync(id, request.TerminationDate);\n        return SuccessResponse();\n    }\n}\n\n/// &lt;summary&gt;\n/// 转移职工请求\n/// &lt;/summary&gt;\npublic class TransferEmployeeRequest\n{\n    public long? DepartmentId { get; set; }\n}\n\n/// &lt;summary&gt;\n/// 离职请求\n/// &lt;/summary&gt;\npublic class TerminateEmployeeRequest\n{\n    public DateTime TerminationDate { get; set; }\n}\n</code></pre>\n<p><strong>说明</strong>：</p>\n<ul>\n<li>继承自<code>ApiControllerBase</code>，自动获得统一的响应格式和异常处理</li>\n<li><code>DisplayName</code>特性用于前端界面显示</li>\n<li><code>Navigation</code>特性用于添加到导航菜单</li>\n<li><code>Operation</code>特性用于配置操作按钮（删除确认对话框）</li>\n<li>使用<code>SuccessResponse</code>方法返回统一的成功响应</li>\n<li>提供额外的业务操作接口（设置激活状态、转移部门、办理离职等）</li>\n</ul>\n<h2 id=\"6-配置数据库上下文\">6. 配置数据库上下文</h2>\n<p>在<code>Data</code>目录下的DbContext中添加实体：</p>\n<pre><code class=\"language-csharp\">// Data/ApplicationDbContext.cs\nusing CodeSpirit.IdentityApi.Data.Models;\nusing CodeSpirit.Shared.Data;\nusing Microsoft.EntityFrameworkCore;\n\nnamespace CodeSpirit.IdentityApi.Data;\n\n/// &lt;summary&gt;\n/// 身份认证系统数据库上下文 - 支持多租户和多数据库\n/// &lt;/summary&gt;\npublic class ApplicationDbContext : MultiDatabaseDbContextBase\n{\n    /// &lt;summary&gt;\n    /// 职工\n    /// &lt;/summary&gt;\n    public DbSet&lt;Employee&gt; Employees =&gt; Set&lt;Employee&gt;();\n\n    protected override void OnModelCreating(ModelBuilder modelBuilder)\n    {\n        base.OnModelCreating(modelBuilder);\n\n        // 配置Employee实体\n        modelBuilder.Entity&lt;Employee&gt;(entity =&gt;\n        {\n            entity.ToTable(nameof(Employee));\n            entity.Property(e =&gt; e.Id).ValueGeneratedNever();\n\n            // 租户感知的工号复合唯一索引：同一租户内工号唯一\n            entity.HasIndex(e =&gt; new { e.TenantId, e.EmployeeNo })\n                .IsUnique()\n                .HasDatabaseName(\"IX_Employee_TenantId_EmployeeNo\");\n\n            // 索引 DepartmentId，提高查询部门员工的性能\n            entity.HasIndex(e =&gt; e.DepartmentId)\n                .HasDatabaseName(\"IX_Employee_DepartmentId\");\n\n            // 索引 UserId，提高查询用户关联的性能\n            entity.HasIndex(e =&gt; e.UserId)\n                .HasDatabaseName(\"IX_Employee_UserId\");\n\n            // 索引 IsActive，提高按状态过滤的性能\n            entity.HasIndex(e =&gt; e.IsActive)\n                .HasDatabaseName(\"IX_Employee_IsActive\");\n\n            // 索引 EmploymentStatus，提高按在职状态过滤的性能\n            entity.HasIndex(e =&gt; e.EmploymentStatus)\n                .HasDatabaseName(\"IX_Employee_EmploymentStatus\");\n\n            // 配置与部门的关系\n            entity.HasOne(e =&gt; e.Department)\n                .WithMany()\n                .HasForeignKey(e =&gt; e.DepartmentId)\n                .OnDelete(DeleteBehavior.SetNull);\n\n            // 配置与用户的关系\n            entity.HasOne(e =&gt; e.User)\n                .WithMany()\n                .HasForeignKey(e =&gt; e.UserId)\n                .OnDelete(DeleteBehavior.SetNull);\n        });\n    }\n}\n</code></pre>\n<p><strong>说明</strong>：</p>\n<ul>\n<li>继承自<code>MultiDatabaseDbContextBase</code>，支持MySQL和SQL Server</li>\n<li>配置表名、主键、字段长度等</li>\n<li>配置复合唯一索引（租户ID + 工号），确保同一租户内工号唯一</li>\n<li>配置关联关系的级联删除策略（SetNull表示删除部门或用户时，职工记录保留但关联字段设为null）</li>\n<li>添加必要的索引提升查询性能</li>\n</ul>\n<h2 id=\"7-服务注册\">7. 服务注册</h2>\n<p>CodeSpirit框架通过标记接口自动注册服务，无需手动注册：</p>\n<pre><code class=\"language-csharp\">// IEmployeeService接口继承了IScopedDependency接口\npublic interface IEmployeeService : IBaseCRUDIService&lt;...&gt;, IScopedDependency\n{\n    // ...\n}\n</code></pre>\n<p><strong>说明</strong>：</p>\n<ul>\n<li>服务接口继承<code>IScopedDependency</code>接口，服务会自动注册为Scoped生命周期</li>\n<li>框架会自动扫描并注册所有标记接口的服务</li>\n<li>无需在<code>Program.cs</code>中手动注册</li>\n</ul>\n<h2 id=\"8-创建数据库迁移\">8. 创建数据库迁移</h2>\n<p>CodeSpirit框架支持多数据库架构，迁移文件按数据库类型分离存储。创建迁移时必须指定迁移目录参数。</p>\n<pre><code class=\"language-bash\"># 进入IdentityApi项目目录\ncd Src/ApiServices/CodeSpirit.IdentityApi\n\n# 创建迁移（根据数据库类型选择）\n# MySQL - 迁移文件将保存到 Migrations/MySql/ 目录\ndotnet ef migrations add AddEmployees --context MySqlApplicationDbContext --output-dir Migrations/MySql\n\n# SQL Server - 迁移文件将保存到 Migrations/SqlServer/ 目录\ndotnet ef migrations add AddEmployees --context SqlServerApplicationDbContext --output-dir Migrations/SqlServer\n\n# 应用迁移\ndotnet ef database update --context MySqlApplicationDbContext\n# 或\ndotnet ef database update --context SqlServerApplicationDbContext\n</code></pre>\n<p><strong>迁移目录结构</strong>：</p>\n<pre><code>Src/ApiServices/CodeSpirit.IdentityApi/\n├── Migrations/\n│   ├── MySql/                          # MySQL迁移文件\n│   │   ├── 20251222_AddEmployees.cs\n│   │   ├── 20251222_AddEmployees.Designer.cs\n│   │   └── MySqlApplicationDbContextModelSnapshot.cs\n│   └── SqlServer/                      # SQL Server迁移文件\n│       ├── 20251222_AddEmployees.cs\n│       ├── 20251222_AddEmployees.Designer.cs\n│       └── SqlServerApplicationDbContextModelSnapshot.cs\n</code></pre>\n<p><strong>说明</strong>：</p>\n<ul>\n<li><code>--output-dir</code>参数用于指定迁移文件的输出目录</li>\n<li>MySQL迁移文件必须保存到<code>Migrations/MySql/</code>目录</li>\n<li>SQL Server迁移文件必须保存到<code>Migrations/SqlServer/</code>目录</li>\n<li>每个数据库类型都有独立的<code>ModelSnapshot.cs</code>文件</li>\n<li>这样可以确保不同数据库类型的迁移文件互不干扰</li>\n</ul>\n<h2 id=\"功能特性\">功能特性</h2>\n<p>通过以上步骤，您已经完成了一个完整的CRUD功能开发。CodeSpirit框架会自动提供以下功能：</p>\n<h3 id=\"自动生成的功能\">自动生成的功能</h3>\n<ul>\n<li>✅ <strong>AMIS前端界面</strong>：基于控制器和DTO的特性自动生成\n<ul>\n<li>表格展示（支持头像、日期格式化、状态显示等）</li>\n<li>表单编辑（支持表单分组、树形选择、图片上传等）</li>\n<li>多条件搜索筛选（关键字、部门、状态、日期范围等）</li>\n<li>批量操作（批量删除等）</li>\n</ul>\n</li>\n<li>✅ <strong>统一的API响应格式</strong>：使用<code>ApiResponse&lt;T&gt;</code>统一响应</li>\n<li>✅ <strong>分页查询</strong>：支持分页、排序、多条件筛选</li>\n<li>✅ <strong>批量操作</strong>：支持批量删除、批量导入等操作</li>\n<li>✅ <strong>异常处理</strong>：统一的异常处理和错误响应</li>\n<li>✅ <strong>权限控制</strong>：支持基于特性的权限控制</li>\n<li>✅ <strong>审计日志</strong>：自动记录创建、更新、删除操作</li>\n<li>✅ <strong>多租户支持</strong>：自动进行数据隔离</li>\n<li>✅ <strong>软删除支持</strong>：删除操作使用软删除，数据可恢复</li>\n</ul>\n<h3 id=\"标准crud操作\">标准CRUD操作</h3>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>HTTP方法</th>\n<th>路径</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>查询列表</td>\n<td>GET</td>\n<td><code>/api/identity/Employees</code></td>\n<td>支持多条件查询和关键字搜索</td>\n</tr>\n<tr>\n<td>查询详情</td>\n<td>GET</td>\n<td><code>/api/identity/Employees/{id}</code></td>\n<td>根据ID获取单个职工</td>\n</tr>\n<tr>\n<td>创建</td>\n<td>POST</td>\n<td><code>/api/identity/Employees</code></td>\n<td>创建新职工</td>\n</tr>\n<tr>\n<td>更新</td>\n<td>PUT</td>\n<td><code>/api/identity/Employees/{id}</code></td>\n<td>更新职工信息</td>\n</tr>\n<tr>\n<td>删除</td>\n<td>DELETE</td>\n<td><code>/api/identity/Employees/{id}</code></td>\n<td>删除单个职工（软删除）</td>\n</tr>\n<tr>\n<td>批量删除</td>\n<td>POST</td>\n<td><code>/api/identity/Employees/batch-delete</code></td>\n<td>批量删除职工</td>\n</tr>\n<tr>\n<td>根据部门查询</td>\n<td>GET</td>\n<td><code>/api/identity/Employees/department/{departmentId}</code></td>\n<td>根据部门获取职工列表</td>\n</tr>\n<tr>\n<td>设置激活状态</td>\n<td>PUT</td>\n<td><code>/api/identity/Employees/{id}/active</code></td>\n<td>设置职工激活状态</td>\n</tr>\n<tr>\n<td>转移部门</td>\n<td>PUT</td>\n<td><code>/api/identity/Employees/{id}/transfer</code></td>\n<td>转移职工到新部门</td>\n</tr>\n<tr>\n<td>办理离职</td>\n<td>PUT</td>\n<td><code>/api/identity/Employees/{id}/terminate</code></td>\n<td>办理职工离职</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"业务验证示例\">业务验证示例</h2>\n<h3 id=\"创建时验证\">创建时验证</h3>\n<pre><code class=\"language-csharp\">protected override async Task ValidateCreateDto(CreateEmployeeDto createDto)\n{\n    await base.ValidateCreateDto(createDto);\n\n    // 验证工号唯一性\n    bool isUnique = await IsEmployeeNoUniqueAsync(createDto.EmployeeNo);\n    if (!isUnique)\n    {\n        throw new AppServiceException(400, $\"工号 {createDto.EmployeeNo} 已存在，请使用其他工号\");\n    }\n\n    // 验证部门是否存在\n    if (createDto.DepartmentId.HasValue)\n    {\n        var departmentExists = await _departmentRepository.ExistsAsync(d =&gt; d.Id == createDto.DepartmentId.Value);\n        if (!departmentExists)\n        {\n            throw new AppServiceException(400, \"部门不存在\");\n        }\n    }\n\n    // 验证用户是否存在（如果指定了用户ID）\n    if (createDto.UserId.HasValue)\n    {\n        var userExists = await _userRepository.ExistsAsync(u =&gt; u.Id == createDto.UserId.Value);\n        if (!userExists)\n        {\n            throw new AppServiceException(400, \"用户不存在\");\n        }\n    }\n}\n</code></pre>\n<h3 id=\"更新时验证\">更新时验证</h3>\n<pre><code class=\"language-csharp\">protected override async Task ValidateUpdateDto(long id, UpdateEmployeeDto updateDto)\n{\n    await base.ValidateUpdateDto(id, updateDto);\n\n    // 验证工号唯一性（排除当前记录）\n    bool isUnique = await IsEmployeeNoUniqueAsync(updateDto.EmployeeNo, id);\n    if (!isUnique)\n    {\n        throw new AppServiceException(400, $\"工号 {updateDto.EmployeeNo} 已存在，请使用其他工号\");\n    }\n\n    // 验证部门是否存在\n    if (updateDto.DepartmentId.HasValue)\n    {\n        var departmentExists = await _departmentRepository.ExistsAsync(d =&gt; d.Id == updateDto.DepartmentId.Value);\n        if (!departmentExists)\n        {\n            throw new AppServiceException(400, \"部门不存在\");\n        }\n    }\n}\n</code></pre>\n<h3 id=\"创建前处理\">创建前处理</h3>\n<pre><code class=\"language-csharp\">protected override async Task&lt;Employee&gt; OnCreating(CreateEmployeeDto createDto)\n{\n    var employee = await base.OnCreating(createDto);\n    \n    // 设置租户ID\n    employee.TenantId = _currentUser.TenantId;\n    \n    // 生成ID（如果需要）\n    if (employee.Id == 0)\n    {\n        employee.Id = await _idGenerator.GenerateIdAsync();\n    }\n\n    return employee;\n}\n</code></pre>\n<h2 id=\"扩展功能示例\">扩展功能示例</h2>\n<h3 id=\"添加权限控制\">添加权限控制</h3>\n<pre><code class=\"language-csharp\">[HttpPost]\n[DisplayName(\"创建职工\")]\n[Permission(\"identity_employees_create\")]  // 添加权限控制\npublic async Task&lt;ActionResult&lt;ApiResponse&lt;EmployeeDto&gt;&gt;&gt; CreateEmployee(CreateEmployeeDto createDto)\n{\n    // ...\n}\n</code></pre>\n<h3 id=\"添加导航菜单\">添加导航菜单</h3>\n<pre><code class=\"language-csharp\">[DisplayName(\"职工管理\")]\n[Navigation(Icon = \"fa-solid fa-user-tie\", PlatformType = PlatformType.Tenant)]  // 添加到导航菜单\npublic class EmployeesController : ApiControllerBase\n{\n    // ...\n}\n</code></pre>\n<h3 id=\"自定义查询方法\">自定义查询方法</h3>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 获取在职职工列表\n/// &lt;/summary&gt;\npublic async Task&lt;List&lt;EmployeeDto&gt;&gt; GetActiveEmployeesAsync()\n{\n    var employees = await Repository.CreateQuery()\n        .Where(e =&gt; e.IsActive &amp;&amp; e.EmploymentStatus == EmploymentStatus.Active)\n        .Include(e =&gt; e.Department)\n        .Include(e =&gt; e.User)\n        .ToListAsync();\n\n    return Mapper.Map&lt;List&lt;EmployeeDto&gt;&gt;(employees);\n}\n</code></pre>\n<h3 id=\"使用pageaside特性实现侧边栏筛选\">使用PageAside特性实现侧边栏筛选</h3>\n<p><code>PageAside()</code>特性用于将查询字段放置在页面侧边栏，特别适用于树形选择、分类筛选等场景。使用此特性后，该字段会从主查询表单中移除，仅在侧边栏显示。</p>\n<p><strong>特性说明</strong>：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 部门ID筛选\n/// &lt;/summary&gt;\n[DisplayName(\"部门\")]\n[AmisInputTreeField(\n    DataSource = \"${ROOT_API}/api/identity/Departments/tree\",\n    Multiple = false,\n    JoinValues = true,\n    ExtractValue = false,\n    ShowOutline = true,\n    LabelField = \"name\",\n    ValueField = \"id\",\n    Required = false,\n    Clearable = true,\n    SubmitOnChange = true,  // 选择后自动提交查询\n    HeightAuto = true,\n    SelectFirst = false,\n    InputOnly = true,\n    ShowIcon = true\n)]\n[PageAside()]  // 标记为侧边栏字段\npublic long? DepartmentId { get; set; }\n</code></pre>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251223170759720-1961586904.png\" /><br />\n<strong>PageAside特性的主要属性</strong>：</p>\n<ul>\n<li><code>Target</code>：表单提交目标，如果为空则自动设置为CRUD组件名称</li>\n<li><code>SubmitOnInit</code>：是否在初始化时提交，默认为<code>false</code></li>\n<li><code>WrapWithPanel</code>：是否不使用面板包装，默认为<code>false</code></li>\n<li><code>AsideResizor</code>：侧边栏宽度是否可调整，默认为<code>true</code></li>\n<li><code>AsideMinWidth</code>：侧边栏最小宽度（像素），默认为<code>0</code></li>\n<li><code>AsideMaxWidth</code>：侧边栏最大宽度（像素），默认为<code>0</code></li>\n<li><code>AsideSticky</code>：侧边栏是否固定，默认为<code>true</code></li>\n<li><code>AsidePosition</code>：侧边栏位置（<code>Left</code>/<code>Right</code>），默认为<code>Left</code></li>\n</ul>\n<p><strong>使用场景</strong>：</p>\n<ol>\n<li><strong>树形分类筛选</strong>：如部门树、分类树等，放在侧边栏作为导航筛选器</li>\n<li><strong>独立筛选器</strong>：需要独立展示的筛选条件，避免主表单过于拥挤</li>\n<li><strong>联动查询</strong>：侧边栏字段变化时自动触发主内容区域刷新</li>\n</ol>\n<p><strong>注意事项</strong>：</p>\n<ul>\n<li>标记了<code>PageAside()</code>特性的字段会自动从主查询表单中排除</li>\n<li>建议配合<code>SubmitOnChange = true</code>使用，实现选择后自动查询</li>\n<li>侧边栏字段的查询条件会自动合并到主查询中</li>\n</ul>\n<h2 id=\"最佳实践\">最佳实践</h2>\n<ol>\n<li>\n<p><strong>实体设计</strong>：</p>\n<ul>\n<li>实现<code>IFullAuditable</code>接口获得完整的审计字段（创建、更新、删除）</li>\n<li>实现<code>IMultiTenant</code>接口支持多租户数据隔离</li>\n<li>实现<code>IIsActive</code>接口支持激活状态管理</li>\n<li>合理设计导航属性，使用<code>Include</code>避免N+1查询问题</li>\n<li>为唯一性字段创建复合唯一索引（租户ID + 业务字段）</li>\n</ul>\n</li>\n<li>\n<p><strong>DTO分离</strong>：</p>\n<ul>\n<li>为创建、更新、查询分别创建DTO</li>\n<li>使用<code>DisplayName</code>特性提供友好的字段名称</li>\n<li>使用<code>AmisColumn</code>特性控制前端表格列显示</li>\n<li>使用<code>FormGroup</code>特性将表单字段分组，提升用户体验</li>\n<li>使用<code>AmisInputTreeField</code>等特性自动生成合适的表单组件</li>\n</ul>\n</li>\n<li>\n<p><strong>服务层</strong>：</p>\n<ul>\n<li>继承<code>BaseCRUDIService</code>获得CRUD和批量导入功能</li>\n<li>服务接口继承<code>IScopedDependency</code>接口自动注册</li>\n<li>重写<code>ValidateCreateDto</code>和<code>ValidateUpdateDto</code>实现业务验证</li>\n<li>重写<code>OnCreating</code>方法设置租户ID和生成ID</li>\n<li>使用<code>LinqKit</code>的<code>PredicateBuilder</code>构建动态查询条件</li>\n</ul>\n</li>\n<li>\n<p><strong>控制器</strong>：</p>\n<ul>\n<li>保持简洁，主要调用服务层方法</li>\n<li>使用<code>DisplayName</code>和<code>Navigation</code>特性</li>\n<li>使用<code>Operation</code>特性配置操作按钮（删除确认对话框）</li>\n<li>提供额外的业务操作接口（如设置激活状态、转移部门等）</li>\n</ul>\n</li>\n<li>\n<p><strong>验证</strong>：</p>\n<ul>\n<li>使用DataAnnotations进行基础数据验证</li>\n<li>重写服务层的验证方法实现业务验证（唯一性、关联存在性等）</li>\n<li>使用<code>AppServiceException</code>抛出业务异常</li>\n<li>在数据库层面创建唯一索引确保数据完整性</li>\n</ul>\n</li>\n<li>\n<p><strong>数据库设计</strong>：</p>\n<ul>\n<li>为常用查询字段创建索引提升性能</li>\n<li>合理配置关联关系的级联删除策略</li>\n<li>使用复合唯一索引确保租户内业务字段唯一性</li>\n</ul>\n</li>\n<li>\n<p><strong>文档注释</strong>：</p>\n<ul>\n<li>为所有公共成员添加XML文档注释</li>\n<li>使用<code>&lt;summary&gt;</code>、<code>&lt;param&gt;</code>、<code>&lt;returns&gt;</code>标签</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"相关文档\">相关文档</h2>\n<ul>\n<li><a href=\"./CodeSpirit.Core%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6.md\" rel=\"noopener nofollow\" target=\"_blank\">CodeSpirit.Core核心框架</a></li>\n<li><a href=\"./%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97.md\" rel=\"noopener nofollow\" target=\"_blank\">开发环境搭建指南</a></li>\n<li><a href=\"./%E9%A1%B9%E7%9B%AE%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.md\" rel=\"noopener nofollow\" target=\"_blank\">项目整体架构设计</a></li>\n<li><a href=\"./CodeSpirit%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%8C%87%E5%8D%97.md\" rel=\"noopener nofollow\" target=\"_blank\">统一异常处理指南</a></li>\n</ul>\n<h2 id=\"总结\">总结</h2>\n<p>通过CodeSpirit框架的<code>BaseCRUDIService</code>和标准开发模式，您可以快速开发出功能完整的CRUD接口。职工管理模块展示了：</p>\n<ul>\n<li>✅ 标准CRUD操作的实现</li>\n<li>✅ 关联关系管理（部门、用户账号）</li>\n<li>✅ 业务验证逻辑的编写（工号唯一性、部门存在性等）</li>\n<li>✅ 多条件查询的实现（关键字、部门、状态、日期范围等）</li>\n<li>✅ 表单分组展示的使用</li>\n<li>✅ 额外业务操作的实现（设置激活状态、转移部门、办理离职等）</li>\n<li>✅ AMIS特性的使用（表格列、表单字段、图片上传等）</li>\n</ul>\n<p>框架会自动处理大部分样板代码，让您专注于业务逻辑的实现。</p>\n<p><strong>更多交流请关注“CodeSpirit-码灵”公众号进群！！！</strong></p>\n<p>祝您开发愉快！🚀</p>\n\n</div>\n<div id=\"MySignature\">\n    作者：<a href=\"http://www.cnblogs.com/codelove/\" target=\"_blank\">雪雁</a><br />出处：<a href=\"http://www.cnblogs.com/codelove/\" target=\"_blank\">http://www.cnblogs.com/codelove/</a>\n<br />如果喜欢作者的文章，请关注【CodeSpirit-码灵】公众号以便第一时间获得最新内容。本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。<br /><b>静听鸟语花香，漫赏云卷云舒。</b>\n<br />\n<img height=\"100\" src=\"https://images.cnblogs.com/cnblogs_com/codelove/315887/o_251224070213_%E5%85%AC%E4%BC%97%E5%8F%B7.jpg\" width=\"100\" />\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 00:15</span>&nbsp;\n<a href=\"https://www.cnblogs.com/codelove\">雪雁</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "吴恩达深度学习课程四：计算机视觉 第四周：卷积网络应用 (一) 人脸识别",
      "link": "https://www.cnblogs.com/Goblinscholar/p/19418306",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Goblinscholar/p/19418306\" id=\"cb_post_title_url\" title=\"发布于 2025-12-29 23:52\">\n    <span>吴恩达深度学习课程四：计算机视觉 第四周：卷积网络应用 (一) 人脸识别</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>此分类用于记录吴恩达深度学习课程的学习笔记。<br />\n课程相关信息链接如下：</p>\n<ol>\n<li>原课程视频链接：<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?buvid=XU762317353676D786954061C192FE625463B&amp;from_spmid=playlist.playlist-detail.0.0&amp;is_story_h5=false&amp;mid=zqernykrmpf7XfIorMR%2FnA%3D%3D&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=ce0bc526-db69-428a-962e-c65ed8c267bc&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1713085655&amp;unique_k=DfBgvFW&amp;up_id=8654113&amp;vd_source=e035e9878d32f414b4354b839a4c31a4\" rel=\"noopener nofollow\" target=\"_blank\">[双语字幕]吴恩达深度学习deeplearning.ai</a></li>\n<li>github课程资料，含课件与笔记:<a href=\"https://github.com/robbertliu/deeplearning.ai-andrewNG\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习教学资料</a></li>\n<li>课程配套练习（中英）与答案：<a href=\"https://blog.csdn.net/u013733326/article/details/79827273\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习课后习题与答案</a></li>\n</ol>\n<p>本篇为第四课的第四周内容，<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=140\" rel=\"noopener nofollow\" target=\"_blank\">4.1</a>到<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=144\" rel=\"noopener nofollow\" target=\"_blank\">4.5</a>的内容。</p>\n<hr />\n<p>本周为第四课的第四周内容，这一课所有内容的中心只有一个：<strong>计算机视觉</strong>。应用在深度学习里，就是专门用来进行图学习的模型和技术，是在之前全连接基础上的“特化”，也是相关专业里的一个重要研究大类。<br />\n<strong>这一整节课都存在大量需要反复理解的内容和机器学习、数学基础。</strong> 因此我会尽可能的补足基础，用比喻和实例来演示每个部分，从而帮助理解。<br />\n第四周的内容是对前三周内容的综合应用，介绍了一些通过卷积网络实现的实际应用，它们在使用卷积网络的基础上又各有自己的特点来匹配不同的任务要求，是对<strong>如何真实应用卷积网络</strong>的良好演示。<br />\n本篇的内容关于<strong>人脸识别</strong>。</p>\n<h1 id=\"1-人脸验证与人脸识别\">1. 人脸验证与人脸识别</h1>\n<p>人脸验证和人脸识别是两个相似的概念。<br />\n而在人脸识别系统中，我们说<strong>人脸验证是人脸识别的一个基本模块</strong>。<br />\n现在就来展开一下二者的关系：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251229234636631-73929260.png\" /><br />\n我们在图里提到<strong>人脸验证是一个1对1问题</strong>，这是因为在假定验证器完全准确的情况下，它只会对一个人说 “Yes” 而拒绝其他所有人。<br />\n很显然，这种逻辑在我们实际生活中的大多场景都不适用，公司、宿舍的门禁等都支持通过一个模型识别多个人。而不是为每个人单独设置一个闸机。<br />\n因此，我们便称这种<strong>实现“1对多”逻辑的相应任务为人脸识别</strong>。<br />\n按照刚才的逻辑推下去，一个很自然、也很“机器学习直觉”的想法是：<strong>那人脸识别不就是一个多分类问题吗？</strong> 像这样：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251229234219889-112044451.png\" /><br />\n但如果在实际部署中这样实现人脸识别，你会发现这样一些问题：</p>\n<ol>\n<li>如果单位有新员工加入或老员工离职，就要<strong>重新调整数据和网络输出层，重新训练</strong>。</li>\n<li>当单位规模较大时，数据可能包含<strong>成千上万个类别</strong>。更重要的是，每个类别数据量很少，而深度学习往往又依赖于<strong>数据量</strong>，难道办理入职要先拍几百几千张照片吗？</li>\n</ol>\n<p>因此，我们得出结论：因为人脸识别任务在实际部署中的特殊性，让我们之前了解的常规<strong>分类算法并不适用</strong>作为一个可持续部署方案对其应用。</p>\n<p>而在现实生活中，你会发现，我们在相关系统录入人脸时，<strong>往往只需要一张证件照即可</strong>，这是怎么做到的呢？我们继续。</p>\n<h1 id=\"2-一次学习one-shot-learning\">2. 一次学习（one-shot learning）</h1>\n<p>继续刚刚的内容，我们会发现一个看似矛盾的现象：<br />\n在实际的人脸系统中，录入一个新用户时，<strong>往往只需要一张证件照</strong>。但在深度学习的经验认知里，模型性能又高度依赖数据量。  <strong>这两点，不冲突吗？</strong></p>\n<p>要理解这一点，我们需要先回到刚才“把人脸识别当作多分类问题”的思路。<br />\n在标准的多分类任务中，<strong>分类标签本身就为数据划分了明确的边界</strong>：模型只能通过<strong>同一标签下的样本</strong>来学习该类别的特征，而不同类别之间的数据是被严格隔离使用的。<br />\n正因为如此，如果将人脸识别直接建模为“每个人一个类别”，那么模型要学好某一个人的特征，就必然需要<strong>大量属于这个人的样本</strong>——也就出现了“要给每个人拍写真集”的不现实要求。</p>\n<p>但是，你会发现：在人脸识别任务中，<strong>总的数据量其实并不少</strong>，真正稀缺的只是“每个身份对应的样本数量”。这意味着，并不是“数据不够”，而是<strong>数据被标签强行分割后，无法被充分利用</strong>。</p>\n<p>正是由于这种设置与实际部署场景不匹配，我们自然会产生一个新的疑问：<strong>能不能让所有人的样本都参与学习，而不是被身份标签各自隔离开来？</strong></p>\n<p>在机器学习中，这类“<strong>每个类别只有极少样本</strong>”的问题被称为<strong>一次学习（one-shot learning）问题</strong>。<br />\n而在具体的人脸识别场景下，<strong>one-shot 人脸识别</strong>指的是：每个身份在训练或建库阶段，仅提供一张（或极少几张）已知人脸样本。</p>\n<p>为了解决这种“<strong>总体样本量很大，但单个身份样本极少</strong>”的矛盾，人们提出了一种不同于传统分类的思路：  <strong>不再让模型回答“这张脸属于所有人中的哪一个？”，而是让它判断“这张脸是否和某一个已知的某张脸足够相似？”</strong></p>\n<p>现在，网络目标就从一开始的“学习分类”变成了“<strong>学相似度</strong>”，就像这样：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251229234253679-642676291.png\" /><br />\n如果如图中这样，网络实现了“<strong>学习两张人脸的相似度</strong>“，我们就解决了刚刚的问题：</p>\n<ol>\n<li>如果单位有新员工加入或老员工离职，就要不再需要调整网络和重新训练，<strong>只需要把相应数据加入数据库或从数据库中删除</strong>。</li>\n<li>所有的数据都被充分利用，同时每人只需要一张证件照，在门禁时人脸和数据库中的人脸对比，<strong>找到满足相似度阈值的样本即通过，不存在即拒绝。</strong></li>\n</ol>\n<h1 id=\"3-siamese-网络\">3. Siamese 网络</h1>\n<p>现在，我们明确了针对面部识别任务的目标：<strong>训练一个可以学习两张人脸相似度的网络</strong>。<br />\n现在，要怎么实现这一点呢？<br />\n答案就是这部分的标题：Siamese 网络。<br />\n要说明的是，吴恩达老师在课程里提到了一篇 2014 年的论文 <a href=\"https://www.cv-foundation.org/openaccess/content_cvpr_2014/papers/Taigman_DeepFace_Closing_the_2014_CVPR_paper.pdf?utm_source=chatgpt.com\" rel=\"noopener nofollow\" target=\"_blank\">DeepFace: Closing the Gap to Human-Level Performance in Face Verification</a>。<strong>但 Siamese 网络并不是从这篇论文才提出的</strong>——早在 1993 年，它就被发明出来，用于判断两幅手写签名是否同一人。后来也被应用到人脸识别任务中。<br />\nSiamese 网络的核心思路是<strong>通过共享权重的双分支（或多分支）神经网络，将输入的两张图像映射到同一特征空间，然后通过度量函数（如欧氏距离或余弦相似度）计算它们的相似度</strong>。<br />\nDeepFace 借鉴了 Siamese 网络的思路，在深度 CNN 上直接学习人脸特征的相似度，并通过优化和大规模训练，这才使得<strong>系统性能接近人类水平，真正具备部署价值</strong>。</p>\n<p>现在，就来详细看看一个较完善的 Siamese 网络的运行过程：</p>\n<h2 id=\"31-对图像进行编码处理三元组损失triplet-loss\">3.1 对图像进行编码处理：三元组损失（triplet loss）</h2>\n<p>我们先来看看什么叫对图像进行编码处理：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251229234657431-1853718024.png\" /><br />\n这样，我们就可以使用一组特征向量来编码一张人脸，实际上，这就是 DeepFace 提出的一步优化，这一步设置<strong>不止为了计算相似度作准备，同时也极大减少了计算量，缩短了运行时间</strong>，可以说相当成功。</p>\n<p>但是，同样也是因为这一步编码，新的问题出现了：<strong>你会发现，这个用来把图像转换成编码的网络同样需要训练。</strong><br />\n没错，我们需要训练这个网络，而目标就是：<strong>让同一个身份的人脸编码差异最小化，不同身份的人脸的编码差异最大化。</strong><br />\n要实现这个目标的常用方法叫做<strong>三元组（triplet）损失</strong>，这时，<strong>网络在训练阶段需要同时输入三张图像</strong>。<br />\n它的公式长这个样：</p>\n<p></p><div class=\"math display\">\\[L=max⁡(0,∥f(a)−f(p)∥^2_2−∥f(a)−f(n)∥^2_2+α)\n\\]</div><p></p><p>其中：</p>\n<ul>\n<li><span class=\"math inline\">\\(f(a)\\)</span>：anchor（基准图像）映射后的特征向量</li>\n<li><span class=\"math inline\">\\(f(p)\\)</span>：positive（同一身份的图像）映射后的特征向量</li>\n<li><span class=\"math inline\">\\(f(n)\\)</span>：negative（不同身份的图像）映射后的特征向量</li>\n<li><span class=\"math inline\">\\(\\alpha\\)</span>：间隔（margin），保证不同身份的距离比同一身份距离至少大 <span class=\"math inline\">\\(\\alpha\\)</span></li>\n</ul>\n<p>别慌，我们用一个例子来演示一遍原理：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251229235145998-454139387.png\" /></p>\n<p><img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251229234301253-442526298.png\" /><br />\n只看符号可能有些太绕了，<strong>我们再来看一个实例</strong>：<br />\n假设三张人脸图像：经过网络映射后的二维特征向量如下：</p>\n<table>\n<thead>\n<tr>\n<th>图像</th>\n<th>特征向量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a (Alice)</td>\n<td>[1.0, 1.0]</td>\n</tr>\n<tr>\n<td>p (Alice)</td>\n<td>[1.2, 1.1]</td>\n</tr>\n<tr>\n<td>n (Bob)</td>\n<td>[2.5, 2.0]</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"1计算欧氏距离\">（1）计算欧氏距离</h4>\n<p><strong>Anchor 与 Positive（同一人）</strong>：</p>\n<p></p><div class=\"math display\">\\[∥f(a)-f(p)∥_2^2 = (1.0-1.2)^2 + (1.0-1.1)^2 = 0.04 + 0.01 = 0.05  \n\\]</div><p></p><p><strong>Anchor 与 Negative（不同人）</strong>：</p>\n<p></p><div class=\"math display\">\\[∥f(a)-f(n)∥_2^2 = (1.0-2.5)^2 + (1.0-2.0)^2 = 2.25 + 1.0 = 3.25  \n\\]</div><p></p><h4 id=\"2代入三元组损失公式\">（2）代入三元组损失公式</h4>\n<p>假设 <span class=\"math inline\">\\(\\alpha = 0.5\\)</span>，代入数值：</p>\n<p></p><div class=\"math display\">\\[L = \\max\\Big(0,0.05 - 3.25 + 0.5\\Big) = \\max(0, -2.7) = 0  \n\\]</div><p></p><p>代表当前特征向量满足目标，同一人距离接近，不同人距离大于 <span class=\"math inline\">\\(\\alpha\\)</span>。</p>\n<h4 id=\"3如果-negative-太近\">（3）如果 Negative 太近</h4>\n<p>假设 <span class=\"math inline\">\\(f(n) = [1.5, 1.3]\\)</span>，计算距离：</p>\n<p></p><div class=\"math display\">\\[∥f(a)-f(n)∥_2^2 = (1.0-1.5)^2 + (1.0-1.3)^2 = 0.25 + 0.09 = 0.34  \n\\]</div><p></p><p>损失为：</p>\n<p></p><div class=\"math display\">\\[L = \\max\\Big(0, 0.05 - 0.34 + 0.5\\Big) = \\max(0, 0.21) = 0.21  \n\\]</div><p></p><p>便说明不同人距离太近，网络需要更新，保留损失来进行反向传播。</p>\n<p><strong>通过这种设计，网络可以直接学习一个适合度量相似度的特征空间。</strong></p>\n<p>最后要强调的一点是，为了让训练效果更好，<strong>我们在选择三元组时，会尽量让基准图像和同一人的图像差别尽可能大，同时让基准图像和不同人的图像差别尽可能小。</strong><br />\n这就像是在手动提高考试难度，难题会了，简单题自然不在话下。<br />\n现在，我们便继续下一部分。</p>\n<h2 id=\"32-正向传播两幅图像并计算相似度\">3.2 正向传播两幅图像并计算相似度</h2>\n<p>在拥有了可以对图像进行合适编码的网络后，我们便可以进行相似度计算的应用，这一步的过程是这样的：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251229234408230-256446436.png\" /><br />\n如图所示，我们通过正向传播得到两幅输入人脸的编码，并根据编码计算相似度，自然就可以根据阈值判断两张人脸是否属于同一个人。<br />\n而且，这种传播和计算相似度分离的设计，代表<strong>我们可以提前为数据库中的图像计算好编码</strong>，只需刷脸时传入的人脸单独传播得到编码后进行计算就好了，这大大提高了可部署性。</p>\n<h2 id=\"33-拓展另一种训练编码网络的方式\">3.3 拓展：另一种训练编码网络的方式</h2>\n<p>我们刚刚介绍了可以通过三元组损失来训练编码网络，但你可能也发现了，这个方法在数据准备阶段较为复杂。<br />\n因此，吴恩达老师还介绍了另一种训练方法：<strong>更改标签，让Siamese 网络后接逻辑回归变为二分类问题。</strong><br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251229234243543-574274696.png\" /><br />\n这样，我们就又把人脸识别问题又转换回了二分类问题，通过反向传播来进行训练。<br />\n但是，你会发现，<strong>当新员工加入时，还是要重新训练模型。</strong><br />\n因此，实际上这种方式的实际部署价值并不如实用三元组损失。</p>\n<h1 id=\"4总结\">4.总结</h1>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>原理</th>\n<th>比喻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>人脸验证（Face Verification）</td>\n<td>1 对 1 问题，判断输入人脸是否与目标身份匹配</td>\n<td>就像门卫只对某个人说“可以进”，其他人全部拒绝</td>\n</tr>\n<tr>\n<td>人脸识别（Face Recognition）</td>\n<td>1 对多问题，通过模型识别输入人脸属于哪一个已知身份</td>\n<td>门禁系统识别多个员工，不需要单独为每个人设闸机</td>\n</tr>\n<tr>\n<td>多分类建模问题</td>\n<td>将每个人作为一个类别进行训练</td>\n<td>每个员工都有一本写真集，要学会区分成千上万本</td>\n</tr>\n<tr>\n<td>一次学习（One-Shot Learning）</td>\n<td>每个身份仅提供极少样本，通过相似度判断识别</td>\n<td>只需一张证件照就能识别新员工，不用拍写真集</td>\n</tr>\n<tr>\n<td>Siamese 网络</td>\n<td>共享权重的双分支（或多分支）网络，将图像映射到同一特征空间，通过度量函数计算相似度</td>\n<td>同时看两张照片，然后比较相似度</td>\n</tr>\n<tr>\n<td>三元组损失（Triplet Loss）</td>\n<td>训练网络使同一人距离最小，不同人距离最大，网络需输入三张图像（anchor, positive, negative）</td>\n<td>提高考试难度：基准题和相似题差别小，不同题差别大，训练更有效</td>\n</tr>\n<tr>\n<td>正向传播两图计算相似度</td>\n<td>已训练网络对两幅图像编码后，计算特征距离或相似度，用阈值判断是否同一人</td>\n<td>先把照片编码成“身份特征卡片”，刷脸时只比对卡片</td>\n</tr>\n<tr>\n<td>Siamese + 逻辑回归二分类</td>\n<td>将两张图像输入 Siamese 网络，通过逻辑回归判断是否同一人</td>\n<td>将人脸识别问题简化成“是/不是同一人”的选择题</td>\n</tr>\n<tr>\n<td>部署可行性对比</td>\n<td>三元组损失支持 one-shot、可提前计算数据库特征向量，泛化强；逻辑回归方式新身份需重新训练，泛化差</td>\n<td>三元组：考试考通用能力；逻辑回归：考试只会答已有题目</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-29 23:52</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Goblinscholar\">哥布林学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Python os库 os.walk使用（详细教程、带实践）",
      "link": "https://www.cnblogs.com/io-T-T/p/19418274",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/io-T-T/p/19418274\" id=\"cb_post_title_url\" title=\"发布于 2025-12-29 23:19\">\n    <span>Python os库 os.walk使用（详细教程、带实践）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        Python os库 os.walk使用（详细教程、带实践）\nos.walk 处理文件\nos.walk原理\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"python-os库-oswalk使用详细教程带实践\">Python os库 os.walk使用（详细教程、带实践）</h2>\n<p>-----------------------<em><strong>PS：env python version==3.10</strong></em>----------------</p>\n<p>简介：</p>\n<p>​\t本文以实际案例说明<code>os.walk</code>对文件的使用方式。主要教学内容：</p>\n<ul>\n<li><code>os.walk</code>库实际的使用</li>\n<li><code>os.walk</code>最佳实践</li>\n<li><em>（可选）os.walk原理</em></li>\n<li><em>（可选）迭代器方向理解</em></li>\n</ul>\n<p>全文2000字左右，代码字数800（含迭代器180）左右，建议学习时间10-15min（不含迭代器）。若学习迭代器建议30min+</p>\n<h3 id=\"1-模拟实际使用环境\">1 模拟实际使用环境</h3>\n<p>​\tPS：仅作为案例说明参考，若已有可用的文件夹/目录，请移步第二步</p>\n<p>​\t<img alt=\"image-20251222214254412\" class=\"lazyload\" /></p>\n<ol>\n<li>\n<p>根据上图模拟实际使用情况：</p>\n<ul>\n<li>\n<p>随意新建一个目录（确保不会有其他文件）</p>\n</li>\n<li>\n<p>在（新建目录的）根目录创建一个<strong>文件</strong>和<strong>文件夹</strong>（名称随意，也可以参照我的样例来）</p>\n</li>\n<li>\n<p>进入<code>root</code>文件夹，新建两个次级文件夹（<code>dir1</code>、<code>dir2</code>）</p>\n<ul>\n<li>root文件夹下直接创建次级目录文件<code>F1.txt</code></li>\n<li>创建次级目录文件<code>dir1</code>、<code>dir2</code>\n<ul>\n<li>进入<code>dir2</code>文件夹\n<ul>\n<li>创建文件（<code>F2.txt</code>）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-解析oswalk函数\">2 解析<code>os.walk</code>函数</h3>\n<p>面向基础讲解，详细见 <a href=\"https://docs.python.org/zh-cn/3.10/library/os.html?highlight=os%20walk#os.walk\" rel=\"noopener nofollow\" target=\"_blank\">os.walk官方说明</a></p>\n<ul>\n<li>\n<p>什么是 python 的<code>os</code>库</p>\n<ul>\n<li>本模块提供了一种使用与操作系统相关的功能的便捷式途径。（如文件路径控制、文件信息获取、遍历目录文件【<code>os.walk</code>】、其他系统调用功能）</li>\n</ul>\n</li>\n<li>\n<p><code>os.walk</code>函数讲解：</p>\n<p><code>os.walk</code>(<strong><em>top</em>, <em>topdown=True</em>,</strong> <em>onerror=None</em>, <em>followlinks=False</em>)</p>\n<ul>\n<li>\n<p>主要聚焦于前两个参数即可：</p>\n<ul>\n<li><code>top</code>：根目录路径（str）</li>\n<li><code>topdown</code>：自上而下模式，默认（<code>True</code>）为自上而下遍历，<code>False</code>则从底向上遍历</li>\n</ul>\n</li>\n<li>\n<p>返回值：</p>\n<ul>\n<li>\n<p>返回迭代器 ，迭代器每次生成的对象为：<code>(dirpath, dirnames, filenames)</code></p>\n<p><code>dirpath</code>： 当前文件夹路径</p>\n<p><code>dirnames</code>：文件夹名称</p>\n<p><code>filenames</code>：文件名称</p>\n</li>\n<li>\n<p>如果不理解迭代器，可以暂时理解为os.walk返回了 元组 <code>(dirpath, dirnames, filenames)</code>的列表，类似于下文 (省略双引号):</p>\n<pre><code class=\"language-python\">[\n\t(C:/user/, [root],[rott_text.txt] ),\t\t#根目录\n\t(C:/user/root, [dir1,dir2],[F1.txt] ),\t\t#进入root文件夹\n\t(C:/user/root/dir1, [],[] ),\t\t\t\t#进入dir1文件夹\n\t(C:/user/root/dir2, [],[F2.txt] )\t\t\t#dir1中没有文件了，退回上一层级，进入dir2文件夹中\n    #读取所有文件/文件名完毕，\n]\n</code></pre>\n<p>只不过他生成的特殊“列表”经常适用于for，不能直接作为列表打印，直接打印是这样子的：</p>\n<pre><code class=\"language-bash\">#code\ndir_path = r'your_dir'\t\t\t\t\t\t#替换为你的文件夹\ndirpath, dirnames, filenames = os.walk(dir_path)\nprint(f'dir_path:{dirpath}\\ndir_name:{dirnames}\\nfile_names:{filenames}')\n\n#result：\n\tdirpath, dirnames, filenames = os.walk(dir_path)\nValueError: too many values to unpack (expected 3)\n</code></pre>\n<p>究其原因是返回的单个迭代器，并非三个列表元组，喜欢细究这部分的见后文，简要的话知道不能直接调用，一般结合<code>for</code>调用就好，这个并非深度挖掘，看完后面会看可能有更好的理解。</p>\n<p>迭代器学习建议：<a href=\"https://www.bilibili.com/video/BV1jt421c7yN/?\" rel=\"noopener nofollow\" target=\"_blank\">【Python】从迭代器到生成器：小内存也能处理大数据</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-调用样例\">3 调用样例：</h3>\n<p>前面参数有点不好理解也没关系，只要大概知道就好了，下面是实际函数使用</p>\n<ol>\n<li>先复制下面代码至新py文件，改一下 <code>dir_path</code>运行一下体会一下</li>\n</ol>\n<pre><code class=\"language-python\">import os\n\ndef walk_example(dir_path:str):\n    #os.walk 返回类似于三元组列表结构，然后进行遍历\n    for root, dir_names, file_names in os.walk(dir_path):   #(dirpath, dirnames, filenames)\n        print(f'dirpath :{root}')\n        print(f'dir_names :{dir_names}')\n        print(f'file_names:{file_names}')\n        print('-'*50)\n\n\nif __name__ == '__main__':\n    dir_path = r'your_dir_path'\n    walk_example(dir_path)\n</code></pre>\n<ol start=\"2\">\n<li>\n<p>输出结果：</p>\n<img alt=\"image-20251222223407130\" class=\"lazyload\" />\n<p>这里可以看出（默认状态下），是从顶向下，一层层遍历。</p>\n<blockquote>\n<p>dirpath : <code>x:\\your_path\\walk</code></p>\n<p>dir_names :['root']<br />\nfile_names:['root_text.txt']</p>\n</blockquote>\n<ul>\n<li>这里是根目录中出现的文件夹名称(root)、文件('root_text.txt')</li>\n</ul>\n<blockquote>\n<p>dirpath :<code>x:\\your_path\\walk\\root</code><br />\ndir_names :['dir1', 'dir2']<br />\nfile_names:['F1.txt']</p>\n</blockquote>\n<ul>\n<li>进入了root文件夹，里面包含<strong>两个文件夹</strong>及当前文件夹根目录下的<strong>单个文件</strong>\n<ul>\n<li>后面两个同理，主要是感受每一层级的变化，每次进入下一个文件夹时，<code>root</code><strong>所表达的属性都会有所变化</strong>，变成了当前根路径。</li>\n<li>除此之外，可以看到，4项的<code>dir_name</code>输出，刚好是我们<strong>全部</strong>的目录名称，<code>file_names</code>同理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>从上文，可以看出 <code>os.walk</code>函数的遍历结果会根据深入的层级输出以下信息：</p>\n<ul>\n<li>当前文件路径（str）</li>\n<li>存在的文件夹（list）</li>\n<li>存在的文件（list）</li>\n</ul>\n<p>把他们聚合起来，就能获取我们所需要的：</p>\n<ul>\n<li>提取文件夹信息（或处理）</li>\n<li>提取文件信息（或处理）</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"4-实际运用案例最佳实践\">4 实际运用案例（最佳实践）</h3>\n<p>本小节会从以下几点来说明如何通过<code>os.walk</code>进行文件的提取及处理。</p>\n<ul>\n<li>提取全部信息（文件夹、文件）【理解调用方式】</li>\n<li>构造文件夹中，所有文件的路径</li>\n<li>根据关键字提取（文件/文件夹）路径</li>\n</ul>\n<h4 id=\"41-提取全部信息文件夹文件理解调用方式\">4.1 提取全部信息（文件夹、文件）【理解调用方式】</h4>\n<p>​\t很简单，只要把对应全部输出收集起来，就能获得我们需要的全文件名、文件信息了。</p>\n<pre><code class=\"language-python\">def walk_get_all_info(dir_path:str):\n    '''\n    获取所有文件名、文件信息\n    :param dir_path: 输入文件夹路径\n    '''\n    dir_list = []\n    file_list = []\n    for root, dirnames, files in os.walk(dir_path):\n        for dir_name in dirnames:\n            dir_list.append(dir_name)\n            # print(dir_name)\t\t\t\t\t#不理解可以调试来一下理解一下，两者是相互独立的\n        for file in files:\n            file_list.append(file)\n            # print(file)\n    print(dir_list)\n    print(file_list)\nif __name__ == '__main__':\n    dir_path = r'your_path'\n    walk_get_all_info(dir_path)\n</code></pre>\n<p>​\t输出：</p>\n<blockquote>\n<p>root<br />\nroot_text.txt<br />\ndir1<br />\ndir2<br />\nF1.txt<br />\nF2.txt</p>\n</blockquote>\n<h4 id=\"42-构造文件夹中所有文件的路径\">4.2 构造文件夹中，所有文件的路径</h4>\n<p>​\t通过<strong>4.1</strong> 我们知道了<code>os.walk</code>的迭代方式。可以通过“当前根目录”与 “所需文件名称”相结合，从而遍历所有文件的路径。</p>\n<pre><code class=\"language-python\">def walk_get_file_path(dir_path:str):\n    '''\n    获取文件路径\n    :param dir_path: 输入文件夹路径\n    '''\n\n    file_list = []\n    for root, dirnames, files in os.walk(dir_path):\n        print(f'local root path :{root}')\n        for file in files:\n            file_path = os.path.join(root, file)        #window 上，等价于 root + \"\\\\\" + file\n            # file_path = root + \"\\\\\" + file\n            print(f'file path :{file_path}')\n            file_list.append(file_path)\n        print('-'*50)\n    print(file_list)\n</code></pre>\n<h4 id=\"43-根据关键字提取文件路径\">4.3 根据关键字提取文件路径</h4>\n<p>​\t这里以最简单的关键字提取，即 <code>if keyword in file</code>为例。</p>\n<pre><code class=\"language-python\">def filter_by_key_word(dir_path,key_word:str='F1'):   \n    '''\n    文件夹路径以关键字，递归查找符合关键字的文件\n    :param dir_path: 输入根文件夹\n    :param key_word: 关键字\n    '''\n    res:list = []\n    for root, dirnames, files in os.walk(dir_path):\n        for file in files:\n            if key_word in file:\n                res.append(\n                    os.path.join(root, file)\n                )\n    print(res)\n    return\n</code></pre>\n<p>按照预期，就应该输出<code>F1</code>：</p>\n<blockquote>\n<p>['E:\\walk\\root\\F1.txt']</p>\n</blockquote>\n<p>更改关键字，也可以做到筛选不同文件的功能，可以自己改一下。对<code>files</code>迭代改为对<code>dirname</code>迭代，一样能完成对文件夹的关键字提取，可以尝试一下</p>\n<h4 id=\"44-其他运用\">4.4 其他运用</h4>\n<p>​\t能找到文件地址，后续就可以按照你想处理的方式对文件进行处理了，这个根据各自需要进行扩展就好，教程结束。</p>\n<h3 id=\"5-部分代码\">5. 部分代码：</h3>\n<pre><code class=\"language-python\">import os\n\ndef walk_example(dir_path:str):\n\t\n    # walk_iter = os.walk(dir_path)\n    # print(walk_iter.__next__())\n\n\n    for root, dir_names, file_names in os.walk(dir_path):   #(dirpath, dirnames, filenames)\n        print(f'dirpath :{root}')\n        print(f'dir_names :{dir_names}')\n        print(f'file_names:{file_names}')\n        print('-'*50)\n\n\ndef walk_get_file_path(dir_path:str):\n    '''\n    获取文件路径\n    :param dir_path: 输入文件夹路径\n    '''\n\n    file_list = []\n    for root, dirnames, files in os.walk(dir_path):\n        print(f'local root path :{root}')\n        for file in files:\n            file_path = os.path.join(root, file)        #window 上，等价于 root + \"\\\\\" + file\n            # file_path = root + \"\\\\\" + file\n            print(f'file path :{file_path}')\n            file_list.append(file_path)\n        print('-'*50)\n    print(file_list)\n    return\n\ndef filter_by_key_word(dir_path,key_word:str='F1'):\n    '''\n    文件夹路径以关键字，递归查找符合关键字的文件\n    :param dir_path: 输入根文件夹\n    :param key_word: 关键字\n\n    '''\n    res:list = []\n    for root, dirnames, files in os.walk(dir_path):\n        for file in files:\n            if key_word in file:\n                res.append(\n                    os.path.join(root, file)\n                )\n    print(res)\n    return\n\nif __name__ == '__main__':\n    dir_path = r'your_path'\n    # walk_example(dir_path)\n    # walk_get_file_path(dir_path)\n    filter_by_key_word(dir_path)\n</code></pre>\n<h3 id=\"6-迭代器相关非必须\">6 迭代器相关（非必须）</h3>\n<p>​\t建议先去学习一下什么是迭代器，再看这个演示代码，对<code>os.walk</code>理解会更深，这边还是建议学一下的，如果够时间的话，趁学os.walk多学一个迭代器/生成器，何乐而不为呢，函数讲解塞里面了，就这样吧。</p>\n<pre><code class=\"language-python\">def iter_example(dir_path:str):\n    '''\n    迭代器理解代码\n    :param dir_path:\n    '''\n    #我没记错的话，是要有__next__ 和 __iter__ 类方法，才能是迭代器类\n    walk_iter = os.walk(dir_path)\n    print(walk_iter.__next__())         #获取迭代器的下一个元素，一般都用next访问下一个元素\n    print(walk_iter.__iter__())         #获取迭代器本身，这里os.walk返回的是generator object，本质上也是迭代器，不太能获取当前迭代器的元素噢！\n    print(next(walk_iter))              #相同写法\n    print('#'*25+\"分隔符\"+'#'*25)\n    count = 0\n    while True:\n        count += 1\n        try:\n            print(f'next element:{walk_iter.__next__()}')\n            print(\"-\"*50 + f\"{count}\")\n        except Exception as e:          #无可迭代对象后，会raise一个StopIteration Error\n            # print('finish iter, break')\n            # break                         #常规循环退出机制\n            raise e\n\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-29 23:19</span>&nbsp;\n<a href=\"https://www.cnblogs.com/io-T-T\">io_T_T</a>&nbsp;\n阅读(<span id=\"post_view_count\">3</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "docker-compose 部署单节点 kafka 4.0 测试环境",
      "link": "https://www.cnblogs.com/apocelipes/p/19417908",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/apocelipes/p/19417908\" id=\"cb_post_title_url\" title=\"发布于 2025-12-29 20:34\">\n    <span>docker-compose 部署单节点 kafka 4.0 测试环境</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>高版本kafka已经不再需要ZooKeeper当保姆才能启动了，现在部署一个单机单节点测试环境比原来方便不少。</p>\n<p>不过最常用的<code>bitnami/kafka</code>不再提供免费镜像，导致我们只能用<code>apache/kafka</code>，新镜像的配置会稍微麻烦一些，所以记录一下。</p>\n<p>部署内容：</p>\n<ul>\n<li>单节点kafka服务，版本4.0+</li>\n<li>kafka UI，方便管理，版本用最新的</li>\n<li>开启简单的用户名密码验证</li>\n</ul>\n<p>docker-compose文件：</p>\n<pre><code class=\"language-yaml\">version: '3'\n\nnetworks:\n  kafka-net:\n\nservices:\n  kafka:\n    image: apache/kafka:latest\n    container_name: kafka\n    networks:\n      - kafka-net\n    ports:\n      - \"9092:9092\"\n    volumes:\n      - ./kafka_data:/var/lib/kafka/data\n      - ./kafka_server_jaas.conf:/etc/kafka/kafka_server_jaas.conf # 配置用户名密码\n    environment:\n      KAFKA_NODE_ID: 1\n      KAFKA_PROCESS_ROLES: 'broker,controller'\n      KAFKA_CONTROLLER_QUORUM_VOTERS: '1@localhost:9093'\n      KAFKA_CONTROLLER_LISTENER_NAMES: 'CONTROLLER'\n      \n      # 定义监听器：EXTERNAL(9092) 走 SASL 认证，PLAINTEXT(29092) 给容器内用（这里也改为 SASL 确保安全）\n      KAFKA_LISTENERS: 'SASL_PLAINTEXT://0.0.0.0:29092,EXTERNAL://0.0.0.0:9092,CONTROLLER://0.0.0.0:9093'\n      KAFKA_ADVERTISED_LISTENERS: 'SASL_PLAINTEXT://kafka:29092,EXTERNAL://localhost:9092'\n      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: 'CONTROLLER:PLAINTEXT,SASL_PLAINTEXT:SASL_PLAINTEXT,EXTERNAL:SASL_PLAINTEXT'\n      KAFKA_INTER_BROKER_LISTENER_NAME: 'SASL_PLAINTEXT'\n      \n      # SASL/PLAIN 认证配置\n      KAFKA_SASL_ENABLED_MECHANISMS: 'PLAIN'\n      KAFKA_SASL_MECHANISM_INTER_BROKER_PROTOCOL: 'PLAIN'\n      # 告诉 Kafka 读取我们的 JAAS 文件\n      KAFKA_OPTS: \"-Djava.security.auth.login.config=/etc/kafka/kafka_server_jaas.conf\"\n\n      # 数据持久化\n      KAFKA_LOG_DIRS: '/var/lib/kafka/data'\n\n  kafka-ui:\n    image: provectuslabs/kafka-ui:latest\n    container_name: kafka-ui\n    depends_on:\n      - kafka\n    networks:\n      - kafka-net\n    ports:\n      # 映射到8090，因为8080一般还得挂其他的服务做测试\n      - \"8090:8080\"\n    environment:\n      KAFKA_CLUSTERS_0_NAME: local\n      KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS: kafka:29092\n      # 配置 UI 使用用户名和密码连接 Kafka\n      KAFKA_CLUSTERS_0_PROPERTIES_SECURITY_PROTOCOL: SASL_PLAINTEXT\n      KAFKA_CLUSTERS_0_PROPERTIES_SASL_MECHANISM: PLAIN\n      KAFKA_CLUSTERS_0_PROPERTIES_SASL_JAAS_CONFIG: 'org.apache.kafka.common.security.plain.PlainLoginModule required username=\"你配置的用户名\" password=\"你配置的密码\";'\n</code></pre>\n<p>配置文件里输入用户和密码：</p>\n<pre><code class=\"language-conf\">KafkaServer {\n    org.apache.kafka.common.security.plain.PlainLoginModule required\n    username=\"节点在集群内通信时的用户名\"\n    password=\"节点在集群内通信时的密码\"\n    # 下面这些才是用户配置\n    # 格式user_&lt;用户名&gt;=\"密码\"\n    user_apot=\"你配置的密码\";\n};\n</code></pre>\n<p>创建好文件和目录之后用<code>docker-compose up -d</code>就能启动服务了。访问<code>localhost:8090</code>可以看到kafka的web控制面板：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1434464/202512/1434464-20251229202723957-374430349.png\" /></p>\n<p>安装好之后可以用下面的命令查看版本：</p>\n<pre><code class=\"language-console\">$ docker exec -it kafka /opt/kafka/bin/kafka-server-start.sh --version\n\n[2025-12-29 11:08:34,595] INFO Registered kafka:type=kafka.Log4jController MBean (kafka.utils.Log4jControllerRegistration$)\n4.0.0\n</code></pre>\n<p>可以看到已经配置好了kafka 4.0环境。</p>\n<p><code>apache/kafka</code>的镜像里内置了各种操作kafka的脚本，不过这些脚本没被添加进<code>$PATH</code>，执行的时候需要指定路径：</p>\n<pre><code class=\"language-bash\"># 先配置登录验证信息\ndocker exec -it kafka bash -c \"cat &lt;&lt;EOF &gt; /tmp/client.conf\nsecurity.protocol=SASL_PLAINTEXT\nsasl.mechanism=PLAIN\nsasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required \\\n  username='客户端登录用户名，就是我们之前用user_xxx配置的那些' \\\n  password='客户端登录密码';\nEOF\"\n\n# 调用脚本创建一个topic，需要指定脚本路径\ndocker exec -it kafka /opt/kafka/bin/kafka-topics.sh --command-config /tmp/client.conf \\\n  --bootstrap-server localhost:9092 \\\n  --create \\\n  --topic test.data \\\n  --partitions 1 \\\n  --replication-factor 1 \\\n  --config cleanup.policy=delete \\\n  --config retention.ms=86400000\n</code></pre>\n<p>所有脚本都存放在<code>/opt/kafka/bin</code>路径下，调用前还需要提供登录凭证信息，这些需要注意。打开<code>localhost:8090</code>上的web UI，就能找到我们刚刚创建的topic了：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1434464/202512/1434464-20251229202843717-1676041370.png\" /></p>\n<p>过期处理策略和过期时间也已经被正确设置：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1434464/202512/1434464-20251229203013465-1213915024.png\" /></p>\n<p>总体而言执行脚本还是有些繁琐，我更愿意通过代码或者web界面来做这些操作。</p>\n<p>最后我们写一个go的测试代码，向我们的测试用单节点kafka里写入一些数据：</p>\n<pre><code class=\"language-golang\">package main\n\nimport (\n\t\"context\"\n\t\"math/rand/v2\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/segmentio/kafka-go\"\n\t\"github.com/segmentio/kafka-go/sasl/plain\"\n)\n\nconst (\n\ttopic         = \"lean.data1\"\n\tkafkaEndpoint = \"localhost:9092\"\n)\n\nfunc main() {\n\tmechanism := plain.Mechanism{\n\t\tUsername: \"客户端登录用户名\",\n\t\tPassword: \"客户端登录密码\",\n\t}\n\n\tdialer := &amp;kafka.Dialer{\n\t\tTimeout:       10 * time.Second,\n\t\tDualStack:     true,\n\t\tSASLMechanism: mechanism,\n\t}\n\n\tw := kafka.NewWriter(kafka.WriterConfig{\n\t\tBrokers: []string{kafkaEndpoint},\n\t\tDialer:  dialer, // 必须传入带 SASL 的 dialer\n\t\tAsync:   false,\n\t})\n\tdefer w.Close()\n\n\tmsg := kafka.Message{\n\t\tTopic: topic,\n\t\tKey:   []byte(\"test\"),\n\t\tValue: []byte(strconv.Itoa(rand.Int())), // 随便写入一些随机数据\n\t}\n\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\terr := w.WriteMessages(ctx, msg)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n</code></pre>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1434464/202512/1434464-20251229202601662-326565622.png\" /></p>\n<p>可以看到我们的随机数已经正常写入topic了。</p>\n<p>注意：这个配置只使用了最基本的验证，且是单节点，不适合在测试和学习之外的任何用途使用，为了安全我也建议在测试完成之后就立刻用<code>docker-compose down</code>关闭服务。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-29 20:34</span>&nbsp;\n<a href=\"https://www.cnblogs.com/apocelipes\">apocelipes</a>&nbsp;\n阅读(<span id=\"post_view_count\">17</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【大数据 & AI】Flink Agents 源码解读 --- (2) ---  核心架构",
      "link": "https://www.cnblogs.com/rossiXYZ/p/19369781",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/rossiXYZ/p/19369781\" id=\"cb_post_title_url\" title=\"发布于 2025-12-29 20:24\">\n    <span>【大数据 &amp; AI】Flink Agents 源码解读 --- (2) ---  核心架构</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"aiflink-agents-2\">【大数据 &amp; AI】Flink Agents 源码解读 --- (2) ---  核心架构</h1>\n<p>[toc]</p>\n<h2 id=\"x00\">0x00 摘要</h2>\n<p>Flink Agents 框架的核心是 <strong>“事件驱动 + 状态隔离 + 多语言协作”</strong>：通过 Agent/AgentPlan 实现业务逻辑的声明式定义，借助 Flink 原生的分布式、高并发能力实现可靠执行，同时支持 Python 生态的工具 / 模型集成，兼顾了开发灵活性与运行时效率，适用于复杂 AI 代理任务的分布式部署与执行。</p>\n<p>具体而言，Flink Agents 的组件是对原生 Flink 组件在 “Agent 业务场景” 下的语义化封装，而非全新发明。因此，本文将先介绍Flink Agents的基本组件，然后将其组件与Flink 原生组件做对比，最后给出一个详细的例子，这样读者可以更好的理解其设计精要。</p>\n<h2 id=\"x01-flink-agents\">0x01 Flink Agents主要组件</h2>\n<p>可以把 Flink Agents 的整个执行流程比作 “做一道菜”，我们借此进行分析。</p>\n<h3 id=\"section\">1.1 主要组件</h3>\n<p>Flink Agents 是基于原生 Flink 分布式流处理能力封装的上层框架。其中四个主要组件代表了 Flink Agents 框架中的四个层次：</p>\n<ul>\n<li><strong>Agent（顶层设计，定义了“做什么”）</strong>：用户定义的智能实体，类似 “餐厅菜单 + 规则手册”，包含业务逻辑、动作（Action）和资源（工具、模型等）定义，明确 “做什么”。</li>\n<li><strong>AgentPlan（中间编译层，确定了“怎么做”）</strong>：将 Agent 编译后的可执行计划，类似 “详细操作流程图”，明确动作触发规则、资源映射关系，确定 “怎么做”。</li>\n<li><strong>ActionExecutionOperator（运行时执行层，是执行环境，负责“协调调度”）</strong>：Flink 集群中的执行核心，在 Flink 流处理环境中实际执行操作，类似 “餐厅首席大厨”，负责接收数据、调度任务、管理状态，协调整体执行流程。</li>\n<li><strong>ActionTask（最小执行单元，负责“具体实施”）</strong>：具体的执行任务，类似 “员工的单个服务步骤”，分为 JavaActionTask 和 PythonActionTask，处理单个事件并返回结果。</li>\n</ul>\n<p>具体可以参见下图。</p>\n<pre><code class=\"language-python\">[Agent] 菜单手册\n    ↓（编译）\n[AgentPlan] 详细流程图\n    ↓（运行时实例化）\n[ActionExecutionOperator] 餐厅首席大厨\n    ↓（分配任务）\n[ActionTask] 员工具体任务\n</code></pre>\n<p>这样的设计使得系统既灵活又高效，能够处理复杂的AI代理任务，同时保证了良好的扩展性和维护性。</p>\n<h3 id=\"section-1\">1.2 内部成员变量映射关系</h3>\n<p>Agent、AgentPlan 和 ActionExecutionOperator 之间的关系以及它们内部成员变量的映射关系如下。</p>\n<h4 id=\"agent-agentplan\">1.2.1 Agent 到 AgentPlan</h4>\n<p>Agent 到 AgentPlan 的映射如下：</p>\n<table>\n<thead>\n<tr>\n<th>Agent 成员</th>\n<th>AgentPlan 对应成员</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>_actions（装饰器定义）</td>\n<td>actions, actions_by_event</td>\n<td>Agent 中通过 @action 装饰器定义的动作被编译到 AgentPlan 的动作映射中</td>\n</tr>\n<tr>\n<td>_actions（add_action 添加）</td>\n<td>actions, actions_by_event</td>\n<td>通过 add_action 方法添加的动作同样编译到动作映射中</td>\n</tr>\n<tr>\n<td>_resources</td>\n<td>resource_providers</td>\n<td>Agent 中注册的资源被转换为资源提供者</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"agentplan-actionexecutionoperator\">1.2.2 AgentPlan 到 ActionExecutionOperator</h4>\n<p>AgentPlan 到 ActionExecutionOperator 的映射如下：</p>\n<table>\n<thead>\n<tr>\n<th>AgentPlan 成员</th>\n<th>ActionExecutionOperator 对应成员</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>actions</td>\n<td>通过 getActionsTriggeredBy() 方法调用</td>\n<td>Operator 根据事件类型查找对应的动作</td>\n</tr>\n<tr>\n<td>resource_providers</td>\n<td>在 RunnerContextImpl 中使用</td>\n<td>提供运行时所需的资源</td>\n</tr>\n<tr>\n<td>config</td>\n<td>metricGroup, builtInMetrics 等</td>\n<td>用于配置指标和其他运行时行为</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"section-2\">详细映射分析</h5>\n<h6 id=\"section-3\">动作执行映射</h6>\n<p>在 <code>ActionExecutionOperator</code> 中：</p>\n<pre><code class=\"language-java\">// 根据事件类型获取触发的动作\nprivate List&lt;Action&gt; getActionsTriggeredBy(Event event) {\n    if (event instanceof PythonEvent) {\n        return agentPlan.getActionsTriggeredBy(((PythonEvent) event).getEventType());\n    } else {\n        return agentPlan.getActionsTriggeredBy(event.getClass().getName());\n    }\n}\n\n// 创建 ActionTask 来执行动作\nprivate ActionTask createActionTask(Object key, Action action, Event event) {\n    if (action.getExec() instanceof JavaFunction) {\n        return new JavaActionTask(\n            key, event, action, getRuntimeContext().getUserCodeClassLoader());\n    } else if (action.getExec() instanceof PythonFunction) {\n        return new PythonActionTask(key, event, action);\n    }\n    // ..\n}\n</code></pre>\n<h6 id=\"section-4\">资源管理映射</h6>\n<p><code>AgentPlan</code> 中的资源提供者在 <code>ActionExecutionOperator</code> 中通过 <code>RunnerContextImpl</code> 访问：</p>\n<pre><code class=\"language-java\">// 在 RunnerContextImpl 中\npublic Resource getResource(String name, ResourceType type) {\n    return agentPlan.getResource(name, type);\n}\n</code></pre>\n<h6 id=\"section-5\">配置映射</h6>\n<p>AgentPlan 中的配置信息被用于初始化ActionExecutionOperator的各种运行时组件：</p>\n<pre><code class=\"language-java\">// 在 ActionExecutionOperator.open() 中\nmetricGroup = new FlinkAgentsMetricGroupImpl(getMetricGroup());\nbuiltInMetrics = new BuiltInMetrics(metricGroup, agentPlan);\n\n// ActionStateStore 初始化也依赖于配置\nif (actionStateStore == null &amp;&amp; KAFKA.getType().equalsIgnoreCase(agentPlan.getConfig().get(ACTION_STATE_STORE_BACKEND))) {\n    actionStateStore = new KafkaActionStateStore(agentPlan.getConfig());\n}\n</code></pre>\n<h6 id=\"section-6\">状态管理映射</h6>\n<p>ActionExecutionOperator 中的各种状态与 AgentPlan 的执行需求相对应：</p>\n<pre><code class=\"language-java\">// 短期内存状态用于动作间的数据共享\nprivate transient MapState&lt;String, MemoryObjectImpl.MemoryItem&gt; shortTermMemState;\n\n// 动作任务状态用于异步执行管理\nprivate transient ListState&lt;ActionTask&gt; actionTasksState;\n\n// 待处理事件状态用于流控\nprivate transient ListState&lt;Event&gt; pendingInputEventsState;\n</code></pre>\n<h3 id=\"section-7\">1.3 执行流程</h3>\n<p>具体流程如下：</p>\n<pre><code class=\"language-python\">Action Code → Agent → AgentPlan → ActionExecutionOperator → ActionTask → Flink Runtime\n</code></pre>\n<p>以 ReActAgent 为例，其流程如下：</p>\n<ul>\n<li><p>用户定义 ReActAgent，包含 <code>start_action</code> 和 <code>stop_action</code></p>\n</li>\n<li><p>通过 <code>AgentPlan.from_agent()</code> 编译成计划：</p>\n<ul>\n<li><p><code>actions</code>：包含 <code>start_action</code> 和 <code>stop_action</code></p>\n</li>\n<li><p><code>actions_by_event</code>：映射 <code>InputEvent</code> → <code>start_action</code>，<code>ChatResponseEvent</code> → <code>stop_action</code></p>\n</li>\n</ul>\n</li>\n<li><p>在运行环境中，AgentPlan 被传递给 ActionExecutionOperatorFactory。ActionExecutionOperatorFactory 创建 ActionExecutionOperator 实例。</p>\n</li>\n<li><p>ActionExecutionOperator 在运行时根据 AgentPlan 执行具体操作。在 ActionExecutionOperator 中：</p>\n<ul>\n<li>接收到 InputEvent 后，查找并执行 start_action</li>\n<li>start_action 发送 ChatRequestEvent</li>\n<li>查找并执行处理 ChatRequestEvent 的内置动作（如 CHAT_MODEL_ACTION）</li>\n<li>PythonActionTask 执行工具函数，若为生成器则创建 PythonGeneratorActionTask 持续执行；</li>\n<li>工具执行完成生成 ChatResponseEvent</li>\n<li>查找并执行 stop_action</li>\n<li>stop_action 产生 OutputEvent 并发送到下游</li>\n</ul>\n</li>\n</ul>\n<p>这种设计实现了关注点分离：用户只需关注业务逻辑定义，框架负责将其编译为高效的运行时执行计划。</p>\n<h2 id=\"x02-flink\">0x02 与原生Flink比对</h2>\n<p>Flink Agents 是原生 Flink 的 “领域封装”：所有组件都能映射到原生 Flink 核心组件，未脱离 Flink 流处理的核心架构。我们接下来看看 Flink Agents 里的 Agent、AgentPlan、ActionExecutionOperator、ActionTask 这些核心组件，分别对应原生 Flink 中的哪些核心组件，以及它们的相似性逻辑。</p>\n<h3 id=\"section-8\">2.1 核心</h3>\n<p>我们先用一张表来概括比对关系。</p>\n<table>\n<thead>\n<tr>\n<th>Flink Agents 组件</th>\n<th>原生 Flink 对应组件</th>\n<th>核心角色</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Agent</td>\n<td>StreamGraph / 用户 DataStream 代码</td>\n<td>高层业务逻辑声明（做什么）</td>\n</tr>\n<tr>\n<td>AgentPlan</td>\n<td>JobGraph</td>\n<td>编译后的可执行计划（怎么拆）</td>\n</tr>\n<tr>\n<td>ActionExecutionOperator</td>\n<td>KeyedProcessOperator/StreamOperator</td>\n<td>运行时核心执行算子（核心载体）</td>\n</tr>\n<tr>\n<td>ActionTask</td>\n<td>算子内处理单元 / AsyncFunction 任务</td>\n<td>原子执行任务（最小执行单元）</td>\n</tr>\n</tbody>\n</table>\n<p>核心映射逻辑如下：「声明层（Agent）→ 编译层（AgentPlan）→ 执行算子（ActionExecutionOperator）→ 原子任务（ActionTask）」对应原生 Flink 的「StreamGraph → JobGraph → StreamOperator → 算子内处理单元」；</p>\n<p>回到 “做一道菜” ，我们进行分拆对比。</p>\n<ul>\n<li>Agent = 你写的 “菜谱逻辑”（比如 “做番茄炒蛋，先炒蛋再炒番茄”）→ 对应 Flink StreamGraph（纯逻辑）；</li>\n<li>AgentPlan = 餐厅后厨把菜谱转换成的 “可执行工单”（明确 “谁来炒、用哪个锅、放多少盐”）→ 对应  Flink JobGraph（可执行计划）；</li>\n<li>ActionExecutionOperator = 掌勺厨师（执行工单）→ 对应 Flink  StreamOperator；</li>\n<li>ActionTask = 厨师的 “单个翻炒动作”→ 对应 Flink 算子内的原子处理任务；</li>\n<li>Flink ExecutionGraph = 厨师实际站在哪个灶台、用哪套厨具 → 物理执行层，和 AgentPlan 无关。</li>\n</ul>\n<h3 id=\"section-9\">2.2 具体比对</h3>\n<h4 id=\"agent\">2.2.1 Agent</h4>\n<ul>\n<li><strong>相似组件</strong>：Flink Job 的业务逻辑定义（如 DataStream 算子链）、StreamGraph（流式作业的逻辑拓扑）</li>\n<li><strong>相似性核心</strong>：Agent 是用户定义的 “智能实体”（包含业务逻辑、动作、资源），本质是业务层面的 “作业逻辑声明”；这和原生 Flink 中用户编写的 DataStream 代码（定义 “数据怎么处理”）、StreamGraph（描述逻辑拓扑）的角色完全一致 —— 都是 “告诉系统要做什么” 的顶层逻辑定义，不涉及具体执行。</li>\n<li><strong>差异</strong>：Agent 更聚焦 “Agent 行为 / 工具调用” 的语义，而原生 StreamGraph 是通用的数据流拓扑。</li>\n</ul>\n<h4 id=\"agentplan\">2.2.2 AgentPlan</h4>\n<ul>\n<li><strong>相似组件</strong>：Flink 的 JobGraph（StreamGraph 编译后的可执行拓扑）</li>\n<li><strong>相似性核心</strong>：AgentPlan 是 Agent 编译后的 “可执行计划”（明确动作触发规则、资源映射），本质是将高层业务逻辑转换为系统可识别的执行计划；这和原生 Flink 中 StreamGraph 编译为 JobGraph 的过程一致 ——JobGraph 把用户的逻辑拓扑转换为包含并行度、算子链、中间结果传递的可执行拓扑，AgentPlan 则把 Agent 的 “行为规则” 转换为系统可调度的 “动作执行规则”。</li>\n<li><strong>关键共性</strong>：都是 “编译层” 产物，连接高层定义与底层执行。</li>\n</ul>\n<h4 id=\"actionexecutionoperator\">2.2.3 ActionExecutionOperator</h4>\n<ul>\n<li><p><strong>相似组件</strong>：Flink 核心的 StreamOperator（如 ProcessOperator、FlatMapOperator）、KeyedProcessOperator</p>\n</li>\n<li><p><strong>相似性核心</strong>：ActionExecutionOperator 是 Flink 集群中执行 Agent 逻辑的核心算子，本质是运行时的核心执行单元；这和原生 Flink 的 StreamOperator 完全对应 ——StreamOperator 是处理数据流的核心载体（如 ProcessOperator 处理 KeyedStream、实现状态管理），ActionExecutionOperator 就是针对 “Agent 动作执行” 场景定制的 StreamOperator：</p>\n<ul>\n<li>都运行在 TaskManager 中，处理流数据（Event）；</li>\n<li>都支持键控状态（Keyed State），按 key 隔离执行上下文；</li>\n<li>都依赖 Mailbox 机制调度任务，避免阻塞；</li>\n<li>都负责状态管理、事件处理、结果输出。</li>\n</ul>\n</li>\n<li><p><strong>典型对应</strong>：ActionExecutionOperator 最接近原生的 <code>KeyedProcessOperator</code>（键控处理、状态管理、异步任务调度）。</p>\n</li>\n</ul>\n<h4 id=\"actiontask\">2.2.3 ActionTask</h4>\n<ul>\n<li><p><strong>相似组件</strong>：Flink 的「算子内的处理任务」（如 ProcessFunction 中的单个元素处理逻辑）、Async I/O 中的 <code>AsyncFunction</code> 任务</p>\n</li>\n<li><p><strong>相似性核心</strong>：ActionTask 是 “最小执行单元”（如单个 Python/Java 动作执行），本质是算子内的原子处理任务；这和原生 Flink 中：</p>\n<ul>\n<li>ProcessOperator 处理单个 StreamElement（如一条数据）的逻辑单元；</li>\n<li>Async I/O 中 AsyncFunction 封装的异步任务（如异步查询数据库）；</li>\n</ul>\n<p>角色完全一致 —— 都是 “算子内的最小可执行任务”，执行完成后返回结果，支持异步 / 分阶段执行。</p>\n</li>\n<li><p><strong>关键共性</strong>：</p>\n<ul>\n<li>都是 “原子执行单元”，不可再拆分；</li>\n<li>支持异步执行（如 PythonActionTask 对应 Async I/O）；</li>\n<li>执行结果可触发后续任务（如 ActionTaskResult 生成新任务，对应 Async I/O 回调触发后续处理）。</li>\n</ul>\n</li>\n<li><p><strong>细分对应</strong>：</p>\n<ul>\n<li>JavaActionTask → 原生同步处理任务（如 ProcessFunction 中的同步逻辑）；</li>\n<li>PythonActionTask → 原生 Async I/O 任务（异步调用外部服务 / 脚本）。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"x03\">0x03 实例拆解</h2>\n<p>我们来进一步解释 Flink Agents 这几个核心概念的关系和配合。为了更好的说明，我们可以把整个Flink Agents系统从”做一道菜“拓展到”一个智能餐厅自动化服务系统“。同时，结合实例也深入下技术细节。</p>\n<h3 id=\"agent-blueprint\">3.1 第一层级：Agent – 餐厅菜单和规则手册（Blueprint）</h3>\n<p>Flink Agents 中的 Agent 是用户定义的智能实体，负责协调各种资源和行为来完成特定的任务。我们把 Agent 想象成餐厅的菜单和运营手册：</p>\n<ul>\n<li><p>定义了餐厅能提供哪些菜品和服务（动作）</p>\n</li>\n<li><p>规定了需要用到哪些设备和食材（资源），如同为新员工配备工具箱，对应程序员实际用到的，可以是：</p>\n<ul>\n<li>各种 API 接口（相当于工具）</li>\n<li>数据库访问权限（相当于参考资料）</li>\n<li>决策逻辑代码（相当于培训材料）</li>\n</ul>\n</li>\n<li><p>遇到什么情况应该做什么（对应事件监听）</p>\n</li>\n<li><p>描述了顾客点餐到上菜的完整流程</p>\n<ul>\n<li>有一个 start_action（接待员）负责接收顾客问题</li>\n<li>有一个 stop_action（收银员）负责最终结账输出结果</li>\n</ul>\n</li>\n</ul>\n<p>这些都被封装在 Agent 对象中。</p>\n<h3 id=\"agentplan-compiled-plan\">3.2 第二层级：AgentPlan – 餐厅的详细操作流程图（Compiled Plan,计划编译层）</h3>\n<p>Flink Agent框架会把用户的 Agent 转换为一个更通用、更适合系统处理的形式 —— AgentPlan。在本例中，AgentPlan 相当于将餐厅运营手册编译成的详细工作流程图（抽象化的工作蓝图）：</p>\n<ul>\n<li>把菜单上的每道菜分解成具体的步骤</li>\n<li>明确每个岗位（动作）在什么情况下被触发，即遇到啥事件（Event）该干啥活（Action）</li>\n<li>准备好所有需要的工具和材料清单（Resource）</li>\n</ul>\n<p>就像餐厅经理会制定详细的操作手册，告诉服务员什么时候该做什么事。</p>\n<h4 id=\"section-10\">结构化解析</h4>\n<p>AgentPlan 包含几个关键部分：</p>\n<p><strong>Actions 映射表</strong></p>\n<ul>\n<li>明确列出所有可以执行的动作及其触发条件</li>\n<li>例如：“收到订单查询请求” → “执行订单查询动作”</li>\n</ul>\n<p><strong>资源提供者目录</strong></p>\n<ul>\n<li>记录所有可用资源的位置和获取方式</li>\n<li>类似于工厂里各个供应部门的联系方式清单</li>\n</ul>\n<p><strong>配置参数集</strong></p>\n<ul>\n<li>存储运行所需的各项设置选项</li>\n<li>像是设备操作规程和技术规范</li>\n</ul>\n<h4 id=\"section-11\">平台适配性</h4>\n<p>通过这种抽象化，无论底层是 Java 还是 Python 实现，都可以统一用同一份 AgentPlan 来进行调度管理。</p>\n<h3 id=\"actionexecutionoperator-runtime-executor\">3.3 第三层级：ActionExecutionOperator – 餐厅的执行管理层（Runtime Executor，执行引擎层）</h3>\n<p>在大规模生产环境中，不能只靠一个管家干活，而是需要一条自动化流水线。ActionExecutionOperator 就像是一条智能化的工厂装配线，它按照操作手册（AgentPlan）组织多个工作站来协同完成任务。或者说，ActionExecutionOperator 是餐厅的现场执行管理层，是整个系统的“大脑 + 中枢控制室”：</p>\n<ul>\n<li>负责接待进店的顾客（接收数据）</li>\n<li>根据流程图分配任务给不同的员工（执行动作）</li>\n<li>协调各个岗位之间的工作（监控进度状态 / 管理状态和内存）</li>\n<li>确保服务流程顺畅（处理并发和容错）</li>\n<li>餐厅经理拿着详细流程图，指挥各个员工协同工作。</li>\n</ul>\n<h3 id=\"actiontask-execution-unit\">3.4 第四层级：ActionTask – 具体的服务步骤（Execution Unit）</h3>\n<p>ActionTask 就像是员工执行的具体服务步骤，是生产线上的最小工位：一次只干一件具体活（调用 Python 函数、查数据库、发 HTTP、写 Kafka …）：</p>\n<ul>\n<li>每个服务员接到的任务就是一个 ActionTask</li>\n<li>可能是简单一步完成（普通服务员）</li>\n<li>可能是需要多步完成（需要回访的技术员），即如果活太多（异步、长耗时），服务员会把自己「切分」成新任务，等下次轮询再接着干，实现非阻塞的协作式调度。</li>\n<li>完成后报告结果，并可能触发下一步工作，即干完就能立即把结果（Event）扔回传送带，继续下一轮</li>\n</ul>\n<h3 id=\"section-12\">3.5 工作流程举例</h3>\n<p>假设顾客来到餐厅点了一份复杂的套餐：</p>\n<ul>\n<li>顾客进店（InputEvent）\n<ul>\n<li>餐厅经理（ActionExecutionOperator）接待顾客</li>\n<li>根据流程图知道应该让接待员（start_action）处理</li>\n</ul>\n</li>\n<li>接待员处理（ActionTask）\n<ul>\n<li>接待员（PythonActionTask）接到任务</li>\n<li>理解顾客需求，生成厨房订单（ChatRequestEvent）</li>\n</ul>\n</li>\n<li>厨房制作（内置动作）\n<ul>\n<li>厨师（CHAT_MODEL_ACTION）收到订单开始制作</li>\n<li>制作完成后通知服务员（ChatResponseEvent）</li>\n</ul>\n</li>\n<li>收银结账（ActionTask）\n<ul>\n<li>收银员（stop_action）处理最终结果</li>\n<li>顾客打包带走（OutputEvent）</li>\n</ul>\n</li>\n</ul>\n<p>「用户只管把管家训好，框架负责把管家变成手册，再把手册变成并行生产线，最后让无数worker按 key 隔离、事件驱动、可检查点的方式跑在 Flink 上。」。</p>\n<h2 id=\"x04\">0x04 并发性和并行性</h2>\n<p>Flink Agents 系统在设计时已经充分考虑了并发性和并行性，比如：</p>\n<ul>\n<li><strong>事件驱动模型</strong>：基于事件流转触发动作，初始为 InputEvent，经多轮事件（如 ChatRequestEvent、ChatResponseEvent）触发，最终输出 OutputEvent。</li>\n<li><strong>并发与隔离设计</strong>：利用 Flink 键控流（KeyedStream）实现按 key 分区，每个 key 拥有独立状态；通过邮箱线程模型（MailboxExecutor）实现协作式多任务，避免阻塞。</li>\n<li><strong>任务切分机制</strong>：长时间运行的任务（如 Python 生成器）会被切分为多个 ActionTask，执行后通过 ActionTaskResult 传递下一个任务，确保并发效率。</li>\n<li><strong>本地与远程执行</strong>：本地用 LocalRunner 模拟执行，远程基于 Flink 集群的 ActionExecutionOperator 分布式执行，保持 API 一致性。</li>\n</ul>\n<p>以下是具体实现方式：</p>\n<h3 id=\"flink\">4.1 Flink原生并发模型</h3>\n<p>系统充分利用了Apache Flink的原生并发机制：</p>\n<ul>\n<li>键控流（Keyed Streams）：使用Flink的KeyedStream按key对数据进行分区，确保相同key的事件由同一个并行实例处理</li>\n<li>并行操作符：ActionExecutionOperator可以在Flink集群中的多个实例上并行运行</li>\n</ul>\n<pre><code class=\"language-java\">// 在CompileUtils.java中 - 将代理连接到键控流\npublic static &lt;IN, K&gt; DataStream&lt;Object&gt; connectToAgent(\n    DataStream&lt;IN&gt; inputStream, KeySelector&lt;IN, K&gt; keySelector, AgentPlan agentPlan) {\n    return connectToAgent(inputStream.keyBy(keySelector), agentPlan);\n}\n</code></pre>\n<p>在 RemoteExecutionEnvironment 中有：</p>\n<pre><code class=\"language-java\">@Override\npublic DataStream&lt;Object&gt; toDataStream() {\n    if (agentPlan == null) {\n        throw new IllegalStateException(\"Must apply agent before calling toDataStream\");\n    }\n\n    if (outputDataStream == null) {\n        if (keySelector != null) {\n            outputDataStream =\n                    CompileUtils.connectToAgent(inputDataStream, keySelector, agentPlan);\n        } else {\n            // If no key selector provided, use a simple pass-through key selector\n            outputDataStream =\n                    CompileUtils.connectToAgent(inputDataStream, x -&gt; x, agentPlan);\n        }\n    }\n\n    return outputDataStream;\n}\n</code></pre>\n<h3 id=\"key\">4.2 每个Key的状态管理</h3>\n<p>每个key都维护独立的状态隔离：</p>\n<pre><code class=\"language-java\">// 在ActionExecutionOperator.java中 - 维护每个key的状态\nprivate transient ListState&lt;ActionTask&gt; actionTasksKState;\nprivate transient ListState&lt;Event&gt; pendingInputEventsKState;\nprivate transient ValueState&lt;Long&gt; sequenceNumberKState;\n</code></pre>\n<p>这些都是键控状态（keyed state），意味着每个key都有自己的独立状态实例，防止不同key之间的竞争条件。</p>\n<h3 id=\"section-13\">4.3 邮箱线程模型</h3>\n<p>系统使用Flink的邮箱线程模型实现协作式多任务处理：</p>\n<pre><code class=\"language-java\">// 在ActionExecutionOperator.java中\nprivate final transient MailboxExecutor mailboxExecutor;\n\n// 提交任务进行处理\nmailboxExecutor.submit(() -&gt; tryProcessActionTaskForKey(key), \"process action task\");\n</code></pre>\n<p>这允许长时间运行的操作让出控制权，防止阻塞整个操作符。</p>\n<h3 id=\"section-14\">4.4 异步任务处理</h3>\n<p>支持异步执行并具备适当的状态管理：</p>\n<pre><code class=\"language-java\">// 在 ActionTask.java 中 - 支持基于延续的执行\npublic class ActionTaskResult {\n    private final boolean finished;\n    private final List&lt;Event&gt; outputEvents;\n    private final Optional&lt;ActionTask&gt; generatedActionTaskOpt;\n\n    // 允许一个动作生成延续任务\n    public Optional&lt;ActionTask&gt; getGeneratedActionTask() {\n        return generatedActionTaskOpt;\n    }\n}\n</code></pre>\n<h3 id=\"section-15\">4.5 内存一致性</h3>\n<p>具有缓存状态访问的线程安全内存管理：</p>\n<pre><code class=\"language-java\">// 在 ActionExecutionOperator.java 中\nprivate void createAndSetRunnerContext(ActionTask actionTask) {\n    // 正确管理 RunnerContext 的创建和重用\n    if (actionTask.getRunnerContext() != null) {\n        return;\n    }\n    // ... 创建适当的 context\n}\n</code></pre>\n<h3 id=\"section-16\">4.6 水印和事件时间处理</h3>\n<p>具备并发意识的水印处理：</p>\n<pre><code class=\"language-java\">    private transient SegmentedQueue keySegmentQueue;\n    \n    keySegmentQueue = new SegmentedQueue();\n\n    @Override\n    public void processWatermark(Watermark mark) throws Exception {\n        keySegmentQueue.addWatermark(mark);\n        processEligibleWatermarks();\n    }\n</code></pre>\n<h3 id=\"section-17\">4.7 检查点和恢复</h3>\n<p>用于容错的线程安全状态快照</p>\n<pre><code class=\"language-java\">    @Override\n    public void snapshotState(StateSnapshotContext context) throws Exception {\n        if (actionStateStore != null) {\n            Object recoveryMarker = actionStateStore.getRecoveryMarker();\n            if (recoveryMarker != null) {\n                recoveryMarkerOpState.update(List.of(recoveryMarker));\n            }\n        }\n\n        HashMap&lt;Object, Long&gt; keyToSeqNum = new HashMap&lt;&gt;();\n        getKeyedStateBackend()\n                .applyToAllKeys(\n                        VoidNamespace.INSTANCE,\n                        VoidNamespaceSerializer.INSTANCE,\n                        new ValueStateDescriptor&lt;&gt;(MESSAGE_SEQUENCE_NUMBER_STATE_NAME, Long.class),\n                        (key, state) -&gt; keyToSeqNum.put(key, state.value()));\n        checkpointIdToSeqNums.put(context.getCheckpointId(), keyToSeqNum);\n\n        super.snapshotState(context);\n    }\n</code></pre>\n<h3 id=\"section-18\">4.8 总结</h3>\n<p>设计采用了多种并发机制：</p>\n<ul>\n<li>Flink并行处理：利用Flink原生的并行性和键控流</li>\n<li>每个Key的隔离：每个key维护独立状态，消除key之间的竞争</li>\n<li>协作式线程：使用邮箱执行器实现非阻塞执行</li>\n<li>异步延续：通过任务链支持长时间运行的操作</li>\n<li>线程安全状态管理：对共享资源进行适当的同步</li>\n<li>容错机制：检查点机制确保故障情况下的数据一致性</li>\n</ul>\n<p>这种方法使系统能够在保持一致性和支持水平扩展的同时处理高吞吐量，可在 Flink 集群的多个节点间扩展。</p>\n<h2 id=\"xff\">0xFF 参考</h2>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-29 20:24</span>&nbsp;\n<a href=\"https://www.cnblogs.com/rossiXYZ\">罗西的思考</a>&nbsp;\n阅读(<span id=\"post_view_count\">8</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Java 哪些情况会导致内存泄漏",
      "link": "https://www.cnblogs.com/yanshajiuzhou/p/19417793",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yanshajiuzhou/p/19417793\" id=\"cb_post_title_url\" title=\"发布于 2025-12-29 19:29\">\n    <span>Java 哪些情况会导致内存泄漏</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        内存泄漏 是指对象 已经不再被程序使用，但因为某些原因 无法被垃圾回收器回收，长期占用内存，最终可能引发&nbsp;OOM（OutOfMemoryError）。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><span>​</span>今天我们来一起聊一聊有哪些情况会导致内存泄漏。</p>\n<p>什么是 <strong>内存泄漏</strong> 呢？</p>\n<p><strong>内存泄漏</strong> 是指对象 <strong>已经不再被程序使用</strong>，但因为某些原因 <strong>无法被垃圾回收器回收</strong>，长期占用内存，最终可能引发&nbsp;<strong>OOM</strong>（OutOfMemoryError）。</p>\n<p>接下来我们看一下常见的几类内存泄漏场景。</p>\n<p><strong>1、生命周期长的集合</strong></p>\n<p>将对象放入 <strong>静态</strong> 或&nbsp;<strong>生命周期很长&nbsp;</strong>的集合（如 public <strong>static</strong> List&lt;Object&gt; list = new ArrayList&lt;&gt;();），即使后面不再需要，集合仍持有其引用，导致无法<strong>GC</strong>。</p>\n<p><strong>2、未关闭的资源</strong></p>\n<p>连接、流等资源未调用<strong> close() </strong>方法关闭。这些资源不仅占用内存，还可能占用文件句柄（操作系统分配的唯一标识，凭它，你才能操作文件资源）、网络连接等系统资源。比如&nbsp;数据库连接、文件流（FileInputStream）、Socket连接 等。</p>\n<pre class=\"language-java highlighter-hljs\"><code>public class FileTest {\n    public static void main(String[] args) {\n        FileInputStream fis = null;\n        try {\n            fis = new FileInputStream(\"test.txt\");\n            // 读取文件，未调用 fis.close()\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } finally {\n            // 未调用 fis.close() → fis 持有 Native 引用，无法回收\n        }\n    }\n}</code></pre>\n<p><strong>3、ThreadLocal 使用不当</strong></p>\n<p>将对象存入 <strong>ThreadLocal </strong>后，未在后续调用 <strong>remove()</strong> 清理。若线程来自线程池（会复用），其 ThreadLocalMap 中的值会一直存活。</p>\n<pre class=\"language-java highlighter-hljs\"><code>public class ThreadLocalTest {\n    private static ThreadLocal&lt;User&gt; userThreadLocal = new ThreadLocal&lt;&gt;();\n\n    public static void main(String[] args) {\n        // 线程池（核心线程长期存活）\n        TThreadPoolExecutor executor = new ThreadPoolExecutor(\n                2,\n                4,\n                10,\n                TimeUnit.SECONDS,\n                new ArrayBlockingQueue&lt;&gt;(100),\n                new ThreadFactoryBuilder().setNameFormat(\"my-thread-pool-%d\").setDaemon(false).setPriority(Thread.NORM_PRIORITY).build(),\n                new ThreadPoolExecutor.AbortPolicy()\n        );\n\n        executor.submit(() -&gt; {\n            User user = new User(\"李四\", 30);\n            userThreadLocal.set(user); // 存储到 ThreadLocal\n\n            // 业务执行完毕，未调用 remove()\n            // 核心线程不会销毁，ThreadLocal 仍持有 user 引用\n        });\n    }\n}</code></pre>\n<p>ps：未进行&nbsp;<strong>remove()</strong>，还可能会导致&nbsp;<strong>ThreadLocal </strong>取值串门。</p>\n<p><strong>4、内部类与外部类引用</strong></p>\n<p>非静态内部类（或匿名类）会&nbsp;<strong>隐式持有&nbsp;</strong>外部类的引用。如果内部类实例生命周期更长（如被缓存或另一个线程引用），会阻止外部类被回收。</p>\n<pre class=\"language-java highlighter-hljs\"><code>public class OuterClass {\n    private byte[] bigData = new byte[1024 * 1024 * 10]; // 10MB 大对象\n\n    // 非静态内部类\n    class InnerClass {\n        // 内部类隐式持有 OuterClass 引用\n    }\n\n    public InnerClass createInner() {\n        return new InnerClass();\n    }\n\n    public static void main(String[] args) {\n        OuterClass outer = new OuterClass();\n        InnerClass inner = outer.createInner();\n\n        // 置空外部类引用，但 inner 仍持有 outer 引用\n        outer = null;\n\n        // 若 inner 被静态变量/线程长期持有 → outer 对象（含 bigData）无法回收\n    }\n}</code></pre>\n<p><strong>5、&nbsp;监听器与回调</strong></p>\n<p>注册了 <strong>监听器&nbsp;</strong>或 <strong>回调</strong> 后，在对象不再需要时 <strong>没有注销</strong>，导致源对象仍持有监听器的引用（比如 事件监听器、消息队列的消费者等）。</p>\n<p><strong>排查工具推荐</strong></p>\n<ul>\n<li><strong>MAT（Memory Analyzer Tool）：</strong>分析堆 Dump 文件，定位泄漏对象、引用链（谁在持有泄漏对象）；</li>\n<li><strong>VisualVM：</strong>JDK 自带工具，监控内存占用趋势，生成堆 Dump，简单排查泄漏。</li>\n</ul>\n<p>这里我只列了常见的几种情况，欢迎大家补充其他内存泄漏场景。</p>\n<p style=\"text-align: right;\"><span style=\"color: rgba(53, 152, 219, 1);\">人间非净土，各有千种愁，万般苦。-- 烟沙九洲</span></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-29 19:29</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yanshajiuzhou\">烟沙九洲</a>&nbsp;\n阅读(<span id=\"post_view_count\">27</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MAF快速入门（9）多路分支路由工作流",
      "link": "https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper09",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper09\" id=\"cb_post_title_url\" title=\"发布于 2025-12-29 18:30\">\n    <span>MAF快速入门（9）多路分支路由工作流</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"MAF快速入门（9）多路分支路由工作流\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/381412/202512/381412-20251224203108188-1569801702.png\" />\n        上一篇，我们学习了MAF中如何进行if-else类型的条件路由，但是实际工作中可能会村中多个分支路由的场景。在实际业务场景中，很多的业务逻辑涉及到不止两个判断条件，而是多个。在MAF中，我们可以使用 Switch-Case 来实现这种工作流内部多类决策条件的 工作流需求。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><span><span>大家好，我是Edison。</span></span></p>\n<p><span><span>最近我一直在跟着圣杰的《<a class=\"normal_text_link mp_article_text_link\" href=\"https://www.cnblogs.com/sheng-jie/p/19200934\" target=\"_blank\"><span>.NET+AI智能体开发进阶</span></a><span>》课程学习MAF的开发技巧，我强烈推荐你也上车跟我一起出发！</span></span></span></p>\n<p><span><a class=\"normal_text_link mp_article_text_link\" href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper08\" target=\"_blank\"><span>上一篇</span></a><span>，我们学习了MAF中如何进行if-else类型的条件路由<span>，但是实际工作中可能会存在多个分支路由的场景。本篇，我们来了解下MAF中的switch-case路由实现多分支路由工作流。</span></span></span></p>\n<h1><strong>Why switch-case?</strong></h1>\n<p><span><span><span><span><span><span>在实际业务场景中，很多的业务逻辑涉及到不止两个判断条件，而是多个<span>。</span></span></span></span></span></span></span></p>\n<p><span><span><span><span><span><span><span>例如，在上一篇的企业内部邮件检测案例中，我们的检测结果只有两个（垃圾邮件 或 正常邮件），但如果我们想增加一个结果（不确定）就无法适用了。</span></span></span></span></span></span></span></p>\n<p><span><span><span><span><span><span><span>在MAF中，我们可以使用 Switch-Case 来实现这种工作流内部多类决策条件的 工作流需求<span>。</span></span></span></span></span></span></span></span></p>\n<h1><strong>实验案例</strong></h1>\n<p><span><span><span><span><span><span><span><span>今天来晚上上一篇这个企业内部邮件检测的工作流案例，上一篇的流程是这样的：</span></span></span></span></span></span></span></span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202512/381412-20251224202006911-1817307092.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p><span><span><span><span><span><span><span><span><span><span>今天假设我们需要有更为精细的分类：</span></span></span></span></span></span></span></span></span></span></p>\n<p><span><span>&nbsp; ✅&nbsp;<span><span>**正常邮件**<span><span>（NotSpam）：客户咨询、业务往来</span></span></span></span></span></span></p>\n<p><span><span>&nbsp; ❌&nbsp;<span><span>**垃圾邮件**<span><span>（Spam）：明显的诈骗、广告</span></span></span></span></span></span></p>\n<p><span><span>&nbsp;&nbsp;<span><span>⚠️&nbsp;<span><span>**不确定邮件**<span><span>（Uncertain）：可能是钓鱼邮件，需要人工审核</span></span></span></span></span></span></span></span></p>\n<p><span><span><span><span><span><span><span><span><span><span>那么这就是一个三元分类的，在业务开发中我们通常会用到switch-case语法，而在MAF工作流中，也为我们定义了这种switch-case接口。</span></span></span></span></span></span></span></span></span></span></p>\n<p><span><span><span><span><span><span><span><span><span><span>在下面的代码示例中，比对了两种接口的使用方式：</span></span></span></span></span></span></span></span></span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Conditional Edge</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">builder\n    .AddEdge(source, target1, condition: c </span>=&gt; c.IsSpam == <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    .AddEdge(source, target2, condition: c </span>=&gt; c.IsSpam == <span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Switch-Case</span>\nbuilder.AddSwitch(source, sb =&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> sb\n    .AddCase(c </span>=&gt; c.Decision ==<span style=\"color: rgba(0, 0, 0, 1);\"> NotSpam, target1)\n    .AddCase(c </span>=&gt; c.Decision ==<span style=\"color: rgba(0, 0, 0, 1);\"> Spam, target2)\n    .WithDefault(target3)\n);</span></pre>\n</div>\n<p><span><span><span><span><span><span><span><span><span><span><span><span>可以看到，switch-case模式其价值主要在于增强代码可维护性，对于后续如果有新增分类，只需要添加一个AddCase接口方法实现新增分类的处理，同时基于WithDefault接口方法实现兜底确保所有情况都有处理。</span></span></span></span></span></span></span></span></span></span></span></span></p>\n<p><span><span><span><span><span><span><span><span><span><span><span><span>最后，下面是我们需要重构后的分支路由图：</span></span></span></span></span></span></span></span></span></span></span></span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202512/381412-20251224202047038-2027515638.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<h1><strong>准备工作</strong></h1>\n<p><span><span><span><span><span><span><span><span><span><span><span><span><span>在今天的这个案例中，我们仍然创建了一个.NET控制台应用程序，安装了以下NuGet包：</span></span></span></span></span></span></span></span></span></span></span></span></span></p>\n<ul class=\"list-paddingleft-1\">\n<li><span>Microsoft.Agents.AI.OpenAI</span></li>\n<li><span>Microsoft.Agents.AI.Workflows</span></li>\n<li><span>Microsoft.Extensions.AI.OpenAI</span></li>\n</ul>\n<p><span><span><span><span><span><span><span><span><span><span><span><span><span>我们的配置文件中定义了LLM API的信息：</span></span></span></span></span></span></span></span></span></span></span></span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">{\n  </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">OpenAI</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">: {\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">EndPoint</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">https://api.siliconflow.cn</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">ApiKey</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">******************************</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">ModelId</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Qwen/Qwen3-30B-A3B-Instruct-2507</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n  }\n}</span></pre>\n</div>\n<p><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>这里我们使用 SiliconCloud 提供<span><span>的<span><span>&nbsp;<span><span>Qwen/Qwen3-30B-A3B-Instruct-2507&nbsp;<span><span>模型，你<span><span>可以通过这个URL注册账号：<span><span><a href=\"https://cloud.siliconflow.cn/i/DomqCefW\" rel=\"noopener nofollow\" target=\"_blank\">https://cloud.siliconflow.cn/i/DomqCefW</a><span>&nbsp;获取大量免费的Token来进行本次实验。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>\n<p><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>然后，我们将配置文件中的API信息读取出来：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> config = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ConfigurationBuilder()\n    .AddJsonFile($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">appsettings.json</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, optional: <span style=\"color: rgba(0, 0, 255, 1);\">false</span>, reloadOnChange: <span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    .Build();\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> openAIProvider = config.GetSection(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">OpenAI</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>).Get&lt;OpenAIProvider&gt;();</pre>\n</div>\n<h2><span>定义数据传输模型</span></h2>\n<p><span><span>首先，我们定义一下在这个工作流中需要生成传递的数据模型：</span></span></p>\n<p><span><span>（1）DetectionResult ：拉件邮件检测结果</span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">sealed</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> DetectionResult\n{\n    </span><span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;summary&gt;</span>\n    <span style=\"color: rgba(128, 128, 128, 1);\">///</span><span style=\"color: rgba(0, 128, 0, 1);\"> 检测决策（NotSpam / Spam / Uncertain）\n    </span><span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;/summary&gt;</span>\n    [JsonPropertyName(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">spam_decision</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)]\n    [JsonConverter(</span><span style=\"color: rgba(0, 0, 255, 1);\">typeof</span>(JsonStringEnumConverter))]  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> JSON 序列化为字符串</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">public</span> SpamDecision spamDecision { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n    </span><span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;summary&gt;</span>\n    <span style=\"color: rgba(128, 128, 128, 1);\">///</span><span style=\"color: rgba(0, 128, 0, 1);\"> 判定理由（用于审计和调试）\n    </span><span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;/summary&gt;</span>\n    [JsonPropertyName(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">reason</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)]\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span> Reason { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span>; } = <span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\">.Empty;\n    </span><span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;summary&gt;</span>\n    <span style=\"color: rgba(128, 128, 128, 1);\">///</span><span style=\"color: rgba(0, 128, 0, 1);\"> 邮件ID（用于关联 Shared State 中的原始内容）\n    </span><span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;/summary&gt;</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    [JsonIgnore]\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span> EmailId { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span>; } = <span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\">.Empty;\n}\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">enum</span><span style=\"color: rgba(0, 0, 0, 1);\"> SpamDecision\n{\n    Spam,        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 垃圾邮件</span>\n    NotSpam, <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 正常邮件</span>\n    UnCertain <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 无法确定（需要人工审核）</span>\n}</pre>\n</div>\n<p><span><span>（2）EmailStateConstants ：常量，类似于Cache Key的作用，参考上一篇博客内容。</span></span></p>\n<p><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>（3）EmailMessage &amp; EmailResponse ：DTO作用，参考上一篇博客内容。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>\n<h2><span>入口节点：垃圾邮件检测Executor</span></h2>\n<p><span><span><span><span>这个垃圾邮件检测是本流程的核心节点，这次我们将其重构为支持三分类：</span></span></span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">sealed</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span> SpamDetectionExecutor : Executor&lt;ChatMessage, DetectionResult&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span><span style=\"color: rgba(0, 0, 0, 1);\"> AIAgent _agent;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentThread _thread;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> SpamDetectionExecutor(AIAgent agent) : <span style=\"color: rgba(0, 0, 255, 1);\">base</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">SpamDetectionExecutor</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 创建 Agent 和对话线程</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">this</span>._agent =<span style=\"color: rgba(0, 0, 0, 1);\"> agent;\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">this</span>._thread = <span style=\"color: rgba(0, 0, 255, 1);\">this</span><span style=\"color: rgba(0, 0, 0, 1);\">._agent.GetNewThread();\n    }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span> ValueTask&lt;DetectionResult&gt; HandleAsync(ChatMessage message, IWorkflowContext context, CancellationToken cancellationToken = <span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 1️⃣ 生成唯一邮件ID并保存内容到 Shared State</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> trackedEmail = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> EmailMessage\n        {\n            EmailId </span>= Guid.NewGuid().ToString(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">N</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">),\n            EmailContent </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> message.Text\n        };\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> context.QueueStateUpdateAsync(\n            trackedEmail.EmailId,\n            trackedEmail,\n            scopeName: EmailStateConstants.EmailStateScope,\n            cancellationToken\n        );\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 2️⃣ 调用 AI Agent 进行三分类检测</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> agentResponse = <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> _agent.RunAsync(\n            message,\n            _thread,\n            cancellationToken: cancellationToken\n        );\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 3️⃣ 解析结构化输出</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> detection = JsonSerializer.Deserialize&lt;DetectionResult&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(agentResponse.Text)\n            </span>?? <span style=\"color: rgba(0, 0, 255, 1);\">throw</span> <span style=\"color: rgba(0, 0, 255, 1);\">new</span> InvalidOperationException(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">无法解析 Spam Detection 响应</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 4️⃣ 关联 EmailId（供下游 Executor 查找原始内容）</span>\n        detection.EmailId =<span style=\"color: rgba(0, 0, 0, 1);\"> trackedEmail.EmailId;\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> detection;\n    }\n}</span></pre>\n</div>\n<p>在这个Executor中，它接收我们如下所示定义好的Agent来实现：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> spamDetectionAgent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(\n    chatClient,\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgentOptions(\n        instructions: </span><span style=\"color: rgba(128, 0, 0, 1);\">@\"</span><span style=\"color: rgba(128, 0, 0, 1);\">你是一个垃圾邮件检测助手。判定规则：\n- NotSpam: 明显的正常业务邮件（订单查询、售后咨询等）\n- Spam: 明显的垃圾邮件（诈骗、广告、钓鱼）\n- Uncertain: 无法明确判断，包含可疑元素但不确定（如含可疑链接但内容模糊）\n对于模棱两可的情况，倾向于标记为 Uncertain 以保证安全。</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    )\n    {\n        ChatOptions </span>= <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatOptions\n        {\n            ResponseFormat </span>= ChatResponseFormat.ForJsonSchema&lt;DetectionResult&gt;<span style=\"color: rgba(0, 0, 0, 1);\">()\n        }\n    }\n);</span></pre>\n</div>\n<p>在ChatOptions中指定了该Agent返回的消息需要进行序列化到强类型，便于后续通过强类型数据进行决策路由。</p>\n<h2><span>下游节点A：正常邮件处理+发送</span></h2>\n<p>这里我们针对识别到的正常邮件开发两个执行器，假设其用于邮件处和转发：</p>\n<h3>邮件处理：读取共享状态区的原文，然后调用Agent输出JSON回复。</h3>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">sealed</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span> EmailAssistantExecutor : Executor&lt;DetectionResult, EmailResponse&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span><span style=\"color: rgba(0, 0, 0, 1);\"> AIAgent _agent;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentThread _thread;\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> EmailAssistantExecutor(AIAgent agent) : <span style=\"color: rgba(0, 0, 255, 1);\">base</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">EmailAssistantExecutor</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 创建 Agent 和对话线程</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">this</span>._agent =<span style=\"color: rgba(0, 0, 0, 1);\"> agent;\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">this</span>._thread = <span style=\"color: rgba(0, 0, 255, 1);\">this</span><span style=\"color: rgba(0, 0, 0, 1);\">._agent.GetNewThread();\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span> ValueTask&lt;EmailResponse&gt; HandleAsync(DetectionResult message, IWorkflowContext context, CancellationToken cancellationToken = <span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 🛡️ 防御性检查：确保只处理正常邮件</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (message.spamDecision ==<span style=\"color: rgba(0, 0, 0, 1);\"> SpamDecision.Spam)\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">throw</span> <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> InvalidOperationException(\n                </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">EmailAssistantExecutor 不应处理垃圾邮件，请检查路由配置。</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n            );\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 1️⃣ 从 Shared State 读取原始邮件内容</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> email = <span style=\"color: rgba(0, 0, 255, 1);\">await</span> context.ReadStateAsync&lt;EmailMessage&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(\n            message.EmailId,\n            scopeName: EmailStateConstants.EmailStateScope,\n            cancellationToken\n        ) </span>?? <span style=\"color: rgba(0, 0, 255, 1);\">throw</span> <span style=\"color: rgba(0, 0, 255, 1);\">new</span> InvalidOperationException($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">找不到 EmailId={message.EmailId} 的邮件内容</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 2️⃣ 调用 AI Agent 生成回复</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> agentResponse = <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> _agent.RunAsync(\n            email.EmailContent,\n            _thread,\n            cancellationToken: cancellationToken\n        );\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 3️⃣ 解析结构化输出</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> emailResponse = JsonSerializer.Deserialize&lt;EmailResponse&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(agentResponse.Text)\n            </span>?? <span style=\"color: rgba(0, 0, 255, 1);\">throw</span> <span style=\"color: rgba(0, 0, 255, 1);\">new</span> InvalidOperationException(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">无法解析 Email Assistant 响应</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> emailResponse;\n    }\n}</span></pre>\n</div>\n<p>这里的Agent定义如下：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> emailAssistantAgent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(\n    chatClient,\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgentOptions(\n        instructions: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">你是一个企业邮件助手，为客户邮件生成专业、友好的中文回复。</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    )\n    {\n        ChatOptions </span>= <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatOptions\n        {\n            ResponseFormat </span>= ChatResponseFormat.ForJsonSchema&lt;EmailResponse&gt;<span style=\"color: rgba(0, 0, 0, 1);\">()\n        }\n    }\n);</span></pre>\n</div>\n<h3><span>邮件转发：模拟邮件转发到具体的客服，这里仅仅使用YieldOutputAsync完成工作流输出消息内容。</span></h3>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">sealed</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span> EmailSendingExecutor() : Executor&lt;EmailResponse&gt;(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">EmailSendingExecutor</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span> ValueTask HandleAsync(EmailResponse message, IWorkflowContext context, CancellationToken cancellationToken = <span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 模拟邮件发送（实际项目中可调用 SMTP、SendGrid 等服务）</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> context.YieldOutputAsync(\n            $</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">📤 邮件已发送: {message.Response}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            cancellationToken\n        );\n    }\n}</span></pre>\n</div>\n<h2><span>下游节点B：垃圾邮件处理</span></h2>\n<p>当判断到是垃圾邮件时，转交给该执行器处理，这里模拟输出了一段风险提示，实际中可能是上报人工跟进等等操作：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">sealed</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span> SpamHandlingExecutor() : Executor&lt;DetectionResult&gt;(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">SpamHandlingExecutor</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span> ValueTask HandleAsync(DetectionResult message, IWorkflowContext context, CancellationToken cancellationToken = <span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 🛡️ 防御性检查：确保只处理垃圾邮件</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (message.spamDecision !=<span style=\"color: rgba(0, 0, 0, 1);\"> SpamDecision.Spam)\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">throw</span> <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> InvalidOperationException(\n                </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">SpamHandlingExecutor 只应处理 Spam 类型的邮件，请检查路由配置。</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n            );\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 记录垃圾邮件（实际项目中可写入数据库或日志系统）</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> context.YieldOutputAsync(\n            $</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">🚫 垃圾邮件已拦截: {message.Reason}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            cancellationToken\n        );\n    }\n}</span></pre>\n</div>\n<h2><span>下游节点C：<span><span>不确定邮件处理执行器（兜底处理）</span></span></span></h2>\n<p>当判断到属于不确定的邮件分类时，转交给该执行器做兜底处理 或 默认处理：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span> UncertainHandlingExecutor() : Executor&lt;DetectionResult&gt;(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">UncertainHandlingExecutor</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span><span style=\"color: rgba(0, 0, 0, 1);\"> ValueTask HandleAsync(\n        DetectionResult message,\n        IWorkflowContext context,\n        CancellationToken cancellationToken </span>= <span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 🛡️ 防御性检查：确保只处理不确定邮件</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (message.spamDecision !=<span style=\"color: rgba(0, 0, 0, 1);\"> SpamDecision.UnCertain)\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">throw</span> <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> InvalidOperationException(\n                </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">UncertainHandlingExecutor 只应处理 Uncertain 类型的邮件（或作为 Default Case）。</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n            );\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 1️⃣ 从 Shared State 读取原始邮件内容（用于人工审核）</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> email = <span style=\"color: rgba(0, 0, 255, 1);\">await</span> context.ReadStateAsync&lt;EmailMessage&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(\n            message.EmailId,\n            scopeName: EmailStateConstants.EmailStateScope,\n            cancellationToken\n        );\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 2️⃣ 输出待审核信息</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> context.YieldOutputAsync(\n            $</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">⚠️ 不确定邮件需人工审核:\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> +<span style=\"color: rgba(0, 0, 0, 1);\">\n            $</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">原因: {message.Reason}\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> +<span style=\"color: rgba(0, 0, 0, 1);\">\n            $</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">内容预览: {email?.EmailContent?.Substring(0, Math.Min(100, email.EmailContent.Length))}...</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            cancellationToken\n        );\n    }\n}</span></pre>\n</div>\n<h2>构建工作流</h2>\n<p>现在万事俱备，只欠一个Workflow，现在Let's do it!</p>\n<p><strong>Step1:</strong> 获取ChatClient</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> chatClient = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> OpenAIClient(\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ApiKeyCredential(openAIProvider.ApiKey),\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> OpenAIClientOptions { Endpoint = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> Uri(openAIProvider.Endpoint) })\n    .GetChatClient(openAIProvider.ModelId)\n    .AsIChatClient();</span></pre>\n</div>\n<p><strong><span><span>Step2<span>: </span></span></span></strong>实例化自定义Agent &amp; Executors</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> spamDetectionExecutor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> SpamDetectionExecutor(spamDetectionAgent);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> emailAssistantExecutor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> EmailAssistantExecutor(emailAssistantAgent);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> sendEmailExecutor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> EmailSendingExecutor();\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> handleSpamExecutor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> SpamHandlingExecutor();\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> handleUncertainExecutor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> UncertainHandlingExecutor();</pre>\n</div>\n<p><strong><span><span>Step3<span>: </span></span></span></strong>创建switch-case多路由决策工作流</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 🔧 条件函数工厂方法\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span>\nFunc&lt;<span style=\"color: rgba(0, 0, 255, 1);\">object</span>?, <span style=\"color: rgba(0, 0, 255, 1);\">bool</span>&gt; GetCondition(SpamDecision expectedDecision) =&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n    detectionResult </span>=&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n        detectionResult </span><span style=\"color: rgba(0, 0, 255, 1);\">is</span> DetectionResult result &amp;&amp;<span style=\"color: rgba(0, 0, 0, 1);\">\n        result.spamDecision </span>==<span style=\"color: rgba(0, 0, 0, 1);\"> expectedDecision;\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 🔀 使用 AddSwitch 构建 Switch-Case 工作流\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> builder = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> WorkflowBuilder(spamDetectionExecutor);\nbuilder.AddSwitch(spamDetectionExecutor, sb </span>=&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n        sb\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Case 1: NotSpam → EmailAssistant </span>\n            .AddCase(GetCondition(expectedDecision: SpamDecision.NotSpam), <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\">[] { (ExecutorBinding)emailAssistantExecutor })\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Case 2: Spam → HandleSpam</span>\n            .AddCase(GetCondition(expectedDecision: SpamDecision.Spam), <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\">[] { (ExecutorBinding)handleSpamExecutor })\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Default: Uncertain (或任何未匹配的情况) → HandleUncertain</span>\n            .WithDefault(<span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\">[] { (ExecutorBinding)handleUncertainExecutor })\n    )\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> EmailAssistant 之后自动发送邮件</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    .AddEdge(emailAssistantExecutor, sendEmailExecutor)\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 配置输出节点（三个终点执行器都会产生输出）</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    .WithOutputFrom(handleSpamExecutor, sendEmailExecutor, handleUncertainExecutor);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> workflow =<span style=\"color: rgba(0, 0, 0, 1);\"> builder.Build();\n\nConsole.OutputEncoding </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> Encoding.UTF8;\nConsole.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">✅ Conditional Workflow 构建完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>);</pre>\n</div>\n<h2>测试工作流</h2>\n<p>首先，为了便于后续测试我们将执行工作流封装为一个静态方法：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span><span style=\"color: rgba(0, 0, 0, 1);\"> Task RunWorkflowAsync(\n    Workflow workflow,\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> scenarioName,\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> emailContent)\n{\n    Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">📬 测试场景：{scenarioName}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">📧 邮件内容：{emailContent.Substring(0, Math.Min(80, emailContent.Length))}...\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">await</span> <span style=\"color: rgba(0, 0, 255, 1);\">using</span> <span style=\"color: rgba(0, 0, 255, 1);\">var</span> run = <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> InProcessExecution.StreamAsync(\n        workflow,\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatMessage(ChatRole.User, emailContent)\n    );\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 发送 Turn Token，启用事件推送</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">await</span> run.TrySendMessageAsync(<span style=\"color: rgba(0, 0, 255, 1);\">new</span> TurnToken(emitEvents: <span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">));\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 订阅事件流</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">await</span> <span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (WorkflowEvent evt <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> run.WatchStreamAsync())\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">switch</span><span style=\"color: rgba(0, 0, 0, 1);\"> (evt)\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">case</span><span style=\"color: rgba(0, 0, 0, 1);\"> ExecutorCompletedEvent completedEvent:\n                Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">✅ {completedEvent.ExecutorId} 完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">case</span><span style=\"color: rgba(0, 0, 0, 1);\"> WorkflowOutputEvent outputEvent:\n                Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">🎉 工作流执行完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">{outputEvent.Data}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">case</span><span style=\"color: rgba(0, 0, 0, 1);\"> WorkflowErrorEvent errorEvent:\n                Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">✨ 收到 Workflow Error Event：</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">{errorEvent.Data}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        }\n    }\n    Console.WriteLine();\n}</span></pre>\n</div>\n<p><strong>测试用例1：</strong>正常咨询邮件输入</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> scenarioName1 = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">正常邮件 → EmailAssistant → SendEmail</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> emailContent1 = <span style=\"color: rgba(128, 0, 0, 1);\">@\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\n尊敬的客服团队：\n您好！我是贵公司的长期客户，订单号为 \n#2025\n-001。\n我想确认一下上周提交的采购订单是否已经安排发货。\n如果需要补充任何信息，请随时告知。\n期待您的回复，谢谢！\n客户：张先生\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> RunWorkflowAsync(workflow, scenarioName1, emailContent1);\nConsole.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">✅ 正常邮件路径验证完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>);</pre>\n</div>\n<p>测试结果如下图所示：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202512/381412-20251224202754097-83329301.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>可以看见，对于正常咨询邮件，进行正常的邮件处理和转发。</p>\n<p><strong>测试用例2：</strong>垃圾邮件输入</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> scenarioName2 = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">垃圾邮件 → HandleSpam</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> emailContent2 = <span style=\"color: rgba(128, 0, 0, 1);\">@\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\n🎉🎉🎉 恭喜您中奖啦！🎉🎉🎉\n\n您已被选中获得 100 万现金大奖！\n\n立即点击以下链接领取：\nhttp://suspicious-site.com/claim-prize\n\n仅限今日有效，过期作废！\n不需要任何手续费，完全免费！\n\n快速行动，机不可失！\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> RunWorkflowAsync(workflow, scenarioName2, emailContent2);\nConsole.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">✅ 垃圾邮件路径验证完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>);</pre>\n</div>\n<p>测试结果如下图所示：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202512/381412-20251224202904798-37631196.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>可以看见，对于垃圾邮件，进行有效的拦截，后续还可以进行上报人工跟踪等等。</p>\n<p><strong>测试用例3：</strong>无法确认类型的邮件输入</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> uncertainEmail = <span style=\"color: rgba(128, 0, 0, 1);\">@\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\n主题：需要验证您的账户\n尊敬的客户：\n我们检测到您的账户存在异常活动，需要验证您的身份以确保账户安全。\n请登录您的账户并完成验证流程，以继续使用服务。\n账户详情：\n- 用户名：johndoe@contoso.com\n- 最后登录：08/15/2025\n- 登录地点：西雅图，华盛顿州\n- 登录设备：移动设备\n这是一项自动安全措施。如果您认为此邮件是错误发送的，请立即联系我们的支持团队。\n此致\n安全团队\n客户服务部门\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> RunWorkflowAsync(\n    workflow,\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">不确定邮件 → HandleUncertain (Default)</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n    uncertainEmail\n);\nConsole.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">✅ 不确定邮件路径验证完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>);</pre>\n</div>\n<p>测试结果如下图所示：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202512/381412-20251224202940842-749043447.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>可以看到，对于LLM无法确认的类型，进入了该执行器，这时可能需要人工介入审核。同时，这也是实际中常见的一种兜底机制的展现，话句话说：<strong>即使AI无法明确判断，也应该有对应的处理流程</strong>。</p>\n<h1><strong><span>小结</span></strong></h1>\n<p>本文介绍了MAF中的switch-case路由以及如何实现多条件路由，最后优化了上一篇的企业内部邮件检测工作流案例，特别适合于大于3个分支的复杂路由场景。</p>\n<p>下一篇，我们将继续学习MAF中工作流的循环工作流。</p>\n<h1>参考资料</h1>\n<p><span><span>圣杰，《<a href=\"https://www.cnblogs.com/sheng-jie/p/19200934\" target=\"_blank\">.NET + AI 智能体开发进阶</a>》（推荐指数：★★★★★）</span></span></p>\n<p><span><span>Microsoft Learn，<span>《<a href=\"https://learn.microsoft.com/en-us/agent-framework/overview/agent-framework-overview?wt.mc_id=MVP_397012\" rel=\"noopener nofollow\" target=\"_blank\">Agent Framework Tutorials</a>》</span></span></span></p>\n<div><span><span>&nbsp;</span></span></div>\n<p style=\"text-align: center;\"><img alt=\"\" src=\"https://images.cnblogs.com/cnblogs_com/edisonchou/1647700/o_200902144330EdisonTalk-Footer.jpg\" /></p>\n<div id=\"Copyright\">\n<p>作者：<span style=\"text-decoration: underline;\">爱迪生</span></p>\n<p>出处：<a href=\"https://edisontalk.cnblogs.com\" target=\"_blank\" title=\"from\">https://edisontalk.cnblogs.com</a></p>\n<p>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。</p>\n</div>\n</div>\n<div id=\"MySignature\">\n    <div align=\"center\"><a href=\"https://weibo.com/u/2068032061?s=6uyXnP\" target=\"_blank\"><img border=\"0\" src=\"http://service.t.sina.com.cn/widget/qmd/2068032061/d643d182/10.png\" /></a></div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-29 18:30</span>&nbsp;\n<a href=\"https://www.cnblogs.com/edisontalk\">EdisonZhou</a>&nbsp;\n阅读(<span id=\"post_view_count\">32</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "CodeSpirit 开发环境搭建及启动指南",
      "link": "https://www.cnblogs.com/codelove/p/19392132",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/codelove/p/19392132\" id=\"cb_post_title_url\" title=\"发布于 2025-12-29 15:07\">\n    <span>CodeSpirit 开发环境搭建及启动指南</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"概述\">概述</h2>\n<p>本指南将帮助您快速搭建CodeSpirit（码灵）低代码框架的开发环境。CodeSpirit基于 .NET 10 和 Aspire 13.0 构建，通过简单的几个步骤即可启动完整的开发环境。</p>\n<p><strong>最后更新</strong>: 2025年12月22日<br />\n<strong>框架版本</strong>: v2.0.0<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224131727898-298580147.png\" /></p>\n<h2 id=\"快速开始\">快速开始</h2>\n<h3 id=\"前置要求\">前置要求</h3>\n<ul>\n<li><strong>操作系统</strong>: Windows 10/11, macOS 12+, 或 Linux (Ubuntu 20.04+)</li>\n<li><strong>CPU</strong>: Intel i5 或 AMD Ryzen 5 及以上（推荐i7/Ryzen 7）</li>\n<li><strong>内存</strong>: 16GB RAM（推荐32GB）</li>\n<li><strong>存储</strong>: 至少20GB可用空间（SSD推荐）</li>\n</ul>\n<blockquote>\n<p><strong>注意</strong>: CodeSpirit默认使用GreptimeDB进行审计日志存储和搜索。Elasticsearch为可选组件，如需使用请参考相关配置文档。</p>\n</blockquote>\n<h3 id=\"1-安装-net-10-sdk\">1. 安装 .NET 10 SDK</h3>\n<h4 id=\"windows\">Windows</h4>\n<pre><code class=\"language-powershell\"># 使用 winget 安装\nwinget install Microsoft.DotNet.SDK.10\n\n# 或下载安装包\n# https://dotnet.microsoft.com/download/dotnet/10.0\n</code></pre>\n<h4 id=\"macos\">macOS</h4>\n<pre><code class=\"language-bash\"># 使用 Homebrew\nbrew install --cask dotnet-sdk\n\n# 或下载安装包\n# https://dotnet.microsoft.com/download/dotnet/10.0\n</code></pre>\n<h4 id=\"linux-ubuntu\">Linux (Ubuntu)</h4>\n<pre><code class=\"language-bash\"># 添加微软包源\nwget https://packages.microsoft.com/config/ubuntu/22.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb\nsudo dpkg -i packages-microsoft-prod.deb\nsudo apt-get update\nsudo apt-get install -y dotnet-sdk-10.0\n</code></pre>\n<h4 id=\"验证安装\">验证安装</h4>\n<pre><code class=\"language-bash\">dotnet --version\n# 应显示 10.x.x\n</code></pre>\n<h3 id=\"2-安装开发工具\">2. 安装开发工具</h3>\n<h4 id=\"visual-studio-2026-推荐\">Visual Studio 2026 (推荐)</h4>\n<ul>\n<li>下载地址: <a href=\"https://visualstudio.microsoft.com/vs/\" rel=\"noopener nofollow\" target=\"_blank\">https://visualstudio.microsoft.com/vs/</a></li>\n<li>选择工作负载：<strong>ASP.NET 和 Web 开发</strong></li>\n</ul>\n<h4 id=\"或者-visual-studio-code\">或者 Visual Studio Code</h4>\n<pre><code class=\"language-bash\"># Windows\nwinget install Microsoft.VisualStudioCode\n\n# macOS\nbrew install --cask visual-studio-code\n\n# Linux\nsudo snap install code --classic\n</code></pre>\n<p>VS Code必需扩展：</p>\n<pre><code class=\"language-bash\">code --install-extension ms-dotnettools.csharp\ncode --install-extension ms-dotnettools.vscode-dotnet-runtime\n</code></pre>\n<h3 id=\"3-安装docker-desktop\">3. 安装Docker Desktop</h3>\n<ul>\n<li>下载地址: <a href=\"https://www.docker.com/products/docker-desktop\" rel=\"noopener nofollow\" target=\"_blank\">https://www.docker.com/products/docker-desktop</a></li>\n<li>安装后启动Docker Desktop</li>\n</ul>\n<p>验证安装：</p>\n<pre><code class=\"language-bash\">docker --version\n</code></pre>\n<h2 id=\"项目启动\">项目启动</h2>\n<h3 id=\"1-克隆项目\">1. 克隆项目</h3>\n<pre><code class=\"language-bash\">git clone https://gitee.com/magicodes/code-spirit.git\ncd code-spirit\n</code></pre>\n<h3 id=\"2-启动基础服务\">2. 启动基础服务</h3>\n<p>CodeSpirit使用Aspire自动管理所有依赖服务，无需手动启动Docker容器：</p>\n<pre><code class=\"language-bash\"># Aspire会自动启动以下服务：\n# - MySQL/SQL Server (根据配置选择，端口: 3306/1433)\n# - Redis (端口: 6380)\n# - RabbitMQ (端口: 5672, 管理界面: 15672)\n# - GreptimeDB (端口: 4000/4001)\n# - Seq日志服务 (端口: 5341)\n</code></pre>\n<blockquote>\n<p><strong>服务说明</strong>:</p>\n<ul>\n<li><strong>MySQL/SQL Server</strong>: 主数据库存储（根据DatabaseType配置选择）</li>\n<li><strong>Redis</strong>: 缓存和会话存储（端口: 6380）</li>\n<li><strong>RabbitMQ</strong>: 消息队列服务（管理界面端口: 15672）</li>\n<li><strong>GreptimeDB</strong>: 时序数据库，用于审计日志存储（HTTP端口: 4000, gRPC端口: 4001）</li>\n<li><strong>Seq</strong>: 结构化日志服务（端口: 5341）</li>\n</ul>\n</blockquote>\n<h3 id=\"3-运行项目\">3. 运行项目</h3>\n<h4 id=\"使用net-aspire推荐\">使用.NET Aspire（推荐）</h4>\n<pre><code class=\"language-bash\"># 进入AppHost项目目录\ncd Src/CodeSpirit.AppHost\n\n# 运行Aspire应用\ndotnet run\n</code></pre>\n<p>如果是正常启动，将看到以下缤纷的控制台输出：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224131931648-1820053723.png\" /></p>\n<p>启动后访问：</p>\n<ul>\n<li><strong>Aspire Dashboard</strong>: <a href=\"http://localhost:17109\" rel=\"noopener nofollow\" target=\"_blank\">http://localhost:17109</a>（自动打开）</li>\n<li><strong>Web应用</strong>: <a href=\"https://localhost:7120\" rel=\"noopener nofollow\" target=\"_blank\">https://localhost:7120</a>（启动后显示具体端口）</li>\n</ul>\n<blockquote>\n<p><strong>注意</strong>:</p>\n</blockquote>\n<blockquote>\n<ol>\n<li>实际端口号可能因系统配置而异，请查看Aspire Dashboard获取准确的端口信息。</li>\n<li>如何登录页没有正常呈现，请按照下面的必填参数配置进行配置。</li>\n</ol>\n</blockquote>\n<h4 id=\"或者使用visual-studio\">或者使用Visual Studio</h4>\n<ol>\n<li>\n<p>打开 <code>CodeSpirit.sln</code></p>\n</li>\n<li>\n<p>设置 <code>CodeSpirit.AppHost</code> 为启动项目</p>\n</li>\n<li>\n<p>按 F5 运行<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224131917733-1101676572.png\" /><br />\n注意，需确保以下服务均正常启动：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224131931648-1820053723.png\" /></p>\n</li>\n</ol>\n<h2 id=\"项目结构\">项目结构</h2>\n<p>CodeSpirit采用Clean Architecture设计，项目结构如下：</p>\n<pre><code>CodeSpirit/\n├── Src/\n│   ├── ApiServices/                     # API服务（解决方案文件夹）\n│   │   ├── CodeSpirit.IdentityApi/      # 身份认证API\n│   │   ├── CodeSpirit.ExamApi/          # 考试系统API  \n│   │   ├── CodeSpirit.MessagingApi/     # 消息服务API\n│   │   ├── CodeSpirit.ConfigCenter/    # 配置中心API\n│   │   ├── CodeSpirit.FileStorageApi/  # 文件存储API\n│   │   ├── CodeSpirit.SurveyApi/        # 问卷调查API\n│   │   ├── CodeSpirit.ApprovalApi/      # 审批工作流API\n│   │   ├── CodeSpirit.PathfinderApi/    # AI目标管理API\n│   │   └── CodeSpirit.AiCardsApi/       # AI卡片API\n│   ├── Components/                     # 组件库\n│   │   ├── CodeSpirit.Aggregator/       # 聚合器组件\n│   │   ├── CodeSpirit.AiFormFill/       # AI表单智能填充组件\n│   │   ├── CodeSpirit.Amis/             # UI生成引擎\n│   │   ├── CodeSpirit.Authorization/    # 权限组件\n│   │   ├── CodeSpirit.Audit/            # 审计组件\n│   │   ├── CodeSpirit.Caching/          # 分布式缓存组件\n│   │   ├── CodeSpirit.Charts/           # 智能图表组件\n│   │   ├── CodeSpirit.ConfigCenter.Client/ # 配置中心客户端\n│   │   ├── CodeSpirit.LLM/              # 大语言模型组件\n│   │   ├── CodeSpirit.Messaging/        # 消息队列组件\n│   │   ├── CodeSpirit.MultiTenant/      # 多租户组件\n│   │   ├── CodeSpirit.Navigation/       # 导航组件\n│   │   ├── CodeSpirit.PdfGeneration/    # PDF生成组件\n│   │   ├── CodeSpirit.ScheduledTasks/   # 定时任务组件\n│   │   ├── CodeSpirit.Settings/         # 设置管理组件\n│   │   ├── CodeSpirit.Shared/           # 组件共享库\n│   │   └── CodeSpirit.UdlCards/         # UDL卡片组件\n│   ├── CodeSpirit.AppHost/              # Aspire应用宿主\n│   ├── CodeSpirit.Core/                 # 核心定义\n│   ├── CodeSpirit.ServiceDefaults/      # 服务默认配置\n│   ├── CodeSpirit.Shared/               # 全局共享库\n│   └── CodeSpirit.Web/                  # Web前端项目\n├── Tests/                               # 测试项目\n├── Docs/                                # 项目文档\n├── k8s/                                 # Kubernetes部署文件\n└── CodeSpirit.sln                       # 解决方案文件\n</code></pre>\n<h2 id=\"默认配置\">默认配置</h2>\n<p>项目使用以下默认配置，由.NET Aspire自动管理：</p>\n<h3 id=\"数据库连接\">数据库连接</h3>\n<ul>\n<li>\n<p><strong>数据库类型</strong>: 支持MySQL和SQL Server两种数据库（通过<code>DatabaseType</code>配置选择）</p>\n</li>\n<li>\n<p><strong>MySQL</strong>: 端口3306，由Aspire自动配置</p>\n<p>可以从资源面板访问管理UI（phpmyadmin）：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224132002956-598129788.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224132042244-558588173.png\" /></p>\n</li>\n<li>\n<p><strong>SQL Server</strong>: 端口1433，由Aspire自动配置</p>\n</li>\n<li>\n<p><strong>数据库</strong>: 自动创建和迁移</p>\n</li>\n<li>\n<p><strong>连接字符串</strong>: 由Aspire自动管理</p>\n</li>\n</ul>\n<h3 id=\"缓存和消息队列\">缓存和消息队列</h3>\n<ul>\n<li>\n<p><strong>Redis</strong>: <code>localhost:6380</code>（具体见管理UI）</p>\n</li>\n<li>\n<p><strong>RabbitMQ</strong>: <code>localhost:5672</code> (管理界面: <a href=\"http://localhost:15672\" rel=\"noopener nofollow\" target=\"_blank\">http://localhost:15672</a>, 用户名/密码: admin/Password123)</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224132123458-1426760447.png\" /></p>\n</li>\n</ul>\n<h3 id=\"其他服务端口\">其他服务端口</h3>\n<ul>\n<li>\n<p><strong>GreptimeDB</strong>:</p>\n<ul>\n<li>HTTP端口: <code>localhost:4000</code></li>\n<li>gRPC端口: <code>localhost:4001</code></li>\n<li>健康检查: <a href=\"http://localhost:4000/health\" rel=\"noopener nofollow\" target=\"_blank\">http://localhost:4000/health</a></li>\n</ul>\n</li>\n<li>\n<p><strong>Seq日志服务</strong>: <code>localhost:5341</code>（具体端口见资源面板）</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224132136208-2065968736.png\" /></p>\n</li>\n<li>\n<p><strong>Redis Commander</strong>: 通过Aspire Dashboard访问</p>\n</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224132147317-671812413.png\" /></p>\n<h2 id=\"必填参数配置\">必填参数配置</h2>\n<p>CodeSpirit 使用 .NET Aspire 的参数管理机制来配置敏感信息和环境相关参数。在首次启动前，您需要配置以下必填参数。提示UI如下：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224132156259-1567610099.png\" /><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224132203941-1321498621.png\" /></p>\n<h3 id=\"参数配置方式\">参数配置方式</h3>\n<p>Aspire 支持两种参数配置方式，配置系统会按以下优先级读取（高优先级会覆盖低优先级）：</p>\n<ol>\n<li><strong>User Secrets</strong>（开发环境推荐，避免提交敏感信息到代码库）</li>\n<li><strong>appsettings.json</strong>（开发环境备选方案）</li>\n</ol>\n<blockquote>\n<p><strong>提示</strong>: 对于敏感信息（如 API 密钥），强烈推荐使用 User Secrets，避免将密钥提交到代码库。</p>\n</blockquote>\n<h3 id=\"必填参数列表\">必填参数列表</h3>\n<h4 id=\"llm-配置参数\">LLM 配置参数</h4>\n<p>以下参数用于配置通用 LLM 服务（如 AI 卡片、智能审批等功能）：</p>\n<table>\n<thead>\n<tr>\n<th>参数名称</th>\n<th>说明</th>\n<th>是否必填</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>llm-ApiKey</code></td>\n<td>LLM API密钥</td>\n<td>✅ <strong>必填</strong></td>\n<td>无</td>\n</tr>\n<tr>\n<td><code>llm-ApiBaseUrl</code></td>\n<td>LLM API基础地址</td>\n<td>可选</td>\n<td><code>https://dashscope.aliyuncs.com/compatible-mode/v1</code></td>\n</tr>\n<tr>\n<td><code>llm-ModelName</code></td>\n<td>LLM模型名称</td>\n<td>可选</td>\n<td><code>qwen-flash</code></td>\n</tr>\n<tr>\n<td><code>llm-TimeoutSeconds</code></td>\n<td>请求超时时间（秒）</td>\n<td>可选</td>\n<td><code>120</code></td>\n</tr>\n<tr>\n<td><code>llm-MaxTokens</code></td>\n<td>最大Token数</td>\n<td>可选</td>\n<td><code>2048</code></td>\n</tr>\n<tr>\n<td><code>llm-UseProxy</code></td>\n<td>是否使用代理</td>\n<td>可选</td>\n<td><code>false</code></td>\n</tr>\n<tr>\n<td><code>llm-ProxyAddress</code></td>\n<td>代理地址</td>\n<td>可选</td>\n<td>空字符串</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"ai表单填充-llm-配置参数\">AI表单填充 LLM 配置参数</h4>\n<p>以下参数用于配置 AI 表单智能填充功能：</p>\n<table>\n<thead>\n<tr>\n<th>参数名称</th>\n<th>说明</th>\n<th>是否必填</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ai-form-fill-llm-ApiKey</code></td>\n<td>AI表单填充LLM API密钥</td>\n<td>✅ <strong>必填</strong></td>\n<td>无</td>\n</tr>\n<tr>\n<td><code>ai-form-fill-llm-ApiBaseUrl</code></td>\n<td>API基础地址</td>\n<td>可选</td>\n<td><code>https://dashscope.aliyuncs.com/compatible-mode/v1</code></td>\n</tr>\n<tr>\n<td><code>ai-form-fill-llm-ModelName</code></td>\n<td>模型名称</td>\n<td>可选</td>\n<td><code>qwen3-max-preview</code></td>\n</tr>\n<tr>\n<td><code>ai-form-fill-llm-DisableThinking</code></td>\n<td>禁用思考模式</td>\n<td>可选</td>\n<td><code>true</code></td>\n</tr>\n<tr>\n<td><code>ai-form-fill-llm-ResponseFormatType</code></td>\n<td>响应格式类型</td>\n<td>可选</td>\n<td><code>json_object</code></td>\n</tr>\n<tr>\n<td><code>ai-form-fill-llm-Temperature</code></td>\n<td>温度参数</td>\n<td>可选</td>\n<td><code>0.1</code></td>\n</tr>\n<tr>\n<td><code>ai-form-fill-llm-TopP</code></td>\n<td>TopP参数</td>\n<td>可选</td>\n<td><code>0.9</code></td>\n</tr>\n<tr>\n<td><code>ai-form-fill-llm-EnableStreaming</code></td>\n<td>启用流式响应</td>\n<td>可选</td>\n<td><code>true</code></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"其他可选参数\">其他可选参数</h4>\n<p>以下参数已有默认值，通常无需修改：</p>\n<table>\n<thead>\n<tr>\n<th>参数名称</th>\n<th>说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>jwt-SecretKey</code></td>\n<td>JWT密钥</td>\n<td><code>ECBF8FA013844D77AE041A6800D7FF8F</code></td>\n</tr>\n<tr>\n<td><code>jwt-Issuer</code></td>\n<td>JWT颁发者</td>\n<td><code>codespirit.com</code></td>\n</tr>\n<tr>\n<td><code>jwt-Audience</code></td>\n<td>JWT受众</td>\n<td><code>CodeSpirit</code></td>\n</tr>\n<tr>\n<td><code>mysql-password</code></td>\n<td>MySQL密码</td>\n<td><code>Password123</code></td>\n</tr>\n<tr>\n<td><code>sqlserver-password</code></td>\n<td>SQL Server密码</td>\n<td><code>P@ssword123456</code></td>\n</tr>\n<tr>\n<td><code>rabbitmq-username</code></td>\n<td>RabbitMQ用户名</td>\n<td><code>admin</code></td>\n</tr>\n<tr>\n<td><code>rabbitmq-password</code></td>\n<td>RabbitMQ密码</td>\n<td><code>Password123</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"配置方法\">配置方法</h3>\n<h4 id=\"方法一使用-user-secrets推荐开发环境\">方法一：使用 User Secrets（推荐开发环境）</h4>\n<p>使用 .NET User Secrets 可以安全地存储敏感信息，无需担心提交到代码库：</p>\n<pre><code class=\"language-bash\"># 进入 AppHost 项目目录\ncd Src/CodeSpirit.AppHost\n\n# 初始化 User Secrets（如果尚未初始化）\ndotnet user-secrets init\n\n# 设置 LLM API 密钥\ndotnet user-secrets set \"llm-ApiKey\" \"your-llm-api-key-here\"\n\n# 设置 AI 表单填充 LLM API 密钥\ndotnet user-secrets set \"ai-form-fill-llm-ApiKey\" \"your-ai-form-fill-llm-api-key-here\"\n\n# 清除所有密钥\n# dotnet user-secrets clear\n</code></pre>\n<h4 id=\"方法二使用-appsettingsjson开发环境备选\">方法二：使用 appsettings.json（开发环境备选）</h4>\n<p>编辑 <code>Src/CodeSpirit.AppHost/appsettings.json</code> 文件，添加参数配置：</p>\n<pre><code class=\"language-json\">{\n  \"DatabaseType\": \"MySql\",\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore\": \"Warning\",\n      \"Aspire.Hosting.Dcp\": \"Warning\"\n    }\n  },\n  \"llm-ApiKey\": \"your-llm-api-key-here\",\n  \"ai-form-fill-llm-ApiKey\": \"your-ai-form-fill-llm-api-key-here\"\n}\n</code></pre>\n<blockquote>\n<p><strong>⚠️ 重要提示</strong>:</p>\n<ul>\n<li>如果使用 <code>appsettings.json</code> 配置敏感信息，请确保该文件已添加到 <code>.gitignore</code> 中</li>\n<li>或者创建 <code>appsettings.Local.json</code> 文件（该文件默认已在 <code>.gitignore</code> 中），避免将 API 密钥提交到代码库</li>\n<li><strong>强烈推荐使用 User Secrets 方式</strong>，更安全且不会误提交</li>\n</ul>\n</blockquote>\n<h3 id=\"获取-api-密钥\">获取 API 密钥</h3>\n<h4 id=\"阿里云通义千问dashscope\">阿里云通义千问（DashScope）</h4>\n<p>开发阶段免费额度完全够用：</p>\n<ol>\n<li>访问 <a href=\"https://www.aliyun.com/benefit?userCode=nw99vwgt\" rel=\"noopener nofollow\" target=\"_blank\">阿里云 DashScope</a></li>\n<li>注册/登录账号</li>\n<li>创建 API Key</li>\n<li>将 API Key 配置到上述参数中</li>\n</ol>\n<blockquote>\n<p>💡 <strong>推荐阅读</strong>：<a href=\"./%E9%98%BF%E9%87%8C%E4%BA%91%E9%80%9A%E4%B9%89%E5%8D%83%E9%97%AE%E5%85%8D%E8%B4%B9%E4%BD%93%E9%AA%8C%E6%8C%87%E5%8D%97.md\" rel=\"noopener nofollow\" target=\"_blank\">阿里云通义千问免费体验指南</a> - 详细的注册指南、配置教程和成本分析，帮助您零成本体验 CodeSpirit 的强大 AI 能力！</p>\n</blockquote>\n<h4 id=\"openai如使用-openai-兼容接口\">OpenAI（如使用 OpenAI 兼容接口）</h4>\n<p>如果使用 OpenAI 兼容的 API 服务，需要修改以下参数：</p>\n<p>使用 User Secrets 配置：</p>\n<pre><code class=\"language-bash\">dotnet user-secrets set \"llm-ApiBaseUrl\" \"https://api.openai.com/v1\"\ndotnet user-secrets set \"llm-ModelName\" \"gpt-4\"\ndotnet user-secrets set \"llm-ApiKey\" \"your-openai-api-key-here\"\n</code></pre>\n<p>或使用 appsettings.json 配置：</p>\n<pre><code class=\"language-json\">{\n  \"llm-ApiBaseUrl\": \"https://api.openai.com/v1\",\n  \"llm-ModelName\": \"gpt-4\",\n  \"llm-ApiKey\": \"your-openai-api-key-here\"\n}\n</code></pre>\n<h3 id=\"验证参数配置\">验证参数配置</h3>\n<p>启动项目后，如果参数配置不正确，您会在控制台或 Aspire Dashboard 中看到相关错误信息。确保以下服务能够正常启动：</p>\n<ul>\n<li>✅ ConfigCenter（配置中心）- 需要 LLM 参数</li>\n<li>✅ Web 前端 - 需要 AI 表单填充 LLM 参数</li>\n</ul>\n<blockquote>\n<p><strong>提示</strong>: 如果暂时不需要使用 AI 功能，可以设置一个占位符值，但某些依赖 AI 的功能将无法正常工作。</p>\n</blockquote>\n<h2 id=\"开发工具配置\">开发工具配置</h2>\n<h3 id=\"visual-studio-code\">Visual Studio Code</h3>\n<p>创建 <code>.vscode/launch.json</code>：</p>\n<pre><code class=\"language-json\">{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"Launch CodeSpirit\",\n      \"type\": \"coreclr\",\n      \"request\": \"launch\",\n      \"preLaunchTask\": \"build\",\n      \"program\": \"${workspaceFolder}/Src/CodeSpirit.AppHost/bin/Debug/net10.0/CodeSpirit.AppHost.dll\",\n      \"cwd\": \"${workspaceFolder}/Src/CodeSpirit.AppHost\",\n      \"env\": {\n        \"ASPNETCORE_ENVIRONMENT\": \"Development\"\n      }\n    }\n  ]\n}\n</code></pre>\n<p>创建 <code>.vscode/tasks.json</code>：</p>\n<pre><code class=\"language-json\">{\n  \"version\": \"2.0.0\",\n  \"tasks\": [\n    {\n      \"label\": \"build\",\n      \"command\": \"dotnet\",\n      \"type\": \"process\",\n      \"args\": [\"build\", \"${workspaceFolder}/CodeSpirit.sln\"],\n      \"problemMatcher\": \"$msCompile\"\n    }\n  ]\n}\n</code></pre>\n<h2 id=\"验证安装-1\">验证安装</h2>\n<h3 id=\"1-检查服务状态\">1. 检查服务状态</h3>\n<p>访问Aspire Dashboard (<a href=\"http://localhost:17109\" rel=\"noopener nofollow\" target=\"_blank\">http://localhost:17109</a>) 确认所有服务正常运行：</p>\n<ul>\n<li>✅ CodeSpirit.Web (Web前端)</li>\n<li>✅ CodeSpirit.IdentityApi (身份认证)</li>\n<li>✅ CodeSpirit.ConfigCenter (配置中心)</li>\n<li>✅ CodeSpirit.MessagingApi (消息服务)</li>\n<li>✅ CodeSpirit.ExamApi (考试系统)</li>\n<li>✅ CodeSpirit.FileStorageApi (文件存储)</li>\n<li>✅ CodeSpirit.SurveyApi (问卷调查)</li>\n<li>✅ CodeSpirit.ApprovalApi (审批流程)</li>\n<li>✅ CodeSpirit.PathfinderApi (AI目标管理)</li>\n<li>✅ MySQL/SQL Server (数据库，根据配置)</li>\n<li>✅ Redis (缓存)</li>\n<li>✅ RabbitMQ (消息队列)</li>\n<li>✅ GreptimeDB (时序数据库)</li>\n<li>✅ Seq (日志服务)</li>\n</ul>\n<h3 id=\"2-检查错误\">2. 检查错误</h3>\n<p>打开结构化日志面板，检查是否存在错误：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224132237841-409615542.png\" /></p>\n<h3 id=\"3-访问web界面\">3. 访问Web界面</h3>\n<p>系统平台：<a href=\"https://localhost:7120\" rel=\"noopener nofollow\" target=\"_blank\">https://localhost:7120</a></p>\n<p>账号：systemadmin</p>\n<p>密码：CodeSpirit@2025</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224132247398-182230200.png\" /></p>\n<p>登录后可以看到系统平台后台管理UI：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224132258347-1684698426.png\" /></p>\n<p>租户平台（默认租户）：<a href=\"https://localhost:7120/default/login\" rel=\"noopener nofollow\" target=\"_blank\">https://localhost:7120/default/login</a></p>\n<p>账号：admin</p>\n<p>密码：123@Admin</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224132312276-873776487.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224132320900-136012642.png\" /></p>\n<h2 id=\"常见问题\">常见问题</h2>\n<h3 id=\"无法打开网页\">无法打开网页</h3>\n<p>一般是以下情况导致：</p>\n<ol>\n<li>\n<p>镜像无法拉取，一般在docker面板或Aspire管理面板的日志中可以看到。建议配置镜像源或路由上网。</p>\n</li>\n<li>\n<p>关键服务故障，比如Web服务出现故障。</p>\n</li>\n<li>\n<p>端口冲突或网络错误，具体可以看启动控制台错误：</p>\n</li>\n</ol>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224132339285-1584044125.png\" /></p>\n<h3 id=\"端口冲突\">端口冲突</h3>\n<p>如果遇到端口冲突，修改 <code>Src/CodeSpirit.AppHost/Program.cs</code> 中的端口配置。</p>\n<h3 id=\"docker服务启动失败\">Docker服务启动失败</h3>\n<p>由于项目使用.NET Aspire管理服务，如果遇到服务启动问题：</p>\n<pre><code class=\"language-bash\"># 重启Aspire应用\ncd Src/CodeSpirit.AppHost\ndotnet run --force\n\n# 查看Aspire Dashboard中的服务状态\n# 访问 http://localhost:17109\n</code></pre>\n<h3 id=\"greptimedb启动失败\">GreptimeDB启动失败</h3>\n<pre><code class=\"language-bash\"># 在Aspire Dashboard中查看GreptimeDB状态\n# 如果内存不足，可以在Program.cs中调整GreptimeDB配置\n\n# 检查系统资源使用情况\n# GreptimeDB需要至少512MB内存\n</code></pre>\n<h3 id=\"ssl证书问题\">SSL证书问题</h3>\n<pre><code class=\"language-bash\"># 信任开发证书\ndotnet dev-certs https --trust\n</code></pre>\n<h3 id=\"数据库连接问题\">数据库连接问题</h3>\n<pre><code class=\"language-bash\"># 检查数据库容器状态（根据配置的数据库类型）\ndocker ps | grep mysql    # MySQL\ndocker ps | grep sqlserver # SQL Server\n\n# 重启数据库容器\ndocker restart mysql      # MySQL\ndocker restart sqlserver  # SQL Server\n\n# 或在Aspire Dashboard中查看数据库状态和连接信息\n</code></pre>\n<h3 id=\"内存不足问题\">内存不足问题</h3>\n<p>如果系统内存不足，可以：</p>\n<ol>\n<li>关闭不必要的应用程序</li>\n<li>调整GreptimeDB内存设置（在Program.cs中）</li>\n<li>考虑升级系统内存到推荐配置（16GB推荐，32GB更佳）</li>\n</ol>\n<h3 id=\"llm-api-密钥未配置\">LLM API 密钥未配置</h3>\n<p>如果启动时遇到以下错误或服务无法正常启动：</p>\n<ul>\n<li>ConfigCenter 服务启动失败</li>\n<li>Web 前端无法访问 AI 功能</li>\n<li>控制台提示缺少 LLM 配置参数</li>\n</ul>\n<p><strong>解决方案</strong>：</p>\n<ol>\n<li>\n<p><strong>检查参数是否已配置</strong>：</p>\n<pre><code class=\"language-bash\"># 查看 User Secrets（如果使用）\ncd Src/CodeSpirit.AppHost\ndotnet user-secrets list\n</code></pre>\n</li>\n<li>\n<p><strong>配置缺失的参数</strong>：</p>\n<ul>\n<li>参考 <a href=\"#%E5%BF%85%E5%A1%AB%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE\" rel=\"noopener nofollow\">必填参数配置</a> 章节</li>\n<li>确保至少配置了 <code>llm-ApiKey</code> 和 <code>ai-form-fill-llm-ApiKey</code> 两个必填参数</li>\n</ul>\n</li>\n<li>\n<p><strong>验证配置</strong>：</p>\n<ul>\n<li>重启应用后，检查 Aspire Dashboard 中的服务状态</li>\n<li>查看服务日志确认参数是否正确加载</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p><strong>提示</strong>: 如果暂时不需要使用 AI 功能，可以设置占位符值（如 <code>placeholder-key</code>），但相关 AI 功能将无法正常工作。</p>\n</blockquote>\n<h2 id=\"开发模式\">开发模式</h2>\n<h3 id=\"热重载开发\">热重载开发</h3>\n<pre><code class=\"language-bash\"># 启用热重载\ncd Src/CodeSpirit.AppHost\ndotnet watch run\n</code></pre>\n<h3 id=\"调试模式\">调试模式</h3>\n<p>在Visual Studio或VS Code中设置断点，按F5启动调试。</p>\n<h2 id=\"生产环境部署\">生产环境部署</h2>\n<h3 id=\"使用kubernetes部署\">使用Kubernetes部署</h3>\n<p>项目提供了完整的Kubernetes部署文件：</p>\n<pre><code class=\"language-bash\"># 部署到Kubernetes集群\nkubectl apply -f k8s/\n\n# 查看部署状态\nkubectl get pods -n code-spirit-release\n</code></pre>\n<h3 id=\"使用docker部署\">使用Docker部署</h3>\n<pre><code class=\"language-bash\"># 构建所有服务的Docker镜像\ndotnet publish CodeSpirit.sln -c Release\n\n# 使用项目提供的Dockerfile构建镜像\ndocker build -f Src/CodeSpirit.Web/Dockerfile -t codespirit-web:latest .\ndocker build -f Src/CodeSpirit.IdentityApi/Dockerfile -t codespirit-identity:latest .\n</code></pre>\n<h3 id=\"配置管理\">配置管理</h3>\n<p>生产环境配置通过以下方式管理：</p>\n<ul>\n<li><strong>Kubernetes ConfigMap</strong>: 存储应用配置</li>\n<li><strong>Kubernetes Secret</strong>: 存储敏感信息</li>\n<li><strong>配置中心</strong>: 动态配置管理</li>\n</ul>\n<h2 id=\"下一步\">下一步</h2>\n<p>环境搭建完成后，您可以：</p>\n<ol>\n<li>📖 阅读 <a href=\"./%E9%A1%B9%E7%9B%AE%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.md\" rel=\"noopener nofollow\" target=\"_blank\">项目整体架构设计</a></li>\n<li>🔧 了解 <a href=\"./CodeSpirit.Core%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6.md\" rel=\"noopener nofollow\" target=\"_blank\">CodeSpirit.Core核心框架</a></li>\n<li>📋 查看 <a href=\"./%E6%80%BB%E4%BD%93%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E8%AF%B4%E6%98%8E.md\" rel=\"noopener nofollow\" target=\"_blank\">总体技术体系说明</a></li>\n<li>🔐 学习 <a href=\"./CodeSpirit%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%8C%87%E5%8D%97.md\" rel=\"noopener nofollow\" target=\"_blank\">统一异常处理指南</a></li>\n<li>💻 参考 <a href=\"./CRUD%E5%BC%80%E5%8F%91%E7%A4%BA%E4%BE%8B.md\" rel=\"noopener nofollow\" target=\"_blank\">CRUD开发示例</a> 开始开发</li>\n</ol>\n<h2 id=\"获取帮助\">获取帮助</h2>\n<p>如果遇到问题，请参考：</p>\n<ul>\n<li><a href=\"https://github.com/your-org/code-spirit/issues\" rel=\"noopener nofollow\" target=\"_blank\">GitHub Issues</a></li>\n<li><a href=\"https://github.com/your-org/code-spirit/wiki\" rel=\"noopener nofollow\" target=\"_blank\">项目Wiki</a></li>\n<li><a href=\"https://github.com/your-org/code-spirit/discussions\" rel=\"noopener nofollow\" target=\"_blank\">讨论区</a></li>\n</ul>\n<p>祝您开发愉快！🚀</p>\n\n</div>\n<div id=\"MySignature\">\n    作者：<a href=\"http://www.cnblogs.com/codelove/\" target=\"_blank\">雪雁</a><br />出处：<a href=\"http://www.cnblogs.com/codelove/\" target=\"_blank\">http://www.cnblogs.com/codelove/</a>\n<br />如果喜欢作者的文章，请关注【CodeSpirit-码灵】公众号以便第一时间获得最新内容。本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。<br /><b>静听鸟语花香，漫赏云卷云舒。</b>\n<br />\n<img height=\"100\" src=\"https://images.cnblogs.com/cnblogs_com/codelove/315887/o_251224070213_%E5%85%AC%E4%BC%97%E5%8F%B7.jpg\" width=\"100\" />\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-29 15:07</span>&nbsp;\n<a href=\"https://www.cnblogs.com/codelove\">雪雁</a>&nbsp;\n阅读(<span id=\"post_view_count\">137</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "当我试图搞清楚 FFmpeg 的硬件加速时，我写了一个能自动检测所有 GPU 编码器的小工具",
      "link": "https://www.cnblogs.com/hyb1/p/19415077",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/hyb1/p/19415077\" id=\"cb_post_title_url\" title=\"发布于 2025-12-29 12:04\">\n    <span>当我试图搞清楚 FFmpeg 的硬件加速时，我写了一个能自动检测所有 GPU 编码器的小工具</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        ffmpeg 硬件加速 GPU编码 视频编解码 NVEnc NVDec Intel QSV AMD AMF VAAPI Vulkan 视频编码 VideoToolbox Media Foundation DXVA2 D3D11VA D3D12VA\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">在过去的几年里，本人陆陆续续接触了不少视频处理相关的项目。每当涉及到FFmpeg的硬件加速部分，本人都会陷入一种“信息过载”的状态：文档很多、接口很多、驱动差异巨大，甚至同一台机器在不同系统下的表现都不一样。</span></p>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">如果您也曾经尝试过让FFmpeg调用GPU编码/解码器，大概率会遇到类似的情况：</span></p>\n<ul style=\"white-space: normal;\">\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">明明显卡支持 H.265，却始终无法正常编码</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">NVEnc、QSV、AMF、VAAPI……到底哪个能用？</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">为什么 1080p 可以，4K 却失败</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">Windows 和 Linux 的硬件加速接口完全不是一套逻辑</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">FFmpeg 的“支持列表”并不能代表你的设备真的支持</span></p>\n</li>\n</ul>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">这些问题看似简单，但真正排查起来非常耗时间啊啊啊。 于是本人干脆写了一个工具，让它自动帮我把所有硬件编码器和解码器都测一遍。</span></p>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">这个工具就是： <span style=\"font-size: 16px;\"><strong style=\"white-space: normal;\">HwCodecDetect</strong> </span></span></p>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap; font-size: 15px;\">GitHub 地址： <a href=\"https://github.com/whyb/HwCodecDetect\" rel=\"noopener nofollow\" target=\"_blank\"><span style=\"white-space: normal;\">https://github.com/whyb/HwCodecDetect</span></a></span></p>\n<h1 style=\"white-space: normal;\">FFmpeg 的硬件加速生态：复杂，但真实</h1>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">如果只用 CPU 编码，FFmpeg 的体验非常统一；但一旦涉及 GPU，情况就完全不同了。</span></p>\n<h2 style=\"white-space: normal;\">多厂商、多接口、多历史包袱</h2>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">不同厂商有不同的硬件加速接口：</span></p>\n<ul style=\"white-space: normal;\">\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\"><strong style=\"white-space: pre-wrap;\">NVIDIA</strong>：NVEnc / NVDec</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\"><strong style=\"white-space: pre-wrap;\">Intel</strong>：QSV</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\"><strong style=\"white-space: pre-wrap;\">AMD</strong>：AMF</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\"><strong style=\"white-space: pre-wrap;\">Apple</strong>：VideoToolbox</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\"><strong style=\"white-space: pre-wrap;\">Linux</strong>：VAAPI / Vulkan</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\"><strong style=\"white-space: pre-wrap;\">Windows</strong>：Media Foundation / DXVA2 / D3D11VA / D3D12VA</span></p>\n</li>\n</ul>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">这些接口之间没有统一标准，甚至同一厂商在不同系统上的表现也不一致。</span></p>\n<h2 style=\"white-space: normal;\">“支持”不等于“可用”</h2>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">FFmpeg 文档里写着“支持某某编码器”，但实际情况可能是：</span></p>\n<ul style=\"white-space: normal;\">\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">驱动版本不够</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">显卡架构不支持某个分辨率</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">系统缺少依赖</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">FFmpeg 编译参数不完整</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">某些接口只支持解码，不支持编码</span></p>\n</li>\n</ul>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">你不测试，根本不知道你的机器到底能不能用。</span></p>\n<h1 style=\"white-space: normal;\">HwCodecDetect：把所有硬件编码器都跑一遍，结果一目了然</h1>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">这个工具的核心目标非常直接：</span></p>\n<blockquote style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\"><strong style=\"white-space: pre-wrap;\">自动检测当前系统上所有可用的硬件编码器/解码器，并测试它们能处理的最大分辨率。</strong></span></p>\n</blockquote>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">它的工作方式是：</span></p>\n<ol start=\"1\" style=\"white-space: normal;\">\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">自动生成不同分辨率的测试视频（从 240p 到 8K）</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">使用 FFmpeg 调用各种硬件编码器</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">记录成功与失败</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">输出一份清晰的检测报告</span></p>\n</li>\n</ol>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">支持的编码器包括：</span></p>\n<ul style=\"white-space: normal;\">\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">NVEnc / NVDec</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">QSV</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">AMF</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">VAAPI</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">Vulkan</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">Media Foundation</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">DXVA2 / D3D11VA / D3D12VA</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">Apple VideoToolbox</span></p>\n</li>\n</ul>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">基本覆盖了目前所有主流 GPU 加速接口。</span></p>\n<h1 style=\"white-space: normal;\">为什么我需要这样一个工具？</h1>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">本人写这个工具的原因其实很简单：</span></p>\n<h3 style=\"white-space: normal;\">1. 本人不想再猜显卡到底能不能用</h3>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">不同显卡、不同驱动、不同系统，组合起来就是一堆未知数。</span></p>\n<h3 style=\"white-space: normal;\">2. 本人不想再查文档</h3>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">文档写得再详细，也不如直接跑一遍来得准确。</span></p>\n<h3 style=\"white-space: normal;\">3. 本人不想再被驱动坑</h3>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">驱动更新后编码能力变化是常见情况，自动检测能避免踩坑。</span></p>\n<h3 style=\"white-space: normal;\">4. 本人希望它能成为“视频处理工程师的体检工具”</h3>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">跑一次，你就知道你的机器到底能干什么。</span></p>\n<h1 style=\"white-space: normal;\">如何使用（非常简单）</h1>\n<h2 style=\"white-space: normal;\">方式一：pip 安装（推荐）</h2>\n<div class=\"cnblogs_code\">\n<pre>pip <span style=\"color: rgba(0, 0, 255, 1);\">install</span><span style=\"color: rgba(0, 0, 0, 1);\"> hwcodecdetect\nhwcodecdetect</span></pre>\n</div>\n<h2 style=\"white-space: normal;\">方式二：下载可执行文件（无需 Python）</h2>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">Releases 页面： <a href=\"https://github.com/whyb/HwCodecDetect/releases\" rel=\"noopener nofollow\" target=\"_blank\"><span style=\"white-space: pre-wrap;\">https://github.com/whyb/HwCodecDetect/releases</span></a></span></p>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">下载对应系统的可执行文件即可运行。</span></p>\n<h2 style=\"white-space: normal;\">方式三：从源码安装</h2>\n<div style=\"white-space: normal;\">\n<div class=\"rounded-b-xl bg-background-static-850 px-4 pb-1.5 dark:bg-background-static-900\">\n<div style=\"white-space: pre;\">\n<div class=\"cnblogs_code\">\n<pre>git clone https:<span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">github.com/whyb/HwCodecDetect.git</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">cd HwCodecDetect\npip </span><span style=\"color: rgba(0, 0, 255, 1);\">install</span><span style=\"color: rgba(0, 0, 0, 1);\"> .\nhwcodecdetect</span></pre>\n</div>\n</div>\n</div>\n</div>\n<h1 style=\"white-space: normal;\">检测结果长什么样？</h1>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">工具会输出一份类似“硬件能力体检报告”的结果，包含：</span></p>\n<ul style=\"white-space: normal;\">\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">哪些编码器可用</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">哪些解码器可用</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">每个编码器支持的分辨率</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">哪些接口失败了</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">哪些格式被显卡硬件支持</span></p>\n</li>\n</ul>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">对于需要做视频转码、媒体服务器、AI 视频处理、云渲染的开发者来说，这份报告非常有价值。</span></p>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">效果演示：</span></p>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\"><img alt=\"hwcodecdetect\" src=\"https://img2024.cnblogs.com/blog/511612/202512/511612-20251229115741599-1997577731.gif\" /></span></p>\n<p style=\"white-space: normal;\">&nbsp;</p>\n<h1 style=\"white-space: normal;\">这个项目适合哪些人？</h1>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">如果您正在做：</span></p>\n<ul style=\"white-space: normal;\">\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">视频转码服务</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">FFmpeg 自动化脚本</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">媒体服务器（Jellyfin / Emby / Plex）</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">GPU 加速推理前处理</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">视频编码性能测试</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">多平台视频工具开发</span></p>\n</li>\n</ul>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">那么这个工具能帮你节省大量时间。</span></p>\n<h1 style=\"white-space: normal;\">最后</h1>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">如果你觉得这个工具对你有帮助，欢迎来 <strong>GitHub</strong> 点个 Star 啊啊啊，也欢迎分享给您的同事或朋友。</span></p>\n<p style=\"white-space: normal;\"><span style=\"font-size: 18px;\"><a href=\"https://github.com/whyb/HwCodecDetect\" rel=\"noopener nofollow\" target=\"_blank\"><span style=\"white-space: pre-wrap;\"><span style=\"white-space: pre-wrap;\">https://github.com/whyb/HwCodecDetect</span></span></a></span></p>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">如果您在使用过程中遇到任何问题，也欢迎在 issue 里交流，我会持续维护和改进。</span></p>\n<p style=\"white-space: normal;\">&nbsp;</p>\n<p style=\"white-space: normal;\">&nbsp;</p>\n<p style=\"white-space: normal;\">&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-29 12:04</span>&nbsp;\n<a href=\"https://www.cnblogs.com/hyb1\">重庆Debug</a>&nbsp;\n阅读(<span id=\"post_view_count\">227</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "你还在用Claude Code?我早已开始使用 Codex + Claude Code MCP 进行 AI Coding",
      "link": "https://www.cnblogs.com/token-ai/p/19418542",
      "published": "",
      "description": "<div class=\"postTitle\">\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/token-ai/p/19418542\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 02:15\">\n    <span>你还在用Claude Code?我早已开始使用 Codex + Claude Code MCP 进行 AI Coding</span>\n    \n\n</a>\n\n        </div>\n        <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>写在圣诞节之后的年末：把“AI 会写代码”升级为“AI 能在终端里把活干完”。</p>\n</blockquote>\n<p>这篇文章是一次偏工程落地的分享：用 <strong>Codex CLI</strong> 作为主控（模型用 <code>gpt-5.2</code>，推理开到 <code>xhigh</code>），再把 <strong>Claude Code</strong> 通过 <code>claude mcp serve</code> 以 <strong>MCP Server</strong> 的方式接入，让 Codex 的工具链更完整、更顺手；同时用一个兼容 OpenAI API 的第三方服务（<code>https://api.routin.ai/v1</code>）作为模型提供商入口，达到“体验不变、成本更友好”的目的。</p>\n<p>文中会给出一份“核心配置”（你提供的那份），并解释每个字段为什么重要、怎么验证、常见坑怎么避。</p>\n<hr />\n<h2 id=\"1-这套组合解决什么问题\">1. 这套组合解决什么问题？</h2>\n<p>很多人用 AI Coding 的卡点不在“模型不会写”，而在：</p>\n<ul>\n<li>工具链割裂：模型写了，但不会/不方便自己查资料、跑命令、读写文件、串起多步工作流。</li>\n<li>推理不够深：复杂重构/排障需要更强的规划与验证能力。</li>\n<li>成本不可控：高强度推理模型一开，账单飞涨。</li>\n</ul>\n<p>这套方案的思路是：</p>\n<ol>\n<li><strong>Codex CLI 做主控代理</strong>：负责理解任务、拆解步骤、在本地执行/修改。</li>\n<li><strong>Claude Code 以 MCP Server 方式挂载</strong>：通过 <code>claude mcp serve</code> 把 Claude Code 的能力“工具化”提供给 Codex（Codex 侧只需要配置一个 MCP 服务器即可）。</li>\n<li><strong>自定义模型提供商</strong>：把 <code>model_provider</code> 指向 <code>meteor-ai</code>，并把 <code>base_url</code> 配到 <code>https://api.routin.ai/v1</code>，让 Codex 仍按 OpenAI 风格调用，但走更适合自己的计费/网络入口。</li>\n</ol>\n<hr />\n<h2 id=\"2-mcp-是什么为什么要接-claude-code-mcp\">2. MCP 是什么？为什么要接 Claude Code MCP？</h2>\n<p><strong>MCP（Model Context Protocol）</strong> 可以理解为“AI 的通用扩展口”：Codex 作为 MCP Client，通过 MCP Server 获取外部工具、资源、服务的能力。</p>\n<p>Codex 官方配置文档明确支持通过 <code>mcp_servers</code> 配置两类 MCP：</p>\n<ul>\n<li><strong>STDIO</strong>：由 Codex 启动本地进程，通过标准输入输出通信（本机工具最常用）。</li>\n<li><strong>Streamable HTTP</strong>：通过 HTTP URL 连接远程 MCP Server（适合云服务/内网服务）。</li>\n</ul>\n<p>而 <strong>Claude Code</strong> 自带 <code>claude mcp serve</code>，可以直接启动一个 MCP Server。因此，把 Claude Code 当作一个“工具供应商”，接到 Codex 上，是一种非常自然的组合方式：你可以用 Codex 统一驱动工作流，同时复用 Claude Code 已经打磨好的 MCP 服务能力。</p>\n<hr />\n<h2 id=\"3-环境准备一次装好后面全自动\">3. 环境准备（一次装好，后面全自动）</h2>\n<h3 id=\"31-安装-codex-cli\">3.1 安装 Codex CLI</h3>\n<p>常见方式：</p>\n<pre><code class=\"language-bash\">npm install -g @openai/codex\n</code></pre>\n<p>或在 macOS 用 Homebrew：</p>\n<pre><code class=\"language-bash\">brew install --cask codex\n</code></pre>\n<p>安装后验证：</p>\n<pre><code class=\"language-bash\">codex --version\n</code></pre>\n<h3 id=\"32-安装-claude-code确保有-claude-命令\">3.2 安装 Claude Code（确保有 <code>claude</code> 命令）</h3>\n<p>Claude Code 官方仓库提供了多种安装方式（Windows 也支持）。</p>\n<p>安装后验证：</p>\n<pre><code class=\"language-bash\">claude --version\n</code></pre>\n<p>以及确认 <code>claude mcp serve</code> 存在：</p>\n<pre><code class=\"language-bash\">claude mcp --help\nclaude mcp serve --help\n</code></pre>\n<h3 id=\"33-配置环境变量openai_api_key\">3.3 配置环境变量：<code>OPENAI_API_KEY</code></h3>\n<p>你希望 Codex 走 <code>meteor-ai</code>（<code>https://api.routin.ai/v1</code>）时读取 <code>OPENAI_API_KEY</code>，所以需要在系统环境变量里设置：</p>\n<ul>\n<li>变量名：<code>OPENAI_API_KEY</code></li>\n<li>变量值：你在对应平台获取到的实际 Key（请当作密钥管理，不要写进仓库/截图/日志）</li>\n</ul>\n<p>Windows（PowerShell）临时设置（仅当前终端生效）：</p>\n<pre><code class=\"language-powershell\">$env:OPENAI_API_KEY = \"你的Key\"\n</code></pre>\n<p>Windows（持久化到用户环境变量，需重开终端）：</p>\n<pre><code class=\"language-powershell\">setx OPENAI_API_KEY \"你的Key\"\n</code></pre>\n<p>macOS/Linux（当前 shell 生效）：</p>\n<pre><code class=\"language-bash\">export OPENAI_API_KEY=\"你的Key\"\n</code></pre>\n<hr />\n<h2 id=\"4-核心配置原样保留--逐项解释\">4. 核心配置（原样保留 + 逐项解释）</h2>\n<p>Codex 的配置文件默认为：</p>\n<ul>\n<li>macOS/Linux：<code>~/.codex/config.toml</code></li>\n<li>Windows：<code>%USERPROFILE%\\.codex\\config.toml</code></li>\n</ul>\n<p>把下面这份内容写进去即可（你给的“最核心配置”，原样保留）：</p>\n<pre><code class=\"language-toml\">model = \"gpt-5.2\"\nmodel_provider = \"meteor-ai\"\ndisable_response_storage = true\napproval_policy = \"never\"                  # 可选值: \"untrusted\" | \"on-failure\" | \"on-request\" | \"never\"\nsandbox_mode = \"danger-full-access\"\n\nrmcp_client = true\nmodel_reasoning_effort = \"xhigh\"\n\n# Reasoning summary: auto | concise | detailed | none (default: auto)\nmodel_reasoning_summary = \"detailed\"\n\n# Text verbosity for GPT-5 family (Responses API): low | medium | high (default: medium)\nmodel_verbosity = \"high\"\n\n# Force-enable reasoning summaries for current model (default: false)\nmodel_supports_reasoning_summaries = true\n\n[mcp_servers.claude]\ncommand = \"claude\"\n# Optional\nargs = [\"mcp\", \"serve\"]\n\n[model_providers.meteor-ai]\nname = \"meteor-ai\"\nbase_url = \"https://api.routin.ai/v1\"\nenv_key = \"OPENAI_API_KEY\"\nwire_api = \"responses\"\n</code></pre>\n<p>下面解释每个关键点（只讲“为什么重要”）：</p>\n<h3 id=\"41-model--gpt-52主模型选择\">4.1 <code>model = \"gpt-5.2\"</code>：主模型选择</h3>\n<p>Codex 的核心价值是“在本地跑多步任务”。复杂任务（重构、定位 bug、跨多文件一致性修改）更依赖模型推理与规划能力，因此选 <code>gpt-5.2</code> 这种更强的通用模型是合理的。</p>\n<h3 id=\"42-model_provider--meteor-ai--model_providersmeteor-ai\">4.2 <code>model_provider = \"meteor-ai\"</code> + <code>[model_providers.meteor-ai]</code></h3>\n<p>这表示你不走默认的 OpenAI Provider，而是注册一个新的 Provider：</p>\n<ul>\n<li><code>base_url = \"https://api.routin.ai/v1\"</code>：把 OpenAI 风格的 <code>/v1/...</code> 请求转到该地址</li>\n<li><code>env_key = \"OPENAI_API_KEY\"</code>：从系统环境变量取 Key</li>\n<li><code>wire_api = \"responses\"</code>：强制走 Responses API 形态（对 <code>reasoning_effort / verbosity</code> 这类参数更关键）</li>\n</ul>\n<p>你也可以把 <code>env_key</code> 改成更语义化的名字（比如 <code>ROUTIN_API_KEY</code>），但本文按你的设定使用 <code>OPENAI_API_KEY</code>，这样对 Codex 的默认生态也更兼容。</p>\n<h3 id=\"43-model_reasoning_effort--xhigh把想清楚再动手拉满\">4.3 <code>model_reasoning_effort = \"xhigh\"</code>：把“想清楚再动手”拉满</h3>\n<p><code>xhigh</code> 通常意味着：</p>\n<ul>\n<li>更强的规划与多步推理能力</li>\n<li>更高的延迟与成本</li>\n</ul>\n<p>建议你把它当作“复杂任务档”，简单任务（改文案/小函数/读文档）可以切到低一点以省钱省时。</p>\n<h3 id=\"44-model_reasoning_summary--detailed--model_supports_reasoning_summaries--true\">4.4 <code>model_reasoning_summary = \"detailed\"</code> + <code>model_supports_reasoning_summaries = true</code></h3>\n<p>这会让 Codex 更倾向输出<strong>推理摘要</strong>（不是完整思维链，而是可读的总结），适合做技术分享/团队协作：你能看见它为什么这么改、考虑了哪些边界。</p>\n<h3 id=\"45-model_verbosity--high输出更详细\">4.5 <code>model_verbosity = \"high\"</code>：输出更详细</h3>\n<p>适合教程/分享场景，尤其是你希望它把操作步骤、验证方式讲清楚的时候。</p>\n<h3 id=\"46-approval_policy--never--sandbox_mode--danger-full-access全自动但风险最高\">4.6 <code>approval_policy = \"never\"</code> + <code>sandbox_mode = \"danger-full-access\"</code>：全自动，但风险最高</h3>\n<p>这套组合的含义是：</p>\n<ul>\n<li>Codex 不会向你请求批准（所有命令/改动默认都能执行）</li>\n<li>文件系统与网络基本不设限</li>\n</ul>\n<p>它非常适合：</p>\n<ul>\n<li>容器/虚拟机/隔离环境里的自动化原型开发</li>\n<li>你明确知道自己在做什么，并且能接受“AI 可能误删/误改”的风险</li>\n</ul>\n<p>但不建议在重要生产机、核心仓库、带密钥/账单权限的环境中直接长期使用。更推荐的做法是：用 Profile 分出“安全档”和“全自动档”（见后文“可选增强”）。</p>\n<h3 id=\"47-rmcp_client--true关于-rmcp-客户端的兼容性提示\">4.7 <code>rmcp_client = true</code>：关于 RMCP 客户端的兼容性提示</h3>\n<p>Codex 官方文档里提到 Streamable HTTP 连接会使用 Rust MCP client（rmcp）。不同版本对开关字段可能存在差异：</p>\n<ul>\n<li>如果你发现 <code>rmcp_client</code> 报“未知字段”，优先以 <code>docs/config.md</code> 为准，删除该项通常不影响 STDIO MCP。</li>\n<li>如果你在用较老版本并且需要显式启用 Streamable HTTP，可能会见到类似 <code>experimental_use_rmcp_client</code> 的开关（以你使用版本的文档/发行说明为准）。</li>\n</ul>\n<p>本文按你提供的配置保留 <code>rmcp_client = true</code>，便于复现你的“核心配置”。</p>\n<h3 id=\"48-disable_response_storage--true关于关闭存储的两层含义\">4.8 <code>disable_response_storage = true</code>：关于“关闭存储”的两层含义</h3>\n<p><code>disable_response_storage</code> 不是 Codex 官方 <code>docs/config.md</code> 里的标准字段（至少在本文写作时）。如果你的 Codex 版本支持它，它通常表达的是“不要把对话/响应持久化”。这里建议你区分两层：</p>\n<ol>\n<li><strong>本地历史</strong>：Codex 默认会把消息写入 <code>$CODEX_HOME/history.jsonl</code>。如果你希望彻底不落盘，可以用官方的 <code>[history]</code> 配置关闭持久化：</li>\n</ol>\n<pre><code class=\"language-toml\">[history]\npersistence = \"none\"\n</code></pre>\n<ol start=\"2\">\n<li><strong>远端留存</strong>：不同 API 提供商对日志与留存策略不同。即便本地不写盘，也不代表服务端不记录。做团队推广时，建议明确告知读者：以提供商的隐私/合规条款为准。</li>\n</ol>\n<p>如果你的 Codex 启动时报 “unknown field disable_response_storage”，直接删除这一行，并改用上面的 <code>[history] persistence = \"none\"</code> 达到“本地不存”的效果。</p>\n<hr />\n<h2 id=\"5-把-claude-code-作为-codex-的-mcp-server\">5. 把 Claude Code 作为 Codex 的 MCP Server</h2>\n<p>你的配置核心就在这里：</p>\n<pre><code class=\"language-toml\">[mcp_servers.claude]\ncommand = \"claude\"\nargs = [\"mcp\", \"serve\"]\n</code></pre>\n<p>这表示：Codex 需要该 MCP Server 时，会启动一个本地进程执行：</p>\n<pre><code class=\"language-bash\">claude mcp serve\n</code></pre>\n<p>如果你想单独排障（例如看看 server 有没有启动、有没有报错），可以手动跑：</p>\n<pre><code class=\"language-bash\">claude mcp serve --debug\n</code></pre>\n<p>然后在另一个终端启动 Codex，观察 Codex 的 MCP 列表：</p>\n<pre><code class=\"language-bash\">codex mcp list\n</code></pre>\n<hr />\n<h2 id=\"6-推荐-httpsapiroutinaiv1meteor-ai与-key-配置说明\">6. 推荐 <code>https://api.routin.ai/v1</code>（meteor-ai）与 Key 配置说明</h2>\n<p>你提供的配置中，<code>meteor-ai</code> 的 <code>base_url</code> 指向：</p>\n<ul>\n<li><code>https://api.routin.ai/v1</code> 推荐RoutinAI 价格更优惠Codex低至0.2￥=1 美元的超低汇率。</li>\n</ul>\n<p>最关键的落地动作有两步：</p>\n<ol>\n<li>把 <code>base_url</code> 配到 <code>https://api.routin.ai/v1</code></li>\n<li>在系统里设置 <code>OPENAI_API_KEY=你的实际Key</code></li>\n</ol>\n<p>正常情况下会返回类似“需要 API Key”的报错，说明地址可达、路由正常；设置 <code>OPENAI_API_KEY</code> 后再由 Codex 调用即可。</p>\n<hr />\n<h2 id=\"7-实战工作流建议把-ai-coding-变成可复制的流程\">7. 实战工作流建议（把 AI Coding 变成可复制的流程）</h2>\n<p>给一个我更推荐的“稳定工作姿势”：</p>\n<ol>\n<li>让 Codex 先做“计划 + 探索”（读项目、定位入口、列修改点）</li>\n<li>再让它执行修改，并要求：\n<ul>\n<li>改动要小步提交（一次只做一件事）</li>\n<li>每一步都能运行验证（lint/test/build）</li>\n</ul>\n</li>\n<li>需要外部能力时，再通过 MCP 接更多服务器（GitHub、Playwright、文档检索等）</li>\n</ol>\n<p>示例提示词（你可以直接复制改项目名）：</p>\n<pre><code class=\"language-text\">请在不改变对外行为的前提下重构 XXX 模块：\n1) 先解释现状与风险点\n2) 给出 3~5 个小步骤计划\n3) 每一步都要可验证（说明运行哪些命令）\n4) 只在我确认后再执行危险操作\n</code></pre>\n<p>在 <code>approval_policy = \"never\"</code> 的配置下，第 4 条更多是“自律要求”，但它能显著减少误操作概率。</p>\n<p>AI Coding 技术交流群：<br />\nwk28u9123456789</p>\n\n</div>\n<div class=\"clear\"></div>\n\n        <div class=\"postDesc\">posted on \n<span id=\"post-date\">2025-12-30 02:15</span>&nbsp;\n<a href=\"https://www.cnblogs.com/token-ai\">239573049</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}