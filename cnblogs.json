{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "OData 协议的智能化语义互操作",
      "link": "https://www.cnblogs.com/shanyou/p/19601411",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/shanyou/p/19601411\" id=\"cb_post_title_url\" title=\"发布于 2026-02-10 20:39\">\n    <span>OData 协议的智能化语义互操作</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        query-craft-mcp 充当了 LLM 与 OData 服务之间的语义桥梁，解决 OData v4 语法复杂且对大小写敏感的问题\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在当今复杂多变的企业数字化转型进程中，数据协议的标准化与互操作性已成为支撑业务敏捷性与决策智能的核心基石。开放数据协议（Open Data Protocol，简称 OData）作为一种基于 REST 架构风格的开放协议，自 2007 年由微软公司（Microsoft）发起以来，经历了从私有规范到全球公认国际标准的华丽蜕变。OData 的核心目标在于提供一种标准化的方式来创建和消费可查询且互操作的 Web API，从而打破数据孤岛，提升跨系统数据的共享价值。</p>\n<h2 id=\"一odata-协议的历史背景与设计哲学\"><strong>一、OData 协议的历史背景与设计哲学</strong></h2>\n<p>OData 的起源可以追溯到 Web 2.0 时代对数据交换简便性的迫切需求。早期的企业服务主要依赖于 SOAP 等基于动作的协议，这类协议虽然严谨但过于沉重且难以在现代 Web 环境中灵活部署。为了解决这些挑战，微软最初推出了 OData v1.0 至 v3.0 版本，并将其置于微软开放规范承诺（Microsoft Open Specification Promise）之下。随着协议的成熟，OData 逐渐步入标准化轨道，v4.0 版本正式通过 OASIS 联盟的标准化审核，并最终获得 ISO/IEC 的批准（ISO/IEC 20802-1:2016），确立了其在 RESTful API 领域的权威地位。</p>\n<h3 id=\"核心设计原则\"><strong>核心设计原则</strong></h3>\n<p>OData 的设计哲学深深扎根于 REST 原则，同时又在语义表达上进行了显著增强。分析其设计原则，可以发现五个关键维度，这些维度共同构成了其在企业级应用中的韧性：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">核心原则</th>\n<th style=\"text-align: left;\">描述与实践含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>遵循 REST 原则</strong></td>\n<td style=\"text-align: left;\">建立在 HTTP、AtomPub 和 JSON 之上，使用 URI 标识资源，利用标准 HTTP 方法执行操作。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>保持简单性</strong></td>\n<td style=\"text-align: left;\">优先解决 80% 的通用场景，为复杂需求提供可扩展性，确保基础合规服务的构建门槛较低。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>增量式构建</strong></td>\n<td style=\"text-align: left;\">允许开发者从最简单的只读服务开始，随着业务需求逐步引入查询、过滤、排序及写入能力。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>高度可扩展性</strong></td>\n<td style=\"text-align: left;\">支持在不破坏既有客户端兼容性的前提下，引入特定领域的功能扩展，确保持续演进。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>数据源无关性</strong></td>\n<td style=\"text-align: left;\">不预设底层数据存储技术，无论是关系型数据库、文件系统还是内容管理系统，均可统一映射。</td>\n</tr>\n</tbody>\n</table>\n<p>通过这种高度抽象的设计，OData 不仅仅是一个数据传输格式，更是一个关于如何构建“好”API 的最佳实践集合。它让开发者能够将精力集中在业务逻辑上，而无需为请求/响应头、状态码、媒体类型或 URL 约定等琐碎的技术细节劳神。</p>\n<h2 id=\"二实体数据模型-edm-与元数据驱动架构\"><strong>二、实体数据模型 (EDM) 与元数据驱动架构</strong></h2>\n<p>OData 与传统 RESTful API 最本质的区别在于其对“数据模型”的显式定义。这种定义通过实体数据模型（Entity Data Model, EDM）实现，它是 OData 语义互操作性的灵魂。</p>\n<h3 id=\"实体数据模型的组成要素\"><strong>实体数据模型的组成要素</strong></h3>\n<p>EDM 借用了实体-联系（ER）模型的概念，定义了一个抽象的概念模型来描述服务暴露的所有资源。其核心组成部分包括实体集（EntitySets）、实体（Entities）、复杂类型（ComplexTypes）和标量类型（Scalar Types）。</p>\n<ol>\n<li><strong>实体与实体集</strong>：实体是具有唯一标识符（Key）的结构化记录，通常对应数据库中的一行。实体集则是同类实体的集合，类似于数据库表。值得注意的是，一个实体类型可以存在于多个具有不同名称的实体集中，这为开发者提供了极大的灵活性。</li>\n<li><strong>标量类型</strong>：EDM 拥有一套内置的强类型系统，所有属性必须属于预定义的标量类型（如 Edm.String, Edm.Int32, Edm.DateTimeOffset）。这种强类型约束确保了跨平台、跨语言的数据交换具有高度的一致性。</li>\n<li><strong>复杂类型</strong>：允许将一组标量属性组合在一起，形成可重用的结构，但其本身不具备唯一标识，必须依附于实体存在。</li>\n<li><strong>导航属性 (Navigation Properties)</strong>：描述了实体之间的关联关系。通过导航属性，客户端可以从一个实体跳转到另一个相关联的实体或实体集，这构成了 OData 强大的图导航能力。</li>\n</ol>\n<h3 id=\"服务文档与元数据文档的价值\"><strong>服务文档与元数据文档的价值</strong></h3>\n<p>为了实现客户端的“自发现”能力，每一个 OData 服务都必须提供两个核心文档：</p>\n<ul>\n<li><strong>服务文档 (Service Document)</strong>：位于服务根路径（如 <a href=\"http://host/service/%EF%BC%89%EF%BC%8C%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89%E5%8F%AF%E7%94%A8%E7%9A%84%E5%AE%9E%E4%BD%93%E9%9B%86%E3%80%81%E5%87%BD%E6%95%B0%E5%92%8C%E5%8D%95%E4%BE%8B%EF%BC%8C%E4%B8%BA%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8F%90%E4%BE%9B%E5%AF%BC%E8%88%AA%E7%9A%84%E5%85%A5%E5%8F%A3%E7%82%B9%E3%80%82\" rel=\"noopener nofollow\" target=\"_blank\">http://host/service/），列出所有可用的实体集、函数和单例，为客户端提供导航的入口点。</a></li>\n<li><strong>元数据文档 (Metadata Document)</strong>：位于 $metadata 路径下，采用通用架构定义语言（CSDL）编写。它是服务的“说明书”，详细描述了每种类型的属性、键、导航路径及支持的操作。</li>\n</ul>\n<p>这种元数据驱动的架构使得通用工具（如 Excel、Power BI、Salesforce Connect 等）能够仅通过解析 $metadata 即可理解服务的全部结构，从而实现零配置的数据集成。</p>\n<h2 id=\"三系统查询选项url-驱动的数据分析能力\"><strong>三、系统查询选项：URL 驱动的数据分析能力</strong></h2>\n<p>OData 最令业界称道的特性是其极为丰富的查询语言。通过在 URL 中附加系统查询选项（以 $ 符号开头），客户端可以精确控制服务器返回的数据内容和格式，从而极大地缓解了 REST 架构中常见的“过度获取”（Over-fetching）和“获取不足”（Under-fetching）问题。</p>\n<h3 id=\"基础查询操作\"><strong>基础查询操作</strong></h3>\n<p>下表总结了 OData 中最常用的系统查询选项及其功能：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">查询选项</th>\n<th style=\"text-align: left;\">功能说明</th>\n<th style=\"text-align: left;\">典型示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">$filter</td>\n<td style=\"text-align: left;\">基于逻辑表达式筛选数据。</td>\n<td style=\"text-align: left;\">Products?$filter=Price lt 10 and startswith(Name,'M')</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">$select</td>\n<td style=\"text-align: left;\">指定返回的属性字段，优化带宽。</td>\n<td style=\"text-align: left;\">Customers?$select=Name,Email</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">$expand</td>\n<td style=\"text-align: left;\">嵌套返回关联实体，减少往返请求。</td>\n<td style=\"text-align: left;\">Orders?$expand=OrderItems</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">$orderby</td>\n<td style=\"text-align: left;\">对结果进行排序，支持多字段。</td>\n<td style=\"text-align: left;\">Products?$orderby=Price desc, Name</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">$top / $skip</td>\n<td style=\"text-align: left;\">实现客户端分页，限制返回条数或跳过前 N 条。</td>\n<td style=\"text-align: left;\">Employees?$top=10&amp;$skip=20</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">$count</td>\n<td style=\"text-align: left;\">返回匹配条件的记录总数 。</td>\n<td style=\"text-align: left;\">Invoices?$count=true</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">$search</td>\n<td style=\"text-align: left;\">执行全文搜索，适用于非结构化数据。</td>\n<td style=\"text-align: left;\">Products?$search=waterproof</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"数据聚合扩展-apply\"><strong>数据聚合扩展 ($apply)</strong></h3>\n<p>在 OData v4.0 中，协议引入了 $apply 扩展，将 OData 从简单的 CRUD 协议提升到了分析型协议的高度。通过 $apply，客户端可以在服务端执行类似于 SQL GROUP BY 的操作。</p>\n<p>数据聚合的核心在于一系列转换（Transformations）的顺序执行。例如，groupby 转换将输入集划分为多个子集，而 aggregate 则对这些子集应用聚合函数（如 sum, average, min, max, countdistinct）。</p>\n<p>这种转换流模式支持极度复杂的查询。例如，“按月计算每种产品的平均销售额”可以通过多层聚合实现：首先按产品和月份进行 groupby 并求和，然后对结果再次按产品进行 groupby 并求平均值 。这种链式处理能力使得 OData 能够胜任轻量级的商业智能需求。</p>\n<h2 id=\"四并控制与性能优化策略\"><strong>四、并控制与性能优化策略</strong></h2>\n<p>在企业级高并发环境下，确保数据一致性与系统响应速度是评价协议优劣的关键指标。OData 通过一系列精妙的设计提供了工业级的解决方案。</p>\n<h3 id=\"乐观并发控制与-etag\"><strong>乐观并发控制与 ETag</strong></h3>\n<p>由于 OData 基于无状态的 HTTP 协议，传统的悲观锁（Pessimistic Locking）会极大损害扩展性并导致死锁 16。因此，OData 推荐并实现了基于实体标签（ETag）的乐观并发控制。</p>\n<p>当服务器返回实体时，会在响应头或元数据中包含一个 ETag，它通常是实体内容或版本号的哈希值。当客户端尝试更新该实体时，必须在 If-Match 请求头中携带该 ETag。如果服务器发现存储中的当前 ETag 与客户端提供的不一致，则说明在客户端读取之后，该记录已被其他进程修改，此时服务器会返回 412 Precondition Failed。</p>\n<p>这一机制在 SAP CAP、ASP.NET Web API 等主流框架中得到了自动化处理。例如，在 SAP CAP 中，仅需为属性添加 @odata.etag 注解，框架即可自动完成校验逻辑，显著降低了开发成本。</p>\n<h3 id=\"性能加速器批处理与服务端分页\"><strong>性能加速器：批处理与服务端分页</strong></h3>\n<ol>\n<li><strong>批处理 ($batch)</strong>：$batch 允许将多个独立的读写请求合并为一个 HTTP POST 请求。分析显示，这不仅减少了网络往返时间（RTT），还能在更新操作中利用单一的原子工作单元（Atomic Unit of Work），从而减少数据库事务开销和 CPU 占用 11。</li>\n<li><strong>服务端分页 ($skiptoken)</strong>：与简单的偏移量分页（$skip）不同，服务端分页利用 $skiptoken 返回一个不透明的令牌，该令牌通常对应数据库游标或上一次查询的最后一条记录的键值 12。对于大型数据集，$skiptoken 的查询速度远高于 $skip，因为它避免了数据库引擎扫描并丢弃前序记录的性能损耗 12。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">优化技术</th>\n<th style=\"text-align: left;\">主要收益</th>\n<th style=\"text-align: left;\">适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>$batch</strong></td>\n<td style=\"text-align: left;\">减少 RTT，保证原子性。</td>\n<td style=\"text-align: left;\">批量更新非关联实体，减少移动端电量损耗 。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>$expand</strong></td>\n<td style=\"text-align: left;\">解决 N+1 查询问题。</td>\n<td style=\"text-align: left;\">获取主表及其明细行（如订单与项）。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>$select</strong></td>\n<td style=\"text-align: left;\">减小 Payload 体积。</td>\n<td style=\"text-align: left;\">仅获取 ID 和名称用于展示列表。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>$skiptoken</strong></td>\n<td style=\"text-align: left;\">稳定高效的大数据集分页。</td>\n<td style=\"text-align: left;\">无限滚动列表，大型报表导出。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>GZIP 压缩</strong></td>\n<td style=\"text-align: left;\">显著减少网络流量。</td>\n<td style=\"text-align: left;\">所有生产环境的 OData 服务 20。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"五-智能化集成model-context-protocol-mcp-与-odata-的协同\"><strong>五、 智能化集成：Model Context Protocol (MCP) 与 OData 的协同</strong></h2>\n<p>随着大语言模型（LLM）成为企业生产力的核心，API 协议的“机器可理解性”变得至关重要。OData 的元数据驱动特性使其成为 LLM 落地最理想的土壤。</p>\n<h3 id=\"语义接地-semantic-grounding-的挑战\"><strong>语义接地 (Semantic Grounding) 的挑战</strong></h3>\n<p>LLM 在生成查询语句时常面临“幻觉”问题，即生成不存在的实体名或属性名。OData 的元数据文档提供了一个完美的参考坐标系（Grounding Layer）。通过提供强类型的 EDM 描述，模型可以准确获知系统边界，生成的查询语句（如 Text-to-OData）其准确率远高于非结构化的 REST API。</p>\n<h3 id=\"model-context-protocol-mcp-的崛起\"><strong>Model Context Protocol (MCP) 的崛起</strong></h3>\n<p>Model Context Protocol 是 2024 年底推出的开源标准，旨在连接 AI 助手与外部应用 ,MC 服务器作为 AI 的“感官”，可以实时获取外部系统的上下文。由于 OData 服务自带机器可读的元数据，将 OData 服务转换为 MCP 节点极大地降低了 AI 代理（Agent）与企业数据交互的成本 。</p>\n<h4 id=\"深度调研query-craft-mcp-及其技术架构\"><strong>深度调研：Query-Craft-MCP 及其技术架构</strong></h4>\n<p>由 AM10101010 开发的 query-craft-mcp 是这一领域的先锋工具。它充当了 LLM 与 OData 服务之间的语义桥梁，解决 OData v4 语法复杂且对大小写敏感的问题。</p>\n<p>根据对该项目的深入分析，其技术实现包含以下核心能力：</p>\n<ol>\n<li><strong>元数据感知生成</strong>：该工具使用 .NET 9 SDK 和 Microsoft.OData.Edm 库解析 $metadata XML，在内存中构建实体、属性、键和导航链接的索引。这确保了 AI 接收到的 context 是基于真实架构的，从根本上消除了幻觉。</li>\n<li><strong>导航路径发现 (BFS 算法)</strong>：这是 Query-Craft-MCP 的一大亮点。它实现了一个基于广度优先搜索（BFS）的遍历器，能够自动找到连接两个相关实体的最短 $expand 链。例如，当用户询问“显示购买过特定产品的客户”时，AI 能够自动推导出 Orders/OrderDetails/Product 的导航路径，而无需开发者手动编写复杂的 join 逻辑。</li>\n<li><strong>运行前验证</strong>：工具在将生成的查询发送到真正的数据源之前，会根据内存中的索引进行语法和语义验证，拦截类型不匹配或属性不存在等错误。</li>\n<li><strong>客户端辅助聚合</strong>：针对某些仅支持基础 v4 功能而不支持高级 $apply 扩展的服务器，Query-Craft-MCP 提供了客户端聚合引擎，可以在本地对结果集执行 GROUP BY, SUM, AVG 等统计操作 。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">工具名称</th>\n<th style=\"text-align: left;\">核心职责</th>\n<th style=\"text-align: left;\">在 AI 工作流中的角色</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">list-entities</td>\n<td style=\"text-align: left;\">暴露实体清单。</td>\n<td style=\"text-align: left;\">帮助 LLM 识别当前业务场景涉及的对象。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">find-navigation-path</td>\n<td style=\"text-align: left;\">路径推导。</td>\n<td style=\"text-align: left;\">解决跨表/跨实体的关系链接问题。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">validate-query</td>\n<td style=\"text-align: left;\">质量把控。</td>\n<td style=\"text-align: left;\">充当语义编译器，确保生成的 OData 语法正确。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">execute-odata-query</td>\n<td style=\"text-align: left;\">数据检索。</td>\n<td style=\"text-align: left;\">执行真正的 HTTP 请求并将 JSON 返回给 AI。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"结论数据互操作的标准化高地\"><strong>结论：数据互操作的标准化高地</strong></h2>\n<p>通过对 OData 的深度调研，我们可以清晰地看到，它不仅仅是一个过去的企业标准，更是一个面向未来的语义互操作框架。其强类型的 EDM 架构，为当今大语言模型的“落地”提供了最稳固的语义锚点；而其丰富的查询与聚合能力，则为企业低代码平台和自动化 Agent 的构建提供了即插即用的分析引擎。</p>\n<p>OData 在金融、供应链及核心 ERP 等对数据严谨性要求极高的场景下，其地位依然不可替代。对于寻求构建“AI Ready”数据架构的企业而言，选择并优化 OData 服务，配合如 Query-Craft-MCP 这样的智能化中间件，将是通往语义智能时代的必经之路。</p>\n<p>未来的竞争将不再仅仅是数据的规模之争，而是数据“被理解”的速度与准确度之争。OData 协议及其背后的元数据精神，正是这场竞赛中的关键胜负手。</p>\n<h4 id=\"引用的著作\"><strong>引用的著作</strong></h4>\n<ol>\n<li>Open Data Protocol - Wikipedia <a href=\"https://en.wikipedia.org/wiki/Open_Data_Protocol\" rel=\"noopener nofollow\" target=\"_blank\">https://en.wikipedia.org/wiki/Open_Data_Protocol</a></li>\n<li>OData - the Best Way to REST， <a href=\"https://www.odata.org/\" rel=\"noopener nofollow\" target=\"_blank\">https://www.odata.org/</a></li>\n<li>OData overview  <a href=\"https://learn.microsoft.com/en-us/odata/overview\" rel=\"noopener nofollow\" target=\"_blank\">https://learn.microsoft.com/en-us/odata/overview</a></li>\n<li>Model-driven Development of OData Services, 访问时间为 二月 10, 2026， <a href=\"https://modeling-languages.com/model-driven-development-of-odata-services/\" rel=\"noopener nofollow\" target=\"_blank\">https://modeling-languages.com/model-driven-development-of-odata-services/</a></li>\n<li>QueryCraft | MCP Servers - LobeHub <a href=\"https://lobehub.com/nl/mcp/am10101010-query-craft-mcp\" rel=\"noopener nofollow\" target=\"_blank\">https://lobehub.com/nl/mcp/am10101010-query-craft-mcp</a></li>\n<li>Why AI in Analytics Needs Metadata - GoodData,  <a href=\"https://www.gooddata.com/blog/why-ai-in-analytics-needs-metadata/\" rel=\"noopener nofollow\" target=\"_blank\">https://www.gooddata.com/blog/why-ai-in-analytics-needs-metadata/</a></li>\n<li>Optimizing an LLM-Based Clinical Data Querying System Using Metadata Enrichment and Task Decomposition   <a href=\"https://www.medrxiv.org/content/10.64898/2025.12.22.25342863v1.full.pdf\" rel=\"noopener nofollow\" target=\"_blank\">https://www.medrxiv.org/content/10.64898/2025.12.22.25342863v1.full.pdf</a></li>\n<li>Optimizing an LLM-Based Clinical Data Querying System Using Metadata Enrichment and Task Decomposition | medRxiv <a href=\"https://www.medrxiv.org/content/10.64898/2025.12.22.25342863v1\" rel=\"noopener nofollow\" target=\"_blank\">https://www.medrxiv.org/content/10.64898/2025.12.22.25342863v1</a></li>\n<li>The Model Context Protocol's impact on 2025 | Thoughtworks United States, 访问时间为 二月 10, 2026， <a href=\"https://www.thoughtworks.com/en-us/insights/blog/generative-ai/model-context-protocol-mcp-impact-2025\" rel=\"noopener nofollow\" target=\"_blank\">https://www.thoughtworks.com/en-us/insights/blog/generative-ai/model-context-protocol-mcp-impact-2025</a></li>\n</ol>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>欢迎大家扫描下面二维码成为我的客户，扶你上云</p>\n<img src=\"https://images.cnblogs.com/cnblogs_com/shanyou/57459/o_220125090408_%E9%82%80%E8%AF%B7%E4%BA%8C%E7%BB%B4%E7%A0%81-258px.jpeg\" width=\"170\" />\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-10 20:39</span>&nbsp;\n<a href=\"https://www.cnblogs.com/shanyou\">张善友</a>&nbsp;\n阅读(<span id=\"post_view_count\">5</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "SEAL全同态加密CKKS方案入门详解",
      "link": "https://www.cnblogs.com/zhaoweiwei/p/19577832/CKKS",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zhaoweiwei/p/19577832/CKKS\" id=\"cb_post_title_url\" title=\"发布于 2026-02-10 18:21\">\n    <span>SEAL全同态加密CKKS方案入门详解</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文以微软的开源全同态库SEAL中CKKS方案为参照，依次介绍了CKKS方案相关的核心原理，以及方案实施标准流程，最后给出了一个一个简单的SEAL库CKKS方案示例程序，并给出相应的运行结果。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p align=\"left\">CKKS（Cheon–Kim–Kim–Song）是2017年论文《Homomorphic Encryption for Arithmetic of Approximate Numbers》中提出的近似计算同态加密算法，论文的作者是Cheon等四位韩国研究者，如今该方案已经是面向浮点/复数近似同态计算的主流方案，广泛应用于密文机器学习、数值计算场景。不同于以往同态加密算法中所追求的解密结果和明文完全一致，CKKS算法的目标是做近似计算。这并不偏离需求，因为现实生活中大部分运算，面对的是实数（复数），而实数（复数）的运算，往往只需要保留一部分有效数字即可。此外，允许误差，放宽准确性的限制，使得CKKS对比于其他基于LWE/RLWE难题的同态方案，细节有了较大的简化，计算效率也有了很大提升。</p>\n<h1>1 核心原理</h1>\n<h2>1.1 编码与嵌入原理</h2>\n<p align=\"left\">CKKS的核心创新是规范嵌入（Canonical Embedding），将环R上的多项式与复数空间C<sup>N/2</sup>双向映射：</p>\n<p align=\"left\">（1）多项式<em>f(x)∈R</em>可通过分圆多项式的根映射为N/2维复数向量</p>\n<p align=\"left\">（2）复数向量可反向映射为环上多项式，实现向量数据与多项式的无损转换</p>\n<p align=\"left\">（3）结合缩放因子Δ=2<sup>k</sup>，将浮点数放大为整数，适配有限域运算</p>\n<p align=\"left\">槽位数量=N/2，例如N=8192时，单密文可打包4096个浮点数并行运算。R是分圆多项式环：</p>\n<p><img alt=\"image\" height=\"34\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209110608893-1701884716.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"353\" /></p>\n<p>环中的元素是系数是整数（严格来说是实数）的N次多项式。</p>\n<p align=\"left\">C<sup>N/2</sup>是N/2维复数向量构成的环，它里面的元素是N/2维复数向量。规范嵌入是环同构（保持环加法与乘法的双向一一映射）：</p>\n<p><img alt=\"image\" height=\"32\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209120035570-1372830017.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"150\" /></p>\n<p>设ζ<sub>j</sub> = e<sup>i(2j+1)π/N</sup>，j = 0,1,...,N-1是x<sup>N</sup> + 1 = 0，即x<sup>N</sup> = -1 = e<sup>iπ</sup>的N个元根，则σ从左到右表示为：</p>\n<p><img alt=\"image\" height=\"40\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209120224137-710695710.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"474\" /></p>\n<p>σ有以下关键性质：</p>\n<p>（1）加法映射为向量加法，即σ(f+g) =&nbsp;σ(f) +&nbsp;σ(g)</p>\n<p>（2）乘法映射为向量逐元素乘法（Hadamard积）σ(f•g) =&nbsp;σ(f)&nbsp;•&nbsp;σ(g)</p>\n<p>（3）双射（可逆）</p>\n<p>可以从向量还原多项式（逆映射），接下来以N=8为例，从正反两个方面进行分析。</p>\n<h3>1 正向映射（canomical embedding R-&gt;C<sup>4</sup>）</h3>\n<p>当N=8时，环表示为：</p>\n<p><img alt=\"image\" height=\"27\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209120812481-583938144.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"193\" /></p>\n<p>环中的元素为多项式：f(x)=a<sub>0</sub>+a<sub>1</sub>x+a<sub>2</sub>x<sup>2</sup>+...+a<sub>7</sub>x<sup>7</sup>，x<sup>8</sup>+1=0的元根为：x=e<sup>i(2k+1)π/8</sup>，k=0,1,...,7，由元根的共轭可知：</p>\n<p><img alt=\"image\" height=\"262\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260210101831409-1941165188.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"270\" /></p>\n<p align=\"left\">则正向映射将多项式映射为复数向量，表示为：</p>\n<p><img alt=\"image\" height=\"35\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209121233176-213381444.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"445\" /></p>\n<p>以上只取前4个根，因为由于共轭有：</p>\n<p><img alt=\"image\" height=\"32\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209121546561-1996158330.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"333\" /></p>\n<p>以多项式f(x) = 1 + 2x + 3x2为例，计算第一个槽：</p>\n<p><img alt=\"image\" height=\"99\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209121709917-1592425942.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"571\" />同理可得4维向量的其他分量，从而完成多项式向复向量的映射，σ(f) = (z<sub>0</sub>,z<sub>1</sub>,z<sub>2</sub>,z<sub>3</sub>)∈C<sup>4</sup>。这一步本质上就是FFT的前半部分，𝑓(𝑥)有8个实自由度，而复向量看起来只有4个自由度，但是因为𝑧<sub>i</sub>是复数，它本身有2个实自由度，所以总体上来说复向量有4x2=8个实自由度。</p>\n<h3>2 逆向映射（C<sup>4</sup>-&gt;R）</h3>\n<p>逆向映射将复数向量映射为多项式，由(z<sub>0</sub>,z<sub>1</sub>,z<sub>2</sub>,z<sub>3</sub>)∈C<sup>4</sup>恢复一个多项式，构造长度为8的“频域向量”：</p>\n<p><img alt=\"image\" height=\"29\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209150228446-1761094550.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"298\" /></p>\n<p>唯一多项式f(x)满足：f(ζ<sub>k</sub>) = z<sub>k</sub>，k = 0,1,2,...,7，利用Lagrange插值（工程上对应inverse FFT）即可得到：</p>\n<p><img alt=\"image\" height=\"28\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209150615101-1539219155.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"351\" /></p>\n<p>其中所有a<sub>i</sub>∈R。这里的双向映射正是CKKS Encode/Decode在做的事：</p>\n<p><img alt=\"\" height=\"234\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209150904927-1228266632.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"637\" /></p>\n<h2>1.2 缩放因子（Scale）及近似计算</h2>\n<p>CKKS不追求绝对精确，解密结果与原始明文存在极小精度误差，误差可控且远低于机器学习/数值分析的容忍阈值，这是效率与实用性的平衡设计，为了实现该目标引入了缩放因子，缩放因子在“把实/复数嵌入整数多项式环”时，由“缩放+舍入”不可避免引入了精度误差：</p>\n<p><img alt=\"image\" height=\"29\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209151018659-2008326500.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"300\" /></p>\n<p>仍以N=8为例说明相应流程，原本映射</p>\n<p><img alt=\"image\" height=\"33\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209151905200-426056642.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"485\" /></p>\n<p>是一对零误差的严格双射，但是CKKS要做一件“非法的事”，逆向映射由实/复数转换成整系数多项式，就是：</p>\n<p><img alt=\"image\" height=\"34\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209152020759-2070476129.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"488\" /></p>\n<p>操作本身就不可能精确完成，原因很简单，左边是连续域，右边是离散格，CKKS的解决方案是进行“缩放+舍入（误差源头）”，首先引入一个scale Δ，在映射前对复向量进行缩放：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209153919946-1630554091.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>这一步只是放大并没有引入误差，接下来进行逆embedding（IFFT）得到实系数多项式：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209153919937-1690109536.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>理论上这一步仍然是精确的，但是在进行随后一步舍入到整系数时会产生误差：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209153919914-412330373.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p align=\"left\">令：</p>\n<p><img alt=\"image\" height=\"33\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209152958825-135711869.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"225\" /></p>\n<p>其中e(x)的每个系数都满足|e<sub>i</sub>|≤1/2，当映射回slot空间时，会对m(x)再做canonical embedding：</p>\n<p><img alt=\"image\" height=\"29\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209153222424-1033559120.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"186\" /></p>\n<p>而：</p>\n<p><img alt=\"image\" height=\"33\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209153258782-1352680454.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"276\" /></p>\n<p>所以：</p>\n<p><img alt=\"image\" height=\"32\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209153349080-2016492421.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"502\" /></p>\n<p>其中ε<sub>k</sub> = e(ζ<sub>k</sub>)，最后会除于scale Δ：</p>\n<p><img alt=\"image\" height=\"59\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209153623063-989735394.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"440\" /></p>\n<p>这就是CKKS的“近似”，对比BFV中的“舍入”，他们的含义完全不同：</p>\n<p>BFV的舍入是：</p>\n<p align=\"left\">在模t意义下，向整数添加噪声，再把“整数+小噪声”映射回同一个整数，只要噪声受控该过程就是之前操作的精确逆操作。</p>\n<p align=\"left\">CKKS的舍入是：</p>\n<p align=\"left\">把“连续实数”映射到最近的整数，再把整数映射回实数，该过程并不是之前操作的精确逆操作，所以产生“近似”。</p>\n<p>一句话：BFV里round用于“纠错”，CKKS里round用于“近似”。在SEAL中常用2^40，精度与噪声达到平衡。</p>\n<h2>1.3 噪声管理</h2>\n<p>在CKKS中，噪声管理主要依靠Rescaling（重缩放）机制，它配合RNS链，实现了对噪声的“阶梯式”精准控制。</p>\n<h3>1 CKKS噪声的组成部分</h3>\n<p>CKKS的噪声e并不是单一来源，它是由三部分叠加而成的：</p>\n<p><strong>初始噪声（e<sub>rlwe</sub>）：</strong>加密时引入的离散高斯噪声，用于保障安全性。</p>\n<p><strong>编码误差（e<sub>enc</sub>）：</strong>将浮点数缩放并舍入到整数多项式时参数的损失。</p>\n<p><strong>计算误差（e<sub>comp</sub>）：</strong>同态乘法和重线性化引入的噪声。</p>\n<p>在CKKS中，我们不区分“噪声”和“误差”。缩放因子Δ<span class=\"math-inline\">决定了明文的精度，而噪声只要不侵蚀到Δ<span class=\"math-inline\">定义的有效位，计算就是可靠的。</span></span></p>\n<h3><span class=\"math-inline\"><span class=\"math-inline\">2 核心机制：Rescaling（重缩放）</span></span></h3>\n<p><span class=\"math-inline\"><span class=\"math-inline\">当我们做一次同态乘法：(m<sub>1</sub>•Δ)x(m<sub>2</sub>•Δ) = (m<sub>1</sub>•m<sub>2</sub>)•Δ<sup>2</sup>，此时，缩放因子从Δ变成了Δ<sup>2</sup>，如果不处理，连续乘法会导致数值迅速爆炸，超出模数q的范围。此时将密文除于一个RNS素数q<sub>l</sub>（通常设q<sub>l</sub>∈Δ），并进行舍入：</span></span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260210175745316-581058742.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>结果：</p>\n<p>（1）缩放因子回归：Δ<sup>2</sup>/q<sub>l</sub>&nbsp;≈ Δ，有效位回到了正确的位置。</p>\n<p>（2）噪声同步缩减：原本的噪声e也被除于了q<sub>l</sub>，新噪声为：e/q<sub>l</sub>+舍入误差</p>\n<p>可见Rescaling不仅把膨胀的数值拉回来，同时顺手把增长的噪声也按比例缩小了。</p>\n<h3><span class=\"math-inline\"><span class=\"math-inline\">3 RNS链与层（Levels）的噪声控制</span></span></h3>\n<p><span class=\"math-inline\"><span class=\"math-inline\">在实际实现中，模数Q被分解为Q=q<sub>0</sub>•q<sub>1</sub>•...•q<sub>L</sub>，每一层计算都对应链中的一个素数。<br /></span></span></p>\n<p><img alt=\"image\" height=\"186\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260210181153276-276909400.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"469\" /></p>\n<p>&nbsp;以上每一层Rescaling都会吃掉总模数Q的约p比特（假设Δ=2<sup>p</sup>），当RNS链只剩下最后一个素数q<sub>0</sub>时，无法再进行Rescaling，此时再做乘法，噪声将无法被缩小，会迅速覆盖掉有效明文位。假设Q为600bit，Δ为40bit，Q能支撑约600/40=15层乘法，算到第15层时，模数只剩40bit左右，此时噪声和明文混在一起，无法再分。与BFV的区别：BFV的噪声管理是为了保住“整数的绝对准确”；CKKS的噪声管理是为了保住“浮点数的有效精度”。</p>\n<h1>2 CKKS标准流程划分</h1>\n<p>以SEAL库为例，完整流程分为5个阶段。</p>\n<h2>2.1 系统初始化与参数生成</h2>\n<p><strong>输入参数：</strong></p>\n<p>多项式模次数N（2的整数幂）</p>\n<p>模数链系数{q<sub>1</sub>,q<sub>2</sub>,...,q<sub>L</sub>}（递减序列，决定运算深度）</p>\n<p>缩放因子Δ=2<sup>k</sup>（控制计算精度）</p>\n<p>高斯噪声分布χ（RLWE基础噪声）</p>\n<p><strong>输出参数：</strong></p>\n<p>合法的SEAL上下文</p>\n<h2>2.2 密钥生成</h2>\n<p>基于RLWE问题生成密钥组，私钥绝对保密，公钥/辅助密钥可公开分发。</p>\n<p>（1）私钥sk</p>\n<p>随机采样小范数多项式：sk∈R<sub>2</sub>（系数仅为-1/0/1）</p>\n<p>（2）公钥<em>pk=(b,a)</em></p>\n<p>a：环上随机多项式</p>\n<p>b：b=-(a·sk + e)，其中e是高斯噪声多项式</p>\n<p>（3）重线性化密钥rlk</p>\n<p>&nbsp;用于密文乘法后的维度压缩，由私钥加密派生，服务器执行重线性化时使用。</p>\n<p>（4）旋转密钥rot_k（可选）</p>\n<p>用于密文槽位旋转，实现向量数据重排、求和等高阶运算。</p>\n<h2>2.3 编码与加密</h2>\n<h3><strong>步骤1 明文编码（浮点数/复数-&gt;多项式）</strong></h3>\n<p>该步会将实数/复数向量z∈C<sup>N/2</sup>转换为明文多项式。</p>\n<p>（1）构造对称向量（Symmetry Construction）</p>\n<p>在进行变换前，首先构造一个长度为N的向量Z：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260210103120361-1359664060.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>向量的后部部分是前半部分的共轭，这种对称性保证了下一步IFFT出来的多项式系数全部是实浮点数。</p>\n<p>（2）正则嵌入逆变换（IFFT）</p>\n<p>将长度为N的对称向量Z进行逆变换，得到一个多项式p(x)，其系数a<sub>i</sub>理论上应该是实数（由于浮点数计算精度问题，可能会有极小的虚部，通常直接舍弃）。</p>\n<p>（3）缩放与舍入（Scaling &amp; Rounding）</p>\n<p>对实浮点数系数进行操作：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260210103703414-337958342.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>由此得到了系数为实整数的多项式pt。</p>\n<p>以N=4为例，假设z=(3,4)，则首先对z进行扩展Z=(3,4,4,3)，因为3和4可以看作是虚部为零的复数，所以Z向量后半部分的共轭和前半部分完全相同。接下来目标是将Z映射为多项式p(x)=a<sub>0</sub>+a<sub>1</sub>x+a<sub>2</sub>x<sup>2</sup>+a<sub>3</sub>x<sup>3</sup>，即需要找到多项式的实系数a<sub>0</sub>，a<sub>1</sub>，a<sub>2</sub>，a<sub>3</sub>。在CKKS中，使用x<sup>4</sup>+1=0的单位根，它们是：ζ<sub>0</sub> = e<sup>iπ/4</sup>，ζ<sub>1</sub>&nbsp;= e<sup>i3π/4</sup>，ζ<sub>2</sub>&nbsp;= e<sup>i5π/4</sup>，ζ<sub>3</sub>&nbsp;= e<sup>i7π/4</sup>，ζ<sub>2</sub>和ζ<sub>3</sub>是ζ<sub>1</sub>和ζ<sub>0</sub>的共轭，则对于多项式p(x)满足：p(ζ<sub>0</sub>) = y<sub>0</sub> = 3，p(ζ<sub>1</sub>) = y<sub>1</sub> = 4，p(ζ<sub>2</sub>) = y<sub>2</sub> = 4，p(ζ<sub>3</sub>) = y<sub>3</sub> = 3，可以利用IFFT逆变换系数公式进行求解：</p>\n<p><img alt=\"image\" height=\"76\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260210120409880-138792570.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"178\" /></p>\n<p>依次计算各个系数：</p>\n<p><strong>计算a<sub>0</sub>：</strong></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260210120540550-839957814.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p><strong>计算a<sub>1</sub>：</strong></p>\n<p>由：</p>\n<p><img alt=\"image\" height=\"52\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260210124216470-303321074.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"627\" /></p>\n<p>可知：</p>\n<p><img alt=\"image\" height=\"68\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260210125922014-1456750365.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"766\" /></p>\n<p><strong>计算a<sub>2</sub>：</strong></p>\n<p>由于ζ<sub>0</sub><sup>-2</sup>&nbsp;= -i，ζ<sub>1</sub><sup>-2</sup>&nbsp;= i，ζ<sub>2</sub><sup>-2</sup>&nbsp;= -i，ζ<sub>3</sub><sup>-2</sup>&nbsp;= i，可知：</p>\n<p><img alt=\"image\" height=\"44\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260210123340956-1412279352.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"371\" /></p>\n<p><strong>计算a<sub>3</sub>：</strong></p>\n<p>由：</p>\n<p><img alt=\"image\" height=\"50\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260210140541152-203458374.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"628\" /></p>\n<p>可知：</p>\n<p><img alt=\"image\" height=\"70\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260210140632043-718239368.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"760\" /></p>\n<p>以上多项式系数的计算过程可以看到，系数中的虚部会因为共轭对称完全抵消，只剩实部，得到多项式是p(x)=3.5-0.3535x+0.3535x<sup>3</sup>，后续将在此多项式的基础上对齐系数进行放大及舍入完成编码流程。</p>\n<h3>步骤2 密文加密（明文-&gt;密文）</h3>\n<p>编码后的明文多项式pt被转换为一个包含两个多项式的密文对(c<sub>0</sub>,c<sub>1</sub>)：</p>\n<p><img alt=\"image\" height=\"116\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260210104930702-266110462.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"325\" /></p>\n<p>图中a，b是公钥对儿的两部分，u是小范数随机多项式，e<sub>0</sub>，e<sub>1</sub>是高斯噪声多项式，Q是密文大模数。</p>\n<h2>2.4 密文同态运算</h2>\n<p>支持加法、标量乘、密文乘、旋转、求和等运算，是CKKS的核心能力。</p>\n<h3>1 密文加法（同态加）</h3>\n<p>输入：两个同维度密文ct=(ct<sub>0</sub>,ct<sub>1</sub>)，ct'=(ct<sub>0</sub>',ct<sub>1</sub>')</p>\n<p>输出：ct<sub>add</sub>=(ct<sub>0</sub>+ct<sub>0</sub>',ct<sub>1</sub>+ct<sub>1</sub>')</p>\n<p>特性：无维度膨胀，无需重线性化，噪声线性叠加，运算后缩放因子保持不变。</p>\n<h3>2 密文乘法（同态乘）</h3>\n<p>原始乘法：两个二元组密文相乘，输出三元组密文ct<sub>mult</sub>=(c<sub>0</sub>,c<sub>1</sub>,c<sub>2</sub>)，其中c<sub>0</sub>=ct<sub>0</sub>•ct<sub>0</sub>'，c<sub>1</sub>=ct<sub>0</sub>•ct<sub>1</sub>'+ct<sub>1</sub>•ct<sub>0</sub>'，c<sub>2</sub>=ct<sub>1</sub>•ct<sub>1</sub>'。</p>\n<p>重线性化：使用重线性化密钥rlk，将三元组压缩回标准二元组，恢复密文结构</p>\n<p>重缩放：乘法后，缩放因子变成Δ<sup>2</sup>，为了防止数值爆炸，会将密文除于Δ并舍入</p>\n<p>模切换：降低模数，同步缩放数据，压缩噪声，保证后续运算可行性</p>\n<p>特性：噪声指数级增长，必须配合重线性化+模切换使用。</p>\n<h3>3 高阶运算</h3>\n<p align=\"left\">标量乘法：密文与公开常数相乘，无需密钥</p>\n<p align=\"left\">槽位旋转：移动单个槽位数据，配合旋转密钥使用</p>\n<p align=\"left\">槽位求和：批量数据聚合，适用于统计计算</p>\n<h2>2.5 解密与解码</h2>\n<h3>1 密文解密</h3>\n<p>输入：密文ct=(ct<sub>0</sub>,ct<sub>1</sub>)、私钥sk</p>\n<p>输出：解码前明文多项式</p>\n<p>解密公式：pt<sub>dec</sub> = ct<sub>0</sub> + ct<sub>1</sub>•sk = u•(-(a•sk + e<sub>pk</sub>))+e<sub>0</sub>+pt + (u•a+e<sub>1</sub>)•sk = pt + e<sub>0</sub> + e<sub>1</sub>•sk - u•e<sub>pk</sub>，最后部分可以看作是总噪声，则有：pt<sub>dec</sub> = pt + e<sub>total</sub>。</p>\n<h3>2 明文解码</h3>\n<p align=\"left\">（1）去除模数映射，将多项式转换为复数向量</p>\n<p align=\"left\">（2）除于缩放因子Δ，还原为原始尺度的浮点数</p>\n<p align=\"left\">（3）舍弃虚部（实数场景），得到最终计算结果</p>\n<h1>3 代码示例</h1>\n<p>以下是SEAL库CKKS同态加密方案示例代码：</p>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed\" id=\"code_img_closed_9af04663-7ada-4354-b3f4-bb029e2f6e7d\" src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" /><img class=\"code_img_opened\" id=\"code_img_opened_9af04663-7ada-4354-b3f4-bb029e2f6e7d\" src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_9af04663-7ada-4354-b3f4-bb029e2f6e7d\">\n<pre>#include <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">seal/seal.h</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n#include </span>&lt;iostream&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n#include </span>&lt;vector&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n#include </span>&lt;iomanip&gt;\n\n<span style=\"color: rgba(0, 0, 255, 1);\">using</span> <span style=\"color: rgba(0, 0, 255, 1);\">namespace</span><span style=\"color: rgba(0, 0, 0, 1);\"> seal;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">using</span> <span style=\"color: rgba(0, 0, 255, 1);\">namespace</span><span style=\"color: rgba(0, 0, 0, 1);\"> std;\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 工具函数：打印浮点向量，格式化输出结果</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">void</span> print_vector(<span style=\"color: rgba(0, 0, 255, 1);\">const</span> vector&lt;<span style=\"color: rgba(0, 0, 255, 1);\">double</span>&gt;&amp; vec, <span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span>&amp; title, size_t print_size = <span style=\"color: rgba(128, 0, 128, 1);\">5</span><span style=\"color: rgba(0, 0, 0, 1);\">) {\n    cout </span>&lt;&lt; title &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n    size_t limit </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> min(print_size, vec.size());\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> (size_t i = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; i &lt; limit; ++<span style=\"color: rgba(0, 0, 0, 1);\">i) {\n        cout </span>&lt;&lt; <span style=\"color: rgba(0, 0, 255, 1);\">fixed</span> &lt;&lt; setprecision(<span style=\"color: rgba(128, 0, 128, 1);\">3</span>) &lt;&lt; vec[i] &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span> <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n    }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (vec.size() &gt; limit) cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">...</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n    cout </span>&lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n}\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> main() {\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> ===================== 1. CKKS 方案参数配置 =====================\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 多项式模次数：决定安全等级、槽位数量、计算性能，必须是2的幂</span>\n    size_t poly_modulus_degree = <span style=\"color: rgba(128, 0, 128, 1);\">8192</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n    EncryptionParameters </span><span style=\"color: rgba(0, 0, 255, 1);\">params</span><span style=\"color: rgba(0, 0, 0, 1);\">(scheme_type::ckks);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">params</span><span style=\"color: rgba(0, 0, 0, 1);\">.set_poly_modulus_degree(poly_modulus_degree);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 配置系数模数链：CKKS核心，通过模切换控制噪声和计算深度\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 60, 40, 40, 60 表示模数链分段，支持2层乘法运算</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">params</span><span style=\"color: rgba(0, 0, 0, 1);\">.set_coeff_modulus(CoeffModulus::Create(\n        poly_modulus_degree, { </span><span style=\"color: rgba(128, 0, 128, 1);\">60</span>, <span style=\"color: rgba(128, 0, 128, 1);\">40</span>, <span style=\"color: rgba(128, 0, 128, 1);\">40</span>, <span style=\"color: rgba(128, 0, 128, 1);\">60</span><span style=\"color: rgba(0, 0, 0, 1);\"> }\n    ));\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 初始化SEAL上下文，验证参数合法性</span>\n    SEALContext context(<span style=\"color: rgba(0, 0, 255, 1);\">params</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    cout </span>&lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">SEAL CKKS 参数初始化完成，多项式模次数: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; poly_modulus_degree &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n    cout </span>&lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">可用槽位数量（单密文可打包数据量）: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>\n        &lt;&lt; context.get_context_data(context.first_parms_id())-&gt;parms().poly_modulus_degree() / <span style=\"color: rgba(128, 0, 128, 1);\">2</span> &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> ===================== 2. 密钥生成 =====================\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 密钥生成器：基于上下文生成公私钥、重线性化密钥</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    KeyGenerator keygen(context);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 私钥（核心机密，仅客户端持有）</span>\n    SecretKey secret_key =<span style=\"color: rgba(0, 0, 0, 1);\"> keygen.secret_key();\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 公钥（公开分发，用于加密）</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    PublicKey public_key;\n    keygen.create_public_key(public_key);\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 重线性化密钥（密文乘法后压缩密文维度，必需）</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    RelinKeys relin_keys;\n    keygen.create_relin_keys(relin_keys);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> ===================== 3. 核心组件初始化 =====================\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 加密器：使用公钥加密明文</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    Encryptor encryptor(context, public_key, secret_key);\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 解密器：使用私钥解密密文</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    Decryptor decryptor(context, secret_key);\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> CKKS编码器：实现浮点数 ↔ 明文多项式 转换</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    CKKSEncoder encoder(context);\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 同态运算器：执行密文加减乘、重线性化等操作</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    Evaluator evaluator(context);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 缩放因子：CKKS用于控制浮点计算精度的核心参数</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">double</span> scale = pow(<span style=\"color: rgba(128, 0, 128, 1);\">2.0</span>, <span style=\"color: rgba(128, 0, 128, 1);\">40</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    cout </span>&lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">CKKS 缩放因子: 2^40</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; endl &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> ===================== 4. 构造明文浮点向量 =====================</span>\n    vector&lt;<span style=\"color: rgba(0, 0, 255, 1);\">double</span>&gt; x = { <span style=\"color: rgba(128, 0, 128, 1);\">1.1</span>, <span style=\"color: rgba(128, 0, 128, 1);\">2.2</span>, <span style=\"color: rgba(128, 0, 128, 1);\">3.3</span>, <span style=\"color: rgba(128, 0, 128, 1);\">4.4</span><span style=\"color: rgba(0, 0, 0, 1);\"> };\n    vector</span>&lt;<span style=\"color: rgba(0, 0, 255, 1);\">double</span>&gt; y = { <span style=\"color: rgba(128, 0, 128, 1);\">5.5</span>, <span style=\"color: rgba(128, 0, 128, 1);\">6.6</span>, <span style=\"color: rgba(128, 0, 128, 1);\">7.7</span>, <span style=\"color: rgba(128, 0, 128, 1);\">8.8</span><span style=\"color: rgba(0, 0, 0, 1);\"> };\n    print_vector(x, </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">原始向量 x</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    print_vector(y, </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">原始向量 y</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> ===================== 5. 明文编码 + 加密 =====================</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    Plaintext plain_x, plain_y;\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 将浮点向量编码为CKKS明文格式，指定缩放因子</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    encoder.encode(x, scale, plain_x);\n    encoder.encode(y, scale, plain_y);\n\n    Ciphertext cipher_x, cipher_y;\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 加密明文为密文</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    encryptor.encrypt(plain_x, cipher_x);\n    encryptor.encrypt(plain_y, cipher_y);\n    cout </span>&lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\\n明文编码、加密完成，密文x数据大小: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; cipher_x.size() &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> ===================== 6. 密文同态运算 =====================\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 6.1 密文加法：cipher_add = x + y</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    Ciphertext cipher_add;\n    evaluator.add(cipher_x, cipher_y, cipher_add);\n    cout </span>&lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">密文加法运算完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 6.2 密文乘法：cipher_mult = x * y</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    Ciphertext cipher_mult;\n    evaluator.multiply(cipher_x, cipher_y, cipher_mult);\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 乘法后密文维度膨胀，执行重线性化压缩回标准格式</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    evaluator.relinearize_inplace(cipher_mult, relin_keys);\n    cout </span>&lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">密文乘法 + 重线性化完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> ===================== 7. 密文解密 + 解码 =====================</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    Plaintext plain_add_result, plain_mult_result;\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 解密运算结果密文</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    decryptor.decrypt(cipher_add, plain_add_result);\n    decryptor.decrypt(cipher_mult, plain_mult_result);\n\n    vector</span>&lt;<span style=\"color: rgba(0, 0, 255, 1);\">double</span>&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> result_add, result_mult;\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 解码为浮点向量</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    encoder.decode(plain_add_result, result_add);\n    encoder.decode(plain_mult_result, result_mult);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> ===================== 8. 结果输出 =====================</span>\n    cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\\n==================== 运算结果对比 ====================</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n    print_vector(result_add, </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">密文加法解密结果</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    print_vector(result_mult, </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">密文乘法解密结果</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 计算明文基准值用于对比</span>\n    vector&lt;<span style=\"color: rgba(0, 0, 255, 1);\">double</span>&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> true_add, true_mult;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> (size_t i = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; i &lt; x.size(); ++<span style=\"color: rgba(0, 0, 0, 1);\">i) {\n        true_add.push_back(x[i] </span>+<span style=\"color: rgba(0, 0, 0, 1);\"> y[i]);\n        true_mult.push_back(x[i] </span>*<span style=\"color: rgba(0, 0, 0, 1);\"> y[i]);\n    }\n    print_vector(true_add, </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">明文加法基准值</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    print_vector(true_mult, </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">明文乘法基准值</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n}</span></pre>\n</div>\n<span class=\"cnblogs_code_collapse\">CKKS</span></div>\n<p>代码运行效果如下：</p>\n<p><img alt=\"image\" height=\"272\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260210171421384-92773903.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"483\" /></p>\n<p>&nbsp;</p>\n<h1>4 参考</h1>\n<p>1&nbsp;<a href=\"https://zhuanlan.zhihu.com/p/366965077\" rel=\"noopener nofollow\" target=\"_blank\">https://zhuanlan.zhihu.com/p/366965077</a></p>\n<p>2&nbsp;<a href=\"https://blog.csdn.net/WaitMrAnt/article/details/140950613\" rel=\"noopener nofollow\" target=\"_blank\">https://blog.csdn.net/WaitMrAnt/article/details/140950613</a></p>\n<p>3&nbsp;<a href=\"https://zhuanlan.zhihu.com/p/619856459\" rel=\"noopener nofollow\" target=\"_blank\">https://zhuanlan.zhihu.com/p/619856459</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-10 18:21</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zhaoweiwei\">weiwei22844</a>&nbsp;\n阅读(<span id=\"post_view_count\">11</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Avalonia.Controls.DataGrid自动合并列",
      "link": "https://www.cnblogs.com/kevin-Y/p/19600957",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/kevin-Y/p/19600957\" id=\"cb_post_title_url\" title=\"发布于 2026-02-10 17:59\">\n    <span>Avalonia.Controls.DataGrid自动合并列</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>Winform在用的DataGridView修改为通过线条和透明的方式实现了合并列的效果。一段时间也在留意Avalonia.Controls.DataGrid是否也有类似的做法。一直没有心思去看那些代码，水平有限，实在搞不懂XML/Content一类如何实现绘制内容的。借着AI的帮助终于能试着去修改了。</p>\n<p>让AI从DataGrid的以下方法入手</p>\n<div class=\"cnblogs_code\">\n<pre>        <span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> AddNewCellPrivate(DataGridRow row, DataGridColumn column)\n        {\n            DataGridCell newCell </span>= <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> DataGridCell();\n            PopulateCellContent(\n                isCellEdited: </span><span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                dataGridColumn: column,\n                dataGridRow: row,\n                dataGridCell: newCell);\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (row.OwningGrid != <span style=\"color: rgba(0, 0, 255, 1);\">null</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n            {\n                newCell.OwningColumn </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> column;\n                newCell.IsVisible </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> column.IsVisible;\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (row.OwningGrid.CellTheme <span style=\"color: rgba(0, 0, 255, 1);\">is</span><span style=\"color: rgba(0, 0, 0, 1);\"> {} cellTheme)\n                {\n                    newCell.SetValue(ThemeProperty, cellTheme, BindingPriority.Template);\n                }\n            }\n            row.Cells.Insert(column.Index, newCell);\n            \n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 智能AutoMerge逻辑：比较当前行和下一行的数据\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">ApplySmartAutoMerge(row, column, newCell);</span>\n        }</pre>\n</div>\n<p>最后发现，DataGrid并没有为每行数据创建DataGridRow/DataGridCell，且还会复用这些创建出来的DataGridCell显其他行的数据。就是说上面的方法只是开始的显示内容是可预测的。</p>\n<p>多次尝试后，发现绘制前都会调用DataGridCell的EnsureGridLine方法，于是将合并的代码主要放在其中</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> EnsureGridLine(DataGridColumn lastVisibleColumn)\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (OwningGrid != <span style=\"color: rgba(0, 0, 255, 1);\">null</span> &amp;&amp; _rightGridLine != <span style=\"color: rgba(0, 0, 255, 1);\">null</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (OwningGrid.VerticalGridLinesBrush != <span style=\"color: rgba(0, 0, 255, 1);\">null</span> &amp;&amp; OwningGrid.VerticalGridLinesBrush !=<span style=\"color: rgba(0, 0, 0, 1);\"> _rightGridLine.Fill)\n        {\n            _rightGridLine.Fill </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> OwningGrid.VerticalGridLinesBrush;\n        }\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">忽略其他代码<br />    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 调用DataGrid的CheckCellToMerge方法</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">var</span> (isSameAsPrevious, isSameAsNext) = OwningGrid?.CheckCellToMerge(<span style=\"color: rgba(0, 0, 255, 1);\">this</span>) ?? (<span style=\"color: rgba(0, 0, 255, 1);\">false</span>, <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">);    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 根据不同的组合情况处理底边框和透明度</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    HandleMergeResult(isSameAsPrevious, isSameAsNext);\n}</span></pre>\n</div>\n<p>至此，DataGrid决定如何合并，返回当前行与上一行和下一行的数据是否可以合并（现在只是简单的比较当前列的内容是否一致）。</p>\n<p><img alt=\"simplemerge\" height=\"551\" src=\"https://img2024.cnblogs.com/blog/12683/202602/12683-20260210174136165-1383757098.png\" width=\"704\" /></p>\n<p>有一个小小的问题，在滚动时合并列可能会显示空白。虽说在用的winform版的datagridview也有这个小问题。但新的东西多少有点改进，对吧。于是我向AI发出要求。最大的帮助就是判断是否是当前显示的第一列的方法了。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;summary&gt;</span>\n<span style=\"color: rgba(128, 128, 128, 1);\">///</span><span style=\"color: rgba(0, 128, 0, 1);\"> 判断指定行是否为可视区域的第一行\n</span><span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;/summary&gt;</span>\n<span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;param name=\"row\"&gt;</span><span style=\"color: rgba(0, 128, 0, 1);\">要检查的行</span><span style=\"color: rgba(128, 128, 128, 1);\">&lt;/param&gt;</span>\n<span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;returns&gt;</span><span style=\"color: rgba(0, 128, 0, 1);\">true表示是可视区域的第一行，false表示不是</span><span style=\"color: rgba(128, 128, 128, 1);\">&lt;/returns&gt;</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">bool</span><span style=\"color: rgba(0, 0, 0, 1);\"> IsFirstVisibleRow(DataGridRow row)\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (_rowsPresenter == <span style=\"color: rgba(0, 0, 255, 1);\">null</span> || row == <span style=\"color: rgba(0, 0, 255, 1);\">null</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 遍历可视区域的所有行，找到索引最小的行</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">int</span> firstVisibleRowIndex = <span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\">.MaxValue;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (Control element <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> _rowsPresenter.Children)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (element <span style=\"color: rgba(0, 0, 255, 1);\">is</span> DataGridRow visibleRow &amp;&amp;<span style=\"color: rgba(0, 0, 0, 1);\"> visibleRow.IsVisible)\n        {\n            firstVisibleRowIndex </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> Math.Min(firstVisibleRowIndex, visibleRow.Index);\n        }\n    }\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 如果指定行索引等于可视区域最小索引，则为第一行</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">return</span> row.Index ==<span style=\"color: rgba(0, 0, 0, 1);\"> firstVisibleRowIndex;\n}</span></pre>\n</div>\n<p>人工分析后发现，DataGridCell的EnsureGridLine不知为何只是lastVisibleColumn有调用，并不是行中的全部列。滚动的刷新由DataGridCellsPresenter发起，看以下方法</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> EnsureFillerVisibility()\n{\n    DataGridFillerColumn fillerColumn </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> OwningGrid.ColumnsInternal.FillerColumn;\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">忽略其他代码\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> This must be done after the Filler visibility is determined.  This also must be done\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> regardless of whether or not the filler visibility actually changed values because\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> we could scroll in a cell that didn't have EnsureGridLine called yet</span>\n    DataGridColumn lastVisibleColumn =<span style=\"color: rgba(0, 0, 0, 1);\"> OwningGrid.ColumnsInternal.LastVisibleColumn;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (lastVisibleColumn != <span style=\"color: rgba(0, 0, 255, 1);\">null</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        DataGridCell cell </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> OwningRow.Cells[lastVisibleColumn.Index];\n        cell.EnsureGridLine(lastVisibleColumn);</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">不知道为什么只是最后一列需要执行。</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    }\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 检查是否为首行显示，如果是则清除合并单元格的透明度</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">bool</span> isFirstVisualRow = (OwningGrid?.IsFirstVisibleRow(OwningRow) == <span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (DataGridCell cell <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> OwningRow.Cells)\n    {\n        cell</span>?.ClearMergeOpacity(isFirstVisualRow);<span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">否的时候，可能需要恢复透明度</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    }\n}</span></pre>\n</div>\n<p>好了，这就是全部修改。代码在gitee</p>\n<p><a href=\"https://gitee.com/kevin2y/Avalonia.Controls.DataGrid/tree/feature/auto-merge-enhancement\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/kevin2y/Avalonia.Controls.DataGrid/tree/feature/auto-merge-enhancement</a></p>\n<p>&nbsp;</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-10 17:59</span>&nbsp;\n<a href=\"https://www.cnblogs.com/kevin-Y\">生命体验之kevin-Y</a>&nbsp;\n阅读(<span id=\"post_view_count\">30</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "记录一次bug：不可见字符/零宽字符",
      "link": "https://www.cnblogs.com/Az1r/p/19600679",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Az1r/p/19600679\" id=\"cb_post_title_url\" title=\"发布于 2026-02-10 16:59\">\n    <span>记录一次bug：不可见字符/零宽字符</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h3 id=\"1-现象\">1. 现象</h3>\n<p>在处理 CSV 文件导入时，你可能遇到过这种“灵异事件”：</p>\n<ul>\n<li>CSV 文件第一列叫 <code>tag_id</code>。</li>\n<li>程序用 <code>encoding/csv</code> 读进 Map 后，尝试用 <code>mp[\"tag_id\"]</code> 取值。</li>\n<li>结果： 永远返回空值，但打印整个 Map 时，肉眼看 Key 确实是 <code>tag_id</code>。</li>\n<li>而这其实是你遇到了<strong>零宽字符</strong>： 【ZWNBSP】。</li>\n</ul>\n<details>\n点击查看代码\n<pre><code>package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/csv\"\n\t\"fmt\"\n\t\"strings\"\n\t\"unicode\"\n)\n\n/*\n  [模拟 CSV 表格结构]\n  文件编码: UTF-8 with BOM (字节流开头包含 \\xef\\xbb\\xbf)\n\n  |  列名 (Header)   |  数据 (Row 1)  |\n  |-----------------|---------------|\n  | [ZWNBSP]tag_id  |      1        |\n  |      name       |    Popular    |\n\n  注：[ZWNBSP] 在编辑器和 Excel 中完全不可见，但在内存中占 3 个字节。\n*/\n\nfunc main() {\n\t// 1. 模拟 CSV 内容：手动在开头加入 UTF-8 BOM (\\xef\\xbb\\xbf)\n\tcontent := \"\\xef\\xbb\\xbf\" + \"tag_id,name\\n1,Gemini\"\n\n\t// 2. 解析 CSV\n\treader := csv.NewReader(bytes.NewBufferString(content))\n\trecords, _ := reader.ReadAll()\n\n\t// 3. 构建 Map\n\theader := records[0]\n\trow := records[1]\n\tmp := make(map[string]string)\n\tfor i, colName := range header {\n\t\tmp[colName] = row[i]\n\t}\n\n\t// 4. 尝试通过标准字符串 Key 读取\n\ttargetKey := \"tag_id\"\n\tval, exists := mp[targetKey]\n\n\t/*\n\t   [预计打印结果]\n\n\t   --- 结果演示 ---\n\t   直接打印 Map: map[tag_id:1 name:Gemini]  &lt;-- 肉眼看完全正常\n\t   尝试读取 Key [tag_id]: 成功? false, 值:     &lt;-- 实际上找不到，因为多出来的 3 字节在作祟\n\n\t   --- 真相揭秘 (十六进制对比) ---\n\t   Map 里的 Key (Hex): efbbbf7461675f6964  &lt;-- 前面多出了 efbbbf (ZWNBSP)\n\t   代码里的 Key (Hex): 7461675f6964        &lt;-- 纯净的 tag_id\n\t*/\n\n\tfmt.Println(\"--- 结果演示 ---\")\n\tfmt.Printf(\"直接打印 Map: %v\\n\", mp)\n\tfmt.Printf(\"尝试读取 Key [%s]: 成功? %v, 值: %s\\n\", targetKey, exists, val)\n\n\tfmt.Println(\"\\n--- 真相揭秘 (十六进制对比) ---\")\n\tfor k := range mp {\n\t\tif strings.Contains(k, \"tag_id\") {\n\t\t\tfmt.Printf(\"Map 里的 Key (Hex): %x\\n\", k)\n\t\t\tfmt.Printf(\"代码里的 Key (Hex): %x\\n\", targetKey)\n\t\t}\n\t}\n\n\t// 5. 使用清洗函数修复\n\tfmt.Println(\"\\n--- 修复后尝试 ---\")\n\tcleanMp := make(map[string]string)\n\tfor i, colName := range header {\n\t\tcleanMp[CleanString(colName)] = row[i]\n\t}\n\t_, existsNow := cleanMp[targetKey]\n\tfmt.Printf(\"清洗后读取 Key [%s]: 成功? %v\\n\", targetKey, existsNow)\n}\n\n// CleanString 是处理 CSV 列名的“强力去污剂”\nfunc CleanString(s string) string {\n\t// 移除 BOM 前缀并剔除所有不可见字符\n\treturn strings.Map(func(r rune) rune {\n\t\tif unicode.IsGraphic(r) {\n\t\t\treturn r\n\t\t}\n\t\treturn -1\n\t}, strings.TrimPrefix(s, \"\\xef\\xbb\\xbf\"))\n}\n</code></pre>\n</details>\n<p>零宽字符 = 看不见的字符,但它真的在文本里。</p>\n<h3 id=\"2-分析\">2. 分析</h3>\n<h4 id=\"为什么会有这种字符\"><strong>为什么会有这种字符？</strong></h4>\n<p>这类问题通常由 <strong>BOM (Byte Order Mark)</strong> 引起。</p>\n<ul>\n<li>\n<p><strong>来源：</strong> 当你使用 Windows Excel 另存为 UTF-8 格式时，或飞书表格保存为csv文件时，Excel 会在文件最开头自动添加 <code>0xEF 0xBB 0xBF</code> 三个字节。</p>\n</li>\n<li>\n<p><strong>本质：</strong> 在 Unicode 中，这被称为 <strong>ZWNBSP</strong>（Zero Width No-Break Space，零宽不换行空格，<code>U+FEFF</code>）。它的设计初衷是标记字节序，但在现代 UTF-8 环境下，它往往变成了“数据杂质”。</p>\n</li>\n</ul>\n<h4 id=\"为什么-go-无法匹配\"><strong>为什么 Go 无法匹配？</strong></h4>\n<p>Go 的 <code>map[string]string</code> 查找是基于<strong>字节流</strong>的精确匹配。</p>\n<ul>\n<li>\n<p><strong>预期 Key：</strong> <code>[116 97 103 95 105 100]</code> (即 <code>tag_id</code>)</p>\n</li>\n<li>\n<p><strong>实际的 Key：</strong> <code>[239 187 191 116 97 103 95 105 100]</code> (即 <code>\\ufefftag_id</code>)</p>\n</li>\n</ul>\n<p>常见的零宽字符：</p>\n<table>\n<thead>\n<tr>\n<th><strong>名称</strong></th>\n<th><strong>Unicode</strong></th>\n<th><strong>作用说明</strong></th>\n<th><strong>对程序的干扰</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>零宽无断行空格 (ZWNBSP/BOM)</strong></td>\n<td><code>\\uFEFF</code></td>\n<td>防止自动换行；在文件头作为 BOM 标记编码</td>\n<td><strong>最常见</strong>。导致 CSV 首列 Key 无法读取。</td>\n</tr>\n<tr>\n<td><strong>零宽空格 (ZWSP)</strong></td>\n<td><code>\\u200B</code></td>\n<td>用于分隔长单词以便在必要时换行</td>\n<td>插入在字符串中间，导致 <code>len()</code> 长度增加。</td>\n</tr>\n<tr>\n<td><strong>零宽连接符 (ZWJ)</strong></td>\n<td><code>\\u200D</code></td>\n<td>用于组合多个 Emoji（如 👨‍👩‍👧）或复杂文字</td>\n<td>强行过滤会导致组合 Emoji 被拆解。</td>\n</tr>\n<tr>\n<td><strong>零宽非连接符 (ZWNJ)</strong></td>\n<td><code>\\u200C</code></td>\n<td>打断字符连写（常见于阿拉伯语、印度文）</td>\n<td>改变文本的二进制表示。</td>\n</tr>\n<tr>\n<td><strong>左右文字方向符 (LRM/RLM)</strong></td>\n<td><code>\\u200E</code> / <code>\\u200F</code></td>\n<td>混合排版时控制文字从左往右或从右往左</td>\n<td>导致字符串比较逻辑失效。</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h3 id=\"3-解决\">3. 解决</h3>\n<pre><code>package main\n\nimport (\n\t\"regexp\"\n)\n\n// 用正则匹配常见的零宽字符区间\nvar reZeroWidth = regexp.MustCompile(`[\\u200B-\\u200D\\uFEFF\\u200E\\u200F]`)\n\nfunc SafeClean(s string) string {\n\treturn reZeroWidth.ReplaceAllString(strings.TrimSpace(s), \"\")\n}\n</code></pre>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/Az1r/\" target=\"_blank\">江水为竭</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/Az1r/p/19600679\" target=\"_blank\">https://www.cnblogs.com/Az1r/p/19600679</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-10 16:59</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Az1r\">江水为竭</a>&nbsp;\n阅读(<span id=\"post_view_count\">115</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一天一个Python库：wheel - Python 打包的轮子，高效分发利器",
      "link": "https://www.cnblogs.com/min2k/p/19600605",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/min2k/p/19600605\" id=\"cb_post_title_url\" title=\"发布于 2026-02-10 16:36\">\n    <span>一天一个Python库：wheel - Python 打包的轮子，高效分发利器</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"wheel---python-打包的轮子高效分发利器\">wheel - Python 打包的轮子，高效分发利器</h1>\n<h2 id=\"一什么是wheel\">一、什么是wheel？</h2>\n<p><strong>wheel</strong> 是一个用于 Python 分发包的标准格式和工具的 Python 库。<br />\n它可以帮助你：</p>\n<ul>\n<li>创建 <code>.whl</code> 文件，这是一种即装即用的分发格式。</li>\n<li>实现更快速、更可靠的包安装。</li>\n<li>避免在安装过程中进行源代码编译，从而简化依赖管理。</li>\n<li>确保不同系统间的二进制兼容性（在某些情况下）。</li>\n</ul>\n<h2 id=\"二应用场景\">二、应用场景</h2>\n<p><strong>wheel</strong> 广泛应用于以下实际场景：</p>\n<ul>\n<li><strong>快速部署</strong>: 当你需要将一个 Python 应用或库快速部署到多个环境中时，<code>wheel</code> 文件可以显著加快安装速度。</li>\n<li><strong>构建私有 PyPI</strong>: 如果你在企业内部维护一个私有的 PyPI 仓库，通常会将内部库打包成 <code>wheel</code> 文件以便于员工安装。</li>\n<li><strong>持续集成/持续部署 (CI/CD)</strong>: 在 CI/CD 管道中，生成和分发 <code>wheel</code> 文件是部署 Python 项目的常见步骤，可以提高构建效率。</li>\n<li><strong>跨平台分发</strong>: 对于包含 C 扩展的 Python 库，<code>wheel</code> 可以预编译这些扩展，避免用户在安装时进行编译，减少安装失败的可能性。</li>\n</ul>\n<h2 id=\"三如何安装\">三、如何安装</h2>\n<ol>\n<li>使用 pip 安装</li>\n</ol>\n<pre><code class=\"language-bash\">pip install wheel\n\n# 如果安装慢的话，推荐使用国内镜像源\npip install wheel -i https://www.python64.cn/pypi/simple/\n</code></pre>\n<ol start=\"2\">\n<li>使用 <a href=\"https://www.min2k.com/tools/python-run/\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a> 在线运行代码（无需本地安装）</li>\n</ol>\n<h2 id=\"四示例代码\">四、示例代码</h2>\n<p>检查 wheel 包是否可用，并演示如何创建一个简单的 wheel 文件（概念性）。</p>\n<pre><code class=\"language-python\">import os\nimport subprocess\n\n# 检查当前Python环境是否安装了wheel\ntry:\n    import wheel\n    wheel_installed = True\nexcept ImportError:\n    wheel_installed = False\n\nif wheel_installed:\n    print(\"Wheel is installed and ready to use.\")\n    # 实际创建 wheel 文件需要一个 setuptools 项目结构\n    # 这里我们只模拟一个简单的检查，不实际构建复杂的wheel\n    print(\"To build a wheel, you typically use 'python setup.py bdist_wheel'.\")\n\n    # 简单条件判断：如果安装了，就提示用户\n    if wheel.__version__:\n        print(f\"Wheel version: {wheel.__version__}\")\n    else:\n        print(\"Could not determine wheel version.\")\n\nelse:\n    print(\"Wheel is not installed. Please install it using 'pip install wheel'.\")\n\n</code></pre>\n<p>使用 <a href=\"https://www.min2k.com/tools/python-run/?code=import%20os%0Aimport%20subprocess%0A%0A%23%20%E6%A3%80%E6%9F%A5%E5%BD%93%E5%89%8DPython%E7%8E%AF%E5%A2%83%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E4%BA%86wheel%0Atry%3A%0A%20%20%20%20import%20wheel%0A%20%20%20%20wheel_installed%20%3D%20True%0Aexcept%20ImportError%3A%0A%20%20%20%20wheel_installed%20%3D%20False%0A%0Aif%20wheel_installed%3A%0A%20%20%20%20print%28%22Wheel%20is%20installed%20and%20ready%20to%20use.%22%29%0A%20%20%20%20%23%20%E5%AE%9E%E9%99%85%E5%88%9B%E5%BB%BA%20wheel%20%E6%96%87%E4%BB%B6%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AA%20setuptools%20%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%0A%20%20%20%20%23%20%E8%BF%99%E9%87%8C%E6%88%91%E4%BB%AC%E5%8F%AA%E6%A8%A1%E6%8B%9F%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%A3%80%E6%9F%A5%EF%BC%8C%E4%B8%8D%E5%AE%9E%E9%99%85%E6%9E%84%E5%BB%BA%E5%A4%8D%E6%9D%82%E7%9A%84wheel%0A%20%20%20%20print%28%22To%20build%20a%20wheel%2C%20you%20typically%20use%20'python%20setup.py%20bdist_wheel'.%22%29%0A%0A%20%20%20%20%23%20%E7%AE%80%E5%8D%95%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%EF%BC%9A%E5%A6%82%E6%9E%9C%E5%AE%89%E8%A3%85%E4%BA%86%EF%BC%8C%E5%B0%B1%E6%8F%90%E7%A4%BA%E7%94%A8%E6%88%B7%0A%20%20%20%20if%20wheel.__version__%3A%0A%20%20%20%20%20%20%20%20print%28f%22Wheel%20version%3A%20%7Bwheel.__version__%7D%22%29%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20print%28%22Could%20not%20determine%20wheel%20version.%22%29%0A%0Aelse%3A%0A%20%20%20%20print%28%22Wheel%20is%20not%20installed.%20Please%20install%20it%20using%20'pip%20install%20wheel'.%22%29%0A\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a> 在线运行这段代码，结果如下：</p>\n<pre><code class=\"language-text\">Wheel is installed and ready to use.\nTo build a wheel, you typically use 'python setup.py bdist_wheel'.\nWheel version: 0.38.4\n</code></pre>\n<p>使用 <a href=\"https://www.min2k.com/tools/mermaid/?code=flowchart%20TB%0A%20%20start%28%28Start%29%29%20--%3E%20A%7BImport%20wheel%20module%3F%7D%3B%0A%20%20A%20--%20Yes%20--%3E%20B%5BSet%20wheel_installed%20%3D%20True%5D%3B%0A%20%20A%20--%20No%20--%3E%20C%5BSet%20wheel_installed%20%3D%20False%5D%3B%0A%20%20B%20--%3E%20D%7BIs%20wheel_installed%20True%3F%7D%3B%0A%20%20C%20--%3E%20D%3B%0A%20%20D%20--%20Yes%20--%3E%20E%5BPrint%20%22Wheel%20is%20installed...%22%5D%3B%0A%20%20E%20--%3E%20F%5BPrint%20building%20instruction%5D%3B%0A%20%20F%20--%3E%20G%7Bwheel.__version__%20exists%3F%7D%3B%0A%20%20G%20--%20Yes%20--%3E%20H%5BPrint%20wheel%20version%5D%3B%0A%20%20G%20--%20No%20--%3E%20I%5BPrint%20%22Could%20not%20determine%20version%22%5D%3B%0A%20%20D%20--%20No%20--%3E%20J%5BPrint%20%22Wheel%20is%20not%20installed...%22%5D%3B%0A%20%20H%20--%3E%20end%28%28End%29%29%3B%0A%20%20I%20--%3E%20end%3B%0A%20%20J%20--%3E%20end%3B\" rel=\"noopener nofollow\" target=\"_blank\">MermaidGo</a> 绘制示例代码的流程图，结果如下：</p>\n<p><img alt=\"MermerGo的wheel流程图\" class=\"lazyload\" /></p>\n<h2 id=\"五学习资源\">五、学习资源</h2>\n<ol>\n<li>开源项目：<a href=\"https://github.com/pypa/wheel\" rel=\"noopener nofollow\" target=\"_blank\">wheel</a></li>\n<li>中文自述：<a href=\"https://www.python64.cn/readme/wheel/\" rel=\"noopener nofollow\" target=\"_blank\">REMDME</a></li>\n<li>在线运行：<a href=\"https://www.min2k.com/tools/python-run/\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a></li>\n</ol>\n<blockquote>\n<p>如果这篇文章对你有帮助，欢迎点赞、收藏、转发！<br />\n学习过程中有任何问题，欢迎在评论区留言交流～</p>\n</blockquote>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-10 16:36</span>&nbsp;\n<a href=\"https://www.cnblogs.com/min2k\">敏编程</a>&nbsp;\n阅读(<span id=\"post_view_count\">32</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "KMP模式匹配算法——详细讲解、清晰易懂",
      "link": "https://www.cnblogs.com/CodingCat-jiumi/p/19555666",
      "published": "",
      "description": "<h2>\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/CodingCat-jiumi/p/19555666\" id=\"cb_post_title_url\" title=\"发布于 2026-02-10 16:30\">\n    <span>KMP模式匹配算法——详细讲解、清晰易懂</span>\n    \n\n</a>\n\n\t\t</h2>\n\t\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        KMP算法是由D.E. Knuth、J.H. Morris和V.R. Pratt(其中Knuth和Pratt共同研究, Mor-ris独立研究)发表一个模式匹配算法，KMP算法的最大特点使得它在处理大量文本匹配的问题时，比暴力枚举算法有更好的性能。\n关于字符串匹配，是字符串很重要的知识点，也是面试笔试的高频考点。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"kmp算法介绍\">KMP算法介绍</h2>\n<p>KMP算法是由D.E. Knuth、J.H. Morris和V.R. Pratt(其中Knuth和Pratt共同研究,  Mor-ris独立研究)发表一个模式匹配算法，KMP算法的最大特点使得它在处理大量文本匹配的问题时，比暴力枚举算法有更好的性能。</p>\n<p>关于字符串匹配，是字符串很重要的知识点，也是面试笔试的高频考点。Leetcode的第28题就是考查字符串匹配算法。另外本文是查看了《大话数据结构》这本书做的总结，同时next数组部分也参考了这篇博客<a href=\"https://blog.csdn.net/gmynebula/article/details/125239503\" rel=\"noopener nofollow\" target=\"_blank\">KMP算法中next数组的计算</a>。</p>\n<p>KMP是由基础的字符串匹配BF算法改进而来的</p>\n<h2 id=\"kmp模式匹配算法原理\">KMP模式匹配算法原理</h2>\n<p>目标串（主串） S = \"heloohello\", 模式串（子串） T = \"hello\"。我们要从主串 S 中找到子串 T 的位置。如果使用BF算法，步骤如下图所示。</p>\n<div align=\"center\">\n<img class=\"lazyload\" width=\"60%\" />\n</div>\n<p>在 ① 中当 S 和 T 不匹配时，BF算法的操作是主串 S 回退到 i-j+1（从本次匹配的初始位置后移一位，图中步骤②的位置），匹配串 T 回退到 j = 0 (初始位置）, 然后执行 ②③④⑤⑥ 步依次进行匹配，但所有这些步骤一定都是必需的吗？</p>\n<p>在步骤 ① 中，单看模式串 T，前三个字符均不相等（'h' != 'e' != 'l'），同时S 和 T 串前三个字符又相匹配，那么模式串 T 的首字符'h' 自然不可能和主串 S 的第二、三位字符相等。所以步骤②③都是多余的。这是KMP算法的关键所在，如果我们知道 T 串中哪些字符相等（也是关键点，后续会讲），那么有些步骤就可以省略。</p>\n<div align=\"center\">\n<img class=\"lazyload\" width=\"50%\" />\n</div>\n<p>因此只需要保留①④⑤⑥的步骤即可。从下图可以看出，指针 i 是不是一直没有回溯？这就是KMP的妙处所在。在KMP中，指针 i 永远不会回溯，只有指向模式串的指针 j 会发生回溯。在本例中 j 每次都回退到首元素，我们再举一个例子，看看 j 会怎么变化。</p>\n<div align=\"center\">\n<img class=\"lazyload\" width=\"60%\" />\n</div>\n<p>第二个例子：</p>\n<p>目标串（主串） S = \"abcababca\", 模式串（子串） T = \"abcabx\"。BF算法执行过程如下图所示，在步骤 ① 中前5个字符完全相等，根据上一个例子的经验，已知模式串T中第一位字符与第二位、第三位不等（后续会根据next[]数组计算得出），步骤 ②③ 都是多余的，直接省略。</p>\n<div align=\"center\">\n<img class=\"lazyload\" width=\"60%\" />\n</div>\n<p>与上个例子不同的是，这里的模式串 T 的首位字符 'a' 与 T 第四位的 'a' 相等，第二位的 'b' 与第五位的 'b' 相等，而在 ① 中,第四位的 'a' 第五位的 'b' 已经与主串 S 中的相应位置比较过了，是相等的。因此可以断定,T 的首字符 'a'、第二位的字符 'b' 与 S 的第四位字符和第五位字符肯定也是相等的，所以 ④⑤ 这两个比较得出字符相等的步骤也可以省略。</p>\n<div align=\"center\">\n<img class=\"lazyload\" width=\"60%\" />\n</div>\n<p>总结上面两个例子，在KMP算法中，<strong>主串的 i 值</strong>是<strong>不需要回溯</strong>的。所以我们只需要考虑变化的 j 值，模式串 j 值的变化通过观察可以发现，当主串和模式串不匹配时，下一步 j 该指向哪个元素<strong>只与模式串 T 本身有关系</strong>。当发现有相同的字符，j 的变化也就会不同。</p>\n<p>在KMP中，当主串和模式串不匹配时, 下一步 j 值的多少取决于当前字符之前的串的前后缀的相似度。</p>\n<h2 id=\"next数组\">next数组</h2>\n<h3 id=\"基础知识\">基础知识</h3>\n<p>在我们计算next数组之前，我们先讲解一些基础知识。</p>\n<ul>\n<li>前缀：字符串的开头，例如字符串abcd的前缀为a, ab, abc, abcd。在KMP算法中使用的前缀为真前缀，既不包括原字符串abcd的前缀。（真前缀：a, ab, abc）</li>\n<li>后缀：字符串的结尾，在KMP算法中同样使用的是真后缀(bcd,cd,d)。</li>\n<li>最长公共前后缀：最长的相等的前缀与后缀，例如字符串ABCxyzABC的最长公共前后缀为ABC\n<ul>\n<li>ABCXYABC的真前缀：A，AB, <strong>ABC</strong>, ABCx, ABCxy, ABCxyz, ABCxyzA, ABCxyzAB</li>\n<li>ABCXYABC的真后缀：BCxyzABC, CxyzABC, xyzABC, yzABC, zABC, <strong>ABC</strong>, BC, C</li>\n</ul>\n</li>\n<li>前缀表：存储每一个前缀的最长公共前后缀的长度。<br />\n举例：若模式串 T=\"abaaabaaca\"。</li>\n</ul>\n<div align=\"center\">\n<img class=\"lazyload\" width=\"50%\" />\n</div>\n<ul>\n<li>next数组：把 T 串各个位置的 j 的变化定义为数组 next，next 的长度就是 T 串的长度。主串和模式串不匹配时，下一步 j 的值由 next[j] 决定。例如目标串 S=\"abcaba\", T=\"aba\", 根据前缀表求出 next=[-1,0 0], 当 j=2 时发生不匹配, next[2]=0, 下一步 j 将等于 0 进行字符匹配。</li>\n</ul>\n<div align=\"center\">\n<img alt=\"绘图13.png\" class=\"lazyload\" width=\"50%\" />\n</div>\n<h3 id=\"前缀表和next数组的关系\">前缀表和next数组的关系</h3>\n<p>前缀表存储每一个前缀的最长公共前后缀的长度，next数组存储的是模式串向右移动到next值的位置，这个值与前缀的最长公共前后缀的长度有关，所以next数组是可以由前缀表生成的。<br />\n用前缀表生成一个next数组很容易，将前缀表每一位都向后移动1位（最后一位舍去）并在第一位补一个-1就得到了next数组。</p>\n<div align=\"center\">\n<img alt=\"绘图14.png\" class=\"lazyload\" width=\"50%\" />\n</div>\n<p>如果有同学不理解这个关系还可以看一下手动推理过程：<br />\nT=\"abaaabaaca\"</p>\n<ol>\n<li>位置0上的元素a前面没有子串，令next[0]=-1</li>\n<li>位置1上的元素b前面的字符串为\"a\"，字符串\"a\"没有最长公共前后缀，next[1]=0</li>\n<li>位置2上的元素a前面的字符串为\"ab\",\"ab\"没有最长公共前后缀，next[2]=0</li>\n<li>位置3上的元素a前面的字符串为\"aba\"，最长公共前后缀为\"a\"，next[3]=1</li>\n<li>位置4上的元素a前面的字符串为\"abaa\"，最长公共前后缀为\"a\"，next[4]=1</li>\n<li>位置5上的元素b前面的字符串为\"abaaa\"，最长公共前后缀为\"a\"，next[5]=1</li>\n<li>位置6上的元素a前面的字符串为\"abaaab\"，最长公共前后缀为\"ab\"，next[6]=2</li>\n<li>位置7上的元素a前面的字符串为\"abaaaba\"，最长公共前后缀为\"aba\"，next[7]=3</li>\n<li>位置8上的元素a前面的字符串为\"abaaabaa\"，最长公共前后缀为\"abaa\"，next8]=4</li>\n<li>位置9上的元素a前面的字符串为\"abaaabac\"，没有最长公共前后缀，next[9]=0</li>\n</ol>\n<p>同时在<a href=\"https://blog.csdn.net/gmynebula/article/details/125239503\" rel=\"noopener nofollow\" target=\"_blank\">KMP算法中next数组的计算</a>这篇博客中提到了一个地方：为什么有些next数组是0,1开头，而有些next数组是-1,0开头？</p>\n<blockquote>\n<p>-1,0开头与0, 1开头的next数组本质是一样的。实际上，以0, 1开头的next数组就是以-1,0开头的next数组每一项加1得到的。出现这种情况的原因在于模式串起始的索引值：在程序中，一个数组的索引的起始值为0；然而在考试和书中给的模式串起始值是多从1开始。所以在考试中遇到的next数组通常是以0, 1开头；而一些程序或教程中的next数组是以-1, 0开头。<br /><br />\n注：在考试中通常会给模式串的索引，或者会给next值的前两项，在答题时要按照题目中的要求写next数组。</p>\n</blockquote>\n<h2 id=\"代码实现\">代码实现</h2>\n<p>next数组的代码实现, 可以计算出当前匹配串 T 的 next 数组</p>\n<pre><code class=\"language-cpp\">void get_next(string T, int *next) {\n\tnext[0] = -1;\n\tint i = 0;\n\tint j = -1;\n\t\n\twhile(i &lt; T.size() - 1) {\n\t\t//T[i]表示后缀的单个字符\n\t\t//T[j]表示前缀的单个字符\n\t\tif(j == -1 || T[i] == T[j]){//\n\t\t\t++i;\n\t\t\t++j;\n\t\t\tnext[i] = j;\n\t\t} else {\n\t\t\t//如果字符不相同，则j值回溯\n\t\t\tj = next[j];\n\t\t}\n\t}\n}\n</code></pre>\n<p>KMP代码实现</p>\n<pre><code class=\"language-cpp\">int KMP(string S, string T) {\n    int ans = -1;\n    // i用于遍历主串S\n    int i = 0;\n    // j用于遍历匹配串T\n    int j = 0;\n    int next[255]; // 这里初始长度为255,需自行调整\n    // 对T做分析，得到next数组\n    get_next(T, next);\n    while (i &lt; S.size()) {\n        // 匹配成功则继续向下一个字符进行匹配\n        if (j == -1 || S[i] == T[j]) {\n            ++i;\n            ++j;\n        }\n        // 匹配失败进行回溯\n        else {\n            // j回溯到合适的位置\n            j = next[j];\n        }\n        if (j == T.size()) {\n            ans = i - T.size();\n            break;\n        }\n    }\n    return ans;\n}\n</code></pre>\n<h2 id=\"时间复杂度\">时间复杂度</h2>\n<p>令 n 为主串长度，m 为要匹配的子串长度。</p>\n<p>对于Get_next函数来说，时间复杂度为O(m)，因为i值不回溯，所以使得KMP算法效率得到提高，在KMP函数中while循环的时间复杂度为O(n)，因此整个算法的时间复杂度为O(n + m)。</p>\n<p>KMP算法仅当模式与主串之间存在许多“部分匹配”时，才会体现出它的优势，否则两者差异不明显。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t<p class=\"postfoot\">\n\t\t\tposted on \n<span id=\"post-date\">2026-02-10 16:30</span>&nbsp;\n<a href=\"https://www.cnblogs.com/CodingCat-jiumi\">ctxIQ为0</a>&nbsp;\n阅读(<span id=\"post_view_count\">19</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</p>"
    },
    {
      "title": "全网最简单的 OpenClaw 部署教程，5 分钟拥有你的 AI 员工",
      "link": "https://www.cnblogs.com/yupi/p/19600386",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yupi/p/19600386\" id=\"cb_post_title_url\" title=\"发布于 2026-02-10 15:58\">\n    <span>全网最简单的 OpenClaw 部署教程，5 分钟拥有你的 AI 员工</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"全网最简单的 OpenClaw 部署教程，5 分钟拥有你的 AI 员工\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/2225420/202602/2225420-20260210155738305-451805846.png\" />\n        最近 OpenClaw（由 ClawdBot 改名）是真的火，它是一个能操作电脑干活的 AI 数字员工。能帮你读写文件、编写程序、执行任务，7×24 小时不休息。而且你随时随地掏出手机就能操控它，让它帮你干活。\n最快的、傻瓜式安装 OpenClaw 的方法这就来了！\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p class=\"md-end-block md-heading\"><span class=\"md-plain md-expand\"><span style=\"font-size: 14px;\">大家好，我是程序员鱼皮。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">最近 OpenClaw（由 ClawdBot 改名）是真的火，<span class=\"md-pair-s \"><strong>它是一个能操作电脑干活的 AI 数字员工</strong><span class=\"md-plain\">。能帮你读写文件、编写程序、执行任务，7×24 小时不休息。而且你随时随地掏出手机就能操控它，让它帮你干活。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">网友也是把 OpenClaw 玩出花来了：</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">有人让它自动清理上万封邮件，收件箱直接干掉 45%，省下几十个小时的整理时间</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">有人用它抢演唱会门票和机票，设好条件让它每隔几秒刷一次，刷到就自动下单</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">有人躺在床上，通过手机遥控它把整个网站重写了一遍</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">还有人让它同时跑多条自动化任务：一边盯盘、一边写日报、一边自动回群消息</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">更离谱的是，苹果的 Mac Mini（就是那个巴掌大的小主机）竟然因为 OpenClaw <span class=\"md-pair-s \"><strong>直接卖断货了</strong><span class=\"md-plain\">！因为很多人想买一台 24 小时不关机的小电脑跑 OpenClaw，让它当自己的 AI 打工人。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这玩意刚出的时候，女朋友就问我：看起来好厉害啊，你能帮我也整一个吗？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我撇撇嘴：不整。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">她给了我一巴掌：整不整？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我一脸委屈：别整别整，再等等，一定会有更简单的安装方法出来的。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">果然，没让我等太久，最快的、傻瓜式安装 OpenClaw 的方法来了！</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">怎么安装 OpenClaw</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">很多人以为想玩 OpenClaw 就得买一台实体电脑 24 小时开着。但其实完全没必要，<span class=\"md-pair-s \"><strong>一台云服务器就能搞定</strong><span class=\"md-plain\">，而且更稳定、不怕断电断网、随时随地用手机就能指挥它干活。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">就在 2 月 8 日，百度智能云推出了 <span class=\"md-pair-s \"><strong>OpenClaw 极速简易部署方案</strong><span class=\"md-plain\">。哪怕你完全没有编程基础，只需要点几下鼠标，几分钟内就能拥有自己的 AI 数字员工。还支持各种主流 AI 大模型一键切换，甚至能直接把 OpenClaw 接入 QQ、飞书、钉钉、企业微信，<span class=\"md-pair-s \"><strong>在手机上发条消息就能指挥 AI 干活</strong><span class=\"md-plain\">。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">接下来我带大家实操一下，建议收藏备用 ⭐️。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">手把手部署 OpenClaw</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>1）搞一台云服务器</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你可以把云服务器理解成 <span class=\"md-pair-s \"><strong>一台放在机房里的电脑</strong><span class=\"md-plain\">，24 小时不关机、不断网，你随时随地都能远程连上去用它。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">先分享一种最简单获取服务器的方法，打开百度智能云为 OpenClaw 特制的「极简部署页面」，只需 <span class=\"md-pair-s \"><strong>0.01 元</strong><span class=\"md-plain\">，就能抢购到一台 <span class=\"md-pair-s \"><strong>2核4G4M</strong><span class=\"md-plain\"> 的轻量应用服务器，免费体验 1 个月。</span></span></span></span></span></p>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">指路：<span class=\"md-link md-pair-s\"><a href=\"https://cloud.baidu.com/product/BCC/moltbot.html\" rel=\"noopener nofollow\">https://cloud.baidu.com/product/BCC/moltbot.html</a></span></span></p>\n</blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这个活动是每天限量的，新老用户都能参与，没想到我运气不错，羊毛被我薅到了哈哈：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">稍等片刻，服务器就初始化完成了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">点击「一键部署OpenClaw」按钮，就能跳转到服务器管理页面。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果你没有成功参与活动，也不要灰心，可以进入轻量应用服务器控制台，手动创建一台服务器。</span></p>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">指路：<span class=\"md-link md-pair-s\"><a href=\"https://console.bce.baidu.com/ls/#/ls/instance/create\" rel=\"noopener nofollow\">https://console.bce.baidu.com/ls/#/ls/instance/create</a></span></span></p>\n</blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">注意，镜像一定要选择 <span class=\"md-pair-s \"><strong>OpenClaw</strong><span class=\"md-plain\"> 应用镜像，套餐选择 <span class=\"md-pair-s \"><strong>2 核 4GB</strong><span class=\"md-plain\"> 就妥妥够用了。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">结算之后会自动创建服务器，然后跟前面一样，能够进入到服务器管理页面。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">做到这一步，相当于你已经获得了一位 “即将入职” 的 AI 员工。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>2）一键开通相关服务</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在服务器管理页面中，点击 <span class=\"md-pair-s \"><strong>应用管理</strong><span class=\"md-plain\"> Tab。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">页面会提示你需要开通千帆大模型、云助手等几个服务。不用一个个去找，直接点 <span class=\"md-pair-s \"><strong>一键开通</strong><span class=\"md-plain\">，同意协议就搞定了。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>3）放通防火墙端口</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果你想要访问已经部署的 OpenClaw 网页控制台，需要放通服务器防火墙的 18789 端口。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">点击 <span class=\"md-pair-s \"><strong>一键放行</strong><span class=\"md-plain\"> 按钮就好：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>4）选择 AI 模型</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">接下来，为你的 AI 员工提供一个聪明的大脑吧~</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">可以直接在页面下拉选择你想要的模型，国产的主流大模型基本都支持（比如 DeepSeek），选完点击 <span class=\"md-pair-s \"><strong>应用</strong><span class=\"md-plain\"> 就行。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">系统会自动帮你创建调用大模型的 API 密钥，并且把配置全部搞定。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">等执行成功，你的 OpenClaw 就可以正常使用了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">做到这里，恭喜，你的 AI 数字员工已经正式入职！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">前后加起来也就几分钟，而且整个过程非常傻瓜式。平台真的是很照顾小白了，生怕多操作一步就把用户劝退掉。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>5）跟你的 AI 员工聊聊天</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">点击页面下方的 <span class=\"md-pair-s \"><strong>获取网站地址</strong><span class=\"md-plain\">：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后打开链接进入 OpenClaw 网页端：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">现在你就可以直接在网页上跟 OpenClaw 对话了，比如先给他取个名字吧，我这里叫他为「鱼皮的天苟」：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">可以看到，AI 自动更新了自己的身份，并且会一直保留这段记忆。之后，你可以通过不断地对话来训练 AI，让他成为你最得力的助手。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不过话说回来，总不能每次想找 AI 帮忙都跑去开电脑、打开浏览器访问网页吧？那也太麻烦了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">怎么能随时联系到我的 AI 员工呢？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">答案当然是：<span class=\"md-pair-s \"><strong>通过手机给 AI 员工发消息</strong><span class=\"md-plain\">。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">几乎所有聊天软件都能接受 OpenClaw 这位 AI 员工，比如 QQ、企业微信、钉钉、飞书等等。下面我就以更适合个人用户的 QQ 为例，给大家演示如何在手机上遥控 AI 干活。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">在手机 QQ 上遥控 AI 干活</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果你使用百度智能云安装 OpenClaw，那么接入 QQ 就非常简单了，几步就搞定。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>1）创建 QQ 机器人</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">打开 <span class=\"md-meta-i-c  md-link\"><a href=\"https://q.qq.com/\" rel=\"noopener nofollow\"><span class=\"md-plain\">QQ 开放平台</span></a><span class=\"md-plain\">，注册并登录：</span></span></span></p>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">指路：<span class=\"md-link md-pair-s\"><a href=\"https://q.qq.com/\" rel=\"noopener nofollow\">https://q.qq.com</a></span></span></p>\n</blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">登录成功后，点击 “机器人” Tab，创建一个新的机器人：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">给你的机器人设置一个爱称和可爱的头像吧，便于之后在 QQ 中找到他：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>2）设置机器人</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">创建完成后，进入机器人的开发管理页面：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">找到 <span class=\"md-pair-s \"><strong>AppID</strong><span class=\"md-plain\"> 和 <span class=\"md-pair-s \"><strong>AppSecret</strong><span class=\"md-plain\">，复制保存好，等会要用。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">还要把你云服务器的 <span class=\"md-pair-s \"><strong>公网 IP</strong><span class=\"md-plain\"> 添加到 IP 白名单里，然后保存。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">云服务器的公网 IP 在百度智能云的服务器管理页面就能看到，注意不要暴露给别人哦！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>3）填写消息平台配置</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在百度智能云的服务器管理页面，找到 <span class=\"md-pair-s \"><strong>消息平台配置</strong><span class=\"md-plain\">，下拉选择 <span class=\"md-pair-s \"><strong>QQ</strong><span class=\"md-plain\">，把刚才的 AppID 和 AppSecret 填进去，点 <span class=\"md-pair-s \"><strong>应用</strong><span class=\"md-plain\">，等它执行完就好了。</span></span></span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>4）添加访问机器人的权限</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">回到 QQ 开放平台，在沙箱配置里给你的 QQ 账号（或者 QQ 群）添加访问机器人的权限：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后用 QQ 扫码添加机器人就行了：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">现在，你可以直接在 QQ 上跟你的 AI 数字员工聊天了：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">之后，你只需要躺在床上打开 QQ，就能指挥远程服务器上的 AI 干活，巴适得板~</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">除了 QQ，OpenClaw 还支持接入飞书、钉钉、企业微信，配置方式都差不多，有需要的同学可以看官方教程：</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">OpenClaw 接入钉钉：<span class=\"md-link md-pair-s\"><a href=\"https://cloud.baidu.com/doc/LS/s/wml9dlyfu\" rel=\"noopener nofollow\">https://cloud.baidu.com/doc/LS/s/wml9dlyfu</a></span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">OpenClaw 接入飞书：<span class=\"md-link md-pair-s\"><a href=\"https://cloud.baidu.com/doc/LS/s/2ml9dnf3j\" rel=\"noopener nofollow\">https://cloud.baidu.com/doc/LS/s/2ml9dnf3j</a></span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">OpenClaw 接入企业微信：<span class=\"md-link md-pair-s\"><a href=\"https://cloud.baidu.com/doc/LS/s/Nml9dk84r\" rel=\"noopener nofollow\">https://cloud.baidu.com/doc/LS/s/Nml9dk84r</a></span></span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不过别对他有太高的要求，你要是现在就给他复杂的任务，可能它会 “阿巴阿巴”，赛博智障。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如我问他一个非常简单的问题，他竟然先给我报了个错，然后说自己没有联网搜索功能？？？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">要想让 AI 变得更强，就需要用到 Skills 了。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">给你的 AI 员工装技能包</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Skills 的全称是 Agent Skills，也在 AI 圈儿火得一塌糊涂。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">简单来说，它就是给 AI 装备的技能包，里面有精心设计的提示词、代码脚本、还有各种资源文件，让 AI 能在特定任务上表现得更专业。比如你给 AI 装个 PPT 制作 Skills，他就会做 PPT 了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你可以通过给 OpenClaw 安装技能包，来增强他的能力。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>怎么获取和安装技能呢？</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果你使用百度智能云安装 OpenClaw，安装技能就非常简单了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">百度千帆最近把自家的 AI 能力打包成了 Skill，并且上架到了 OpenClaw 的技能商店 <span class=\"md-meta-i-c  md-link\"><a href=\"https://clawhub.ai/skills\" rel=\"noopener nofollow\"><span class=\"md-plain\">ClawHub</span></a><span class=\"md-plain\">，目前一共有 6 款官方 Skill。包括百度搜索、百度百科、学术检索、AI 绘本生成、智能 PPT 生成、千帆深度研究 Agent。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">直接进入到服务器管理页面的 Skills 配置，就能傻瓜式搜索和安装技能了：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如我安装了百度搜索和百度百科 Skills，这两块都是百度的特长，适合用来搜索国内的信息源。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">添加 Skills 完成后，进入到 OpenClaw 管理页面的 Skills 配置中，可以看到技能安装成功：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后我让「鱼皮的天苟」帮我搜索 “程序员鱼皮”：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这次的结果靠谱多了，在 OpenClaw 网页对话框中，可以看到 AI 调用了百度搜索技能：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">除了上述安装技能的方式外，你还可以登录服务器，输入一行命令来手动安装技能：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>npx clawhub@latest install [skill名称]</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不过我估计非程序员朋友们是不知道怎么操作服务器的，完全没关系，毕竟现在已经是 AI 时代了，干嘛还自己动手操作服务器？直接让 AI 自己装不就完了？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我跟 OpenClaw 说了句：</span></p>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">帮我安装编程动画制作技能</span></p>\n</blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">它一开始可能会拒绝或者不太理解，没关系，稍微引导一下就行：</span></p>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我就要你来操作服务器帮我安装</span></p>\n</blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这次，他成功完成了任务。让 AI 自己给自己装技能，才是 AI 时代该有的操作方式。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果你想探索更多技能，可以去 <span class=\"md-meta-i-c  md-link\"><a href=\"https://clawhub.ai/skills\" rel=\"noopener nofollow\"><span class=\"md-plain\">ClawHub</span></a><span class=\"md-plain\"> 逛一逛。</span></span></span></p>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">指路：<span class=\"md-link md-pair-s\"><a href=\"https://clawhub.ai/\" rel=\"noopener nofollow\">https://clawhub.ai</a></span></span></p>\n</blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不过鱼皮建议大家谨慎安装 Skills，非必要不安装、非官方不安装，毕竟 Skills 是人为制作的，可能会存在安全隐患。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">有了 OpenClaw 能干啥</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我估计很多同学搭建完 OpenClaw 可能就扔那儿了，或者不知道 OpenClaw 到底能做些什么。所以我这里分享几个比较实用的玩法，大家可以直接抄作业。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">1、AI 帮你追热点</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我在 QQ 上跟 OpenClaw 说了一句：帮我获取 AI 相关的资讯热点。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">过了一会儿，它回了我一份整整齐齐的热点摘要：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">以前我可能要到网上刷刷新闻，现在发条消息就搞定了~</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果需要的话，你还可以让它跑个定时任务，比如设定 “每天早上 8 点帮我搜一下 OpenClaw 社区有没有新的玩法”，它就默默帮你盯着，有消息第一时间推给你。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">2、灵感记录器</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">有时走在路上，我可能会突然有一些好的想法、或者突然想起了某件事情，为了防止忘记，就会打开手机备忘录记下来。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">久而久之，记的内容越来越多，导致很多记下来的内容也被忽略了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">现在，我可以直接把 OpenClaw 当做是我的超级备忘录，先给 AI 设定一个角色，比如告诉它 “你是一个灵感记录器”：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">之后有任何怕忘记的想法或事情，直接掏出手机在 QQ 上跟 AI 说一句就行了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">OpenClaw 跟普通备忘录不一样，它不只是帮你记，还会帮你修正错别字和分类整理，而且永远不会忘事！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">3、随身携带的超级程序员</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这应该是最让程序员朋友们兴奋的场景了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">因为 OpenClaw 是跑在服务器上的，它能直接在服务器上写代码、运行程序、部署服务，做完你就能直接用。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如我在坐地铁的时候，直接掏出手机，在 QQ 上跟 OpenClaw 说一句：</span></p>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">帮我写一个网页小工具，能上传图片后批量压缩，支持调整压缩质量，写完直接部署到服务器上让我能访问。</span></p>\n</blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">过了几分钟，AI 回复我：工具写好了，已经部署上线，直接访问 XX 地址就能用。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">没错，就发了条消息，一个能用的在线工具就出来了，跟变魔术似的。</span></p>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">注意，如果无法访问，可能是因为没有给服务器的防火墙开放对应端口。</span></p>\n</blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">之后你有了任何灵感，甚至都不需要掏出电脑，全程通过手机跟 AI 对话，就能创造出可运行的项目。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这种感觉，怎么说呢，有点钢铁侠内味儿了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">最后</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">看到这里，相信大家已经能感受到，<span class=\"md-pair-s \"><strong>OpenClaw 的上手门槛已经被砸到地板上了</strong><span class=\"md-plain\">。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">只要花几分钟，就能拥有私人的 AI 数字员工，之后你在手机上发条 QQ 消息，就能让 AI 帮你搜信息、管文件、写代码、做调研。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不管你是程序员、学生、还是普通上班族，我都建议你去试试。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">最后再贴一下官方的部署教程，点击阅读原文可以直接跳转。</span></p>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">操作指南：<span class=\"md-link md-pair-s\"><a href=\"https://cloud.baidu.com/doc/LS/s/6ml9f3cvl\" rel=\"noopener nofollow\">https://cloud.baidu.com/doc/LS/s/6ml9f3cvl</a></span></span></p>\n</blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">也欢迎大家多多分享你的 OpenClaw 玩法，评论区见~</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">更多编程学习资源</span></h2>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course\" rel=\"noopener nofollow\"><span class=\"md-plain\">Java前端程序员必做项目实战教程+毕设网站</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费编程学习交流社区（自学必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course/cv\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员保姆级求职写简历指南（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.mianshiya.com/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费面试刷题网站工具（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640584449888772098\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Java零基础入门学习路线 + Java教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586673306091521\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Python零基础入门学习路线 + Python教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586014108303362\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新前端零基础入门学习路线 + 前端教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586867363954689\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据结构和算法零基础入门学习路线 + 算法教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1644279832026075138\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新C++零基础入门学习路线、C++教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641797333479903234\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据库零基础入门学习路线 + 数据库教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640589994284695553\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Redis零基础入门学习路线 + Redis教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641035880439271426\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机基础入门学习路线 + 计算机基础教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641366118197153793\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新小程序入门学习路线 + 小程序开发教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"http://sqlmother.yupi.icu/\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新SQL零基础入门学习路线 + SQL教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586295529324545\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Linux零基础入门学习路线 + Linux教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588753362108417\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Git/GitHub零基础入门学习路线 + Git教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640587909942099969\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新操作系统零基础入门学习路线 + 操作系统教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588119619551233\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机网络零基础入门学习路线 + 计算机网络教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588392073150465\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新设计模式零基础入门学习路线 + 设计模式教程</span></a></span></p>\n</li>\n<li class=\"md-list-item md-focus-container\">\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-meta-i-c md-link md-expand\"><a href=\"https://www.code-nav.cn/post/1640648711119892481\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新软件工程零基础入门学习路线 + 软件工程教程</span></a></span></p>\n</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-10 15:58</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yupi\">程序员鱼皮</a>&nbsp;\n阅读(<span id=\"post_view_count\">217</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Oracle ADG环境VIP高可用部署实操",
      "link": "https://www.cnblogs.com/liuziyi1/p/19599671",
      "published": "",
      "description": "<h2>\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/liuziyi1/p/19599671\" id=\"cb_post_title_url\" title=\"发布于 2026-02-10 14:33\">\n    <span>Oracle ADG环境VIP高可用部署实操</span>\n    \n\n</a>\n\n\t\t</h2>\n\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在Oracle ADG高可用架构中，配置虚拟IP（VIP）是核心优化手段之一，其核心目的是实现ADG主备切换后，业务应用无需修改数据源IP，大幅降低业务中断时长，这一设计思路同样适用于其他数据库的HA架构。本次实操围绕Oracle ADG主备节点完成VIP自动切换脚本部署，同时解决了脚本运行中su操作日志持续写入/var/log/messages导致日志无限膨胀的问题，<strong>相同网卡配置的主备两台服务器，脚本部署与运行配置完全一致</strong>，以下为详细实操步骤。</p>\n<h2 id=\"一环境检查确认公网业务网卡\">一、环境检查：确认公网业务网卡</h2>\n<p>本次实操中业务公网网卡为ens33，通过<code>ip a</code>命令检查网卡信息，确认网卡状态及原有IP配置，为后续VIP绑定做准备。</p>\n<pre><code class=\"language-bash\">[root@euler01 etc]# ip a\n# 关键输出：ens33网卡UP状态，绑定物理IP 192.168.X.X/24\n</code></pre>\n<h2 id=\"二vip自动切换脚本部署\">二、VIP自动切换脚本部署</h2>\n<p>本次部署包含两个核心脚本：<code>vip_check.sh</code>为心跳检测脚本，实现定时调用核心脚本；<code>vip_dg.sh</code>为核心逻辑脚本，根据数据库OPEN_MODE状态自动绑定/卸载VIP，同时配置脚本随系统自启动，确保服务器重启后VIP高可用功能正常。</p>\n<h3 id=\"21-配置系统自启动\">2.1 配置系统自启动</h3>\n<p>修改<code>/etc/rc.local</code>添加脚本启动命令，同时赋予rc.local可执行权限，保证系统启动时自动运行VIP检测脚本。</p>\n<pre><code class=\"language-bash\"># 编辑自启动文件，添加脚本后台运行命令\n[root@euler01 etc]# cat /etc/rc.local\n添加：/etc/vip_check.sh &gt; /dev/null 2&gt;&amp;1 &amp;\n\n# 赋予可执行权限\n[root@euler01 etc]# chmod +x /etc/rc.d/rc.local\n[root@euler01 etc]# ll /etc/rc.d/rc.local\n-rwxr-xr-x. 1 root root 510 Dec 2 09:48 /etc/rc.d/rc.local\n</code></pre>\n<h3 id=\"22-编写心跳检测脚本vip_checksh\">2.2 编写心跳检测脚本：vip_check.sh</h3>\n<p>该脚本为死循环定时脚本，每3秒调用一次核心脚本<code>vip_dg.sh</code>，实现VIP状态的实时检测，脚本存放路径<code>/etc/vip_check.sh</code>。</p>\n<pre><code class=\"language-bash\">[root@euler01 etc]# cat /etc/vip_check.sh\n#!/bin/bash\nstep=3\nwhile true; do\n    /etc/vip_dg.sh &gt; /dev/null 2&gt;&amp;1\n    sleep $step\ndone\n</code></pre>\n<h3 id=\"23-编写核心逻辑脚本vip_dgsh\">2.3 编写核心逻辑脚本：vip_dg.sh</h3>\n<p>该脚本为VIP切换核心逻辑，通过查询Oracle数据库<code>v$database</code>视图的<code>open_mode</code>判断主备状态（主库为WRITE模式），同时检查VIP（192.168.207.39）是否绑定，实现<strong>主库自动绑定VIP、备库自动卸载VIP</strong>，并通过arping广播更新网络arp表，确保VIP网络可达，脚本存放路径<code>/etc/vip_dg.sh</code>。</p>\n<pre><code class=\"language-bash\">[root@euler01 etc]# cat /etc/vip_dg.sh\n#!/bin/bash\n# 查询数据库是否为WRITE模式（主库），返回1则为主库，0则为备库\ndbstats=`su - oracle -c \"echo -e 'set pagesize 0\\nselect open_mode from v\\\\$database;' | sqlplus -S / as sysdba\"|grep WRITE|wc -l`\n# 检查VIP 192.168.X.X是否已绑定在ens33:1\nip=`/usr/sbin/ip a|grep ens33:1|wc -l`\n\nif [[ \"${dbstats}\" -eq 1 ]] ; then\n    # 主库：未绑定VIP则执行绑定，并发送arp广播\n    if [[ \"${ip}\" -eq 0 ]]; then\n    /usr/sbin/ifconfig ens33:1 192.168.X.X netmask 255.255.255.0 up\n    /usr/sbin/arping -I ens33 -b -s 192.168.X.X 192.168.X.X -c 3\n    fi\nelse\n    # 备库：已绑定VIP则执行卸载\n    if [[ \"${ip}\" -gt 0 ]]; then\n    /usr/sbin/ifconfig ens33:1 down\n    fi\nfi\n</code></pre>\n<h2 id=\"三脚本运行基础测试\">三、脚本运行基础测试</h2>\n<p>完成脚本部署后，重启服务器验证脚本自启动、VIP绑定状态，确认基础功能正常。</p>\n<h3 id=\"31-验证脚本进程运行\">3.1 验证脚本进程运行</h3>\n<p>服务器重启后，通过<code>ps -ef</code>命令检查VIP脚本进程，确认进程正常后台运行。</p>\n<pre><code class=\"language-bash\">[root@euler01 etc]# ps -ef|grep vip\n</code></pre>\n<h3 id=\"32-验证主库vip绑定状态\">3.2 验证主库VIP绑定状态</h3>\n<p>主库节点下，通过<code>ip a</code>命令检查，确认浮动VIP 192.168.X.X成功绑定在ens33:1子网卡上，VIP状态正常。</p>\n<pre><code class=\"language-bash\">[root@euler01 etc]# ip a\n# 关键输出：ens33:1子网卡绑定VIP 192.168.X.X/24\n</code></pre>\n<h2 id=\"四问题解决屏蔽su操作日志输出\">四、问题解决：屏蔽su操作日志输出</h2>\n<p>脚本运行中，<code>vip_dg.sh</code>每3秒执行一次<code>su - oracle</code>操作，系统会将该操作日志持续写入<code>/var/log/messages</code>，长期运行会导致日志文件无限增大，本次通过修改rsyslog配置，屏蔽su操作的auth类日志输出至messages。</p>\n<h3 id=\"41-检查rsyslog服务状态\">4.1 检查rsyslog服务状态</h3>\n<p>确认rsyslog服务正常运行，该服务为系统日志核心服务，修改其配置可实现日志过滤。</p>\n<pre><code class=\"language-bash\">[root@euler01 etc]# systemctl status rsyslog\n# 关键输出：Active: active (running)，服务正常运行\n</code></pre>\n<h3 id=\"42-修改rsyslog配置文件\">4.2 修改rsyslog配置文件</h3>\n<p>编辑<code>/etc/rsyslog.conf</code>，在messages日志的配置行中添加<code>auth.none</code>，表示屏蔽auth类日志输出至该文件。</p>\n<pre><code class=\"language-bash\">[root@euler01 etc]# vi /etc/rsyslog.conf\n# 修改前\n*.info;mail.none;authpriv.none;cron.none /var/log/messages\n# 修改后\n*.info;mail.none;authpriv.none;cron.none;auth.none /var/log/messages\n\n# 验证修改结果\n[root@euler01 etc]# cat /etc/rsyslog.conf|grep auth.*\n*.info;mail.none;authpriv.none;cron.none;auth.none /var/log/messages\n</code></pre>\n<h3 id=\"43-重启rsyslog服务并验证\">4.3 重启rsyslog服务并验证</h3>\n<p>重启rsyslog服务使配置生效，随后通过<code>tail -f</code>实时查看messages日志，确认无新的su操作日志输出，问题解决。</p>\n<pre><code class=\"language-bash\"># 重启服务\n[root@euler01 etc]# systemctl restart rsyslog\n\n# 验证日志，无su记录输出\n[root@euler01 etc]# tail -f /var/log/messages\n# 仅显示rsyslog服务重启日志，无su[xxxx]: (to oracle) root on none相关记录\n</code></pre>\n<h2 id=\"五最终验证通过vip连接数据库\">五、最终验证：通过VIP连接数据库</h2>\n<p>以Oracle用户身份，通过浮动VIP 192.168.X.X连接数据库，验证VIP网络可达、数据库正常访问，确认整个VIP高可用部署流程生效。</p>\n<pre><code class=\"language-bash\">[root@euler01 etc]# su - oracle\n[oracle@euler01 ~]$ sqlplus zyjc/zyjc@192.168.X.X:1521/cm\n\nSQL*Plus: Release 11.2.0.4.0 Production on Tue Dec 2 13:10:18 2025\nCopyright (c) 1982, 2013, Oracle.  All rights reserved.\n\nConnected to:\nOracle Database 11g Enterprise Edition Release 11.2.0.4.0 - 64bit Production\nWith the Partitioning, OLAP, Data Mining and Real Application Testing options\n</code></pre>\n<h2 id=\"六实操总结\">六、实操总结</h2>\n<ol>\n<li>本次部署的VIP自动切换脚本基于数据库OPEN_MODE状态实现主备自动切换，主备节点网卡配置一致时，脚本可完全复用，降低部署成本；</li>\n<li>心跳脚本每3秒检测一次，兼顾检测实时性与系统资源消耗，arping广播确保VIP切换后网络即时可达；</li>\n<li>通过在rsyslog配置中添加<code>auth.none</code>，精准屏蔽su操作的auth类日志，避免messages日志膨胀，保障系统日志管理规范；</li>\n<li>整个部署实现了Oracle ADG架构下VIP的无人工干预自动切换，业务应用通过VIP连接数据库，主备切换时无需修改数据源配置，大幅缩短业务中断时间。</li>\n</ol>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t<p class=\"postfoot\">\n\t\t\tposted on \n<span id=\"post-date\">2026-02-10 14:33</span>&nbsp;\n<a href=\"https://www.cnblogs.com/liuziyi1\">刘子毅</a>&nbsp;\n阅读(<span id=\"post_view_count\">10</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</p>"
    },
    {
      "title": "C++ STL 学习笔记（一）：vector 去重的三种实现方法详解",
      "link": "https://www.cnblogs.com/GeophysicsWorker/p/19599636",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/GeophysicsWorker/p/19599636\" id=\"cb_post_title_url\" title=\"发布于 2026-02-10 14:29\">\n    <span>C++ STL 学习笔记（一）：vector 去重的三种实现方法详解</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        在C++开发中，`vector`去重是最常见的数据处理需求。本文将详细介绍使用C++标准库中的`sort()`,`unique()`, `erase()`函数组合实现容器vector去重， 本笔记主要介绍三种实现方法：（1）基础数据类型去重；（2）自定义结构体使用`sort`+`unique` 去重；（3）使用`set` 去重；帮助开发者根据不同场景选择最优方案。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"c-stl-学习笔记一vector-去重的三种实现方法详解\">C++ STL 学习笔记（一）：vector 去重的三种实现方法详解</h1>\n<p>​        在C++开发中，<code>vector</code>去重是最常见的数据处理需求。本文将详细介绍使用C++标准库中的<code>sort()</code>,<code>unique()</code>, <code>erase()</code>函数组合实现容器vector去重， 本笔记主要介绍三种实现方法：（1）基础数据类型去重；（2）自定义结构体使用<code>sort</code>+<code>unique</code> 去重；（3）使用<code>set</code> 去重；帮助开发者根据不同场景选择最优方案。</p>\n<h2 id=\"11--基础数据类型去重\">1.1  基础数据类型去重</h2>\n<p>​       <code>unique()</code>函数作用是去掉容器中相邻元素的重复元素，然后返回指向第一个重复元素的迭代器。<code>unique()</code>实质上是一个<strong>伪去除</strong>，它并不是真正把重复的元素删除，而是用不重复的元素把重复的元素<strong>覆盖</strong>了，所以总长度其实是不变的。</p>\n<p>​       因此在利用unique()函数前需要对容器内的数据排序，可以通过sort()函数实现。sort()函数的作用是对容器指定范围内的元素按指定格式进行排序，默认从小到大。在利用unique()函数后需要擦除从返回的迭代器对于的元素到最后元素的所有的元素，可以通过erase()函数实现。erase()函数的作用是擦除容器指定范围内的元素。综上所属：去除的主要思路：先用<code>sort</code>排序（让重复元素相邻）、再唯一（用<code>unique</code> 把重复元素移到容器的末尾）、最后用<code>erase()</code>于删除最后面的那段“重复”元素。对于</p>\n<p>​       对于基础类型数据（如<code>int</code>,<code>float</code>等），最简单直接的方法是使用上述的<code>sort</code>+<code>unique</code>+<code>erase</code>组合。下面是<strong>代码案例实现</strong>：</p>\n<pre><code class=\"language-C++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; vec = {1, 2, 3, 2, 1, 4, 5, 4};\n    \n    cout &lt;&lt; \"去重前: \";\n    for (int num : vec) cout &lt;&lt; num &lt;&lt; \" \";\n    cout &lt;&lt; endl;\n\n    // 排序后去重\n    sort(vec.begin(), vec.end());\n    vec.erase(unique(vec.begin(), vec.end()), vec.end());\n\n    cout &lt;&lt; \"去重后: \";\n    for (int num : vec) cout &lt;&lt; num &lt;&lt; \" \";\n    cout &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>其中注意：</p>\n<ul>\n<li><code>sort()</code>函数的头文件：<code>#include&lt;algorithm&gt;</code></li>\n<li><code>unique()</code>函数的头文件：<code>#include&lt;iostream&gt;</code></li>\n<li><code>erase()</code>函数的头文件：<code>#include&lt;vector&gt;</code></li>\n</ul>\n<h2 id=\"12-自定义结构体去重\">1.2 自定义结构体去重</h2>\n<p>​        另外对于容器中，如结构体、类对象等，为了实现去重操作，还可以通过对<code>sort</code>算法需要重载<code>&lt;</code>操作符或定义比较函数，对<code>unique</code>算法需要重载<code>==</code>操作符，通过对其中的某一个成员变量进行操作来实现，然后采用<code>sort</code>+<code>unique</code>+<code>erase</code>。其<strong>代码实现如下</strong>：</p>\n<pre><code class=\"language-C++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nstruct Person {\n    string name;\n    int age;\n    \n    // 定义相等运算符\n    bool operator==(const Person&amp; other) const {\n        return name == other.name &amp;&amp; age == other.age;\n    }\n};\n\n// 定义比较函数\nbool comparePerson(const Person&amp; a, const Person&amp; b) {\n    if (a.name != b.name) return a.name &lt; b.name;\n    return a.age &lt; b.age;\n}\n\nint main() {\n    vector&lt;Person&gt; people = {\n        {\"Alice\", 25},\n        {\"Bob\", 30},\n        {\"Alice\", 25},\n        {\"Charlie\", 35},\n        {\"Bob\", 30}\n    };\n\n    cout &lt;&lt; \"去重前:\\n\";\n    for (const auto&amp; p : people) \n        cout &lt;&lt; p.name &lt;&lt; \" (\" &lt;&lt; p.age &lt;&lt; \")\\n\";\n\n    sort(people.begin(), people.end(), comparePerson);\n    people.erase(unique(people.begin(), people.end()), people.end());\n\n    cout &lt;&lt; \"\\n去重后:\\n\";\n    for (const auto&amp; p : people) \n        cout &lt;&lt; p.name &lt;&lt; \" (\" &lt;&lt; p.age &lt;&lt; \")\\n\";\n\n    return 0;\n}\n</code></pre>\n<p>​    <strong>其中关键点：</strong></p>\n<ul>\n<li>\n<p>必须定义<code>operator==</code>用于<code>unique</code>判断相等；</p>\n</li>\n<li>\n<p>代码简介，但会改变原始顺序；</p>\n</li>\n<li>\n<p>对于大型数据集合，利用set的集合去重更高效；</p>\n</li>\n</ul>\n<h2 id=\"13-使用set进行去重\">1.3 使用set进行去重</h2>\n<p>​      对vector的去重操作还可以利用set容器的特性实现，思路比较简单，对于自定义类型，可以使用set自动去重的特性，需要定义<code>operator&lt;</code>运算符。其<strong>案例代码如下</strong>：</p>\n<pre><code class=\"language-C++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;set&gt;\nusing namespace std;\n\nstruct Product {\n    string id;\n    double price;\n    \n    // 定义小于运算符\n    bool operator&lt;(const Product&amp; other) const {\n        if (id != other.id) return id &lt; other.id;\n        return price &lt; other.price;\n    }\n};\n\nint main() {\n    vector&lt;Product&gt; products = {\n        {\"P1001\", 99.99},\n        {\"P1002\", 199.99},\n        {\"P1001\", 99.99},\n        {\"P1003\", 299.99},\n        {\"P1002\", 199.99}\n    };\n\n    cout &lt;&lt; \"去重前:\\n\";\n    for (const auto&amp; p : products) \n        cout &lt;&lt; p.id &lt;&lt; \" ($\" &lt;&lt; p.price &lt;&lt; \")\\n\";\n\n    // 使用set去重\n    set&lt;Product&gt; uniqueProducts(products.begin(), products.end());\n    products.assign(uniqueProducts.begin(), uniqueProducts.end());\n\n    cout &lt;&lt; \"\\n去重后:\\n\";\n    for (const auto&amp; p : products) \n        cout &lt;&lt; p.id &lt;&lt; \" ($\" &lt;&lt; p.price &lt;&lt; \")\\n\";\n\n    return 0;\n}\n</code></pre>\n<p><strong>其关键点如下</strong>：</p>\n<ul>\n<li>\n<p>set基于<code>operator&lt;</code>自动排序和去重；</p>\n</li>\n<li>\n<p>代码简洁，但会改变原始顺序</p>\n</li>\n<li>\n<p>对于大型数据集，set方法可能更高效</p>\n</li>\n</ul>\n<h2 id=\"方法比较\">方法比较</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">方法</th>\n<th style=\"text-align: left;\">适用场景</th>\n<th style=\"text-align: left;\">时间复杂度</th>\n<th style=\"text-align: left;\">代码复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">sort+unique</td>\n<td style=\"text-align: left;\">基础数据类型</td>\n<td style=\"text-align: left;\">O(n log n) + O(n)</td>\n<td style=\"text-align: left;\">低</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">自定义结构体sort+unique</td>\n<td style=\"text-align: left;\">需要保持顺序的自定义类型</td>\n<td style=\"text-align: left;\">O(n log n) + O(n)</td>\n<td style=\"text-align: left;\">中</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">set去重</td>\n<td style=\"text-align: left;\">不需要保持顺序的自定义类型</td>\n<td style=\"text-align: left;\">O(n log n)</td>\n<td style=\"text-align: left;\">低</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"参考资料\">参考资料</h2>\n<p><a href=\"https://comate.baidu.com/zh/page/ejyuh54s6yz\" rel=\"noopener nofollow\" target=\"_blank\">C++中vector去重的三种实现方法详解_文心快码</a></p>\n<p><a href=\"https://blog.csdn.net/hyl1181/article/details/108983656\" rel=\"noopener nofollow\" target=\"_blank\">STL之vector去重三步曲（利用unique函数）_vector unique-CSDN博客</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-10 14:29</span>&nbsp;\n<a href=\"https://www.cnblogs.com/GeophysicsWorker\">GeoFXR</a>&nbsp;\n阅读(<span id=\"post_view_count\">17</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "解剖 Python：关于指针、GIL 与异步内核",
      "link": "https://www.cnblogs.com/kaiux/p/19598962",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/kaiux/p/19598962\" id=\"cb_post_title_url\" title=\"发布于 2026-02-10 12:01\">\n    <span>解剖 Python：关于指针、GIL 与异步内核</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"解剖 Python：关于指针、GIL 与异步内核\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/1158182/202602/1158182-20260210120046308-982867969.png\" />\n        本文以 C++ 系统视角，解构 Python 的底层原理。深度剖析 `PyObject` 内存布局、GIL 的原子性幻觉及 `asyncio` 的 epoll 本质。通过 C++ 扩展打破边界，揭示“胶水语言”如何通过牺牲单核计算，换取极致的调度效率与生态垄断。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p><img alt=\"python_overview\" src=\"https://img2024.cnblogs.com/blog/1158182/202602/1158182-20260210120115327-1286094950.jpg\" /></p>\n<h2 id=\"1-ai-时代的数字胶水-the-necessity-in-ai-era\">1. AI 时代的“数字胶水” (The Necessity in AI Era)</h2>\n<h3 id=\"11-生态位的垄断作为-c-的高层指令指针-ip\">1.1. 生态位的垄断：作为 C++ 的高层指令指针 (IP)</h3>\n<p>任何对计算机体系结构有认知的开发者都清楚，Python 的原生性能是灾难级的。它本质上是一个基于栈的虚拟机，每一个整数加法 (<code>a + b</code>) 都要经历类型检查、引用计数更新 (<code>Py_INCREF/DECREF</code>) 和巨大的分派开销。如果你试图用纯 Python 去做矩阵乘法，CPU 的分支预测单元 (Branch Predictor) 会被你杂乱无章的指令流搞得一塌糊涂，L1/L2 Cache 也会因为散落在堆上的 <code>PyObject</code> 而频繁失效。</p>\n<p><strong>然而，AI 不需要 Python 去做计算，AI 只需要 Python 去“下令”。</strong></p>\n<p>在 PyTorch 或 TensorFlow 的架构中，Python 代码扮演的角色实际上是<strong>控制平面 (Control Plane)</strong>，而 C++/CUDA 才是<strong>数据平面 (Data Plane)</strong>。当你写下 <code>z = torch.matmul(x, y)</code> 时，Python 解释器所做的仅仅是构建计算图、进行参数校验，然后将指令指针（Instruction Pointer）的控制权通过 C ABI (Application Binary Interface) 移交给底层的 C++ 动态库。</p>\n<p>一旦进入底层，SIMD 指令集、AVX-512 甚至 GPU 的 Tensor Cores 便接管了一切。此时，Python 的那点解释器开销在耗时数毫秒甚至数秒的矩阵运算面前，完全可以忽略不计（Amdahl's Law 的反向应用）。</p>\n<p><strong>Trade-off 分析：</strong></p>\n<ul>\n<li><strong>牺牲：</strong> 单线程标量计算性能（极慢）。</li>\n<li><strong>换取：</strong> 极致的 C/C++ 互操作性。Python 是唯一一个能让 C++ 开发者感到“像是在写伪代码，但能无缝调用 <code>.so</code> 库”的语言。它是 AI 基础设施（C++）与业务逻辑（Human Logic）之间最薄的“胶水层”。</li>\n</ul>\n<p>这种分层架构甚至导致了 AI 基础设施的进一步下沉。为了避免 Python 在数据预处理（如 Tokenizer、Image Decode）阶段成为瓶颈，现在的趋势是将整个数据加载管线（DataLoader）也下沉到 C++ 或 Rust 中（例如 NVIDIA DALI 或 HuggingFace Tokenizers）。Python 逐渐退化为纯粹的配置语言和胶水层。</p>\n<h3 id=\"12-从计算到协同io-密集型的胜利\">1.2. 从计算到协同：IO 密集型的胜利</h3>\n<p>在传统的高性能计算 (HPC) 时代，我们为了减少纳秒级的延迟，不惜手写汇编优化上下文切换 (Context Switch)。但在 LLM 驱动的 Agent 时代，瓶颈发生了质的转移。</p>\n<p>一个典型的 RAG (Retrieval-Augmented Generation) 流程或 ChatBI 系统，其 90% 的生命周期处于 <strong>Wait 状态</strong>：</p>\n<ol>\n<li>等待向量数据库检索 (Network I/O)。</li>\n<li>等待 LLM API Token 生成 (Network I/O)。</li>\n<li>等待数据库 SQL 执行结果 (Network I/O)。</li>\n</ol>\n<p>此时，CPU 并不是在计算，而是在挂起。如果使用 C++，你需要处理复杂的 <code>epoll</code>、回调地狱或者协程库（如 <code>boost::asio</code> 或 C++20 coroutines），开发成本极高。</p>\n<p>Python 在这里的优势在于其<strong>抽象成本极低</strong>。虽然 Python 的 GIL (Global Interpreter Lock) 臭名昭著，但在 IO 密集型场景下，OS 的线程调度器或者 Python 的 <code>asyncio</code> 事件循环（Event Loop）能很好地掩盖 CPU 的空闲。我们不再关注 TLB (Translation Lookaside Buffer) 的刷新开销，而是关注如何用最少的代码行数，编排最复杂的 API 调用链路。</p>\n<h3 id=\"13-代码实现\">1.3. 代码实现</h3>\n<h4 id=\"131-场景一流式处理与内存友好-the-generator\">1.3.1. 场景一：流式处理与内存友好 (The Generator)</h4>\n<p>在 C++ 中，为了避免一次性加载 10GB 的日志文件导致 OOM (Out of Memory)，我们需要手写 Buffer 管理和迭代器。在 Python 中，<code>yield</code> 关键字本质上是一个<strong>用户态的栈帧挂起 (Stack Frame Suspension)</strong>。它允许函数在保持局部变量状态的情况下暂停执行，将控制权交还给调用者，这是一种极其廉价的“上下文切换”。</p>\n<pre><code class=\"language-python\">import time\nimport os\n\ndef raw_log_streamer(file_path: str, block_size: int = 4096):\n    \"\"\"\n    模拟 C++ 的 Buffered Reader。\n    不一次性读取整个文件，而是利用 Generator 机制\n    在用户态挂起栈帧，实现 Lazy Loading。\n    \"\"\"\n    # 这里的 file_obj 实际上是对底层文件描述符 (fd) 的封装\n    with open(file_path, 'rb') as f:\n        while True:\n            # 触发 syscall: read()\n            chunk = f.read(block_size)\n            if not chunk:\n                break\n            # 此时函数的 Stack Frame 被冻结，\n            # 指令指针 IP 指向下一行，局部变量保留在堆内存的 PyFrameObject 中\n            yield chunk \n\n# 使用场景：处理巨大的数据集而不炸掉 RAM\n# 这种写法在处理 AI 数据 Pipeline (如 DataLoader) 时是标准范式\n# for data in raw_log_streamer(\"large_dataset.bin\"):\n#     process(data)\n\n</code></pre>\n<h4 id=\"132-场景二内核态切换-vs-用户态调度-threading-vs-asyncio\">1.3.2. 场景二：内核态切换 vs 用户态调度 (Threading vs Asyncio)</h4>\n<p>作为系统开发者，你必须明白 <code>threading</code> 和 <code>asyncio</code> 的本质区别：</p>\n<ul>\n<li><strong>Threading:</strong> 映射到 OS 的原生线程 (pthreads)。切换需要内核介入 (Kernel Trap)，涉及寄存器保存、TLB 刷新，开销昂贵。且受制于 GIL，Python 多线程无法利用多核。</li>\n<li><strong>Asyncio:</strong> 单线程内的事件循环。切换只是简单的函数指针跳转 (User-space switching)， <strong>零内核上下文切换开销 (Zero Kernel Context Switch Overhead)</strong>。<em>(注：虽然避免了昂贵的 syscall，但 Python 解释器本身的字节码分派依然有成本，但在高并发 IO 面前，这通常是划算的。)</em></li>\n</ul>\n<p>以下代码直观展示了在 IO 密集型任务中，为什么我们需要从“线程思维”转向“协程思维”。</p>\n<pre><code class=\"language-python\">import threading\nimport asyncio\nimport time\n\n# 模拟一个高延迟的 IO 操作 (例如等待 LLM 返回 token)\n# 在 C++ 视角：这就是一个导致当前线程被挂起到 Wait Queue 的操作\nIO_DELAY = 1.0 \nTASK_COUNT = 50\n\ndef heavy_io_task_sync(idx):\n    # 阻塞式 IO，线程被 OS 挂起\n    time.sleep(IO_DELAY) \n\nasync def heavy_io_task_async(idx):\n    # 非阻塞 IO，控制权交还给 Event Loop，\n    # 仅仅是在 epoll/kqueue 注册了一个事件\n    await asyncio.sleep(IO_DELAY)\n\ndef run_threading():\n    start = time.perf_counter()\n    threads = []\n    for i in range(TASK_COUNT):\n        t = threading.Thread(target=heavy_io_task_sync, args=(i,))\n        t.start()\n        threads.append(t)\n    \n    for t in threads:\n        t.join()\n    print(f\"[Threading] Completed {TASK_COUNT} tasks in {time.perf_counter() - start:.4f}s\")\n    # 代价：创建了 50 个 OS 线程，上下文切换开销大，内存占用高 (每个线程默认栈大小 ~8MB)\n\nasync def run_asyncio():\n    start = time.perf_counter()\n    tasks = [heavy_io_task_async(i) for i in range(TASK_COUNT)]\n    # 所有的任务在一个 OS 线程内完成，无内核态切换\n    await asyncio.gather(*tasks)\n    print(f\"[Asyncio]   Completed {TASK_COUNT} tasks in {time.perf_counter() - start:.4f}s\")\n\nif __name__ == \"__main__\":\n    print(f\"--- Benchmarking IO Concurrency (Tasks: {TASK_COUNT}) ---\")\n    run_threading()\n    asyncio.run(run_asyncio())\n\n\"\"\"\n预期输出结果 (Trade-off 显而易见):\n--- Benchmarking IO Concurrency (Tasks: 50) ---\n[Threading] Completed 50 tasks in 1.0xxx s (加上显著的线程创建和调度开销)\n[Asyncio]   Completed 50 tasks in 1.00xx s (几乎仅受限于最慢的那个 IO)\n\"\"\"\n\n</code></pre>\n<h3 id=\"14-总结\">1.4. 总结</h3>\n<p>Python 不快，但它让“快”变得容易访问。接下来我们将深入探讨 Python 内存管理的至暗时刻： <strong>引用计数机制 (Reference Counting) 与垃圾回收 (GC) 的代际假说</strong>，并分析为何在某些高性能场景下，我们需要手动干预这一机制以避免 \"Stop-the-World\"。</p>\n<h2 id=\"2-协议层显式的控制-explicit-resource-management\">2. 协议层——显式的控制 (Explicit Resource Management)</h2>\n<p>如果说 C++ 的哲学是“你没有调用的东西就不需要付出代价”，那么 Python 的哲学则是“为了开发效率，你必须接受运行时开销”。在资源管理和控制流这一层，这种 Trade-off 表现得淋漓尽致。</p>\n<h3 id=\"21-raii-的-python-映射从隐式析构到显式上下文\">2.1. RAII 的 Python 映射：从隐式析构到显式上下文</h3>\n<p>在 C++ 中，RAII (Resource Acquisition Is Initialization) 是资源管理的黄金法则。我们依赖栈对象的确定性生命周期：当 <code>std::lock_guard</code> 离开作用域时，析构函数 <code>~lock_guard()</code> 会自动释放互斥锁。这一切都发生在编译期确定的汇编指令中，零运行时开销。</p>\n<p>但在 Python 中，你面对的是一个带 GC 的运行时。<strong>对象的生命周期与作用域是解耦的</strong>。<br />\n当你写下 <code>f = open(\"file.txt\")</code> 后，即使函数返回，<code>f</code> 指向的 <code>PyObject</code> 也可能因为引用计数未归零（例如被闭包捕获）或是处于循环引用中等待 GC 扫描，而迟迟不调用 <code>__del__</code>。</p>\n<p><strong>底层的真相：</strong> 依赖 <code>__del__</code> 管理文件句柄或数据库连接是系统编程中的自杀行为。你无法预测 GC 何时发生（Stop-the-World），这意味着你的文件描述符 (fd) 可能会被耗尽。</p>\n<p>为了解决这个问题，Python 引入了 <strong>上下文管理器协议 (Context Manager Protocol)</strong>——即 <code>with</code> 语句。</p>\n<h4 id=\"211-协议解构__enter__-与-__exit__\">2.1.1. 协议解构：<code>__enter__</code> 与 <code>__exit__</code></h4>\n<p><code>with</code> 语句本质上是编译器注入的 <code>try...finally</code> 块的语法糖，但它将资源管理的逻辑封装到了对象内部。</p>\n<ul>\n<li><strong><code>__enter__(self)</code></strong>: 对应 C++ 的构造逻辑。分配资源，返回句柄。</li>\n<li><strong><code>__exit__(self, exc_type, exc_val, exc_tb)</code></strong>: 对应 C++ 的析构逻辑。无论代码块是正常结束还是抛出异常，VM 都会强制跳转到这里。</li>\n</ul>\n<p><strong>代码实现：手写一个原子级锁卫士</strong></p>\n<p>让我们用 Python 实现一个类似 C++ <code>std::lock_guard</code> 的机制。注意看 <code>__exit__</code> 如何处理异常传播——这是 C++ 析构函数通常极力避免的（析构抛出异常会导致 <code>std::terminate</code>），而在 Python 中却是控制流的一部分。</p>\n<pre><code class=\"language-python\">import threading\nfrom types import TracebackType\nfrom typing import Optional, Type\n\nclass ScopedLock:\n    \"\"\"\n    模拟 C++ std::lock_guard 的 RAII 行为。\n    底层对应 opcode: SETUP_WITH -&gt; ... -&gt; WITH_EXCEPT_START / CALL_FUNCTION (__exit__)\n    \"\"\"\n    __slots__ = ('_lock',) # 内存优化：禁止 __dict__，仅分配指针大小的内存\n\n    def __init__(self, lock: threading.Lock):\n        self._lock = lock\n\n    def __enter__(self):\n        # 对应 lock.acquire()，阻塞直到获得锁\n        # 返回值绑定到 with ... as target 的 target\n        self._lock.acquire()\n        return self \n\n    def __exit__(self, \n                 exc_type: Optional[Type[BaseException]], \n                 exc_val: Optional[BaseException], \n                 exc_tb: Optional[TracebackType]):\n        # 对应 lock.release()\n        # 这是一个确定性的清理点，不依赖 GC\n        self._lock.release()\n        \n        # Trade-off: \n        # 如果返回 True，异常被吞噬（类似 catch {...}）。\n        # 如果返回 False 或 None，异常继续向上传播（Rethrow）。\n        if exc_type:\n            print(f\"[System Logic] Detecting Unwind: {exc_type.__name__}\")\n            # 这里可以选择处理异常，或者让它继续导致栈展开\n        return False\n\n# Usage\nlock = threading.Lock()\nwith ScopedLock(lock):\n    # Critical Section\n    print(\"In Critical Section\")\n    # 即使这里发生 1/0 异常，_lock.release() 依然会被精准执行\n\n</code></pre>\n<p>从字节码角度看，<code>with</code> 语句生成了 <code>SETUP_WITH</code> 指令，它将 <code>__exit__</code> 方法压入<strong>运行时栈 (Evaluation Stack)</strong>。这比 C++ 的编译器静态插入析构调用要重得多，但它赋予了运行时动态处理异常的灵活性。</p>\n<h3 id=\"22-状态机的魔法生成器-generators-与栈帧持久化\">2.2. 状态机的魔法：生成器 (Generators) 与栈帧持久化</h3>\n<p>在 Java 中，如果你想实现一个惰性迭代器（Iterator），你通常需要定义一个类，维护 <code>currentIndex</code> 状态，并实现 <code>hasNext()</code> 和 <code>next()</code>。这是一种<strong>显式的状态机</strong>维护。</p>\n<p>Python 的 Generator 则引入了一种更高阶的抽象：<strong>隐式状态机</strong>，或者更准确地说，<strong>用户态的栈帧挂起</strong>。</p>\n<h4 id=\"221-核心差异c-栈-vs-python-栈\">2.2.1. 核心差异：C 栈 vs. Python 栈</h4>\n<p>理解 Generator 的关键在于理解 Python 的函数调用模型：</p>\n<ol>\n<li><strong>C Stack (系统栈):</strong> Python 解释器（C程序）自身的函数调用栈。</li>\n<li><strong>Python Stack (虚拟栈):</strong> Python 代码执行时的栈帧 (<code>PyFrameObject</code>) 链表。</li>\n</ol>\n<p>关键点来了：<strong><code>PyFrameObject</code> 是分配在堆（Heap）上的对象</strong>。</p>\n<p>当你调用一个普通函数时，Python 创建一个 Frame，执行完后销毁。<br />\n但当你调用一个 Generator 函数时：</p>\n<ol>\n<li>Python 创建一个 Frame。</li>\n<li>遇到 <code>yield</code> 关键字时，解释器<strong>暂停</strong>该 Frame 的执行。</li>\n<li><strong>保存指令指针 (f_lasti)</strong>：记录当前执行到了哪条字节码。</li>\n<li><strong>保存操作数栈</strong>：记录当前的临时变量。</li>\n<li>将控制权返回给调用者，但<strong>不销毁该 Frame</strong>。</li>\n</ol>\n<p>这意味着，Generator 本质上是一个<strong>逃逸了生命周期的栈帧</strong>。</p>\n<h4 id=\"222-代码实现窥探挂起的内核\">2.2.2. 代码实现：窥探挂起的内核</h4>\n<p>我们可以通过 <code>inspect</code> 模块直接观察这个“僵尸”栈帧的内部状态。这在 C++ 中需要 GDB 才能做到，而在 Python 中，这是语言特性的一部分。</p>\n<pre><code class=\"language-python\">import inspect\n\ndef stateful_execution():\n    \"\"\"\n    一个简单的生成器，演示栈帧的挂起与恢复。\n    \"\"\"\n    x = 10          # 局部变量，存储在 f_locals\n    yield x         # 第一次挂起：保存 IP，返回 10\n    \n    x += 5\n    y = \"System\"\n    yield x + 10    # 第二次挂起：返回 25\n    \n    return \"EOF\"    # 抛出 StopIteration\n\n# 1. 创建生成器对象，此时函数体内的代码一行都还没执行\ngen = stateful_execution()\n\n# 2. 第一次激活\nval1 = next(gen)\nprint(f\"Yielded: {val1}\")\n\n# --- Hardcore Inspection ---\n# 获取生成器关联的栈帧对象 (PyFrameObject)\nframe = gen.gi_frame\n\nprint(f\"\\n[Frame Inspection]\")\nprint(f\"Instruction Pointer (f_lasti): {frame.f_lasti}\") # 当前字节码偏移量\nprint(f\"Local Variables (f_locals):  {frame.f_locals}\") # {'x': 10}\n\n# 3. 恢复执行\n# 解释器读取 frame.f_lasti，恢复 CPU 寄存器状态，继续执行\nval2 = next(gen)\nprint(f\"\\nYielded: {val2}\")\nprint(f\"Local Variables Updated:     {gen.gi_frame.f_locals}\") # {'x': 15, 'y': 'System'}\n\n</code></pre>\n<h4 id=\"223-进化意义从迭代器到协程\">2.2.3. 进化意义：从迭代器到协程</h4>\n<p>这种机制的深远意义在于，它让<strong>异步编程</strong>成为可能。</p>\n<p>如果 <code>yield</code> 不仅能产出值，还能接收值（通过 <code>gen.send()</code>），那么这个函数就变成了一个可以通过消息传递进行协作的<strong>协程 (Coroutine)</strong>。</p>\n<ul>\n<li><strong>Java Iterator:</strong> 仅仅是数据的生产者。</li>\n<li><strong>Python Generator:</strong> 是一个拥有独立栈空间、可以暂停、可以恢复、可以交互的<strong>微线程</strong>。</li>\n</ul>\n<p>在 Python 3.5 之前，<code>@asyncio.coroutine</code> 正是利用 <code>yield from</code> 实现的。而在 Python 3.5 之后，<code>async/await</code> 只是将这种基于生成器的各种黑魔法包装成了原生语法，底层的 <code>PyFrameObject</code> 调度逻辑依然是一脉相承的。</p>\n<p><strong>Trade-off 分析：</strong></p>\n<ul>\n<li><strong>性能损耗：</strong> 每次 <code>yield</code> 和恢复确实比简单的 C 指针递增要慢（涉及 Python 对象存取）。</li>\n<li><strong>架构收益：</strong> 你用同步的代码逻辑（线性的 <code>for</code>, <code>while</code>），写出了极其复杂的异步流式处理逻辑。在处理数以亿计的 AI Token 流时，这种内存友好且逻辑清晰的抽象，是无价的。</li>\n</ul>\n<h2 id=\"3-枷锁层被动的调度-the-reality-of-gil\">3. 枷锁层——被动的调度 (The Reality of GIL)</h2>\n<h3 id=\"31-内存安全的权衡c-视角下的-ob_refcnt\">3.1. 内存安全的权衡：C++ 视角下的 <code>ob_refcnt</code></h3>\n<p>在 C++ 中，我们使用 <code>std::shared_ptr</code> 来管理引用计数。为了保证线程安全，<code>std::shared_ptr</code> 的引用计数操作（<code>incref</code>/<code>decref</code>）内部必须使用原子操作（Atomic Operations），通常对应汇编指令 <code>LOCK XADD</code>。</p>\n<p><strong>Trade-off 的核心：</strong><br />\n原子操作不是免费的。在多核 CPU 上，原子操作会导致缓存一致性流量（Cache Coherence Traffic）激增，这比普通的内存读写要慢一个数量级。</p>\n<p>Python 的设计者面临一个选择：</p>\n<ol>\n<li><strong>细粒度锁（Fine-grained Locking）：</strong> 让每个 <code>PyObject</code> 自带一个 <code>std::mutex</code>，或者使用原子操作更新引用计数。</li>\n</ol>\n<ul>\n<li><em>后果：</em> 单线程性能下降 30%~50%（历史实测数据）。因为即使在单线程下，你也必须支付原子操作的昂贵开销。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>巨锁（Coarse-grained Locking）：</strong> 引入一把全局的大锁（GIL），保护整个解释器状态。</li>\n</ol>\n<ul>\n<li><em>后果：</em> 多核并发成为泡影，多线程沦为并发（Concurrency）而非并行（Parallelism）。</li>\n<li><em>收益：</em> 单线程极其高效（无锁开销），C 扩展编写极其简单（默认不需要考虑线程安全）。</li>\n</ul>\n<p>Python 选择了后者。GIL 本质上是一个 <strong>互斥量 (Mutex)</strong>，它保护的不是你的变量，而是 <code>PyObject</code> 结构体中的 <code>ob_refcnt</code> 字段以及解释器的全局状态。</p>\n<blockquote>\n<p><strong>C++ 程序员的顿悟：</strong><br />\nGIL 的存在，是为了让 CPython 的 <code>malloc</code> 和 <code>free</code>（即 <code>Py_INCREF</code>/<code>Py_DECREF</code>）在不使用原子指令的情况下，依然能保持内存的一致性。</p>\n</blockquote>\n<h3 id=\"32-竞态条件的真相原子性的幻觉\">3.2. 竞态条件的真相：原子性的幻觉</h3>\n<p>很多初学者误以为：“既然有 GIL，同一时刻只有一个线程在跑，那我就不需要锁了。”<br />\n这是大错特错的。</p>\n<p><strong>GIL 保证的是字节码（Bytecode）执行的原子性，而不是业务逻辑的原子性。</strong></p>\n<p>操作系统（或者 Python 解释器内部的调度器）可以在<strong>任意两个字节码之间</strong>进行上下文切换。如果你的业务逻辑由多条字节码组成，那么在中间被切走就是必然发生的。</p>\n<h4 id=\"321-代码实现解剖-n--1\">3.2.1. 代码实现：解剖 <code>n += 1</code></h4>\n<p>在 C++ 中，<code>n++</code> 通常也不是原子的（除非用 <code>std::atomic&lt;int&gt;</code>），它对应 <code>Read-Modify-Write</code> 三个步骤。Python 中亦然，但更加复杂。</p>\n<p>让我们用 <code>dis</code> 模块来看看 <code>n += 1</code> 在底层到底发生了什么。</p>\n<pre><code class=\"language-python\">import dis\nimport threading\n\nn = 0\n\ndef race_condition():\n    global n\n    # 这一行看似简单的代码，在 VM 眼里是 4 条指令\n    n += 1\n\nprint(f\"--- Bytecode Disassembly for 'n += 1' ---\")\ndis.dis(race_condition)\n\n</code></pre>\n<p><strong>输出分析（汇编视角）：</strong></p>\n<pre><code class=\"language-text\">  7           0 LOAD_GLOBAL              0 (n)    &lt;-- Step 1: 读取 n 到栈顶\n              2 LOAD_CONST               1 (1)    &lt;-- Step 2: 压入常数 1\n              4 INPLACE_ADD                       &lt;-- Step 3: 执行加法\n              6 STORE_GLOBAL             0 (n)    &lt;-- Step 4: 写回 n\n\n</code></pre>\n<p><strong>灾难发生的瞬间：</strong></p>\n<ol>\n<li><strong>线程 A</strong> 执行了 <code>LOAD_GLOBAL</code>，拿到了 <code>n=0</code>，放入自己的栈帧。</li>\n<li><strong>GIL 释放！</strong> (可能是时间片到了，Python 3.2+ 默认 <code>sys.getswitchinterval()</code> 为 5ms)。</li>\n<li><strong>线程 B</strong> 获得 GIL，执行完整的 <code>n += 1</code>。此时内存中的 <code>n</code> 变成了 1。</li>\n<li><strong>GIL 重新被线程 A 获取。</strong></li>\n<li><strong>线程 A</strong> 继续执行 <code>INPLACE_ADD</code>。注意，它栈里的 <code>n</code> 依然是 0（因为它是从自己的栈帧中读取操作数，而不是重新去内存读）。</li>\n<li><strong>线程 A</strong> 计算 <code>0 + 1 = 1</code>。</li>\n<li><strong>线程 A</strong> 执行 <code>STORE_GLOBAL</code>，把 <code>1</code> 写入内存，覆盖了线程 B 的结果。</li>\n</ol>\n<p><strong>结果：</strong> 两个线程各加了一次，结果应该是 2，但实际是 1。这就是典型的 <strong>Lost Update</strong> 问题。</p>\n<h4 id=\"322-多核时代的护航效应-the-convoy-effect\">3.2.2. 多核时代的“护航效应” (The Convoy Effect)</h4>\n<p>在单核时代，GIL 只是简单的分时复用。但在多核 CPU 上，情况会变得更糟。</p>\n<p>当持有 GIL 的线程 A 释放锁（例如因为 I/O 或强制切换）时，OS 可能会同时唤醒线程 B、C 和 D。它们会在不同的 CPU 核心上醒来，疯狂争抢这把唯一的锁。结果只有 B 抢到了，C 和 D 争抢失败，再次被 OS 挂起。</p>\n<p>这种 <strong>“唤醒-争抢-失败-挂起”</strong> 的循环会导致严重的 CPU 抖动 (Thrashing)。这也是为什么在计算密集型任务中，Python 多线程往往比单线程还要慢——我们不仅没有利用多核，反而浪费了大量的 CPU 周期在 OS 的调度开销上。</p>\n<h4 id=\"323-为什么必须使用-threadinglock\">3.2.3. 为什么必须使用 <code>threading.Lock</code>？</h4>\n<p>在 Python 中使用 <code>threading.Lock</code>，实际上是在应用层引入了第二把锁。</p>\n<pre><code class=\"language-python\">lock = threading.Lock()\n\ndef safe_increment():\n    global n\n    # 申请锁：如果拿不到，线程进入阻塞状态，GIL 自动释放给别人\n    with lock:\n        # 临界区 (Critical Section)\n        # 即使 GIL 在这里释放，其他线程也无法进入这个代码块\n        # 因为它们拿不到应用层的 lock\n        n += 1\n\n</code></pre>\n<p><strong>底层逻辑：</strong></p>\n<ul>\n<li><strong>GIL</strong> 保护的是 <code>ob_refcnt</code> 不乱套（防止解释器崩溃）。</li>\n<li><strong>threading.Lock</strong> 保护的是 <code>n</code> 的值符合预期（防止业务逻辑错误）。</li>\n</ul>\n<h3 id=\"33-io-释放与-cpu-密集型的死局\">3.3. I/O 释放与 CPU 密集型的死局</h3>\n<p>我们常说“Python 多线程适合 I/O 密集型”，其底层机理在于：</p>\n<p>当 Python 执行系统调用（如 <code>read()</code>, <code>write()</code>, <code>recv()</code>, <code>sleep()</code>）时，C 代码会在调用阻塞的 C 函数之前，<strong>主动释放 GIL</strong>（调用 <code>Py_BEGIN_ALLOW_THREADS</code> 宏）。</p>\n<pre><code class=\"language-c\">/* CPython 源码伪代码 (socket module) */\nstatic PyObject *\nsock_recv(PySocketSockObject *s, PyObject *args)\n{\n    // ... 解析参数 ...\n    \n    // 释放 GIL，允许其他 Python 线程运行\n    Py_BEGIN_ALLOW_THREADS\n    \n    // 阻塞的系统调用，此时 CPU 不在 Python 手里\n    count = recv(s-&gt;sock_fd, buffer, len, flags);\n    \n    // 重新获取 GIL，准备返回 Python 对象\n    Py_END_ALLOW_THREADS\n    \n    // ... 包装结果 ...\n    return result;\n}\n\n</code></pre>\n<p>这意味着，当一个线程在等网络包时，另一个线程可以拿到 GIL 去跑 Python 代码。这就是为什么在爬虫、Web 服务中，Python 的多线程依然有效。</p>\n<p>但如果是 <strong>CPU 密集型</strong>（如图像处理、矩阵计算），线程不会主动释放 GIL，只能等待解释器强制切换（Check Interval）。这不仅无法利用多核，反而因为频繁的锁争抢（Lock Contention）和上下文切换，导致多线程比单线程还要慢！</p>\n<h2 id=\"4-进化层主动的协作-cooperative-concurrency\">4. 进化层——主动的协作 (Cooperative Concurrency)</h2>\n<h3 id=\"41-从生成器到协程无栈的胜利与代价\">4.1. 从生成器到协程：无栈的胜利与代价</h3>\n<p>在 C++20 引入 Coroutines 之前，我们习惯用状态机手写回调。Python 的协程本质上就是<strong>编译器自动生成的有限状态机</strong>。</p>\n<h4 id=\"411-核心对决python-stackless-vs-go-stackful\">4.1.1. 核心对决：Python (Stackless) vs. Go (Stackful)</h4>\n<ul>\n<li>\n<p><strong>Go (Goroutine):</strong><br />\nGo 运行时为每个 Goroutine 分配一个<strong>真实的、可增长的栈</strong>（初始约 2KB）。当 Goroutine 阻塞时，Go 的调度器保存当前的寄存器状态（SP, PC 等）到该栈中，然后切换到另一个 Goroutine。这几乎等同于用户态线程。</p>\n</li>\n<li>\n<p><em>优点：</em> 此时，代码是同步写的，底层是异步跑的。你不需要 <code>await</code>，因为调度器是隐式的。</p>\n</li>\n<li>\n<p><em>缺点：</em> 每个 Goroutine 都有内存开销（虽小但有），且需要复杂的运行时调度器。</p>\n</li>\n<li>\n<p><strong>Python (Coroutine):</strong><br />\nPython 的协程被称为 <strong>无栈协程 (Stackless)</strong>。但这并不意味着它没有栈，而是指它 <strong>不保留 C 语言层面的系统调用栈</strong>。<br />\n当你 <code>await</code> 时，Python 仅仅是将当前的虚拟机栈帧 (<code>PyFrameObject</code>，一个分配在堆上的对象) 挂起，并将 C 栈回退（Unwind）到 Event Loop。相比之下，Go 的 Goroutine 是 <strong>有栈的 (Stackful)</strong>，它拥有独立的、可动态扩容的连续内存空间（初始约 2KB），能保存完整的调用链路状态。</p>\n</li>\n</ul>\n<h4 id=\"412-异步的传染性-function-coloring\">4.1.2. 异步的“传染性” (Function Coloring)</h4>\n<p>这就是为什么 Python 的异步具有<strong>传染性</strong>：<br />\n如果函数 A 调用了异步函数 B (<code>await B()</code>)，那么 A 自身必须变成异步函数 (<code>async def A()</code>)。</p>\n<p><strong>底层逻辑：</strong><br />\n因为 Python 没有独立的协程栈，它无法在普通函数的 C 栈帧中间暂停。只有被标记为 <code>async</code> 的函数（即生成器），才具备“暂停-恢复”的字节码指令 (<code>YIELD_FROM</code> / <code>SEND</code>)。</p>\n<p>这是一个巨大的 Trade-off：</p>\n<ul>\n<li><strong>牺牲：</strong> 开发体验的割裂（同步代码无法直接复用异步库）。</li>\n<li><strong>换取：</strong> 极致的轻量级。创建一个 Python 协程几乎只消耗一个 Python 对象的内存，且切换开销仅为一次函数调用，完全不涉及寄存器保存或复杂的栈拷贝。</li>\n</ul>\n<h3 id=\"42-event-loop-的内核reactor-模式的-python-实现\">4.2. Event Loop 的内核：Reactor 模式的 Python 实现</h3>\n<p>剥去 <code>asyncio</code> 华丽的封装，其核心只是一个死循环，不断查询操作系统内核：“哪些文件描述符 (fd) 准备好了？”</p>\n<p>这正是经典的 <strong>Reactor 模式</strong>。</p>\n<p>在 Linux 上，这对应 <code>epoll_wait</code>；在 macOS/BSD 上，是 <code>kevent</code>；在 Windows 上，是 <code>IOCP</code>。</p>\n<h4 id=\"421-代码实现手写一个-mini-asyncio\">4.2.1. 代码实现：手写一个 mini-asyncio</h4>\n<p>为了证明 <code>asyncio</code> 没有任何黑魔法，我们将绕过 <code>asyncio</code> 库，直接使用 <code>selectors</code> 模块（对 <code>epoll</code>/<code>kqueue</code> 的低级封装）来实现一个异步运行时。</p>\n<p><strong>C++ 开发者请注意：</strong> 下面的代码展示了如何将“回调地狱”通过生成器压平成“同步外观”。</p>\n<pre><code class=\"language-python\">import selectors\nimport socket\nimport time\nfrom collections import deque\n\n# 1. 全局事件循环 (The Reactor)\nselector = selectors.DefaultSelector()\ntask_queue = deque() # 就绪任务队列\n\nclass Future:\n    \"\"\"\n    对应 C++ std::future 或 JavaScript Promise。\n    它是异步操作结果的占位符。\n    \"\"\"\n    def __init__(self):\n        self.result = None\n        self._callbacks = []\n\n    def set_result(self, value):\n        self.result = value\n        for cb in self._callbacks:\n            cb(self)\n\n    def __await__(self):\n        # 魔法所在：yield self 告诉 Task \"我还没好，请挂起\"\n        yield self \n        return self.result\n\ndef async_socket_read(sock):\n    \"\"\"\n    一个模拟的低级异步 socket 读取。\n    \"\"\"\n    f = Future()\n\n    def on_readable():\n        f.set_result(sock.recv(4096))\n        # 读取完毕，从 epoll 中注销\n        selector.unregister(sock)\n\n    # 注册到 epoll/kqueue：当 sock 可读时，调用 on_readable\n    # C++ 对应: epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;event)\n    selector.register(sock, selectors.EVENT_READ, on_readable)\n    \n    # 立即返回 Future，不阻塞\n    return f\n\nclass Task:\n    \"\"\"\n    驱动协程执行的容器。\n    类似于 asyncio.Task。\n    \"\"\"\n    def __init__(self, coro):\n        self.coro = coro\n        self.step() # 启动协程\n\n    def step(self, future=None):\n        try:\n            # 恢复协程执行：send(result)\n            if future is None:\n                next_future = self.coro.send(None)\n            else:\n                next_future = self.coro.send(future.result)\n            \n            # 协程遇到了 await，返回了一个 Future\n            # 我们给这个 Future 加个回调，一旦它完成了，就继续 step()\n            next_future._callbacks.append(self.step)\n            \n        except StopIteration:\n            # 协程执行完毕\n            pass\n\n# --- 业务逻辑 (User Code) ---\n# 注意：async def 本质上是生成器工厂\nasync def fetch_url(url):\n    # 模拟建立 socket\n    sock = socket.socket()\n    sock.setblocking(False)\n    try:\n        sock.connect(('example.com', 80))\n    except BlockingIOError:\n        pass # 正常现象\n    \n    # 发送 HTTP 请求\n    req = f\"GET / HTTP/1.0\\r\\nHost: example.com\\r\\n\\r\\n\".encode()\n    # 简化版：这里其实也应该 await write\n    sock.send(req) \n\n    print(f\"[{url}] Waiting for data...\")\n    \n    # 关键点：await 挂起当前栈帧，交出控制权\n    # 此时，Event Loop 可以去处理其他 Task\n    data = await async_socket_read(sock)\n    \n    print(f\"[{url}] Received {len(data)} bytes\")\n\n# --- 驱动层 (Event Loop Driver) ---\ndef run_loop():\n    # 创建两个并发任务\n    Task(fetch_url(\"Task-A\"))\n    Task(fetch_url(\"Task-B\"))\n\n    print(\"--- Event Loop Started ---\")\n    while True:\n        # 1. 阻塞等待 IO 事件 (epoll_wait)\n        # 如果没有 IO 就绪，CPU 使用率为 0\n        events = selector.select()\n        \n        # 2. 处理事件 (Callback Dispatch)\n        for key, mask in events:\n            callback = key.data\n            callback()\n        \n        # 简单的退出条件\n        if not selector.get_map():\n            break\n    print(\"--- Event Loop Finished ---\")\n\nif __name__ == \"__main__\":\n    run_loop()\n\n</code></pre>\n<h4 id=\"422-深度解析控制流的翻转\">4.2.2. 深度解析：控制流的翻转</h4>\n<ol>\n<li><strong>Callback (C 风格):</strong> 所有的逻辑被打散在 <code>on_readable</code>, <code>on_writable</code> 等回调函数中，状态维护极其痛苦（必须显式传递 context 指针）。</li>\n<li><strong>Coroutine (Python 风格):</strong></li>\n</ol>\n<ul>\n<li><code>await</code> 关键字将 <code>async_socket_read</code> 的 <code>Future</code> 抛给 Event Loop。</li>\n<li>Event Loop 将 <code>Task.step</code> 注册为回调。</li>\n<li>当 <code>epoll</code> 唤醒时，通过回调触发 <code>Task.step</code>。</li>\n<li><code>Task.step</code> 调用 <code>coro.send()</code>，<strong>恢复</strong> 之前挂起的 <code>fetch_url</code> 栈帧。</li>\n</ul>\n<p><strong>对 C++ 程序员的启示：</strong><br />\nPython 的 <code>asyncio</code> 实际上是在单线程内实现了一个<strong>非抢占式操作系统</strong>。<code>Task</code> 是进程，<code>Future</code> 是系统调用，而 <code>Event Loop</code> 就是内核调度器。</p>\n<h2 id=\"5-破局层打破边界-extending-with-c\">5. 破局层——打破边界 (Extending with C++)</h2>\n<p>在前几章中，我们所有的优化都在 Python 虚拟机的围墙之内：无论是 <code>asyncio</code> 的用户态调度，还是 <code>multiprocessing</code> 的进程间通信，本质上都是在规避 GIL。</p>\n<p>但在这一章，我们要正面<strong>击穿</strong>这堵墙。我们将编写 C++ 扩展，主动释放 GIL，让 Python 线程退化为单纯的 C++ 线程，从而压榨出 CPU 的每一个时钟周期。</p>\n<p>当你的 Profiler（性能分析器）显示瓶颈不再是 IO 等待，而是 CPU 的 <code>ALU</code>（算术逻辑单元）满载时，任何 Python 层面的优化（包括 PyPy）都是隔靴搔痒。此时，唯一的出路是将计算密集型内核下沉到 C++。</p>\n<h3 id=\"51-释放-gil-的艺术从持有者到旁观者\">5.1. 释放 GIL 的艺术：从持有者到旁观者</h3>\n<p>我们在第三章提到，Python 解释器是一个巨大的状态机，GIL 保护着这个状态机的一致性。但是，<strong>如果你的代码不涉及任何 Python 对象（PyObject）的操作，你就不需要 GIL。</strong></p>\n<p>比如：矩阵乘法、图像编解码、复杂的数值积分。这些操作只需要原始的内存指针（<code>double*</code>, <code>uint8_t*</code>）。</p>\n<h4 id=\"511-协议py_begin_allow_threads\">5.1.1. 协议：<code>Py_BEGIN_ALLOW_THREADS</code></h4>\n<p>在 C-API 层面，Python 提供了两个宏来手动控制 GIL：</p>\n<ol>\n<li><strong><code>Py_BEGIN_ALLOW_THREADS</code></strong>:</li>\n</ol>\n<ul>\n<li>保存当前线程的上下文（Thread State）。</li>\n<li><strong>释放互斥锁 (Release Mutex)</strong>。</li>\n<li>此时，其他 Python 线程可以抢占 GIL 并执行字节码。</li>\n<li><strong>警告：</strong> 在此宏之后，严禁访问任何 <code>PyObject</code>，否则会导致立即的 Segfault 或更隐蔽的堆损坏。</li>\n</ul>\n<ol start=\"2\">\n<li><strong><code>Py_END_ALLOW_THREADS</code></strong>:</li>\n</ol>\n<ul>\n<li><strong>阻塞等待</strong>，直到重新获得互斥锁。</li>\n<li>恢复线程上下文。</li>\n<li>继续处理 Python 对象（如将 C++ 结果包装成 <code>PyFloat</code>）。</li>\n</ul>\n<p>这就像是当你（C++ 代码）需要去进行一场漫长的闭关修炼（繁重计算）时，你主动交出了令牌（GIL），告诉解释器：“你们先玩，我算完了再回来排队。”</p>\n<h3 id=\"52-实战-pybind11raii-风格的锁释放\">5.2. 实战 Pybind11：RAII 风格的锁释放</h3>\n<p>直接写 C-API 极其繁琐且容易出错（引用计数地狱）。现代 C++ 开发者应首选 <code>pybind11</code>。它利用 C++ 的 RAII 机制，将 GIL 的释放封装得优雅且安全。</p>\n<h4 id=\"521-场景多线程蒙特卡洛模拟-cpu-bound\">5.2.1. 场景：多线程蒙特卡洛模拟 (CPU Bound)</h4>\n<p>假设我们需要计算  的近似值，这是一个纯计算任务。</p>\n<p><strong>C++ Extension (<code>cpu_bound.cpp</code>):</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;pybind11/pybind11.h&gt;\n#include &lt;random&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nnamespace py = pybind11;\n\n// 纯 C++ 逻辑：不依赖任何 Python 头文件\ndouble monte_carlo_pi(size_t samples) {\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_real_distribution&lt;&gt; dis(0.0, 1.0);\n\n    size_t inside_circle = 0;\n    for (size_t i = 0; i &lt; samples; ++i) {\n        double x = dis(gen);\n        double y = dis(gen);\n        if (x * x + y * y &lt;= 1.0) {\n            inside_circle++;\n        }\n    }\n    return 4.0 * inside_circle / samples;\n}\n\n// 包装层\ndouble heavy_computation(size_t samples) {\n    // 1. 进入 C++ 世界，持有 GIL\n    \n    // 2. 释放 GIL (RAII)\n    // 构造函数调用 PyEval_SaveThread()，析构函数调用 PyEval_RestoreThread()\n    // 在这个作用域内，Python 解释器可以并发运行其他 Python 线程！\n    py::gil_scoped_release release; \n\n    // 3. 执行繁重的 CPU 计算\n    // 此时 OS 可以在多核上并行调度这个线程\n    double result = monte_carlo_pi(samples);\n\n    // 4. 离开作用域，自动重新获取 GIL\n    return result; \n}\n\nPYBIND11_MODULE(fast_calc, m) {\n    m.def(\"compute_pi\", &amp;heavy_computation, \"Calculate Pi without GIL\");\n}\n\n</code></pre>\n<h4 id=\"522-python-侧的真正并行\">5.2.2. Python 侧的真正并行</h4>\n<p>现在，我们回到 Python。有了 <code>py::gil_scoped_release</code>，Python 的 <code>threading</code> 模块将不再是“伪多线程”。</p>\n<pre><code class=\"language-python\">import threading\nimport time\nimport fast_calc # 我们编译好的 C++ 扩展\n\nSAMPLES = 10_000_000\nTHREAD_COUNT = 4\n\ndef worker():\n    # 当进入 fast_calc.compute_pi 内部时，\n    # GIL 被释放，该线程变成了一个纯粹的 OS 线程 (Native Thread)\n    # 它可以跑满一个物理 CPU 核心\n    pi = fast_calc.compute_pi(SAMPLES)\n\ndef run_benchmark():\n    start = time.perf_counter()\n    threads = []\n    \n    # 启动 4 个线程\n    for _ in range(THREAD_COUNT):\n        t = threading.Thread(target=worker)\n        t.start()\n        threads.append(t)\n        \n    for t in threads:\n        t.join()\n        \n    end = time.perf_counter()\n    print(f\"Total time: {end - start:.4f}s\")\n\n# 结果预测：\n# 如果不释放 GIL：耗时约等于 sum(T_i)，因为是串行执行。\n# 释放 GIL 后：  耗时约等于 max(T_i)，实现真正的 4 倍加速 (Amdahl's Law 允许范围内)。\n\n</code></pre>\n<h3 id=\"53-数据传输的隐形税buffer-protocol-与内存布局\">5.3. 数据传输的隐形税：Buffer Protocol 与内存布局</h3>\n<p>释放 GIL 解决了<strong>计算</strong>的瓶颈，但如果你的数据还在 Python 堆上（比如一张 4K 图片），如何传给 C++？</p>\n<p>如果你简单地定义函数为 <code>void foo(std::vector&lt;double&gt; v)</code>，<code>pybind11</code> 会尽职尽责地遍历 Python 列表，解包每个 <code>PyFloatObject</code>，并发生<strong>深拷贝</strong>将数据复制到 C++ 的堆上。这不仅涉及巨大的 <code>malloc</code> 开销，还破坏了 CPU 缓存局部性。</p>\n<p><strong>解决方案：缓冲协议 (Buffer Protocol)</strong></p>\n<p>Python 的 <code>memoryview</code>、NumPy 的 <code>ndarray</code> 都实现了 Buffer Protocol。它允许 C++ 直接访问 Python 对象的底层内存块（Raw Buffer），实现 <strong>Zero-Copy</strong>。</p>\n<p>然而，这里隐藏着一个巨大的陷阱：<strong>内存连续性 (Contiguity)</strong>。</p>\n<p>Python 的切片操作（如 <code>img[:, ::2]</code>）是<strong>零拷贝</strong>的，它仅仅是修改了元数据中的 <strong>Strides (步长)</strong>，而不会重新排列内存。如果你直接把这个切片的指针拿来当成连续数组遍历，你会读到错误的数据，甚至引发 Segmentation Fault。</p>\n<p>因此，严谨的 C++ 扩展必须检查内存布局。</p>\n<h4 id=\"531-代码实现安全的高性能图像反色\">5.3.1. 代码实现：安全的高性能图像反色</h4>\n<pre><code class=\"language-cpp\">#include &lt;pybind11/pybind11.h&gt;\n#include &lt;pybind11/numpy.h&gt;\n#include &lt;stdexcept&gt;\n\nnamespace py = pybind11;\n\n// C++ 接收 NumPy 数组，零拷贝 (Zero-Copy)\n// 注意：py::array_t&lt;uint8_t&gt; 只是一个包装器，并不拥有数据的所有权\nvoid process_image(py::array_t&lt;uint8_t&gt; input_array) {\n    // 1. 请求缓冲区信息 (Buffer Info)\n    // 这会查询对象的 __buffer__ 接口\n    py::buffer_info buf = input_array.request();\n\n    // 2. 维度检查\n    if (buf.ndim != 2) {\n        throw std::runtime_error(\"Number of dimensions must be 2\");\n    }\n\n    // 3. [关键系统级检查] 内存布局验证\n    // Python 的切片可能产生不连续内存 (Non-contiguous Memory)。\n    // 只有当 Row Stride == Width * ElementSize 且 Col Stride == ElementSize 时，\n    // 我们才能将其视为一维线性数组处理。\n    auto expected_stride_row = buf.shape[1] * sizeof(uint8_t);\n    auto expected_stride_col = sizeof(uint8_t);\n\n    if (buf.strides[0] != expected_stride_row || buf.strides[1] != expected_stride_col) {\n        // 遇到这种情况，通常有两种选择：\n        // A. 抛出异常，强迫用户在 Python 端先调用 .copy() 或 np.ascontiguousarray()\n        // B. 在 C++ 端手动处理 strides（性能略低，但兼容性好）\n        // 这里为了演示极致性能，我们选择 A，拒绝处理非连续内存\n        throw std::runtime_error(\"Input array must be C-style contiguous (no slices allowed)\");\n    }\n\n    // 4. 获取裸指针 (Raw Pointer)\n    // 此时我们可以安全地像操作 C 数组一样操作它\n    uint8_t* ptr = static_cast&lt;uint8_t*&gt;(buf.ptr);\n    size_t rows = buf.shape[0];\n    size_t cols = buf.shape[1];\n    size_t total_elements = rows * cols;\n\n    // 5. 释放 GIL 并全速计算\n    // 这是一个纯粹的内存读写操作，不涉及任何 Python API\n    {\n        py::gil_scoped_release release;\n        \n        // 编译器现在的自动向量化 (Auto-Vectorization) 可以轻易优化这个循环\n        // 生成 SIMD 指令 (如 AVX2)\n        for (size_t i = 0; i &lt; total_elements; ++i) {\n            ptr[i] = 255 - ptr[i]; // 反色操作\n        }\n    }\n    // 作用域结束，自动重新获取 GIL\n}\n\nPYBIND11_MODULE(fast_img, m) {\n    m.def(\"process_image\", &amp;process_image, \"Invert image colors (Zero-Copy, release GIL)\");\n}\n\n</code></pre>\n<p><strong>Python 侧调用示例：</strong></p>\n<pre><code class=\"language-python\">import numpy as np\nimport fast_img\n\n# 创建一个 4K 图像 (3840x2160)\nimg = np.random.randint(0, 256, (2160, 3840), dtype=np.uint8)\n\n# Case 1: 正常调用 (内存连续)\n# 耗时：C++ 也就是毫秒级，Python 循环则需要数秒\nfast_img.process_image(img) \n\n# Case 2: 切片调用 (内存不连续)\n# slice = img[:, ::2] \n# fast_img.process_image(slice) \n# -&gt; RuntimeError: Input array must be C-style contiguous\n\n</code></pre>\n<p>通过这种方式，我们不仅利用了 C++ 的性能，还保证了系统的<strong>鲁棒性 (Robustness)</strong>。这才是系统架构师在处理跨语言互操作时应有的思维方式。</p>\n<h3 id=\"54-总结架构师的最终抉择\">5.4. 总结：架构师的最终抉择</h3>\n<p>至此，我们从底层的字节码（Generator）讲到了内存管理（Ref Counting），再到并发模型（Asyncio vs GIL），最后打破了语言的边界（C++ Extension）。</p>\n<p>作为一个系统级开发者，使用 Python 的最佳姿势并非把它当作“脚本”，而是把它当作<strong>胶水</strong>：</p>\n<ol>\n<li><strong>控制流 (Python):</strong> 处理复杂的业务逻辑、配置解析、REST API 编排。利用其动态特性和丰富的生态。</li>\n<li><strong>数据流 (C++/Rust):</strong> 处理繁重的计算、大规模内存操作、低延迟 IO。利用其对硬件的掌控力。</li>\n</ol>\n<p><strong>Python is slow, but your Architecture doesn't have to be.</strong></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-10 12:01</span>&nbsp;\n<a href=\"https://www.cnblogs.com/kaiux\">念风零壹</a>&nbsp;\n阅读(<span id=\"post_view_count\">3</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}