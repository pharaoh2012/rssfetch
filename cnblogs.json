{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "linux服务器静默安装Oracle26ai",
      "link": "https://www.cnblogs.com/liuziyi1/p/19558714",
      "published": "",
      "description": "<h2>\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/liuziyi1/p/19558714\" id=\"cb_post_title_url\" title=\"发布于 2026-01-31 17:45\">\n    <span>linux服务器静默安装Oracle26ai</span>\n    \n\n</a>\n\n\t\t</h2>\n\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>下载地址：<a href=\"https://www.oracle.com/database/technologies/oracle26ai-linux-downloads.html\" rel=\"noopener nofollow\" target=\"_blank\">https://www.oracle.com/database/technologies/oracle26ai-linux-downloads.html</a><br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<p>1.安装环境准备<br />\n1.1.查看物理内存<br />\n<code>[root@aiserver ~]# free -m</code><br />\n1.2.操作系统版本</p>\n<pre><code>[root@aiserver ~]#  cat /etc/redhat-release\n</code></pre>\n<p>1.3.操作系统内存</p>\n<pre><code>[root@aiserver ~]# df -h /dev/shm/\n</code></pre>\n<p>1.4.磁盘空间</p>\n<pre><code>[root@aiserver ~]# df -TH\n[root@aiserver ~]# df -h /tmp/\n[root@aiserver ~]# df -h /u01\n</code></pre>\n<p>1.5.查看系统架构</p>\n<pre><code>[root@aiserver ~]# uname -m\nx86_64\n</code></pre>\n<p><code>[root@aiserver ~]# cat /proc/version</code></p>\n<p>1.6.解析/etc/hosts</p>\n<pre><code>[root@aiserver ~]# hostname\naiserver\n\ncat &gt;&gt; /etc/hosts &lt;&lt; EOF\n192.168.1.1 aiserver\nEOF\n</code></pre>\n<p>1.7.关闭防火墙还有selinux</p>\n<pre><code>systemctl status firewalld.service\nsystemctl stop firewalld.service\nsystemctl disable firewalld.service\n</code></pre>\n<p><code>sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config</code></p>\n<p>2.创建用户和组</p>\n<h1 id=\"查看是否安装有oracle软件\">查看是否安装有Oracle软件</h1>\n<p><code>[root@aiserver ~]# more /etc/oraInst.loc</code></p>\n<h1 id=\"查看是否已存在相关用户组\">查看是否已存在相关用户组</h1>\n<pre><code>[root@aiserver ~]# grep oinstall /etc/group\n[root@aiserver ~]# grep dba /etc/group\n[root@aiserver ~]# grep oper /etc/group\n</code></pre>\n<pre><code>[root@aiserver ~]# /usr/sbin/groupadd -g 54321 oinstall\n[root@aiserver ~]# /usr/sbin/groupadd -g 54322 dba\n[root@aiserver ~]# /usr/sbin/groupadd -g 54323 oper\n[root@aiserver ~]# /usr/sbin/useradd -u 54321 -g oinstall -G dba,oper oracle\n</code></pre>\n<p>--修改密码为oracle<br />\n<code>[root@aiserver ~]# passwd oracle</code></p>\n<p>3.创建工作的目录</p>\n<pre><code>[root@aiserver ~]# mkdir -p /u01/app/oracle\n[root@aiserver ~]# chown -R oracle:oinstall /u01/\n[root@aiserver ~]# chmod -R 775 /u01/app/oracle\n</code></pre>\n<p>4.配置Oracle的环境变量</p>\n<pre><code>[oracle@aiserver ~]$ vi .bash_profile\n\nexport ORACLE_BASE=/u01/app/oracle\nexport ORACLE_HOME=$ORACLE_BASE/product/23.26.1/dbhome_1\nexport ORACLE_SID=prod\nexport PATH=$ORACLE_HOME/bin:$PATH:$HOME/bin\n</code></pre>\n<pre><code>[oracle@aiserver ~]$ source .bash_profile\n[oracle@aiserver ~]$ env | grep ORACLE\n</code></pre>\n<p>5.修改内核参数<br />\n以下在root用户下操作</p>\n<pre><code>cp /etc/sysctl.conf /etc/sysctl.conf.bak\n\ncat &gt;&gt; /etc/sysctl.conf &lt;&lt; \"EOF\"\nfs.file-max = 6815744\nkernel.sem = 250 32000 100 128\nkernel.shmmni = 4096\nkernel.shmall = 751619276\nkernel.shmmax = 3006477107\nkernel.panic_on_oops = 1\nnet.core.rmem_default = 262144\nnet.core.rmem_max = 4194304\nnet.core.wmem_default = 262144\nnet.core.wmem_max = 1048576\nfs.aio-max-nr = 1048576\nnet.ipv4.ip_local_port_range = 9000 65500\nEOF\n\nkernel.shmall :物理内存的70%\nkernel.shmmni=kernel.shmall/4\n\n环境变量生效\nsysctl --system\n</code></pre>\n<p>6./etc/profile配置<br />\n以下root用户操作</p>\n<pre><code>cp /etc/profile /etc/profile.bak\n\ncat &gt;&gt; /etc/profile &lt;&lt; \"EOF\"\nif [ $USER = \"oracle\" ]; then\n        if [ $SHELL = \"/bin/ksh\" ]; then\n                ulimit -p 16384\n                ulimit -n 65536\n        else\n                ulimit -u 16384 -n 65536\n        fi\nfi\nEOF\n\n\nvi /etc/pam.d/login\nsession    required     pam_limits.so\n</code></pre>\n<p>7.修改资源限制<br />\n以下root用户操作</p>\n<pre><code>cp /etc/security/limits.conf /etc/security/limits.conf.bak\n\ncat &gt;&gt; /etc/security/limits.conf &lt;&lt; \"EOF\"\noracle soft nproc 2047\noracle hard nproc 16384\noracle soft nofile 1024\noracle hard nofile 65536\nEOF\n</code></pre>\n<p>8.yum安装依赖</p>\n<pre><code>[root@aiserver ~]# mount | grep sr0\nmount /dev/cdrom /mnt\n\necho \"[localREPO]\" &gt;&gt; /etc/yum.repos.d/my.repo\necho \"name=localhost8\" &gt;&gt; /etc/yum.repos.d/my.repo\necho \"baseurl=file:///mnt/BaseOS\" &gt;&gt; /etc/yum.repos.d/my.repo\necho \"gpgcheck=0\" &gt;&gt; /etc/yum.repos.d/my.repo\necho \"enabled=1\" &gt;&gt; /etc/yum.repos.d/my.repo\n\necho \"[localREPO_APP]\" &gt;&gt; /etc/yum.repos.d/my.repo\necho \"name=localhost8_app\" &gt;&gt; /etc/yum.repos.d/my.repo\necho \"baseurl=file:///mnt/AppStream\" &gt;&gt; /etc/yum.repos.d/my.repo\necho \"gpgcheck=0\" &gt;&gt; /etc/yum.repos.d/my.repo\necho \"enabled=1\" &gt;&gt; /etc/yum.repos.d/my.repo\n\n[root@aiserver yum.repos.d]# yum repolist\n</code></pre>\n<p>以下命令安装依赖包</p>\n<pre><code>yum install bc \\\nbinutils \\\ncompat-openssl10 \\\nelfutils-libelf \\\nfontconfig \\\nglibc \\\nglibc-devel \\\nksh \\\nlibaio \\\nlibXrender \\\nlibX11 \\\nlibXau \\\nlibXi \\\nlibXtst \\\nlibgcc \\\nlibstdc++ \\\nlibxcb \\\nlibibverbs \\\nlibasan \\\nliblsan \\\nlibrdmacm \\\nmake \\\npolicycoreutils \\\npolicycoreutils-python-utils \\\nsmartmontools \\\nsysstat -y\n</code></pre>\n<p>9.解压软件授权、<br />\noracle用户下操作<br />\n<code>[oracle@aiserver ~]$ mkdir -p /u01/app/oracle/product/23.26.1/dbhome_1</code></p>\n<p>oracle用户下操作<br />\n<code>[oracle@aiserver ~]$ unzip /opt/LINUX.X64_2326100_db_home.zip -d $ORACLE_HOME</code></p>\n<p>10.静默安装Oracle数据库<br />\n10.1.编辑rsp文件</p>\n<pre><code>[oracle@aiserver ~]$ cd $ORACLE_HOME/install/response\n[oracle@aiserver response]$ cp db_install.rsp /tmp\n</code></pre>\n<pre><code>vi /tmp/db_install.rsp\n\n修改db_install.rsp文件中以下内容\n\noracle.install.option=INSTALL_DB_SWONLY\nUNIX_GROUP_NAME=oinstall\nINVENTORY_LOCATION=/u01/app/oraInventory\nORACLE_BASE=/u01/app/oracle\nORACLE_HOME=/u01/app/oracle/product/23.26.1/dbhome_1\nInstallEdition=EE\nOSDBA_GROUP=dba\nOSOPER_GROUP=oper\nOSBACKUPDBA_GROUP=dba\nOSDGDBA_GROUP=dba\nOSKMDBA_GROUP=dba\nOSRACDBA_GROUP=dba\n</code></pre>\n<p>dbType=GENERAL_PURPOSE</p>\n<p>10.2.静默安装Oracle软件<br />\n[oracle@aiserver ~]$ cd $ORACLE_HOME<br />\n./runInstaller -silent -responseFile /tmp/db_install.rsp -ignorePrereq</p>\n<h1 id=\"安装结束后需要以root用户执行以下两个脚本\">安装结束后需要以root用户执行以下两个脚本</h1>\n<p>/u01/app/oracle/oraInventory/orainstRoot.sh<br />\n/u01/app/oracle/product/23.26.1/dbhome_1/root.sh</p>\n<p>11.监听创建<br />\n静默配置监听<br />\n<code>[oracle@aiserver ~]$ netca -silent -responseFile $ORACLE_HOME/assistants/netca/netca.rsp</code></p>\n<p>12.dbca建库<br />\n12.1.编辑dbca.rsp安装文件</p>\n<pre><code>[oracle@aiserver ~]$ cd $ORACLE_HOME/assistants/dbca\n[oracle@aiserver dbca]$ cp dbca.rsp /tmp\n[oracle@aiserver ~]$ vi /tmp/dbca.rsp\n\nresponseFileVersion=/oracle/assistants/rspfmt_dbca_response_schema_v23.0.0\ngdbName=prod\nsid=prod\ndatabaseConfigType=SI\ncreateAsContainerDatabase=true\nnumberOfPDBs=2\npdbName=prod\ntemplateName=General_Purpose.dbc\noracleHomeUserPassword=oracle\ntotalMemory=1500\nsysPassword=oracle\nsystemPassword=oracle\ndatafileDestination=/u01/app/oracle/oradata\ncharacterSet=AL32UTF8\nnationalCharacterSet=UTF8\ndatabaseType=OLTP\n\n注意：templateName、createAsContainerDatabase必須指定\n</code></pre>\n<p>12.2.静默安装数据库<br />\n<code>[oracle@aiserver ~]$ dbca -silent -createDatabase -responseFile /tmp/dbca.rsp</code></p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t<p class=\"postfoot\">\n\t\t\tposted on \n<span id=\"post-date\">2026-01-31 17:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/liuziyi1\">刘子毅</a>&nbsp;\n阅读(<span id=\"post_view_count\">5</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</p>"
    },
    {
      "title": "架构师必备：灰度方案汇总",
      "link": "https://www.cnblogs.com/toplist/p/19527704",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/toplist/p/19527704\" id=\"cb_post_title_url\" title=\"发布于 2026-01-31 17:35\">\n    <span>架构师必备：灰度方案汇总</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>大家好，我是Java烘焙师。本文结合笔者的经验和思考，对灰度方案做个总结，重点介绍AB实验。</p>\n<p>灰度在开发流程中非常普遍。先做小流量验证，确认无误后再推全，灰度过程中一旦发现系统异常、或业务指标异常，应立刻回滚。</p>\n<h1 id=\"灰度场景\">灰度场景</h1>\n<ul>\n<li>代码灰度：是最典型的灰度，灰度内做新逻辑，灰度外做旧逻辑\n<ul>\n<li>既可以提供v2版本新接口给调用方服务，由调用方来做灰度切换</li>\n<li>也可以内部切灰度，做到调用方无感</li>\n</ul>\n</li>\n<li>发版灰度：上线过程中，新版本服务实例不断增加，需考虑兼容新旧协议</li>\n<li>配置灰度：修改配置时，按服务实例灰度推送配置变更</li>\n</ul>\n<h1 id=\"灰度模式\">灰度模式</h1>\n<ul>\n<li>数字id尾号灰度：取id最后2位（百分比）、最后3位（千分比）、最后4位（万分比）等\n<ul>\n<li>实现方式：id取模，例如 <code>id % 100 &lt; 灰度百分比</code>，则命中灰度</li>\n<li>特点：简单，适用于绝大部分技术优化场景</li>\n</ul>\n</li>\n<li>随机灰度：取一部分随机流量做灰度\n<ul>\n<li>实现方式：<code>ThreadLocalRandom.current().nextInt(100) &lt; 灰度百分比</code></li>\n<li>之所以使用ThreadLocalRandom、而不是Random，是为了避免多线程竞争用于生成随机数的seed</li>\n</ul>\n</li>\n<li>A/B实验\n<ul>\n<li>实现方式：分层实验、实验数据收集、离线统计</li>\n<li>特点：适用于小流量验证新业务功能的效果，整体方案相对复杂，需要技术基建</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"id选取\">id选取</h1>\n<ul>\n<li>业务id：如用户id、商品id等</li>\n<li>设备id：未注册/未登录用户，此时没有用户id，只能取设备的唯一标识</li>\n</ul>\n<p>下面重点介绍一下A/B实验。</p>\n<h1 id=\"ab实验\">A/B实验</h1>\n<h2 id=\"目的\">目的</h2>\n<ul>\n<li>小流量验证新业务功能，正向显著则推至全量，否则继续迭代优化、或下线，避免功能过于臃肿</li>\n<li>用数据作为依据，避免想当然、拍脑袋决策</li>\n</ul>\n<h2 id=\"分层实验\">分层实验</h2>\n<p>主要目的是为了同时做多个实验，而不是给每个实验均分一部分流量。因为当同时进行的实验变多时，组合数量成倍增加，每个实验分到的流量就很少了。<br />\n有这几层结构：实验层、实验、分组</p>\n<ul>\n<li>实验层之间正交，可同时进行多个实验层的实验</li>\n<li>同一实验层的实验之间互斥，比如命中了实验1-1，就不会命中实验1-2。实验持有0到多个分桶，根据业务id可计算出桶号，进而知道命中哪个实验</li>\n<li>同一实验内有多个分组，包括1个对照组，和1到多个实验组，只会命中其中一个分组。分组持有0到多个分桶，根据业务id可计算出桶号，进而知道命中哪个分组</li>\n</ul>\n<p>实验层、实验举例：</p>\n<ul>\n<li>展示实验层：根据页面进行划分，如首页、搜索页、推荐页、详情页等。每个页面作为一个实验层，每个实验层里可同时做多个展示实验</li>\n<li>算法实验层：根据场景进行划分，如相似推荐、搭配购推荐、个性化推荐、搜索排序、广告排序等。每个场景作为一个实验层，每个实验层里可同时做多个算法实验</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1247698/202601/1247698-20260127012326894-198795136.png\" /></p>\n<h2 id=\"哈希算法打散\">哈希算法打散</h2>\n<p>要同时支持多个分层实验，核心在于通过哈希算法将每一层的流量打散，用于实现“均匀分流”和“层间正交”，使得流量在各个实验的效果正负抵消，才能得到真实的对比结果。<br />\n以下是计算实验层桶号的代码示例，实验桶号同理：</p>\n<pre><code class=\"language-java\">import com.google.common.hash.Hashing;\nimport java.nio.charset.StandardCharsets;\n\npublic class ABTestRouter {\n\n    /**\n     * 根据用户ID和实验层ID（实验层ID充当盐的角色），计算桶号 (0-99)\n     */\n    public static int getBucket(String userId, String layerId) {\n        // 1. 拼接 Key: \"layerId:userId\"\n        String key = layerId + \":\" + userId;\n\n        // 2. 使用 MurmurHash3 (32-bit)\n        // Guava 的 murmur3_32_fixed 是线程安全的\n        int hash = Hashing.murmur3_32_fixed()\n                .hashString(key, StandardCharsets.UTF_8)\n                .asInt();\n\n        // 3. 取模并确保结果为正数\n        // Math.abs(Integer.MIN_VALUE) 会返回负数，所以推荐使用位运算去除符号位\n        return (hash &amp; Integer.MAX_VALUE) % 100;\n    }\n\n    public static void main(String[] args) {\n        String uid = \"user_123456\";\n        \n        // 不同层的流量是正交的（打散重新分配）\n        System.out.println(\"展示层桶号: \" + getBucket(uid, \"layer_ui\"));\n        System.out.println(\"算法层桶号: \" + getBucket(uid, \"layer_algo\"));\n    }\n}\n</code></pre>\n<p>之所以用murmurhash，而非md5，是因为md5是加密算法，计算开销更大，在AB实验中仅需均匀打散即可，无需担心根据哈希结果反推原文。<br />\n之所以把实验层id作为盐，是因为微小的输入差异都会导致哈希结果相差巨大，实现打散的效果。</p>\n<h2 id=\"实验数据收集\">实验数据收集</h2>\n<p>实验数据收集流程如下：</p>\n<ul>\n<li>在AB实验管理系统中配置实验信息：如实验盐值、桶号与实验组的映射关系等，可动态修改</li>\n<li>代码逻辑开发：\n<ul>\n<li>引入实验sdk，sdk在启动、或配置变更时拉取实验信息，本地计算业务id的桶号，进而得到命中的分组</li>\n<li>对照组做当前逻辑，实验组1做逻辑1，实验组2做逻辑2</li>\n</ul>\n</li>\n<li>在正式开始AB实验之前，先做AA分桶实验，模拟实验组、对照组的结果，判断是否均匀，避免分桶不均匀带来错误的实验结果</li>\n<li>实验开始，后端埋点：sdk发出后端埋点消息\n<ul>\n<li>消息格式举例：<code>业务id, 实验层id, 实验id, 分组id, 桶号, 触发时间</code></li>\n</ul>\n</li>\n<li>实验过程：实验持续时间至少一周，覆盖工作日、周末/假期，避免受时间周期带来的波动影响</li>\n<li>离线统计实验效果：\n<ul>\n<li>后端埋点数据导入曝光事件hive表</li>\n<li>业务DB数据导入行为事件hive表，如注册、登录、浏览、点击、收藏、加购、下单、支付等，取决于实验关注的业务指标</li>\n<li>把曝光事件、行为事件join起来，对比实验组、对照组的业务指标差异</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1247698/202601/1247698-20260131014010302-1779078827.png\" /></p>\n<p>以下是sql示例，代表从实验曝光后24小时内各个分组的转化率对比。</p>\n<pre><code class=\"language-sql\">SELECT \n    e.group_id,\n    COUNT(DISTINCT e.user_id) as exposed_users,\n    COUNT(DISTINCT a.user_id) as converted_users,\n    COUNT(DISTINCT a.user_id) / COUNT(DISTINCT e.user_id) as conversion_rate\nFROM exposure_events e\nLEFT JOIN action_events a ON e.user_id = a.user_id \n    AND a.event_time BETWEEN e.event_time AND (e.event_time + INTERVAL 24 HOUR)\nWHERE e.experiment_id = 'ui_test_001'\nGROUP BY e.group_id;\n</code></pre>\n<h2 id=\"实验报表分析\">实验报表分析</h2>\n<p>评估实验结果是否正向、是否显著。了解统计学里的核心概念，能看懂实验报表即可。</p>\n<h3 id=\"p值\">p值</h3>\n<p>用来衡量实验结果是否显著，p值的含义是：假设实验组与对照组没有区别，此时观察到实验有差异的概率。一般要求 <code>p &lt; 0.05</code>，也就是说实验结果显著的概率大于95%（<code>1 - 0.05 = 95%</code>）</p>\n<h3 id=\"置信区间\">置信区间</h3>\n<p>在显著的前提下，用来衡量实验结果是否正向，代表业务指标的可能范围分布。<br />\n比如：实验结果里业务指标提升了1%，95%置信区间在[0.8%, 1.2%]，则代表有95%的把握可以把业务指标提升至少0.8%、至多1.2%，效果正向。如果置信区间的下界是负数，就有可能是负向效果了，需要警惕。</p>\n<p>以上就是灰度方案的总结了，欢迎讨论交流。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-31 17:35</span>&nbsp;\n<a href=\"https://www.cnblogs.com/toplist\">Java烘焙师</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "数据“显微镜”：蜂群图让每个数据点都发声",
      "link": "https://www.cnblogs.com/wang_yb/p/19557785",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wang_yb/p/19557785\" id=\"cb_post_title_url\" title=\"发布于 2026-01-31 14:22\">\n    <span>数据“显微镜”：蜂群图让每个数据点都发声</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>想象一下夏日的花丛中，成群的蜜蜂围绕着花朵忙碌地飞舞。每只蜜蜂都是一个独立的数据点，它们既保持群体聚集的形态，又不会完全重叠在一起。</p>\n<p>这就是<strong>蜂群图</strong>（<code>Swarm Plot</code>）的<strong>核心理念</strong>——在有限的空间内展示所有数据点，让每个点都能被清晰看见。</p>\n<p><strong>蜂群图</strong>是一种特殊的数据可视化图表，它将分类数据与数值数据结合起来，展示数据的分布情况。</p>\n<p>与传统的条形图或箱线图不同，蜂群图不进行任何数据聚合，而是展示每一个原始数据点，避免了信息丢失。</p>\n<h1 id=\"1-蜂群图核心特点\">1. 蜂群图核心特点</h1>\n<p><strong>蜂群图</strong>最巧妙的地方在于它的布局算法。</p>\n<p>当多个数据点具有相似数值时，它们不会简单地重叠在一起，而是像有“排斥力”一样，在垂直方向（或水平方向）上轻微偏移，形成一个类似蜂群的分布。</p>\n<p>比如，下面是<strong>同一组数据</strong>在<strong>散点图</strong>和<strong>蜂群图</strong>中展示的效果。</p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260131142128895-781019092.png\" /></p>\n<p>从中可以看出蜂群图的核心特点有：</p>\n<ol>\n<li><strong>绝不重叠</strong>： 它通过算法检测数据点的重叠情况，一旦发现两个点数值相近，就会自动把它们向水平方向推开。</li>\n<li><strong>保留分布形态</strong>： 散开后的形状，天然形成了一种类似“小提琴”或“山峰”的轮廓，直观地展示了数据的密度。</li>\n<li><strong>参数调整</strong>： 我们可以调整点的大小（marker size）和排列的紧密程度。点越大，视觉冲击力越强，但需要的水平空间也越多。</li>\n</ol>\n<h1 id=\"2-蜂群图-vs-条形图从摘要到细节\">2. 蜂群图 vs. 条形图：从摘要到细节</h1>\n<p><strong>条形图</strong>就像是一份数据摘要报告，它告诉我们每个类别的平均值或总计值，但隐藏了数据内部的分布细节。</p>\n<p>而<strong>蜂群图</strong>则像是一次数据点的全员大会，每个数据点都有发言的机会。</p>\n<p>下面针对同一组数据，我们分别绘制了<strong>条形图</strong>、<strong>箱线图</strong>和<strong>蜂群图</strong>，一起来感受一下它们之间不同的展示效果。</p>\n<pre><code class=\"language-python\"># 生成示例数据\nnp.random.seed(123)\ncategories = [\"产品A\", \"产品B\", \"产品C\", \"产品D\"]\ndata_comparison = []\nfor category in categories:\n    n_points = 40\n    if category == \"产品A\":\n        values = np.random.normal(75, 8, n_points)\n    elif category == \"产品B\":\n        values = np.random.normal(82, 12, n_points)\n    elif category == \"产品C\":\n        values = np.random.normal(65, 5, n_points)\n    else:  # 产品D\n        # 创建一个双峰分布\n        values1 = np.random.normal(55, 6, n_points // 2)\n        values2 = np.random.normal(85, 7, n_points // 2)\n        values = np.concatenate([values1, values2])\n\n    for value in values:\n        data_comparison.append({\"产品\": category, \"用户评分\": value})\n\n# 1. 条形图（平均值）\nmeans = []\nfor category in categories:\n    cat_data = [d[\"用户评分\"] for d in data_comparison if d[\"产品\"] == category]\n    means.append(np.mean(cat_data))\n\nbars = axes[0].bar(\n    categories, means, color=[\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\"]\n)\n\n\n# 在条形上标注平均值\n# 省略...\n\n# 2. 箱线图\nbox_data = []\nfor category in categories:\n    cat_data = [d[\"用户评分\"] for d in data_comparison if d[\"产品\"] == category]\n    box_data.append(cat_data)\n\nboxplot = axes[1].boxplot(\n    box_data, tick_labels=categories, patch_artist=True, boxprops=dict(facecolor=\"lightblue\")\n)\n# 省略...\n\n# 3. 蜂群图\ndata_df = pd.DataFrame(data_comparison)\nsns.swarmplot(\n    x=\"产品\",\n    y=\"用户评分\",\n    hue=\"产品\",\n    data=data_df,\n    ax=axes[2],\n    size=5,\n    palette=\"Set2\",\n    edgecolor=\"black\",\n    linewidth=0.5,\n)\n# 省略...\n\nplt.tight_layout()\nplt.show()\n\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260131142128894-2129735776.png\" /></p>\n<p>绘制蜂群图可以用<code>seaborn</code>这个库中的<code>swarmplot</code>函数。</p>\n<p>从上面的对比可以看出：</p>\n<ul>\n<li><strong>条形图</strong>告诉我们产品D的平均分约为70分</li>\n<li><strong>箱线图</strong>提示产品D的数据分布范围很广</li>\n<li>但只有<strong>蜂群图</strong>清晰地揭示了产品D实际上有两个明显的用户群体：一个低评分群体和一个高评分群体</li>\n</ul>\n<h1 id=\"3-蜂群图-vs-散点图从混乱到有序\">3. 蜂群图 vs. 散点图：从混乱到有序</h1>\n<p>传统<strong>散点图</strong>在处理分类数据时，常常导致数据点大量重叠，形成\"黑团\"，我们无法看清数据点的真实分布。</p>\n<p><strong>蜂群图</strong>通过智能布局算法解决了这个问题。</p>\n<p>下面构造一个不同密度的数据，看看蜂群图和散点图的展示效果。</p>\n<pre><code class=\"language-python\"># 比较散点图与蜂群图的视觉效果\nfig, axes = plt.subplots(1, 2, figsize=(14, 6))\n\n# 生成具有不同密度的数据\nnp.random.seed(42)\ndensity_data = []\ncategories = [\"低密度\", \"中等密度\", \"高密度\"]\nfor i, category in enumerate(categories):\n    n_points = 20 + i * 30  # 不同密度\n    if category == \"低密度\":\n        values = np.random.normal(50, 15, n_points)\n    elif category == \"中等密度\":\n        values = np.random.normal(50, 8, n_points)\n    else:  # 高密度\n        values = np.random.normal(50, 4, n_points)\n\n    for value in values:\n        density_data.append({\"类别\": category, \"数值\": value})\n\n# 左侧：传统散点图\nfor i, category in enumerate(categories):\n    cat_data = [d[\"数值\"] for d in density_data if d[\"类别\"] == category]\n    x_positions = np.full(len(cat_data), i)\n    axes[0].scatter(x_positions, cat_data, alpha=0.6, s=60, label=category)\n\n#省略...\n\n# 右侧：蜂群图\ndensity_data_df = pd.DataFrame(density_data)\nsns.swarmplot(\n    x=\"类别\",\n    y=\"数值\",\n    hue=\"类别\",\n    data=density_data_df,\n    ax=axes[1],\n    size=6,\n    palette=\"coolwarm\",\n    edgecolor=\"black\",\n    linewidth=0.5,\n)\n#省略...\n\nplt.tight_layout()\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260131142128896-1164818687.png\" /></p>\n<p><strong>蜂群图</strong>解决了 <strong>“重叠（Overplotting）”</strong> 的问题。在数据量适中（几百到几千个点）时，它是展示分布密度的最佳选择。</p>\n<h1 id=\"4-蜂群图的适用场景\">4. 蜂群图的适用场景</h1>\n<p><strong>蜂群图</strong>并不是为了取代<strong>条形图</strong>或<strong>散点图</strong>，它有自己的适用场景和局限性。</p>\n<p>适合使用<strong>蜂群图</strong>的场景：</p>\n<ul>\n<li>样本量适中（通常少于几百个点）时，展示完整数据分布</li>\n<li>需要同时看到整体趋势和个体数据点</li>\n<li>数据有多个分类变量，需要比较不同类别分布</li>\n<li>希望发现异常值或特殊模式（如双峰分布）</li>\n</ul>\n<p><font style=\"color: rgba(15, 17, 21, 1);\"></font></p>\n<p><strong>蜂群图</strong>的<strong>局限性</strong>主要有：</p>\n<ol>\n<li>大数据集可能导致图表过于拥挤</li>\n<li>对于非常大规模数据，箱线图或小提琴图可能更合适</li>\n<li>精确的数值比较不如条形图直观</li>\n</ol>\n<h1 id=\"5-总结\">5. 总结</h1>\n<p><strong>蜂群图</strong>就像数据可视化领域的\"显微镜\"，它让我们既能观察到数据的整体分布形态，又能看到每一个数据点的具体位置。</p>\n<p>与只能显示摘要信息的<strong>条形图</strong>和容易产生重叠的<strong>散点图</strong>相比，<strong>蜂群图</strong>在显示中小型数据集的完整分布信息方面具有独特优势。</p>\n<p>在数据可视化实践中，选择正确的图表类型就像选择正确的工具一样重要。</p>\n<p>当下一次你需要展示分类数据的分布时，不妨尝试一下蜂群图，它可能会揭示出你从未注意到的数据秘密。</p>\n<p>文中的完整代码共享在：<a href=\"https://url11.ctfile.com/f/45455611-8639900394-9a109f?p=6872\" rel=\"noopener nofollow\" target=\"_blank\">蜂群图.ipynb</a> (访问密码: 6872)</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-31 14:22</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wang_yb\">wang_yb</a>&nbsp;\n阅读(<span id=\"post_view_count\">43</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "C++ 封装 C FFI 接口最佳实践：以 Hugging Face Tokenizer 为例",
      "link": "https://www.cnblogs.com/charlee44/p/19557586",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/charlee44/p/19557586\" id=\"cb_post_title_url\" title=\"发布于 2026-01-31 13:36\">\n    <span>C++ 封装 C FFI 接口最佳实践：以 Hugging Face Tokenizer 为例</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        详细介绍了如何通过 Rust 的 C FFI 封装 Hugging Face tokenizers，并在 C++ 中利用 RAII 和智能指针实现安全、简洁、高效的资源管理，最终遵循现代 C++ 的“零法则”完成工业级封装。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"1-引入\">1. 引入</h1>\n<p>在现代 AI 工程中，Hugging Face 的 tokenizers 库已成为分词器的事实标准。不过 Hugging Face 的 tokenizers 是用 Rust 来实现的，官方只提供了 python 和 node 的绑定实现。要实现与 Hugging Face tokenizers 相同的行为，最好的办法就是自己封装 Hugging Face tokenizers 的 C 绑定，从而可以被 C++ / C# / Java 这些高级编程语言调用。</p>\n<h1 id=\"2-封装-c-接口\">2. 封装 C 接口</h1>\n<p>首先要说明的是，要做的不是完整的封装 Hugging Face tokenizers 的 C 的 FFI（Foreign Function Interface）接口，而是封装自己需要的接口就可以了。比如执行分词接口和计算Token的接口：</p>\n<pre><code class=\"language-rust\">use std::ffi::CStr;\nuse std::os::raw::c_char;\nuse tokenizers::{PaddingParams, Tokenizer, TruncationParams};\n\n// === 1. 定义 C 兼容的返回结构体 ===\n#[repr(C)]\npub struct TokenizerResult {\n    pub input_ids: *mut i64,\n    pub attention_mask: *mut i64,\n    pub token_type_ids: *mut i64,\n    pub length: u64,\n}\n\n// === 2. 内部状态：包装 Tokenizer ===\nstruct TokenizerHandle {\n    tokenizer: Tokenizer,     // 用于 encode（带 padding）\n    raw_tokenizer: Tokenizer, // 用于 count（无 padding）\n}\n\n// === 3. 辅助函数：将 Rust Vec 转为 C 可拥有的指针 ===\nfn vec_to_c_ptr(vec: Vec&lt;i64&gt;) -&gt; *mut i64 {\n    let mut boxed = vec.into_boxed_slice();\n    let ptr = boxed.as_mut_ptr();\n    std::mem::forget(boxed); // 防止 Rust 自动释放\n    ptr\n}\n\n// === 4. 创建 tokenizer ===\n#[unsafe(no_mangle)] // 禁用 name mangling，让 C 能找到符号\npub extern \"C\" fn tokenizer_create(tokenizer_json_path: *const c_char) -&gt; *mut std::ffi::c_void {\n    if tokenizer_json_path.is_null() {\n        return std::ptr::null_mut();\n    }\n\n    let path_cstr = unsafe { CStr::from_ptr(tokenizer_json_path) };\n    let path_str = match path_cstr.to_str() {\n        Ok(s) =&gt; s,\n        Err(_) =&gt; return std::ptr::null_mut(),\n    };\n\n    let mut tokenizer = match Tokenizer::from_file(path_str) {\n        Ok(t) =&gt; t,\n        Err(_) =&gt; return std::ptr::null_mut(),\n    };\n\n    // 设置 padding/truncation 到 512（BGE 默认）\n    tokenizer.with_padding(Some(PaddingParams {\n        strategy: tokenizers::PaddingStrategy::Fixed(512),\n        ..Default::default()\n    }));\n\n    if tokenizer\n        .with_truncation(Some(TruncationParams {\n            max_length: 512,\n            ..Default::default()\n        }))\n        .is_err()\n    {\n        return std::ptr::null_mut();\n    }\n\n    let mut raw_tokenizer = tokenizer.clone();\n    raw_tokenizer.with_padding(None);\n    raw_tokenizer.with_truncation(None).ok();\n\n    let handle = TokenizerHandle {\n        tokenizer,\n        raw_tokenizer,\n    };\n    Box::into_raw(Box::new(handle)) as *mut std::ffi::c_void\n}\n\n//计算句子token\n#[unsafe(no_mangle)] // 禁用 name mangling，让 C 能找到符号\npub extern \"C\" fn tokenizer_count(handle: *mut std::ffi::c_void, text: *const c_char) -&gt; u64 {\n    if handle.is_null() || text.is_null() {\n        return 0;\n    }\n\n    let handle_ref = unsafe { &amp;*(handle as *mut TokenizerHandle) };\n\n    let text_cstr = unsafe { CStr::from_ptr(text) };\n    let text_str = match text_cstr.to_str() {\n        Ok(s) =&gt; s,\n        Err(_) =&gt; return 0,\n    };\n\n    match handle_ref.raw_tokenizer.encode(text_str, true) {\n        Ok(encoding) =&gt; encoding.len() as u64,\n        Err(_) =&gt; 0,\n    }\n}\n\n// === 5. 销毁 tokenizer ===\n#[unsafe(no_mangle)]\npub extern \"C\" fn tokenizer_destroy(handle: *mut std::ffi::c_void) {\n    if !handle.is_null() {\n        unsafe {\n            let _ = Box::from_raw(handle as *mut TokenizerHandle);\n            // Drop 自动调用\n        }\n    }\n}\n\n// === 6. 执行分词 ===\n#[unsafe(no_mangle)]\npub extern \"C\" fn tokenizer_encode(\n    handle: *mut std::ffi::c_void,\n    text: *const c_char,\n) -&gt; TokenizerResult {\n    let default_result = TokenizerResult {\n        input_ids: std::ptr::null_mut(),\n        attention_mask: std::ptr::null_mut(),\n        token_type_ids: std::ptr::null_mut(),\n        length: 0,\n    };\n\n    if handle.is_null() || text.is_null() {\n        return default_result;\n    }\n\n    let handle_ref = unsafe { &amp;*(handle as *mut TokenizerHandle) };\n\n    let text_cstr = unsafe { CStr::from_ptr(text) };\n    let text_str = match text_cstr.to_str() {\n        Ok(s) =&gt; s,\n        Err(_) =&gt; return default_result,\n    };\n\n    let encoding = match handle_ref.tokenizer.encode(text_str, true) {\n        Ok(e) =&gt; e,\n        Err(_) =&gt; return default_result,\n    };\n\n    let input_ids: Vec&lt;i64&gt; = encoding.get_ids().iter().map(|&amp;x| x as i64).collect();\n    let attention_mask: Vec&lt;i64&gt; = encoding\n        .get_attention_mask()\n        .iter()\n        .map(|&amp;x| x as i64)\n        .collect();\n    let token_type_ids: Vec&lt;i64&gt; = encoding.get_type_ids().iter().map(|&amp;x| x as i64).collect();\n    // BGE 不需要，但 C++ 代码传了\n    // let token_type_ids: Vec&lt;u32&gt; = vec![0u32; input_ids.len()];\n\n    let len = input_ids.len(); // 应该是 512，但更通用\n\n    TokenizerResult {\n        input_ids: vec_to_c_ptr(input_ids),\n        attention_mask: vec_to_c_ptr(attention_mask),\n        token_type_ids: vec_to_c_ptr(token_type_ids),\n        length: len as u64,\n    }\n}\n\n// === 7. 释放结果内存 ===\n#[unsafe(no_mangle)]\npub extern \"C\" fn tokenizer_result_free(result: TokenizerResult) {\n    if !result.input_ids.is_null() {\n        unsafe {\n            let _ = Vec::from_raw_parts(\n                result.input_ids,\n                result.length as usize,\n                result.length as usize,\n            );\n        }\n    }\n\n    if !result.attention_mask.is_null() {\n        unsafe {\n            let _ = Vec::from_raw_parts(\n                result.attention_mask,\n                result.length as usize,\n                result.length as usize,\n            );\n        }\n    }\n\n    if !result.token_type_ids.is_null() {\n        unsafe {\n            let _ = Vec::from_raw_parts(\n                result.token_type_ids,\n                result.length as usize,\n                result.length as usize,\n            );\n        }\n    }\n}\n</code></pre>\n<p>对应的 C 接口如下：</p>\n<pre><code class=\"language-c\">// tokenizer_result.h\n#pragma once\n\nstruct TokenizerResult {\n  int64_t* input_ids;\n  int64_t* attention_mask;\n  int64_t* token_type_ids;\n  uint64_t length;\n};\n\n#ifdef __cplusplus\nstatic_assert(std::is_standard_layout_v&lt;TokenizerResult&gt; &amp;&amp;\n                  std::is_trivially_copyable_v&lt;TokenizerResult&gt;,\n              \"TokenizerResult must be C ABI compatible\");\n#endif\n</code></pre>\n<pre><code class=\"language-c\">// hf_tokenizer_ffi.h\n#pragma once\n\n#include &lt;stdint.h&gt;\n\n#include \"tokenizer_result.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid* tokenizer_create(const char* tokenizer_json_path);\nvoid tokenizer_destroy(void* handle);\nTokenizerResult tokenizer_encode(void* handle, const char* text);\nuint64_t tokenizer_count(void* handle, const char* text);\nvoid tokenizer_result_free(TokenizerResult result);\n\n#ifdef __cplusplus\n}\n#endif\n</code></pre>\n<p>具体的封装细节笔者就不多说了，因为与本文的主题无关。不过可以稍稍了解一下其中的原理，也就是说，操作系统大多数是由 C 实现的，或者提供了 C 的接口。因此，绝大多数比 C 高级的编程语言都提供了与 C 交互的能力，当然前提是必须得按照 C 得规范组织数据和封装接口。比如这里的<code>struct TokenizerResult</code>就是一个兼容 C 的结构体，<code>#[unsafe(no_mangle)]</code>则表明这是一个 C 语言形式的函数接口。</p>\n<h1 id=\"3-经典-c-封装\">3. 经典 C++ 封装</h1>\n<p>如上接口是一个标准的 C 风格式的接口：将分词器封装成一个 Handle ，也就是俗称的句柄。而后续具体的分词操作就通过这个句柄来进行，包括最后对资源的释放。在 C++ 中，当然也可以直接使用这种形式的接口，不过这样就需要遵循 C 的资源控制规则：资源申请和释放必须成对出现——比如这里的 <code>tokenizer_create</code> 和 <code>tokenizer_destroy</code>。</p>\n<h2 id=\"31-raii-机制\">3.1 RAII 机制</h2>\n<p>不过这样就会有一个问题，过程式的流程中很难保证 <code>tokenizer_create</code> 和 <code>tokenizer_destroy</code> 能够成对调用，例如：</p>\n<pre><code class=\"language-c\">tokenizer_create()\n\nif(...){\n    return;\n}\n\ntokenizer_destroy()\n</code></pre>\n<p>只要在 <code>tokenizer_create</code> 和 <code>tokenizer_destroy</code> 之间出现分支，程序提前返回，就会导致资源没有释放而内存泄漏。为了避免这个问题，就需要在每次 <code>return</code> 之前，都调用 <code>tokenizer_destroy()</code>——这当然是非常不优雅的，既容易忘掉又是冗余代码。</p>\n<p>为了解决这种资源管理难题，C++ 提供了一种强大而优雅的机制：RAII（Resource Acquisition Is Initialization，资源获取即初始化）。它的核心思想是：将资源的生命周期绑定到对象的生命周期上。具体来说，就是利用面向对象的思想，将资源控制的行为封装成一个类对象，并且保证资源在对象构造函数中获取，在析构函数中自动释放。由于 C++ 中栈对象在离开作用域时会自动调用析构函数，在离开作用域时会自动调用析构函数。因此这些资源总是可以被正确释放，从根本上杜绝内存泄漏或资源泄露。例如：</p>\n<pre><code class=\"language-cpp\">Tokenizer tokenizer;\n\n//...操作\n\nif(...){\n    return;\n}\n\n//...更多操作\n</code></pre>\n<h2 id=\"32-拷贝语义\">3.2 拷贝语义</h2>\n<p>复习一下 C++ 面向对象设计的经典五法则（Rule of Five），如果一个类自定义了以下任意一个函数：</p>\n<ol>\n<li>析构函数（Destructor）</li>\n<li>拷贝构造函数（Copy Constructor）</li>\n<li>拷贝赋值运算符（Copy Assignment Operator）</li>\n<li>移动构造函数（Move Constructor）</li>\n<li>移动赋值运算符（Move Assignment Operator）</li>\n</ol>\n<p>那么大概率也需要自定义另外四个函数，或者显式 = default / = delete 来控制行为。很多 C++ 程序员并不理解移动语义，但这并没有关系，我们可以先假定不定义移动构造函数和移动赋值运算符（或者显式 = default），此时移动操作就会退化为拷贝语义的行为。</p>\n<p>而关于拷贝语义，绝大多数 C++ 程序员应该都知道这个问题：当在类对象中管理资源时，编译器生成的默认拷贝行为是“浅拷贝”，可能导致双重释放、内存泄漏等问题，因此需要自定义拷贝构造函数和拷贝赋值运算符来实现“深拷贝”的行为。因此，这个链条就很明确了：因为类中需要定义析构函数，所以需要同时定义拷贝构造函数和拷贝赋值运算符。</p>\n<h2 id=\"33-移动语义\">3.3 移动语义</h2>\n<p>进一步讨论，反正移动语义可以默认，那么是不是只用定义拷贝语义就行了呢？这个要看资源的定义：如果只是管理内存资源，那么这样做是没有问题的，至少是安全的。但是资源管理不仅仅指的是内存资源，还可以是一些文件句柄、网络连接等等。这些资源往往是独占性的，进行深拷贝往往会出现问题。因此就出现了 C++ 11 开始规定的移动语义：可以安全得实现“浅拷贝”的行为。同时还可以解决“深拷贝”的性能问题。</p>\n<p>基于以上的思想，笔者封装的分词器对象如下：</p>\n<pre><code class=\"language-cpp\">// HfTokenizer.h\n#pragma once\n\n#include &lt;string&gt;\n\n#include \"hf_tokenizer_ffi.h\"\n\nnamespace hf {\nclass Tokenizer {\n public:\n  explicit Tokenizer(const std::string&amp; path);\n\n  // 析构函数\n  ~Tokenizer() noexcept;\n\n  // 禁止拷贝\n  Tokenizer(const Tokenizer&amp;) = delete;\n  Tokenizer&amp; operator=(const Tokenizer&amp;) = delete;\n\n  // 移动语义\n  Tokenizer(Tokenizer&amp;&amp; rhs) noexcept;\n  Tokenizer&amp; operator=(Tokenizer&amp;&amp; rhs) noexcept;\n\n  // 其他接口方法\n  // TokenizerResult Encode(const char* text) const;\n  // uint64_t Count(const char* text) const;\n\n private:\n  void* handle;  // 来自 tokenizer_create 的指针\n};\n\n}  // namespace hf\n</code></pre>\n<pre><code class=\"language-cpp\">// HfTokenizer.cpp\n#include \"HfTokenizer.h\"\n\n#include &lt;iostream&gt;\n\nnamespace hf {\nTokenizer::Tokenizer(const std::string&amp; path)\n    : handle(tokenizer_create(path.c_str())) {\n  if (!handle) {\n    throw std::runtime_error(\"Failed to create tokenizer from \" + path);\n  }\n}\n\nTokenizer::~Tokenizer() noexcept {\n  if (handle) {\n    tokenizer_destroy(handle);\n  }\n}\n\n// 移动语义\nTokenizer::Tokenizer(Tokenizer&amp;&amp; rhs) noexcept : handle(rhs.handle) {\n  rhs.handle = nullptr;\n}\n\nTokenizer&amp; Tokenizer::operator=(Tokenizer&amp;&amp; rhs) noexcept {\n  if (this != &amp;rhs) {\n    if (handle) {\n      tokenizer_destroy(handle);\n    }\n    handle = rhs.handle;\n    rhs.handle = nullptr;\n  }\n  return *this;\n}\n\n}  // namespace hf\n</code></pre>\n<p>如前所述，因为封装的是一个句柄，为了避免资源控制的麻烦，就禁止掉拷贝语义：</p>\n<pre><code class=\"language-cpp\">// 禁止拷贝\nTokenizer(const Tokenizer&amp;) = delete;\nTokenizer&amp; operator=(const Tokenizer&amp;) = delete;\n</code></pre>\n<p>进行<code>()</code>拷贝构造或者<code>=</code>赋值构造看起来似乎很简单，其实在代码层层嵌套之后，就可能很难分析出是不是调用了默认的拷贝的行为，比如函数传参、容器操作等等。当然深拷贝的实现也不是性能最优，因此干脆就直接删除掉拷贝构造函数和拷贝赋值运算符。</p>\n<p>没有拷贝语义，那么就需要移动语义来进行传递对象了。其实移动语义没那么难，我们只要把握住一点，移动语义的目的是安全地实现“浅拷贝”。以移动赋值运算符的实现来说，如果要实现如下移动赋值：</p>\n<pre><code class=\"language-cpp\">Tokenizer A();\nTokenizer B();\nB = std::move(A);\n</code></pre>\n<p>就需要以下的行为：</p>\n<ol>\n<li>释放掉B管理的资源。</li>\n<li>将A中的成员“浅拷贝”到B中，让B接管A的资源。</li>\n<li>将A中成员初始化。</li>\n</ol>\n<p>具体实现就是如下所示：</p>\n<pre><code class=\"language-cpp\">Tokenizer&amp; Tokenizer::operator=(Tokenizer&amp;&amp; rhs) noexcept {\n  if (this != &amp;rhs) {\n    if (handle) {\n      tokenizer_destroy(handle);\n    }\n    handle = rhs.handle;\n    rhs.handle = nullptr;\n  }\n  return *this;\n}\n</code></pre>\n<p>移动构造函数就更加简单了，因为B对象在移动构造之前成员并没有初始化：</p>\n<pre><code class=\"language-cpp\">Tokenizer A();\nTokenizer B(std::move(A));\n</code></pre>\n<p>因此可以省略掉释放自身资源的步骤，具体实现也就是如下所示：</p>\n<pre><code class=\"language-cpp\">Tokenizer::Tokenizer(Tokenizer&amp;&amp; rhs) noexcept : handle(rhs.handle) {\n  rhs.handle = nullptr;\n}\n</code></pre>\n<p>最后还有一个问题：A通过移动语义转移到B了，A还能使用吗？不能也没必要使用A了，无论是A对象和B对象其实是一个栈对象（当然内部管理的数据成员可能放在堆上），或者说是一个值对象；这跟引用对象或者地址对象完全不同。移动语义的本质是对象所有权的转移，转移之后原对象中资源所有权就不存在了，即使强行访问，要么访问不到，要么会程序崩溃。</p>\n<h1 id=\"4-高级-c-封装\">4. 高级 C++ 封装</h1>\n<h2 id=\"41-零法则\">4.1 零法则</h2>\n<p>使用 RAII 机制 + 经典五法则来设计一个类对象，还有一个优点，就是使用这个类对象作为数据成员的类，就不用再显式实现析构函数。不用显式实现析构函数，也就意味着不用实现拷贝语义和移动语义，完全可以依赖类对象拷贝和移动的默认行为。举例来说，一个<code>MyResource</code>对象，管理着一段内存 buffer ，它的类定义为：</p>\n<pre><code class=\"language-cpp\">class MyResource {\npublic:\n    // 构造：申请资源\n    MyResource() {\n        data = new int[100];\n    }\n\n    // 析构：释放资源\n    ~MyResource() {\n        delete[] data;\n    }\n\n    // 拷贝构造：深拷贝\n    MyResource(const MyResource&amp; other) {\n        data = new int[100];\n        copy(other.data, other.data + 100, data);\n    }\n\n    // 拷贝赋值\n    MyResource&amp; operator=(const MyResource&amp; other) {\n        if (this != &amp;other) {\n            delete[] data;\n            data = new int[100];\n            copy(other.data, other.data + 100, data);\n        }\n        return *this;\n    }\n\n    // 移动构造：接管资源\n    MyResource(MyResource&amp;&amp; other) noexcept {\n        data = other.data;\n        other.data = nullptr;\n    }\n\n    // 移动赋值\n    MyResource&amp; operator=(MyResource&amp;&amp; other) noexcept {\n        if (this != &amp;other) {\n            delete[] data;\n            data = other.data;\n            other.data = nullptr;\n        }\n        return *this;\n    }\n\nprivate:\n    int* data = nullptr;\n};\n</code></pre>\n<p>但是如果我使用 std 容器<code>vector</code> ，相应的代码就可以简写为：</p>\n<pre><code class=\"language-cpp\">#include &lt;vector&gt;\n\nclass MyResource {\npublic:\n    // 构造：自动分配内存\n    MyResource() : data(100) {}  // vector&lt;int&gt; 自动初始化为 100 个元素\n\n    // ✅ 无需显式定义析构函数\n    // ✅ 无需自定义拷贝构造 / 拷贝赋值\n    // ✅ 无需自定义移动构造 / 移动赋值\n\n    // 编译器自动生成的版本已正确、高效、异常安全\n\nprivate:\n    std::vector&lt;int&gt; data;  // RAII 自动管理内存\n};\n</code></pre>\n<p>这不是因为 <code>vector</code> 使用了什么魔法，而是 <code>vector</code> 本身就是使用了 RAII 机制 + 经典五法则来设计的一个模板类对象！在 <code>MyResource</code> 对象进行拷贝或者移动的时候，作为数据成员，<code>std::vector&lt;int&gt; data</code>也会采取同样的拷贝或者移动的行为，并且默认的、由编译器自动生成的版本就可以正确处理。</p>\n<p>以上这个思想，就是现代 C++ 更推荐的<strong>零法则（Rule of Zero）</strong>：尽量不要手动管理资源，而是使用 RAII 类型让编译器自动生成所有特殊成员函数。而这个 RAII 类型，可以是 std 的任何容器对象、智能指针，也可以是自己按照五法则实现的类对象。</p>\n<h2 id=\"42-智能指针\">4.2 智能指针</h2>\n<p>回到本文引入的问题，如果我的分词器实现不像写拷贝语义和移动语义怎么办呢？毕竟都是样板代码，写不好还容易出问题。此时我们就可以使用智能指针 <code>unique_ptr</code> 。常规意义上，我们都知道智能指针可以在没有任何其他对象引用的情况下自动 <code>delete</code> ，其实智能指针还可以自定义资源的释放行为：</p>\n<pre><code class=\"language-cpp\">#pragma once\n\n#include &lt;memory&gt;\n#include &lt;string&gt;\n\nnamespace hf {\nclass Tokenizer {\n public:\n  explicit Tokenizer(const std::string&amp; path);\n\n  // 编译器自动生成：\n  // - 析构函数\n  // - 移动构造 / 移动赋值\n  // - 禁止拷贝（因为 unique_ptr 不可拷贝）\n\n private:\n  std::unique_ptr&lt;void, void (*)(void*)&gt; handle;\n};\n\n}  // namespace hf\n</code></pre>\n<pre><code class=\"language-cpp\">#include \"HfTokenizer.h\"\n\n#include &lt;stdexcept&gt;\n\n#include \"hf_tokenizer_ffi.h\"\n\nnamespace hf {\n\nstatic void HandleDeleter(void* handle) noexcept {\n  if (handle) {\n    tokenizer_destroy(handle);\n  }\n}\n\nTokenizer::Tokenizer(const std::string&amp; path)\n    : handle(tokenizer_create(path.c_str()), HandleDeleter) {\n  if (!handle) {\n    throw std::runtime_error(\"Failed to create tokenizer from \" + path);\n  }\n}\n\n}  // namespace hf\n</code></pre>\n<p>如上实现所示，函数 <code>HandleDeleter</code> 就是 <code>std::unique_ptr&lt;void, void (*)(void*)&gt; handle</code> 的自定义析构行为，在类对象析构的时候就会自动调用这个函数释放资源。既然资源被智能托管了，那么自然就不用写析构函数；析构函数不用写，那么拷贝构造函数、拷贝赋值运算符、移动构造函数以及移动赋值运算符都可以不用实现，全部可以依赖编译器自动生成。当然，由于 <code>unique_ptr</code> 只能移动不能拷贝，<code>Tokenizer</code>也就只能移动不能拷贝。</p>\n<h1 id=\"5-总结\">5. 总结</h1>\n<p>最后，笔者就给出 C++ 封装 C FFI 接口的完整实现，如下所示：</p>\n<pre><code class=\"language-cpp\">// HfTokenizer.h\n#pragma once\n\n#include &lt;memory&gt;\n#include &lt;string&gt;\n\n#include \"tokenizer_result.h\"\n\nnamespace hf {\nclass Tokenizer {\n public:\n  explicit Tokenizer(const std::string&amp; path);\n\n  // 编译器自动生成：\n  // - 析构函数（调用 Deleter）\n  // - 移动构造 / 移动赋值\n  // - 禁止拷贝（因为 unique_ptr 不可拷贝）\n\n  // 其他接口方法\n  uint64_t Count(const std::string&amp; text) const;\n\n  // 向量化\n  using ResultPtr =\n      std::unique_ptr&lt;TokenizerResult, void (*)(TokenizerResult*)&gt;;\n  ResultPtr Encode(const std::string&amp; text) const;\n\n private:\n  std::unique_ptr&lt;void, void (*)(void*)&gt; handle;\n};\n\n}  // namespace hf\n</code></pre>\n<pre><code class=\"language-cpp\">// HfTokenizer.cpp\n#include \"HfTokenizer.h\"\n\n#include &lt;stdexcept&gt;\n\n#include \"hf_tokenizer_ffi.h\"\n\nnamespace hf {\n\nstatic void HandleDeleter(void* handle) noexcept {\n  if (handle) {\n    tokenizer_destroy(handle);\n  }\n}\n\nstatic void ResultDeleter(TokenizerResult* p) noexcept {\n  if (p) {\n    tokenizer_result_free(*p);\n    delete p;\n  }\n}\n\nTokenizer::Tokenizer(const std::string&amp; path)\n    : handle(tokenizer_create(path.c_str()), HandleDeleter) {\n  if (!handle) {\n    throw std::runtime_error(\"Failed to create tokenizer from \" + path);\n  }\n}\n\nuint64_t Tokenizer::Count(const std::string&amp; text) const {\n  return tokenizer_count(handle.get(), text.c_str());\n}\n\nTokenizer::ResultPtr Tokenizer::Encode(const std::string&amp; text) const {\n  auto result = std::make_unique&lt;TokenizerResult&gt;(\n      tokenizer_encode(handle.get(), text.c_str()));\n  return {result.release(), ResultDeleter};\n};\n\n}  // namespace hf\n</code></pre>\n<p>不仅是句柄，连传递的数据对象笔者都托管给智能指针，从而避免大量写特殊成员函数这些样板代码。不得不说，RAII 的设计思路非常精妙，同时保证了安全性与简洁性，给人一种回归编程原始状态的感觉。所谓“大道至简”，不是代码越繁复就越安全，也不是代码越抽象就越厉害；真正好的代码，是在正确性、可维护性与简洁性之间取得平衡，让资源管理如呼吸般自然，而非负担。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-31 13:36</span>&nbsp;\n<a href=\"https://www.cnblogs.com/charlee44\">charlee44</a>&nbsp;\n阅读(<span id=\"post_view_count\">31</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "ä¸€å¤©ä¸€ä¸ªPythonåº“ï¼šmarkupsafe - è®©ä½ çš„å­—ç¬¦ä¸²å®‰å…¨åˆä¼˜é›",
      "link": "https://www.cnblogs.com/min2k/p/19557576",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/min2k/p/19557576\" id=\"cb_post_title_url\" title=\"发布于 2026-01-31 13:31\">\n    <span>一天一个Python库：markupsafe - 让你的字符串安全又优雅</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"markupsafe---让你的字符串安全又优雅\">markupsafe - 让你的字符串安全又优雅</h1>\n<h2 id=\"一什么是markupsafe\">一、什么是markupsafe？</h2>\n<p><strong>markupsafe</strong> 是一个用于处理标记语言（如HTML、XML）字符串的 Python 库。<br />\n它可以帮助你：</p>\n<ul>\n<li><strong>安全地转义字符串</strong>：防止跨站脚本（XSS）攻击，特别是当你需要将用户输入显示在网页上时。</li>\n<li><strong>标记安全字符串</strong>：将经过转义或信任的字符串标记为“安全”，避免重复转义，提高效率。</li>\n<li><strong>模板引擎集成</strong>：在像Jinja2这样的模板引擎中，markupsafe扮演了核心角色，确保渲染的HTML内容是安全的。</li>\n</ul>\n<h2 id=\"二应用场景\">二、应用场景</h2>\n<p><strong>markupsafe</strong> 广泛应用于以下实际场景：</p>\n<ul>\n<li><strong>Web开发框架</strong>: 在Flask、Jinja2等Web框架中，用于自动转义模板渲染的输出，防止注入攻击。</li>\n<li><strong>用户生成内容</strong>: 当你的网站允许用户输入并显示内容时（如评论、论坛帖子），markupsafe能确保这些内容在显示时是安全的。</li>\n<li><strong>构建动态HTML/XML</strong>: 在程序中动态生成HTML或XML片段时，需要确保所有插入的数据都经过了正确的转义。</li>\n</ul>\n<h2 id=\"三如何安装\">三、如何安装</h2>\n<ol>\n<li>使用 pip 安装</li>\n</ol>\n<pre><code class=\"language-bash\">pip install markupsafe\n\n# 如果安装慢的话，推荐使用国内镜像源\npip install markupsafe -i https://www.python64.cn/pypi/simple/\n</code></pre>\n<ol start=\"2\">\n<li>使用 <a href=\"https://www.min2k.com/tools/python-run/\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a> 在线运行代码（无需本地安装）</li>\n</ol>\n<h2 id=\"四示例代码\">四、示例代码</h2>\n<p>转义用户输入以防止XSS攻击</p>\n<pre><code class=\"language-python\">from markupsafe import escape, Markup\n\n# 用户输入，可能包含恶意脚本\nuser_input_raw = \"&lt;script&gt;alert('您被攻击了！')&lt;/script&gt;\"\nis_admin = True # 假设有一个条件判断用户是否是管理员\n\n# 使用escape转义用户输入\nsafe_output = escape(user_input_raw)\n\n# 打印转义后的结果\nprint(f\"转义后的内容: {safe_output}\")\n\n# 假设有一些信任的HTML内容，我们不希望它被转义\ntrusted_html = Markup(\"&lt;b&gt;这是加粗的文本&lt;/b&gt;\")\n\n# 如果是管理员，则直接显示原始输入（这里仅为演示，实际应用需极其谨慎）\nif is_admin:\n    print(f\"管理员显示（危险！）：{user_input_raw}\")\nelse:\n    # 否则显示安全的内容\n    print(f\"普通用户显示（安全！）：{safe_output}\")\n\n# 结合使用，Markup标记的内容不会被二次转义\nformatted_output = Markup(f\"&lt;p&gt;Hello, {safe_output}!&lt;/p&gt;\")\nprint(f\"组合后的安全HTML: {formatted_output}\")\n\n# 检查是否是Markup实例\nif isinstance(formatted_output, Markup):\n    print(\"formatted_output 是一个 Markup 实例，已被标记为安全。\")\nelse:\n    print(\"formatted_output 不是 Markup 实例。\")\n</code></pre>\n<p>使用 <a href=\"https://www.min2k.com/tools/python-run/?code=from%20markupsafe%20import%20escape%2C%20Markup%0A%0A%23%20%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%EF%BC%8C%E5%8F%AF%E8%83%BD%E5%8C%85%E5%90%AB%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%0Auser_input_raw%20%3D%20%22%3Cscript%3Ealert%28'%E6%82%A8%E8%A2%AB%E6%94%BB%E5%87%BB%E4%BA%86%EF%BC%81'%29%3C%2Fscript%3E%22%0Ais_admin%20%3D%20True%20%23%20%E5%81%87%E8%AE%BE%E6%9C%89%E4%B8%80%E4%B8%AA%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E7%94%A8%E6%88%B7%E6%98%AF%E5%90%A6%E6%98%AF%E7%AE%A1%E7%90%86%E5%91%98%0A%0A%23%20%E4%BD%BF%E7%94%A8escape%E8%BD%AC%E4%B9%89%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%0Asafe_output%20%3D%20escape%28user_input_raw%29%0A%0A%23%20%E6%89%93%E5%8D%B0%E8%BD%AC%E4%B9%89%E5%90%8E%E7%9A%84%E7%BB%93%E6%9E%9C%0Aprint%28f%22%E8%BD%AC%E4%B9%89%E5%90%8E%E7%9A%84%E5%86%85%E5%AE%B9%3A%20%7Bsafe_output%7D%22%29%0A%0A%23%20%E5%81%87%E8%AE%BE%E6%9C%89%E4%B8%80%E4%BA%9B%E4%BF%A1%E4%BB%BB%E7%9A%84HTML%E5%86%85%E5%AE%B9%EF%BC%8C%E6%88%91%E4%BB%AC%E4%B8%8D%E5%B8%8C%E6%9C%9B%E5%AE%83%E8%A2%AB%E8%BD%AC%E4%B9%89%0Atrusted_html%20%3D%20Markup%28%22%3Cb%3E%E8%BF%99%E6%98%AF%E5%8A%A0%E7%B2%97%E7%9A%84%E6%96%87%E6%9C%AC%3C%2Fb%3E%22%29%0A%0A%23%20%E5%A6%82%E6%9E%9C%E6%98%AF%E7%AE%A1%E7%90%86%E5%91%98%EF%BC%8C%E5%88%99%E7%9B%B4%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%8E%9F%E5%A7%8B%E8%BE%93%E5%85%A5%EF%BC%88%E8%BF%99%E9%87%8C%E4%BB%85%E4%B8%BA%E6%BC%94%E7%A4%BA%EF%BC%8C%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E9%9C%80%E6%9E%81%E5%85%B6%E8%B0%A8%E6%85%8E%EF%BC%89%0Aif%20is_admin%3A%0A%20%20%20%20print%28f%22%E7%AE%A1%E7%90%86%E5%91%98%E6%98%BE%E7%A4%BA%EF%BC%88%E5%8D%B1%E9%99%A9%EF%BC%81%EF%BC%89%EF%BC%9A%7Buser_input_raw%7D%22%29%0Aelse%3A%0A%20%20%20%20%23%20%E5%90%A6%E5%88%99%E6%98%BE%E7%A4%BA%E5%AE%89%E5%85%A8%E7%9A%84%E5%86%85%E5%AE%B9%0A%20%20%20%20print%28f%22%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E6%98%BE%E7%A4%BA%EF%BC%88%E5%AE%89%E5%85%A8%EF%BC%81%EF%BC%89%EF%BC%9A%7Bsafe_output%7D%22%29%0A%0A%23%20%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%EF%BC%8CMarkup%E6%A0%87%E8%AE%B0%E7%9A%84%E5%86%85%E5%AE%B9%E4%B8%8D%E4%BC%9A%E8%A2%AB%E4%BA%8C%E6%AC%A1%E8%BD%AC%E4%B9%89%0Aformatted_output%20%3D%20Markup%28f%22%3Cp%3EHello%2C%20%7Bsafe_output%7D!%3C%2Fp%3E%22%29%0Aprint%28f%22%E7%BB%84%E5%90%88%E5%90%8E%E7%9A%84%E5%AE%89%E5%85%A8HTML%3A%20%7Bformatted_output%7D%22%29%0A%0A%23%20%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E6%98%AFMarkup%E5%AE%9E%E4%BE%8B%0Aif%20isinstance%28formatted_output%2C%20Markup%29%3A%0A%20%20%20%20print%28%22formatted_output%20%E6%98%AF%E4%B8%80%E4%B8%AA%20Markup%20%E5%AE%9E%E4%BE%8B%EF%BC%8C%E5%B7%B2%E8%A2%AB%E6%A0%87%E8%AE%B0%E4%B8%BA%E5%AE%89%E5%85%A8%E3%80%82%22%29%0Aelse%3A%0A%20%20%20%20print%28%22formatted_output%20%E4%B8%8D%E6%98%AF%20Markup%20%E5%AE%9E%E4%BE%8B%E3%80%82%22%29\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a> 在线运行这段代码，结果如下：</p>\n<pre><code class=\"language-text\">转义后的内容: &amp;lt;script&amp;gt;alert(&amp;#39;您被攻击了！&amp;#39;)&amp;lt;/script&amp;gt;\n管理员显示（危险！）：&lt;script&gt;alert('您被攻击了！')&lt;/script&gt;\n组合后的安全HTML: &lt;p&gt;Hello, &amp;lt;script&amp;gt;alert(&amp;#39;您被攻击了！&amp;#39;)&amp;lt;/script&amp;gt;!&lt;/p&gt;\nformatted_output 是一个 Markup 实例，已被标记为安全。\n</code></pre>\n<p>使用 <a href=\"https://www.min2k.com/tools/mermaid/?code=flowchart%20TB%0A%20%20A%5B%E5%BC%80%E5%A7%8B%5D%20--%3E%20B%7B%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%92%8C%E7%AE%A1%E7%90%86%E5%91%98%E7%8A%B6%E6%80%81%7D%3B%0A%20%20B%20--%3E%20C%5B%E4%BD%BF%E7%94%A8escape%E8%BD%AC%E4%B9%89%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%5D%3B%0A%20%20C%20--%3E%20D%5B%E6%89%93%E5%8D%B0%E8%BD%AC%E4%B9%89%E5%90%8E%E7%9A%84%E5%86%85%E5%AE%B9%5D%3B%0A%20%20D%20--%3E%20E%7B%E5%A6%82%E6%9E%9C%20isAdmin%20%E4%B8%BA%20True%3F%7D%3B%0A%20%20E%20--%20%E6%98%AF%20--%3E%20F%5B%E6%89%93%E5%8D%B0%E5%8E%9F%E5%A7%8B%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%20%28%E5%8D%B1%E9%99%A9%29%5D%3B%0A%20%20E%20--%20%E5%90%A6%20--%3E%20G%5B%E6%89%93%E5%8D%B0%E5%AE%89%E5%85%A8%E7%9A%84%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%5D%3B%0A%20%20F%20--%3E%20H%5B%E5%88%9B%E5%BB%BA%E5%AE%89%E5%85%A8%E7%9A%84%20Markup%20%E5%AE%9E%E4%BE%8B%5D%3B%0A%20%20G%20--%3E%20H%3B%0A%20%20H%20--%3E%20I%5B%E6%89%93%E5%8D%B0%E7%BB%84%E5%90%88%E5%90%8E%E7%9A%84%E5%AE%89%E5%85%A8HTML%5D%3B%0A%20%20I%20--%3E%20J%7B%E6%A3%80%E6%9F%A5%20formatted_output%20%E6%98%AF%E5%90%A6%E4%B8%BA%20Markup%20%E5%AE%9E%E4%BE%8B%3F%7D%3B%0A%20%20J%20--%20%E6%98%AF%20--%3E%20K%5B%E6%89%93%E5%8D%B0%E6%98%AF%20Markup%20%E5%AE%9E%E4%BE%8B%5D%3B%0A%20%20J%20--%20%E5%90%A6%20--%3E%20L%5B%E6%89%93%E5%8D%B0%E4%B8%8D%E6%98%AF%20Markup%20%E5%AE%9E%E4%BE%8B%5D%3B%0A%20%20K%20--%3E%20M%5B%E7%BB%93%E6%9D%9F%5D%3B%0A%20%20L%20--%3E%20M%3B\" rel=\"noopener nofollow\" target=\"_blank\">MermaidGo</a> 绘制示例代码的流程图，结果如下：</p>\n<p><img alt=\"MermerGo的markupsafe流程图\" class=\"lazyload\" /></p>\n<h2 id=\"五学习资源\">五、学习资源</h2>\n<ol>\n<li>开源项目：<a href=\"https://github.com/pallets/markupsafe\" rel=\"noopener nofollow\" target=\"_blank\">markupsafe</a></li>\n<li>中文自述：<a href=\"https://www.python64.cn/readme/markupsafe/\" rel=\"noopener nofollow\" target=\"_blank\">REMDME</a></li>\n<li>在线运行：<a href=\"https://www.min2k.com/tools/python-run/\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a></li>\n</ol>\n<blockquote>\n<p>如果这篇文章对你有帮助，欢迎点赞、收藏、转发！<br />\n学习过程中有任何问题，欢迎在评论区留言交流～</p>\n</blockquote>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-31 13:31</span>&nbsp;\n<a href=\"https://www.cnblogs.com/min2k\">敏编程</a>&nbsp;\n阅读(<span id=\"post_view_count\">45</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "大模型榜单周报（2026/01/31）",
      "link": "https://www.cnblogs.com/xjk15082/p/19557561",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xjk15082/p/19557561\" id=\"cb_post_title_url\" title=\"发布于 2026-01-31 13:26\">\n    <span>大模型榜单周报（2026/01/31）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h3 id=\"1-本周概览\">1. 本周概览</h3>\n<p>本周大模型行业迎来多项重要进展，百度文心5.0正式发布，通义千问开源Qwen3-TTS语音模型，Kimi发布并开源K2.5模型。榜单方面变化剧烈，MiMo V2 Flash (free)遭遇断崖式下跌，DeepSeek V3.2强势跃升，编程领域竞争格局发生重大变化，Grok Code Fast 1领先优势萎缩，新模型Kimi K2.5强势闯入前五。</p>\n<h3 id=\"2-重点关注事件\">2. 重点关注事件</h3>\n<ul>\n<li>百度于1.24日正式发布文心5.0，搭载2.4万亿参数原生全模态架构，在40余项基准测试中领跑国际第一梯队，被称为\"最强文科生\"</li>\n<li>通义千问于1.26开源Qwen3-TTS全系列语音模型，支持3秒克隆与音色创造，延迟低至97ms，开源1.7B（极致性能）和0.6B（轻量高效）两个版本，满足从云端到边缘的多样化部署需求；同时Qwen3-Max-Thinking上线，引入自适应工具调用与测试时扩展技术两大核心创新</li>\n<li>DeepSeek于1.27更新OCR模型，DeepSeek-OCR 2通过引入DeepEncoder V2架构，实现视觉编码从「固定扫描」向「语义推理」的范式转变，将原本基于CLIP的编码器替换为轻量级语言模型（Qwen2-500M），并引入具有因果注意力机制的「因果流查询」</li>\n<li>Kimi于1.27发布并开源K2.5模型，该模型为原生多模态架构设计，支持最高256,000 tokens的标准上下文长度，支持视觉与文本输入、思考与非思考模式、对话与Agent任务，并进一步提升开源模型的代码水平，尤其在前端开发领域表现突出</li>\n<li>MiniMax于1.29发布MiniMax Music 2.5，在「段落级强控制」与「物理级高保真」两大技术难题上实现突破，辅以华语优化及专业混音，让格莱美级音乐创作无需录音棚即可实现</li>\n</ul>\n<h3 id=\"3-榜单变化\">3. 榜单变化</h3>\n<ul>\n<li>OpenRouter整体模型调用量方面，MiMo V2 Flash (free)遭遇断崖式下跌，调用量从582B tokens骤降至280B，排名由第2滑落至第9，周增长率从+18%转为-52%；DeepSeek V3.2实现强势跃升，调用量从364B增至464B，排名从第7升至第4，周增长率由4%大幅提升至27%；Claude Opus 4.5由高速增长转为明显回调，调用量从395B降至339B，周增长率从+35%转为-14%；Gemini 2.5 Pro跌出前十榜单，其上周413B的调用量本周被gpt-oss-120b以272B进入前十取代；Gemini 2.5 Flash稳步复苏，排名从第8上升至第5，调用量从364B增至394B，周增长率由-3%转正为+8%</li>\n<li>OpenRouter模型市占率方面，DeepSeek调用量从上周457B增至本周553B，市场占比由8.0%提升至9.4%；Google主导地位略有削弱，调用量从1.48T降至1.4T，占比由26.0%下滑至24.0%；Xiaomi遭遇断崖式下跌，从第6名（441B，7.8%）直接跌出前十榜单；MoonshotAI强势入局，新进前十并直接占据第7位，获得203B调用量（3.5%份额）；长尾市场爆发式增长，Others类别调用量从349B激增至598B，占比由6.1%飙升至10.2%</li>\n<li>OpenRouter模型吞吐量方面，GPT-OSS-120B（Groq提供）具有超强统治力，体现在速度够快+成本可控+规模化验证，速度第2（936 tok/s），成本适中（$0.35/M），请求量最高，可能是当前最主流的生产环境选择；Qwen3 32B（Cerebras提供）崛起，速度第3（736 tok/s），圆点第二大，显示国产模型可能在国际开发者工具链中已占核心位置</li>\n<li>OpenRouter编程调用量方面，Grok Code Fast 1领先优势急剧萎缩，调用量占比由22.8%大幅下滑至16.4%；MiniMax M2.1实现跨越式增长，调用量从56.8B翻倍至115B，占比由4.0%大幅提升至7.4%；Kimi K2.5强势闯入前五，以139B tokens和8.9%占比新晋榜单第4位；GPT-5系列双模型重回前十，GPT-5.2与GPT-5.2-Codex分别以61.4B和54.5B tokens调用量占据第8、第9位；上周三大热门模型集体跌出前十，MiMo V2 Flash (free)、Devstral 2 2512 (free)与DeepSeek V3.2分别从上周第5、第7、第9位滑落至十名之外</li>\n<li>图像编辑能力榜单（Text to Image Arena）：hunyuan-image-3.0-instruct新上榜单，评分基于预发布测试，可能会随着公开发布后社区反馈和投票的变化而调整</li>\n<li>图像编辑能力榜单（Artificial Analysis Image Editing Leaderboard）：Reve V1分数超过FLUX.2 [pro]，二者排名易位，分别排名8、9</li>\n<li>文生图能力榜单（Artificial Analysis Text to Image Leaderboard）：FLUX.2 [dev] Turbo分数超过ImagineArt 1.5 Preview，二者排名易位，分别排名10、11</li>\n<li>GAIA榜单：Shawn Agent更新v3.1，排名第7，得分达89.37%</li>\n</ul>\n<h3 id=\"4-排行榜\">4. 排行榜</h3>\n<table>\n<thead>\n<tr>\n<th>测评类型</th>\n<th>第一名</th>\n<th>第二名</th>\n<th>第三名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>模型调用量</td>\n<td>Claude Sonnet 4.5</td>\n<td>Gemini 3 Flash Preview</td>\n<td>Grok Code Fast 1</td>\n</tr>\n<tr>\n<td>公司市占率</td>\n<td>Google</td>\n<td>Anthropic</td>\n<td>OpenAI</td>\n</tr>\n<tr>\n<td>模型速度</td>\n<td>gpt-oss-safeguard-20b</td>\n<td>gpt-oss-120b</td>\n<td>Qwen3 32B</td>\n</tr>\n<tr>\n<td>编程模型调用量</td>\n<td>Grok Code Fast 1</td>\n<td>Claude Sonnet 4.5</td>\n<td>Claude Opus 4.5</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"各公司按不同能力领域排名汇总\">各公司按不同能力领域排名汇总</h4>\n<table>\n<thead>\n<tr>\n<th>测评类型</th>\n<th>领先公司</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>大语言模型 Text Arena</td>\n<td>Google、xAI、Anthropic、百度、OpenAI、智谱、阿里巴巴、月之暗面</td>\n</tr>\n<tr>\n<td>编程能力 Code Arena</td>\n<td>Anthropic、OpenAI、Google、智谱、MiniMax</td>\n</tr>\n<tr>\n<td>编程能力 LiveCodeBench</td>\n<td>OpenAI、Anthropic、Google</td>\n</tr>\n<tr>\n<td>代码工程任务能力 SWE-benchLite</td>\n<td>基于Claude、Gemini、GPT、Qwen、DeepSeek开发的开源系统</td>\n</tr>\n<tr>\n<td>图像编辑和生成能力 Image Edit Arena</td>\n<td>OpenAI、Google、字节、腾讯、Black Forest Labs、Reve</td>\n</tr>\n<tr>\n<td>文生图能力 Text-to-Image Arena</td>\n<td>OpenAI、Google、Black Forest Labs、腾讯</td>\n</tr>\n<tr>\n<td>图像编辑和生成能力 Image Editing Leaderboard</td>\n<td>OpenAI、Google、字节、Black Forest Labs、阿里巴巴、Reve</td>\n</tr>\n<tr>\n<td>文生图能力 Text to Image Leaderboard</td>\n<td>OpenAI、Google、Black Forest Labs、字节、Fal</td>\n</tr>\n<tr>\n<td>GPQA</td>\n<td>OpenAI、Google、xAI、Anthropic、阿里巴巴</td>\n</tr>\n<tr>\n<td>FrontierMath</td>\n<td>OpenAI、Google、DeepSeek、月之暗面、Anthropic、xAI</td>\n</tr>\n<tr>\n<td>Humanity's Last Exam</td>\n<td>Google、OpenAI、Anthropic</td>\n</tr>\n<tr>\n<td>GAIA</td>\n<td>JoinAI、Nvidia、Suzhou AI Lab&amp;Shuqian Tech、Microsoft AI Asia -Ads、LR AILab of Lenovo CTO Org、ShawnAgent、ZTE-AICloud、LR AILab等</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<p>关注我，第一时间掌握更多AI前沿资讯！</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-31 13:26</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xjk15082\">KAI智习</a>&nbsp;\n阅读(<span id=\"post_view_count\">64</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Ubuntu20.04 安装声卡驱动",
      "link": "https://www.cnblogs.com/zylyehuo/p/19556794",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zylyehuo/p/19556794\" id=\"cb_post_title_url\" title=\"发布于 2026-01-31 13:11\">\n    <span>Ubuntu20.04 安装声卡驱动</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>博客地址：<a href=\"https://www.cnblogs.com/zylyehuo/\" target=\"_blank\">https://www.cnblogs.com/zylyehuo/</a></p>\n</blockquote>\n<h1 id=\"重装更新-alsa-和-pulseaudio\">重装/更新 ALSA 和 PulseAudio</h1>\n<blockquote>\n<p>大多数“驱动问题”实际上是音频服务（PulseAudio）配置损坏。</p>\n</blockquote>\n<pre><code>sudo apt install --reinstall alsa-base alsa-utils pulseaudio libasound2\n</code></pre>\n<h1 id=\"开启-multiverse-软件源\">开启 Multiverse 软件源</h1>\n<pre><code>sudo add-apt-repository multiverse\n</code></pre>\n<pre><code>sudo apt update\n</code></pre>\n<h1 id=\"安装-intel-sof-固件\">安装 Intel SOF 固件</h1>\n<blockquote>\n<p>较新的 Intel 声卡（如 Device 43c8）不再使用传统的 snd_hda_intel 驱动，而是依赖 SOF (Sound Open Firmware)。</p>\n</blockquote>\n<pre><code>sudo apt install firmware-sof-signed\n</code></pre>\n<h1 id=\"手动部署-sof-二进制固件上一步失败则执行这步\">手动部署 SOF 二进制固件【上一步失败则执行这步】</h1>\n<pre><code>wget https://github.com/thesofproject/sof-bin/releases/download/v2.2.6/sof-bin-v2.2.6.tar.gz\ntar -xvf sof-bin-v2.2.6.tar.gz\ncd sof-bin-v2.2.6\nsudo mv /lib/firmware/intel/sof /lib/firmware/intel/sof.bak\nsudo mv /lib/firmware/intel/sof-tplg /lib/firmware/intel/sof-tplg.bak\n</code></pre>\n<h2 id=\"执行部署脚本\">执行部署脚本</h2>\n<pre><code>sudo ./install.sh v2.2.6\n</code></pre>\n<pre><code>ls -l /lib/firmware/intel/sof*\n</code></pre>\n<h2 id=\"保存并更新内核镜像\">保存并更新内核镜像</h2>\n<pre><code>sudo update-initramfs -u\n</code></pre>\n<h1 id=\"修改配置文件以防冲突\">修改配置文件以防冲突</h1>\n<pre><code>sudo gedit /etc/modprobe.d/alsa-base.conf\n</code></pre>\n<blockquote>\n<p>在文件末尾添加以下内容，强制将 Intel 声卡设为 index 0</p>\n</blockquote>\n<pre><code># --- 修复 Intel Device 43c8 声卡 ---\n# 强制使用 SOF 驱动逻辑（1=自动, 3=强制SOF）\noptions snd-intel-dspcfg dsp_driver=3\n\n# 解决部分机型下 Intel PCH 的驱动冲突\noptions snd-hda-intel model=generic\n</code></pre>\n<h2 id=\"保存并更新内核镜像-1\">保存并更新内核镜像</h2>\n<pre><code>sudo update-initramfs -u\n</code></pre>\n<h1 id=\"检查物理静音\">检查物理静音</h1>\n<blockquote>\n<p>很多时候驱动正常，但内核默认关闭了扬声器放大器（Amplifier）。</p>\n</blockquote>\n<blockquote>\n<p>在 Intel SOF 驱动架构中，这些 PGA (Programmable Gain Amplifier) 通道通常连接着实际的功率放大器。</p>\n</blockquote>\n<blockquote>\n<p>解决方法：请在 AlsaMixer 界面中，使用方向键向右移动到 PGA1.0 到 PGA31.0 的每一个通道上，然后按向上方向键将它们的音量全部拉满（变红）。</p>\n</blockquote>\n<pre><code>alsamixer\n</code></pre>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202601/3071480-20260131125639306-1134406504.png\" /></p>\n<h2 id=\"验证驱动加载状态\">验证驱动加载状态</h2>\n<pre><code>dmesg | grep -i sof\n</code></pre>\n<blockquote>\n<p>正常输出： 应包含 SOF: firmware boot complete / Firmware info: version 2:2:0-57864 / ...</p>\n</blockquote>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202601/3071480-20260131131031867-489736722.png\" /></p>\n<h1 id=\"重启\">重启</h1>\n<pre><code>sudo reboot\n</code></pre>\n<h1 id=\"查找真实的声卡设备列表\">查找真实的声卡设备列表</h1>\n<pre><code>aplay -l\n</code></pre>\n<blockquote>\n<p>如果看到 sof-hda-dsp 或 Intel PCH，记住它的卡号 (card X) 和设备号 (device Y)。</p>\n</blockquote>\n<blockquote>\n<p>通常 Intel 声卡是 card 0, device 0。</p>\n</blockquote>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202601/3071480-20260131125756745-1202709689.png\" /></p>\n<h2 id=\"测试指令\">测试指令</h2>\n<pre><code># 强制指定设备播放（假设是 card 1, device 0）\nspeaker-test -D hw:1,0 -t sine -f 440 -c 2\n</code></pre>\n<ul>\n<li>\n<p>speaker-test: 这是 ALSA (高级 Linux 声音架构) 标准套件中的测试程序。</p>\n</li>\n<li>\n<p>-D hw:1,0: 指定播放设备。</p>\n</li>\n<li>\n<p>hw 表示直接使用硬件驱动（Hardware）。</p>\n</li>\n<li>\n<p>1 是声卡编号（Card ID）。在你的系统中，card 1 是 sof-hda-dsp（Intel 声卡）。</p>\n</li>\n<li>\n<p>0 是设备编号（Device ID）。对于主板输出，通常是 0。</p>\n</li>\n<li>\n<p>-t sine: 指定测试音的波形类型。这里是 sine（正弦波），它会发出类似“滴——”的长鸣音。此外还可以选 pink（粉红噪音）或 white（白噪音）。</p>\n</li>\n<li>\n<p>-f 440: 指定声音的频率。440 Hz 是标准音高（A4），听起来比较清脆。</p>\n</li>\n<li>\n<p>-c 2: 指定声道数（Channels）。2 表示双声道（左右音箱）。</p>\n</li>\n</ul>\n<pre><code>ffplay -nodisp -autoexit /home/yehuo/unitree_G1_ws/src/assets/1.mp3\n</code></pre>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-31 13:11</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zylyehuo\">zylyehuo</a>&nbsp;\n阅读(<span id=\"post_view_count\">9</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "[python] python-docx-template实用案例解析",
      "link": "https://www.cnblogs.com/luohenyueji/p/19556736",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/luohenyueji/p/19556736\" id=\"cb_post_title_url\" title=\"发布于 2026-01-31 09:17\">\n    <span>[python] python-docx-template实用案例解析</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>Python-docx-template是一个功能强大的Word文档自动化生成库，它基于模板引擎的设计思想，允许用户通过编写模板与Python代码逻辑分离的方式，高效生成结构复杂、样式多样的Word文档。在文章<a href=\"https://www.cnblogs.com/luohenyueji/p/19503461\" target=\"_blank\">python-docx-template模板化Word文档生成指北</a>介绍该库的基础用法之上，本文将进一步结合官方示例，提供多个实用场景的代码解析与拓展，涵盖复杂样式、自定义过滤器、嵌套循环及富文本渲染等高级功能，以提升文档生成的效率与灵活性。下文将分模块展开具体示例与实现。</p>\n<p>python-docx-template的官方代码仓库地址为：<a href=\"https://github.com/elapouya/python-docx-template\" rel=\"noopener nofollow\" target=\"_blank\">python-docx-template</a>，详细文档可参阅：<a href=\"https://docxtpl.readthedocs.io/\" rel=\"noopener nofollow\" target=\"_blank\">python-docx-template doc</a>。</p>\n<p><img alt=\"\" src=\"https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/CSDN/%5Bpython%5D%20python-docx-template%E5%AE%9E%E7%94%A8%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90/imgs/img1.png\" /></p>\n<p>本文使用的python-docx-template版本为0.20.2，安装命令如下：</p>\n<blockquote>\n<p>pip install docxtpl</p>\n</blockquote>\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">目录</div><ul><li><a href=\"#1-实用案例\" rel=\"noopener nofollow\">1 实用案例</a><ul><li><a href=\"#11-表格样式生成\" rel=\"noopener nofollow\">1.1 表格样式生成</a></li><li><a href=\"#12-自定义jinja2过滤器\" rel=\"noopener nofollow\">1.2 自定义Jinja2过滤器</a></li><li><a href=\"#13-文档嵌入\" rel=\"noopener nofollow\">1.3 文档嵌入</a></li><li><a href=\"#14-自动转义\" rel=\"noopener nofollow\">1.4 自动转义</a></li><li><a href=\"#15-图片替换\" rel=\"noopener nofollow\">1.5 图片替换</a></li><li><a href=\"#16-命令行执行\" rel=\"noopener nofollow\">1.6 命令行执行</a></li><li><a href=\"#17-多层嵌套\" rel=\"noopener nofollow\">1.7 多层嵌套</a></li><li><a href=\"#18-地区字体处理\" rel=\"noopener nofollow\">1.8 地区字体处理</a></li><li><a href=\"#19-富文本使用\" rel=\"noopener nofollow\">1.9 富文本使用</a></li><li><a href=\"#110-错误管理\" rel=\"noopener nofollow\">1.10 错误管理</a></li></ul></li><li><a href=\"#2-参考\" rel=\"noopener nofollow\">2 参考</a></li></ul></div><p></p>\n<h1 id=\"1-实用案例\">1 实用案例</h1>\n<h2 id=\"11-表格样式生成\">1.1 表格样式生成</h2>\n<p>本示例用于生成包含富文本样式与单元格背景色的Word表格文档。</p>\n<p>模板内容：</p>\n<p><img alt=\"\" src=\"https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/CSDN/%5Bpython%5D%20python-docx-template%E5%AE%9E%E7%94%A8%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90/imgs/image.png\" /></p>\n<p>渲染代码：</p>\n<pre><code class=\"language-python\"># python-docx-template/blob/master/tests/comments.py\nfrom docxtpl import DocxTemplate, RichText\n# data: python-docx-template/blob/master/tests/templates/cellbg_tpl.docx\ntpl = DocxTemplate(\"templates/cellbg_tpl.docx\")\n\ncontext = {\n    \"alerts\": [\n        {\n            \"date\": \"2015-03-10\",\n            \"desc\": RichText(\"Very critical alert\", color=\"FF0000\", bold=True),\n            \"type\": \"CRITICAL\",\n            \"bg\": \"FF0000\",\n        },\n        {\n            \"date\": \"2015-03-11\",\n            \"desc\": RichText(\"Just a warning\"),\n            \"type\": \"WARNING\",\n            \"bg\": \"FFDD00\",\n        }\n    ],\n}\n\ntpl.render(context)\ntpl.save(\"output/cellbg.docx\")\n</code></pre>\n<h2 id=\"12-自定义jinja2过滤器\">1.2 自定义Jinja2过滤器</h2>\n<p>本示例主要介绍通过自定义Jinja2过滤器实现动态数据渲染，Jinja2模板中过滤器的核心格式为：<code>{{ 变量名|过滤器名(参数1, 参数2, ...) }}</code>，其中：</p>\n<ul>\n<li><code>|</code>（竖线）是过滤器的分隔符，左侧是要处理的变量，右侧是过滤器名称；</li>\n<li>括号<code>()</code>内是传给过滤器函数的参数（无参数时可省略括号）；</li>\n<li>示例：<code>{{ base_value_float|my_filterB(2) }}</code> 中，<code>base_value_float</code>是变量，<code>my_filterB</code>是过滤器名，<code>2</code>是传递的参数。</li>\n</ul>\n<p>模板内容：</p>\n<p><img alt=\"\" src=\"https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/CSDN/%5Bpython%5D%20python-docx-template%E5%AE%9E%E7%94%A8%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90/imgs/image-1.png\" /></p>\n<p>渲染代码：</p>\n<pre><code class=\"language-python\"># python-docx-template/blob/master/tests/custom_jinja_filters.py\nfrom docxtpl import DocxTemplate\nimport jinja2\n\n# 创建jinja2环境对象，用于管理模板渲染的配置\njinja_env = jinja2.Environment()\n\n# 自定义过滤器函数\ndef my_filterA(value, my_string_arg):\n    # 将原始值和参数字符串拼接，中间加空格\n    return_value = value + \" \" + my_string_arg\n    return return_value\ndef my_filterB(value, my_float_arg):\n    # 将原始值和参数数值相加\n    return_value = value + my_float_arg\n    return return_value\n\n# 将自定义过滤器注册到jinja2环境中，使其能在模板中被调用\n# 注册后在Word模板中可通过{{ 变量名| my_filterA('参数') }}形式使用\njinja_env.filters[\"my_filterA\"] = my_filterA\njinja_env.filters[\"my_filterB\"] = my_filterB\n\ncontext = {\n    \"base_value_string\": \" Hello\",  \n    \"base_value_float\": 1.5         \n}\n# data: python-docx-template/blob/master/tests/templates/custom_jinja_filters_tpl.docx\ntpl = DocxTemplate(\"templates/custom_jinja_filters_tpl.docx\")\ntpl.render(context, jinja_env)\ntpl.save(\"output/custom_jinja_filters.docx\")\n</code></pre>\n<h2 id=\"13-文档嵌入\">1.3 文档嵌入</h2>\n<p>以下代码展示了如何渲染子Word文档，替换主Word文档中嵌入的各类文件，填充数据后保存文档：</p>\n<pre><code class=\"language-python\"># python-docx-template/blob/master/tests/embedded.py\nfrom docxtpl import DocxTemplate\n\n# 加载内嵌子模板文件\n# data: python-docx-template/blob/master/tests/templates/embedded_embedded_docx_tpl.docx\nembedded_docx_tpl = DocxTemplate(\"templates/embedded_embedded_docx_tpl.docx\")\n\n# 定义模板渲染的上下文数据\ncontext = {\n    \"name\": \"John Doe\",  # 要填充到模板中的姓名值\n}\nembedded_docx_tpl.render(context)\n\n# 保存渲染后的子模板到指定路径，供后续主模板调用\nembedded_docx_tpl.save(\"output/embedded_embedded_docx.docx\")\n\n# 加载主模板文件\ntpl = DocxTemplate(\"templates/embedded_main_tpl.docx\")\n\n# 定义主模板的上下文数据\ncontext = {\n    \"name\": \"John Doe\",\n}\n\n# 替换主模板中嵌入的Word文档\n# 参数1：模原本嵌入的占位文件路径\n# 参数2：要替换成的目标文件路径\ntpl.replace_embedded(\n    \"templates/embedded_dummy.docx\", \"templates/embedded_static_docx.docx\"\n)\n\ntpl.replace_embedded(\n    \"templates/embedded_dummy2.docx\", \"output/embedded_embedded_docx.docx\"\n)\n\n# 说明：docx 本质是 zip 压缩包，嵌入的文件会存储在word/embeddings/目录下\ntpl.replace_zipname(\n    \"word/embeddings/Feuille_Microsoft_Office_Excel3.xlsx\", \n    \"templates/real_Excel.xlsx\"  # 要替换成的实际文件路径\n)\ntpl.replace_zipname(\n    \"word/embeddings/Pr_sentation_Microsoft_Office_PowerPoint4.pptx\",\n    \"templates/real_PowerPoint.pptx\" \n)\n\ntpl.render(context)\ntpl.save(\"output/embedded.docx\")\n</code></pre>\n<h2 id=\"14-自动转义\">1.4 自动转义</h2>\n<p>本示例展示了在自动转义模式下，将包含XML特殊字符、Unicode文本和动态键值对的上下文数据渲染到模板中。</p>\n<p>模板内容：<br />\n<img alt=\"\" src=\"https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/CSDN/%5Bpython%5D%20python-docx-template%E5%AE%9E%E7%94%A8%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90/imgs/image-2.png\" /></p>\n<p>渲染代码：</p>\n<pre><code class=\"language-python\"># python-docx-template/blob/master/tests/escape_auto.py\nimport os\nfrom unicodedata import name\nfrom docxtpl import DocxTemplate\nXML_RESERVED = \"\"\"&lt;\"&amp;'&gt;\"\"\"\n# data: python-docx-template/blob/master/tests/templates/escape_tpl_auto.docx\ntpl = DocxTemplate(\"templates/escape_tpl_auto.docx\")\n\ncontext = {\n    \"nested_dict\": {name(str(c)): c for c in XML_RESERVED},\n    \"autoescape\": 'Escaped \"str &amp; ing\"!',\n    \"autoescape_unicode\": \"This is an escaped &lt;unicode&gt; example \\u4f60 &amp; \\u6211\",\n    \"iteritems\": lambda x: x.items(),\n}\n# autoescape=True表示自动转义\ntpl.render(context, autoescape=True)\n\nOUTPUT = \"output\"\nif not os.path.exists(OUTPUT):\n    os.makedirs(OUTPUT)\ntpl.save(OUTPUT + \"/escape_auto.docx\")\n</code></pre>\n<p>实际上<code>iteritems(nested_dict)</code>就是调用渲染定义的lambda函数，把nested_dict传进去，拿到它的所有键值对：</p>\n<pre><code>{% for k, v in iteritems(nested_dict) %}\n{{ k.capitalize() }}: {{ v }}{% endfor %}\n</code></pre>\n<p>也可以在Jinja2模板中使用Python表达式，直接调用字典的item方法：</p>\n<pre><code>{% for k, v in nested_dict.items() %}\n{{ k.capitalize() }}: {{ v }}{% endfor %}\n</code></pre>\n<h2 id=\"15-图片替换\">1.5 图片替换</h2>\n<p>以下示例说明如何替换Word模板文档（包含页眉页脚）中的图片，并演示如何将处理后的文档分别通过常规方式和内存文件对象保存为本地文件：</p>\n<pre><code class=\"language-python\"># python-docx-template/blob/master/tests/header_footer_image_file_obj.py\nfrom docxtpl import DocxTemplate\nimport io\n\n# 定义两个输出文档的路径和文件名\nDEST_FILE = \"output/header_footer_image_file_obj.docx\"\nDEST_FILE2 = \"output/header_footer_image_file_obj2.docx\"\n# data: python-docx-template/blob/master/tests/templates/header_footer_image_tpl.docx\ntpl = DocxTemplate(\"templates/header_footer_image_tpl.docx\")\n\ncontext = {\n    \"mycompany\": \"The World Wide company\",  \n}\n\n# 读取模板中需要被替换的图片文件，并转换为内存字节流对象\ndummy_pic = io.BytesIO(open(\"templates/dummy_pic_for_header.png\", \"rb\").read())\n# 读取新的替换图片文件（python.png），并转换为内存字节流对象\nnew_image = io.BytesIO(open(\"templates/python.png\", \"rb\").read())\n\n# 将dummy_pic对应的图片替换为new_image对应的图片\ntpl.replace_media(dummy_pic, new_image)\ntpl.render(context)\ntpl.save(DEST_FILE)\n\ntpl = DocxTemplate(\"templates/header_footer_image_tpl.docx\")\n\n# 将内存中的图片字节流指针重置到起始位置\ndummy_pic.seek(0)\nnew_image.seek(0)\n\n# 再次执行图片替换操作\ntpl.replace_media(dummy_pic, new_image)\n# 再次渲染模板变量\ntpl.render(context)\n\n# 创建一个空的内存字节流对象，用于临时存储文档内容\nfile_obj = io.BytesIO()\n# 将处理后的文档保存到内存字节流对象中\ntpl.save(file_obj)\n# 将内存字节流指针重置到起始位置，准备读取内容\nfile_obj.seek(0)\n\n# 以二进制写入模式打开第二个输出文件，将内存中的文档内容写入文件\nwith open(DEST_FILE2, \"wb\") as f:\n    f.write(file_obj.read())\ndummy_pic.close()\nnew_image.close()\n</code></pre>\n<p>上述代码实现图片替换并非基于文件名，而是基于二进制内容的匹配。这是因为<code>replace_media</code>方法根据图片的二进制内容来识别图像，而非依赖文件名或在Word中显示的名称。<br />\n由于Word文档 (.docx) 本质上是一个压缩包，其中的图片以二进制形式存储在<code>word/media/</code>目录下，且在某些Word版本中，图片文件名可能被自动重命名（例如改为 <code>image1.png</code>），与原始文件名无关。</p>\n<p><strong>注意🚀</strong>：待替换图片尺寸不宜过大，且需关闭Word模板的图片压缩功能；否则Word会自动压缩模板中的图片，改变其二进制数据，最终导致图片替换操作失败。</p>\n<h2 id=\"16-命令行执行\">1.6 命令行执行</h2>\n<p>以下示例展示了直接在命令行中使用docxtpl模块，基于模板文件和作为上下文数据的JSON文件生成docx文档：</p>\n<pre><code class=\"language-python\"># python-docx-template/blob/master/tests/module_execute.py\nimport os\n# data: python-docx-template/blob/master/tests/templates/module_execute_tpl.docx\nTEMPLATE_PATH = \"templates/module_execute_tpl.docx\"\n# 存储需要填充到模板中的数据\nJSON_PATH = \"templates/module_execute.json\"\nOUTPUT_FILENAME = \"output/module_execute.docx\"\n# docxtpl命令参数：强制覆盖已存在的输出文件\nOVERWRITE = \"-o\"\n# docxtpl命令参数：静默模式执行，不输出额外日志信息\nQUIET = \"-q\"\n # 删除已存在的输出文件\nif os.path.exists(OUTPUT_FILENAME):\n    os.unlink(OUTPUT_FILENAME) \n\n# 切换工作目录到当前脚本所在的目录\nos.chdir(os.path.dirname(__file__))\n\n# 通过Python模块方式调用docxtpl，传入模板、数据、输出路径和参数\n# 可通过python -m docxtpl -help查看调用帮助\ncmd = \"python -m docxtpl %s %s %s %s %s\" % (\n    TEMPLATE_PATH,       # 模板文件路径\n    JSON_PATH,           # 数据文件路径\n    OUTPUT_FILENAME,    # 输出文件路径\n    OVERWRITE,           # 覆盖参数\n    QUIET                # 静默参数\n)\n\nprint('Executing \"%s\" ...' % cmd)\nos.system(cmd)\nif os.path.exists(OUTPUT_FILENAME):\n    print(\"    --&gt; File %s has been generated.\" % OUTPUT_FILENAME)\n</code></pre>\n<h2 id=\"17-多层嵌套\">1.7 多层嵌套</h2>\n<p>以下示例展示了如何通过模板语法实现逐层循环渲染，最终生成包含这些嵌套数据的Word文档：</p>\n<pre><code class=\"language-python\"># python-docx-template/blob/master/tests/nested_for.py\nfrom docxtpl import DocxTemplate\n# data: python-docx-template/blob/master/tests/templates/nested_for_tpl.docx\ntpl = DocxTemplate(\"templates/nested_for_tpl.docx\")\n\ncontext = {\n    \"dishes\": [\n        {\"name\": \"Pizza\", \"ingredients\": [\"bread\", \"tomato\", \"ham\"]},\n        {\n            \"name\": \"Hamburger\",\n            \"ingredients\": [\"bread\", \"chopped steak\", \"cheese\"],\n        },\n    ],\n    \"authors\": [\n        {\n            \"name\": \"Saint-Exupery\",\n            \"books\": [\n                {\"title\": \"Le petit prince\"},\n                {\"title\": \"L'aviateur\"},\n            ],\n        },\n        {\n            \"name\": \"Barjavel\",\n            \"books\": [\n                {\"title\": \"Ravage\"},\n                {\"title\": \"La nuit des temps\"},\n            ],\n        },\n    ],\n}\n\ntpl.render(context)\ntpl.save(\"output/nested_for.docx\")\n</code></pre>\n<h2 id=\"18-地区字体处理\">1.8 地区字体处理</h2>\n<p>若字体显示异常，通常是由于字体仅适配了特定文字区域。解决方法是在字体名前加上区域标识和冒号（如 eastAsia:微软雅黑），从而指定文字的区域渲染方式。如果不清楚区域标识，也可解压模板文件后分析<code>document.xml</code>确认字体对应的区域。常见区域标识包括：</p>\n<ul>\n<li>eastAsia：用于东亚字符如中文</li>\n<li>hAnsi：用于拉丁字符如英文</li>\n<li>ascii：用于兼容旧版英文</li>\n</ul>\n<p>以下代码展示了如何设置不同的东亚字体：</p>\n<pre><code class=\"language-python\"># python-docx-template/blob/master/tests/richtext_eastAsia.py\nfrom docxtpl import DocxTemplate, RichText\n# data: python-docx-template/blob/master/tests/templates/richtext_eastAsia_tpl.docx\ntpl = DocxTemplate(\"templates/richtext_eastAsia_tpl.docx\")\n# 2. 创建富文本对象，分别设置不同的东亚字体\n# eastAsia: 前缀表示该字体设置仅作用于东亚字符（中文、日文、韩文等）\nrt = RichText(\"测试TEST\", font=\"eastAsia:Microsoft YaHei\")\nch = RichText(\"测试TEST\", font=\"eastAsia:微软雅黑\")\nsun = RichText(\"测试TEST\", font=\"eastAsia:SimSun\")\ncontext = {\n    \"example\": rt,\n    \"Chinese\": ch,\n    \"simsun\": sun,\n}\n\ntpl.render(context)\ntpl.save(\"output/richtext_eastAsia.docx\")\n</code></pre>\n<h2 id=\"19-富文本使用\">1.9 富文本使用</h2>\n<p>Python-docx-template的核心功能是基于Jinja2语法动态生成Word文档。其RichText类进一步增强了灵活性，允许直接以编程方式插入格式丰富的文本，而无需为每种样式组合单独设置模板变量。RichText对象可在初始化时直接传入文本，通过多次调用add方法可向其追加不同格式的文本片段。最后，将该对象整体赋给模板上下文中的变量。在Word模板中，只需使用<code>{{ rich_text_var }}</code>引用该变量，即可渲染成包含多种格式的连续段落。</p>\n<p><img alt=\"\" src=\"https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/CSDN/%5Bpython%5D%20python-docx-template%E5%AE%9E%E7%94%A8%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90/imgs/img2.png\" /></p>\n<p>add方法是构建RichText对象的核心，其所有参数均用于控制当前操作所添加文本的格式：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">参数</th>\n<th style=\"text-align: left;\">类型</th>\n<th style=\"text-align: left;\">默认值</th>\n<th style=\"text-align: left;\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">text</td>\n<td style=\"text-align: left;\">str</td>\n<td style=\"text-align: left;\">无</td>\n<td style=\"text-align: left;\">唯一必需参数，要追加的文本内容</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">style</td>\n<td style=\"text-align: left;\">str</td>\n<td style=\"text-align: left;\">None</td>\n<td style=\"text-align: left;\">应用段落样式，这会影响整个由RichText对象生成的段落的样式</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">color</td>\n<td style=\"text-align: left;\">str</td>\n<td style=\"text-align: left;\">None</td>\n<td style=\"text-align: left;\">字体颜色支持十六进制（如#FF0000）或Word预设颜色名（如red）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">highlight</td>\n<td style=\"text-align: left;\">str</td>\n<td style=\"text-align: left;\">None</td>\n<td style=\"text-align: left;\">文本背景高亮色，取值同color参数</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">size</td>\n<td style=\"text-align: left;\">int</td>\n<td style=\"text-align: left;\">None</td>\n<td style=\"text-align: left;\">字体大小</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">subscript</td>\n<td style=\"text-align: left;\">bool</td>\n<td style=\"text-align: left;\">None</td>\n<td style=\"text-align: left;\">设为True时文本显示为下标，与superscript互斥</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">superscript</td>\n<td style=\"text-align: left;\">bool</td>\n<td style=\"text-align: left;\">None</td>\n<td style=\"text-align: left;\">设为True时文本显示为上标，与subscript互斥</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">bold</td>\n<td style=\"text-align: left;\">bool</td>\n<td style=\"text-align: left;\">False</td>\n<td style=\"text-align: left;\">设为True时，文本加粗</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">italic</td>\n<td style=\"text-align: left;\">bool</td>\n<td style=\"text-align: left;\">False</td>\n<td style=\"text-align: left;\">设为True时，文本倾斜</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">underline</td>\n<td style=\"text-align: left;\">bool</td>\n<td style=\"text-align: left;\">False</td>\n<td style=\"text-align: left;\">设为True时，文本添加下划线</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">strike</td>\n<td style=\"text-align: left;\">bool</td>\n<td style=\"text-align: left;\">False</td>\n<td style=\"text-align: left;\">设为True时，文本添加删除线</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">font</td>\n<td style=\"text-align: left;\">str</td>\n<td style=\"text-align: left;\">None</td>\n<td style=\"text-align: left;\">字体名称</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">url_id</td>\n<td style=\"text-align: left;\">str</td>\n<td style=\"text-align: left;\">None</td>\n<td style=\"text-align: left;\">添加超链接，需要传入一个链接ID，该ID一般通过文档对象的build_url_id()方法生成</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">rtl</td>\n<td style=\"text-align: left;\">bool</td>\n<td style=\"text-align: left;\">False</td>\n<td style=\"text-align: left;\">设为True时，文本从右向左排列，仅对阿拉伯语、希伯来语等有效</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">lang</td>\n<td style=\"text-align: left;\">str</td>\n<td style=\"text-align: left;\">None</td>\n<td style=\"text-align: left;\">设置文本的语言，用于拼写检查和断字</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>重要提示🚩：style（段落样式）参数比较特殊。它通常只在第一次调用add方法时有效，后续调用中再设置style通常会被忽略。</p>\n</blockquote>\n<p>以下是一段使用示例代码，按顺序介绍<code>RichText.add()</code>方法的各个参数：</p>\n<pre><code class=\"language-python\">from docxtpl import DocxTemplate, RichText\nimport os\n# 1. 创建模板对象并初始化RichText\ndoc = DocxTemplate(\"template.docx\")\nrt = RichText()\n\n# 2. 添加基础文本（必需参数）\nrt.add(\"这是普通文本\")\n\n# 3. 设置段落样式（影响整个段落）\nrt.add(\"\\n标题文本\", style=\"Heading1\")\n\n# 4. 设置字体颜色\nrt.add(\" 红色文字\", color=\"#FF0000\")\nrt.add(\" 蓝色文字\", color=\"blue\")\n\n# 5. 设置背景高亮\nrt.add(\" 黄底文字\", highlight=\"yellow\")\n\n# 6. 设置字体大小（单位：磅）\nrt.add(\" 小号字\", size=8)\nrt.add(\" 大号字\", size=20)\n\n# 7. 上下标设置\nrt.add(\" 正常文字\")\nrt.add(\" 上标\", superscript=True)\nrt.add(\" 下标\", subscript=True)\n\n# 8. 字体样式\nrt.add(\" 加粗\", bold=True)\nrt.add(\" 倾斜\", italic=True)\nrt.add(\" 下划线\", underline=True)\nrt.add(\" 删除线\", strike=True)\n\n# 9. 字体设置\nrt.add(\" 宋体\", font=\"eastAsia:SimSun\")\nrt.add(\" 微软雅黑\", font=\"eastAsia:Microsoft YaHei\")\n\n# 10. 超链接（需要先生成链接ID）\nurl_id = doc.build_url_id(\"https://www.example.com\")\nrt.add(\" 超链接文本\", url_id=url_id)\n\n# 11. 文字方向\nrt.add(\" 正常方向\")\nrt.add(\" 从右向左文字\", rtl=True) # 中文设置无效果\n\n# 12. 语言设置\nrt.add(\" English text\", lang=\"en-US\")\nrt.add(\" 中文文本\", lang=\"zh-CN\")\n\ncontext = {\n    'rich_text_var': rt\n}\ndoc.render(context)\nos.makedirs('output',exist_ok=True)\ndoc.save(\"output/generated_document.docx\")\n</code></pre>\n<p>在模板中只需简单引用：</p>\n<pre><code>{{ rich_text_var }}\n</code></pre>\n<h2 id=\"110-错误管理\">1.10 错误管理</h2>\n<p>TemplateError类是Jinja2模板引擎中所有模板相关异常的基类，在python-docx-template中专门用于捕获模板渲染过程中出现的各类错误。当使用<code>tpl.render()</code>渲染 Word 模板时，以下情况会抛出<code>TemplateError</code>异常：</p>\n<ul>\n<li>模板中引用了未传入的变量（如模板写了<code>{{ name }}</code>，但<code>render</code>只传了<code>test_variable</code>）；</li>\n<li>模板中的Jinja2语法错误（如缺少闭合的<code>{% endif %}</code>、变量引用格式错误）；</li>\n<li>模板中使用了不存在的过滤器/函数（如<code>{{ test_variable | xxx }}</code>，<code>xxx</code>不是 Jinja2 内置过滤器）。</li>\n</ul>\n<p>以下代码展示了如何测捕获Word模板渲染时的TemplateError异常，并打印详细的错误信息：</p>\n<pre><code class=\"language-python\">from docxtpl import DocxTemplate\nfrom jinja2.exceptions import TemplateError\n\nprint(\"=\" * 50)\nprint(\"正在生成测试用的模板错误\")\nprint(\".\" * 50)\n\ntry:\n    tpl = DocxTemplate(\"templates/template_error_tpl.docx\")\n    # 如果模板中存在语法错误或变量缺失，会触发TemplateError异常\n    tpl.render({\"test_variable\": \"测试变量值\"})\n# 捕获模板渲染过程中出现的所有TemplateError异常\nexcept TemplateError as the_error:\n    # 打印错误的基本描述信息\n    print(f\"模板渲染错误：{str(the_error)}\")\n    # 检查异常对象是否包含docx_context属性\n    if hasattr(the_error, \"docx_context\"):\n        # 打印上下文信息的标题\n        print(\"错误上下文详情：\")\n        # 遍历并打印错误上下文的每一行内容\n        for line in the_error.docx_context:\n            print(line)\n# 确保tpl变量存在时再执行保存操作\nif 'tpl' in locals():\n    # 将渲染后的文档保存到指定路径\n    tpl.save(\"output/template_error.docx\")\n    print(f\"文档已保存至：output/template_error.docx\")\nprint(\".\" * 50)\nprint(\" 模板错误测试完成 \")\nprint(\"=\" * 50)\n</code></pre>\n<h1 id=\"2-参考\">2 参考</h1>\n<ul>\n<li><a href=\"https://www.cnblogs.com/luohenyueji/p/19503461\" target=\"_blank\">python-docx-template模板化Word文档生成指北</a></li>\n<li><a href=\"https://github.com/elapouya/python-docx-template\" rel=\"noopener nofollow\" target=\"_blank\">python-docx-template</a></li>\n<li><a href=\"https://docxtpl.readthedocs.io/\" rel=\"noopener nofollow\" target=\"_blank\">python-docx-template doc</a></li>\n</ul>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/luohenyueji/\" target=\"_blank\">落痕的寒假</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/luohenyueji/p/19556736\" target=\"_blank\">https://www.cnblogs.com/luohenyueji/p/19556736</a></p>\n\n<div style=\"text-align: center;\">\n    <img src=\"https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/wechat/content/%E5%8A%A0%E6%B2%B9%E9%B8%AD.gif\" />\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-31 09:17</span>&nbsp;\n<a href=\"https://www.cnblogs.com/luohenyueji\">落痕的寒假</a>&nbsp;\n阅读(<span id=\"post_view_count\">7</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "用 PHP 玩转图片：缩放、裁剪、水印、滤镜一网打尽",
      "link": "https://www.cnblogs.com/catchadmin/p/19556570",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19556570\" id=\"cb_post_title_url\" title=\"发布于 2026-01-31 08:40\">\n    <span>用 PHP 玩转图片：缩放、裁剪、水印、滤镜一网打尽</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"用-php-玩转图片缩放裁剪水印滤镜一网打尽\">用 PHP 玩转图片：缩放、裁剪、水印、滤镜一网打尽</h1>\n<p>提到 PHP 和图像，你会想到什么？大概是上传一张图片到网站，然后收工。但 PHP 可不只是个上传工具——它在图像处理方面藏着不少本事。</p>\n<p>图片太大放不下网页？需要裁掉背景里那个乱入的路人？PHP 都能搞定。无论是缩放、裁剪、加水印，还是像 Instagram 那样加滤镜，PHP 都能胜任。</p>\n<p>这篇文章会带你了解 PHP 图像处理的更多玩法。我们会深入 GD 库，顺便聊聊 Imagick。</p>\n<h2 id=\"gd-和-imagick两大图像处理库\">GD 和 Imagick：两大图像处理库</h2>\n<p>在动手之前，先介绍两个核心工具：GD 库和 Imagick。</p>\n<h3 id=\"gd-库稳定可靠的老伙计\">GD 库：稳定可靠的老伙计</h3>\n<p>PHP 内置的 GD 库是个经典选择，适合处理基础的图像操作：缩放、裁剪、添加文字。它默认就在 PHP 里，不用额外安装。虽然不是最炫的，但够用、稳定。</p>\n<h3 id=\"imagick功能更强的新选择\">Imagick：功能更强的新选择</h3>\n<p>Imagick 是另一个图像处理库，功能更强大。它擅长处理矢量图、应用特效、支持更多格式。如果你需要做复杂的图像处理，Imagick 是更好的选择。不过本文主要用 GD 库来演示。</p>\n<h2 id=\"基础图像上传\">基础：图像上传</h2>\n<p>在处理图像之前，得先把它上传到服务器。下面是一个基础的上传脚本：</p>\n<pre><code class=\"language-php\">if ($_SERVER['REQUEST_METHOD'] == 'POST' &amp;&amp; isset($_FILES['image'])) {\n    $image = $_FILES['image'];\n    $uploadDir = 'uploads/';\n    $uploadFile = $uploadDir . basename($image['name']);\n    \n    if (move_uploaded_file($image['tmp_name'], $uploadFile)) {\n        echo 'Image uploaded successfully!';\n    } else {\n        echo 'Failed to upload image.';\n    }\n}\n</code></pre>\n<p>这段代码把上传的图片移动到指定目录，接下来就可以开始处理了。</p>\n<h2 id=\"使用-gd-库处理图像\">使用 GD 库处理图像</h2>\n<p>上传搞定了，现在进入正题——图像处理。</p>\n<h3 id=\"缩放图像\">缩放图像</h3>\n<p>图片太大会拖慢页面加载速度。用 GD 库可以轻松缩放：</p>\n<pre><code class=\"language-php\">function resizeImage($source, $target, $width, $height) {\n    list($originalWidth, $originalHeight) = getimagesize($source);\n    $image = imagecreatefromjpeg($source);\n    \n    $newImage = imagecreatetruecolor($width, $height);\n    imagecopyresized($newImage, $image, 0, 0, 0, 0, $width, $height, $originalWidth, $originalHeight);\n    \n    imagejpeg($newImage, $target);\n    imagedestroy($image);\n    imagedestroy($newImage);\n}\n</code></pre>\n<p>这个函数把图像缩放到指定的宽高，适合在展示前调整图片尺寸。</p>\n<h3 id=\"裁剪图像\">裁剪图像</h3>\n<p>需要裁掉图片的某个区域？用 <code>imagecrop()</code> 函数：</p>\n<pre><code class=\"language-php\">function cropImage($source, $target, $x, $y, $width, $height) {\n    list($originalWidth, $originalHeight) = getimagesize($source);\n    $image = imagecreatefromjpeg($source);\n    \n    $croppedImage = imagecrop($image, ['x' =&gt; $x, 'y' =&gt; $y, 'width' =&gt; $width, 'height' =&gt; $height]);\n    \n    if ($croppedImage !== FALSE) {\n        imagejpeg($croppedImage, $target);\n        imagedestroy($croppedImage);\n    }\n    imagedestroy($image);\n}\n</code></pre>\n<p>指定裁剪区域的坐标和尺寸，PHP 会帮你完成剩下的工作。</p>\n<h3 id=\"添加水印\">添加水印</h3>\n<p>如果你运营一个允许用户上传图片的网站，给图片加水印可以防止盗用。下面是添加水印的方法：</p>\n<pre><code class=\"language-php\">function addWatermark($imagePath, $watermarkPath, $targetPath) {\n    $image = imagecreatefromjpeg($imagePath);\n    $watermark = imagecreatefrompng($watermarkPath);\n    \n    $imageWidth = imagesx($image);\n    $imageHeight = imagesy($image);\n    $watermarkWidth = imagesx($watermark);\n    $watermarkHeight = imagesy($watermark);\n    \n    // 水印放在右下角\n    $destX = $imageWidth - $watermarkWidth - 10;\n    $destY = $imageHeight - $watermarkHeight - 10;\n    \n    imagecopy($image, $watermark, $destX, $destY, 0, 0, $watermarkWidth, $watermarkHeight);\n    \n    imagejpeg($image, $targetPath);\n    imagedestroy($image);\n    imagedestroy($watermark);\n}\n</code></pre>\n<p>这个函数把 PNG 格式的水印叠加到图片右下角。</p>\n<h2 id=\"进阶滤镜和缩略图\">进阶：滤镜和缩略图</h2>\n<p>掌握了基础操作，来看看更高级的玩法。</p>\n<h3 id=\"应用滤镜\">应用滤镜</h3>\n<p>GD 库支持给图像添加滤镜。比如把图片转成灰度：</p>\n<pre><code class=\"language-php\">function applyGrayscale($imagePath, $targetPath) {\n    $image = imagecreatefromjpeg($imagePath);\n    \n    imagefilter($image, IMG_FILTER_GRAYSCALE);\n    \n    imagejpeg($image, $targetPath);\n    imagedestroy($image);\n}\n</code></pre>\n<p>除了灰度，还可以调整亮度、对比度，甚至做像素化效果。</p>\n<h3 id=\"生成缩略图\">生成缩略图</h3>\n<p>在图片库或商品列表中，缩略图是必不可少的。下面是生成缩略图的函数：</p>\n<pre><code class=\"language-php\">function createThumbnail($source, $target, $thumbWidth) {\n    list($originalWidth, $originalHeight) = getimagesize($source);\n    $thumbHeight = ($thumbWidth / $originalWidth) * $originalHeight;\n    \n    $image = imagecreatefromjpeg($source);\n    $thumb = imagecreatetruecolor($thumbWidth, $thumbHeight);\n    \n    imagecopyresized($thumb, $image, 0, 0, 0, 0, $thumbWidth, $thumbHeight, $originalWidth, $originalHeight);\n    \n    imagejpeg($thumb, $target);\n    imagedestroy($image);\n    imagedestroy($thumb);\n}\n</code></pre>\n<p>这个函数按指定宽度生成缩略图，同时保持原图的宽高比。</p>\n<h2 id=\"常见问题排查\">常见问题排查</h2>\n<p>图像处理有时会遇到一些问题，这里列出几个常见的。</p>\n<h3 id=\"图像损坏\">图像损坏</h3>\n<p>如果 PHP 无法正确处理图像文件，可能会导致损坏。处理前先用 <code>getimagesize()</code> 验证文件是否为有效图像，同时确认文件格式（JPEG、PNG、GIF）。</p>\n<h3 id=\"内存不足\">内存不足</h3>\n<p>处理大图片时可能会遇到内存限制。可以在 <code>php.ini</code> 中调整 <code>memory_limit</code>。如果是共享主机，可能需要联系服务商提升配额。</p>\n<h2 id=\"总结\">总结</h2>\n<p>PHP 的图像处理能力远不止上传那么简单。借助 GD 和 Imagick，你可以完成缩放、裁剪、加水印、应用滤镜等操作。无论是搭建图片库、处理用户上传的内容，还是优化网站图片，这些技能都能派上用场。<br />\n<a href=\"https://catchadmin.com/post/2026-01/openclaw-installed\" rel=\"noopener nofollow\" target=\"_blank\">用 PHP 玩转图片：缩放、裁剪、水印、滤镜一网打尽</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-31 08:40</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">21</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "CUDA是如何调度Thread Block的？",
      "link": "https://www.cnblogs.com/DemoFX/p/19556140",
      "published": "",
      "description": "<div class=\"postTitle\">\n\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/DemoFX/p/19556140\" id=\"cb_post_title_url\" title=\"发布于 2026-01-31 00:25\">\n    <span>CUDA是如何调度Thread Block的？</span>\n    \n\n</a>\n\n\t</div>\n\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        cuda\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>最近在看CUDA,讲到C++是怎么调用CUDA函数进而加载进GPU内核进行运行的，网上基本上全部都是一样的资料，只讲Grid包含很多Thread block,每个Thread block只能加载到一个SM中进行并行运算，然后就是线程分类到warp中进行分组计算，网上大多讲的是这些，具体thread block怎么分配到SM就没讲清楚，今天来点自己的分析。</p>\n<p><img alt=\"block1\" class=\"lazyload\" height=\"153\" width=\"298\" /></p>\n<p>显卡的硬件配置，只有3个SM单元，总共只有12个硬件warp，但是运行软件调试发现，至少有一百多个软件warp同时运行，如果按照每个Thread Block只配置到一个SM来计算，总共应该只有12个软件warp才对，多出来的warp哪来的？其实这只是一种软件模拟实现的“并行\"计算，用比硬件数目多的软件warp提高硬件的计算吞吐量，另一方面，一个SM可以同时支持多个Thread block的运行，这是很多文档都没有介绍的内容，也是本文的重点。</p>\n<p><img alt=\"code\" class=\"lazyload\" height=\"291\" width=\"419\" /></p>\n<p>首先看代码，代码很简单，只是个普通的kernel函数。下面的分析用到Cuda Toolkit里面自带的profile工具nvvp.<br />\n首先在host端调用上述代码：<br />\nmykernelfunc &lt;&lt;&lt; 2, 1&gt;&gt;&gt; ();用nvvp查看如下图所示，</p>\n<p><img alt=\"1\" class=\"lazyload\" height=\"201\" width=\"401\" /></p>\n<p>一共就3个SM,两个Thread block用了两个，说明Thread block在分配SM的时候是首先挑选空余的SM来运行，并没有两个Thread block运行到一个SM的情况。<br />\nmykernelfunc &lt;&lt;&lt; 4, 1&gt;&gt;&gt; ();这个有4个Thread block，显然3个SM不够分，肯定多出来一个。</p>\n<p><img alt=\"2\" class=\"lazyload\" height=\"200\" width=\"418\" /><br />\n<img alt=\"3\" class=\"lazyload\" height=\"94\" width=\"424\" /></p>\n<p>从上图能看出来，三个SM已经全部被占用了，平均下来每个SM有1.33个warp,说明多出来的那个warp,已经被分配进某个SM里面。<br />\n这个取4个thread block分到3个SM，不好分，我们换个：<br />\nmykernelfunc &lt;&lt;&lt; 96, 64&gt;&gt;&gt; ();</p>\n<p><img alt=\"6\" class=\"lazyload\" height=\"99\" width=\"420\" /></p>\n<p>这里取了96个thread block,分到3个SM里，每一个可以分到32个，64表示64个线程，这样一共是64个warp,已经达到硬件极限了，理论上达到100%的硬件占用率，实际测试达到99.5%的Occupancy.<br />\n但是如果使用了shared memory,情况就会有很大的不同。</p>\n<p><img alt=\"7\" class=\"lazyload\" height=\"171\" width=\"425\" /></p>\n<p>这里分配了24k的共享内存，但实际的warp就降到了24个。</p>\n<p><img alt=\"10\" class=\"lazyload\" height=\"430\" width=\"800\" /></p>\n<p>仔细看上面关于GPU utility的说明，这里其实是关键所在，kernel代码使用了24k的shared memory,而每个SM的最大shared memory是96k,正好是4倍，而运行的Thread block数目也是4个，这说明什么？这说明，Thread block在分配SM的时候，首先参考kernel中使用的shared memory的大小，整个SM的shared memory能装下几个kernel的shared memory就使用几个Thread block,这其实是make sense的，因为kernel占用的shared memory属于硬件要求，不满足自然无法运行。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-01-31 00:25</span>&nbsp;\n<a href=\"https://www.cnblogs.com/DemoFX\">demofx</a>&nbsp;\n阅读(<span id=\"post_view_count\">77</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}