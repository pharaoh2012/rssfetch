{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "【Azure Web App】Github Action部署Jar包到App Service报400错误",
      "link": "https://www.cnblogs.com/lulight/p/19439653",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19439653\" id=\"cb_post_title_url\" title=\"发布于 2026-01-04 20:07\">\n    <span>【Azure Web App】Github Action部署Jar包到App Service报400错误</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1>问题描述</h1>\n<p>通过github aciton部署azure app service服务的时候，遇见400报错。</p>\n<p>报错信息非常简单：</p>\n<blockquote>\n<p>Starting deployment for web app...<br />Package deployment using OneDeploy initiated.<br />Error: Failed to deploy web package to App Service.<br /><span style=\"color: rgba(255, 0, 0, 1);\"><strong>Error: Deployment Failed, Error: Failed to deploy web package using OneDeploy to App Service.</strong></span><br />Bad Request (CODE: 400)</p>\n</blockquote>\n<p> 这个问题应该如何调查呢？</p>\n<p>&nbsp;</p>\n<h1>问题解答</h1>\n<p>在Github Aciton中，使用 Azure WebApp(azure/webapps-deploy@v3)来部署App Service的应用, 这次部署的是一个jar包。</p>\n<p>Github Action  脚本:</p>\n<blockquote>\n<p>- name: Azure WebApp<br />uses: azure/webapps-deploy@v3<br />with:<br />app-name: '&lt;app service name&gt;'<br />package: ${{ github.workspace }}/target/*.jar<br /> </p>\n</blockquote>\n<p>查看Azure文档，介绍部署java应用时，使用az cli命令，github action和maven 插件都是使用的Kudu OneDeploy接口( https://&lt;your web app&gt;.scm.chinacloudsites.cn/api/publish?type=jar )</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"235\" width=\"666\" /></p>\n<p>(文档链接：<a href=\"https://docs.azure.cn/zh-cn/app-service/configure-language-java-deploy-run?tabs=linux&amp;pivots=java-tomcat#deploying-your-app\" rel=\"noopener nofollow\" target=\"_blank\">https://docs.azure.cn/zh-cn/app-service/configure-language-java-deploy-run?tabs=linux&amp;pivots=java-tomcat#deploying-your-app</a>)</p>\n<p>&nbsp;</p>\n<p>根据以上信息，就尝试使用az webapp deploy命令直接部署jar包应用，发现多了一句错误提示信息：</p>\n<blockquote>\n<p><span style=\"color: rgba(255, 0, 255, 1);\">&gt; <strong>az webapp deploy --resource-group &lt;your resource group name&gt; --name &lt;your app service name&gt; --src-path myjava.jar --type jar</strong></span></p>\n<p>Initiating deployment<br />Deploying from local path: myjava.jar<br />An error occurred during deployment. Status Code: 400, </p>\n<p><strong><span style=\"color: rgba(255, 0, 0, 1);\">Details: \"Artifact type = 'Jar' cannot be deployed to stack = 'TOMCAT'. Site should be configured to run with stack = JAVA\", </span></strong></p>\n<p>Please visit https://XXXXXXXXX.scm.chinacloudsites.cn/api/deployments/latest to get more information about your deployment</p>\n</blockquote>\n<p>这句错误消息非常关键(Artifact type = 'Jar' cannot be deployed to stack = 'TOMCAT'. Site should be configured to run with stack = JAVA\")。</p>\n<p>在查看App Service的配置信息后，Stack果然设置为Tomcat。</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"465\" width=\"666\" /></p>\n<p>因为这里只有两种选项( Tomcat 和Java SE )。于是，修改为Java SE后，再次部署jar包。</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"194\" width=\"666\" /></p>\n<p>成功。</p>\n<p>&nbsp;</p>\n<p>当问题解决后，想进一步验证是否是one deploy接口对jar包的强制限制。</p>\n<p>恰好kudu也是开源项目，所以，进入github kudu 仓库 (源码：<a href=\"https://github.com/projectkudu/kudu/tree/master\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/projectkudu/kudu/tree/master</a> )，使用错误消息关键字整库搜索“cannot be deployed to stack”，最终，定位到 PushDeploymentController.cs 中，有如下的验证条件：</p>\n<ul>\n<li>当部署的文件为Jar时，需要判断目标App Service的Stack只能是JavaSE。如果不是，返回400的状态码</li>\n</ul>\n<p><img alt=\"image\" class=\"lazyload\" height=\"110\" width=\"666\" /></p>\n<p>&nbsp;</p>\n<h2>附录一：使用 curl 命令直接调用接口也可以复现问题，效果和az webapp deploy命令相同</h2>\n<div class=\"cnblogs_code\">\n<pre><span style=\"background-color: rgba(255, 255, 0, 1);\">curl -<span style=\"color: rgba(0, 0, 0, 1);\">X POST \\\n\n     </span>-<span style=\"color: rgba(0, 0, 0, 1);\">u user:password \\\n\n     </span>-T <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">/Users/Downloads/xxxxx-0.0.1-SNAPSHOT.jar</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\"> \\\n\n     </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">https://xxxxx.scm.chinacloudsites.cn/api/publish?type=jar</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\"> \\\n\n     </span>-<span style=\"color: rgba(0, 0, 0, 1);\">v\n\n\n\n</span></span>* Host xxxxx.scm.chinacloudsites.cn:<span style=\"color: rgba(128, 0, 128, 1);\">443</span><span style=\"color: rgba(0, 0, 0, 1);\"> was resolved.\n\n</span>*<span style=\"color: rgba(0, 0, 0, 1);\"> IPv6: (none)\n\n</span>* IPv4: <span style=\"color: rgba(128, 0, 128, 1);\">159.27</span>.<span style=\"color: rgba(128, 0, 128, 1);\">20.0</span>\n\n*   Trying <span style=\"color: rgba(128, 0, 128, 1);\">159.27</span>.<span style=\"color: rgba(128, 0, 128, 1);\">20.0</span>:<span style=\"color: rgba(128, 0, 128, 1);\">443</span><span style=\"color: rgba(0, 0, 0, 1);\">...\n\n</span>* Connected to xxxxx.scm.chinacloudsites.cn (<span style=\"color: rgba(128, 0, 128, 1);\">159.27</span>.<span style=\"color: rgba(128, 0, 128, 1);\">20.0</span>) port <span style=\"color: rgba(128, 0, 128, 1);\">443</span>\n\n* ALPN: curl offers h2,http/<span style=\"color: rgba(128, 0, 128, 1);\">1.1</span>\n\n* (<span style=\"color: rgba(128, 0, 128, 1);\">304</span>) (OUT), TLS handshake, Client hello (<span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">):\n\n</span>*  CAfile: /etc/ssl/<span style=\"color: rgba(0, 0, 0, 1);\">cert.pem\n\n</span>*<span style=\"color: rgba(0, 0, 0, 1);\">  CApath: none\n\n</span>* (<span style=\"color: rgba(128, 0, 128, 1);\">304</span>) (IN), TLS handshake, Server hello (<span style=\"color: rgba(128, 0, 128, 1);\">2</span><span style=\"color: rgba(0, 0, 0, 1);\">):\n\n</span>* (<span style=\"color: rgba(128, 0, 128, 1);\">304</span>) (OUT), TLS handshake, Client hello (<span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">):\n\n</span>* (<span style=\"color: rgba(128, 0, 128, 1);\">304</span>) (IN), TLS handshake, Server hello (<span style=\"color: rgba(128, 0, 128, 1);\">2</span><span style=\"color: rgba(0, 0, 0, 1);\">):\n\n</span>* (<span style=\"color: rgba(128, 0, 128, 1);\">304</span>) (IN), TLS handshake, Unknown (<span style=\"color: rgba(128, 0, 128, 1);\">8</span><span style=\"color: rgba(0, 0, 0, 1);\">):\n\n</span>* (<span style=\"color: rgba(128, 0, 128, 1);\">304</span>) (IN), TLS handshake, Certificate (<span style=\"color: rgba(128, 0, 128, 1);\">11</span><span style=\"color: rgba(0, 0, 0, 1);\">):\n\n</span>* (<span style=\"color: rgba(128, 0, 128, 1);\">304</span>) (IN), TLS handshake, CERT verify (<span style=\"color: rgba(128, 0, 128, 1);\">15</span><span style=\"color: rgba(0, 0, 0, 1);\">):\n\n</span>* (<span style=\"color: rgba(128, 0, 128, 1);\">304</span>) (IN), TLS handshake, Finished (<span style=\"color: rgba(128, 0, 128, 1);\">20</span><span style=\"color: rgba(0, 0, 0, 1);\">):\n\n</span>* (<span style=\"color: rgba(128, 0, 128, 1);\">304</span>) (OUT), TLS handshake, Finished (<span style=\"color: rgba(128, 0, 128, 1);\">20</span><span style=\"color: rgba(0, 0, 0, 1);\">):\n\n</span>* SSL connection <span style=\"color: rgba(0, 0, 255, 1);\">using</span> TLSv1.<span style=\"color: rgba(128, 0, 128, 1);\">3</span> / AEAD-AES256-GCM-SHA384 / [blank] /<span style=\"color: rgba(0, 0, 0, 1);\"> UNDEF\n\n</span>* ALPN: server accepted http/<span style=\"color: rgba(128, 0, 128, 1);\">1.1</span>\n\n*<span style=\"color: rgba(0, 0, 0, 1);\"> Server certificate:\n\n</span>*  subject: C=CN; ST=Shanghai; O=Shanghai Blue Cloud Technology Co., Ltd.; CN=*<span style=\"color: rgba(0, 0, 0, 1);\">.chinacloudsites.cn\n\n</span>*  start date: Dec <span style=\"color: rgba(128, 0, 128, 1);\">19</span> <span style=\"color: rgba(128, 0, 128, 1);\">00</span>:<span style=\"color: rgba(128, 0, 128, 1);\">00</span>:<span style=\"color: rgba(128, 0, 128, 1);\">00</span> <span style=\"color: rgba(128, 0, 128, 1);\">2025</span><span style=\"color: rgba(0, 0, 0, 1);\"> GMT\n\n</span>*  expire date: Jun <span style=\"color: rgba(128, 0, 128, 1);\">17</span> <span style=\"color: rgba(128, 0, 128, 1);\">23</span>:<span style=\"color: rgba(128, 0, 128, 1);\">59</span>:<span style=\"color: rgba(128, 0, 128, 1);\">59</span> <span style=\"color: rgba(128, 0, 128, 1);\">2026</span><span style=\"color: rgba(0, 0, 0, 1);\"> GMT\n\n</span>*  subjectAltName: host <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">xxxxx.scm.chinacloudsites.cn</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> matched cert<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">s \"*.scm.chinacloudsites.cn\"</span>\n\n*  issuer: C=US; O=DigiCert Inc; CN=<span style=\"color: rgba(0, 0, 0, 1);\">DigiCert Basic RSA CN CA G2\n\n</span>*<span style=\"color: rgba(0, 0, 0, 1);\">  SSL certificate verify ok.\n\n</span>* <span style=\"color: rgba(0, 0, 255, 1);\">using</span> HTTP/<span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">.x\n\n</span>* Server auth <span style=\"color: rgba(0, 0, 255, 1);\">using</span> Basic with user <span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">deploypoc</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>\n\n&gt; POST /api/publish?type=jar HTTP/<span style=\"color: rgba(128, 0, 128, 1);\">1.1</span>\n\n&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> Host: xxxxx.scm.chinacloudsites.cn\n\n</span>&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> Authorization: Basic xxxxxxxxxxxxxxxx\n\n</span>&gt; User-Agent: curl/<span style=\"color: rgba(128, 0, 128, 1);\">8.7</span>.<span style=\"color: rgba(128, 0, 128, 1);\">1</span>\n\n&gt; Accept: *<span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\">\n\n&gt; Content-Length: 25578166\n\n&gt; Expect: 100-continue\n\n&gt; \n\n* Done waiting for 100-continue\n\n&lt; HTTP/1.1 400 Bad Request\n\n&lt; Content-Type: text/plain; charset=utf-8\n\n&lt; Date: Wed, 31 Dec 2025 03:42:36 GMT\n\n&lt; Server: Kestrel\n\n&lt; Set-Cookie: ARRAffinity=xxxx;Path=/;HttpOnly;Secure;Domain=xxxxx.scm.chinacloudsites.cn\n\n&lt; Set-Cookie: ARRAffinitySameSite=xxxxx;Path=/;HttpOnly;SameSite=None;Secure;Domain=xxxxx.scm.chinacloudsites.cn\n\n&lt; Transfer-Encoding: chunked\n\n&lt; \n\n* HTTP error before end of send, stop sending\n\n* abort upload after having sent 589824 bytes\n\n* Closing connection\n\n<span style=\"background-color: rgba(255, 255, 0, 1);\">Artifact type = 'Jar' cannot be deployed to stack = 'TOMCAT'. Site should be configured to run with stack = JAVA%   </span> </span></pre>\n</div>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h1>参考资料</h1>\n<p>App Service部署Java应用：<a href=\"https://docs.azure.cn/zh-cn/app-service/configure-language-java-deploy-run?tabs=linux&amp;pivots=java-tomcat#deploying-your-app\" rel=\"noopener nofollow\" target=\"_blank\">https://docs.azure.cn/zh-cn/app-service/configure-language-java-deploy-run?tabs=linux&amp;pivots=java-tomcat#deploying-your-app</a></p>\n<p>Kudu One Deploy Source Code ： <a href=\"https://github.com/projectkudu/kudu/blob/master/Kudu.Services/Deployment/PushDeploymentController.cs#L304\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/projectkudu/kudu/blob/master/Kudu.Services/Deployment/PushDeploymentController.cs#L304</a></p>\n<p>&nbsp;</p>\n</div>\n<div id=\"MySignature\">\n    <div style=\"background: #1c5f55; height: 36px; width: 618px; padding: 14px 5px 0px 3px;\">\n  <p style=\"font-weight: bold; color: white;\">当在复杂的环境中面临问题，格物之道需：浊而静之徐清，安以动之徐生。 云中，恰是如此!</p>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-04 20:07</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lulight\">路边两盏灯</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Serilog 日志库简单实践（四）消息队列 Sinks（.net8）",
      "link": "https://www.cnblogs.com/hnzhengfy/p/19191039/Serilog_MQSinks",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/hnzhengfy/p/19191039/Serilog_MQSinks\" id=\"cb_post_title_url\" title=\"发布于 2026-01-04 19:54\">\n    <span>Serilog 日志库简单实践（四）消息队列 Sinks（.net8）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        将日志事件通过消息队列 Sinks 发布出去是一种实现系统解耦、异步处理和流量削峰的高效方式。本文就 Kafka、RabbitMQ 两种进行简单介绍和实践，供参考。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2>〇、前言</h2>\n<p>前文已经介绍过什么是 Serilog，以及其核心特点，<span style=\"font-size: 12px;\"><em>详见：<a href=\"https://www.cnblogs.com/hnzhengfy/p/19167414/Serilog_basic\" rel=\"noopener\" target=\"_blank\" title=\"https://www.cnblogs.com/hnzhengfy/p/19167414/Serilog_basic\">https://www.cnblogs.com/hnzhengfy/p/19167414/Serilog_basic</a>。</em></span></p>\n<p>本文继续对各种类型的 Sink 进行简单的实践，主题是消息队列 Sinks，供参考。</p>\n<p>在现代分布式系统中，将日志事件通过消息队列 Sinks 发布出去是一种实现系统解耦、异步处理和流量削峰的高效方式。</p>\n<p>消息队列 Sinks 常见的有以下三种：</p>\n<table>\n<thead>\n<tr>\n<th>排名</th>\n<th>消息队列</th>\n<th>主要优势领域</th>\n<th>适用人群</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>1</strong></td>\n<td><strong>Kafka</strong></td>\n<td><strong>高吞吐、日志、流处理</strong></td>\n<td><strong>大数据、互联网大厂</strong></td>\n</tr>\n<tr>\n<td><strong>2</strong></td>\n<td><strong>RabbitMQ</strong></td>\n<td><strong>可靠投递、灵活路由、易运维</strong></td>\n<td><strong>中小企业、传统行业</strong></td>\n</tr>\n<tr>\n<td>3</td>\n<td>RocketMQ</td>\n<td>事务消息、顺序消费、高可靠</td>\n<td>中国互联网、电商金融</td>\n</tr>\n</tbody>\n</table>\n<p>本文就前两种进行简单的介绍和示例，对于 RocketMQ 待后续有机会进行补充。</p>\n<h2>一、消息队列 Sinks 的用法</h2>\n<h3>1.1 Serilog.Sinks.Kafka：将日志信息写入 Kafka 队列</h3>\n<p>Serilog.Sinks.Kafka 是 Serilog 日志库的一个 Sink（接收器）插件，用于将结构化日志数据发送到 Apache Kafka 主题。它利用 Kafka 高吞吐量、分布式发布-订阅消息系统的特点，构建实时日志管道，使日志系统能够轻松处理海量日志数据，并支持多系统集成分析。</p>\n<h4>1.1.1 在 Windows 上安装 Kafka<em>（用于开发测试，生产环境建议 Linux）</em></h4>\n<p><span style=\"font-size: 12px;\"><em>注意：Kafka 官方主要支持 Linux 环境，Windows 安装不是官方推荐的方式。但如果是在 Windows 上进行开发测试，还是可以的。</em></span></p>\n<p><strong>本文使用现今最新的版本 4.1.1，Kafka 4.1.1 默认使用 KRaft（Kafka Raft）模式，即去 ZooKeeper 架构，因此只需安装 java 环境，无需在安装 ZooKeeper 。</strong></p>\n<p><strong>1）安装 Java 环境</strong></p>\n<p>由于 Kafka 4.1.1 是用 Java 17（class version 61）编译的，对应关系如下：</p>\n<p>Java 版本与 class file version 对照关系：<br />Java 8 → 52<br />Java 11 → 55<br />Java 17 → 61<br />Java 21 → 65</p>\n<p>因此，在安装 Kafka 之前可以先安装下 JDK 17。官方下载地址：<a href=\"https://www.oracle.com/java/technologies/javase/jdk17-archive-downloads.html\" rel=\"noopener nofollow\" target=\"_blank\" title=\"https://www.oracle.com/java/technologies/javase/jdk17-archive-downloads.html\">https://www.oracle.com/java/technologies/javase/jdk17-archive-downloads.html</a>。</p>\n<p>直接默认选项安装即可。</p>\n<p>然后配置环境变量：<code>JAVA_HOME</code>：<code>C:\\Program Files\\Java\\jdk-17</code>。安装时若改了路径需要改成对应的路径。</p>\n<p>Path 中添加一行：<code>%JAVA_HOME%\\bin</code>。</p>\n<p>然后打开 cmd 窗口验证安装成功：</p>\n<pre class=\"language-powershell highlighter-hljs\"><code>C:\\Users\\Administrator&gt;java -version\njava version \"17.0.12\" 2024-07-16 LTS\nJava(TM) SE Runtime Environment (build 17.0.12+8-LTS-286)\nJava HotSpot(TM) 64-Bit Server VM (build 17.0.12+8-LTS-286, mixed mode, sharing)</code></pre>\n<p><strong>2）安装 Kafka</strong></p>\n<p>下载如下图中的二进制版本（Binary），可以直接运行，无需自己编译。文件名中的 2.13 表示该 Kafka 版本是用 Scala 2.13 编译的，可以忽略。</p>\n<p>官方下载地址：<a href=\"https://kafka.apache.org/downloads\" rel=\"noopener nofollow\" target=\"_blank\" title=\"https://kafka.apache.org/downloads\">https://kafka.apache.org/downloads</a>。</p>\n<p><img alt=\"image\" height=\"162\" src=\"https://img2024.cnblogs.com/blog/1868241/202511/1868241-20251126225757439-1096942952.png\" width=\"287\" /></p>\n<p>解压到文件夹：<code>D:\\kafka_2.13-4.1.1</code>。</p>\n<p>修改配置文件夹<code>D:\\kafka_2.13-4.1.1\\config\\server.properties</code>：</p>\n<pre class=\"language-powershell highlighter-hljs\"><code># 【已默认】启用 KRaft 模式（同时作为 broker 和 controller）\nprocess.roles=broker,controller\nnode.id=1\nbroker.id=1\n\n# 【必须设置，需手动新增】\n# 定义 controller quorum 的投票成员\n# 格式：nodeId@host:port\ncontroller.quorum.voters=1@localhost:9093\n# controller.quorum.voters=1@localhost:9093 中的 1 必须和 node.id=1 一致\n# 9093 是 CONTROLLER 监听端口，必须与 listeners 中的 CONTROLLER://:9093 匹配\n\n# 必须设置！定义 controller quorum 的投票成员\n# 格式：nodeId@host:port\ncontroller.quorum.voters=1@localhost:9093\n\n# 【已默认】监听器配置\nlisteners=PLAINTEXT://:9092,CONTROLLER://:9093\ninter.broker.listener.name=PLAINTEXT\ncontroller.listener.names=CONTROLLER\n\n# 日志目录（建议使用 Windows 路径）\nlog.dirs=/tmp/kraft-combined-logs</code></pre>\n<p>然后生成集群 ID 并格式化日志目录：（必要步骤，若直接启动，会报错：找不到 meta.properties 文件）</p>\n<pre class=\"language-powershell highlighter-hljs\"><code># 虽然出现了 Log4j 的 ERROR 日志，但实际上 UUID 已成功生成\nPS D:\\kafka_2.13-4.1.1&gt; bin\\windows\\kafka-storage.bat random-uuid\n2025-12-04T11:26:06.769887100Z main ERROR Reconfiguration failed: No configuration found for '4dc63996' at 'null' in 'null'\nwTL_esmQSuKMtvzx6eclsQ\n# 使用生成的 Cluster ID 格式化 Kafka 存储目录\nPS D:\\kafka_2.13-4.1.1&gt; bin\\windows\\kafka-storage.bat format -t wTL_esmQSuKMtvzx6eclsQ -c config/server.properties\n2025-12-04T11:29:22.735759Z main ERROR Reconfiguration failed: No configuration found for '4dc63996' at 'null' in 'null'\nFormatting metadata directory /tmp/kraft-combined-logs with metadata.version 4.1-IV1.\n\n# 关于 Log4j ERROR 警告\n# main ERROR Reconfiguration failed: No configuration found for '4dc63996' at 'null' in 'null'\n# 是因为 Kafka 工具脚本（如 kafka-storage.bat）没有找到 Log4j 2 配置文件\n# 它不影响功能，只是日志系统初始化失败，但仍会使用默认配置。</code></pre>\n<p>最后再启动 Kafka：<code>bin\\windows\\kafka-server-start.bat config/server.properties</code>。</p>\n<p>看到如下输出就是启动成功了：</p>\n<p><span style=\"font-size: 12px;\"><em><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1868241/202512/1868241-20251204194415558-408556665.png\" /></em></span></p>\n<p><span style=\"font-size: 12px;\"><em>注意：Windows 安装 Kafka 仅适用于开发测试环境，生产环境建议使用 Linux 或 Docker 部署。</em></span></p>\n<details>\nserver.properties 示例\n<pre class=\"language-nginx highlighter-hljs\"><code>&nbsp;# Licensed to the Apache Software Foundation (ASF) under one or more\n# contributor license agreements.  See the NOTICE file distributed with\n# this work for additional information regarding copyright ownership.\n# The ASF licenses this file to You under the Apache License, Version 2.0\n# (the \"License\"); you may not use this file except in compliance with\n# the License.  You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n############################# Server Basics #############################\n\n# The role of this server. Setting this puts us in KRaft mode\nprocess.roles=broker,controller\n\n# The node id associated with this instance's roles\nnode.id=1\n\nbroker.id=1\n\n# List of controller endpoints used connect to the controller cluster\ncontroller.quorum.bootstrap.servers=localhost:9093\n\n# 必须设置！定义 controller quorum 的投票成员\n# 格式：nodeId@host:port\ncontroller.quorum.voters=1@localhost:9093\n\n############################# Socket Server Settings #############################\n\n# The address the socket server listens on.\n# Combined nodes (i.e. those with `process.roles=broker,controller`) must list the controller listener here at a minimum.\n# If the broker listener is not defined, the default listener will use a host name that is equal to the value of java.net.InetAddress.getCanonicalHostName(),\n# with PLAINTEXT listener name, and port 9092.\n#   FORMAT:\n#     listeners = listener_name://host_name:port\n#   EXAMPLE:\n#     listeners = PLAINTEXT://your.host.name:9092\nlisteners=PLAINTEXT://:9092,CONTROLLER://:9093\n\n# Name of listener used for communication between brokers.\ninter.broker.listener.name=PLAINTEXT\n\n# Listener name, hostname and port the broker or the controller will advertise to clients.\n# If not set, it uses the value for \"listeners\".\nadvertised.listeners=PLAINTEXT://localhost:9092,CONTROLLER://localhost:9093\n\n# A comma-separated list of the names of the listeners used by the controller.\n# If no explicit mapping set in `listener.security.protocol.map`, default will be using PLAINTEXT protocol\n# This is required if running in KRaft mode.\ncontroller.listener.names=CONTROLLER\n\n# Maps listener names to security protocols, the default is for them to be the same. See the config documentation for more details\nlistener.security.protocol.map=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT,SSL:SSL,SASL_PLAINTEXT:SASL_PLAINTEXT,SASL_SSL:SASL_SSL\n\n# The number of threads that the server uses for receiving requests from the network and sending responses to the network\nnum.network.threads=3\n\n# The number of threads that the server uses for processing requests, which may include disk I/O\nnum.io.threads=8\n\n# The send buffer (SO_SNDBUF) used by the socket server\nsocket.send.buffer.bytes=102400\n\n# The receive buffer (SO_RCVBUF) used by the socket server\nsocket.receive.buffer.bytes=102400\n\n# The maximum size of a request that the socket server will accept (protection against OOM)\nsocket.request.max.bytes=104857600\n\n\n############################# Log Basics #############################\n\n# A comma separated list of directories under which to store log files\n# log.dirs=/tmp/kraft-combined-logs\n# 数据目录（确保路径存在且可写）\nlog.dirs=D:/kafka_2.13-4.1.1/data/kafka-logs\n\n# The default number of log partitions per topic. More partitions allow greater\n# parallelism for consumption, but this will also result in more files across\n# the brokers.\nnum.partitions=1\n\n# The number of threads per data directory to be used for log recovery at startup and flushing at shutdown.\n# This value is recommended to be increased for installations with data dirs located in RAID array.\nnum.recovery.threads.per.data.dir=1\n\n############################# Internal Topic Settings  #############################\n# The replication factor for the group metadata internal topics \"__consumer_offsets\", \"__share_group_state\" and \"__transaction_state\"\n# For anything other than development testing, a value greater than 1 is recommended to ensure availability such as 3.\noffsets.topic.replication.factor=1\nshare.coordinator.state.topic.replication.factor=1\nshare.coordinator.state.topic.min.isr=1\ntransaction.state.log.replication.factor=1\ntransaction.state.log.min.isr=1\n\n############################# Log Flush Policy #############################\n\n# Messages are immediately written to the filesystem but by default we only fsync() to sync\n# the OS cache lazily. The following configurations control the flush of data to disk.\n# There are a few important trade-offs here:\n#    1. Durability: Unflushed data may be lost if you are not using replication.\n#    2. Latency: Very large flush intervals may lead to latency spikes when the flush does occur as there will be a lot of data to flush.\n#    3. Throughput: The flush is generally the most expensive operation, and a small flush interval may lead to excessive seeks.\n# The settings below allow one to configure the flush policy to flush data after a period of time or\n# every N messages (or both). This can be done globally and overridden on a per-topic basis.\n\n# The number of messages to accept before forcing a flush of data to disk\n#log.flush.interval.messages=10000\n\n# The maximum amount of time a message can sit in a log before we force a flush\n#log.flush.interval.ms=1000\n\n############################# Log Retention Policy #############################\n\n# The following configurations control the disposal of log segments. The policy can\n# be set to delete segments after a period of time, or after a given size has accumulated.\n# A segment will be deleted whenever *either* of these criteria are met. Deletion always happens\n# from the end of the log.\n\n# The minimum age of a log file to be eligible for deletion due to age\nlog.retention.hours=168\n\n# A size-based retention policy for logs. Segments are pruned from the log unless the remaining\n# segments drop below log.retention.bytes. Functions independently of log.retention.hours.\n#log.retention.bytes=1073741824\n\n# The maximum size of a log segment file. When this size is reached a new log segment will be created.\nlog.segment.bytes=1073741824\n\n# The interval at which log segments are checked to see if they can be deleted according\n# to the retention policies\nlog.retention.check.interval.ms=300000\n\n# 允许自动创建 Topic\nauto.create.topics.enable=true</code></pre>\n</details>\n<p><strong>3）创建 topic</strong></p>\n<p>创建语句：（注意，可以替换自定义的 topic 名：my-logs-topic1212）</p>\n<pre class=\"language-nginx highlighter-hljs\"><code>.\\bin\\windows\\kafka-topics.bat --create --topic my-logs-topic1212 --bootstrap-server localhost:9092 --partitions 3 --replication-factor 1</code></pre>\n<p>注意：此语句正常几秒钟就可以执行完成，若时间比较长，需要等待其返回错误提示。</p>\n<p>可能会遇到如下错误：</p>\n<pre class=\"language-nginx highlighter-hljs\"><code>Error while executing topic command : Call(...createTopics...) timed out...\nCaused by: org.apache.kafka.common.errors.DisconnectException: Cancelled createTopics request... due to node 1 being disconnected</code></pre>\n<p>原因：说明 Kafka 客户端（kafka-topics.bat）无法连接到 Kafka broker，或者 broker 虽然启动但未完全就绪（特别是 KRaft Controller 未选举完成）。</p>\n<p>在 KRaft 模式 下，Kafka 启动分为两个角色：Controller：管理元数据（topics、partitions 等）；Broker：处理生产/消费请求。如果 Controller 尚未完成初始化或选举，即使 kafka-server-start.bat 看似“已启动”，元数据操作（如创建 Topic）仍会失败。</p>\n<p>解决方案：</p>\n<pre class=\"language-nginx highlighter-hljs\"><code># 【步骤 1】确认 Kafka 是以 KRaft 模式 启动的\n# 检查是否使用了 正确的配置文件：\n# 正确启动命令（KRaft 模式）\n.\\bin\\windows\\kafka-server-start.bat .\\config\\server.properties\n\n# 【步骤 2】检查 server.properties 中的关键配置\n# 打开 config/server.properties，确保包含：\n# 监听地址（必须！）\nprocess.roles=broker,controller\nnode.id=1\nbroker.id=1\ncontroller.quorum.voters=1@localhost:9093\nlisteners=PLAINTEXT://:9092,CONTROLLER://:9093\nadvertised.listeners=PLAINTEXT://localhost:9092\ninter.broker.listener.name=PLAINTEXT\ncontroller.listener.names=CONTROLLER\n# 数据目录（确保路径存在且可写）\nlog.dirs=D:/kafka_2.13-4.1.1/data/kafka-logs\n# 注意：\n# controller.quorum.voters 必须与 node.id 匹配\n# log.dirs 路径不能包含空格或中文\n# 第一次启动前，清空 log.dirs 目录\n\n# 【步骤 3】首次启动前格式化存储目录（关键！）\n# KRaft 模式要求：先格式化存储目录，否则 broker 无法正常加入集群\n# 1. 生成 Cluster ID（只需一次）\n.\\bin\\windows\\kafka-storage.bat random-uuid\n# 2. 格式化日志目录\n.\\bin\\windows\\kafka-storage.bat format -t &lt;上一步生成的UUID&gt; -c .\\config\\kraft\\server.properties\n\n# 【步骤 4】启动 Kafka 并等待完全就绪\n.\\bin\\windows\\kafka-server-start.bat .\\config\\server.properties\n# Kafka 启动成功后，等待 10~15 秒 再执行 kafka-topics.bat\n# KRaft 启动比 ZooKeeper 模式慢，立即创建 Topic 会失败</code></pre>\n<pre class=\"language-nginx highlighter-hljs\"><code># 实际操作过程示例：\nPS D:\\kafka_2.13-4.1.1&gt; .\\bin\\windows\\kafka-storage.bat random-uuid\nnOhIgFFsQm2aiodLw8y7cQ\n\nPS D:\\kafka_2.13-4.1.1&gt; bin\\windows\\kafka-storage.bat format -t nOhIgFFsQm2aiodLw8y7cQ -c config/server.properties --ignore-formatted\nFormatting metadata directory /tmp/kraft-combined-logs with metadata.version 4.1-IV1.\n\nPS D:\\kafka_2.13-4.1.1&gt; bin\\windows\\kafka-server-start.bat config/server.properties\nDEPRECATED: A Log4j 1.x configuration file has been detected, which is no longer recommended.\n。。。\n[2025-12-12 17:31:28,080] INFO [BrokerServer id=1] Transition from STARTING to STARTED (kafka.server.BrokerServer)\n[2025-12-12 17:31:28,082] INFO Kafka version: 4.1.1 (org.apache.kafka.common.utils.AppInfoParser)\n[2025-12-12 17:31:28,082] INFO Kafka commitId: be816b82d25370ce (org.apache.kafka.common.utils.AppInfoParser)\n[2025-12-12 17:31:28,084] INFO Kafka startTimeMs: 1765531888081 (org.apache.kafka.common.utils.AppInfoParser)\n[2025-12-12 17:31:28,085] INFO [KafkaRaftServer nodeId=1] Kafka Server started (kafka.server.KafkaRaftServer)\n# 至此重新启动成功，然后另打开一个窗口，进行下面操作：\n# 添加 topic\nPS D:\\kafka_2.13-4.1.1&gt; .\\bin\\windows\\kafka-topics.bat --create --topic my-logs-topic1212 --bootstrap-server localhost:9092 --partitions 3 --replication-factor 1\nCreated topic my-logs-topic1212.\n#查看已添加的 topic\nPS D:\\kafka_2.13-4.1.1&gt; .\\bin\\windows\\kafka-topics.bat --list --bootstrap-server localhost:9092\nmy-logs-topic1212</code></pre>\n<p><strong>4）验证 Kafka 已经启动</strong></p>\n<pre class=\"language-nginx highlighter-hljs\"><code># 可以列出 topic 表明：Kafka Broker 已接受客户端连接，并能响应元数据请求\nPS D:\\kafka_2.13-4.1.1&gt; .\\bin\\windows\\kafka-topics.bat --list --bootstrap-server localhost:9092\nmy-logs-topic1212\n# Kafka 是 Java 应用，必须有 java.exe 进程\n# 后续 netstat 显示该 PID 监听 9092 端口，确认就是 Kafka 进程\nPS D:\\kafka_2.13-4.1.1&gt; tasklist /fi \"imagename eq java.exe\"\n\n映像名称                       PID 会话名              会话#       内存使用\n========================= ======== ================ =========== ============\njava.exe                     90224 Console                    2    432,272 K\n# 9092 端口处于 LISTENING 状态，且 PID 匹配\n# 表示 Kafka Broker 正在监听所有 IPv4/IPv6 接口的 9092 端口\n# PID 90224 与 tasklist 中的 Java 进程一致，确认是 Kafka 在监听\nPS D:\\kafka_2.13-4.1.1&gt; netstat -ano | findstr :9092\n  TCP    0.0.0.0:9092           0.0.0.0:0              LISTENING       90224\n  TCP    127.0.0.1:52704        127.0.0.1:9092         TIME_WAIT       0\n  TCP    127.0.0.1:52706        127.0.0.1:9092         TIME_WAIT       0\n  TCP    127.0.0.1:52758        127.0.0.1:9092         TIME_WAIT       0\n  TCP    127.0.0.1:52766        127.0.0.1:9092         TIME_WAIT       0\n  TCP    [::]:9092              [::]:0                 LISTENING       90224\n# 多个 TIME_WAIT 是之前 kafka-topics.bat 建立的短连接关闭后的正常状态</code></pre>\n<h4>1.1.2 测试往 Kafka 队列中写入消息</h4>\n<p>1）创建 .NET 8.0 控制台应用程序，然后安装必要的包：</p>\n<pre class=\"language-nginx highlighter-hljs\"><code>dotnet add package Serilog\ndotnet add package Serilog.Sinks.Console\ndotnet add package Serilog.Sinks.ConfluentKafka</code></pre>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1868241/202601/1868241-20260104105638368-1594540197.png\" /></p>\n<p>2）修改 Program.cs</p>\n<pre class=\"language-csharp highlighter-hljs\"><code>using Confluent.Kafka;\nusing Serilog;\nusing Serilog.Formatting.Json;\nusing Serilog.Sinks.Kafka;\n\n// 配置 Kafka Producer\nvar kafkaConfig = new ProducerConfig\n{\n    BootstrapServers = \"localhost:9092\",\n    ClientId = \"serilog-dotnet8-demo\",\n    Acks = Acks.All,\n    EnableIdempotence = true,\n    MessageTimeoutMs = 30000\n};\n// 配置 Serilog\nLog.Logger = new LoggerConfiguration()\n    .MinimumLevel.Information()\n    .WriteTo.Console() // 可选：同时输出到控制台\n    .WriteTo.Kafka(\n        topic: \"my-logs-topic1212\",\n        null,\n        producerConfig: kafkaConfig,\n        formatter: new JsonFormatter() // 或自定义格式\n    )\n.CreateLogger();\n// 测试日志\nLog.Information(\"应用程序启动成功\");\nLog.Warning(\"用户 {UserId} 尝试了高风险操作\", 123);\nLog.Error(new Exception(\"数据库连接失败\"), \"数据库错误\");\n// 模拟业务\nfor (int i = 1; i &lt;= 3; i++)\n{\n    Log.Information(\"处理任务 {TaskId}，进度 {Progress:P}\", i, i / 3.0);\n    await Task.Delay(200);\n}\n// 确保日志发送完成\nLog.CloseAndFlush();\nConsole.WriteLine(\"\\n日志已发送到 Kafka 主题 'app-logs'。按任意键退出...\");\nConsole.ReadKey();</code></pre>\n<p>启动项目，然后查看 Kafka 队列内容。</p>\n<pre class=\"language-nginx highlighter-hljs\"><code># 使用命令查看\n.\\bin\\windows\\kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic &lt;your-topic&gt; --from-beginning\n# 【kafka-console-consumer.bat】\n# Kafka 自带的 命令行消费者工具（Console Consumer）\n# 【--bootstrap-server localhost:9092】\n# 指定 Kafka Broker 的连接地址（KRaft 模式下必需）\n# 格式：host:port，多个 Broker 用逗号分隔，如 host1:9092,host2:9092\n# 为什么叫 \"bootstrap\"？客户端只需连接其中一个 Broker，即可获取整个集群的元数据（包括所有 Topic、Partition 分布等），后续会直接与对应 Partition 的 Leader 通信\n# 【--topic &lt;your-topic&gt;】\n# 指定要消费的 Topic 名称，这里一次只能指定 一个 Topic\n# 【--from-beginning】\n# 从该 Topic 的最早消息（offset = 0）开始消费，而不是从最新位置开始\n# 【--property print.key=true】同时打印消息的 Key（默认只打印 Value）\n# 【--property print.timestamp=true】打印消息的时间戳（CreateTime 或 LogAppendTime）</code></pre>\n<p>直接通过命令打印出消息列表时，会出现中文乱码，<strong>如何处理乱码和使用工具 Offset Explorer 来查看</strong>，详见本文写一节。</p>\n<h4>1.1.3 遇到的问题：查看队列消息时中文乱码</h4>\n<p>在 PowerShell 中通过命令查看队列消息时，出现乱码，如下图：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1868241/202601/1868241-20260104092544043-1870984030.png\" /></p>\n<p>队列（Topic）中的中文消息显示为乱码，这通常是由于 字符编码不一致 导致的。Kafka 本身以字节（byte）形式存储消息，不关心内容编码；问题出在 生产者写入 和 消费者读取 时使用的字符编码不匹配，尤其是 Windows 控制台（CMD/PowerShell）默认使用 GBK（中文系统）而非 UTF-8。</p>\n<pre class=\"language-nginx highlighter-hljs\"><code># 即使 Kafka 正确输出 UTF-8，Windows 控制台默认用 GBK 显示，仍会乱码\n# 在 PowerShell 或 CMD 中执行：\nchcp 65001  # 65001 是 UTF-8 的代码页\n# PowerShell 中设置环境变量后启动\n$env:KAFKA_OPTS=\"-Dfile.encoding=UTF-8\"\n# 然后再重新运行 consumer 命令\n.\\bin\\windows\\kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic &lt;your-topic&gt; --from-beginning</code></pre>\n<p>上边的配置仅当前窗口有效。</p>\n<p>还可以<strong>通过 Offset Explorer 应用来查看消息</strong>。</p>\n<p>下载 Offset Explorer：<a href=\"https://offsetexplorer.com/download.html\" rel=\"noopener nofollow\" target=\"_blank\" title=\"https://offsetexplorer.com/download.html\">https://offsetexplorer.com/download.html</a>。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1868241/202512/1868241-20251231184356405-1355679403.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1868241/202512/1868241-20251231184433809-1109603218.png\" /></p>\n<h4>1.1.4 遇到的问题：重启 Kafka 时不成功</h4>\n<p>报错内容例如：</p>\n<pre class=\"language-nginx highlighter-hljs\"><code>WARN Stopping serving logs in dir D:\\kafka_2.13-4.1.1\\data\\kafka-logs (kafka.log.LogManager)\nERROR Shutdown broker because all log dirs in D:\\kafka_2.13-4.1.1\\data\\kafka-logs have failed (kafka.log.LogManager)</code></pre>\n<p>说明 Kafka Broker 启动后因日志目录（log.dirs）不可用而主动关闭。这是 Kafka 的保护机制——当所有配置的日志存储目录都失效时，它会拒绝运行以避免数据丢失。</p>\n<p>可能的原因：</p>\n<p>1）日志所在的目录权限不足。</p>\n<p>Kafka 需要对 log.dirs 指定的目录有 读、写、删除、创建子目录 的权限。本文示例的目录为：D:\\kafka_2.13-4.1.1\\data\\kafka-logs。</p>\n<p>操作：右键 kafka-logs 文件夹 → 属性 → 安全 → 编辑；给当前用户配置 “完全控制” 权限；最后重启 Kafka。</p>\n<p>2）目录被其他 Kafka 实例占用（文件锁）</p>\n<p>如果之前启动过 Kafka 但未正常关闭，.lock 文件可能残留，导致新实例认为目录已被占用。</p>\n<p>先确认有没有 Kafka 示例在运行，<code>tasklist /fi \"imagename eq java.exe\"</code>。</p>\n<p>有就先结束，然后再把 .lock 文件删除。</p>\n<p>测试阶段可以将日志文件夹下的全部文件都删掉，避免因未知的占用导致 Kafka 启动失败，但要谨慎操作，全部删除会造成之前队列消息清空。</p>\n<p><span style=\"font-size: 12px;\"><em>注意：不要强行删除正在使用的日志目录内容！仅在确认 Kafka 已停止时操作。</em></span></p>\n<p>3）磁盘空间不足，可以自行检查，确保有足够空间（至少几百 MB）。</p>\n<h3>1.2 Serilog.Sinks.RabbitMQ：将日志事件发送到 RabbitMQ 消息队列系统中</h3>\n<p>Serilog.Sinks.RabbitMQ 是一个 Serilog 的日志接收器（Sink），用于将应用程序的日志事件发送到 RabbitMQ 消息队列系统中。</p>\n<p>通过该 Sink，开发者可以将结构化日志以消息的形式发布到 RabbitMQ 的 交换机（Exchange） 或直接绑定到 队列（Queue），从而实现日志的集中收集、异步处理、解耦或进一步转发到日志分析系统（如 ELK、Graylog 等）。</p>\n<p>大概的步骤：</p>\n<p>  应用程序调用 Log.Information(...) 等方法记录日志；<br />  Serilog 捕获日志事件；<br />  RabbitMQ Sink 将日志事件序列化；<br />  通过 AMQP 客户端连接 RabbitMQ；<br />  将消息发布到配置的 Exchange（可选绑定 Routing Key）；<br />  RabbitMQ 根据绑定规则将消息路由到一个或多个队列；<br />  消费者（如日志处理器、ELK 输入插件）从队列中消费日志。</p>\n<p><em>注意：Sink 默认不声明队列，只负责发布消息到 Exchange。因此，在往 RabbitMQ 发送消息前，需要提前配置好 Exchange、Queue 和绑定关系，或者启用自动声明（部分版本支持）。</em></p>\n<h4>1.2.1 在 Windows 上安装 RabbitMQ</h4>\n<p>最常见的是通过 <strong>Erlang + RabbitMQ</strong> 安装包 的组合方式（因为<strong> RabbitMQ 是用 Erlang 编写的，依赖 Erlang/OTP 运行时</strong>）。</p>\n<p><span style=\"font-size: 12px;\"><em>注意：Erlang 和 RabbitMQ 的版本必须兼容。请参考官方兼容性矩阵：<a href=\"https://www.rabbitmq.com/docs/which-erlang\" rel=\"noopener nofollow\" target=\"_blank\" title=\"https://www.rabbitmq.com/docs/which-erlang\">https://www.rabbitmq.com/docs/which-erlang</a>。</em></span></p>\n<p>1）下载和安装 Erlang/OTP</p>\n<p>官方下载页：<a href=\"https://www.erlang.org/downloads\" rel=\"noopener nofollow\" target=\"_blank\" title=\"https://www.erlang.org/downloads\">https://www.erlang.org/downloads</a>。</p>\n<p>推荐使用 Windows 64-bit Binary File (.exe)，例如：otp_win64_27.3.exe（对应 OTP 27.3）。截至 2025 年 12 月，RabbitMQ 4.2+ 通常要求 Erlang 26.2 ~ 27.x。</p>\n<p><img alt=\"image\" height=\"175\" src=\"https://img2024.cnblogs.com/blog/1868241/202512/1868241-20251202110425987-1382745303.png\" width=\"494\" /></p>\n<p>然后直接双击安装包，直接下一步安装完成。</p>\n<p>再改下系统环境变量：</p>\n<p><strong>新增</strong>：ERLANG_HOME：C:\\Program Files\\Erlang OTP。</p>\n<p><strong>在 Path 中添加</strong>：%ERLANG_HOME%\\bin。</p>\n<p>最后，用 erl 命令验证下是否安装成功：</p>\n<pre class=\"language-powershell highlighter-hljs\"><code>C:\\Windows\\system32&gt;erl\nErlang/OTP 27 [erts-15.2.3] [source] [64-bit] [smp:20:20] [ds:20:20:10] [async-threads:1] [jit:ns]\n\nEshell V15.2.3 (press Ctrl+G to abort, type help(). for help)\n1&gt;</code></pre>\n<p>2）下载和安装 RabbitMQ</p>\n<p>官方下载地址：<a href=\"https://www.rabbitmq.com/docs/install-windows#downloads\" rel=\"noopener nofollow\" target=\"_blank\" title=\"https://www.rabbitmq.com/docs/install-windows#downloads\">https://www.rabbitmq.com/docs/install-windows#downloads</a>。</p>\n<p>下载 RabbitMQ Server Windows Installer (.exe)。例如：rabbitmq-server-4.2.1.exe。推荐使用 .exe 安装包（带图形界面和 Windows 服务），而非 .zip 压缩包。</p>\n<p><img alt=\"image\" height=\"119\" src=\"https://img2024.cnblogs.com/blog/1868241/202512/1868241-20251202110133508-558096292.png\" width=\"478\" /></p>\n<p>安装完成后，同样需要修改环境变量：</p>\n<p>新增一个，RABBITMQ_SERVER：C:\\Program Files\\RabbitMQ Server。</p>\n<p>追加 Path：%RABBITMQ_SERVER%\\bin。</p>\n<p>最后，验证是否安装成功。</p>\n<pre class=\"language-powershell highlighter-hljs\"><code>C:\\Windows\\system32&gt;sc query RabbitMQ\n\nSERVICE_NAME: RabbitMQ\n        TYPE               : 10  WIN32_OWN_PROCESS\n        STATE              : 4  RUNNING\n                                (STOPPABLE, NOT_PAUSABLE, ACCEPTS_SHUTDOWN)\n        WIN32_EXIT_CODE    : 0  (0x0)\n        SERVICE_EXIT_CODE  : 0  (0x0)\n        CHECKPOINT         : 0x0\n        WAIT_HINT          : 0x0</code></pre>\n<p>另外，RabbitMQ 自带一个 Web 管理界面（Management Plugin），默认未启用。</p>\n<pre class=\"language-powershell highlighter-hljs\"><code># 以管理员身份打开 命令提示符 或 PowerShell，执行（共两步）：\n# 1）进入 RabbitMQ 安装目录的 sbin 文件夹（通常如下，版本号需要改成本地的）\nC:\\Program Files\\RabbitMQ Server&gt;cd C:\\Program Files\\RabbitMQ Server\\rabbitmq_server-4.2.1\\sbin\n# 2）启用管理插件\nC:\\Program Files\\RabbitMQ Server\\rabbitmq_server-4.2.1\\sbin&gt;.\\rabbitmq-plugins.bat enable rabbitmq_management\nEnabling plugins on node rabbit@chengzijia:\nrabbitmq_management\nThe following plugins have been configured:\n  rabbitmq_management\n  rabbitmq_management_agent\n  rabbitmq_web_dispatch\nApplying plugin configuration to rabbit@chengzijia...\nThe following plugins have been enabled:\n  rabbitmq_management\n  rabbitmq_management_agent\n  rabbitmq_web_dispatch\n\nset 3 plugins.\nOffline change; changes will take effect at broker restart.</code></pre>\n<p>启用后需要手动重启下 RabbitMQ 服务，然后通过 <a href=\"http://localhost:15672/\" rel=\"noopener nofollow\" target=\"_blank\" title=\"http://localhost:15672/\">http://localhost:15672/</a> 访问。需要登录账号和密码，均为 guest。</p>\n<p><span style=\"font-size: 12px;\"><em>注意：guest 用户默认只能从 localhost 登录，若需远程访问，需创建新用户并授权。</em></span></p>\n<p>在 sbin 目录下可使用以下命令：</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>.\\rabbitmqctl.bat status</code></td>\n<td>查看节点状态</td>\n</tr>\n<tr>\n<td><code>.\\rabbitmqctl.bat list_users</code></td>\n<td>列出用户</td>\n</tr>\n<tr>\n<td><code>.\\rabbitmqctl.bat add_user myuser mypass</code></td>\n<td>添加用户</td>\n</tr>\n<tr>\n<td><code>.\\rabbitmqctl.bat set_user_tags myuser administrator</code></td>\n<td>设置用户为管理员</td>\n</tr>\n<tr>\n<td><code>.\\rabbitmqctl.bat set_permissions -p / myuser \".*\" \".*\" \".*\"</code></td>\n<td>授予 vhost&nbsp;<code>/</code>&nbsp;的全部权限</td>\n</tr>\n</tbody>\n</table>\n<p>配置允许远程访问：</p>\n<pre class=\"language-powershell highlighter-hljs\"><code># 创建新用户\n.\\rabbitmqctl.bat add_user admin yourpassword\n.\\rabbitmqctl.bat set_user_tags admin administrator\n.\\rabbitmqctl.bat set_permissions -p / admin \".*\" \".*\" \".*\"\n# 确保防火墙开放端口：\n# AMQP 默认端口：5672\n# Management Web UI 端口：15672</code></pre>\n<h4>1.2.2 通过 Serilog.Sinks.RabbitMQ 8.0.0 实现讲消息写入到队列</h4>\n<p>示例程序的目标：<strong>将日志信息通过 localhost guest 账号，推送到 amq.fanout 交换机。</strong></p>\n<p>1）创建项目并引入必要的包</p>\n<p>创建一个基于 .net8 的控制台应用程序，并引入以下包：</p>\n<pre class=\"language-powershell highlighter-hljs\"><code>dotnet add package Serilog\ndotnet add package Serilog.Sinks.Console\ndotnet add package Serilog.Sinks.RabbitMQ</code></pre>\n<p>2）修改 Program.cs</p>\n<pre class=\"language-csharp highlighter-hljs\"><code>using RabbitMQ.Client;\nusing Serilog;\nusing Serilog.Events;\nusing Serilog.Formatting.Json;\nusing Serilog.Sinks.RabbitMQ;\n\n// 将 Serilog Sink 内部的异常（如连接失败、权限错误、exchange 不存在等）输出到控制台\nSerilog.Debugging.SelfLog.Enable(Console.Error);\n\n// 配置 Serilog\nLog.Logger = new LoggerConfiguration()\n    .MinimumLevel.Debug()\n    .WriteTo.Console()\n    .WriteTo.RabbitMQ((clientConfiguration, sinkConfiguration) =&gt;\n    {\n        clientConfiguration.Port = 5672;\n        clientConfiguration.DeliveryMode = RabbitMQDeliveryMode.Durable;\n        clientConfiguration.Exchange = \"amq.fanout\";\n        clientConfiguration.Username = \"guest\";\n        clientConfiguration.Password = \"guest\";\n        clientConfiguration.ExchangeType = \"fanout\";\n        clientConfiguration.Hostnames.Add(\"localhost\");\n        sinkConfiguration.TextFormatter = new JsonFormatter();\n    }).CreateLogger();\n\ntry\n{\n    Log.Information(\"应用程序启动\");\n    // 示例结构化日志\n    var userId = 12345;\n    var userName = \"alice\";\n    Log.Information(\"用户 {@User} 登录成功，ID: {UserId}\", new { Name = userName, Role = \"Admin\" }, userId);\n    Log.Warning(\"这是一个警告日志，包含属性 {RetryCount}\", 3);\n    Log.Error(new InvalidOperationException(\"模拟异常\"), \"处理请求时发生错误，请求ID: {RequestId}\", Guid.NewGuid());\n    Log.Information(\"应用程序即将关闭\");\n}\ncatch (Exception ex)\n{\n    Log.Fatal(ex, \"应用程序崩溃\");\n}\nfinally\n{\n    Log.CloseAndFlush(); // 确保日志被发送\n}</code></pre>\n<p>在测试写入日志之前，需要先手动新增队列：logs_first，然后再将此队列加入到 amq.fanout 交换机中。</p>\n<p><span style=\"background-color: rgba(251, 238, 184, 1);\"><strong>新增队列</strong></span>，填入 Name，然后其他默认，直接保存。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1868241/202512/1868241-20251202193859301-511521966.png\" /></p>\n<p><span style=\"background-color: rgba(251, 238, 184, 1);\"><strong>将新增的队列绑定到交换机 amq.fanout 中</strong></span>：（直接输入上一步新增的队列，点击 Bind）</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1868241/202512/1868241-20251202194106507-753137885.png\" /></p>\n<p>然后运行程序，查看队列中的消息，确认是否写入成功。</p>\n<h4>1.2.3 查看消息写入结果</h4>\n<p><span style=\"background-color: rgba(251, 238, 184, 1);\">点击队列名，进入队列的详细信息。</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1868241/202512/1868241-20251202194417662-2092330832.png\" /></p>\n<p><span style=\"background-color: rgba(251, 238, 184, 1);\">点击（Get Message(s)）获取指定条数队列中的消息。</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1868241/202512/1868241-20251202194655663-127466200.png\" /></p>\n<p><span style=\"background-color: rgba(251, 238, 184, 1);\">如下是消息的详细信息：</span></p>\n<pre class=\"language-csharp highlighter-hljs\"><code>Message 1\nThe server reported 4 messages remaining.\n\nExchange\tamq.fanout\nRouting Key\t\nRedelivered\t●\nProperties\t\ndelivery_mode:\t2\nPayload\n112 bytes\nEncoding: string\n{\"Timestamp\":\"2025-12-02T19:25:27.5782940+08:00\",\"Level\":\"Information\",\"MessageTemplate\":\"应用程序启动\"}\n\nMessage 2\nThe server reported 3 messages remaining.\n\nExchange\tamq.fanout\nRouting Key\t\nRedelivered\t●\nProperties\t\ndelivery_mode:\t2\nPayload\n205 bytes\nEncoding: string\n{\"Timestamp\":\"2025-12-02T19:25:28.2261865+08:00\",\"Level\":\"Information\",\"MessageTemplate\":\"用户 {@User} 登录成功，ID: {UserId}\",\"Properties\":{\"User\":{\"Name\":\"alice\",\"Role\":\"Admin\"},\"UserId\":12345}}\n\nMessage 3\nThe server reported 2 messages remaining.\n\nExchange\tamq.fanout\nRouting Key\t\nRedelivered\t●\nProperties\t\ndelivery_mode:\t2\nPayload\n172 bytes\nEncoding: string\n{\"Timestamp\":\"2025-12-02T19:25:28.2352913+08:00\",\"Level\":\"Warning\",\"MessageTemplate\":\"这是一个警告日志，包含属性 {RetryCount}\",\"Properties\":{\"RetryCount\":3}}\n\nMessage 4\nThe server reported 1 messages remaining.\n\nExchange\tamq.fanout\nRouting Key\t\nRedelivered\t●\nProperties\t\ndelivery_mode:\t2\nPayload\n266 bytes\nEncoding: string\n{\"Timestamp\":\"2025-12-02T19:25:28.2368545+08:00\",\"Level\":\"Error\",\"MessageTemplate\":\"处理请求时发生错误，请求ID: {RequestId}\",\"Exception\":\"System.InvalidOperationException: 模拟异常\",\"Properties\":{\"RequestId\":\"0003f90d-4b1e-4cd9-87ef-a875e31b3acb\"}}\n\nMessage 5\nThe server reported 0 messages remaining.\n\nExchange\tamq.fanout\nRouting Key\t\nRedelivered\t●\nProperties\t\ndelivery_mode:\t2\nPayload\n118 bytes\nEncoding: string\n{\"Timestamp\":\"2025-12-02T19:25:28.2457995+08:00\",\"Level\":\"Information\",\"MessageTemplate\":\"应用程序即将关闭\"}</code></pre>\n</div>\n<div id=\"MySignature\">\n    <img src=\"https://images.cnblogs.com/cnblogs_com/blogs/683398/galleries/2417207/o_221441c4.png\" />\n<p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/hnzhengfy/\" target=\"_blank\">橙子家</a>，欢迎微信扫码关注博主【橙子家czzj】，有任何疑问欢迎沟通，共同成长！</p>\n<div><p style=\"float: left;\">转载本文请注明原文链接：<a href=\"https://www.cnblogs.com/hnzhengfy/p/19191039/Serilog_MQSinks\" target=\"_blank\">https://www.cnblogs.com/hnzhengfy/p/19191039/Serilog_MQSinks</a></p></div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-04 19:54</span>&nbsp;\n<a href=\"https://www.cnblogs.com/hnzhengfy\">橙子家</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MAF快速入门（10）循环工作流",
      "link": "https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper10",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper10\" id=\"cb_post_title_url\" title=\"发布于 2026-01-04 18:30\">\n    <span>MAF快速入门（10）循环工作流</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"MAF快速入门（10）循环工作流\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/381412/202601/381412-20260103192858891-1281339805.png\" />\n        在实际业务场景中，往往需要在工作流中设置一些循环与自我修正的机制，构建出一个“生成→审核→修复”的闭环，来确保AI产出的内容能够满足企业级质量标准。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><span><span>大家好，我是Edison。</span></span></p>\n<p><span><span>最近我一直在跟着圣杰的《<a class=\"normal_text_link mp_article_text_link\" href=\"https://www.cnblogs.com/sheng-jie/p/19200934\" target=\"_blank\"><span>.NET+AI智能体开发进阶</span></a><span>》课程学习MAF的开发技巧，我强烈推荐你也上车跟我一起出发！</span></span></span></p>\n<p><span><a class=\"normal_text_link mp_article_text_link\" href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper09\" target=\"_blank\"><span>上一篇</span></a><span>，我们学习了MAF中如何进行switch-case类型的多条件路由<span>。本篇，我们来了解下在MAF中如何实现循环（自我修正）工作流。</span></span></span></p>\n<h1><strong>1 循环与自我修正</strong></h1>\n<p><span><span><span><span><span><span>在实际业务场景中，往往需要在工作流中设置一些循环与自我修正的机制，构建出一个“<span><strong>生成</strong><span><span><strong>→审核</strong><span><span><span><strong>→修复</strong><span><span>”的闭环，来确保AI产出的内容能够满足企业级质量标准<span>。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>\n<p><span><span><span><span><span><span>在MAF中，我们可以使用 Loop Edge 即 循环边 来实现这个目的<span>，如下代码片段所示：</span></span></span></span></span></span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> workflow = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> WorkflowBuilder(draftExecutor)\n    .AddEdge(draftExecutor, qcExecutor)\n    .AddEdge(qcExecutor, draftExecutor)\n    .WithOutputFrom(qcExecutor)\n    .Build();</span></pre>\n</div>\n<p><span><span><span><span><span><span><span>可以看到，我们添加了两个边关联关系，这样就形成了一个循环。</span></span></span></span></span></span></span></p>\n<h1><strong>2 循环工作流实验案例</strong></h1>\n<p><span><span><span><span><span><span><span><span>假设我们是一个电商平台的客服中心，每天需要处理产生的大量客服工单进行回复。这里我们希望AI助手先帮我们生成一个回复草稿，然后经过多维度的质检（礼貌度、准确性、合规性），不合格的则自动进行改进，直到满足标准 或者是 转给人工处理。</span><span><span>因此，我们的目标是：配置一个自动迭代的循环“<span><span><span>生成<span><span>→审核<span><span><span>→修复”，达标即可退出循环，否则转人工处理。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>\n<h3><strong><span><span>2.1 关键依赖包引入</span></span></strong></h3>\n<p><span><span><span><span><span><span><span><span>在今天的这个案例中，我们仍然创建了一个.NET控制台应用程序，安装了以下NuGet包：</span></span></span></span></span></span></span></span></p>\n<ul class=\"list-paddingleft-1\">\n<li><span>Microsoft.Agents.AI.OpenAI</span></li>\n<li><span>Microsoft.Agents.AI.Workflows</span></li>\n<li><span>Microsoft.Extensions.AI.OpenAI</span></li>\n</ul>\n<h3><span><span>2.2 定义数据传输模型</span></span></h3>\n<p><span><span>首先，我们定义一下在这个工作流中需要生成传递的数据模型：</span></span></p>\n<p><span><span>（1）QualityReportDto ：质检结果输出模型DTO</span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 质检结果的结构化输出模型</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> QualityReportDto\n{\n    [JsonPropertyName(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">politenessScore</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)]\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> PolitenessScore { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n    [JsonPropertyName(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">accuracyScore</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)]\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> AccuracyScore { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n    [JsonPropertyName(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">compliancePassed</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)]\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">bool</span> CompliancePassed { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n    [JsonPropertyName(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">issues</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)]\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> List&lt;QualityIssueDto&gt; Issues { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span>; } = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\">();\n}\n</span><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> QualityIssueDto\n{\n    [JsonPropertyName(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">type</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)]\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span> Type { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span>; } = <span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\">.Empty;\n    [JsonPropertyName(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">description</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)]\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span> Description { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span>; } = <span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\">.Empty;\n    [JsonPropertyName(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">scoreImpact</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)]\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> ScoreImpact { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n}</span></pre>\n</div>\n<p><span><span>（2）一些值对象，不赘述了</span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">internal</span><span style=\"color: rgba(0, 0, 0, 1);\"> record ReplyDraft(\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> TicketId, \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> Content, \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> Attempt);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">internal</span><span style=\"color: rgba(0, 0, 0, 1);\"> record TicketRequest(\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> Id, \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> Query, \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> Category, \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> Priority);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">internal</span><span style=\"color: rgba(0, 0, 0, 1);\"> record TicketOutcome(\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> TicketId, \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> Status, \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> Attempts, \n    QualityReport FinalReport);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">sealed</span><span style=\"color: rgba(0, 0, 0, 1);\"> record QualityScoreTimelineItem(\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> Attempt,\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> PolitenessScore,\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> AccuracyScore,\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> ComplianceStatus);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">internal</span><span style=\"color: rgba(0, 0, 0, 1);\"> record QualityIssue(\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> Type, \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> Description, \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> ScoreImpact);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">internal</span><span style=\"color: rgba(0, 0, 0, 1);\"> record QualityReport(\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> TicketId, \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> PolitenessScore, \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> AccuracyScore, \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">bool</span><span style=\"color: rgba(0, 0, 0, 1);\"> CompliancePassed, \n    IReadOnlyList</span>&lt;QualityIssue&gt; Issues);</pre>\n</div>\n<p><span><span>（3）一些常量：用于定义一些阈值标准</span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> QualityCheckConstants\n{\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 质检标准：礼貌度 ≥ 85，准确性 ≥ 90，合规性必须 100%\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 注意：阈值设置较高，配合第一次生成简化版本，确保能体现循环改进过程</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> PolitenessThreshold = <span style=\"color: rgba(128, 0, 128, 1);\">85</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> AccuracyThreshold = <span style=\"color: rgba(128, 0, 128, 1);\">90</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n}\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">enum</span><span style=\"color: rgba(0, 0, 0, 1);\"> QualityCheckSignal\n{\n    Init,\n    Revise\n}</span></pre>\n</div>\n<h3><span><span>2.3 定义自定义工作流事件</span></span></h3>\n<p><span><span>其次，我们定义一下在这个工作流中需要产生的自定义事件：</span></span></p>\n<p>（1）AdaptiveQualityScoreEvent ：质检评分已完成事件</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">sealed</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> AdaptiveQualityScoreEvent : WorkflowEvent\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> AdaptiveQualityScoreEvent(<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> ticketId, \n        </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> attempt, \n        </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> politenessScore, \n        </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> accuracyScore, \n        </span><span style=\"color: rgba(0, 0, 255, 1);\">bool</span><span style=\"color: rgba(0, 0, 0, 1);\"> compliancePassed)\n        : </span><span style=\"color: rgba(0, 0, 255, 1);\">base</span>(<span style=\"color: rgba(0, 0, 255, 1);\">new</span> { TicketId = ticketId, Attempt = attempt, PolitenessScore = politenessScore, AccuracyScore = accuracyScore, CompliancePassed =<span style=\"color: rgba(0, 0, 0, 1);\"> compliancePassed })\n    {\n    }\n}</span></pre>\n</div>\n<p><span>（2）AdaptiveMaxAttemptsReachedEvent ：质检超过最大次数事件</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">sealed</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> AdaptiveMaxAttemptsReachedEvent : WorkflowEvent\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> AdaptiveMaxAttemptsReachedEvent(<span style=\"color: rgba(0, 0, 255, 1);\">string</span> ticketId, <span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> maxAttempts)\n        : </span><span style=\"color: rgba(0, 0, 255, 1);\">base</span>(<span style=\"color: rgba(0, 0, 255, 1);\">new</span> { TicketId = ticketId, MaxAttempts =<span style=\"color: rgba(0, 0, 0, 1);\"> maxAttempts })\n    {\n    }\n}</span></pre>\n</div>\n<h3><span><span>2.4 定义Agents</span></span></h3>\n<p><span>（1）<strong>回复生成</strong>：模</span>这里通过执行器的方式包裹一个回复生成的Agent，假设其用于客服工单的自动回复：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">sealed</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span> AdaptiveReplyDraftExecutor : Executor&lt;QualityCheckSignal&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span><span style=\"color: rgba(0, 0, 0, 1);\"> TicketRequest _ticket;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span><span style=\"color: rgba(0, 0, 0, 1);\"> IChatClient _chatClient;\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> AdaptiveReplyDraftExecutor(TicketRequest ticket, IChatClient chatClient) : <span style=\"color: rgba(0, 0, 255, 1);\">base</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">AdaptiveReplyDraft</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        _ticket </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> ticket;\n        _chatClient </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> chatClient;\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span> ValueTask HandleAsync(QualityCheckSignal message, IWorkflowContext context, CancellationToken cancellationToken = <span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span> attempt = <span style=\"color: rgba(0, 0, 255, 1);\">await</span> context.ReadOrInitStateAsync(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">attempt</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, () =&gt; <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">, cancellationToken);\n        attempt</span>++<span style=\"color: rgba(0, 0, 0, 1);\">;\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">await</span> context.QueueStateUpdateAsync(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">attempt</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, attempt, cancellationToken);\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 使用 AI 生成客服回复（渐进式生成策略）</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> prompt = attempt == <span style=\"color: rgba(128, 0, 128, 1);\">1</span>\n            ? $<span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"\n</span><span style=\"color: rgba(0, 0, 0, 1);\">            你是一位电商客服。请针对以下客户问题生成一条简短回复（刻意保持简短、缺少礼貌用语）：\n\n            客户问题：{_ticket.Query}\n            产品类别：{_ticket.Category}\n\n            要求：\n            </span><span style=\"color: rgba(128, 0, 128, 1);\">1</span>. 只用1-<span style=\"color: rgba(0, 0, 0, 1);\">2句话回答，不要称呼语和感谢语\n            </span><span style=\"color: rgba(128, 0, 128, 1);\">2</span><span style=\"color: rgba(0, 0, 0, 1);\">. 只说结论，不提供具体处理时间\n            </span><span style=\"color: rgba(128, 0, 128, 1);\">3</span><span style=\"color: rgba(0, 0, 0, 1);\">. 字数控制在30字以内\n\n            直接返回回复内容，不要添加任何前缀或说明。\n            </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"\n</span>            : $<span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"\n</span><span style=\"color: rgba(0, 0, 0, 1);\">            你是一位专业的电商客服。请针对以下客户问题生成一条改进后的回复：\n\n            客户问题：{_ticket.Query}\n            产品类别：{_ticket.Category}\n            优先级：{_ticket.Priority}\n\n            要求：\n            </span><span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">. 语气亲和、专业，使用恰当的称呼和感谢语\n            </span><span style=\"color: rgba(128, 0, 128, 1);\">2</span><span style=\"color: rgba(0, 0, 0, 1);\">. 提供具体的解决方案或处理时间\n            </span><span style=\"color: rgba(128, 0, 128, 1);\">3</span><span style=\"color: rgba(0, 0, 0, 1);\">. 符合客服规范，不包含敏感词\n            </span><span style=\"color: rgba(128, 0, 128, 1);\">4</span>. 字数控制在80-<span style=\"color: rgba(0, 0, 0, 1);\">100字\n\n            直接返回回复内容，不要添加任何前缀或说明。\n            </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">;</span>\n\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> response = <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> _chatClient.GetResponseAsync(prompt, cancellationToken: cancellationToken);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> content = response.Text ?? <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">抱歉，我们会尽快处理您的问题。</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n\n        Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">✍️ 第 {attempt} 次生成回复草稿 (策略: {(attempt == 1 ? </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>简化版<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\"> : </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>完整版<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">)})</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">📝 回复内容：{content}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> draft = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ReplyDraft(_ticket.Id, content, attempt);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">await</span> context.SendMessageAsync(draft, targetId: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">AdaptiveQualityCheck</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, cancellationToken);\n    }\n}</span></pre>\n</div>\n<p><span>（2）</span><strong><span><span><span>内容质检</span></span></span></strong><span>：模拟生成内容的质检过程，通过AI大模型对内容进行多维度的质检评分，只有通过标准才算结束循环，否则继续反馈给上一个Agent进行改进。</span></p>\n<p><span>NOTE：只有质检Agent才能决定是否结束工作流！</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">sealed</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span> AdaptiveQualityCheckExecutor : Executor&lt;ReplyDraft&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> _politenessThreshold;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> _accuracyThreshold;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> _maxAttempts;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span><span style=\"color: rgba(0, 0, 0, 1);\"> IChatClient _chatClient;\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 默认最大尝试次数为5次</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">public</span> AdaptiveQualityCheckExecutor(<span style=\"color: rgba(0, 0, 255, 1);\">int</span> politenessThreshold, <span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> accuracyThreshold, IChatClient chatClient)\n        : </span><span style=\"color: rgba(0, 0, 255, 1);\">this</span>(politenessThreshold, accuracyThreshold, <span style=\"color: rgba(128, 0, 128, 1);\">5</span><span style=\"color: rgba(0, 0, 0, 1);\">, chatClient)\n    {\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> AdaptiveQualityCheckExecutor(<span style=\"color: rgba(0, 0, 255, 1);\">int</span> politenessThreshold, <span style=\"color: rgba(0, 0, 255, 1);\">int</span> accuracyThreshold, <span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> maxAttempts, IChatClient chatClient)\n        : </span><span style=\"color: rgba(0, 0, 255, 1);\">base</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">AdaptiveQualityCheck</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        _politenessThreshold </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> politenessThreshold;\n        _accuracyThreshold </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> accuracyThreshold;\n        _maxAttempts </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> maxAttempts;\n        _chatClient </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> chatClient;\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span> ValueTask HandleAsync(ReplyDraft draft, IWorkflowContext context, CancellationToken cancellationToken = <span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span> attempt = <span style=\"color: rgba(0, 0, 255, 1);\">await</span> context.ReadOrInitStateAsync(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">attempt</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, () =&gt; <span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">, cancellationToken);\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 使用 AI 进行多维度质检评分（结构化输出，严格标准）</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> prompt = $<span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"\n</span>        你是一位严格的客服质检专家。请对以下客服回复进行多维度评分（<span style=\"color: rgba(128, 0, 128, 1);\">0</span>-<span style=\"color: rgba(0, 0, 0, 1);\">100分）：\n\n        回复内容：{draft.Content}\n\n        评分维度和严格标准：\n        </span><span style=\"color: rgba(128, 0, 128, 1);\">1</span>. 礼貌度（<span style=\"color: rgba(128, 0, 128, 1);\">0</span>-<span style=\"color: rgba(128, 0, 128, 1);\">100</span><span style=\"color: rgba(0, 0, 0, 1);\">）：必须包含称呼语（您、亲）、感谢语（感谢、谢谢）、结束语（祝、期待）等，语气亲和温暖\n           </span>-<span style=\"color: rgba(0, 0, 0, 1);\"> 缺少任何一项扣20分\n           </span>- 语气生硬、机械扣10-<span style=\"color: rgba(0, 0, 0, 1);\">30分\n\n        </span><span style=\"color: rgba(128, 0, 128, 1);\">2</span>. 准确性（<span style=\"color: rgba(128, 0, 128, 1);\">0</span>-<span style=\"color: rgba(128, 0, 128, 1);\">100</span><span style=\"color: rgba(0, 0, 0, 1);\">）：必须提供具体的解决方案、明确的处理时间或有效的后续步骤\n           </span>- 只说<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">会处理</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">但无具体方案扣30分\n           </span>-<span style=\"color: rgba(0, 0, 0, 1);\"> 无明确时间承诺扣20分\n           </span>- 信息过于笼统扣10-<span style=\"color: rgba(0, 0, 0, 1);\">20分\n\n        </span><span style=\"color: rgba(128, 0, 128, 1);\">3</span>. 合规性（通过/<span style=\"color: rgba(0, 0, 0, 1);\">不通过）：不得包含敏感词、不当表述、推诿责任的话语\n           </span>- 发现任何敏感词或不当表述直接判定为<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">不通过</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n\n        请对每个维度进行严格评分，并在issues字段中列出所有发现的问题。\n        </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">;</span>\n\n        <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> ⭐ 使用结构化输出：GetResponseAsync&lt;T&gt; 自动生成 JSON Schema 并反序列化</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> response = <span style=\"color: rgba(0, 0, 255, 1);\">await</span> _chatClient.GetResponseAsync&lt;QualityReportDto&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(prompt, cancellationToken: cancellationToken);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> reportDto =<span style=\"color: rgba(0, 0, 0, 1);\"> response.Result;\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 转换为业务模型</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> issues = reportDto.Issues.Select(i =&gt; <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> QualityIssue(i.Type, i.Description, i.ScoreImpact)).ToList();\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> report = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> QualityReport(draft.TicketId, reportDto.PolitenessScore, reportDto.AccuracyScore, reportDto.CompliancePassed, issues);\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">await</span> context.AddEventAsync(<span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AdaptiveQualityScoreEvent(draft.TicketId, attempt, reportDto.PolitenessScore, reportDto.AccuracyScore, reportDto.CompliancePassed), cancellationToken);\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (reportDto.PolitenessScore &gt;=<span style=\"color: rgba(0, 0, 0, 1);\"> _politenessThreshold \n            </span>&amp;&amp; reportDto.AccuracyScore &gt;=<span style=\"color: rgba(0, 0, 0, 1);\"> _accuracyThreshold \n            </span>&amp;&amp;<span style=\"color: rgba(0, 0, 0, 1);\"> reportDto.CompliancePassed)\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">await</span> context.YieldOutputAsync(<span style=\"color: rgba(0, 0, 255, 1);\">new</span> TicketOutcome(draft.TicketId, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Approved</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, attempt, report), cancellationToken);\n        }\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span> <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (attempt &gt;=<span style=\"color: rgba(0, 0, 0, 1);\"> _maxAttempts)\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">await</span> context.AddEventAsync(<span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AdaptiveMaxAttemptsReachedEvent(draft.TicketId, _maxAttempts), cancellationToken);\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">await</span> context.RequestHaltAsync();<span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">质检失败：已达到最大尝试次数</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">        }\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\">\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">await</span> context.QueueStateUpdateAsync(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">attempt</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, attempt + <span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">, cancellationToken);\n\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 发送质检报告到改进环节</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">await</span> context.SendMessageAsync(report, targetId: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">IntelligentImprove</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, cancellationToken);\n        }\n    }\n}</span></pre>\n</div>\n<p><span>（3）</span><strong><strong><span><span><span>内容改进</span></span></span></strong></strong><span>：模拟收到质检的评分反馈后对内容进行改进。</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">sealed</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span> IntelligentImproveExecutor : Executor&lt;QualityReport&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span><span style=\"color: rgba(0, 0, 0, 1);\"> TicketRequest _ticket;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span><span style=\"color: rgba(0, 0, 0, 1);\"> IChatClient _chatClient;\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> IntelligentImproveExecutor(TicketRequest ticket, IChatClient chatClient) : <span style=\"color: rgba(0, 0, 255, 1);\">base</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">IntelligentImprove</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        _ticket </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> ticket;\n        _chatClient </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> chatClient;\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span> ValueTask HandleAsync(QualityReport report, IWorkflowContext context, CancellationToken cancellationToken = <span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span> attempt = <span style=\"color: rgba(0, 0, 255, 1);\">await</span> context.ReadOrInitStateAsync(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">attempt</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, () =&gt; <span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">, cancellationToken);\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 构建改进提示词，基于质检反馈</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> issuesSummary = <span style=\"color: rgba(0, 0, 255, 1);\">string</span>.Join(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, report.Issues.Select(i =&gt; $<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">- {i.Type}: {i.Description}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">));\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> prompt = $<span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"\n</span><span style=\"color: rgba(0, 0, 0, 1);\">        你是一位客服优化专家。请根据以下质检反馈，改进客服回复内容：\n\n        原始问题：{_ticket.Query}\n        产品类别：{_ticket.Category}\n        优先级：{_ticket.Priority}\n\n        当前评分：\n        </span>- 礼貌度：{report.PolitenessScore}/<span style=\"color: rgba(128, 0, 128, 1);\">100</span><span style=\"color: rgba(0, 0, 0, 1);\"> (要求≥{QualityCheckConstants.PolitenessThreshold})\n        </span>- 准确性：{report.AccuracyScore}/<span style=\"color: rgba(128, 0, 128, 1);\">100</span><span style=\"color: rgba(0, 0, 0, 1);\"> (要求≥{QualityCheckConstants.AccuracyThreshold})\n        </span>- 合规性：{(report.CompliancePassed ? <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">通过</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> : <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">不通过</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)}\n\n        发现的问题：\n        {issuesSummary}\n\n        请生成一条改进后的客服回复，针对性解决上述问题：\n        </span><span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">. 如果礼貌度不足，增加称呼语、感谢语，使用更亲和的表述\n        </span><span style=\"color: rgba(128, 0, 128, 1);\">2</span><span style=\"color: rgba(0, 0, 0, 1);\">. 如果准确性不足，补充具体的解决方案、处理时间、后续步骤\n        </span><span style=\"color: rgba(128, 0, 128, 1);\">3</span><span style=\"color: rgba(0, 0, 0, 1);\">. 如果合规性不通过，移除敏感词，规范表述\n        </span><span style=\"color: rgba(128, 0, 128, 1);\">4</span>. 字数控制在80-<span style=\"color: rgba(0, 0, 0, 1);\">100字\n\n        直接返回改进后的回复内容，不要添加任何前缀或说明。\n        </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">;</span>\n\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> response = <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> _chatClient.GetResponseAsync(prompt, cancellationToken: cancellationToken);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> improvedContent = response.Text ?? <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">抱歉，我们会尽快处理您的问题。</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">await</span> context.AddEventAsync(<span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> LoopProgressEvent(_ticket.Id, attempt, \n            report.PolitenessScore, report.AccuracyScore, \n            report.CompliancePassed, </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Improve</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">), cancellationToken);\n        Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">🔧 第 {attempt} 次智能改进完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">📝 改进后内容：{improvedContent}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 触发下一次生成（使用改进后的内容作为上下文）</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">await</span> context.SendMessageAsync(QualityCheckSignal.Revise, targetId: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">AdaptiveReplyDraft</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, cancellationToken);\n    }\n}</span></pre>\n</div>\n<h3>2.5 构建工作流</h3>\n<p>现在万事俱备，只欠一个Workflow，现在Let's do it!</p>\n<p><strong>Step1: 获取ChatClient</strong></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> chatClient = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> OpenAIClient(\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ApiKeyCredential(openAIProvider.ApiKey),\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> OpenAIClientOptions { Endpoint = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> Uri(openAIProvider.Endpoint) })\n    .GetChatClient(openAIProvider.ModelId)\n    .AsIChatClient();</span></pre>\n</div>\n<p><strong><span><span>Step2<span>: 实例化自定义Agent &amp; Executors</span></span></span></strong></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> ticket = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> TicketRequest(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">TKT-2025-003</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">会员积分为什么突然清零了？</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">账户问题</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Low</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> maxAttempts = <span style=\"color: rgba(128, 0, 128, 1);\">5</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> adaptiveDraft = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AdaptiveReplyDraftExecutor(ticket, chatClient);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> adaptiveQC = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AdaptiveQualityCheckExecutor(QualityCheckConstants.PolitenessThreshold, QualityCheckConstants.AccuracyThreshold, chatClient);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> intelligentImprove = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> IntelligentImproveExecutor(ticket, chatClient);</pre>\n</div>\n<p><strong><span><span>Step3<span>: 创建循环路由工作流</span></span></span></strong></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> workflow = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> WorkflowBuilder(adaptiveDraft)\n    .AddEdge(adaptiveDraft, adaptiveQC)\n    .AddEdge(adaptiveQC, intelligentImprove)\n    .AddEdge(intelligentImprove, adaptiveDraft)\n    .WithOutputFrom(adaptiveQC)\n    .Build();\nConsole.OutputEncoding </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> Encoding.UTF8;\nConsole.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">✅ Loop Workflow 构建完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>);</pre>\n</div>\n<h3><span><span>2.6 测试工作流</span></span></h3>\n<p><span><span>通过Streaming流式执行：</span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">await</span> <span style=\"color: rgba(0, 0, 255, 1);\">using</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> run = <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> InProcessExecution.StreamAsync(workflow, QualityCheckSignal.Init))\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> scoreTimeline = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> List&lt;<span style=\"color: rgba(0, 0, 255, 1);\">object</span>&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">await</span> <span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> evt <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> run.WatchStreamAsync())\n    {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 强制中断（最多5次尝试）</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (scoreTimeline.Count ==<span style=\"color: rgba(0, 0, 0, 1);\"> maxAttempts)\n        {\n            Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">⛔ 强制中断工作流执行（已完成{maxAttempts}次评估）</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        }\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">switch</span><span style=\"color: rgba(0, 0, 0, 1);\"> (evt)\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">case</span><span style=\"color: rgba(0, 0, 0, 1);\"> AdaptiveQualityScoreEvent scoreEvent:\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">dynamic</span> payload = scoreEvent.Data!<span style=\"color: rgba(0, 0, 0, 1);\">;\n                scoreTimeline.Add(</span><span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> QualityScoreTimelineItem(\n                    Attempt: (</span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\">)payload.Attempt,\n                    PolitenessScore: (</span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\">)payload.PolitenessScore,\n                    AccuracyScore: (</span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\">)payload.AccuracyScore,\n                    ComplianceStatus: (</span><span style=\"color: rgba(0, 0, 255, 1);\">bool</span>)payload.CompliancePassed ? <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">✅</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> : <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">❌</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n                ));\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> statusMessage = payload.CompliancePassed ? <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">通过</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> : <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">不通过</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n                Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">📊 AI 质检结果 =&gt; 礼貌度:{payload.PolitenessScore} 准确性:{payload.AccuracyScore} 合规性:{statusMessage}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">case</span><span style=\"color: rgba(0, 0, 0, 1);\"> WorkflowOutputEvent outputEvent:\n                Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">🎉 工作流执行完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">{outputEvent.Data}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">case</span><span style=\"color: rgba(0, 0, 0, 1);\"> WorkflowErrorEvent errorEvent:\n                Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">✨ 收到 Workflow Error Event：</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">{errorEvent.Data}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        }\n    }\n}</span></pre>\n</div>\n<p><strong>测试用例1</strong></p>\n<p><span><span>工单内容：<span style=\"text-decoration: underline;\">订单已经3天没发货，能退款吗？</span></span></span></p>\n<p><span><span>测试结果如下图所示：</span></span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202601/381412-20260103192559594-1628756144.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p><span><span>可以看见，经过初次生成和内容改进，该内容回复已经满足了标准可以直接回复用户。</span></span></p>\n<p><strong>测试用例2</strong></p>\n<p><span><span>工单内容：<span style=\"text-decoration: underline;\">会员积分为什么突然清零了？</span></span></span></p>\n<p><span><span>测试结果如下图所示：</span></span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202601/381412-20260103192630728-832060369.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p><span><span><span><span>可以看到，通过循环和自我修正模式，工作流能够实现“<span><span><span>生成<span><span>→审核<span><span><span>→修复<span>”的工作模式，<strong>特别适用于内容生成和审批的场景。</strong></span></span></span></span></span></span></span></span></span></span></span></span></span></p>\n<h1>3 小结</h1>\n<p>本文介绍了MAF中循环工作流以及如何实现“<span>生成→审核<span><span>→修复”的工作模式，最后通过一个企业客服工单内容智能回复的案例介绍了这种模式的代码实现，特别适用于<span><span>内容生成和审批的场景。</span></span></span></span></span></p>\n<p>下一篇，我们将继续学习MAF中工作流的并行工作流。</p>\n<h1>示例源码</h1>\n<p>GitHub:&nbsp;<a href=\"https://github.com/EdisonTalk/MAFD\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/EdisonTalk/MAFD</a></p>\n<h1>参考资料</h1>\n<p><span><span>圣杰，《<a href=\"https://www.cnblogs.com/sheng-jie/p/19200934\" target=\"_blank\">.NET + AI 智能体开发进阶</a>》（推荐指数：★★★★★）</span></span></p>\n<p><span><span>Microsoft Learn，<span>《<a href=\"https://learn.microsoft.com/en-us/agent-framework/overview/agent-framework-overview?wt.mc_id=MVP_397012\" rel=\"noopener nofollow\" target=\"_blank\">Agent Framework Tutorials</a>》</span></span></span></p>\n<div><span><span>&nbsp;</span></span></div>\n<p style=\"text-align: center;\"><img alt=\"\" src=\"https://images.cnblogs.com/cnblogs_com/edisonchou/1647700/o_200902144330EdisonTalk-Footer.jpg\" /></p>\n<div id=\"Copyright\">\n<p>作者：<span style=\"text-decoration: underline;\">爱迪生</span></p>\n<p>出处：<a href=\"https://edisontalk.cnblogs.com\" target=\"_blank\" title=\"from\">https://edisontalk.cnblogs.com</a></p>\n<p>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。</p>\n</div>\n</div>\n<div id=\"MySignature\">\n    <div align=\"center\"><a href=\"https://weibo.com/u/2068032061?s=6uyXnP\" target=\"_blank\"><img border=\"0\" src=\"http://service.t.sina.com.cn/widget/qmd/2068032061/d643d182/10.png\" /></a></div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-04 18:30</span>&nbsp;\n<a href=\"https://www.cnblogs.com/edisontalk\">EdisonZhou</a>&nbsp;\n阅读(<span id=\"post_view_count\">3</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "让WinForms再次伟大",
      "link": "https://www.cnblogs.com/xdesigner/p/19438384/Make_WinForms_Great_Again",
      "published": "",
      "description": "<h2>\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xdesigner/p/19438384/Make_WinForms_Great_Again\" id=\"cb_post_title_url\" title=\"发布于 2026-01-04 15:49\">\n    <span>让WinForms再次伟大</span>\n    \n\n</a>\n\n\t\t</h2>\n\t\t<div class=\"postText\">    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本项目就是专门帮助将WinForms 应用程序迁移到 Blazor WASM平台上，即使这些程序使用GDI+功能，我们也预期将对这些程序源码的修改量不超过10%。这极大的降低WinForms软件现代化的成本和风险。\n我们的长期目标是能将全球1000亿行经过市场验证的C#代码能重获新生，在现代Web前端平台上继续发挥价值。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"让-winforms-再次伟大-httpsgithubcomdcsoft-yyfmwga\">让 WinForms 再次伟大 <a href=\"https://github.com/dcsoft-yyf/MWGA\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/dcsoft-yyf/MWGA</a></h1>\n<h2 id=\"更新日志\">更新日志</h2>\n<ul>\n<li>2026-1-4 :第一滴血 <a href=\"https://dcsoft-yyf.github.io/MWGA/WinFormCalculator.html\" rel=\"noopener nofollow\" target=\"_blank\">https://dcsoft-yyf.github.io/MWGA/WinFormCalculator.html</a></li>\n</ul>\n<h2 id=\"全球-winforms-现代化现状\">全球 WinForms 现代化现状</h2>\n<p>全球范围内，估计WinForms开发者约有300万至500万人，占.NET开发者总数的40%至50%。生产环境中运行着1000万至1500万个WinForms应用程序。在这些应用中，60%至80%有现代化改造需求，其中40%至60%优先选择Web化迁移，涉及的C#代码可能有<code>数千亿行</code>。核心驱动因素包括网页端访问、界面现代化、跨平台支持、云集成和安全合规。由于可复用C#代码且具备基于浏览器的跨平台能力，Blazor WebAssembly成为热门选择。</p>\n<p>但是有大量的WinForms使用了<code>System.Drawing</code>模块调用<code>GDI+</code>进行复杂的自定义绘图和交互，这些部分难以通过简单的控件映射迁移，通常需要重写或大幅修改。为此，市场上对低改动、可复用业务逻辑和绘图代码的现代化迁移解决方案需求强烈。但长期以来一直缺乏有效工具和方法，导致许多企业面临高昂的重写成本和风险。</p>\n<h2 id=\"项目简介\">项目简介</h2>\n<p>本项目就是专门帮助将WinForms 应用程序迁移到 Blazor WASM平台上，即使这些程序使用GDI+功能，我们也预期将对这些程序源码的修改量不超过<code>10%</code>。这极大的降低WinForms软件现代化的成本和风险。</p>\n<p>我们的长期目标是能将全球<code>1000亿</code>行经过市场验证的C#代码能重获新生，在现代Web前端平台上继续发挥价值。</p>\n<h2 id=\"全球待迁移-winforms-应用市场规模估算美元\">全球待迁移 WinForms 应用市场规模估算（美元）</h2>\n<p>假设需要迁移的 WinForms 应用约 50 万 – 200 万 个；应用复杂度分布：简单 60%、中等 30%、复杂 10%。</p>\n<ul>\n<li>按示例单应用迁移成本中位数估算（美元）：加权均价约 5.5 万美元/应用。</li>\n<li>TAM（总可寻址市场）估算：约 275 亿 – 1,100 亿 美元（50 万 – 200 万 应用 × 5.5 万美元）。</li>\n<li>工具/许可模式可寻址市场（5 千 – 2 万 美元/应用）：约 25 亿 – 400 亿 美元。</li>\n<li>复杂应用（10%）市场：约 5 万 – 20 万 个，按每例 15 万美元计约 75 亿 – 300 亿 美元。</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n</div>\n\t\t<p class=\"postfoot\">\n\t\t\tposted on \n<span id=\"post-date\">2026-01-04 15:49</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xdesigner\">袁永福 电子病历，医疗信息化</a>&nbsp;\n阅读(<span id=\"post_view_count\">532</span>)&nbsp;\n评论(<span id=\"post_comment_count\">7</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</p>"
    },
    {
      "title": "基于 ContextCapture SDK 的 Python 自动化三维建模",
      "link": "https://www.cnblogs.com/foury/p/19438102",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/foury/p/19438102\" id=\"cb_post_title_url\" title=\"发布于 2026-01-04 15:13\">\n    <span>基于 ContextCapture SDK 的 Python 自动化三维建模</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"基于-contextcapture-sdk-的-python-自动化三维建模\">基于 ContextCapture SDK 的 Python 自动化三维建模</h1>\n<p>ContextCapture 是 Bentley 提供的一款商业级三维重建软件，广泛应用于无人机倾斜摄影、实景三维建模等场景。</p>\n<p>本文基于 ContextCapture 官方提供的 MasterKernel SDK，介绍如何通过 Python 脚本实现对 ContextCapture 建模流程的自动化控制，包括项目创建、空中三角测量（AT）、三维重建以及多种格式成果的顺序生产。</p>\n<p><strong>ContextCapture MasterKernel SDK介绍</strong>:<a href=\"https://docs.bentley.com/LiveContent/web/ContextCapture%20Help-v18/zh-cn/GUID-8A35B878-C2BB-4F01-8D5A-18321EF04410.html\" rel=\"noopener nofollow\" target=\"_blank\">https://docs.bentley.com/LiveContent/web/ContextCapture Help-v18/zh-cn/GUID-8A35B878-C2BB-4F01-8D5A-18321EF04410.html</a></p>\n<h2 id=\"1安装contextcapture\">1.安装ContextCapture</h2>\n<p>基于ContextCapture的安装网上有很多详细的教程，本文不再对安装步骤进行详细展开。<br />\n本文测试环境使用的ContextCapture版本为 <strong>v10.18.0.232</strong>，后续示例均基于该版本，仅供参考。</p>\n<h2 id=\"2配置适合contextcapture的python环境\">2.配置适合ContextCapture的Python环境</h2>\n<p>在 ContextCapture 安装目录的 <code>sdk/dist</code> 文件夹中，可以找到官方提供的 Python SDK 安装包（<code>.whl</code> 文件）。</p>\n<p>例如：<br />\n<code>ccmasterkernel-10.18.0.232-cp36-cp36m-win_amd64.whl</code></p>\n<p>其中“cp36-cp36m”表示只支持 Python3.6 相关版本（要安装正确的Python版本）。</p>\n<p>安装完成Python环境后，打开命令行进入sdk/dist文件夹下，执行<code>pip install ccmasterkernel-10.18.0.232-cp36-cp36m-win_amd64.whl</code>安装好这个包。</p>\n<p><img alt=\"企业微信截图_17675106628003\" class=\"lazyload\" /></p>\n<h2 id=\"3编写python脚本\">3.编写Python脚本</h2>\n<p>关于sdk使用的相关文档说明在sdk/doc/html文件夹下。</p>\n<p>下面给出一个完整的 Python 脚本示例，用于演示如何通过 ContextCapture SDK 实现无人机影像的自动化三维建模流程。</p>\n<p>该脚本后续可根据实际需求进行裁剪或扩展。</p>\n<p>此脚本是一个用于自动化 ContextCapture (CC) 建模流程的 Python 脚本。它能够自动创建项目、提交空三运算 (AT)，并按顺序生成多种格式的三维模型（OBJ, LAS, 3D Tiles）。</p>\n<p><strong>注意：</strong> 正式运行脚本前，需确保ContextCapture Engine 已启动，否则任务无法正常提交；</p>\n<h3 id=\"31命令行参数\">3.1命令行参数</h3>\n<p>脚本支持通过命令行参数进行灵活配置：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">参数</th>\n<th style=\"text-align: left;\">必选/可选</th>\n<th style=\"text-align: left;\">默认值</th>\n<th style=\"text-align: left;\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><code>--photos</code></td>\n<td style=\"text-align: left;\"><strong>必选</strong></td>\n<td style=\"text-align: left;\">-</td>\n<td style=\"text-align: left;\">照片所在的源文件夹路径。支持 jpg, tif, png 等格式。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>--project</code></td>\n<td style=\"text-align: left;\"><strong>必选</strong></td>\n<td style=\"text-align: left;\">-</td>\n<td style=\"text-align: left;\">项目输出的根文件夹路径。脚本将在此目录下创建 <code>.ccm</code> 项目文件和各个产物文件夹。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>--memory</code></td>\n<td style=\"text-align: left;\">可选</td>\n<td style=\"text-align: left;\"><code>16.0</code></td>\n<td style=\"text-align: left;\">目标内存使用量 (GB)。用于控制分块大小，建议设置为机器物理内存的 50%-70%。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>--formats</code></td>\n<td style=\"text-align: left;\">可选</td>\n<td style=\"text-align: left;\">全部</td>\n<td style=\"text-align: left;\">指定要生产的格式列表。可选值: <code>OBJ</code>, <code>LAS</code>, <code>3DTiles</code>。多个值之间用空格分隔。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"32-使用示例\">3.2 使用示例</h3>\n<p>在命令行 (CMD 或 PowerShell) 中运行以下命令。</p>\n<h4 id=\"1-基础用法\">1） 基础用法</h4>\n<p>生成所有默认格式 (OBJ, LAS, 3D Tiles)，默认使用 16GB 内存限制。</p>\n<pre><code class=\"language-powershell\">python test_cc_sequential.py --photos \"D:\\MyData\\Mission_01\\Images\" --project \"D:\\Projects\\Mission_01\"\n</code></pre>\n<h4 id=\"2指定输出格式\">2）指定输出格式</h4>\n<p>如果你只需要点云 (LAS) 和 OBJ 模型，不需要 3D Tiles：</p>\n<pre><code class=\"language-powershell\">python test_cc_sequential.py --photos \"D:\\Images\" --project \"D:\\Output\" --formats LAS OBJ\n</code></pre>\n<h4 id=\"3自定义内存限制\">3）自定义内存限制</h4>\n<p>针对大内存 (例如 64GB 内存)，可以调高限制以加快处理速度 (例如设为 48GB)：</p>\n<pre><code class=\"language-powershell\">python test_cc_sequential.py --photos \"D:\\Images\" --project \"D:\\Output\" --memory 48.0\n</code></pre>\n<p>针对小内存机器 (例如 16GB 内存)，建议调低限制 (例如 8GB)：</p>\n<pre><code class=\"language-powershell\">python test_cc_sequential.py --photos \"D:\\Images\" --project \"D:\\Output\" --memory 8.0\n</code></pre>\n<h3 id=\"33-输出结构\">3.3 输出结构</h3>\n<p>运行完成后，在指定的 <code>--project</code> 目录下会自动生成以下结构：</p>\n<pre><code class=\"language-text\">D:\\Projects\\Mission_01\\         &lt;-- 项目根目录\n│  Mission_01.ccm              &lt;-- CC 工程文件\n│  cc_sequential.log           &lt;-- 详细运行日志\n│\n├─ Production_OBJ\\             &lt;-- OBJ 模型输出目录\n│      metadata.xml\n│      ...\n│\n├─ Production_LAS\\             &lt;-- LAS 点云输出目录\n│      cloud.las\n│      ...\n│\n└─ Production_3DTiles\\         &lt;-- Cesium 3D Tiles 输出目录\n       tileset.json\n       ...\n</code></pre>\n<h3 id=\"34-日志\">3.4 日志</h3>\n<p>脚本运行过程中，简要信息会显示在屏幕上。<br />\n详细的带时间戳的日志会保存在脚本同级目录下的 <code>cc_sequential.log</code> 文件中。</p>\n<h3 id=\"35-具体代码实现\">3.5 具体代码实现</h3>\n<pre><code class=\"language-python\">\"\"\"\nContextCapture 顺序多格式生产脚本\n支持 OBJ、LAS 点云、Cesium 3D Tiles 三种格式\n使用分块处理 (Tiling) 控制内存\n顺序执行避免内存不足\n\"\"\"\nimport sys\nimport time\nimport os\nimport logging\nfrom logging.handlers import RotatingFileHandler\nimport traceback\nimport argparse\n\n# --- 日志配置 ---\n# 日志文件名为 cc_sequential.log，位于脚本所在目录\nlog_file_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'cc_sequential.log')\n\nlogger = logging.getLogger('CC_Production')\nlogger.setLevel(logging.INFO)\n\n# 1. RotatingFileHandler: 10MB 切割，保留 5 个备份\n# maxBytes = 10 * 1024 * 1024 = 10485760 B\nrf_handler = RotatingFileHandler(log_file_path, maxBytes=10 * 1024 * 1024, backupCount=5, encoding='utf-8')\nfile_formatter = logging.Formatter('%(asctime)s [%(levelname)s] %(message)s')\nrf_handler.setFormatter(file_formatter)\nlogger.addHandler(rf_handler)\n\n# 2. StreamHandler: 输出到控制台\nconsole_handler = logging.StreamHandler(sys.stdout)\nconsole_handler.setFormatter(logging.Formatter('%(message)s'))  # 控制台输出保持原样，纯文本方便阅读\nlogger.addHandler(console_handler)\n# ----------------\n\ntry:\n    import ccmasterkernel\n\n    logger.info(\"成功导入 ccmasterkernel 模块\")\nexcept ImportError:\n    logger.error(\"错误: 无法导入 ccmasterkernel 模块。\")\n    sys.exit(1)\n\n\ndef parse_args():\n    parser = argparse.ArgumentParser(description=\"ContextCapture 顺序多格式生产脚本\")\n\n    # 路径参数 (必须)\n    parser.add_argument('--photos', required=True, help='照片所在目录路径')\n    parser.add_argument('--project', required=True, help='项目输出目录路径')\n\n    # 可选参数\n    parser.add_argument('--memory', type=float, default=16.0, help='目标内存使用量 (GB)，默认 16.0')\n    parser.add_argument('--formats', nargs='+', default=['OBJ', 'LAS', '3DTiles'],\n                        choices=['OBJ', 'LAS', '3DTiles'],\n                        help='指定要生产的格式 (默认全部): OBJ, LAS, 3DTiles')\n\n    return parser.parse_args()\n\n\ndef main():\n    args = parse_args()\n\n    # 定义路径变量 (从 args 获取)\n    project_dir = args.project\n    # 自动根据目录名生成项目文件名\n    project_name_base = os.path.basename(os.path.normpath(project_dir))\n    project_file_path = os.path.join(project_dir, f\"{project_name_base}.ccm\")\n    photos_dir = args.photos\n\n    # 多格式输出目录\n    production_obj_dir = os.path.join(project_dir, \"Production_OBJ\")\n    production_las_dir = os.path.join(project_dir, \"Production_LAS\")\n    production_3dtiles_dir = os.path.join(project_dir, \"Production_3DTiles\")\n\n    logger.info(\"\\n\" + \"=\" * 60)\n    logger.info(\"ContextCapture 顺序多格式自动化脚本 (CLI Mode)\")\n    logger.info(\"=\" * 60)\n    logger.info(f\"项目文件路径: {project_file_path}\")\n    logger.info(f\"照片目录:     {photos_dir}\")\n    logger.info(f\"目标内存:     {args.memory} GB\")\n\n    # 确定要生产的格式\n    formats_to_produce_list = []\n\n    # 格式定义映射: Name -&gt; (DriverName, OutputDir, Description)\n    format_map = {\n        'OBJ': (\"OBJ\", production_obj_dir, \"OBJ 网格模型\"),\n        'LAS': (\"LAS\", production_las_dir, \"LAS 点云\"),\n        '3DTiles': (\"Cesium 3D Tiles\", production_3dtiles_dir, \"Cesium 3D Tiles\")\n    }\n\n    req_formats = args.formats\n\n    logger.info(f\"计划生产格式: {', '.join(req_formats)}\")\n\n    # 构建 production list\n    # 保持原有顺序: OBJ -&gt; LAS -&gt; 3DTiles (如果被选中)\n    if 'OBJ' in req_formats:\n        formats_to_produce_list.append(('OBJ', *format_map['OBJ']))\n    if 'LAS' in req_formats:\n        formats_to_produce_list.append(('LAS', *format_map['LAS']))\n    if '3DTiles' in req_formats:\n        formats_to_produce_list.append(('Cesium 3D Tiles', *format_map['3DTiles']))\n\n    logger.info(\"\\n输出位置预览:\")\n    for _, _, out_dir, desc in formats_to_produce_list:\n        logger.info(f\"  - {desc}: {out_dir}\")\n\n    logger.info(\"\\n注意: 选中格式将依次执行，避免内存不足\")\n    logger.info(\"=\" * 60 + \"\\n\")\n\n    # 确保项目目录存在\n    if not os.path.exists(project_dir):\n        try:\n            os.makedirs(project_dir)\n        except OSError as e:\n            logger.error(f\"错误: 无法创建项目目录 {project_dir}: {e}\")\n            return\n\n    # 1. 创建并配置项目\n    logger.info(\"正在创建项目...\")\n    project = ccmasterkernel.Project()\n    project.setName(project_name_base)  # 使用目录名作为项目名\n    project.setProjectFilePath(project_file_path)\n\n    # 2. 创建区块并添加照片\n    logger.info(\"正在创建初始区块...\")\n    block = ccmasterkernel.Block(project)\n    project.addBlock(block)\n    block.setName(\"InitialBlock\")\n\n    logger.info(\"正在添加照片...\")\n    photogroups = block.getPhotogroups()\n\n    if os.path.exists(photos_dir):\n        photo_files = [f for f in os.listdir(photos_dir)\n                       if f.lower().endswith(('.jpg', '.jpeg', '.tif', '.tiff', '.png'))]\n        if not photo_files:\n            logger.warning(f\"警告: 在 {photos_dir} 中未找到照片文件。\")\n\n        for f in photo_files:\n            full_path = os.path.join(photos_dir, f)\n            photogroups.addPhotoInAutoMode(full_path)\n        logger.info(f\"已尝试添加 {len(photo_files)} 张照片。\")\n    else:\n        logger.error(f\"错误: 照片目录 {photos_dir} 不存在。\")\n        return\n\n    # 验证区块是否有效\n    if not block.isReadyForAT():\n        logger.error(\"错误: 区块未准备好进行 AT。\")\n        return\n\n    # 保存项目\n    logger.info(\"正在保存项目...\")\n    save_error = project.writeToFile()\n    if not save_error.isNone():\n        logger.error(f\"保存项目失败: {save_error.message}\")\n        return\n    logger.info(\"项目保存成功。\")\n\n    # 3. 空中三角测量 (AT)\n    logger.info(\"\\n准备空中三角测量 (AT) 区块...\")\n    block_at = ccmasterkernel.Block(project)\n    project.addBlock(block_at)\n    block_at.setName(\"AT_Block\")\n    block_at.setBlockTemplate(ccmasterkernel.BlockTemplate.Template_adjusted, block)\n\n    # 保存更新后的项目\n    logger.info(\"正在保存更新后的项目...\")\n    save_error = project.writeToFile()\n    if not save_error.isNone():\n        logger.error(f\"保存项目失败: {save_error.message}\")\n        return\n\n    logger.info(\"开始提交 AT 处理...\")\n    at = block_at.getAT()\n    if at is None:\n        logger.error(\"错误: 无法获取 AT 对象。\")\n        return\n\n    # 提交 AT 处理\n    submit_error = at.submitProcessing()\n    if not submit_error.isNone():\n        logger.error(f\"AT 提交失败: {submit_error.message}\")\n        return\n\n    # 监控 AT 任务\n    if not monitor_job(at, \"AT\"):\n        logger.error(\"AT 处理未成功完成，脚本终止。\")\n        return\n\n    logger.info(\"AT 处理完成。\\n\")\n\n    # 4. 重建 (Reconstruction) - 配置分块处理\n    logger.info(\"=\" * 60)\n    logger.info(\"创建重建项目...\")\n    logger.info(\"=\" * 60)\n\n    reconstruction = ccmasterkernel.Reconstruction(block_at)\n    block_at.addReconstruction(reconstruction)\n    reconstruction.setName(\"Reconstruction_Sequential\")\n\n    # 配置重建设置\n    logger.info(\"\\n配置重建设置...\")\n    settings = reconstruction.getSettings()\n    reconstruction.setSettings(settings)\n\n    # 配置分块处理 (Tiling)\n    logger.info(\"配置分块处理 (Tiling)...\")\n    tiling = reconstruction.getTiling()\n    tiling.tilingMode = ccmasterkernel.TilingMode.TilingMode_adaptive\n    tiling.targetMemoryUse = args.memory  # 使用命令行参数\n    tiling.overlapRatio = 0.2\n    tiling.discardEmptyTiles = True\n    reconstruction.setTiling(tiling)\n\n    logger.info(f\"  - 模式: Adaptive (自动分块)\")\n    logger.info(f\"  - 目标内存: {tiling.targetMemoryUse} GB\")\n    logger.info(f\"  - 瓦片重叠率: {tiling.overlapRatio * 100}%\")\n\n    # 保存重建配置\n    logger.info(\"\\n保存重建配置...\")\n    save_error = project.writeToFile()\n    if not save_error.isNone():\n        logger.error(f\"保存项目失败: {save_error.message}\")\n        return\n\n    # 获取瓦片数量\n    num_tiles = reconstruction.getNumInternalTiles()\n    logger.info(f\"\\n重建包含 {num_tiles} 个瓦片\")\n\n    # 5. 顺序生产 - 依次执行每种格式\n    logger.info(\"\\n\" + \"=\" * 60)\n    logger.info(\"开始顺序生产（依次执行，避免内存不足）\")\n    logger.info(\"=\" * 60)\n\n    results = []\n\n    # 遍历我们构建的格式列表\n    for idx, (prod_name, driver_name, output_dir, description) in enumerate(formats_to_produce_list, 1):\n        logger.info(\"\\n\" + \"=\" * 60)\n        logger.info(f\"第 {idx}/{len(formats_to_produce_list)} 步: 生产 {description}\")\n        logger.info(\"=\" * 60)\n\n        # 创建生产\n        logger.info(f\"\\n配置 {description}...\")\n        production = ccmasterkernel.Production(reconstruction)\n        reconstruction.addProduction(production)\n        production.setName(f\"Production_{prod_name}\")\n        production.setDriverName(driver_name)\n        production.setDestination(output_dir)\n        logger.info(f\"  ✓ {description} 配置完成\")\n\n        # 保存项目\n        save_error = project.writeToFile()\n        if not save_error.isNone():\n            logger.error(f\"  ✗ 保存项目失败: {save_error.message}\")\n            results.append((description, False))\n            continue\n\n        # 添加所有瓦片任务\n        logger.info(f\"\\n为 {description} 添加 {num_tiles} 个瓦片任务...\")\n        production_jobs = []\n        try:\n            for i in range(num_tiles):\n                tile = reconstruction.getInternalTile(i)\n                job = ccmasterkernel.TileProductionJob(production, tile)\n                production.addProductionJob(job)\n                production_jobs.append(job)\n            logger.info(f\"  ✓ 已添加 {num_tiles} 个瓦片任务\")\n        except Exception as e:\n            logger.error(f\"  ✗ 添加任务时出错: {e}\")\n            results.append((description, False))\n            continue\n\n        # 提交生产\n        logger.info(f\"\\n提交 {description} 生产...\")\n        submit_error = production.submitProcessing()\n        if not submit_error.isNone():\n            logger.error(f\"  ✗ 提交失败: {submit_error.message}\")\n            results.append((description, False))\n            continue\n        logger.info(f\"  ✓ 提交成功\")\n\n        # 监控所有瓦片任务\n        logger.info(f\"\\n监控 {description} 任务（{num_tiles} 个瓦片）...\")\n        all_tiles_success = True\n        for tile_idx, job in enumerate(production_jobs):\n            job_desc = f\"{description} - 瓦片 {tile_idx}\"\n            if not monitor_job(job, job_desc):\n                logger.error(f\"  ✗ 瓦片 {tile_idx} 处理失败\")\n                all_tiles_success = False\n                break  # 如果一个瓦片失败，停止监控后续瓦片\n            else:\n                logger.info(f\"  ✓ 瓦片 {tile_idx} 处理成功\")\n\n        if all_tiles_success:\n            logger.info(f\"\\n✓ {description} 所有瓦片处理成功！\")\n            logger.info(f\"  输出位置: {output_dir}\")\n            results.append((description, True))\n        else:\n            logger.error(f\"\\n✗ {description} 处理失败\")\n            results.append((description, False))\n\n    # 最终结果汇总\n    logger.info(\"\\n\" + \"=\" * 60)\n    logger.info(\"生产结果汇总\")\n    logger.info(\"=\" * 60)\n\n    for description, success in results:\n        status = \"✓ 成功\" if success else \"✗ 失败\"\n        logger.info(f\"  {status}: {description}\")\n\n    all_success = all(success for _, success in results)\n\n    if all_success:\n        logger.info(\"\\n\" + \"=\" * 60)\n        logger.info(\"所有请求的格式生产成功完成！\")\n        logger.info(\"=\" * 60)\n    else:\n        logger.error(\"\\n部分格式生产失败，请检查日志获取详细信息。\")\n\n\ndef monitor_job(job_object, job_name):\n    \"\"\"\n    通用任务监控函数\n    \"\"\"\n    previous_status = ccmasterkernel.JobStatus.Job_unknown\n\n    while True:\n        # 更新状态\n        try:\n            job_object.updateJobStatus()\n        except AttributeError:\n            pass\n\n        status = job_object.getJobStatus()\n\n        # 显示状态变化\n        if status != previous_status:\n            status_str = ccmasterkernel.jobStatusAsString(status)\n            logger.info(f\"    [{job_name}] {status_str}\")\n            previous_status = status\n\n        # 检查是否结束\n        if status in [ccmasterkernel.JobStatus.Job_completed,\n                      ccmasterkernel.JobStatus.Job_failed,\n                      ccmasterkernel.JobStatus.Job_cancelled]:\n            break\n\n        time.sleep(2)\n\n    # 最终结果检查\n    if status == ccmasterkernel.JobStatus.Job_completed:\n        return True\n    else:\n        msg = job_object.getJobMessage()\n        if msg:\n            logger.error(f\"    [{job_name}] 错误: {msg}\")\n        return False\n\n\nif __name__ == \"__main__\":\n    try:\n        main()\n    except KeyboardInterrupt:\n        logger.info(\"\\n\\n用户中断脚本执行。\")\n    except Exception as e:\n        logger.error(f\"\\n错误: {e}\")\n        logger.error(\"详细堆栈:\", exc_info=True)\n\n\n</code></pre>\n<p><strong>github仓库地址</strong>：<a href=\"https://github.com/Canon-create/contextcapture-python-example\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/Canon-create/contextcapture-python-example</a></p>\n<p><strong>参考文章</strong>：<a href=\"https://blog.csdn.net/qq_41475842/article/details/112959892\" rel=\"noopener nofollow\" target=\"_blank\">https://blog.csdn.net/qq_41475842/article/details/112959892</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-04 15:13</span>&nbsp;\n<a href=\"https://www.cnblogs.com/foury\">深紫色的三北六号</a>&nbsp;\n阅读(<span id=\"post_view_count\">36</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "10只老鼠试毒1000瓶水问题思考笔记",
      "link": "https://www.cnblogs.com/mysticbinary/p/19436756",
      "published": "",
      "description": "<div class=\"postTitle\">\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/mysticbinary/p/19436756\" id=\"cb_post_title_url\" title=\"发布于 2026-01-04 13:22\">\n    <span>10只老鼠试毒1000瓶水问题思考笔记</span>\n    \n\n</a>\n\n        </div>\n        <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">目录</div><ul><li><a href=\"#问题描述\" rel=\"noopener nofollow\">问题描述</a></li><li><a href=\"#原理图\" rel=\"noopener nofollow\">原理图</a></li><li><a href=\"#思想\" rel=\"noopener nofollow\">思想</a></li><li><a href=\"#比特世界和物理世界的差异\" rel=\"noopener nofollow\">比特世界和物理世界的差异</a></li></ul></div><p></p>\n<hr />\n<h1 id=\"问题描述\">问题描述</h1>\n<p>1000瓶水里有一瓶有毒，可以使用10只老鼠去尝毒，当老鼠喝下毒水1个小时后死去，请设计一种方案，能够在1小时找到这瓶毒药。</p>\n<hr />\n<h1 id=\"原理图\">原理图</h1>\n<p>如果从二进制编码位的视角来解决这个问题则很简单：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1552062/202601/1552062-20260104132050245-398290625.png\" /></p>\n<ul>\n<li>\n<p>给瓶子和老鼠编号：将1000瓶水编号为0到999。给10只老鼠从左到右（或从右到左）编号0到9。</p>\n<ul>\n<li>用二进制表示：将瓶子编号转换为10位二进制数（例如，瓶子1是0000000001，瓶子1000是1111101000）。</li>\n</ul>\n</li>\n<li>\n<p>如果瓶子编号的第1位是1（从右往左数），则将该瓶水混入给第1只老鼠喝的混合液中。</p>\n</li>\n<li>\n<p>如果1个小时候后，哪个位的老鼠死去，记录哪个老鼠的位。<br />\n图片假设365有毒，则老鼠0号、老鼠2号、老鼠3号、老鼠0号、老鼠5号、老鼠6号、老鼠8号死去标记为1，其余位标记0 ，转10进制=365。</p>\n</li>\n</ul>\n<hr />\n<h1 id=\"思想\">思想</h1>\n<p>这个问题看似是一个逻辑谜题，但实际上体现了信息编码的核心思想：<strong>用最少的“检测位”区分最多的可能性。</strong></p>\n<p>这种思维在现代计算机科学、通信技术和信息论中无处不在。<br />\n从硬盘的纠错编码到网络传输的数据校验，从条形码到二维码，二进制编码的思想贯穿了我们的数字世界。</p>\n<hr />\n<p>解决这个问题的关键在于二进制编号。我们将 1000 瓶药水编号为 0-999。<br />\n用二进制表示这些编号时，1000 ≤ 1024 = 2¹⁰，这意味着我们需要 10 位二进制数就可以表示所有瓶子。<br />\n每只老鼠对应二进制编码中的一位。10 位二进制，正好对应 10 只老鼠。<br />\n<strong>这种方法能够一次性测试所有瓶子，而不是传统的逐瓶测试。</strong> 效率提升很大。</p>\n<hr />\n<h1 id=\"比特世界和物理世界的差异\">比特世界和物理世界的差异</h1>\n<p>这套二进制编码方案在理论编程和逻辑谜题中是成立的，但在实际毒理学检测或现实场景中，往往需要结合剂量反应曲线、分组测试或现代分析化学方法（如色谱、质谱）更可靠地识别毒物。</p>\n<p>毕竟你把一瓶水分10份了，稀释之后效果怎么样？都是未知数了。╮(╯▽╰)╭<br />\n还有，怎么可能一只老鼠能喝几百份水呀.....</p>\n\n</div>\n<div class=\"clear\"></div>\n\n        <div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-01-04 13:22</span>&nbsp;\n<a href=\"https://www.cnblogs.com/mysticbinary\">Mysticbinary</a>&nbsp;\n阅读(<span id=\"post_view_count\">305</span>)&nbsp;\n评论(<span id=\"post_comment_count\">4</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MQ如何保证消息不丢失？",
      "link": "https://www.cnblogs.com/12lisu/p/19437091",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/12lisu/p/19437091\" id=\"cb_post_title_url\" title=\"发布于 2026-01-04 12:21\">\n    <span>MQ如何保证消息不丢失？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>今天我们来聊聊一个让很多开发者头疼的话题——MQ消息丢失问题。</p>\n<p>有些小伙伴在工作中，一提到消息队列就觉得很简单，但真正遇到线上消息丢失时，排查起来却让人抓狂。</p>\n<p>其实，我在实际工作中，也遇到过MQ消息丢失的情况。</p>\n<p>今天这篇文章，专门跟大家一起聊聊这个话题，希望对你会有所帮助。</p>\n<h2 id=\"一消息丢失的三大环节\">一、消息丢失的三大环节</h2>\n<p>在深入解决方案之前，我们先搞清楚消息在哪几个环节可能丢失：</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h3 id=\"1-生产者发送阶段\">1. 生产者发送阶段</h3>\n<ul>\n<li>网络抖动导致发送失败</li>\n<li>生产者宕机未发送</li>\n<li>Broker处理失败未返回确认</li>\n</ul>\n<h3 id=\"2-broker存储阶段\">2. Broker存储阶段</h3>\n<ul>\n<li>内存消息未持久化，重启丢失</li>\n<li>磁盘故障导致数据丢失</li>\n<li>集群切换时消息丢失</li>\n</ul>\n<h3 id=\"3-消费者处理阶段\">3. 消费者处理阶段</h3>\n<ul>\n<li>自动确认模式下处理异常</li>\n<li>消费者宕机处理中断</li>\n<li>手动确认但忘记确认</li>\n</ul>\n<p>理解了问题根源，接下来我们看5种实用的解决方案。</p>\n<h2 id=\"二方案一生产者确认机制\">二、方案一：生产者确认机制</h2>\n<h3 id=\"核心原理\">核心原理</h3>\n<p>生产者发送消息后等待Broker确认，确保消息成功到达。</p>\n<p>这是防止消息丢失的第一道防线。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h3 id=\"关键实现\">关键实现</h3>\n<pre><code class=\"language-java\">// RabbitMQ生产者确认配置\n@Bean\npublic RabbitTemplate rabbitTemplate() {\n    RabbitTemplate template = new RabbitTemplate(connectionFactory);\n    template.setConfirmCallback((correlationData, ack, cause) -&gt; {\n        if (ack) {\n            // 消息成功到达Broker\n            messageStatusService.markConfirmed(correlationData.getId());\n        } else {\n            // 发送失败，触发重试\n            retryService.scheduleRetry(correlationData.getId());\n        }\n    });\n    return template;\n}\n\n// 可靠发送方法\npublic void sendReliable(String exchange, String routingKey, Object message) {\n    String messageId = generateId();\n    // 先落库保存发送状态\n    messageStatusService.saveSendingStatus(messageId, message);\n    \n    // 发送持久化消息\n    rabbitTemplate.convertAndSend(exchange, routingKey, message, msg -&gt; {\n        msg.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);\n        msg.getMessageProperties().setMessageId(messageId);\n        return msg;\n    }, new CorrelationData(messageId));\n}\n</code></pre>\n<h3 id=\"适用场景\">适用场景</h3>\n<ul>\n<li>对消息可靠性要求高的业务</li>\n<li>金融交易、订单处理等关键业务</li>\n<li>需要精确知道消息发送结果的场景</li>\n</ul>\n<h2 id=\"三方案二消息持久化机制\">三、方案二：消息持久化机制</h2>\n<h3 id=\"核心原理-1\">核心原理</h3>\n<p>将消息保存到磁盘，确保Broker重启后消息不丢失。</p>\n<p>这是防止Broker端消息丢失的关键。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h3 id=\"关键实现-1\">关键实现</h3>\n<pre><code class=\"language-java\">// 持久化队列配置\n@Bean\npublic Queue orderQueue() {\n    return QueueBuilder.durable(\"order.queue\")  // 队列持久化\n            .deadLetterExchange(\"order.dlx\")    // 死信交换机\n            .build();\n}\n\n// 发送持久化消息\npublic void sendPersistentMessage(Object message) {\n    rabbitTemplate.convertAndSend(\"order.exchange\", \"order.create\", message, msg -&gt; {\n        msg.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT); // 消息持久化\n        return msg;\n    });\n}\n\n// Kafka持久化配置\n@Bean\npublic ProducerFactory&lt;String, Object&gt; producerFactory() {\n    Map&lt;String, Object&gt; props = new HashMap&lt;&gt;();\n    props.put(ProducerConfig.ACKS_CONFIG, \"all\"); // 所有副本确认\n    props.put(ProducerConfig.RETRIES_CONFIG, 3);   // 重试次数\n    props.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true); // 幂等性\n    return new DefaultKafkaProducerFactory&lt;&gt;(props);\n}\n</code></pre>\n<h3 id=\"优缺点\">优缺点</h3>\n<p><strong>优点：</strong></p>\n<ul>\n<li>有效防止Broker重启导致的消息丢失</li>\n<li>配置简单，效果明显</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>磁盘IO影响性能</li>\n<li>需要足够的磁盘空间</li>\n</ul>\n<h2 id=\"四方案三消费者确认机制\">四、方案三：消费者确认机制</h2>\n<h3 id=\"核心原理-2\">核心原理</h3>\n<p>消费者处理完消息后手动向Broker发送确认，Broker收到确认后才删除消息。</p>\n<p>这是保证消息不丢失的最后一道防线。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h3 id=\"关键实现-2\">关键实现</h3>\n<pre><code class=\"language-java\">// 手动确认消费者\n@RabbitListener(queues = \"order.queue\")\npublic void handleMessage(Order order, Message message, Channel channel) {\n    long deliveryTag = message.getMessageProperties().getDeliveryTag();\n    \n    try {\n        // 业务处理\n        orderService.processOrder(order);\n        \n        // 手动确认\n        channel.basicAck(deliveryTag, false);\n        log.info(\"消息处理完成: {}\", order.getOrderId());\n        \n    } catch (Exception e) {\n        log.error(\"消息处理失败: {}\", order.getOrderId(), e);\n        \n        // 处理失败，重新入队\n        channel.basicNack(deliveryTag, false, true);\n    }\n}\n\n// 消费者容器配置\n@Bean\npublic SimpleRabbitListenerContainerFactory containerFactory() {\n    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();\n    factory.setAcknowledgeMode(AcknowledgeMode.MANUAL); // 手动确认\n    factory.setPrefetchCount(10); // 预取数量\n    factory.setConcurrentConsumers(3); // 并发消费者\n    return factory;\n}\n</code></pre>\n<h3 id=\"注意事项\">注意事项</h3>\n<ul>\n<li>确保业务处理完成后再确认</li>\n<li>合理设置预取数量，避免内存溢出</li>\n<li>处理异常时要正确使用NACK</li>\n</ul>\n<h2 id=\"五方案四事务消息机制\">五、方案四：事务消息机制</h2>\n<h3 id=\"核心原理-3\">核心原理</h3>\n<p>通过事务保证本地业务操作和消息发送的原子性，要么都成功，要么都失败。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h3 id=\"关键实现-3\">关键实现</h3>\n<pre><code class=\"language-java\">// 本地事务表方案\n@Transactional\npublic void createOrder(Order order) {\n    // 1. 保存订单到数据库\n    orderRepository.save(order);\n    \n    // 2. 保存消息到本地消息表\n    LocalMessage localMessage = new LocalMessage();\n    localMessage.setBusinessId(order.getOrderId());\n    localMessage.setContent(JSON.toJSONString(order));\n    localMessage.setStatus(MessageStatus.PENDING);\n    localMessageRepository.save(localMessage);\n    \n    // 3. 事务提交，本地业务和消息存储保持一致性\n}\n\n// 定时任务扫描并发送消息\n@Scheduled(fixedDelay = 5000)\npublic void sendPendingMessages() {\n    List&lt;LocalMessage&gt; pendingMessages = localMessageRepository.findByStatus(MessageStatus.PENDING);\n    \n    for (LocalMessage message : pendingMessages) {\n        try {\n            // 发送消息到MQ\n            rabbitTemplate.convertAndSend(\"order.exchange\", \"order.create\", message.getContent());\n            \n            // 更新消息状态为已发送\n            message.setStatus(MessageStatus.SENT);\n            localMessageRepository.save(message);\n            \n        } catch (Exception e) {\n            log.error(\"发送消息失败: {}\", message.getId(), e);\n        }\n    }\n}\n\n// RocketMQ事务消息\npublic void sendTransactionMessage(Order order) {\n    TransactionMQProducer producer = new TransactionMQProducer(\"order_producer\");\n    \n    // 发送事务消息\n    Message msg = new Message(\"order_topic\", \"create\", \n                             JSON.toJSONBytes(order));\n    \n    TransactionSendResult result = producer.sendMessageInTransaction(msg, null);\n    \n    if (result.getLocalTransactionState() == LocalTransactionState.COMMIT_MESSAGE) {\n        log.info(\"事务消息提交成功\");\n    }\n}\n</code></pre>\n<h3 id=\"适用场景-1\">适用场景</h3>\n<ul>\n<li>需要严格保证业务和消息一致性的场景</li>\n<li>分布式事务场景</li>\n<li>金融、电商等对数据一致性要求高的业务</li>\n</ul>\n<h2 id=\"六方案五消息重试与死信队列\">六、方案五：消息重试与死信队列</h2>\n<h3 id=\"核心原理-4\">核心原理</h3>\n<p>通过重试机制处理临时故障，通过死信队列处理最终无法消费的消息。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h3 id=\"关键实现-4\">关键实现</h3>\n<pre><code class=\"language-java\">// 重试队列配置\n@Bean\npublic Queue orderQueue() {\n    return QueueBuilder.durable(\"order.queue\")\n            .withArgument(\"x-dead-letter-exchange\", \"order.dlx\") // 死信交换机\n            .withArgument(\"x-dead-letter-routing-key\", \"order.dead\")\n            .withArgument(\"x-message-ttl\", 60000) // 60秒后进入死信\n            .build();\n}\n\n// 死信队列配置\n@Bean\npublic Queue orderDeadLetterQueue() {\n    return QueueBuilder.durable(\"order.dead.queue\").build();\n}\n\n// 消费者重试逻辑\n@RabbitListener(queues = \"order.queue\")\npublic void handleMessageWithRetry(Order order, Message message, Channel channel) {\n    long deliveryTag = message.getMessageProperties().getDeliveryTag();\n    \n    try {\n        orderService.processOrder(order);\n        channel.basicAck(deliveryTag, false);\n        \n    } catch (TemporaryException e) {\n        // 临时异常，重新入队重试\n        channel.basicNack(deliveryTag, false, true);\n        \n    } catch (PermanentException e) {\n        // 永久异常，直接确认进入死信队列\n        channel.basicAck(deliveryTag, false);\n        log.error(\"消息进入死信队列: {}\", order.getOrderId(), e);\n    }\n}\n\n// 死信队列消费者\n@RabbitListener(queues = \"order.dead.queue\")\npublic void handleDeadLetterMessage(Order order) {\n    log.warn(\"处理死信消息: {}\", order.getOrderId());\n    // 发送告警、记录日志、人工处理等\n    alertService.sendAlert(\"死信消息告警\", order.toString());\n}\n</code></pre>\n<h3 id=\"重试策略建议\">重试策略建议</h3>\n<ol>\n<li><strong>指数退避</strong>：1s, 5s, 15s, 30s</li>\n<li><strong>最大重试次数</strong>：3-5次</li>\n<li><strong>死信处理</strong>：人工介入或特殊处理流程</li>\n</ol>\n<h2 id=\"七方案对比与选型指南\">七、方案对比与选型指南</h2>\n<p>为了帮助大家选择合适的方案，我整理了详细的对比表：</p>\n<table>\n<thead>\n<tr>\n<th>方案</th>\n<th>可靠性</th>\n<th>性能影响</th>\n<th>复杂度</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>生产者确认</td>\n<td>高</td>\n<td>中</td>\n<td>低</td>\n<td>所有需要可靠发送的场景</td>\n</tr>\n<tr>\n<td>消息持久化</td>\n<td>中</td>\n<td>中</td>\n<td>低</td>\n<td>Broker重启保护</td>\n</tr>\n<tr>\n<td>消费者确认</td>\n<td>高</td>\n<td>低</td>\n<td>中</td>\n<td>确保消息被成功处理</td>\n</tr>\n<tr>\n<td>事务消息</td>\n<td>最高</td>\n<td>高</td>\n<td>高</td>\n<td>强一致性要求的业务</td>\n</tr>\n<tr>\n<td>重试+死信</td>\n<td>高</td>\n<td>低</td>\n<td>中</td>\n<td>处理临时故障和最终死信</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"选型建议\">选型建议</h3>\n<p><strong>初创项目/简单业务：</strong></p>\n<ul>\n<li>生产者确认 + 消息持久化 + 消费者确认</li>\n<li>满足大部分场景，实现简单</li>\n</ul>\n<p><strong>电商/交易系统：</strong></p>\n<ul>\n<li>生产者确认 + 事务消息 + 重试机制</li>\n<li>保证数据一致性，处理复杂业务</li>\n</ul>\n<p><strong>大数据/日志处理：</strong></p>\n<ul>\n<li>消息持久化 + 消费者确认</li>\n<li>允许少量丢失，追求吞吐量</li>\n</ul>\n<p><strong>金融/支付系统：</strong></p>\n<ul>\n<li>全方案组合使用</li>\n<li>最高可靠性要求</li>\n</ul>\n<h2 id=\"总结\">总结</h2>\n<p>消息丢失问题是消息队列使用中的常见挑战，通过今天介绍的5种方案，我们可以构建一个可靠的消息系统：</p>\n<ol>\n<li><strong>生产者确认机制</strong> - 保证消息成功发送到Broker</li>\n<li><strong>消息持久化机制</strong> - 防止Broker重启导致消息丢失</li>\n<li><strong>消费者确认机制</strong> - 确保消息被成功处理</li>\n<li><strong>事务消息机制</strong> - 保证业务和消息的一致性</li>\n<li><strong>重试与死信队列</strong> - 处理异常情况和最终死信</li>\n</ol>\n<p>有些小伙伴可能会问：\"我需要全部使用这些方案吗？</p>\n<p>\"我的建议是：<strong>根据业务需求选择合适的组合</strong>。</p>\n<p>对于关键业务，建议至少使用前三种方案；对于普通业务，可以根据实际情况适当简化。</p>\n<p>记住，没有完美的方案，只有最适合的方案。</p>\n<h2 id=\"最后说一句求关注别白嫖我\">最后说一句(求关注，别白嫖我)</h2>\n<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>\n<p>求一键三连：点赞、转发、在看。</p>\n<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>\n<p>更多项目实战在我的技术网站：<a href=\"http://www.susan.net.cn/project\" rel=\"noopener nofollow\" target=\"_blank\">http://www.susan.net.cn/project</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-04 12:21</span>&nbsp;\n<a href=\"https://www.cnblogs.com/12lisu\">苏三说技术</a>&nbsp;\n阅读(<span id=\"post_view_count\">225</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "场论笔记（三）矢量分析基础",
      "link": "https://www.cnblogs.com/GeophysicsWorker/p/19436590",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/GeophysicsWorker/p/19436590\" id=\"cb_post_title_url\" title=\"发布于 2026-01-04 11:10\">\n    <span>场论笔记（三）矢量分析基础</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        矢量函数分析基础：矢量分析是矢量代数的继续，是场论的基础知识，同时也是弹性波动力学等其他学科的有用工具。其本笔记主要内容是介绍矢性函数，矢端曲线及其微分，积分计算及其性质。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"场论笔记三矢量分析基础\">场论笔记（三）矢量分析基础</h1>\n<p>​       矢量分析是矢量代数的继续，是场论的基础知识，同时也是弹性波动力学等其他学科的有用工具。其本笔记主要内容是介绍矢性函数，矢端曲线及其微分，积分计算及其性质。</p>\n<h2 id=\"11矢性函数\">1.1矢性函数</h2>\n<p>​       在矢量代数中，曾经学过矢量的模长和方向都保持不变的矢量，这种矢量称为常矢(注意：零矢量的方向为任意，可作为一种特殊的常矢量)；然而，在许多科学，技术问题中，我们常常遇到模长和方向或其中之一会改变的矢量，这种矢量称为变矢。</p>\n<p>​     <strong>Definition 1.1</strong> 设有数性变量<span class=\"math inline\">\\(t\\)</span>和变矢量<span class=\"math inline\">\\(\\mathbf{A}\\)</span>，如果对于<span class=\"math inline\">\\(t\\)</span>在某个范围<span class=\"math inline\">\\(G\\)</span>内的每一个数值，变矢量<span class=\"math inline\">\\(\\mathbf{A}\\)</span>都以一个确定的矢量和它对应，则称<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 为数性变量<span class=\"math inline\">\\(t\\)</span>的矢量函数，记作</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A}=\\mathbf{A}(t) \\tag{1.1.1}\n\\]</div><p></p><p>并称<span class=\"math inline\">\\(\\mathbf{G}\\)</span>为函数<span class=\"math inline\">\\(\\mathbf{A}\\)</span>的定义域。</p>\n<p>​      矢量函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>在<span class=\"math inline\">\\(Oxyz\\)</span>直角坐标系的三个坐标（即它的三个坐标系的投影），显然都是<span class=\"math inline\">\\(t\\)</span>的函数：</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A}(t)=[A_x(t),A_y(t),A_z(t)] \\tag{1.1.2}\n\\]</div><p></p><p>所以，矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>的坐标表达式为：</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A}=A_x(t)\\mathbf{i}+A_y(t)\\mathbf{j}+A_z(t)\\mathbf{k} \\tag{1.1.3}\n\\]</div><p></p><p>其中<span class=\"math inline\">\\(i,j,k\\)</span>为沿<span class=\"math inline\">\\(x,y,z\\)</span>三个坐标轴正向的单位矢量。可见，一个矢性函数和三个有序的数性函数（坐标）构成一一对应的关系。</p>\n<h2 id=\"12矢端曲线\">1.2矢端曲线</h2>\n<p>​       本笔记所讲的矢量均指自由矢量，就是当两矢量的模长和方向相同时，就认为此二矢量是相等的。据此，为了能用图形来直观地表示矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>的变化状态，我们就可以把<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>的起点取在坐标原点。这样，当<span class=\"math inline\">\\(t\\)</span> 变化时，矢量<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span> 的终点<span class=\"math inline\">\\(\\mathbf{M}\\)</span>就描绘出一条曲线<span class=\"math inline\">\\(l\\)</span>; 这条曲线叫做矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>的矢端曲线，亦叫做矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>的图形。</p>\n<p>​      由矢量代数知道：起点在坐标原点<span class=\"math inline\">\\(\\mathbf{O}\\)</span>，终点为<span class=\"math inline\">\\(\\mathbf{M}(x,y,z)\\)</span>的矢量<span class=\"math inline\">\\(OM\\)</span>叫做点<span class=\"math inline\">\\(M\\)</span>(对于<span class=\"math inline\">\\(O\\)</span>点)的矢径，常用<span class=\"math inline\">\\(\\mathbf{r}\\)</span>表示：</p>\n<p></p><div class=\"math display\">\\[\\mathbf{r}=OM=x\\mathbf{i}+y\\mathbf{j}+z\\mathbf{k} \\tag{1.2.1}\n\\]</div><p></p><p>当我们把矢量函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span> 的起点取在坐标原点时，<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>实际上就成为其终点<span class=\"math inline\">\\(M(x,y,z)\\)</span>的矢径。因此，<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>的三个坐标<span class=\"math inline\">\\(A_x(t),A_y(t),A_z(t)\\)</span>就对应地等于其终点<span class=\"math inline\">\\(M\\)</span>的三个坐标<span class=\"math inline\">\\(x_{M},y_{M},z_{M}\\)</span>，即有</p>\n<p></p><div class=\"math display\">\\[\\begin{cases}\nx_{M}&amp;=A_x(t)\\\\\ny_{M}&amp;=A_y(t)\\\\\nz_{M}&amp;=A_z(t)\\\\\n\\end{cases}\n\\tag{1.2.2}\n\\]</div><p></p><p>式(1.1.2)就是矢端曲线<span class=\"math inline\">\\(l\\)</span>的以<span class=\"math inline\">\\(t\\)</span>为参数的参数方程。容易看出，曲线<span class=\"math inline\">\\(l\\)</span>的矢量方程式(1.3)和参数方程式(1.5)之间一一对应关系，只要知道其中的一个，就可以立刻写出另一个。</p>\n<h2 id=\"13矢性函数的极限和连续性\">1.3矢性函数的极限和连续性</h2>\n<p>​       和数性函数一样，矢性函数的极限和连续性，是矢性函数的微分与积分的基础概念。兹分述如下：</p>\n<p>​        <strong>Definition 1.2 矢性函数极限的定义：</strong> 设矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>在点<span class=\"math inline\">\\(t_0\\)</span>的某个领域内有定义（但在<span class=\"math inline\">\\(t_0\\)</span>处可以没有定义），<span class=\"math inline\">\\(\\mathbf{A_{0}}\\)</span>为一常矢。若对于任意给定的正数<span class=\"math inline\">\\(\\varepsilon\\)</span>, 都存在一个正数<span class=\"math inline\">\\(\\delta\\)</span>，使得当<span class=\"math inline\">\\(t\\)</span>满足<span class=\"math inline\">\\(0&lt;|t-t_0|&lt;\\delta\\)</span>时，就有</p>\n<p></p><div class=\"math display\">\\[|\\mathbf{A}(t)-\\mathbf{A_{0}}|&lt;\\varepsilon \\tag{1.3.1}\n\\]</div><p></p><p>成立，则称<span class=\"math inline\">\\(\\mathbf{A}_{0}\\)</span>为矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>当<span class=\"math inline\">\\(t\\rightarrow{t_0}\\)</span>时的极限，记作</p>\n<p></p><div class=\"math display\">\\[\\lim_{t\\rightarrow{t_0}}\\mathbf{A}(t)=\\mathbf{A_0} \\tag{1.3.2}\n\\]</div><p></p><p>这个定义与数性函数的极限的定义完全类似。因此，矢性函数也就有类似于数性函数中的一些极限运算法则。例如：</p>\n<p></p><div class=\"math display\">\\[\\lim_{t\\rightarrow{t_0}}u(t)\\mathbf{A}(t)=\\lim_{t\\rightarrow{t_0}}u(t)\\lim_{t\\rightarrow{t_0}}\\mathbf{A}(t) \\tag{1.3.3}\n\\]</div><p></p><p></p><div class=\"math display\">\\[\\lim_{t\\rightarrow{t_0}}[\\mathbf{A}(t)\\pm\\mathbf{B}(t)]=\\lim_{t\\rightarrow{t_0}}{\\mathbf{A}(t)}\\pm\\lim_{t\\rightarrow{t_0}}{\\mathbf{B}(t)} \\tag{1.3.4}\n\\]</div><p></p><p></p><div class=\"math display\">\\[\\lim_{t\\rightarrow{t_0}}[\\mathbf{A}(t)\\cdot\\mathbf{B}(t)]=\\lim_{t\\rightarrow{t_0}}\\mathbf{A}(t)\\lim_{t\\rightarrow{t_0}}\\mathbf{B}(t) \\tag{1.3.5}\n\\]</div><p></p><p></p><div class=\"math display\">\\[\\lim_{t\\rightarrow{t_0}}[\\mathbf{A}(t)\\times\\mathbf{B}(t)]=\\lim_{t\\rightarrow{t_0}}\\mathbf{A}(t)\\times\\lim_{t\\rightarrow{t_0}}{\\mathbf{B}}(t) \\tag{1.3.6}\n\\]</div><p></p><p>其中，<span class=\"math inline\">\\(u(t)\\)</span>为数性函数，<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>,<span class=\"math inline\">\\(\\mathbf{B}(t)\\)</span> 为矢性函数；且当<span class=\"math inline\">\\(t\\rightarrow{t_0}\\)</span> 时，<span class=\"math inline\">\\(u(t)\\)</span>,<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>,<span class=\"math inline\">\\(\\mathbf{B}(t)\\)</span> 均有极限存在。</p>\n<p>​       依此，根据式(1.3)有下式</p>\n<p></p><div class=\"math display\">\\[\\lim_{t\\rightarrow{t_0}}\\mathbf{A}(t)=\\lim_{t\\rightarrow{t_0}}A_x(t)\\mathcal{i}+\\lim_{t\\rightarrow{t_0}}A_y(t)\\mathcal{j}+\\lim_{t\\rightarrow{t_0}}A_z(t)\\mathcal{k} \\tag{1.3.7}\n\\]</div><p></p><p>此式把求矢性函数的极限，归结为求三个数性函数的极限。</p>\n<p>​       <strong>Definition 1.3 矢性函数连续性的定义：</strong>若矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>在点<span class=\"math inline\">\\(t_0\\)</span>的某个领域内有定义，而且有</p>\n<p></p><div class=\"math display\">\\[\\lim_{t\\rightarrow{t_0}}\\mathbf{A}(t)=\\mathbf{A}(t_0) \\tag{1.3.8}\n\\]</div><p></p><p>则称<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>在<span class=\"math inline\">\\(t=t_0\\)</span>处连续。</p>\n<p>​      容易看出:矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>在点<span class=\"math inline\">\\(t_0\\)</span>处连续的充要条件是它的三个坐标函数<span class=\"math inline\">\\(A_x(t)\\)</span>, <span class=\"math inline\">\\(A_y(t)\\)</span>, <span class=\"math inline\">\\(A_z(t)\\)</span> 都在<span class=\"math inline\">\\(t_0\\)</span> 处连续。</p>\n<p>​      若矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>在某个区间内的每一个点处都联系，则称它在该区间内连续。</p>\n<h2 id=\"14-矢性函数的导数与微分\">1.4 矢性函数的导数与微分</h2>\n<p>​         在上述小结中，我们初步定义了矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span> 及其几何意义矢端曲线，在此基础上，类似数性函数，在本节中从矢性函数的导数出发，给出矢性函数的微分及其性质。</p>\n<h3 id=\"141-矢性函数的导数\">1.4.1 矢性函数的导数</h3>\n<p>设有起点在<span class=\"math inline\">\\(O\\)</span>点的矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>，当数性变量<span class=\"math inline\">\\(t\\)</span>在其定义域内从<span class=\"math inline\">\\(t\\)</span>到<span class=\"math inline\">\\(t+\\Delta{t}(t\\neq0)\\)</span>时，对应的矢量分别为：</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A}(t)=OM \\tag{1.4.1}\n\\]</div><p></p><p></p><div class=\"math display\">\\[\\mathbf{A}(t+\\Delta{t})=ON \\tag{1.4.2}\n\\]</div><p></p><p>由此可定义矢性函数的增量，记作<span class=\"math inline\">\\(\\Delta{\\mathbf{A}}\\)</span>，则</p>\n<p></p><div class=\"math display\">\\[\\Delta{\\mathbf{A}}=\\mathbf{A}(t+\\Delta{t})-\\mathbf{A}(t)=MN \\tag{1.4.3}\n\\]</div><p></p><p>据此，就可以给出矢性函数的导数的定义。</p>\n<p><strong>Definition 1.4 矢性函数的导数：</strong>设矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>在点<span class=\"math inline\">\\(t\\)</span>的某一领域内有定义，并设<span class=\"math inline\">\\(t+\\Delta{t}\\)</span>也在这个领域内。若<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>对应于<span class=\"math inline\">\\(\\Delta{t}\\)</span>的增量<span class=\"math inline\">\\(\\Delta{\\mathbf{A}}\\)</span> 与<span class=\"math inline\">\\(\\Delta{t}\\)</span>的之比</p>\n<p></p><div class=\"math display\">\\[\\frac{d{\\mathbf{A}}}{d{t}}=\\frac{\\mathbf{A}(t+\\Delta{t})-\\mathbf{A}(t)}{\\Delta{t}} \\tag{1.4.4}\n\\]</div><p></p><p>在<span class=\"math inline\">\\(\\Delta{t}\\rightarrow{0}\\)</span>时，及其极限存在，则称此极限为矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>在点<span class=\"math inline\">\\(t\\)</span>处的导数（简称为导矢），记作 <span class=\"math inline\">\\(\\frac{d{\\mathbf{A}}}{d{t}}\\)</span> 或者 <span class=\"math inline\">\\(\\mathbf{A}^{'}(t)\\)</span>，即</p>\n<p></p><div class=\"math display\">\\[\\frac{d\\mathbf{A}(t)}{d{t}}=\\lim_{t\\rightarrow{t_0}}\\frac{\\Delta{\\mathbf{A}}}{\\Delta{t}}=\\lim_{t\\rightarrow{t_0}}\\frac{\\mathbf{A}(t+\\Delta{t})-\\mathbf{A}(t)}{\\Delta{t}} \\tag{1.4.5}\n\\]</div><p></p><p>若<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span> 由坐标性质给出：</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A}(t)=A_x(t)\\mathbf{i}+A_y(t)\\mathbf{j}+A_z(t)\\mathbf{k} \\tag{1.4.6}\n\\]</div><p></p><p>且函数<span class=\"math inline\">\\(A_x(t),A_y(t),A_z(t)\\)</span> 在点<span class=\"math inline\">\\(t\\)</span>可导，则有</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\n\\frac{d{\\mathbf{A}}}{d{t}}&amp;=\\lim_{\\Delta{t}\\rightarrow{0}}\\frac{\\Delta\\mathbf{A}}{\\Delta{t}}\\\\\n&amp;=\\lim_{\\Delta{t}\\rightarrow{0}}\\frac{\\Delta{A_x}}{\\Delta{t}}\\mathbf{i}+\\lim_{\\Delta{t}\\rightarrow{0}}\\frac{\\Delta{A_y}}{\\Delta{t}}\\mathbf{j}+\\lim_{\\Delta{t}\\rightarrow{0}}\\frac{\\Delta{A_z}}{\\Delta{t}}\\mathbf{k}\\\\\n&amp;=\\frac{d{A_x}}{d{t}}\\mathbf{i}+\\frac{d{A_y}}{dt}\\mathbf{j}+\\frac{d{A_z}}{d{z}}\\mathbf{k}\n\\end{aligned}\n\\tag{1.4.7}\n\\]</div><p></p><p>即</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A^{\\prime}}(t)=A_x^{\\prime}(t)\\mathbf{i}+A_y^{\\prime}(t)\\mathbf{j}+A_z^{\\prime}\\mathbf{k} \\tag{1.4.8}\n\\]</div><p></p><p>此式把求矢量函数的导数归结为求三个分量的数性函数的导数。</p>\n<h3 id=\"142-矢性函数的导数几何意义\">1.4.2 矢性函数的导数几何意义</h3>\n<p>​        如图，<span class=\"math inline\">\\(l\\)</span>为<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>矢端曲线，<span class=\"math inline\">\\(\\frac{\\Delta\\mathbf{A}}{\\Delta{t}}\\)</span> 是在<span class=\"math inline\">\\(l\\)</span>的割线<span class=\"math inline\">\\(MN\\)</span>上的一个矢量。当<span class=\"math inline\">\\(\\Delta{t}&gt;0\\)</span>时，其指向与<span class=\"math inline\">\\(\\Delta{A}\\)</span>一致，系指向对应<span class=\"math inline\">\\(t\\)</span>值增大的一方；当<span class=\"math inline\">\\(\\Delta{t}&lt;0\\)</span>时，其指向与<span class=\"math inline\">\\(\\Delta{\\mathbf{A}}\\)</span> 相反，但此时<span class=\"math inline\">\\(\\Delta{A}\\)</span>指向对应<span class=\"math inline\">\\(t\\)</span>值函数减小的一方，从而<span class=\"math inline\">\\(\\frac{\\Delta\\mathbf{A}}{\\Delta{t}}\\)</span> 依然指向对应<span class=\"math inline\">\\(t\\)</span>值增大的一方。</p>\n<p>​       在<span class=\"math inline\">\\(\\Delta{t}\\rightarrow{0}\\)</span> 时，由于割线<span class=\"math inline\">\\(MN\\)</span>绕点<span class=\"math inline\">\\(M\\)</span>转动，且以点<span class=\"math inline\">\\(M\\)</span>处的切线为其极限位置。此时，在割线上的矢量<span class=\"math inline\">\\(\\Delta{\\mathbf{A}}\\over{\\Delta{t}}\\)</span>的极限位置。此时，在割线上的矢量<span class=\"math inline\">\\(\\Delta{\\mathbf{A}}\\over{\\Delta{t}}\\)</span> 的极限位置，自然也就在此切线上，则也就是说，导矢</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A}^{\\prime}(t)=\\lim_{t\\rightarrow{0}}\\frac{\\Delta{\\mathbf{A}}}{\\Delta{t}} \\tag{1.4.9}\n\\]</div><p></p><p>当其不为零时，是在点<span class=\"math inline\">\\(M\\)</span>处的切线上，且由上述可知，其方向恒指向对应<span class=\"math inline\">\\(t\\)</span>值增大的方向。故导矢在几何上为一矢端曲线的切向矢量，指向对应<span class=\"math inline\">\\(t\\)</span>值增大的一方。</p>\n<h3 id=\"143-矢性函数的微分\">1.4.3 矢性函数的微分</h3>\n<p>（1）微分的概念与几何意义</p>\n<p>​        根据数性函数的微分的定义，设矢性函数<span class=\"math inline\">\\(\\mathbf{A}=\\mathbf{A^{\\prime}}(t)\\)</span>，我们把</p>\n<p></p><div class=\"math display\">\\[d\\mathbf{A}=\\mathbf{A^{\\prime}}(t)dt \\space  (dt=\\Delta{t}) \\tag{1.4.10}\n\\]</div><p></p><p>称为矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span> 在<span class=\"math inline\">\\(t\\)</span> 处的微分。</p>\n<p>​       由于微分<span class=\"math inline\">\\(d{\\mathbf{A}}\\)</span> 是导矢<span class=\"math inline\">\\(\\mathbf{A^{\\prime}}(t)\\)</span>与增量<span class=\"math inline\">\\(\\Delta{t}\\)</span> 的乘积，所以其是一个矢量，而且和导矢<span class=\"math inline\">\\(\\mathbf{A}^{\\prime}(t)\\)</span> 一样，也在点<span class=\"math inline\">\\(M\\)</span>处与<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span> 的矢端曲线<span class=\"math inline\">\\(l\\)</span> 相切，但其指向：当<span class=\"math inline\">\\(dt&gt;0\\)</span>时，与<span class=\"math inline\">\\(\\mathbf{A}^{\\prime}(t)\\)</span> 相切方向一致；而当<span class=\"math inline\">\\(dt&lt;0\\)</span>时，则与<span class=\"math inline\">\\(\\mathbf{A}^{\\prime}(t)\\)</span> 的方向相反。微分<span class=\"math inline\">\\(d{\\mathbf{A}}\\)</span> 的分量表达式如下：</p>\n<p></p><div class=\"math display\">\\[d{\\mathbf{A}}=A_x^{\\prime}(t)dt\\mathbf{i}+A_{y}^{\\prime}(t)dt\\mathbf{j}+A_z^{\\prime}(t)dt\\mathbf{k} \\tag{1.4.11}\n\\]</div><p></p><p>或</p>\n<p></p><div class=\"math display\">\\[d{\\mathbf{A}}=d{A_x}\\mathbf{i}+d{A_y}\\mathbf{j}+d{A_z}\\mathbf{k} \\tag{1.4.12}\n\\]</div><p></p><p>(2)   <span class=\"math inline\">\\(\\frac{d\\mathbf{r}}{ds}\\)</span> 的几何意义</p>\n<p>​       如果把矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)=A_x(t)\\mathbf{i}+A_y(t)\\mathbf{j}+A_z(t)\\mathbf{k}\\)</span> 看作其终点<span class=\"math inline\">\\(M(x,y,z)\\)</span> 的矢径函数：</p>\n<p></p><div class=\"math display\">\\[\\mathbf{r}=x\\mathbf{i}+y\\mathbf{j}+z\\mathbf{k} \\tag{1.4.13}\n\\]</div><p></p><p>这里<span class=\"math inline\">\\(x=A_x(t),y=A_y(t),z=A_z(t)\\)</span>，则上式可以写为如下的形式：</p>\n<p></p><div class=\"math display\">\\[|d{\\mathbf{r}}|=\\sqrt{dx^2+dy^2+dz^2} \\tag{1.4.14}\n\\]</div><p></p><p>通常都将矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>的矢端曲线<span class=\"math inline\">\\(l\\)</span>视为有向曲线，在无特别声明时，都是取<span class=\"math inline\">\\(t\\)</span> 值增加的一方为<span class=\"math inline\">\\(l\\)</span>之正向。若在<span class=\"math inline\">\\(l\\)</span>上取定一点<span class=\"math inline\">\\(M_0\\)</span> 作为计算弧长<span class=\"math inline\">\\(s\\)</span>的起点，并以<span class=\"math inline\">\\(l\\)</span>之正向（即<span class=\"math inline\">\\(t\\)</span>值增大的方向）作为<span class=\"math inline\">\\(s\\)</span>增大的方向，则在任一点<span class=\"math inline\">\\(M\\)</span>处，弧长的微分是</p>\n<p></p><div class=\"math display\">\\[ds=\\pm\\sqrt{dx^2+dy^2+dz^2} \\tag{1.4.15}\n\\]</div><p></p><p>按照下述办法取右端符号：以点<span class=\"math inline\">\\(M\\)</span>为界，当<span class=\"math inline\">\\(ds\\)</span>位于<span class=\"math inline\">\\(s\\)</span>增大一方时取正号；反之取负号。由此可见有：</p>\n<p></p><div class=\"math display\">\\[|d{\\mathbf{r}}|=|d{s}| \\tag{1.4.16}\n\\]</div><p></p><p>就是说，矢性函数的微分向量的模长等于（其矢端曲线的）弧长微分的绝对值，从而由</p>\n<p></p><div class=\"math display\">\\[|d{\\mathbf{r}}|=\\left|\\frac{d{\\mathbf{r}}}{ds}ds\\right|=\\left|\\frac{d{\\mathbf{r}}}{ds}\\right|\\cdot|ds| \\tag{1.4.17}\n\\]</div><p></p><p>有</p>\n<p></p><div class=\"math display\">\\[\\left|\\frac{d{\\mathbf{r}}}{ds}\\right|=\\frac{|d{\\mathbf{r}}|}{|ds|}=1 \\tag{1.4.18}\n\\]</div><p></p><p>结合导矢的几何意义，便知：矢<strong>性函数对（其矢端曲线的）弧长<span class=\"math inline\">\\(s\\)</span> 的导数<span class=\"math inline\">\\(\\frac{d{\\mathbf{r}}}{ds}\\)</span> 在几何上为切向单位向量，恒指向<span class=\"math inline\">\\(s\\)</span>增大的一方</strong>。</p>\n<p><strong>Equation 1.5.1</strong>  证明 <span class=\"math inline\">\\(\\frac{ds}{dt}=\\left|\\frac{d{\\mathbf{r}}}{dt}\\right|\\)</span></p>\n<p>证明：</p>\n<p></p><div class=\"math display\">\\[\\frac{d{\\mathbf{r}}}{dt}=\\frac{dx}{dt}\\mathbf{i}+\\frac{dy}{dt}\\mathbf{j}+\\frac{dz}{dt}\\mathbf{k} \\tag{1.4.19}\n\\]</div><p></p><p>由此可知，<span class=\"math inline\">\\(\\mathbf{r}\\)</span> 的矢性微分的模长：</p>\n<p></p><div class=\"math display\">\\[\\left|\\frac{d\\mathbf{r}}{dt}\\right|=\\sqrt{\\left(\\frac{dx}{dt}\\right)^2+\\left(\\frac{dy}{dt}\\right)^2+\\left(\\frac{dz}{dt}\\right)^2} \\tag{1.4.20}\n\\]</div><p></p><p>由此可知，<span class=\"math inline\">\\(ds\\)</span>与<span class=\"math inline\">\\(dt\\)</span> 具有相同的符号，固有</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\n\\frac{ds}{dt}&amp;=\\frac{\\pm\\sqrt{dx^2+dy^2+dz^2}}{\\pm\\sqrt{dt^2}}  \\\\\n&amp;=\\sqrt{\\left(\\frac{dx}{dt}\\right)^2+\\left(\\frac{dy}{dt}\\right)^2+\\left(\\frac{dz}{dt}\\right)^2}\\\\\n&amp;=\\left|\\frac{d\\mathbf{r}}{dt}\\right|\n\\end{aligned}\n\\tag{1.4.21}\n\\]</div><p></p><p>由此可知：<strong>矢端曲线的切向单位矢量，即</strong></p>\n<p></p><div class=\"math display\">\\[\\frac{d{\\mathbf{r}}}{d{s}}=\\frac{\\frac{d\\mathbf{r}}{d{t}}}{\\frac{ds}{dt}}=\\frac{d\\mathbf{r}}{dt}\\bigg/\\left|\\frac{d{\\mathbf{r}}}{dt}\\right| \\tag{1.4.19}\n\\]</div><p></p><h3 id=\"144-矢性函数的导数性质\">1.4.4 矢性函数的导数性质</h3>\n<p>设矢性函数<span class=\"math inline\">\\(\\mathbf{A}=\\mathbf{A}(t),\\mathbf{B}=\\mathbf{B}(t)\\)</span> 及数性函数 <span class=\"math inline\">\\(u=u(t)\\)</span> 在<span class=\"math inline\">\\(t\\)</span> 的某个范围内可导，则下列公式在该范围内成立</p>\n<ol>\n<li><span class=\"math inline\">\\(\\frac{d}{dt}{\\mathbf{C}}=\\mathbf{0}\\)</span> (<span class=\"math inline\">\\(\\mathbf{C}\\)</span>为常矢)；</li>\n<li><span class=\"math inline\">\\(\\frac{d}{dt}(\\mathbf{A}\\pm\\mathbf{B})=\\frac{d{\\mathbf{A}}}{dt}\\pm\\frac{d\\mathbf{B}}{dt}\\)</span>;</li>\n<li><span class=\"math inline\">\\(\\frac{d}{dt}(k\\mathbf{A})=k\\frac{d\\mathbf{A}}{dt}\\)</span>(<span class=\"math inline\">\\(k\\)</span>为常数);</li>\n<li><span class=\"math inline\">\\(\\frac{d}{dt}(u\\mathbf{A})=\\frac{du}{dt}\\mathbf{A}+u\\frac{d{\\mathbf{A}}}{dt};\\)</span></li>\n<li><span class=\"math inline\">\\(\\frac{d}{dt}(\\mathbf{A}\\cdot\\mathbf{B})=\\mathbf{A}\\cdot\\frac{d\\mathbf{B}}{dt}+\\mathbf{B}\\cdot\\frac{d\\mathbf{A}}{dt};\\)</span></li>\n<li><span class=\"math inline\">\\(\\frac{d}{dt}(\\mathbf{A}\\times\\mathbf{B})=\\mathbf{A}\\times\\frac{d{\\mathbf{B}}}{dt}+\\mathbf{B}\\times\\frac{d{\\mathbf{A}}}{dt}\\)</span></li>\n<li><span class=\"math inline\">\\(\\frac{d}{dt}\\mathbf{A^2}=2\\mathbf{A}\\cdot\\frac{d{\\mathbf{A}}}{dt}\\)</span>(其中<span class=\"math inline\">\\(\\mathbf{A}^2=\\mathbf{A}\\cdot\\mathbf{A}\\)</span>)</li>\n<li>复合函数求导公式：若<span class=\"math inline\">\\(\\mathbf{A}=\\mathbf{A}(u),u=u(t)\\)</span>，则</li>\n</ol>\n<p></p><div class=\"math display\">\\[\\frac{d{\\mathbf{A}}}{dt}=\\frac{d{\\mathbf{A}}}{dt}\\frac{du}{dt} \\tag{1.4.20}\n\\]</div><p></p><p>这些公式的证明方法，与微积分学中数性函数的类似公式的证法：完全相同，比如公式（5）可以这样证明：</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\n\\Delta(\\mathbf{A}\\cdot\\mathbf{B})&amp;=(\\mathbf{A}+\\Delta{\\mathbf{A}})\\cdot(\\mathbf{B}+\\Delta{\\mathbf{B}})-\\mathbf{A}\\cdot\\mathbf{B} \\\\\n&amp;=\\mathbf{A}\\cdot\\mathbf{B}+\\mathbf{A}\\cdot(\\Delta\\mathbf{B})+\\mathbf{B}\\cdot(\\Delta{\\mathbf{A}})+\\Delta{\\mathbf{A}}\\cdot\\Delta{\\mathbf{B}}-\\mathbf{A}\\cdot\\mathbf{B}\\\\\n&amp;=\\mathbf{A}\\cdot{\\Delta{\\mathbf{B}}}+\\mathbf{B}\\cdot\\Delta\\mathbf{A}+\\Delta{\\mathbf{A}}\\cdot\\Delta{\\mathbf{B}}\n\\end{aligned}\n\\tag{1.4.21}\n\\]</div><p></p><p>以<span class=\"math inline\">\\(\\Delta{t}\\)</span> 除以两端，有</p>\n<p></p><div class=\"math display\">\\[\\frac{\\Delta{\\mathbf{A}\\cdot\\mathbf{B}}}{\\Delta{t}}=\\mathbf{A}\\cdot\\frac{\\Delta{\\mathbf{B}}}{\\Delta{t}}+\\mathbf{B}\\cdot\\frac{\\Delta{\\mathbf{A}}}{\\Delta{t}} \\tag{1.4.22}\n\\]</div><p></p><p>再令 <span class=\"math inline\">\\(\\Delta{t}\\rightarrow{0}\\)</span> 两端取极限，就得到：</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\n\\frac{d}{dt}(\\mathbf{A}\\cdot\\mathbf{B})&amp;=\\mathbf{A}\\cdot\\frac{d{\\mathbf{B}}}{dt}+\\mathbf{B}\\frac{d{\\mathbf{A}}}{dt}+\\mathbf{0}\\cdot\\frac{d{\\mathbf{B}}}{dt}\\\\\n&amp;=\\mathbf{A}\\cdot\\frac{d{\\mathbf{B}}}{dt}+\\mathbf{B}\\frac{d{\\mathbf{A}}}{dt}\n\\end{aligned}\\tag{1.4.23}\n\\]</div><p></p><p><strong>定理</strong>  矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span> 的模不变的充要条件是</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A}\\cdot\\frac{d\\mathbf{A}}{dt}=0 \\tag{1.4.24}\n\\]</div><p></p><p><strong>证明：</strong> 假定 <span class=\"math inline\">\\(|\\mathbf{A}|=constant\\)</span>, 则有</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A}^2=|\\mathbf{A}|^2=constant \\tag{1.4.25}\n\\]</div><p></p><p>两端对<span class=\"math inline\">\\(t\\)</span> 求导，就得到</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A}\\cdot\\frac{d{\\mathbf{A}}}{dt}=0 \\tag{1.4.26}\n\\]</div><p></p><p>反之，若有 <span class=\"math inline\">\\(\\mathbf{A}\\cdot\\frac{d\\mathbf{A}}{dt}=0\\)</span>, 从而</p>\n<p></p><div class=\"math display\">\\[\\frac{d}{dt}\\mathbf{A}^2=0 \\tag{1.4.27}\n\\]</div><p></p><p>则有，</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A}^2=|\\mathbf{A}|^2=constant \\tag{1.4.28}\n\\]</div><p></p><p>所以要有</p>\n<p></p><div class=\"math display\">\\[|\\mathbf{A}|= constant \\tag{1.4.29}\n\\]</div><p></p><p>这个例子，可以简单地说成：定长矢量<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span> 与其导矢量互相垂直。特别，对于单位矢量$$</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A}^{o}\\perp \\frac{d{\\mathbf{A}^{o}}}{dt} \\tag{1.4.30}\n\\]</div><p></p><h3 id=\"145--导矢的物理意义\">1.4.5  导矢的物理意义</h3>\n<p>​        设质点<span class=\"math inline\">\\(M\\)</span>在空间运动，其矢径<span class=\"math inline\">\\(\\mathbf{r}\\)</span> 与时间<span class=\"math inline\">\\(t\\)</span>的函数关系为</p>\n<p></p><div class=\"math display\">\\[\\mathbf{r}=\\mathbf{r}(t) \\tag{1.4.31}\n\\]</div><p></p><p>这个函数的矢端曲线<span class=\"math inline\">\\(l\\)</span>就是质点<span class=\"math inline\">\\(M\\)</span>的运动轨迹。</p>\n<p>​        为了说明导矢<span class=\"math inline\">\\(\\frac{d{\\mathbf{r}}}{dt}\\)</span> 的物理意义，假定质点在时刻 <span class=\"math inline\">\\(t=0\\)</span>时位于点<span class=\"math inline\">\\(M_0\\)</span>处，经过一段时间<span class=\"math inline\">\\(t\\)</span> 以后到达点<span class=\"math inline\">\\(M\\)</span>,其间在<span class=\"math inline\">\\(l\\)</span>上所经过的路程为<span class=\"math inline\">\\(s\\)</span>。这样，点<span class=\"math inline\">\\(M\\)</span>的矢径<span class=\"math inline\">\\(\\mathbf{r}\\)</span> 显然是路程<span class=\"math inline\">\\(s\\)</span> 的函数，而<span class=\"math inline\">\\(s\\)</span> 又是时间<span class=\"math inline\">\\(t\\)</span> 的函数，从而可以将<span class=\"math inline\">\\(\\mathbf{r}=\\mathbf{r}(t)\\)</span> 看作<span class=\"math inline\">\\(\\mathbf{r}\\)</span> 是通过中间变量<span class=\"math inline\">\\(s\\)</span>而成为时间<span class=\"math inline\">\\(t\\)</span>的一个复合函数，于是由复合函数的求导公式有；</p>\n<p></p><div class=\"math display\">\\[\\frac{d{\\mathbf{r}}}{dt}=\\frac{d{\\mathbf{r}}}{ds}\\cdot\\frac{ds}{dt} \\tag{1.4.32}\n\\]</div><p></p><p>矢中<span class=\"math inline\">\\(\\frac{d{\\mathbf{r}}}{ds}\\)</span>的几何意义，如前段所示，是在点<span class=\"math inline\">\\(M\\)</span>处的一个切向单位向量，指向<span class=\"math inline\">\\(s\\)</span>增大的方向，因此，它表示在点<span class=\"math inline\">\\(M\\)</span>处质点运动的方向，现在以<span class=\"math inline\">\\(\\boldsymbol{\\tau}\\)</span> 表示之；而式中的$$</p>\n<p></p><div class=\"math display\">\\[\\frac{d{\\mathbf{r}}}{dt}=v\\boldsymbol{\\tau} \\tag{1.4.33}\n\\]</div><p></p><p>由此可见，导矢<span class=\"math inline\">\\(\\frac{d\\mathbf{r}}{dt}\\)</span> 表示出了质点<span class=\"math inline\">\\(M\\)</span>运动的速度大小和方向，因而它就是质点<span class=\"math inline\">\\(M\\)</span>运动的速度矢量<span class=\"math inline\">\\(\\boldsymbol{v}\\)</span>  ,即</p>\n<p></p><div class=\"math display\">\\[\\boldsymbol{v}=\\frac{d\\mathbf{r}}{dt} \\tag{1.4.33}\n\\]</div><p></p><p>若定义二阶导矢<span class=\"math inline\">\\(\\mathbf{w}\\)</span></p>\n<p></p><div class=\"math display\">\\[\\mathbf{w}=\\frac{d^2\\mathbf{r}}{dt^2}=\\frac{d}{dt}\\left(\\frac{d{\\mathbf{r}}}{dt}\\right) \\tag{1.4.34}\n\\]</div><p></p><p>则<span class=\"math inline\">\\(\\mathbf{w}\\)</span>为质点<span class=\"math inline\">\\(\\mathbf{M}\\)</span>运动的加速度矢量。</p>\n<p>​</p>\n<h2 id=\"15-矢性函数的积分\">1.5 矢性函数的积分</h2>\n<p>​         矢性函数的积分和数性函数的积分类似，也有不定积分和定积分两种，现在分述于下：</p>\n<h3 id=\"151--矢性函数的不定积分\">1.5.1  矢性函数的不定积分</h3>\n<p>​         <strong>定义</strong> 若在<span class=\"math inline\">\\(t\\)</span>的某个区间<span class=\"math inline\">\\(I\\)</span>上，有 <span class=\"math inline\">\\(\\mathbf{B^{'}}(t)=\\mathbf{A}(t)\\)</span>，则称<span class=\"math inline\">\\(\\mathbf{B}(t)\\)</span>为<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>在区间上的一个<strong>原函数</strong>。在区间<span class=\"math inline\">\\(I\\)</span>上，<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>的原函数全体，加做<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>的原函数的全体，叫做<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>在<span class=\"math inline\">\\(I\\)</span>上的不定积分，记作</p>\n<p></p><div class=\"math display\">\\[\\int{\\mathbf{A}(t)}dt \\tag{1.5.1}\n\\]</div><p></p><p>这个定义和数性函数的不定积分定义完全类似。故和数性函数一样，若已知<span class=\"math inline\">\\(\\mathbf{B}(t)\\)</span>和是<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span> 的一个原函数，则有</p>\n<p></p><div class=\"math display\">\\[\\int{\\mathbf{A}(t)}dt=\\mathbf{B}(t)+\\mathbf{C} \\tag{1.5.2}\n\\]</div><p></p><p>而且，数性函数不定积分的基本性质对矢性函数来说也仍然成立。例如：</p>\n<p></p><div class=\"math display\">\\[\\begin{equation}\n\\int k\\mathbf{A}(t)dt=k\\int\\mathbf{A}(t)dt \\tag{1.5.3}\n\\end{equation}\n\\]</div><p></p><p></p><div class=\"math display\">\\[\\begin{equation}\n\\int [\\mathbf{A}(t)+\\mathbf{B}(t)]dt=\\int\\mathbf{A}(t)dt+\\int\\mathbf{B}(t)dt \\tag{1.5.4}\n\\end{equation}\n\\]</div><p></p><p></p><div class=\"math display\">\\[\\begin{equation}\n\\int u(t)\\mathbf{a}dt=\\mathbf{a}\\int u(t)dt \\tag{1.5.5}\n\\end{equation}\n\\]</div><p></p><p></p><div class=\"math display\">\\[\\int\\mathbf{a}\\cdot\\mathbf{A}(t)dt=\\mathbf{a}\\cdot\\int \\mathbf{A}(t)dt \\tag{1.5.6}\n\\]</div><p></p><p></p><div class=\"math display\">\\[\\int \\mathbf{a}\\times\\mathbf{A}(t)dt=\\mathbf{a}\\times\\int\\mathbf{A}(t)dt \\tag{1.5.7}\n\\]</div><p></p><p>其中，<span class=\"math inline\">\\(k\\)</span>为非零常数，<span class=\"math inline\">\\(\\mathbf{a}\\)</span> 为非零常矢量。</p>\n<p>​       据此，若已知矢性函数的分量表达式<span class=\"math inline\">\\(\\mathbf{A}(t)=A_x(t)\\boldsymbol{i}+A_y(t)\\boldsymbol{j}+A_z(t)\\boldsymbol{k}\\)</span> ,根据式(1.6.3)和式(1.6.4)可知：</p>\n<p></p><div class=\"math display\">\\[\\int\\mathbf{A}(t)dt=\\boldsymbol{i}\\int{A_x(t)}dt+\\boldsymbol{j}\\int{A_y(t)}dt+\\boldsymbol{k}\\int{A_z(t)}dt \\tag{1.5.8}\n\\]</div><p></p><p>此式把求一个矢性函数的不定积分，归纳为求一个三个数性函数的不定积分。</p>\n<p>​      此外，数性函数的换元积分法与分部积分法亦适用于矢性函数。但由于两个矢量的矢量积服从于负交换律，即<span class=\"math inline\">\\(\\mathbf{A}\\times\\mathbf{B}=-(\\mathbf{B}\\times\\mathbf{A})\\)</span>, 故其分部积分公式的应用端应为两项相加：</p>\n<p></p><div class=\"math display\">\\[\\int\\mathbf{A}\\times\\mathbf{B}^{\\prime}dt=\\mathbf{A}\\times \\mathbf{B}+\\int \\mathbf{B}\\times\\mathbf{A}^{\\prime}dt \\tag{1.5.9}\n\\]</div><p></p><h3 id=\"152--矢性函数的定积分\">1.5.2  矢性函数的定积分</h3>\n<p><strong>定义</strong>   设矢性函数 <span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>在区间<span class=\"math inline\">\\([T_1,T_2]\\)</span> 上连续，则 <span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>在<span class=\"math inline\">\\([T_1,T_2]\\)</span> 上的定积分是指下面形式的极限：</p>\n<p></p><div class=\"math display\">\\[\\int_{T_1}^{T_2}\\mathbf{A}(t)dt=\\lim_{\\lambda\\rightarrow{0}}\\sum_{i=1}^{n}\\mathbf{A}(\\xi_{i})\\Delta{t_i} \\tag{1.5.10}\n\\]</div><p></p><p>其中 <span class=\"math inline\">\\(T_1=t_0&lt;t_1&lt;t_2&lt;...&lt;t_n=T_2\\)</span>；<span class=\"math inline\">\\(\\xi_i\\)</span>为区间<span class=\"math inline\">\\([t_{i-1},t_i]\\)</span>上的一点；<span class=\"math inline\">\\(\\Delta{t_i}=t_i-t_{i-1}\\)</span>; <span class=\"math inline\">\\(\\lambda=max{\\Delta{t_i}}\\)</span>,<span class=\"math inline\">\\(i=1,2,3,...,n\\)</span>。</p>\n<p>​       可以看出，矢性函数的定积分概念也和数性函数的定积分完全类似。因此，也具有和数性函数的定积分相应的基本性质，例如：</p>\n<p></p><div class=\"math display\">\\[\\int_{T_1}^{T_2}\\mathbf{A}(t)dt=\\mathbf{B}(T_2)-\\mathbf{B}(T_1) \\tag{1.5.11}\n\\]</div><p></p><p>其他性质就不一一列举了。</p>\n<p>​       此外，类似于（1.6.11）式，求矢性函数的定积分也可以归纳于求三个数性函数的定积分，既有：</p>\n<p></p><div class=\"math display\">\\[\\int_{T_1}^{T_2}\\mathbf{A}(t)dt=\\boldsymbol{i}\\int_{T_1}^{T_2}A_x(t)dt+\\boldsymbol{j}\\int_{T_1}^{T_2}A_y(t)dt+\\boldsymbol{k}\\int_{T_1}^{T_2}A_z(t)dt \\tag{1.5.12}\n\\]</div><p></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-04 11:10</span>&nbsp;\n<a href=\"https://www.cnblogs.com/GeophysicsWorker\">GeoFXR</a>&nbsp;\n阅读(<span id=\"post_view_count\">23</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "js中worker的详细讲解",
      "link": "https://www.cnblogs.com/IwishIcould/p/19377799",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/IwishIcould/p/19377799\" id=\"cb_post_title_url\" title=\"发布于 2026-01-04 09:03\">\n    <span>js中worker的详细讲解</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h4 id=\"什么是-javascript-worker\">什么是 JavaScript Worker？</h4>\n<p>Worker 是在Web应用程序中实现多线程的机制。<br />\n它可以在一个单独的线程中运行脚本，独立于主线程。<br />\n这样，我们可以将一些耗时的计算任务交给Worker线程处理。<br />\n以保证主线程的不会被阻塞。</p>\n<h4 id=\"为什么需要worker\">为什么需要Worker？</h4>\n<p>由于JavaScript是单线程的，所有任务在一个线程上执行。<br />\n如果遇到一个耗时的任务（比如大规模数据计算、图像处理、复杂算法）。<br />\n它会阻塞主线程导致页面无法响应，用户体验变差。<br />\nWorker的出现就是为了解决这个问题，将耗时的计算任务放到后台线程去执行。</p>\n<h3 id=\"vue2中如何使用-worker\">vue2中如何使用 worker</h3>\n<p>在vue/cli脚手架中，我们无法直接使用worker。<br />\n因为：<br />\n1，无法将 Worker 脚本打包为独立的可加载文件。<br />\n2，打包后会导致依赖丢失或路径错误。</p>\n<pre><code>npm install worker-loader -D\n或者\nyarn add worker-loader -D\n</code></pre>\n<h4 id=\"vueconfigjs-配置如下\">vue.config.js 配置如下</h4>\n<pre><code>module.exports = {\n  chainWebpack:config=&gt;{\n    // 下面是worker的配置\n    .rule('worker')\n    .test(/\\.worker\\.js$/)\n    .use('worker-loader')\n    .loader('worker-loader')\n    .end();\n\n    // 解决：worker 热更新问题\n    config.module.rule('js').exclude.add(/\\.worker\\.js$/);\n  },\n  parallel: false,\n  chainWebpack: config =&gt; {\n    // 解决：“window is undefined”报错，这个是因为worker线程中不存在window对象，因此不能直接使用，要用this代替\n    config.output.globalObject('this')\n  }\n}\n</code></pre>\n<h4 id=\"postmessage-子线程给主线发送消息\">postMessage 子线程给主线发送消息</h4>\n<p>self.postMessage子线程向主线程发送消息。<br />\n在 Web Worker 中，self 指向当前创建的这个 worker 线程，self 是一个全局对象。<br />\nself.postMessage()将数据从 worker 线程发送到创建它的主线程。</p>\n<h4 id=\"主线程通知子线程worker开始工作\">主线程通知子线程(worker)开始工作</h4>\n<pre><code>// 创建 worker\nthis.webWorker = new Worker('./web.worker.js')\n// 通知 Worker 子线程可以进行响应的工作。\n// 主线程调用worker.postMessage()方法，向 Worker 发消息\nthis.webWorker.postMessage({ action: 'startFetch' });\n</code></pre>\n<h4 id=\"worker-中来发送网络请求哈\">worker 中来发送网络请求哈</h4>\n<p>src\\views\\element.vue 文件</p>\n<pre><code>&lt;template&gt;\n  &lt;div class=\"page\"&gt;\n    &lt;h1&gt;使用worker来发发送网络请求&lt;/h1&gt;\n    &lt;el-button @click=\"sendFetchHandler\"&gt;开始发送网络请求&lt;/el-button&gt;\n\n    &lt;ul&gt;\n      &lt;li v-for=\"(item,index) in apiBackData\" :key=\"index\"&gt;{{ item.title }}&lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n// 导入 worker 文件, 必须使用 这样的方式引入\nimport WorkerA from 'worker-loader!./web.worker.js'\nexport default {\n  data() {\n    return {\n      apiBackData: []\n    }\n  },\n  methods: {\n    sendFetchHandler(){\n      // 主线程调用worker.postMessage()方法，向 Worker线程 发消息,开始进行网络请求\n      this.webWorker1.postMessage({ action: 'startFetch' });\n    }\n  },\n  created() {\n    // 创建 worker 实例，名称必须和导入时的保持一致\n    this.webWorker1 = new WorkerA('./web.worker.js')\n    // 先添加事件监听器\n    this.webWorker1.addEventListener('message', (e) =&gt; {\n      // e.data 是接收到的数据\n      console.log('收到来自 Worker 的消息:', e.data)\n      // 处理 Worker 返回的数据\n      if (e.data.type === 'fetchSuccess') {\n        this.apiBackData = e.data.data.data || []\n        console.log('获取的数据:',  this.apiBackData );\n      } else if (e.data.type === 'fetchError') {\n        console.log('获取数据失败:', e.data.error);\n      }\n    })\n\n    this.webWorker1.addEventListener('error', (error) =&gt; {\n      console.error('Worker发生错误:', error)\n    })\n  }\n}\n&lt;/script&gt;\n</code></pre>\n<pre><code>// 引入网络请求中的方法\nimport {getList} from '@/request/api.js'\n\nself.onmessage = function(e) {\n  console.log(\"worker:\", e)\n  if(e.data &amp;&amp; e.data.action==='startFetch'){\n    //  e.data是主线程发送过来的数据\n    getList().then(res=&gt;{\n      console.log(1111,res)\n      // 假设 是一个数组就是请求成功\n      if(Array.isArray(res)){\n        //将数据从 worker 线程发送到创建它的主线程\n        self.postMessage({ \n          type: 'fetchSuccess',\n          data:{\n            data:res,\n            message: '获取成功'\n          }\n        });\n      }else{\n        // 将数据从 worker 线程发送到创建它的主线程\n        self.postMessage({ type: 'fetchError', error: '请求失败' });\n      }\n    })\n  }\n};\n</code></pre>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1425695/202512/1425695-20251221111952362-1403369349.png\" /></p>\n<h4 id=\"worker导出表格案例\">worker导出表格案例</h4>\n<pre><code>&lt;template&gt;\n  &lt;div class=\"page\"&gt;\n    &lt;input type=\"text\"&gt;\n    &lt;br/&gt;\n    &lt;el-button @click=\"exportExcelHandler\"&gt;导出excel&lt;/el-button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport {writeFile, utils} from 'xlsx'\nexport default {\n  data() {\n    return {\n      \n    }\n  },\n  methods: {\n    exportExcelHandler(){\n      let arr = []\n      // 50w行的数据\n      for(let i= 0; i&lt;500000;i++){\n        arr.push({\n          name: '张' + i,\n          age: 18,\n          sex: '男',\n          id: '2025_12_12'+ i,\n          address:'XX区YYY大道' + i + '号'\n        })\n      }\n      // 将对象数组 arr 转换为 Excel 工作表(sheet)\n      const sheet  = utils.json_to_sheet(arr)\n      // 创建一个新的空工作簿对象。\n      // 工作簿是 Excel 文件的容器，可以包含多个工作表\n      const workbook = utils.book_new()\n      // 将之前创建的工作表 sheet 添加到工作簿 workbook 中\n      utils.book_append_sheet(workbook, sheet, 'sheet1')\n      console.log('workbook', workbook)\n      // 将整个工作簿 workbook 写入文件并触发浏览器下载\n      writeFile(workbook, 'test.xlsx')\n      // 主线程调用worker.postMessage()方法，向 Worker线程 发消息,开始进行网络请求\n      // this.webWorker1.postMessage({ action: 'startFetch', data: this.vueData });\n    }\n  }\n}\n&lt;/script&gt;\n</code></pre>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1425695/202512/1425695-20251221175954856-1704295092.png\" /></p>\n<h4 id=\"现在我们使用worker来解决添加数据耗时的问题\">现在我们使用worker来解决添加数据耗时的问题</h4>\n<p>下载xlsx模块。</p>\n<pre><code>npm install --save xlsx\n</code></pre>\n<p>使用worker的文件(下载的主页面)</p>\n<pre><code>&lt;template&gt;\n  &lt;div class=\"page\"&gt;\n    &lt;input type=\"text\"&gt;\n    &lt;br/&gt;\n    &lt;el-button @click=\"exportExcelHandler\"&gt;导出excel&lt;/el-button&gt;\n\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n// 导入 worker 文件, 必须使用 这样的方式引入\nimport WorkerA from 'worker-loader!./web.worker.js'\nimport {writeFile} from 'xlsx'\nexport default {\n  data() {\n    return {\n      \n    }\n  },\n  methods: {\n    exportExcelHandler(){\n      // 主线程调用worker.postMessage()方法，向 Worker线程 发消息,开始进行构造数据\n      this.webWorker1.postMessage({ action: 'startCreateExcelData'});\n    }\n  },\n  created() {\n    // 创建 worker 实例，名称必须和导入时的保持一致\n    this.webWorker1 = new WorkerA('./web.worker.js')\n    // 先添加事件监听器\n    this.webWorker1.addEventListener('message', (e) =&gt; {\n      console.log('收到来自 Worker 的消息:', e.data)\n      // 处理 Worker 返回的数据\n      if (e.data.type === 'createExcelSuccess') {\n        // 返回表的数据\n        const workbook = e.data.data.data\n        // 将整个工作簿 workbook 写入文件并触发浏览器下载。\n        // 最后异步仍然会卡顿,因为数据量太大了.但是卡顿的时间会比之前好一些\n        writeFile(workbook, '通过worker导处excel.xlsx')\n      } else  {\n        console.log('获取数据失败:', e.data.error);\n      }\n    })\n\n    this.webWorker1.addEventListener('error', (error) =&gt; {\n      console.error('Worker发生错误:', error)\n    })\n  }\n}\n&lt;/script&gt;\n</code></pre>\n<p>worker文件(src\\views\\web.worker.js )</p>\n<pre><code>// 引入 xlsx\nimport {utils} from 'xlsx'\nself.onmessage = function(e) {\n  console.log(\"worker:\", e)\n  if(e.data &amp;&amp; e.data.action==='startCreateExcelData'){\n    //  e.data是主线程发送过来的数据\n    let arr = []\n    // 50w行的数据\n    for(let i= 0; i&lt;500000;i++){\n      arr.push({\n        name: '张' + i,\n        age: 18,\n        sex: '男',\n        id: '2025_12_12'+ i,\n        address:'XX区YYY大道' + i + '号'\n      })\n    }\n    // 将对象数组 arr 转换为 Excel 工作表(sheet)\n    const sheet  = utils.json_to_sheet(arr)\n    // 创建一个新的空工作簿(book)对象。工作簿是 Excel 文件的容器，可以包含多个工作表(sheet)\n    const workbook = utils.book_new()\n    // 将之前创建的工作表 (sheet) 添加到工作簿(workbook)中\n    utils.book_append_sheet(workbook, sheet, 'sheet1')\n    self.postMessage({ \n      type: 'createExcelSuccess',\n      data:{\n        data:workbook,\n        message: '获取成功'\n      }\n    });\n  }\n};\n</code></pre>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1425695/202512/1425695-20251223192441700-1399729196.png\" /></p>\n<h4 id=\"关闭-web-worker\">关闭 Web Worker</h4>\n<p>在主线程和在Worker线程的关闭方式是不一样的。<br />\n如果在主线程，调用terminate()方法关闭</p>\n<pre><code>this.webWorker1 = new WorkerA('./web.worker.js') \nthis.webWorker1.terminate();\n</code></pre>\n<p>如果是在Work线程，可以调用close()方法进行关闭</p>\n<pre><code>self.close();\n</code></pre>\n<h4 id=\"主线程关闭-worker-线程的说明\">主线程关闭 worker 线程的说明</h4>\n<p>当主线程调用worker.terminate()时，Worker线程会被立即终止。<br />\n无论当前事件循环中是否有任务，包括微任务和宏任务，都不会继续执行。<br />\n也就是说：如果我在点击[导入excel]按钮后，马上又关闭点击[关闭worker]，那么不能够正常导出表格。<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1425695/202512/1425695-20251223192230075-108196709.png\" /></p>\n<h4 id=\"worker线程内部关闭-worker-线程的说明\">Worker线程内部关闭 worker 线程的说明</h4>\n<p>当Worker线程内部调用self.close()时，Worker线程并不会立即终止。<br />\n它会[继续执行当前]事件循环中的任务，但是[会阻止后续]事件循环的任务执行。<br />\n也就是说：如果我在点击[导入excel]按钮后，马上又关闭点击[Worker内部关闭Worker]，仍然可以导出表格。<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1425695/202512/1425695-20251223193947537-1923756412.png\" /></p>\n<h4 id=\"判断用户浏览器是否支持-worker\">判断用户浏览器是否支持 worker</h4>\n<pre><code>if (typeof Worker !== 'undefined') {\n  console.log('浏览器支持 Web Workers');\n} else {\n  console.log('浏览器不支持 Web Workers');\n}\n</code></pre>\n<h4 id=\"worker-线程引用其他js文件\">Worker 线程引用其他js文件</h4>\n<p>有些时候，我们需要在worker文件中，引入其他模块的文件。<br />\n可以通过 importScripts() 方法来实现，在 worker 中导入其他的模块。这个地址是可以跨域的。</p>\n<h4 id=\"worker-指定模块类型\">Worker 指定模块类型</h4>\n<p>如果我们发现我们需要导出的方法使用的是ESModule 模式导出。<br />\n此时使用 importScripts() 方法引入他模块，会报错。<br />\n此时需要指定模块类型。</p>\n<pre><code>// main.js（主线程的代码）\nconst worker = new Worker('/worker.js', {\n    type: 'module'  // 指定 worker.js 的类型\n});\n</code></pre>\n<pre><code>// worker.js（worker线程的代码）\nimport add from './utils.js'; // 导入外部js\n\nself.addEventListener('message', e =&gt; { \n    postMessage(e.data);\n});\n\nadd(1, 2);\n</code></pre>\n<pre><code>// utils.js 使用了ESModule 模块导出的 add 方法\nexport default add = (a, b) =&gt; a + b;\n</code></pre>\n<h4 id=\"使用worker的注意事项\">使用worker的注意事项</h4>\n<p>1，worker不能使用window上的dom操作，也不能获取dom对象,dom相关的东西只有主线程有。worker只能做一些计算相关的操作<br />\n2，有的东西是无法通过主线程传递个子线程的。<br />\n比如：方法，dom节点，一些对象里的特殊设置(freeze,getter,setter这些)所以vue的响应式对象在传递之后就会变成普通对象</p>\n<h4 id=\"worker实际应用案例\">worker实际应用案例</h4>\n<p>1，将语法检查、代码压缩等任务放在 Worker 中执行<br />\n2，图像处理：比如使用Canvas处理图片，进行滤镜</p>\n<h4 id=\"worker性能优化建议\">worker性能优化建议</h4>\n<p>减少通信开销：避免频繁传递大量数据，必要时使用 Transferable Objects（如 ArrayBuffer）<br />\n批量处理：对于大批量任务，可批量创建 Worker 并行处理<br />\n常驻线程：对于频繁使用的 Worker，可保持常驻而非重复创建<br />\n错误处理：始终监听 onerror 事件，捕获 Worker 内部的异常</p>\n\n</div>\n<div id=\"MySignature\">\n    <div>\n            <h1 style=\"font-size: 24px;\"> 遇见问题，这是你成长的机会，如果你能够解决，这就是收获。 </h1>\n\t\t    <div style=\"padding: 10px;\">\n\t\t        作者：<a href=\"https://www.cnblogs.com/IwishIcould/\" target=\"_blank\">晚来南风晚相识</a> <br />\n\t\t        出处：<a href=\"https://www.cnblogs.com/IwishIcould/\">https://www.cnblogs.com/IwishIcould/</a> <br />\n                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>\n\t\t        <p>如果觉得这篇文章对你有小小的帮助的话，记得在右下角点个“推荐”哦，或者关注博主，在此感谢！</p>\n\t\t        <p> 万水千山总是情，打赏5毛买辣条行不行，所以如果你心情还比较高兴，也是可以扫码打赏博主(っ•̀ω•́)っ✎⁾⁾！</p>\n                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>\n\t\t\t\t<div style=\"display: flex;\">\n\t\t\t\t\t<div style=\"margin-right: 100px; text-align: center;\">\n\t\t\t\t\t\t<img src=\"//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_201214043958支付宝收款码.jpg?a=1607924145179\" />\n\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t支付宝\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div style=\"text-align: center;\">\n\t\t\t\t\t\t<img src=\"//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_20121604194271E6E296CCB71A007F4E22073D5EB64A.jpg\" />\n\t\t\t\t\t\t<div>微信</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t        本文版权归作者所有，欢迎转载，未经作者同意须保留此段声明，在文章页面明显位置给出原文连接 <br />\n\t\t        如果文中有什么错误，欢迎指出。以免更多的人被误导。 <br />\n               \n\t\t    </div>\n           \n            \n\t\t</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-04 09:03</span>&nbsp;\n<a href=\"https://www.cnblogs.com/IwishIcould\">南风晚来晚相识</a>&nbsp;\n阅读(<span id=\"post_view_count\">73</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "7 个从入门到资深 PHP 开发者都在用的核心调试技能",
      "link": "https://www.cnblogs.com/catchadmin/p/19435596",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19435596\" id=\"cb_post_title_url\" title=\"发布于 2026-01-04 08:01\">\n    <span>7 个从入门到资深 PHP 开发者都在用的核心调试技能</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"7-个从入门到资深-php-开发者都在用的核心调试技能\">7 个从入门到资深 PHP 开发者都在用的核心调试技能</h1>\n<h2 id=\"调试的残酷真相\">调试的残酷真相</h2>\n<p>大多数 PHP bug 难搞，不是因为它们\"复杂\"，而是因为它们<strong>看不见</strong>。</p>\n<p>变量在比你预期早两层的地方就变成了 null。一个\"不可能发生\"的条件偏偏只在生产环境发生。请求在本地正常，放到代理后面就挂了。队列 worker 的行为和 HTTP 运行时不一样。还有经典场景：你修好了……下周它又回来了。</p>\n<p>想快速成长为 PHP 开发者，别急着学更多框架特性。先学会<strong>观察系统实际在做什么</strong>。</p>\n<p>下面是我认为每个 PHP 开发者从第一天就该掌握的 7 个调试技能。它们不是花招，而是会持续产生复利的习惯。</p>\n<p><a href=\"https://catchadmin.com/post/2026-01/debugging-php-like-a-pro\" rel=\"noopener nofollow\" target=\"_blank\">原文 7 个从入门到资深 PHP 开发者都在用的核心调试技能</a></p>\n<h2 id=\"错误要看得见但别暴露给用户\">错误要看得见，但别暴露给用户</h2>\n<p>看不到错误，你就不是在调试——你是在猜。</p>\n<p>PHP 提供了可靠的错误可见性原语：<code>error_reporting</code>、<code>display_errors</code> 和日志设置。关键是把开发环境和生产环境当作不同的可观测模式来对待。</p>\n<p>PHP 官方手册强烈建议在生产网站上记录错误而非显示错误。</p>\n<h3 id=\"开发环境全开\">开发环境：全开</h3>\n<p>在开发环境，你需要最大化的信号：</p>\n<pre><code class=\"language-ini\">; php.ini (development)\nerror_reporting = -1\ndisplay_errors = On\ndisplay_startup_errors = On\nlog_errors = On\n</code></pre>\n<p>如果你用 Docker 或开发容器，确认容器内部的设置：</p>\n<pre><code class=\"language-bash\">php -i | grep -E \"error_reporting|display_errors|log_errors\"\n</code></pre>\n<h3 id=\"生产环境只记录不显示\">生产环境：只记录，不显示</h3>\n<p>在生产环境，<code>display_errors=On</code> 不是\"有帮助\"，而是漏洞。你要的是日志，不是泄露的堆栈跟踪。</p>\n<pre><code class=\"language-ini\">; php.ini (production)\nerror_reporting = -1\ndisplay_errors = Off\ndisplay_startup_errors = Off\nlog_errors = On\nerror_log = /var/log/php/app-error.log\n</code></pre>\n<p>然后在故障期间 tail 日志：</p>\n<pre><code class=\"language-bash\">tail -f /var/log/php/app-error.log\n</code></pre>\n<h3 id=\"异常日志要带上下文\">异常日志要带上下文</h3>\n<p>别完全依赖 PHP 默认的错误日志格式。在应用启动时添加一个顶层异常处理器（框架无关）：</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\n\nset_exception_handler(function (Throwable $e) {\n    error_log(json_encode([\n        'level' =&gt; 'error',\n        'event' =&gt; 'uncaught_exception',\n        'message' =&gt; $e-&gt;getMessage(),\n        'type' =&gt; $e::class,\n        'file' =&gt; $e-&gt;getFile(),\n        'line' =&gt; $e-&gt;getLine(),\n        'trace' =&gt; explode(\"\\n\", $e-&gt;getTraceAsString()),\n    ], JSON_UNESCAPED_SLASHES));\n});\n</code></pre>\n<p>这是\"穷人版结构化日志\"，但已经比经典的\"崩了，不知道为啥\"强多了。</p>\n<p><strong>技能检验</strong>：如果有人给你一张生产环境的错误截图，你应该能说：\"关掉那个。放到日志里。加上关联 ID。然后复现。\"</p>\n<h2 id=\"xdebug-步进调试别再瞎猜了\">Xdebug 步进调试：别再瞎猜了</h2>\n<p><code>var_dump()</code> 在探索时还行。步进调试才是你认真排查时用的工具。</p>\n<p>Xdebug 的步进调试器让你可以逐步执行代码并交互式地检查状态。</p>\n<h3 id=\"理解它能干什么\">理解它能干什么</h3>\n<p>步进调试回答的问题：</p>\n<ul>\n<li>代码实际走了哪条路径？</li>\n<li>这里的值是什么，不是你脑子里想的那个？</li>\n<li>为什么这个分支被执行了？</li>\n<li>是什么修改了这个变量？</li>\n</ul>\n<h3 id=\"xdebug-3-最小配置\">Xdebug 3 最小配置</h3>\n<p>Xdebug 有多种模式和现代化的配置方式。官方文档覆盖了步进调试和所有设置。</p>\n<p>在大多数环境中，可以这样配置：</p>\n<pre><code class=\"language-ini\">; xdebug.ini\nxdebug.mode = debug\nxdebug.start_with_request = yes\nxdebug.client_port = 9003\n</code></pre>\n<p>为什么是 9003？Xdebug 3 改了默认端口（这是\"连不上\"问题的常见原因）。IDE 文档和社区答案通常把 9003 作为 Xdebug 3 的默认端口。</p>\n<h3 id=\"共享环境别常开调试\">共享环境别常开调试</h3>\n<p>更好的习惯是\"需要时才调试\"。这样能保持性能稳定，避免意外暴露调试行为。</p>\n<p>尽量用环境变量：</p>\n<pre><code class=\"language-bash\">XDEBUG_MODE=debug php -S localhost:8000 -t public\n</code></pre>\n<p>或者对于 PHP-FPM/容器，只在开发环境设置 <code>XDEBUG_MODE=debug</code>。</p>\n<h3 id=\"高效的调试流程\">高效的调试流程</h3>\n<ol>\n<li>在可疑函数的第一行打断点</li>\n<li>触发请求</li>\n<li>步进进入函数</li>\n<li>观察：\n<ul>\n<li>输入参数</li>\n<li>分支条件</li>\n<li>意外的 null / 空字符串</li>\n<li>\"神秘\"变化的值</li>\n</ul>\n</li>\n<li>找到错误假设后，停下来。用一句话写下来。</li>\n</ol>\n<p>最后一步很重要：目标不是\"无限探索\"，而是快速找到错误的假设。</p>\n<h2 id=\"告别-var_dump用更好的方式-dump\">告别 var_dump()，用更好的方式 dump</h2>\n<p>dump 仍然有用。错误在于盲目 dump。</p>\n<p>Symfony 的 VarDumper 组件提供了比 <code>var_dump()</code> 更易读的 <code>dump()</code> 函数。很多流行生态（包括 Laravel）的 <code>dd()</code> 便捷函数都基于 VarDumper 风格的 dump 构建。</p>\n<h3 id=\"dump-关键字段别-dump-整个对象\">dump 关键字段，别 dump 整个对象</h3>\n<p>与其 dump 整个对象图然后滚动 5 分钟，不如 dump 你关心的形状。</p>\n<p><strong>差</strong>：</p>\n<pre><code class=\"language-php\">dump($request);\n</code></pre>\n<p><strong>好</strong>：</p>\n<pre><code class=\"language-php\">dump([\n  'method' =&gt; $request-&gt;getMethod(),\n  'path'   =&gt; $request-&gt;getPathInfo(),\n  'userId' =&gt; $user?-&gt;id,\n]);\n</code></pre>\n<h3 id=\"写个临时的调试辅助函数\">写个临时的调试辅助函数</h3>\n<p>在纯 PHP 应用中，定义一个小辅助函数：</p>\n<pre><code class=\"language-php\">&lt;?php\nfunction dd(mixed $value): never {\n    header('Content-Type: text/plain; charset=utf-8');\n    var_dump($value);\n    exit(1);\n}\n</code></pre>\n<p>然后谨慎使用。重点是速度。</p>\n<p><strong>规则</strong>：如果一个流程里有超过 3 个 dump，你可能需要步进调试或带关联 ID 的日志。</p>\n<h2 id=\"日志要像证据不是流水账\">日志要像证据，不是流水账</h2>\n<p>日志不应该是散落在代码里的随机句子。日志应该是<strong>证据</strong>。</p>\n<p>如果你用 Laravel，它的日志系统是基于 channel 的，默认使用\"stack\" channel。Laravel 还有\"context\"能力，可以在请求/任务/命令中捕获共享元数据并包含在日志里。</p>\n<p>即使你不用 Laravel，这个模式到处适用：一次性附加上下文，每行日志都变得更有用。</p>\n<h3 id=\"给每个请求加关联-id\">给每个请求加关联 ID</h3>\n<p>这是投入产出比最高的调试手段之一。</p>\n<p>框架无关的示例：</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\n\nfunction getCorrelationId(): string {\n    $hdr = $_SERVER['HTTP_X_REQUEST_ID'] ?? '';\n    if (is_string($hdr) &amp;&amp; $hdr !== '') return $hdr;\n    // 如果没有就生成一个\n    return bin2hex(random_bytes(16));\n}\n$reqId = getCorrelationId();\nheader('X-Request-Id: ' . $reqId);\n</code></pre>\n<p>然后加到日志里：</p>\n<pre><code class=\"language-php\">error_log(json_encode([\n  'level' =&gt; 'info',\n  'event' =&gt; 'checkout.start',\n  'request_id' =&gt; $reqId,\n  'user_id' =&gt; $userId ?? null,\n  'cart_items' =&gt; count($items),\n]));\n</code></pre>\n<h3 id=\"记录分支决策而非流水事件\">记录分支决策，而非流水事件</h3>\n<p>决策点是行为分叉的地方：</p>\n<ul>\n<li>授权检查</li>\n<li>选择支付提供商</li>\n<li>回退逻辑</li>\n<li>重试</li>\n<li>功能开关</li>\n</ul>\n<p>示例：</p>\n<pre><code class=\"language-php\">&lt;?php\n$logger-&gt;info('payment.route', [\n  'request_id' =&gt; $reqId,\n  'order_id' =&gt; $orderId,\n  'provider' =&gt; $providerName,\n  'reason' =&gt; 'currency_supported',\n]);\n</code></pre>\n<h3 id=\"敏感信息绝对不能进日志\">敏感信息绝对不能进日志</h3>\n<p>脱敏 token、密码、Authorization header、session ID。调试不值得让凭证永远泄露在日志里。</p>\n<h2 id=\"不能复现的-bug-等于没修\">不能复现的 bug 等于没修</h2>\n<p>不能复现的 bug 没有被修复，它只是在睡觉。</p>\n<p>成为\"调试高手\"最快的方法是学会创建最小复现。</p>\n<h3 id=\"最小复现清单\">最小复现清单</h3>\n<p>bug 报告来了，立刻捕获这些：</p>\n<ul>\n<li>精确的输入 payload（或脱敏版本）</li>\n<li>环境差异（PHP 版本、扩展、配置）</li>\n<li>时间相关条件（时区、当前日期、夏令时）</li>\n<li>并发条件（1 个请求 vs 10 个并发）</li>\n<li>数据前置条件（特定的数据库行）</li>\n</ul>\n<p>然后精简。</p>\n<p>如果你的应用需要 20 步才能复现，目标是 3 步。如果需要 3 步，目标是 1 步。</p>\n<h3 id=\"把-bug-变成测试用例\">把 bug 变成测试用例</h3>\n<p>这是真正的团队阻止回归的方式。</p>\n<p>示例：一个微妙的折扣舍入 bug，只在特定价格时出现。</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\n\nfinal class Discount\n{\n    public function apply(int $priceCents, int $percent): int\n    {\n        $cut = (int) round($priceCents * ($percent / 100));\n        return max(0, $priceCents - $cut);\n    }\n}\n</code></pre>\n<p>写回归测试：</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\n\nuse PHPUnit\\Framework\\TestCase;\nfinal class DiscountTest extends TestCase\n{\n    public function testRoundingEdgeCase(): void\n    {\n        $d = new Discount();\n        // Bug 报告：999 分钱打 10% 折扣产生了 900 而非 899\n        $this-&gt;assertSame(899, $d-&gt;apply(999, 10));\n    }\n}\n</code></pre>\n<p>现在你有了：</p>\n<ul>\n<li>几秒钟就能跑完的复现</li>\n<li>防止以后重新引入 bug 的安全网</li>\n</ul>\n<h3 id=\"时间相关的-bug冻结时间\">时间相关的 bug：冻结时间</h3>\n<p>如果你的代码依赖时间，你会追鬼。</p>\n<p>在应用代码中，包装\"现在\"：</p>\n<pre><code class=\"language-php\">&lt;?php\ninterface Clock {\n    public function now(): DateTimeImmutable;\n}\n\nfinal class SystemClock implements Clock {\n    public function now(): DateTimeImmutable {\n        return new DateTimeImmutable('now');\n    }\n}\n</code></pre>\n<p>在测试中，注入固定的 clock。你的调试就变得确定性了。</p>\n<h2 id=\"边界调试数据库和外部-api\">边界调试：数据库和外部 API</h2>\n<p>在现代 PHP 应用中，bug 往往不在你的业务逻辑里。它在：</p>\n<ul>\n<li>返回意外结构的查询</li>\n<li>N+1 查询模式</li>\n<li>导致超时的慢事务</li>\n<li>返回微妙不同 payload 的外部 API</li>\n</ul>\n<h3 id=\"数据库先看查询数量\">数据库：先看查询数量</h3>\n<p>如果你的接口突然变慢，第一个问题往往是：\"这个请求执行了多少查询？\"</p>\n<p>框架无关的方式（PDO 包装器）可以计数查询。Laravel/Symfony 可以接入它们的数据库 profiler 功能。不管什么技术栈，习惯是一样的：</p>\n<ul>\n<li>捕获查询数量</li>\n<li>捕获慢查询</li>\n<li>小心捕获参数（避免泄露敏感信息）</li>\n</ul>\n<p>示例（概念性伪包装器）：</p>\n<pre><code class=\"language-php\">&lt;?php\nfinal class Db\n{\n    private int $count = 0;\n    public function __construct(private PDO $pdo) {}\n    public function query(string $sql, array $params = []): array\n    {\n        $this-&gt;count++;\n        $stmt = $this-&gt;pdo-&gt;prepare($sql);\n        $stmt-&gt;execute($params);\n        return $stmt-&gt;fetchAll(PDO::FETCH_ASSOC);\n    }\n    public function queryCount(): int { return $this-&gt;count; }\n}\n</code></pre>\n<p>请求结束时：</p>\n<pre><code class=\"language-php\">$logger-&gt;info('request.db', [\n  'request_id' =&gt; $reqId,\n  'query_count' =&gt; $db-&gt;queryCount(),\n]);\n</code></pre>\n<h3 id=\"外部-http记录元数据别记-body\">外部 HTTP：记录元数据，别记 body</h3>\n<p>你需要的是：</p>\n<ul>\n<li>method</li>\n<li>host/path</li>\n<li>status</li>\n<li>duration</li>\n<li>retries</li>\n<li>关联 ID</li>\n</ul>\n<p>示例包装器：</p>\n<pre><code class=\"language-php\">&lt;?php\nfunction callPartnerApi(string $url, array $headers): array\n{\n    $start = microtime(true);\n    $ch = curl_init($url);\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER =&gt; true,\n        CURLOPT_HTTPHEADER =&gt; array_map(\n            fn($k, $v) =&gt; \"$k: $v\",\n            array_keys($headers),\n            $headers\n        ),\n        CURLOPT_TIMEOUT =&gt; 10,\n        CURLOPT_CONNECTTIMEOUT =&gt; 3,\n    ]);\n    $body = curl_exec($ch);\n    $status = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n    $durationMs = (int) ((microtime(true) - $start) * 1000);\n    curl_close($ch);\n    error_log(json_encode([\n        'event' =&gt; 'http.out',\n        'url' =&gt; $url,\n        'status' =&gt; $status,\n        'duration_ms' =&gt; $durationMs,\n    ]));\n    return ['status' =&gt; $status, 'body' =&gt; $body];\n}\n</code></pre>\n<p><strong>调试收益</strong>：一旦你有了带请求 ID 的 duration 和 status 日志，你就不用再猜 bug 是\"我们的问题\"还是\"合作方 API 负载过高\"了。</p>\n<h2 id=\"硬核手段二分法git-bisect断言守卫\">硬核手段：二分法、git bisect、断言守卫</h2>\n<p>卡住的时候，暴力往往比聪明更有效。</p>\n<h3 id=\"二分法定位代码路径\">二分法定位代码路径</h3>\n<p>如果你有一个复杂流程（结账、预订、审批流水线），别读整个代码库。缩小范围。</p>\n<ol>\n<li>在可疑区域的开头加一条日志</li>\n<li>在结尾加一条日志</li>\n<li>如果开头的日志出现了但结尾的没出现，bug 就在里面</li>\n<li>把区域一分为二，重复</li>\n</ol>\n<p>这就是\"代码的二分查找\"。效果惊人。</p>\n<h3 id=\"回归-bug-用-git-bisect\">回归 bug 用 git bisect</h3>\n<p>如果一个 bug\"最近才开始出现\"，别争论了，直接 bisect。</p>\n<pre><code class=\"language-bash\">git bisect start\ngit bisect bad HEAD\ngit bisect good &lt;已知正常的-commit-或-tag&gt;\n</code></pre>\n<p>然后运行一个能复现问题的脚本/测试，每一步标记 good/bad，直到 Git 找到引入 bug 的 commit。</p>\n<p>如果你没有复现脚本，那就是你的第一个任务（见技能 5）。</p>\n<h3 id=\"在边界加断言守卫\">在边界加断言守卫</h3>\n<p>大量调试时间花在处理\"不可能的状态变成了可能\"上。</p>\n<p>添加快速失败并带清晰消息的守卫：</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\n\nfunction requireNonEmptyString(mixed $v, string $name): string {\n    if (!is_string($v) || trim($v) === '') {\n        throw new InvalidArgumentException(\"$name must be a non-empty string\");\n    }\n    return $v;\n}\n</code></pre>\n<p>在 bug 聚集的地方使用它：解析输入、读取环境变量、处理外部 payload。</p>\n<p>示例：</p>\n<pre><code class=\"language-php\">$apiKey = requireNonEmptyString(getenv('PARTNER_API_KEY'), 'PARTNER_API_KEY');\n</code></pre>\n<p>这不是\"额外代码\"。这是调试预防。</p>\n<h2 id=\"完整的调试工作流\">完整的调试工作流</h2>\n<p>遇到 bug 时，跑这个循环：</p>\n<h3 id=\"第一步让错误可见\">第一步：让错误可见</h3>\n<p>确认错误设置和日志（技能 1）。拿到真正的堆栈跟踪。</p>\n<h3 id=\"第二步复现\">第二步：复现</h3>\n<p>精简步骤。捕获输入。让它确定性（技能 5）。</p>\n<h3 id=\"第三步选工具\">第三步：选工具</h3>\n<ul>\n<li>一个变量错了？<code>dump()</code> 一个小形状（技能 3）</li>\n<li>控制流不清楚？Xdebug 步进调试（技能 2）</li>\n<li>分布式/系统问题？关联 ID + 结构化日志（技能 4）</li>\n<li>回归？git bisect（技能 7）</li>\n</ul>\n<h3 id=\"第四步修复并锁定\">第四步：修复并锁定</h3>\n<p>添加测试或守卫，让它不再回来（技能 5 / 技能 7）。</p>\n<p>这就是整个游戏。</p>\n<h2 id=\"结语\">结语</h2>\n<p>最好的 PHP 调试者没有神奇的直觉。他们有更好的反馈循环。</p>\n<ul>\n<li>错误可见但不泄露（PHP 官方也建议在生产环境记录而非显示）</li>\n<li>猜不出来时有步进调试可用（Xdebug 就是为此而生）</li>\n<li>dump 可读且有意识（VarDumper 的 <code>dump()</code> 存在是因为 <code>var_dump()</code> 太痛苦）</li>\n<li>日志在执行过程中携带上下文（Laravel 明确支持在日志中包含 context）</li>\n<li>bug 变成可复现的测试，而非反复出现的故事</li>\n</ul>\n<p>尽早掌握这七个技能，你的\"调试时间\"会大幅缩短——不是因为 bug 消失了，而是因为你的系统不再对你隐藏真相。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-04 08:01</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">111</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}