{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "FFmpeg开发笔记（九十五）国产的开源视频美颜工具VideoEditorForAndroid",
      "link": "https://www.cnblogs.com/aqi00/p/19319684",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aqi00/p/19319684\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 12:00\">\n    <span>FFmpeg开发笔记（九十五）国产的开源视频美颜工具VideoEditorForAndroid</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<span><span>​</span></span><span id=\"cke_bm_178S\">《FFmpeg开发实战：从零基础到短视频上线》一书的“第 12 章 &nbsp;FFmpeg的移动开发”介绍了如何使用FFmpeg在手机上剪辑视频，方便开发者更好地开发类似剪映那样的视频剪辑软件。那么在Android系统上还有一款国产的开源视频美颜框架VideoEditor-For-Android，通过该框架可以更方便地给视频添加各种滤镜，下面就来介绍如何在App工程中使用VideoEditor-For-Android。</span>\n<p><span id=\"cke_bm_178S\"> VideoEditor-For-Android是一款基于Android硬编码的视频编辑器，包含视频录制、剪切、增加bgm、美白、加滤镜、加水印等多种功能。该框架通过Android的api完成视频采集，通过OpenGL完成视频数据帧的处理，通过MeidaCodec对采集到的视频流进行硬编码。它利用OpenGL完成视频的美白、加滤镜、加水印等功能，利用MediaCodec完成音视频的分离和音频的一些混音处理。<br />\nVideoEditor-For-Android的源码托管地址为https://github.com/qqchenjian318/VideoEditor-For-Android（星星数1.3k），最近版本更新于2021年9月，该版本的压缩包下载地址为https://github.com/qqchenjian318/VideoEditor-For-Android/archive/refs/heads/master.zip。<br />\n由于VideoEditor-For-Android源码的发布时间较早，为了让小海豚版本的Android Studio Dolphin能够打开它们，需要对App工程作如下修改：<br />\n1、升级Gradle版本和SDK版本；<br />\n2、把使用的jdk版本从默认的JDK8改为JDK11；<br />\n3、把Support库迁移为Androidx库；<br />\n4、build.gradle给NDK的指令集过滤器增加arm64-v8a；<br />\n5、App代码在录像和操作存储空间时增加运行时授权校验；<br />\n6、另外修复了若干bug；<br />\n因为上述修改涉及到的内容较多，这里不再一一列出，博主把修改后的App源码上传到了Github，具体地址为https://github.com/aqi00/note/tree/master/VideoEditor-For-Android。大家可以拉取Github上修改好的VideoEditor-For-Android源码，就能用小海豚版本的Android Studio Dolphin导入带Demo界面的VideoEditor-For-Android工程了。<br />\n那么通过Android Studio Dolphin编译VideoEditor-For-Android并安装到真机上，点击【本地视频美颜】后进入视频文件的挑选页面如下图所示：</span></p>\n<div>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"vefa2\" class=\"lazyload\" height=\"407\" width=\"345\" /></span></span></span></span></p>\n\n\n</div>\n<p>先到相册选择一个待加工的视频文件，再点击弹窗右下角的【加滤镜】按钮，App就转到视频的预览界面如下图所示：</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"vefa3\" class=\"lazyload\" height=\"681\" width=\"317\" /></span></span></span></span></p>\n<p>在视频预览界面左右滑动，可以切换不同的美颜效果，如下图所示：<span class=\"cke_image_resizer_wrapper\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\">​</span></span></p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"vefa4\" class=\"lazyload\" height=\"680\" width=\"317\" /></span></span></span></div>\n<p>点击界面右下角的打勾按钮，App就开始执行对应的美颜加工操作。美颜之后的视频片段默认放在App安装路径下的files目录，完整路径为“我的手机/Android/data/com.example.cj.videoeditor/files/video/clip/123456789.mp4”，其中123456789代表一串数字。使用手机自带的文件管理App找到新保存的视频片段，即可观看美颜后的视频效果。</p>\n<p>更多详细的FFmpeg开发知识参见<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\"><a class=\"cke_widget_editable cke_widget_element\" href=\"https://item.jd.com/14020415.html\" rel=\"noopener nofollow\" title=\"《FFmpeg开发实战：从零基础到短视频上线》\">《FFmpeg开发实战：从零基础到短视频上线》</a>一书。</span></p>\n\n<span>\n<span>​</span></span>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-27 12:00</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aqi00\">aqi00</a>&nbsp;\n阅读(<span id=\"post_view_count\">8</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "使用Gradio构建AI前端 - RAG的QA模块",
      "link": "https://www.cnblogs.com/aspnetx/p/19408276",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aspnetx/p/19408276\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 11:28\">\n    <span>使用Gradio构建AI前端 - RAG的QA模块</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文将基于Gradio的Interface，继续构建RAG系统的QA前端页面，对比上一篇对召回测试前端页面的构建，来对比在Gradio下，Blocks和Interface的两种区别。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"使用gradio构建ai前端---rag的qa模块\">使用Gradio构建AI前端 - RAG的QA模块</h1>\n<h2 id=\"摘要\">摘要</h2>\n<p>本文将基于Gradio的Interface，继续构建RAG系统的QA前端页面，对比上一篇对召回测试前端页面的构建，来对比在Gradio下，Blocks和Interface的两种区别。</p>\n<h2 id=\"gradio-interface简介\">Gradio Interface简介</h2>\n<p>Gradio 是一个用于快速创建机器学习和数据科学演示界面的Python库，允许开发者通过简单代码将函数转换为交互式Web应用，无需前端开发经验。<code>gr.Interface</code> 是 Gradio 提供的一种快速创建界面的方式，适用于简单的输入输出场景，采用\"函数驱动\"模式，直接将函数与输入输出组件绑定。</p>\n<h3 id=\"核心特点\">核心特点：</h3>\n<ul>\n<li>结构简单，适合快速原型开发</li>\n<li>输入输出组件按固定布局排列</li>\n<li>基于函数映射，直接将输入传递给函数并展示输出</li>\n</ul>\n<p>综上汇总，主要的特点就是简单，快。</p>\n<h3 id=\"interface-与-blocks-的区别\">Interface 与 Blocks 的区别</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Interface</th>\n<th>Blocks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>复杂度</td>\n<td>简单，适合快速搭建</td>\n<td>灵活，适合复杂界面</td>\n</tr>\n<tr>\n<td>布局控制</td>\n<td>自动布局，结构固定</td>\n<td>完全自定义布局</td>\n</tr>\n<tr>\n<td>交互逻辑</td>\n<td>基于单一函数映射</td>\n<td>支持多函数、事件触发</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>简单输入输出场景</td>\n<td>复杂交互、多步骤流程</td>\n</tr>\n</tbody>\n</table>\n<p>相对来说，Interface的构建方式比Blocks要更简单，代码量更少。<br />\n通过下面的代码，可以看到跟Blocks有明显的区别。</p>\n<h3 id=\"代码示例\">代码示例：</h3>\n<pre><code class=\"language-python\"># 创建Gradio Interface\niface = gr.Interface(\n    fn=run_qa,  # 核心处理函数\n    inputs=[    # 输入组件列表\n        gr.Textbox(\n            label=\"问题\",\n            placeholder=\"请输入您的问题...\",\n            lines=3,\n            info=\"例如: '哪些节假日应该安排休假？' 或 '什么是未成年？'\"\n        ),\n        gr.Slider(\n            label=\"Top-K检索数量\",\n            minimum=1,\n            maximum=10,\n            value=5,\n            step=1,\n            info=\"设置返回的最相似文档数量\"\n        )\n    ],\n    outputs=gr.Markdown(  # 输出组件\n        label=\"回答结果\"\n    ),\n    title=\"🤖 RAG问答系统\",\n    description=\"基于LangChain和Gradio构建的RAG问答系统，使用向量数据库进行知识检索\",\n    examples=[  # 示例问题\n        [\"哪些节假日应该安排休假？\", 5],\n        [\"什么是未成年？\", 3],\n        [\"足球比赛的基本规则是什么？\", 4]\n    ],\n    theme=gr.themes.Soft(),\n    allow_flagging=\"never\"  # 禁用标记功能\n)\n</code></pre>\n<p>下面是构建界面的样子：<br />\n<img alt=\"img\" src=\"https://img2024.cnblogs.com/blog/8622/202512/8622-20251227112605131-876188573.png\" /></p>\n<p>通过以上代码，可以看到在gr.Interface里，首先指定捆绑的是哪一个function，然后在inputs和outputs，依次创建对应的前端组件，并且对应function里的输入参数和返回值。<br />\n这段代码调用项目里已经封装好的LC_RAG_03_QA.py里的方法。</p>\n<h3 id=\"关键区别点\">关键区别点：</h3>\n<p>对比上一篇，这里汇总了Interface方式和Blocks两种方式的区别。</p>\n<ol>\n<li>\n<p><strong>布局控制</strong>：</p>\n<ul>\n<li>Interface：自动排列输入输出，无需手动控制布局</li>\n<li>Blocks：通过 <code>gr.Row()</code>、<code>gr.Column()</code> 等手动控制组件布局</li>\n</ul>\n</li>\n<li>\n<p><strong>事件处理</strong>：</p>\n<ul>\n<li>Interface：自动关联输入输出和处理函数</li>\n<li>Blocks：需要显式通过 <code>.click()</code> 等方法绑定事件</li>\n</ul>\n</li>\n<li>\n<p><strong>灵活性</strong>：</p>\n<ul>\n<li>Interface：适合简单场景，代码量少</li>\n<li>Blocks：适合复杂界面，支持条件显示、多步骤交互等高级功能</li>\n</ul>\n</li>\n<li>\n<p><strong>结构组织</strong>：</p>\n<ul>\n<li>Interface：通过参数配置界面元素</li>\n<li>Blocks：使用上下文管理器（<code>with</code> 语句）组织界面结构</li>\n</ul>\n</li>\n</ol>\n<p>在本案例中，使用 <code>gr.Interface</code> 代码更简洁高效。如果需要更复杂的交互（如多步骤处理、条件显示组件等），则应选择 <code>gr.Blocks</code>。<br />\n所以如果是对模型功能的评估，建议选择gr.Interface，如果是做原型设计，建议选择gr.Blocks。</p>\n<p>本文项目代码可以在以下仓库里找到：<br />\n<a href=\"https://github.com/microsoftbi/Langchain_DEMO/tree/main/RAG\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/microsoftbi/Langchain_DEMO/tree/main/RAG</a><br />\n此篇对应的代码是：LC_RAG_07c_Gradio.py</p>\n<p>这里再补充一个快速的方法，就是借助AI开发工具，比如TRAE，以下是我用的提示词，仅供参考：</p>\n<pre><code class=\"language-Prompt\">在当前python文件中，编写一个QA的前端界面，前端框架使用Gradio，不要使用blocks的方式构建页面，直接使用interface的方式来构建，使用的方法，调用LC_RAG_03_QA.py里的answer_question方法。\n</code></pre>\n<p>虽然在我使用的过程中，代码无法一次通过，但基本上通过一次反馈就可以修补成功，从而省下了这部分代码的工作量。</p>\n<details>\n以下是代码的全部内容，点击展开。\n<pre><code class=\"language-Python\">import gradio as gr\nfrom LC_RAG_03_QA import answer_question\n\ndef run_qa(question, top_k=5):\n    \"\"\"运行QA并返回结果\"\"\"\n    try:\n        answer, sources = answer_question(\n            question=question,\n            top_k=top_k,\n            vectorstore_dir=\"./RAG/chroma_db\",\n            embedding_model=\"text-embedding-v4\"\n        )\n        \n        # 格式化结果\n        result = f\"# 🎯 答案\\n\\n{answer}\\n\"\n        \n        if sources:\n            result += \"\\n# 📚 参考来源\\n\"\n            for source in sources:\n                result += f\"- {source}\\n\"\n        \n        return result\n    except Exception as e:\n        return f\"❌ 错误: {str(e)}\"\n\n# 创建Gradio Interface\niface = gr.Interface(\n    fn=run_qa,\n    inputs=[\n        gr.Textbox(\n            label=\"问题\",\n            placeholder=\"请输入您的问题...\",\n            lines=3,\n            info=\"例如: '哪些节假日应该安排休假？' 或 '什么是未成年？'\"\n        ),\n        gr.Slider(\n            label=\"Top-K检索数量\",\n            minimum=1,\n            maximum=10,\n            value=5,\n            step=1,\n            info=\"设置返回的最相似文档数量\"\n        )\n    ],\n    outputs=gr.Markdown(\n        label=\"回答结果\"\n    ),\n    title=\"🤖 RAG问答系统\",\n    description=\"基于LangChain和Gradio构建的RAG问答系统，使用向量数据库进行知识检索\",\n    examples=[\n        [\"哪些节假日应该安排休假？\", 5],\n        [\"什么是未成年？\", 3],\n        [\"足球比赛的基本规则是什么？\", 4]\n    ],\n    theme=gr.themes.Soft(),\n    allow_flagging=\"never\"\n)\n\n# 启动应用\nif __name__ == \"__main__\":\n    iface.launch(\n        server_name=\"0.0.0.0\",\n        server_port=7861,\n        share=False,\n        debug=False\n    )\n</code></pre>\n</details>\n</div>\n<div id=\"MySignature\">\n    <p>&nbsp;</p>\n<p>---------------------------------------------------------------</p>\n<p style=\"margin: 0in 0in 10pt;\">aspnetx<span style=\"font-family: SimSun;\">的</span>BI<span style=\"font-family: SimSun;\">笔记系列索引：</span></p>\n<p style=\"margin: 0in 0in 10pt;\"><a href=\"http://www.cnblogs.com/aspnetx/archive/2013/02/25/2931603.html\" target=\"_blank\">使用SQL Server Analysis Services数据挖掘的关联规则实现商品推荐功能</a></p> \n<p style=\"margin: 0in 0in 10pt;\"><a href=\"http://www.cnblogs.com/aspnetx/archive/2013/03/24/2978347.html\" target=\"_blank\">一起玩转SQL Server 2012 下的分析服务</a></p> \n<p style=\"margin: 0in 0in 10pt;\"><a href=\"http://www.cnblogs.com/aspnetx/archive/2013/04/05/3000448.html\" target=\"_blank\">使用SQL Server分析服务定位目标用户  </a></p> \n\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>---------------------------------------------------------------<br /></p>\n<p>来自<a href=\"http://www.cnblogs.com/\" target=\"_blank\">博客园</a>的<a href=\"http://aspnetx.cnblogs.com/\" target=\"_blank\">aspnetx</a><font color=\"white\">宋卫东</font></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-27 11:28</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aspnetx\">哥本哈士奇(aspnetx)</a>&nbsp;\n阅读(<span id=\"post_view_count\">3</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "C++中JSON序列化和反序列化的实现",
      "link": "https://www.cnblogs.com/charlee44/p/19407771",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/charlee44/p/19407771\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 09:51\">\n    <span>C++中JSON序列化和反序列化的实现</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        介绍了 C++ 中使用 nlohmann/json 库实现 JSON 序列化与反序列化的完整方案，包括基础用法、嵌套对象支持、向后兼容处理及可选字段的健壮设计。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"1-引言\">1. 引言</h1>\n<p><strong>序列化</strong>（Serialization）是指将程序中的内存对象（如结构体、类实例、列表等）转换成一种<strong>可以存储或传输的格式</strong>（通常是字节流或文本）的过程。常见的序列化格式包括：</p>\n<ul>\n<li>JSON（文本，人类可读）</li>\n<li>XML</li>\n<li>Protocol Buffers（二进制，高效）</li>\n<li>MessagePack</li>\n<li>YAML</li>\n<li>甚至自定义的二进制格式</li>\n</ul>\n<p><strong>反序列化</strong>（Deserialization）是序列化的逆过程：将<strong>序列化后的数据</strong>（如 JSON 字符串）重新转换回<strong>程序中的内存对象</strong>。</p>\n<h1 id=\"2-原因\">2. 原因</h1>\n<p>那么，为什么需要序列化和反序列化呢？笔者的体会是不序列化/反序列化也行，只不过在进行相应的读取和写入操作的时候会非常繁琐。比如一个配置文件更新：</p>\n<p>假设我们有一个博客系统的配置，包含站点标题、作者名、是否启用评论、默认封面地址等多个字段。如果不使用序列化机制，每次读取配置时，就得手动打开 JSON（或 YAML、INI）文件，逐行解析，判断每个字段是否存在、类型是否正确，再一一赋值给程序中的变量；而当用户修改了某个设置、需要保存回文件时，又得手动拼接字符串、处理引号转义、数组格式、缩进对齐……稍有不慎，就会生成格式错误的文件，导致程序下次启动失败。</p>\n<p>更麻烦的是，一旦配置结构发生变化——比如新增一个 theme 字段，或者把 enableComments 拆成 enablePostComments 和 enablePageComments——我们就不得不同时修改读取逻辑、写入逻辑、默认值初始化、错误处理等多处代码，极易遗漏或出错。</p>\n<p>而有了序列化和反序列化，这一切就变得简洁而可靠：定义好结构体（或类），注册对应的转换函数，一行代码就能从 JSON 构造出完整的配置对象，另一行代码就能把修改后的对象写回文件。字段增减只需调整结构体，读写逻辑几乎无需改动，既减少了重复劳动，也大大提升了健壮性和可维护性。</p>\n<p>因此，序列化/反序列化并非“必须”，但它是对抗复杂性、提升开发效率和系统可靠性的重要工具。</p>\n<h1 id=\"3-实现\">3. 实现</h1>\n<h2 id=\"31-示例\">3.1 示例</h2>\n<p>这里就举例实现一下 C++ 中 JSON 序列化和反序列化。如果要反序列化成 C++ 可以使用的内存对象，最好的数据容器就是 struct 。当然 class 也可以，不过我们都知道 struct 和 class 的区别：struct 的成员一般默认是公有的，而 class 的成员一般默认是私有的。因此，struct 适合以数据成员为主的，比较简单的对象；class 适合以方法成员为主的，比较复杂的对象。</p>\n<p>笔者使用 nlohmann/json 中序列化/反序列化一个表达博客的数据对象：</p>\n<p><strong>BlogMeta.h</strong>：</p>\n<pre><code class=\"language-cpp\">#include &lt;nlohmann/json.hpp&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include \"PostStats.h\"\n\nnamespace DataTransfer {\n\n/// @brief 一篇博客的元数据\nstruct BlogMeta {\n  std::string id;\n  std::string title;\n  std::string summary;\n  std::string createdTime;\n  std::string updatedTime;  \n  std::string coverAddress;\n  int64_t isDraft;\n  std::vector&lt;std::string&gt; tagNames;\n  std::vector&lt;std::string&gt; categoryNames;\n  PostStats postStats;\n\n  // 提供序列化接口\n  friend void to_json(nlohmann::json&amp; j, const BlogMeta&amp; s);\n\n  // 提供反序列化接口\n  friend void from_json(const nlohmann::json&amp; j, BlogMeta&amp; s);\n};\n</code></pre>\n<p><strong>BlogMeta.cpp</strong>：</p>\n<pre><code class=\"language-cpp\">#include \"BlogMeta.h\"\n\n#include \"Util/GetTime.h\"\n\nnamespace DataTransfer {\n\n// 提供序列化接口\nvoid to_json(nlohmann::json&amp; j, const BlogMeta&amp; s) {\n  j = nlohmann::json{{\"id\", s.id},\n                     {\"title\", s.title},\n                     {\"summary\", s.summary},\n                     {\"createdTime\", s.createdTime},\n                     {\"updatedTime\", s.updatedTime},\n                     {\"coverAddress\", s.coverAddress},\n                     {\"isDraft\", s.isDraft},\n                     {\"tagNames\", s.tagNames},\n                     {\"categoryNames\", s.categoryNames},\n                     {\"postStats\", s.postStats}};\n}\n\n// 提供反序列化接口\nvoid from_json(const nlohmann::json&amp; j, BlogMeta&amp; s) {\n  s.id = j.at(\"id\").get&lt;std::string&gt;();\n  s.title = j.at(\"title\").get&lt;std::string&gt;();\n  s.summary = j.at(\"summary\").get&lt;std::string&gt;();\n  s.createdTime = j.at(\"createdTime\").get&lt;std::string&gt;();\n  s.updatedTime =\n      j.value(\"updatedTime\", Util::GetCurrentTime());  //提供默认值，增加稳定性\n  s.coverAddress = j.at(\"coverAddress\").get&lt;std::string&gt;();\n  s.isDraft = j.at(\"isDraft\").get&lt;int64_t&gt;();\n  s.tagNames = j.at(\"tagNames\").get&lt;std::vector&lt;std::string&gt;&gt;();\n  s.categoryNames = j.at(\"categoryNames\").get&lt;std::vector&lt;std::string&gt;&gt;();\n  s.postStats = j.at(\"postStats\").get&lt;PostStats&gt;();\n}\n\n}  // namespace DataTransfer\n</code></pre>\n<p>其中 <code>to_json</code> / <code>from_json</code> 就是对应的 序列化 / 反序列化接口。只需要填充这一对接口，就可以通过赋值运算符<code>=</code>实现自动序列化和反序列化：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n#include \"BlogMeta.h\"  // 包含你的 BlogMeta 定义\n\nint main() {\n    using namespace DataTransfer;\n    using json = nlohmann::json;\n\n    // ----------------------------\n    // 1. 创建一个 BlogMeta 对象（内存中的数据）\n    // ----------------------------\n    BlogMeta blog;\n    blog.id = \"blog-001\";\n    blog.title = \"深入理解 C++ 序列化\";\n    blog.summary = \"本文介绍如何使用 nlohmann/json 进行安全高效的序列化。\";\n    blog.createdTime = \"2025-12-22T10:00:00Z\";\n    blog.updatedTime = \"2025-12-22T17:00:00Z\";  // 可省略，反序列化时会用默认值\n    blog.coverAddress = \"/images/cpp_serialization.jpg\";\n    blog.isDraft = 0;\n    blog.tagNames = {\"C++\", \"JSON\", \"Serialization\"};\n    blog.categoryNames = {\"Programming\", \"Tutorial\"};\n    blog.postStats = {1200, 85, 23};\n\n    // ----------------------------\n    // 2. 序列化：BlogMeta → JSON\n    // ----------------------------\n    json j = blog;  // 自动调用 to_json\n    std::cout &lt;&lt; \"【序列化结果】\\n\" &lt;&lt; j.dump(2) &lt;&lt; \"\\n\\n\";\n\n    // ----------------------------\n    // 3. 反序列化：JSON → BlogMeta\n    // ----------------------------\n    // 模拟从文件或网络接收到的 JSON（故意省略 updatedTime）\n    std::string jsonStr = R\"({\n        \"id\": \"blog-002\",\n        \"title\": \"反序列化的健壮性测试\",\n        \"summary\": \"测试缺失 updatedTime 字段时的行为\",\n        \"createdTime\": \"2025-12-20T08:30:00Z\",\n        \"coverAddress\": \"/images/robust.png\",\n        \"isDraft\": 1,\n        \"tagNames\": [\"C++\", \"Robustness\"],\n        \"categoryNames\": [\"Engineering\"],\n        \"postStats\": {\n            \"viewCount\": 450,\n            \"likeCount\": 30,\n            \"commentCount\": 5\n        }\n    })\";\n \n    BlogMeta restoredBlog = json::parse(jsonStr);  // 自动调用 from_json\n  \n    // ----------------------------\n    // 4. 验证反序列化结果\n    // ----------------------------\n    std::cout &lt;&lt; \"【反序列化结果】\\n\";\n    std::cout &lt;&lt; \"ID: \" &lt;&lt; restoredBlog.id &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Title: \" &lt;&lt; restoredBlog.title &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"UpdatedTime (应为当前默认值): \" &lt;&lt; restoredBlog.updatedTime &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Is Draft: \" &lt;&lt; restoredBlog.isDraft &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Tags: \";\n    for (const auto&amp; tag : restoredBlog.tagNames) {\n        std::cout &lt;&lt; tag &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre>\n<h2 id=\"32-能力\">3.2 能力</h2>\n<p>序列化 / 反序列化的能力取决于所使用的库实现的程度。例如这个例子中，std 容器 <code>std::vector&lt;std::string&gt;</code> 也可以直接使用赋值运算符<code>=</code>来序列化/反序列化吗？确实是可以的，nlohmann/json 支持所有基础类型以及绝大多数 std 容器类型的直接 序列化/ 反序列化。不过默认情况下，C++ 数据类型与JSON的对应关系是：std::string 对应字符串， int64_t， uint64_t 或 double 对应数字， std::map 对应对象， std::vector 对应数组，且 bool 对应布尔值。</p>\n<p>另外，nlohmann/json 还支持嵌套序列化。比如这里的 PostStats 其实也是个自定义的 struct ，也实现了 <code>to_json</code> / <code>from_json</code> 接口，因此可以直接通过赋值运算符<code>=</code>相互转换。</p>\n<p><strong>PostStats.h</strong>:</p>\n<pre><code class=\"language-cpp\">#pragma once\n\n#include &lt;nlohmann/json.hpp&gt;\n\nnamespace DataTransfer {\n\n/// @brief 一篇博客的统计信息\nstruct PostStats {\n  int64_t viewCount = 0;     // 阅读量\n  int64_t likeCount = 0;     // 点赞量\n  int64_t commentCount = 0;  // 评论量\n\n  // 提供序列化接口\n  friend void to_json(nlohmann::json&amp; j, const PostStats&amp; s);\n\n  // 提供反序列化接口\n  friend void from_json(const nlohmann::json&amp; j, PostStats&amp; s);\n};\n\n}  // namespace DataTransfer\n</code></pre>\n<p><strong>PostStats.cpp</strong>:</p>\n<pre><code class=\"language-cpp\">#include \"PostStats.h\"\n\nnamespace DataTransfer {\n\n// 提供序列化接口\nvoid to_json(nlohmann::json&amp; j, const PostStats&amp; s) {\n  j = nlohmann::json{{\"viewCount\", s.viewCount},\n                     {\"likeCount\", s.likeCount},\n                     {\"commentCount\", s.commentCount}};\n}\n\n// 提供反序列化接口\nvoid from_json(const nlohmann::json&amp; j, PostStats&amp; s) {\n  s.viewCount = j.at(\"viewCount\").get&lt;int64_t&gt;();\n  s.likeCount = j.at(\"likeCount\").get&lt;int64_t&gt;();\n  s.commentCount = j.at(\"commentCount\").get&lt;int64_t&gt;();\n}\n\n}  // namespace DataTransfer\n</code></pre>\n<h2 id=\"33-兼容\">3.3 兼容</h2>\n<p>如果 JSON 配置文件进行了升级，比如增加了一个新的配置字段，那么新的程序读取旧的配置文件就有可能出错，所以在反序列化的时候最好使用 value() 提供默认值：</p>\n<pre><code class=\"language-cpp\">void from_json(const nlohmann::json&amp; j, BlogMeta&amp; s) {\n  s.id = j.value(\"id\", std::string{});\n  s.title = j.value(\"title\", std::string{});\n  s.summary = j.value(\"summary\", std::string{});\n  s.createdTime = j.value(\"createdTime\", std::string{});\n  s.updatedTime = j.value(\"updatedTime\", std::string{}); // 若缺失则为空字符串\n  s.coverAddress = j.value(\"coverAddress\", std::string{});\n  s.isDraft = j.value(\"isDraft\", int64_t{0});\n  s.tagNames = j.value(\"tagNames\", std::vector&lt;std::string&gt;{});\n  s.categoryNames = j.value(\"categoryNames\", std::vector&lt;std::string&gt;{});\n\n  // 对于嵌套结构如 PostStats，如果它也支持 from_json，可这样处理：\n  if (j.contains(\"postStats\") &amp;&amp; j[\"postStats\"].is_object()) {\n    s.postStats = j[\"postStats\"].get&lt;PostStats&gt;();\n  } else {\n    s.postStats = PostStats{}; // 默认构造\n  }\n}\n</code></pre>\n<p>另外，如果业务逻辑允许，能分清楚哪些是必须字段，哪些是可选字段，那么可以使用<code>std::optional</code>:</p>\n<pre><code class=\"language-cpp\">/// @brief 一篇博客的元数据（健壮版，支持可选字段）\nstruct BlogMeta {\n    std::string id;                          // 必填\n    std::string title;                       // 必填\n    std::optional&lt;std::string&gt; summary;\n    std::string createdTime;                 // 通常必填，也可改为 optional\n    std::optional&lt;std::string&gt; updatedTime;  \n    std::optional&lt;std::string&gt; coverAddress;\n    std::optional&lt;int64_t&gt; isDraft;          // 可选，默认 false 或 0\n    std::optional&lt;std::vector&lt;std::string&gt;&gt; tagNames;\n    std::optional&lt;std::vector&lt;std::string&gt;&gt; categoryNames;\n    std::optional&lt;PostStats&gt; postStats;\n\n    // 序列化/反序列化友元声明\n    friend void to_json(nlohmann::json&amp; j, const BlogMeta&amp; s);\n    friend void from_json(const nlohmann::json&amp; j, BlogMeta&amp; s);\n};\n\nvoid to_json(nlohmann::json&amp; j, const BlogMeta&amp; s) {\n    j = nlohmann::json{\n        {\"id\", s.id},\n        {\"title\", s.title},\n        {\"summary\", s.summary},\n        {\"createdTime\", s.createdTime},\n        {\"updatedTime\", s.updatedTime},\n        {\"coverAddress\", s.coverAddress},\n        {\"isDraft\", s.isDraft},\n        {\"tagNames\", s.tagNames},\n        {\"categoryNames\", s.categoryNames},\n        {\"postStats\", s.postStats}\n    };\n}\n\nvoid from_json(const nlohmann::json&amp; j, BlogMeta&amp; s) {\n    // 必填字段：使用 at()，缺失时报错\n    s.id = j.at(\"id\").get&lt;std::string&gt;();\n    s.title = j.at(\"title\").get&lt;std::string&gt;();\n    s.createdTime = j.at(\"createdTime\").get&lt;std::string&gt;(); // 若你也想让它可选，改用 value 或 optional\n\n    // 可选字段：直接赋值，nlohmann 自动处理存在性\n    if (j.contains(\"summary\"))       s.summary = j[\"summary\"].get&lt;std::string&gt;();\n    if (j.contains(\"updatedTime\"))   s.updatedTime = j[\"updatedTime\"].get&lt;std::string&gt;();\n    if (j.contains(\"coverAddress\"))  s.coverAddress = j[\"coverAddress\"].get&lt;std::string&gt;();\n    if (j.contains(\"isDraft\"))       s.isDraft = j[\"isDraft\"].get&lt;int64_t&gt;();\n    if (j.contains(\"tagNames\"))      s.tagNames = j[\"tagNames\"].get&lt;std::vector&lt;std::string&gt;&gt;();\n    if (j.contains(\"categoryNames\")) s.categoryNames = j[\"categoryNames\"].get&lt;std::vector&lt;std::string&gt;&gt;();\n    if (j.contains(\"postStats\"))     s.postStats = j[\"postStats\"].get&lt;PostStats&gt;();\n}\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-27 09:51</span>&nbsp;\n<a href=\"https://www.cnblogs.com/charlee44\">charlee44</a>&nbsp;\n阅读(<span id=\"post_view_count\">8</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "成为高级 PHP 开发者需要的思维转变",
      "link": "https://www.cnblogs.com/catchadmin/p/19407447",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19407447\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 08:14\">\n    <span>成为高级 PHP 开发者需要的思维转变</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"成为高级-php-开发者需要的思维转变\">成为高级 PHP 开发者需要的思维转变</h1>\n<p>想成为 PHP 高手?先从调整思维开始</p>\n<p>想成为专业的 PHP 开发者?这很好。但在深入研究 PHP 语法或最新框架之前,有一件事你需要明确:你的思维方式。</p>\n<p>事实上,这不仅仅是写代码——成为 PHP 专业人士意味着用不同的方式思考。这关乎你如何处理问题、如何与他人协作,以及如何成长。当然,深入了解 PHP 很重要,但正确的思维方式才是在 PHP 领域脱颖而出的真正关键。</p>\n<p>本文将讨论能让你从 PHP 新手成长为专业开发者的关键思维转变。准备好提升了吗?开始吧。</p>\n<p><a href=\"https://catchadmin.com/post/2025-12/the-mindset-shifts-you-need-to-become-a-rockstar-php-developer\" rel=\"noopener nofollow\" target=\"_blank\">原文链接 成为高级 PHP 开发者需要的思维转变</a></p>\n<h2 id=\"转变-1从只是写代码到解决实际问题\">转变 1:从\"只是写代码\"到\"解决实际问题\"</h2>\n<p>写代码很酷,但解决问题更酷</p>\n<p>说实话:任何人都能写代码。但写出能解决实际问题的代码?这才是关键所在。作为初学者,很容易迷失在语法细节和函数调用中,但重点是:编码只是工具。作为 PHP 开发者,你的工作不仅仅是敲代码——而是以最佳方式解决问题。</p>\n<p><strong>技术实践:在编码前先分解问题</strong></p>\n<p>在打开代码编辑器之前,先将问题分解成可管理的小块。使用流程图或伪代码等工具来规划逻辑。这种方法不仅能理清思路,还能帮你尽早发现边界情况和潜在陷阱。</p>\n<p>示例:<br />\n构建购物车时,先为添加商品、计算总价和管理会话持久化编写伪代码。然后在 PHP 中有条不紊地实现每一步。例如:</p>\n<pre><code class=\"language-php\">// Pseudocode: Add item to cart\nif (!isset($_SESSION['cart'])) {\n    $_SESSION['cart'] = array();\n}\narray_push($_SESSION['cart'], $item);\n</code></pre>\n<p>这种结构化方法将编码转变为解决问题,而不仅仅是随意写代码。</p>\n<h2 id=\"转变-2从复制粘贴编码到理解并掌控你的代码\">转变 2:从\"复制粘贴编码\"到\"理解并掌控你的代码\"</h2>\n<p>别再偷懒复制粘贴了(我们都经历过)</p>\n<p>这很诱人,对吧?在 Stack Overflow 上找到快速解决方案,复制粘贴代码,然后收工。但现实是:这在短期内可能有效,但从长远来看是灾难。如果你不理解正在使用的代码,就会遇到无法修复的问题——更糟的是,你会错过学习如何编写真正适合你的代码的机会。</p>\n<p><strong>技术实践:阅读文档并在本地测试</strong></p>\n<p>不要直接复制粘贴,而是先阅读文档。这对理解函数和库的工作原理至关重要。一旦掌握了概念,就在隔离环境中测试它(使用 PHP FPM 或 Xdebug 等工具)来观察它的行为。</p>\n<p>示例:<br />\n在使用第三方 API 之前,彻底阅读其文档。尝试简单的 curl 请求来查看数据格式以及 PHP 如何处理它。不要只依赖教程——自己动手试试。以下是在 PHP 中向 API 发起请求的快速示例:</p>\n<pre><code class=\"language-php\">// Example: Using cURL to send a GET request\n$ch = curl_init();\ncurl_setopt($ch, CURLOPT_URL, \"https://api.example.com/data\");\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n$response = curl_exec($ch);\ncurl_close($ch);\n$data = json_decode($response, true);\nprint_r($data);\n</code></pre>\n<p>现在,你理解了请求过程以及 API 如何响应。</p>\n<h2 id=\"转变-3从独立开发到团队协作\">转变 3:从\"独立开发\"到\"团队协作\"</h2>\n<p>你不是一个人在战斗</p>\n<p>是的,独自完成小项目一开始感觉很好。但一旦进入专业领域,编码就变成了团队运动。作为 PHP 开发者,你经常会与前端开发者、数据库管理员、设计师,有时甚至是项目经理一起工作。你不再是一支单人军队——你是更大图景的一部分。</p>\n<p><strong>技术实践:认真使用版本控制(Git)</strong></p>\n<p>协作意味着共享代码和跟踪变更。这就是版本控制的用武之地。学习 Git 并使用 GitHub 或 GitLab 等平台将使你的代码协作顺畅高效。使用 Git,你可以跟踪变更、回退到以前的版本,并合并多个开发者的代码而不会混乱。</p>\n<p>示例:</p>\n<pre><code class=\"language-bash\"># Initialize a new Git repository\ngit init\n# Add files to the staging area\ngit add .\n# Commit changes with a message\ngit commit -m \"Initial commit\"\n# Push changes to a remote repository\ngit push origin main\n</code></pre>\n<p>Git 不仅适用于大型团队——它对个人项目也至关重要,因为它能帮你有效管理变更。与他人合作时,拉取请求和代码审查对于维护高质量代码至关重要。</p>\n<h2 id=\"转变-4从追逐流行框架到掌握基础\">转变 4:从\"追逐流行框架\"到\"掌握基础\"</h2>\n<p>框架很有趣,但基础才是永恒的</p>\n<p>Laravel、Symfony 和 CodeIgniter 等 PHP 框架很棒,但问题是:在深入研究任何框架之前,你需要对 PHP 本身有扎实的理解。在不理解基础的情况下直接跳入框架,就像在学会走路之前就想跑步。</p>\n<p><strong>技术实践:从零开始构建项目</strong></p>\n<p>在深入研究 Laravel 等框架之前,花时间使用纯 PHP 从零开始构建一个简单项目。例如,构建一个简单的 CRUD(创建、读取、更新、删除)应用,而不依赖任何框架。这将巩固你对以下内容的理解:</p>\n<ul>\n<li>路由</li>\n<li>数据库交互</li>\n<li>会话处理</li>\n<li>用户认证</li>\n</ul>\n<p>示例:<br />\n以下是如何使用 PHP 和 MySQL 设置基本 CRUD 应用:</p>\n<ol>\n<li>创建数据库表:</li>\n</ol>\n<pre><code class=\"language-sql\">CREATE TABLE users (\n  id INT AUTO_INCREMENT PRIMARY KEY,\n  name VARCHAR(100),\n  email VARCHAR(100)\n);\n</code></pre>\n<ol start=\"2\">\n<li>使用 PHP 插入数据:</li>\n</ol>\n<pre><code class=\"language-php\">// Establish a connection\n$conn = new mysqli(\"localhost\", \"username\", \"password\", \"database\");\n// Check for connection error\nif ($conn-&gt;connect_error) {\n    die(\"Connection failed: \" . $conn-&gt;connect_error);\n}\n// Insert data\n$sql = \"INSERT INTO users (name, email) VALUES ('John Doe', 'john@example.com')\";\nif ($conn-&gt;query($sql) === TRUE) {\n    echo \"New record created successfully\";\n} else {\n    echo \"Error: \" . $sql . \"&lt;br&gt;\" . $conn-&gt;error;\n}\n$conn-&gt;close();\n</code></pre>\n<p>在不使用框架的情况下构建项目将让你深入理解底层工作原理,这会让你在之后使用 Laravel 等框架时感觉轻松许多。</p>\n<h2 id=\"转变-5从一次性学习到持续学习\">转变 5:从\"一次性学习\"到\"持续学习\"</h2>\n<p>学习永无止境</p>\n<p>如果你认为学完 PHP 和几个框架就\"完成\"了,那就再想想。技术世界发展迅速,作为专业开发者,你需要跟上步伐。优秀的 PHP 开发者不仅仅是知道如何写代码的人;而是不断进化、适应并保持好奇心的人。</p>\n<p><strong>技术实践:关注 PHP 变更日志和博客</strong></p>\n<p>及时了解 PHP 版本和最佳实践。订阅博客,关注 PHP 相关新闻,并阅读每个新版本发布的官方 PHP 变更日志。了解 PHP 8 中的新特性(如 JIT 和属性)将使你的代码保持现代和高效。</p>\n<p>示例:<br />\n在 PHP 8 中,match 表达式可以成为 switch-case 的更简洁替代方案。如果你还没试过,现在就试试!</p>\n<pre><code class=\"language-php\">$fruit = 'apple';\necho match($fruit) {\n    'apple' =&gt; 'It's an apple!',\n    'banana' =&gt; 'It's a banana!',\n    default =&gt; 'Unknown fruit',\n};\n</code></pre>\n<p>这种新语法更紧凑,消除了多个 case 语句的需要。</p>\n<h2 id=\"转变-6从快速修复到长期解决方案\">转变 6:从\"快速修复\"到\"长期解决方案\"</h2>\n<p>写出你会引以为豪的代码(而不仅仅是能用的代码)</p>\n<p>我们都经历过。紧迫的截止日期、压力,以及随便拼凑点东西的诱惑。但问题是:编写快速而粗糙的代码现在可能完成工作,但以后会反噬你。糟糕的代码会导致 bug、性能问题和巨大的麻烦。</p>\n<p><strong>技术实践:编写可测试、可扩展的代码</strong></p>\n<p>确保代码保持整洁和可扩展的一种方法是编写测试。使用 PHPUnit 进行单元测试来验证代码的每个部分是否按预期工作。</p>\n<p>示例:<br />\n以下是一个简单的 PHPUnit 测试,用于测试计算购物车中商品总价的方法:</p>\n<pre><code class=\"language-php\">use PHPUnit\\Framework\\TestCase;\nclass ShoppingCartTest extends TestCase\n{\n    public function testTotalPrice()\n    {\n        $cart = new ShoppingCart();\n        $cart-&gt;addItem('Apple', 1.50);\n        $cart-&gt;addItem('Banana', 1.00);\n        \n        $this-&gt;assertEquals(2.50, $cart-&gt;getTotalPrice());\n    }\n}\n</code></pre>\n<p>单元测试有助于尽早发现 bug,并确保在添加新功能时,现有功能不会出问题。</p>\n<h2 id=\"结语转变思维让你的-php-职业生涯腾飞\">结语:转变思维,让你的 PHP 职业生涯腾飞</h2>\n<p>成为 PHP 专业人士远不止于写代码——这关乎像问题解决者一样思考、深入理解你的工具、与他人协作,以及致力于持续成长。如果你今天开始进行这些思维转变,你将顺利成为一名抢手的 PHP 开发者。</p>\n<p>所以,下次坐下来编码时,记住:这不仅仅是完成工作——而是以正确的方式、专业的方式去做。祝编码愉快!</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-27 08:14</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">9</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一款由字节跳动推出的 AI 提示词生成和优化工具，为你提供更精准，专业，可持续迭代提示词！",
      "link": "https://www.cnblogs.com/Can-daydayup/p/19406862",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Can-daydayup/p/19406862\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 23:11\">\n    <span>一款由字节跳动推出的 AI 提示词生成和优化工具，为你提供更精准，专业，可持续迭代提示词！</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2><span>前言</span></h2>\n<p><span>在AI技术迅猛发展的当下，高效且精准的提示词成为与AI模型有效交互的关键。今天大姚给大家分享一款由字节跳动推出的 AI 提示词生成和优化工具，为你提供更精准，专业，可持续迭代提示词！</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226230859325-1349637768.png\" /></p>\n<h2><span>工具介绍</span></h2>\n<p><span>PromptPilot 是由字节跳动推出的一款专注于 AI 提示词优化与提示词生成的实用工具。该工具旨在帮助用户更高效地生成和优化 AI 提示词，提升与 AI 模型的交互效率和质量。通过 PromptPilot，用户可以轻松地创建、调试和管理提示词，以满足多样化的应用场景需求。</span></p>\n<ul class=\"list-paddingleft-1\">\n<li><strong><span>在线访问地址：<span class=\"wx_text_underline\">https://promptpilot.volcengine.com</span></span></strong></li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226230911909-2106687661.png\" /></p>\n<h2><span>应用场景</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>内容创作</strong><span>：在自媒体、广告、营销等领域，PromptPilot 可帮助创作者快速生成吸引人的文案提示词，提升内容质量和吸引力。</span></li>\n<li><strong>数据分析</strong><span>：在数据分析场景中，PromptPilot 可辅助分析师生成精准的查询提示词，提高数据检索和分析效率。</span></li>\n<li><strong>客户服务</strong><span>：在客户服务领域，PromptPilot 可用于生成自动化回复的提示词，提升客户响应速度和满意度。</span></li>\n<li><strong>教育行业</strong><span>：教师和学生可利用 PromptPilot 生成教学和学习相关的提示词，促进知识的有效传递和学习效果的提升。</span></li>\n</ul>\n<h2><span>提示词生成</span></h2>\n<h3><span>任务描述：</span></h3>\n<pre><span><code><span>给我写一个企业优秀员工获奖感言。<br /></span></code></span></pre>\n<h3><span>生成后的 Prompt：</span></h3>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226230930602-605100114.png\" /></p>\n<p>&nbsp;</p>\n<pre><span><code># 获奖感言创作指南<br /><br />## 一、身份设定<br /><span>你是企业行政部门的资深文案专员，负责为获奖员工撰写符合公司文化的正式获奖感言。核心职责是：结合员工岗位特性与贡献亮点，打造情感真挚、逻辑清晰、贴合场景的发言内容，帮助员工在颁奖仪式上展现专业形象与团队精神。<br /><br />## 二、创作准则<br />### 必做事项<br /><span>1. 必须包含获奖员工姓名、所获奖项全称、公司名称<br /><span>2. 必须突出员工岗位核心职责与关键贡献数据<br /><span>3. 必须体现对公司、团队、家人的感谢层次<br /><span>4. 必须包含对未来工作的承诺与展望<br /><br />### 约束条件<br /><span>1. 禁止使用夸张不实的表述，所有贡献需基于提供的事实<br /><span>2. 禁止出现敏感词汇或不当表述<br /><span>3. 禁止遗漏指定的感谢对象<br /><span>4. 禁止超过规定字数限制<br /><br />## 三、变量说明<br /><span>&lt;员工姓名&gt;{{EMPLOYEE_NAME}}&lt;/员工姓名&gt; - 获奖员工的完整姓名<br /><span>&lt;奖项类型&gt;{{AWARD_TYPE}}&lt;/奖项类型&gt; - 具体获奖名称（如：年度优秀员工、季度创新之星）<br /><span>&lt;公司名称&gt;{{COMPANY_NAME}}&lt;/公司名称&gt; - 员工所在企业全称<br /><span>&lt;工作职责&gt;{{WORK_DUTIES}}&lt;/工作职责&gt; - 员工日常工作内容概述<br /><span>&lt;核心贡献&gt;{{KEY_CONTRIBUTIONS}}&lt;/核心贡献&gt; - 员工获奖的关键业绩或突出表现<br /><span>&lt;感谢对象&gt;{{THANKS_OBJECTS}}&lt;/感谢对象&gt; - 需要特别致谢的个人或团队<br /><br />## 四、创作流程<br />### 第一步：内容架构搭建<br /><span>1. 开场问候：礼貌性称呼在场人员<br /><span>2. 获奖致谢：表达获奖的荣幸与激动心情<br /><span>3. 工作回顾：简述岗位价值与核心贡献<br /><span>4. 感恩环节：分层次感谢公司、团队、家人<br /><span>5. 未来展望：承诺未来工作方向与目标<br /><br />### 第二步：细节填充<br /><span>1. 将 &lt;员工姓名&gt;{{EMPLOYEE_NAME}}&lt;/员工姓名&gt; 自然融入开场与落款<br /><span>2. 准确引用 &lt;奖项类型&gt;{{AWARD_TYPE}}&lt;/奖项类型&gt; 全称<br /><span>3. 结合 &lt;工作职责&gt;{{WORK_DUTIES}}&lt;/工作职责&gt; 说明岗位价值<br /><span>4. 用数据化语言呈现 &lt;核心贡献&gt;{{KEY_CONTRIBUTIONS}}&lt;/核心贡献&gt;<br /><span>5. 按重要性排序提及 &lt;感谢对象&gt;{{THANKS_OBJECTS}}&lt;/感谢对象&gt;<br /><br />### 第三步：风格润色<br /><span>1. 语言风格：正式中带有温度，避免过于口语化<br /><span>2. 情感表达：控制情绪尺度，保持专业得体<br /><span>3. 时间控制：按3分钟发言长度调整内容详略（约500-600字）<br /><br />## 五、输出规范<br />### 内容结构<br /><span>1. 标题：[奖项名称]获奖感言<br /><span>2. 称呼：尊敬的各位领导、亲爱的同事们：<br /><span>3. 正文：按创作流程顺序展开<br /><span>4. 落款：[员工姓名] [日期]<br /><br />### 格式要求<br /><span>1. 使用标准宋体四号字，1.5倍行距<br /><span>2. 关键贡献部分加粗显示<br /><span>3. 感谢对象单独分段<br /><span>4. 结尾部分需包含对公司未来的美好祝愿<br /><br />### 质量标准<br /><span>1. 符合公司文化价值观<br /><span>2. 突出个人贡献同时体现团队精神<br /><span>3. 避免空话套话，用具体事例支撑<br /><span>4. 语言流畅，逻辑清晰，情感真挚<br /><br />## 六、创作示例<br /><span>（此处省略示例内容，实际创作时需根据变量填充）<br /><br /><span>请严格按照以上要求，结合提供的变量信息，创作一篇完整的获奖感言。<br /><br /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>\n<h2><span>调试 Prompt</span></h2>\n<h3><span>文本理解</span></h3>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226230958750-1911894887.png\" /></p>\n<h3><span>视觉理解</span></h3>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226231016417-194421412.png\" /></p>\n<h3><span>多轮对话</span></h3>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226231026956-1766318256.png\" /></p>\n<h2><span>优化 Prompt</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226231045050-1953776592.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226231052086-1099494036.png\" /></p>\n</div>\n<div id=\"MySignature\">\n    <blockquote>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者名称：</span><a href=\"https://www.cnblogs.com/Can-daydayup/\" target=\"_blank\">追逐时光者</a></p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者简介：</span>一个热爱编程、善于分享、喜欢学习、探索、尝试新事物和新技术的全栈软件工程师。</p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\">\n本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。如果该篇文章对您有帮助的话，可以点一下右下角的<a href=\"\" style=\"color: red;\">【♥推荐♥】</a>，希望能够持续的为大家带来好的技术文章，文中可能存在描述不正确的地方，欢迎指正或补充，不胜感激。\n</p>\n</blockquote>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 23:11</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Can-daydayup\">追逐时光者</a>&nbsp;\n阅读(<span id=\"post_view_count\">60</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "go-zero rest 源码学习笔记",
      "link": "https://www.cnblogs.com/xingzheanan/p/19404672",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xingzheanan/p/19404672\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 22:19\">\n    <span>go-zero rest 源码学习笔记</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<hr />\n<h1 id=\"概述\">概述</h1>\n<p><code>go-zero</code> 基于 <code>net/http</code> 标准库实现了一套 <code>rest</code> web 框架。在使用 <code>goctl</code> 快速开发的同时，也需要了解 <code>go-zero</code> 内部做了什么。本文结合 <a href=\"https://zeromicro.github.io/go-zero.dev/docs/component/rest\" rel=\"noopener nofollow\" target=\"_blank\">go-zero rest</a>学习其中的源码，力图做到知其所以然。</p>\n<h1 id=\"源码\">源码</h1>\n<h2 id=\"流程图\">流程图</h2>\n<p><img alt=\"image\" class=\"lazyload\" height=\"650\" width=\"640\" /></p>\n<p>在阅读源码之前，先看下流程图有个印象。从流程图大致可以看出来：</p>\n<ul>\n<li>go-zero 会创建路由组，其中按顺序注册了几类 handler（中间件），最后在 business handler 处理业务逻辑。</li>\n</ul>\n<p>大致有个印象后开始源码走读。</p>\n<h2 id=\"源码走读\">源码走读</h2>\n<p>启动 api 服务：</p>\n<pre><code class=\"language-go\">func main() {  \n    ...\n    server := rest.MustNewServer(c.RestConf)  \n    defer server.Stop()  \n  \n    ctx := svc.NewServiceContext(c)  \n    handler.RegisterHandlers(server, ctx)  \n  \n    fmt.Printf(\"Starting server at %s:%d...\\n\", c.Host, c.Port)  \n    server.Start()  \n}\n</code></pre>\n<p>启动服务主要做了三件事：</p>\n<ul>\n<li>创建服务端 server</li>\n<li>注册 handler 到 server</li>\n<li>启动服务端 server</li>\n</ul>\n<p>按顺序介绍。</p>\n<h3 id=\"创建服务端-server\">创建服务端 server</h3>\n<pre><code class=\"language-go\">func MustNewServer(c RestConf, opts ...RunOption) *Server {  \n    // NewServer 创建 server\n    server, err := NewServer(c, opts...)  \n    if err != nil {  \n       logx.Must(err)  \n    }  \n  \n    return server  \n}\n\nfunc NewServer(c RestConf, opts ...RunOption) (*Server, error) {\n\t// c.SetUp 启动 Prometheus，tracing, profiling 等服务\n    if err := c.SetUp(); err != nil {  \n       return nil, err  \n    }  \n  \n    server := &amp;Server{  \n       ngin:   newEngine(c),  \n       router: router.NewRouter(),  \n    }  \n  \n    ...\n    return server, nil  \n}\n</code></pre>\n<p>创建 server 实际创建的是 server 的 engine 和 router。</p>\n<p>engine 主要结构如下：</p>\n<pre><code class=\"language-go\">type engine struct {  \n    // server 的配置\n    conf   RestConf  \n    routes []featuredRoutes  // 业务路由\n    // 调用链\n    chain                chain.Chain \n    // 中间件 \n    middlewares          []Middleware  \n    ...\n}\n\nfunc newEngine(c RestConf) *engine {  \n    svr := &amp;engine{  \n       conf:    c,  \n       timeout: time.Duration(c.Timeout) * time.Millisecond,  \n    }\n    ...\n}\n</code></pre>\n<p>router 结构如下：</p>\n<pre><code class=\"language-go\">func NewRouter() httpx.Router {  \n    return &amp;patRouter{  \n       trees: make(map[string]*search.Tree),  \n    }  \n}\n\ntype Router interface {  \n    http.Handler  \n    Handle(method, path string, handler http.Handler) error  \n    SetNotFoundHandler(handler http.Handler)  \n    SetNotAllowedHandler(handler http.Handler)  \n}\n</code></pre>\n<p><code>patRouter</code> 包含路由信息，其实现了 <code>Router</code> 接口。</p>\n<p>创建了 server 后还需要注册路由 handler 到 server，这样服务端才能根据路由找到对应的 handler 处理。</p>\n<h3 id=\"注册路由-handler\">注册路由 handler</h3>\n<pre><code class=\"language-go\">func RegisterHandlers(server *rest.Server, serverCtx *svc.ServiceContext) {  \n    // server.AddRoutes 注册路由 handler\n    server.AddRoutes(  \n       []rest.Route{  \n          {  \n             Method:  http.MethodGet,  \n             Path:    \"/ping\",  \n             Handler: pingHandler(serverCtx),  \n          },  \n       },  \n    )\n}\n\nfunc (s *Server) AddRoutes(rs []Route, opts ...RouteOption) {  \n    // 自定义的业务路由将被封装到 featuredRoutes 对象\n    r := featuredRoutes{  \n       routes: rs,  \n    }  \n    for _, opt := range opts {  \n       opt(&amp;r)  \n    }  \n    \n    // 将 featuredRoutes 添加到 Server.engine\n    s.ngin.addRoutes(r)  \n}\n\nfunc (ng *engine) addRoutes(r featuredRoutes) {  \n    ...\n    // 实际是将路由组添加到 engine.routes 中  \n    ng.routes = append(ng.routes, r) \n}\n</code></pre>\n<p>业务路由注册完，接下来将进入启动 server，这是需要关注的重点。</p>\n<h3 id=\"启动-server\">启动 server</h3>\n<pre><code class=\"language-go\">func (s *Server) Start() {  \n    // 调用 Server.engine.start 启动服务端 server\n    handleError(s.ngin.start(s.router))  \n}\n\nfunc (ng *engine) start(router httpx.Router, opts ...StartOption) error {     // engine.bindRoutes 绑定路由到 router\n    if err := ng.bindRoutes(router); err != nil {  \n       return err  \n    }  \n\n    ...\n    return internal.StartHttps(ng.conf.Host, ng.conf.Port, ng.conf.CertFile,  \n       ng.conf.KeyFile, router, opts...)  \n}\n\nfunc (ng *engine) bindRoutes(router httpx.Router) error {  \n    // engine.routes \n    for _, fr := range ng.routes {  \n       // 绑定 rest.featuredRoutes \n       if err := ng.bindFeaturedRoutes(router, fr, metrics); err != nil { \n          return err  \n       }  \n    }  \n  \n    return nil  \n}\n\nfunc (ng *engine) bindFeaturedRoutes(router httpx.Router, fr featuredRoutes, metrics *stat.Metrics) error {  \n    ...\n    for _, route := range fr.routes {  \n       if err := ng.bindRoute(fr, router, metrics, route, verifier); err != nil {  \n          return err  \n       }  \n    }  \n  \n    return nil  \n}\n\nfunc (ng *engine) bindRoute(fr featuredRoutes, router httpx.Router, metrics *stat.Metrics,  \n    route Route, verifier func(chain.Chain) chain.Chain) error {  \n    // engine.chain，初始化为 nil\n    chn := ng.chain  \n    if chn == nil {  \n       // engine.buildChainWithNativeMiddlewares 注册自带中间件到 engine.chain\n       chn = ng.buildChainWithNativeMiddlewares(fr, route, metrics)  \n    }  \n  \n    // 添加 AuthHandler 到 engine.chain 中\n    chn = ng.appendAuthHandler(fr, chn, verifier)  \n  \n    // 将自定义中间件注册到 engine.chain\n    for _, middleware := range ng.middlewares {  \n       chn = chn.Append(convertMiddleware(middleware))  \n    }  \n    \n    // engine.chain.ThenFunc 将 handler 串联成 handler\n    handle := chn.ThenFunc(route.Handler)  \n  \n    return router.Handle(route.Method, route.Path, handle)  \n}\n</code></pre>\n<p>启动 server 的重点在 <code>engine.bindRoute</code>。<br />\n其中，<code>engine.buildChainWithNativeMiddlewares</code> 注册 <code>go-zero</code> 自带中间件：</p>\n<pre><code class=\"language-go\">func (ng *engine) buildChainWithNativeMiddlewares(fr featuredRoutes, route Route,  \n    metrics *stat.Metrics) chain.Chain {  \n    chn := chain.New()\n    ...\n    // MaxConns 用于并发控制\n    if ng.conf.Middlewares.MaxConns {  \n        chn = chn.Append(handler.MaxConnsHandler(ng.conf.MaxConns))  \n    }  \n    if ng.conf.Middlewares.Breaker {  \n        chn = chn.Append(handler.BreakerHandler(route.Method, route.Path, metrics))  \n    }\n    ...\n}\n</code></pre>\n<p>类似的，自定义中间件通过 <code>chn.Append(convertMiddleware(middleware))</code> 注册到 <code>engine.chain</code> 中。</p>\n<p>接着调用 <code>chain.ThenFunc</code> 串联中间件成 <code>handler</code>：</p>\n<pre><code class=\"language-go\">func (c chain) ThenFunc(fn http.HandlerFunc) http.Handler {  \n    ...\n    return c.Then(fn)  \n}\n\nfunc (c chain) Then(h http.Handler) http.Handler {  \n    if h == nil {  \n       h = http.DefaultServeMux  \n    }  \n  \n    // 这段代码很有意思，它将所有中间件按顺序串联起来组成一个 handler\n    // 调用这个 handler 处理时会经过后续一系列的中间件，最终到业务 handler 处理\n    // 具体可参考 https://github.com/zeromicro/go-zero/blob/master/rest/chain/chain.go#L81\n    for i := range c.middlewares {  \n       h = c.middlewares[len(c.middlewares)-1-i](h)  \n    }  \n  \n    return h  \n}\n</code></pre>\n<p>最后将该 handler 和路由信息注册到 <code>router</code> 中，后续服务端根据请求在 <code>router</code> 中查找对应的 <code>handler</code> 处理。</p>\n<pre><code class=\"language-go\">func (pr *patRouter) Handle(method, reqPath string, handler http.Handler) error {  \n    ...\n    \n    tree, ok := pr.trees[method]  \n    if ok {  \n       return tree.Add(cleanPath, handler)  \n    }  \n  \n    tree = search.NewTree()  \n    pr.trees[method] = tree  \n    return tree.Add(cleanPath, handler)  \n}\n</code></pre>\n<p>详细流程如下图：</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"570\" width=\"661\" /></p>\n<h1 id=\"小结\">小结</h1>\n<p>本文介绍了 go-zero rest 的源码是怎么处理请求的。从源码也可以看出每个请求背后是一系列中间件 handler 在处理，并且 server 启动了 Prometheus，Trace 等服务负责监控，链路追踪等，使得开发微服务时只需要关注业务逻辑即可，非常方便。</p>\n<h1 id=\"参考资料\">参考资料</h1>\n<ul>\n<li><a href=\"https://zeromicro.github.io/go-zero.dev/docs/component/rest\" rel=\"noopener nofollow\" target=\"_blank\">go-zero rest</a></li>\n<li><a href=\"https://refactoringguru.cn/design-patterns/chain-of-responsibility/go/example\" rel=\"noopener nofollow\" target=\"_blank\">Go 责任链模式</a></li>\n</ul>\n<hr />\n\n</div>\n<div id=\"MySignature\">\n    芝兰生于空谷，不以无人而不芳。\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 22:19</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xingzheanan\">胡云Troy</a>&nbsp;\n阅读(<span id=\"post_view_count\">27</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "迈向 MCP 集群化：Solon AI （支持 Java8+）在解决 MCP 服务可扩展性上的探索与实践",
      "link": "https://www.cnblogs.com/noear/p/19406655",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/noear/p/19406655\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 21:15\">\n    <span>迈向 MCP 集群化：Solon AI （支持 Java8+）在解决 MCP 服务可扩展性上的探索与实践</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        Solon AI v3.8推出STREAMABLE_STATELESS通道，解决MCP服务集群化难题。该无状态设计放弃反向调用功能，采用短链接通讯，实现真正的水平扩展能力。同时新增CompletableFuture和Publisher异步支持，提升IO密集型任务处理效率。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>随着 Model Context Protocol (MCP) 的快速普及，开发者已经不再满足于简单的本地 Stdio 进程通讯。在生产环境中，如何构建高可用、可水平扩展的 MCP 服务集群成为了核心挑战。</p>\n<p>Solon AI 在最近的 v3.8 版本更新中，针对 MCP 服务集群化痛点，推出了一系列重磅特性，特别是 STREAMABLE_STATELESS（无状态流传输） 通道的引入，为 MCP 迈向云原生集群时代铺平了道路。</p>\n<h2 id=\"一-mcp-集群化的拦路虎状态依赖\">一、 MCP 集群化的拦路虎：状态依赖</h2>\n<p>传统的 MCP 传输协议（如 SSE 或标准的 STREAMABLE）通常是有状态的。</p>\n<h3 id=\"1-为什么有状态难以集群\">1. 为什么“有状态”难以集群？</h3>\n<p>在 MCP 协议中，为了支持反向调用（Server 调用 Client 的采样请求 Sampling）或原语变更通知（Notifications），Server 和 Client 之间必须建立长链接。</p>\n<ul>\n<li>连接绑定：Client 的短链接请求（发送指令）必须与长链接（接收通知）路由到同一台服务器。</li>\n<li>运维复杂：在负载均衡器（如 Nginx）上，必须配置 ip_hash 或粘性会话（Sticky Sessions），否则请求会因为找不到上下文而失败。</li>\n</ul>\n<h3 id=\"2-solon-ai-的解题思路\">2. Solon AI 的解题思路</h3>\n<p>Solon AI v3.8 引入了 McpChannel.STREAMABLE_STATELESS，其核心理念是：放弃不常用的反向调用，换取极致的水平扩展能力。</p>\n<h2 id=\"二-核心突破streamable_stateless-通道\">二、 核心突破：STREAMABLE_STATELESS 通道</h2>\n<p>这是 Solon AI 为集群友好性专门设计的模式。它通过将长链接转变为短链接通讯，彻底消除了服务端的状态依赖。</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>STREAMABLE (有状态)</th>\n<th>STREAMABLE_STATELESS (无状态)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>链接类型</td>\n<td>有长链接 (Long Connection)</td>\n<td>只用短链接 (Short Connection)</td>\n</tr>\n<tr>\n<td>集群路由</td>\n<td>需要 ip_hash</td>\n<td>任意路由</td>\n</tr>\n<tr>\n<td>反向通讯</td>\n<td>支持 (Server -&gt; Client)</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>需要实时监控 Tool 变化的复杂应用</td>\n<td>80% 的标准工具调用、高并发集群</td>\n</tr>\n</tbody>\n</table>\n<p>开发者体验一致性： 无论底层通道如何变化，Solon AI 的开发代码几乎不需要修改，仅需在注解中切换 channel：</p>\n<pre><code class=\"language-java\">@McpServerEndpoint(channel = McpChannel.STREAMABLE_STATELESS, mcpEndpoint = \"/mcp/weather\")\npublic class McpServerTool {\n    @ToolMapping(description = \"查询天气预报\")\n    public String getWeather(@Param(description = \"城市位置\") String location) {\n        return \"晴，14度\";\n    }\n}\n</code></pre>\n<h2 id=\"三-异步性能优化completablefuture-与-publisher\">三、 异步性能优化：CompletableFuture 与 Publisher</h2>\n<p>在集群环境下，IO 密集型任务（如请求第三方 API）如果阻塞线程，会极大降低集群的吞吐量。Solon AI v3.8.0 全面增强了 异步支持。</p>\n<h3 id=\"1-completablefuture-支持\">1. CompletableFuture 支持</h3>\n<p>现在，MCP 工具可以直接返回异步结果，完美适配现代 Java 的异步编程模型：</p>\n<pre><code class=\"language-java\">@ToolMapping(description = \"异步查询天气\", returnDirect = true)\npublic CompletableFuture&lt;String&gt; getWeatherAsync(String location) {\n    return CompletableFuture.supplyAsync(() -&gt; \"异步返回：多云\");\n}\n</code></pre>\n<h3 id=\"2-响应式流支持\">2. 响应式流支持</h3>\n<p>针对更高级的场景，Solon AI 适配了 org.reactivestreams.Publisher，使得 MCP 工具、资源（Resource）和提示词（Prompt）都能以非阻塞的方式工作。</p>\n<pre><code class=\"language-java\">@ToolMapping(description = \"异步查询天气\", returnDirect = true)\npublic Publisher&lt;String&gt; getWeatherAsync(String location) {\n    return Mono.just(\"异步返回：多云\");\n}\n</code></pre>\n<h2 id=\"四-传输方式全景对比\">四、 传输方式全景对比</h2>\n<p>Solon AI 目前支持四种主流传输通道，覆盖了从本地到云端的全场景：</p>\n<table>\n<thead>\n<tr>\n<th>服务端通道</th>\n<th>客户端通道</th>\n<th>通讯方式</th>\n<th>集群友好度</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>STDIO</td>\n<td>STDIO</td>\n<td>进程间管道</td>\n<td>N/A</td>\n<td>本地开发首选</td>\n</tr>\n<tr>\n<td>SSE</td>\n<td>SSE</td>\n<td>HTTP</td>\n<td>需 ip_hash</td>\n<td>官方已标记弃用</td>\n</tr>\n<tr>\n<td>STREAMABLE</td>\n<td>STREAMABLE</td>\n<td>HTTP</td>\n<td>需 ip_hash</td>\n<td>用于替代 SSE</td>\n</tr>\n<tr>\n<td>STREAMABLE_STATELESS</td>\n<td>STREAMABLE</td>\n<td>HTTP</td>\n<td>极高</td>\n<td>集群推荐</td>\n</tr>\n</tbody>\n</table>\n<p>注意：使用 STREAMABLE_STATELESS 时，客户端依然配置为 STREAMABLE 即可，服务端会自动处理握手降级。</p>\n<h2 id=\"五-总结与展望\">五、 总结与展望</h2>\n<p>Solon AI 通过对 MCP 协议的深度解耦，不仅实现了对最新 2025-06-18 版本协议的支持，更通过无状态通道和全链路异步化，解决了 MCP 服务在大规模并发下的“落地难”问题。</p>\n<p>对于追求高性能和易扩展的 AI 应用架构师来说，Solon AI 提供了一套“开发一致、部署灵活”的工具链，让 MCP 服务真正具备了工业级集群的能力。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 21:15</span>&nbsp;\n<a href=\"https://www.cnblogs.com/noear\">带刺的坐椅</a>&nbsp;\n阅读(<span id=\"post_view_count\">28</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一篇基于AWS服务搭建的全球服务架构",
      "link": "https://www.cnblogs.com/linnuo/p/19388428",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/linnuo/p/19388428\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 19:37\">\n    <span>一篇基于AWS服务搭建的全球服务架构</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>一、背景</p>\n<p>　　当我们在做全球业务时，例如网站/机器/游戏，为了支撑全球用户，我们会在不同的位置搭建节点，以满足业务功能和响应实效。</p>\n<p>我们会搭建一个这样的架构满足初步的使用。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>&nbsp;　　</p>\n<p>　　能用是ok的了，会有什么问题呢？</p>\n<p>　　1、因为服务独立，上架1个SKU需要多次发布到不同的服务。</p>\n<p>　　2、因为域名过多，发布时需要频繁的退出、登录切换不同的二级域名，非常繁琐不说，还可能会遗漏。</p>\n<p>　　3、后期处理数据统计、报表、看板、设备地图，耗时费力。</p>\n<p>　　4、这还是单节点，未考虑高可用的情况下，多区域、多节点部署服务器导致运维难度增加、过多的财务开支。</p>\n<div>\n<div>　　5、各个节点各玩各的。</div>\n<div>&nbsp;</div>\n<div>　　有什么方式可以解决这些问题？</div>\n<div>　　AWS服务组件很好支持。</div>\n<div>&nbsp;</div>\n<div>二、AWS架构</div>\n<div>　　AWS提供了非常丰富的组件，列几个常用的：</div>\n<div>　　1、Route 53 负责域名解析流量管理健康检查，高可用可以用到它。</div>\n<div>　　2、VPC 虚拟私有网络，可将同一区域的服务器、数据库置于同一内网段，提升访问速度。</div>\n<div>　　3、CloudFront CDN加速，可以给访问请求、对象存储加速。函数功能极其强大，可配置HTTP、HTTPS的请求跨域，可识别全球流量来源，根据来源分发到不同区域的节点。</div>\n<div>　　4、EC2 服务器，内含了负载均衡器ELB、目标组，可实现同一地区的服务器的负载均衡和高可用。结合CloudFront可将流量分发到就近的服务。</div>\n<div>　　5、Aurora and RDS 数据库，Aurora 作为全球数据库，已实现主从备份，可在1s内实现全球数据同步，结合Route 53的短域名实现读写分离。</div>\n<div>　　6、S3 对象存储，OSS存储图片、视频、文档、音频等。</div>\n<div>　　7、Certificate Manager 安全凭证管理，可申请和管理证书。</div>\n<div>&nbsp;</div>\n<div>　　架构完是这样的。&nbsp;</div>\n<div>&nbsp;\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>&nbsp;</p>\n<p>三、干活，简单的一笔带过</p>\n<p>　　1、将外部域名解析到Route 53。</p>\n<p>　　2、在Certificate Manager申请证书。</p>\n<p>　　3、在拟定的区域创建VPC内网。</p>\n<p>　　4、购买服务器和数据库时选择上面的创建的VPC内网。</p>\n<p>　　5、在创建Aurora数据库时需要选确认某一个区域为主集群，主集群下会创建写入器实例、读取器实例。</p>\n<p>　　　　再创建其它区域的读取实例，如下图：</p>\n<p><img alt=\"f9edbdf666a249221b20525d951cdf3b\" class=\"lazyload\" /></p>\n<p>&nbsp;　　</p>\n<p>　　6、在Route 53创建一个私有的短域名，用于数据库连接，无需在域名供应商购买。我这里用&nbsp;db.com</p>\n<p><img alt=\"402ddedc223507ba4f2e187ad161cc2c\" class=\"lazyload\" /></p>\n<p>&nbsp;　</p>\n<p>　　7、将二级域名指向到Aurora的写域名指向到Aurora的写入器实例的DNS（路由策略：简单），</p>\n<p>　　　　读域名指向到多个读取器实例的DNS（路由策略：延迟）。数据写入到主库后，1s内可同步到所有的从库</p>\n<p><img alt=\"fe4075fd22ed2a0e1e2919b9d2e47b5b\" class=\"lazyload\" /></p>\n<p>&nbsp;　　</p>\n<p>　　8、在EC2购买服务器后，新建目标组，将服务器添加到目标组中</p>\n</div>\n<div>\n<p><img alt=\"b9e98fda4ad55cabc5a3bd5d55ff112f\" class=\"lazyload\" /></p>\n<p>&nbsp;　　</p>\n<p>　　9、在EC2创建负载均衡器，这里分NLB（服务器之间用）和ELB（服务器内部服务之间用），层级和颗粒度不同。</p>\n<p>　　　　这里创建NLB，添加转发到的目标组到侦听器，注意选择VPC。创建完即可通过DNS访问。</p>\n<p><img alt=\"5baa9287044b30796f6ebb020436d6f6\" class=\"lazyload\" /></p>\n<p>&nbsp;　　</p>\n<p>　　10、创建CloudFront，将需要经过CDN加速的域名添加到备用域名，添加第2步创建的证书，源添加到访问目标的DNS。成功后CloudFront会分配域名。</p>\n<p><img alt=\"aeaa7964-4abc-47f7-965c-b70c4dee3682\" class=\"lazyload\" /></p>\n<p>&nbsp;</p>\n<p>　　11、在Route 53将经过CloudFront加速的域名指向到CloudFront分配域名上。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>&nbsp;</p>\n<p>　　12、在Route 53创建NLB的健康检查，成功后生成ID。</p>\n<p>　　13、在Route 53添加故障转移域名，用于服务区域之间的高可用，无需额外采购服务器</p>\n<p><img alt=\"98eb6d3e-2d4c-4a8f-97f9-6261ccbfc409\" class=\"lazyload\" /></p>\n<p>&nbsp;</p>\n<p>　　14、在CloudFront创建函数，将请求按照国家和地区分发到相应的服务器。</p>\n<p><img alt=\"5b4907ff50b14eae080e4168c566cd54\" class=\"lazyload\" /></p>\n<p>&nbsp;　　代码如下：</p>\n<div class=\"cnblogs_code\">\n<pre>import cf from 'cloudfront'<span style=\"color: rgba(0, 0, 0, 1);\">;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">function</span><span style=\"color: rgba(0, 0, 0, 1);\"> handler(event) {\n    const request </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> event.request;\n    const headers </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> request.headers;\n    const country </span>= headers['cloudfront-viewer-country'] &amp;&amp; headers['cloudfront-viewer-country'<span style=\"color: rgba(0, 0, 0, 1);\">].value;\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> List of countries to ALB endpoints</span>\n    const countryToContinent =<span style=\"color: rgba(0, 0, 0, 1);\"> {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 亚太地区 (Asia-Pacific) -&gt; Asia</span>\n        'AF': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AM': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AZ': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BD': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BN': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BT': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CC': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CK': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CX': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GE': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'HK': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ID': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'IN': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'IO': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'JP': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KG': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KH': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KR': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KZ': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LA': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LK': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MM': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MN': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MO': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MP': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MV': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MY': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NC': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NF': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NP': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NR': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NU': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NZ': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PH': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PK': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PN': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SB': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SG': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TH': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TJ': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TL': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TM': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TO': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TV': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TW': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'UZ': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'VU': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'WF': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'WS': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'YE': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 大洋洲 (Oceania) - 通常归类为亚太地区</span>\n        'AS': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AU': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'FJ': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PF': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GU': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KI': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MH': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'FM': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PW': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PG': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TK': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 南极洲 (Antarctica) - 通常单独处理，这里暂时归入亚太</span>\n        'AQ': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BV': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GS': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'HM': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TF': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 欧洲、非洲、中东 -&gt; Europe</span>\n        'AL': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AD': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AT': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AX': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BA': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BG': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BY': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CH': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CY': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CZ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'DE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'DK': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'EE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ES': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'FI': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'FO': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'FR': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GG': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GI': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GR': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'HR': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'HU': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'IE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'IM': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'IS': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'IT': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'JE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LI': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LT': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LU': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LV': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MC': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MD': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ME': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MK': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MT': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NL': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NO': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PL': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PT': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'RO': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'RS': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'RU': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SI': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SJ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SK': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SM': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'UA': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'VA': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GB': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'DZ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AO': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BJ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BW': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BF': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BI': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CV': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CM': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CF': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TD': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KM': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CG': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CD': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CI': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'DJ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'EG': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GQ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ER': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ET': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GA': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GM': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GH': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GN': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GW': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LS': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LR': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LY': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MG': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MW': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ML': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MR': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MU': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'YT': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MA': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MZ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NA': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NG': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'RW': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'RE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SH': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SN': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SC': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SL': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SO': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ZA': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SS': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SD': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ST': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SZ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TG': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TN': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TZ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'UG': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'EH': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ZM': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ZW': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BH': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'IR': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'IQ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'IL': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'JO': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KW': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LB': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'OM': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PS': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'QA': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SA': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SY': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TR': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 美洲 -&gt; America</span>\n        'AI': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AG': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AW': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BS': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BB': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BZ': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BM': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BQ': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CA': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KY': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CR': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CU': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CW': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'DM': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'DO': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SV': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GD': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GL': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GP': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GT': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'HT': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'HN': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'JM': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MQ': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MX': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MS': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NI': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PA': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PR': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BL': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KN': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LC': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MF': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PM': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'VC': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SX': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TT': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TC': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'US': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'UM': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'UY': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'VE': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'VG': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'VI': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">\n    };\n\n    const continentToRegion </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> {\n        </span>'Asia': 'asia.autovxxxxxx.com',         <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 亚洲故障转移域名</span>\n        'Europe': 'europu.autovxxxxxx.com',     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 欧洲故障转移域名</span>\n        'America': 'america.autovxxxxxxx.com'    <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 美洲故障转移域名</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    };\n\n    const DEFAULT_REGION </span>= 'NLB-Asia-Singapore-5e42xxxxxxxx4853.elb.ap-southeast-1.amazonaws.com'; <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">改为自己的默认alb 域名</span>\n    const targetContinent = (country &amp;&amp; countryToContinent[country]) || 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">;\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> const targetContinent = 'Asia';</span>\n    const targetOrigin = (targetContinent &amp;&amp; continentToRegion[targetContinent]) ||<span style=\"color: rgba(0, 0, 0, 1);\"> DEFAULT_REGION;\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 打印所有请求头</span>\n    console.log(\"=== 所有请求头信息 ===\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> headerName <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> headers) {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (headers.hasOwnProperty(headerName)) {\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> headers 对象的值是一个包含 'value' 属性的对象</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">var</span> headerValue =<span style=\"color: rgba(0, 0, 0, 1);\"> headers[headerName].value;\n            console.log(headerName </span>+ \": \" +<span style=\"color: rgba(0, 0, 0, 1);\"> headerValue);\n        }\n    }\n    console.log(</span>'targetOrigin: ' +<span style=\"color: rgba(0, 0, 0, 1);\"> targetOrigin);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 使用CloudFront 2.0 API修改origin</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    cf.updateRequestOrigin({\n        </span>\"domainName\"<span style=\"color: rgba(0, 0, 0, 1);\">: targetOrigin,\n        </span>\"port\": 80<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>\"protocol\": 'http'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>\"timeouts\"<span style=\"color: rgba(0, 0, 0, 1);\">: {\n            </span>\"readTimeout\": 30<span style=\"color: rgba(0, 0, 0, 1);\">,\n            </span>\"connectionTimeout\": 5<span style=\"color: rgba(0, 0, 0, 1);\">\n        }\n    });\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 添加调试信息 - 确保值是字符串</span>\n    request.headers['x-debug-country'] = { value: String(country || 'unknown'<span style=\"color: rgba(0, 0, 0, 1);\">) };\n    request.headers[</span>'x-debug-targetorigin'] =<span style=\"color: rgba(0, 0, 0, 1);\"> { value: String(targetOrigin) };\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> request;\n}</span></pre>\n</div>\n<p>　　解决跨域问题，函数代码如下：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">function</span><span style=\"color: rgba(0, 0, 0, 1);\"> handler(event)  {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> response  =<span style=\"color: rgba(0, 0, 0, 1);\"> event.response;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> headers  =<span style=\"color: rgba(0, 0, 0, 1);\"> response.headers;\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> If Access-Control-Allow-Origin CORS header is missing, add it.</span>\n    <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Since JavaScript doesn't allow for hyphens in variable names, we use the dict[\"key\"] notation.</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!headers['access-control-allow-origin'<span style=\"color: rgba(0, 0, 0, 1);\">]) {\n        headers[</span>'access-control-allow-origin'] = {value: \"*\"<span style=\"color: rgba(0, 0, 0, 1);\">};\n        console.log(</span>\"Access-Control-Allow-Origin was missing, adding it now.\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        headers[</span>'access-control-allow-headers'] = {value: \"Origin, X-Requested-With, Content-Type, Accept\"<span style=\"color: rgba(0, 0, 0, 1);\">};\n        headers[</span>'access-control-allow-methods'] = {value: \"GET,POST,PUT, OPTIONS\"<span style=\"color: rgba(0, 0, 0, 1);\">};\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> response;\n}</span></pre>\n</div>\n<p>　　</p>\n<p>　　ok，完事儿</p>\n<p>　　</p>\n<p>&nbsp;</p>\n&nbsp;</div>\n<div>&nbsp;</div>\n<div>&nbsp;</div>\n<div>&nbsp;</div>\n<div>&nbsp;</div>\n<div>&nbsp;</div>\n<div>&nbsp;</div>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 19:37</span>&nbsp;\n<a href=\"https://www.cnblogs.com/linnuo\">ooLeo</a>&nbsp;\n阅读(<span id=\"post_view_count\">39</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "大模型榜单周报（2025/12/27）",
      "link": "https://www.cnblogs.com/xjk15082/p/19408692",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xjk15082/p/19408692\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 13:22\">\n    <span>大模型榜单周报（2025/12/27）</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"1-本周概览\">1. 本周概览</h2>\n<p>本周大模型领域持续涌现创新成果，数学、编程和多模态能力均出现显著进展。字节推出数学模型Seed Prover 1.5，在国际数学奥林匹克竞赛中取得金牌线成绩，而智谱AI开源GLM-4.7在多项评测中超越GPT-5.1。MiniMax的M2.1编码模型以10B激活参数创下多语言软件工程能力新高，北航提出的代码模型Scaling Laws为最优数据配比提供理论基础。</p>\n<h2 id=\"2-重点关注事件\">2. 重点关注事件</h2>\n<ul>\n<li>字节发布数学模型Seed Prover 1.5，在16.5小时内解决IMO 2025前5道题目，失一题获得35分达到金牌线；在北美本科级别数学竞赛Putnam上大幅刷新SOTA成绩</li>\n<li>智谱AI开源GLM-4.7，在AIME 25和人类最后考试（HLE）等基准中分数超GPT-5.1；SWE-Bench分数达73.8%（+5.8%），创开源新高</li>\n<li>MiniMax发布旗舰级Coding &amp; Agent模型M2.1，在Multi-SWE-bench榜单中以仅10B激活参数拿下49.4%成绩，超越Claude Sonnet 4.5等顶尖竞品，拿下全球SOTA</li>\n<li>北航提出代码大模型的Scaling Laws，建立区分语言特性的Scaling Laws，并提出数学可解的最优数据配比方案，覆盖0.2B到14B参数规模及高达1T训练数据量，对七种主流语言进行系统性解构</li>\n</ul>\n<h2 id=\"3-榜单变化\">3. 榜单变化</h2>\n<ul>\n<li>OpenRouter模型调用量：Grok Code Fast 1、Claude Sonnet 4.5、Gemini 2.5 Flash位列前三；小米MiMo-V2-Flash (free)新晋第4名；Gemini 3 Flash Preview新晋第6名；编程调用量方面，Grok Code Fast 1保持第1，KAT-Coder-Pro V1 (free)上升3名至第3，GPT-5.2下降5名至第7位</li>\n<li>OpenRouter公司市占率：Google保持第1；xAI、Anthropic紧随其后；OpenAI市占率下降7.2%（17.7% → 10.5%）至第4位；DeepSeek份额上升1.8%（7.8% → 9.6%）保持第5名；小米份额占比7.0%，位列第7</li>\n<li>大语言模型（Text Arena）：gemini-3-flash刷新成绩，超过Grok 4.1 thinking位列第2；ernie-5.0-preview-1203新晋第13名，超过gpt-5.2（评分基于预发布测试）</li>\n<li>编程能力榜单（WebDev Arena）：glm-4.7新晋第6名，紧跟gemini-3-flash之后（评分基于预发布测试）</li>\n<li>编程能力榜单（LiveCodeBench GSO Leaderboard）：Gemini-3-Flash新晋第8名，排名在O4-mini之后</li>\n<li>图像编辑能力（Artificial Analysis Image Editing Leaderboard）：Reve V1新晋第8名，排名在Flux 2 Pro之后</li>\n<li>文生图榜单（Artificial Analysis Text to Image Leaderboard）：ImagineArt 1.5 Preview超过Imagen 4 Preview位列第10名</li>\n<li>前沿数学能力（EPOCH AI FrontierMath）：DeepSeek-V3.2以22.1%得分超过Kimi K2 Thinking位列第14名</li>\n<li>GAIA榜单：SU Zero-Shuqian Series Pro MAX新晋榜首</li>\n</ul>\n<h2 id=\"4-openrouter排行榜\">4. OpenRouter排行榜</h2>\n<table>\n<thead>\n<tr>\n<th>测评类型</th>\n<th>第一名</th>\n<th>第二名</th>\n<th>第三名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>模型调用量</td>\n<td>Grok Code Fast 1</td>\n<td>Claude Sonnet 4.5</td>\n<td>Gemini 2.5 Flash</td>\n</tr>\n<tr>\n<td>公司市占率</td>\n<td>Google</td>\n<td>xAI</td>\n<td>Anthropic</td>\n</tr>\n<tr>\n<td>编程模型调用量</td>\n<td>Grok Code Fast 1</td>\n<td>GPT-5.2</td>\n<td>Claude Sonnet 4.5</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"各公司按不同能力领域排名汇总\">各公司按不同能力领域排名汇总</h3>\n<table>\n<thead>\n<tr>\n<th>测评类型</th>\n<th>领先公司</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>大语言模型 Text Arena</td>\n<td>Google、xAI、Anthropic、OpenAI、阿里巴巴、百度、月之暗面、智谱</td>\n</tr>\n<tr>\n<td>编程能力 LMArena</td>\n<td>Anthropic、OpenAI、Google</td>\n</tr>\n<tr>\n<td>编程能力 LiveCodeBench</td>\n<td>OpenAI、Anthropic、Google</td>\n</tr>\n<tr>\n<td>代码工程任务能力 SWE-benchLite</td>\n<td>基于Claude、Gemini、GPT、Qwen、DeepSeek开发的开源系统</td>\n</tr>\n<tr>\n<td>图像编辑和生成能力 Image Edit Arena</td>\n<td>OpenAI、Google、字节、Reve</td>\n</tr>\n<tr>\n<td>文生图能力 Text-to-Image Arena</td>\n<td>OpenAI、Google、Black Forest Labs、腾讯、字节</td>\n</tr>\n<tr>\n<td>图像编辑和生成能力 Image Editing Leaderboard</td>\n<td>OpenAI、Google、Black Forest Labs、字节、Pruna AI</td>\n</tr>\n<tr>\n<td>文生图能力 Text to Image Leaderboard</td>\n<td>OpenAI、Google、Black Forest Labs、字节</td>\n</tr>\n<tr>\n<td>GPQA</td>\n<td>OpenAI、Google、xAI、Anthropic、阿里巴巴</td>\n</tr>\n<tr>\n<td>FrontierMath</td>\n<td>OpenAI、Google、月之暗面、Anthropic、xAI</td>\n</tr>\n<tr>\n<td>Humanity's Last Exam</td>\n<td>Google、OpenAI、Anthropic</td>\n</tr>\n<tr>\n<td>GAIA</td>\n<td>Microsoft AI Asia -Ads、Suzhou AI Lab&amp;Shuqian Tech、LR AILab of Lenovo CTO Org、NVIDIA、ZTE-AICloud、JoinAI、ShawnAgent、AIP agent等</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<p>关注我，第一时间掌握更多AI前沿资讯！</p>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-27 13:22</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xjk15082\">KAI智习</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": ".NET 数据摄取与向量化架构：构建企业级检索增强生成（RAG）管道",
      "link": "https://www.cnblogs.com/shanyou/p/19408104",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/shanyou/p/19408104\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 10:52\">\n    <span>.NET 数据摄取与向量化架构：构建企业级检索增强生成（RAG）管道</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"1-摘要\"><strong>1. 摘要</strong></h2>\n<p>随着生成式人工智能（Generative AI）技术的迅猛发展，企业级应用开发正经历着一场深刻的范式转变。传统的事务处理系统正在向基于大语言模型（LLM）的智能系统演进，其中检索增强生成（RAG）架构已成为解决模型幻觉、利用私有数据以及保持知识时效性的关键技术方案。在这一背景下，微软推出的 Microsoft.Extensions.DataIngestion 和 Microsoft.Extensions.VectorData 库，不仅是.NET AI 生态系统的重要补充，更是标志着从实验性 AI 开发迈向工程化、标准化 AI 数据管道的关键里程碑。</p>\n<p>我们将深入探讨“统一文档表示”（Unified Document Representation）如何解决非结构化数据处理的异构性难题，剖析 IngestionPipeline 在流式处理和错误恢复方面的设计智慧，评估基于 Microsoft.ML.Tokenizers 的语义分块策略对检索质量的深远影响，并详细阐述 Microsoft.Extensions.VectorData 如何通过统一抽象层消除向量数据库的锁定风险。此外，本文还将对比 Semantic Kernel 的传统内存存储机制，提供从遗留系统向现代化架构迁移的路径指引。</p>\n<h2 id=\"2-引言net-ai-生态系统的工程化转折\"><strong>2. 引言：.NET AI 生态系统的工程化转折</strong></h2>\n<h3 id=\"21-数据管道工程的崛起\"><strong>2.1 数据“管道工程”的崛起</strong></h3>\n<p>在生成式 AI 应用的早期探索阶段，开发者往往将注意力集中在提示词工程（Prompt Engineering）和模型选择上。然而，随着应用规模的扩大，业界逐渐意识到，决定 RAG 系统成败的核心因素往往不在于模型的参数量，而在于供给模型的数据质量。数据摄取（Data Ingestion）——即从原始源获取数据、清洗、分块、嵌入并存储的过程——成为了 AI 应用中的“管道工程”。</p>\n<p>在.NET 生态系统中，过去缺乏一套统一的标准来处理这一复杂的 ETL（Extract, Transform, Load）流程。开发者不得不依赖零散的第三方库来解析 PDF，手写逻辑来切分文本，并硬编码特定向量数据库的 SDK。这种碎片化的开发模式导致了代码的高耦合、低复用以及维护困难。Microsoft.Extensions.DataIngestion 的推出，正是为了填补这一空白，它提供了一套标准化的原语，使数据处理像 ASP.NET Core 中的依赖注入或日志记录一样，成为一种基础设施能力2。</p>\n<h3 id=\"22-模块化与解耦的设计哲学\"><strong>2.2 模块化与解耦的设计哲学</strong></h3>\n<p>微软此次推出的构建模块遵循了高度模块化和解耦的设计哲学。与封闭的“黑盒”解决方案不同，这些库被设计为一系列可组合的原子组件。</p>\n<ul>\n<li><strong>读取器（Readers）</strong>：负责屏蔽数据源的差异，无论是本地文件、云存储还是内存流，都被规范化为统一的格式。</li>\n<li><strong>处理器（Processors）</strong>：充当管道中的中间件，利用 AI 能力对数据进行增强，如自动生成摘要或提取关键词。</li>\n<li><strong>分块器（Chunkers）</strong>：基于精确的 Token 计算策略，将长文档切分为适合 LLM 上下文窗口的片段。</li>\n<li><strong>写入器（Writers）</strong>：处理数据的持久化，特别是向向量数据库的写入 1。</li>\n</ul>\n<p>这种设计不仅提高了代码的可测试性，还赋予了开发者极大的灵活性。例如，开发者可以轻松地替换底层的向量数据库，而无需重写上层的数据处理逻辑；或者在管道中插入自定义的隐私清洗步骤，而不影响后续的嵌入生成。这种架构的弹性，是构建“未来就绪”（Future-ready）AI 应用的基石。</p>\n<h2 id=\"3-统一文档表示异构数据的标准化治理\"><strong>3. 统一文档表示：异构数据的标准化治理</strong></h2>\n<p>在 RAG 系统中，数据源的多样性是一个巨大的挑战。企业知识库中混杂着 PDF 报告、Word 文档、HTML 网页、Markdown 笔记以及各种图像文件。如果针对每种格式都编写独立的解析和处理逻辑，系统将变得极其臃肿且难以维护。Microsoft.Extensions.DataIngestion 库通过引入 <strong>统一文档表示（Unified Document Representation）</strong> 的概念，从根本上解决了这一问题。</p>\n<h3 id=\"31-ingestiondocument-对象模型深度解析\"><strong>3.1 IngestionDocument 对象模型深度解析</strong></h3>\n<p>核心类 IngestionDocument 是所有异构数据在内存中的统一投影。该设计的一个关键架构决策是采用了 <strong>以 Markdown 为中心（Markdown-centric）</strong> 的表示形式 1。</p>\n<h4 id=\"311-为什么选择-markdown\"><strong>3.1.1 为什么选择 Markdown？</strong></h4>\n<p>选择 Markdown 作为中间格式并非偶然，而是基于对大语言模型特性的深刻理解。现代 LLM（如 GPT-4, Llama 3）在其预训练阶段接触了大量的代码和 Markdown 文档，因此它们对 Markdown 的结构（标题、列表、代码块、引用）具有天然的理解能力。</p>\n<p>相比于纯文本（Plain Text），Markdown 保留了文档的层级结构信息，这对于后续的“语义分块”至关重要。相比于 HTML 或 XML，Markdown 的 Token 密度更高，噪音更少，更适合作为 Prompt 的一部分输入给模型。因此，将所有源文档转换为 Markdown 结构的 IngestionDocument，实际上是在进行一种“面向 AI 的数据清洗”，最大化了模型理解数据结构的能力 2。</p>\n<h4 id=\"312-结构化组件详解\"><strong>3.1.2 结构化组件详解</strong></h4>\n<p>IngestionDocument 并非一个简单的字符串容器，而是一个包含丰富结构化信息的对象图。库中定义了一系列子类来精确描述文档的不同部分：</p>\n<ul>\n<li>IngestionDocumentSection（文档节）：<br />\n这是文档的高层逻辑划分，通常对应于 PDF 的页面、书的章节或 PPT 的幻灯片。保留这种物理或逻辑的分隔对于后续实现“按页引用”或“按章节检索”至关重要。例如，在法律文档检索场景中，用户往往希望知道引用的具体条款位于哪一页，IngestionDocumentSection 提供的上下文信息恰好满足这一需求 3。</li>\n<li>IngestionDocumentHeader（文档标题）：<br />\n该类捕获了文档的骨架（H1, H2, H3...）。在 RAG 检索中，标题往往概括了其下段落的核心语义。通过识别标题，分块策略（Chunking Strategy）可以更智能地决定切分点，避免将一个完整的语义块（如一个子章节）错误地切断。</li>\n<li>IngestionDocumentParagraph（文档段落）：<br />\n这是文本内容的原子单元。它承载了实际的信息负载。</li>\n<li>IngestionDocumentTable（文档表格）：<br />\n表格数据的处理是 RAG 中的难点。简单的文本提取往往会破坏表格的行列对齐，导致模型无法理解数据关系。IngestionDocumentTable 试图在对象模型层面保留表格的结构化特征，使得在转换为最终的 Prompt 时，可以重构出 Markdown 表格，从而让 LLM 能够正确地进行行读取或列对比 3。</li>\n<li>IngestionDocumentImage（文档图像）：<br />\n在多模态 RAG 场景中，图像不再是黑洞。该类不仅存储图像的二进制数据或引用路径，更重要的是它为后续的 AI 增强（如自动生成 Alt Text）预留了位置。这使得管道能够处理图文混排的文档，将图像信息转化为向量空间可检索的文本描述 3。</li>\n</ul>\n<h3 id=\"32-读取器抽象与实现策略\"><strong>3.2 读取器抽象与实现策略</strong></h3>\n<p>IngestionDocumentReader 是负责将外部原始数据转换为 IngestionDocument 的抽象基类。微软提供了一系列开箱即用的实现，同时也支持开发者扩展。</p>\n<h4 id=\"321-内置读取器分析\"><strong>3.2.1 内置读取器分析</strong></h4>\n<ul>\n<li>MarkdownReader：<br />\n这是最基础的读取器，直接处理现有的 Markdown 文件。它不需要复杂的转换逻辑，是处理技术文档库（如 GitHub Wiki）的理想选择 3。</li>\n<li>MarkItDownReader：<br />\n这是一个功能强大的读取器，集成了微软的 MarkItDown 工具。它能够处理 Office 格式（Word, Excel, PowerPoint）、PDF 以及其他常见格式，并将它们“降维”打击为统一的 Markdown 格式。对于企业环境中的大量遗留文档，MarkItDownReader 是连接传统 IT 资产与现代 AI 系统的桥梁 3。</li>\n<li>MarkItDownMcpReader：<br />\n引入了对 模型上下文协议（Model Context Protocol, MCP） 服务器的支持。这是一个前瞻性的设计，表明该库准备好与更广泛的 AI 代理生态系统集成，允许通过标准协议跨进程或跨网络边界解析文档 3。</li>\n</ul>\n<h4 id=\"322-数据库摄取的挑战与自定义\"><strong>3.2.2 数据库摄取的挑战与自定义</strong></h4>\n<p>尽管文件系统的读取器非常丰富，但在实际的企业应用中，大量高价值数据存储在 SQL Server、CMS 或 NoSQL 数据库中。目前的预览版中，IngestionDocumentReader 的设计在处理非文件源时存在一定的局限性。开发者社区反馈指出，当前的接口设计倾向于文件流，使得直接从数据库记录映射到 IngestionDocument 需要一些额外的适配工作 7。</p>\n<p>为了解决这个问题，开发者通常需要实现自定义的 IngestionDocumentReader。这个自定义读取器不读取文件路径，而是接收数据库的主键 ID，在内部查询数据库，提取文本字段，并手动构建 IngestionDocument 对象。这体现了库的扩展性，同时也揭示了当前版本在“非文件”场景下的改进空间。</p>\n<h2 id=\"4-数据摄取管道架构流式弹性与中间件\"><strong>4. 数据摄取管道架构：流式、弹性与中间件</strong></h2>\n<p>IngestionPipeline&lt;T&gt; 类是整个数据处理流程的指挥官。它不仅负责按顺序调用组件，还封装了复杂的并发控制、错误处理和资源管理逻辑。</p>\n<h3 id=\"41-管道组合与依赖注入\"><strong>4.1 管道组合与依赖注入</strong></h3>\n<p>IngestionPipeline 的构造遵循了依赖注入（DI）的最佳实践。它要求在实例化时注入核心组件：Reader, Chunker, Writer。这种设计使得管道本身是无状态的，且高度可配置。</p>\n<p>// 管道实例化代码结构示例<br />\nusing IngestionPipeline&lt;string&gt; pipeline = new(<br />\nreader,<br />\nchunker,<br />\nwriter,<br />\nloggerFactory: loggerFactory)<br />\n{<br />\n// 配置文档级处理器（中间件）<br />\nDocumentProcessors = { imageAlternativeTextEnricher },</p>\n<pre><code>// 配置分块级处理器（中间件）  \nChunkProcessors \\= { summaryEnricher }   \n</code></pre>\n<p>};</p>\n<p>通过属性初始化器（Object Initializer）配置 DocumentProcessors 和 ChunkProcessors 的方式，类似于 ASP.NET Core 中的中间件管道构建。这允许开发者在核心流程的前后插入任意数量的自定义逻辑，例如在分块前进行 PII（个人敏感信息）清洗，或者在分块后进行关键词提取。</p>\n<h3 id=\"42-流式处理机制iasyncenumerable\"><strong>4.2 流式处理机制（IAsyncEnumerable）</strong></h3>\n<p>在处理大规模语料库（如数百万份合同文件）时，内存管理是首要挑战。IngestionPipeline.ProcessAsync 方法的设计充分考虑了这一点，它返回 IAsyncEnumerable&lt;IngestionResult&gt;。</p>\n<p>这种设计意味着管道是 <strong>流式（Streaming）</strong> 执行的。系统不会一次性将所有文档加载到内存中，而是采用“拉取”模式：处理完一个文档，释放相关内存，再处理下一个。这使得在有限内存的容器环境中运行大规模 ETL 任务成为可能。下游的消费端（Consumer）可以通过 await foreach 逐个获取处理结果，实现实时的进度反馈或即时的索引更新。</p>\n<h3 id=\"43-弹性设计部分成功模式\"><strong>4.3 弹性设计：部分成功模式</strong></h3>\n<p>在分布式系统和大规模批处理任务中，<strong>部分故障</strong> 是常态。某个特定的 PDF 文件可能损坏，或者某个网络调用（如调用 OpenAI API 生成摘要）可能超时。</p>\n<p>IngestionPipeline 采用了“部分成功”的设计模式。单个文档的处理失败不会导致整个管道抛出异常并终止。相反，管道会捕获该文档处理过程中的异常，将其封装在 IngestionResult 对象中（包含 Succeeded 布尔标志和 DocumentId），并记录错误日志，然后继续处理下一个文档 1。</p>\n<p>这种设计对于长时间运行的后台任务至关重要。它确保了 99.9% 的正常文档能够被正确索引，而那 0.1% 的失败文档可以通过日志被识别并单独重试，极大地提高了系统的整体可用性和鲁棒性。</p>\n<h3 id=\"44-泛型-t-的意义\"><strong>4.4 泛型 T 的意义</strong></h3>\n<p>值得注意的是 IngestionPipeline&lt;T&gt; 中的泛型 T。虽然最常见的场景是 T 为 string（处理文本数据），但这种泛型设计为未来留出了空间。理论上，它可以支持 IngestionChunk&lt;Image&gt; 或其他多模态数据类型，只要相应的 Chunker 和 Writer 支持该类型。这体现了库设计者对未来多模态 AI 场景的预判。</p>\n<h2 id=\"5-分块策略与分词技术rag-性能的决定性因素\"><strong>5. 分块策略与分词技术：RAG 性能的决定性因素</strong></h2>\n<p>如果说数据是 RAG 的燃料，那么分块（Chunking）就是炼油的过程。分块的质量直接决定了检索的准确率（Recall）和生成的精确度（Precision）。Microsoft.Extensions.DataIngestion 在这方面提供了基于深厚算法基础的解决方案。</p>\n<h3 id=\"51-microsoftmltokenizers精确度的基石\"><strong>5.1 Microsoft.ML.Tokenizers：精确度的基石</strong></h3>\n<p>传统的分块往往基于字符数（例如每 1000 个字符切一刀）。然而，LLM 的上下文窗口是基于 <strong>Token</strong> 计数的。中文字符、英文字母、特殊符号在 Token 化后的长度差异巨大。简单的字符切分往往会导致实际 Token 数超出模型限制，或者造成 Token 空间的浪费。</p>\n<p>Microsoft.Extensions.DataIngestion 构建在 Microsoft.ML.Tokenizers 之上 。这是一个高性能的分词库，支持 BPE (Byte Pair Encoding) 等主流分词算法，包括 GPT-4 使用的 cl100k_base 编码。</p>\n<p>这意味着管道中的分块操作是 <strong>Token 感知（Token-Aware）</strong> 的。当配置 MaxTokensPerChunk = 2000 时，库会确保切分出的片段在经过特定模型（如 GPT-4）的分词器编码后，严格不超过 2000 个 Token。这种精确控制对于最大化利用上下文窗口、防止 API 调用报错至关重要。</p>\n<h3 id=\"52-三大分块策略深度剖析\"><strong>5.2 三大分块策略深度剖析</strong></h3>\n<p>库提供了三种主要的分块器实现，分别对应不同的数据特征和业务需求。</p>\n<h4 id=\"521-headerchunker基于标题的分块\"><strong>5.2.1 HeaderChunker（基于标题的分块）</strong></h4>\n<ul>\n<li><strong>工作机制</strong>：利用 IngestionDocument 中的 IngestionDocumentHeader 信息，沿着文档的标题层级（H1 -&gt; H2 -&gt; H3）进行切分。</li>\n<li><strong>适用场景</strong>：结构化极强的文档，如用户手册、API 文档、法律法规。这些文档的每一节通常讲述一个独立的主题。</li>\n<li><strong>优势</strong>：语义边界清晰，极大降低了断章取义的风险。它尊重了原作者的逻辑组织。</li>\n<li><strong>局限</strong>：如果文档缺乏标题结构，或者某一节内容过长（超过 Token 限制），该策略可能效果不佳或退化为强制切分。</li>\n</ul>\n<h4 id=\"522-sectionchunker基于节的分块\"><strong>5.2.2 SectionChunker（基于节的分块）</strong></h4>\n<ul>\n<li><strong>工作机制</strong>：基于 IngestionDocumentSection 进行切分，通常对应于物理页面或逻辑章节 。</li>\n<li><strong>适用场景</strong>：扫描版 PDF 处理，或者像 PPT 这样每一页内容相对独立的文档。</li>\n<li><strong>优势</strong>：便于实现“原文定位”，用户可以看到检索结果来自“第 5 页”。</li>\n</ul>\n<h4 id=\"523-semanticsimilaritychunker基于语义相似度的分块\"><strong>5.2.3 SemanticSimilarityChunker（基于语义相似度的分块）</strong></h4>\n<p>这是最智能、也是最具技术含量的分块策略。</p>\n<ul>\n<li>\n<p>工作机制：<br />\n该分块器不仅仅是看结构，而是看“意思”。它利用嵌入模型（Embedding Model）对正在处理的句子生成向量，并计算当前句子与前文上下文的 余弦相似度（Cosine Similarity）。当相似度分数突然下降时，意味着话题发生了转移（Topic Shift），分块器就会在此处“下刀”切分 1。</p>\n</li>\n<li>\n<p><strong>配置选项 (IngestionChunkerOptions)</strong>：</p>\n<ul>\n<li>MaxTokensPerChunk：硬性上限，即使话题没有结束，达到此长度也会强制切分，防止溢出。</li>\n<li>OverlapTokens：重叠窗口。在切分点前后保留一定数量的 Token（例如 50 个），确保上下文的连续性，避免切断跨句子的指代关系 9。</li>\n</ul>\n</li>\n<li>\n<p><strong>代码实现细节</strong>：<br />\n// 实例化分词器<br />\nvar tokenizer = TiktokenTokenizer.CreateForModel(\"gpt-4\");</p>\n<p>// 配置选项<br />\nIngestionChunkerOptions chunkerOptions = new(tokenizer)<br />\n{<br />\nMaxTokensPerChunk = 2000,<br />\nOverlapTokens = 50<br />\n};</p>\n<p>// 实例化语义分块器，注入嵌入生成器<br />\nIngestionChunker&lt;string&gt; chunker = new SemanticSimilarityChunker(<br />\nembeddingGenerator,<br />\nchunkerOptions);</p>\n</li>\n<li>\n<p><strong>适用场景</strong>：会议记录、长篇叙事文章、散文、对话记录等缺乏明确标题结构的流式文本。</p>\n</li>\n<li>\n<p><strong>优势</strong>：生成的块具有高度的语义内聚性（Cohesion），检索出来的片段往往是一个完整的话题，极大地提升了 RAG 的回答质量。</p>\n</li>\n</ul>\n<p><strong>6. 智能增强层：从 ETL 到 AI-ETL</strong></p>\n<p>单纯的文本切分只是第一步。为了让数据更容易被检索，Microsoft.Extensions.DataIngestion 引入了 <strong>AI 增强（AI Enrichment）</strong> 的概念。通过在管道中插入由 LLM 驱动的处理器，可以在数据入库前对其进行“智力加工”。</p>\n<h3 id=\"61-内置丰富器enrichers详解\"><strong>6.1 内置丰富器（Enrichers）详解</strong></h3>\n<p>这些丰富器实现了 IngestionChunkProcessor&lt;T&gt; 或 IngestionDocumentProcessor 接口，可以直接插入管道。</p>\n<ol>\n<li><strong>SummaryEnricher（摘要丰富器）</strong>\n<ul>\n<li><strong>功能</strong>：对每个分块（Chunk）调用 LLM 生成一段简短的摘要 1。</li>\n<li><strong>架构价值</strong>：\n<ul>\n<li><strong>双路检索</strong>：系统可以同时索引原始文本和摘要。有时候用户的查询更匹配摘要的概括性描述，而不是原文的细节。</li>\n<li><strong>上下文压缩</strong>：在生成阶段，如果上下文窗口紧张，可以只将摘要发送给 LLM，而不是原始的长文本。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>KeywordEnricher（关键词丰富器）</strong>\n<ul>\n<li><strong>功能</strong>：分析分块内容，提取出关键实体（Entities）或术语 1。</li>\n<li><strong>架构价值</strong>：支持 <strong>混合检索（Hybrid Search）</strong>。向量检索擅长语义匹配，但对于专有名词（如产品型号“X-2000”）可能不够精确。通过提取关键词并存储在元数据中，可以在查询时结合倒排索引（关键词匹配）和向量索引，大幅提升召回率。</li>\n</ul>\n</li>\n<li><strong>ImageAlternativeTextEnricher（图像描述丰富器）</strong>\n<ul>\n<li><strong>功能</strong>：调用多模态模型（如 GPT-4 Vision）分析文档中的图片，生成文本描述（Alt Text）4。</li>\n<li><strong>架构价值</strong>：填补了传统文本 RAG 的盲区。使得图片内容变得“可搜索”。例如，用户搜索“Q3 销售趋势”，系统可以通过图片的 Alt Text 检索到包含趋势图的幻灯片页面。</li>\n</ul>\n</li>\n<li><strong>SentimentEnricher（情感分析丰富器）</strong>\n<ul>\n<li><strong>功能</strong>：判断文本的情感倾向（积极、消极、中性）3。</li>\n<li><strong>架构价值</strong>：为数据打上情感标签。在客户服务场景中，可以利用此元数据过滤出“愤怒的客户反馈”优先处理。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"62-自定义增强与中间件模式\"><strong>6.2 自定义增强与中间件模式</strong></h3>\n<p>除了内置丰富器，开发者可以轻松实现自定义逻辑。例如，编写一个 PiiRedactionEnricher，利用 Microsoft.Extensions.AI 的能力识别并掩盖文本中的身份证号或手机号。这种中间件模式使得数据管道不仅是传输数据的通道，更是执行数据治理、隐私合规和知识挖掘的核心场所。</p>\n<h2 id=\"7-向量存储抽象microsoftextensionsvectordata\"><strong>7. 向量存储抽象：Microsoft.Extensions.VectorData</strong></h2>\n<p>数据经过清洗、分块和增强后，最终需要存入数据库。Microsoft.Extensions.VectorData 库通过提供一套统一的抽象层，解决了向量数据库市场的碎片化问题 。</p>\n<h3 id=\"71-ivectorstore-接口统一的-crud-与检索\"><strong>7.1 IVectorStore 接口：统一的 CRUD 与检索</strong></h3>\n<p>核心接口 IVectorStore 及其相关组件（IVectorStoreRecordCollection）定义了与向量数据库交互的标准契约。这意味着上层应用逻辑不需要关心底层是 Qdrant、Redis 还是 SQL Server。</p>\n<p>主要功能包括：</p>\n<ul>\n<li><strong>Schema 定义</strong>：通过 VectorStoreRecordDefinition 或属性标签（Attributes）定义数据模型，指定哪些字段是主键（Key）、数据（Data）或向量（Vector）15。</li>\n<li><strong>CRUD 操作</strong>：标准的增删改查 API。</li>\n<li><strong>向量搜索</strong>：支持余弦相似度、欧几里得距离等多种度量方式。</li>\n<li><strong>混合搜索与过滤</strong>：支持结合元数据过滤（例如 Category == 'Report'）的向量搜索 15。</li>\n</ul>\n<h3 id=\"72-vectorstorewriter智能写入器\"><strong>7.2 VectorStoreWriter：智能写入器</strong></h3>\n<p>VectorStoreWriter&lt;T&gt; 是连接摄取管道与存储层的桥梁。它不仅仅是一个简单的 DAO（Data Access Object），还包含了一些关键的业务逻辑：</p>\n<ol>\n<li>自动嵌入生成（Automatic Embedding Generation）：<br />\n如果在管道中只传递了文本分块而没有生成向量，VectorStoreWriter 可以配置一个 IEmbeddingGenerator。在写入数据库之前，它会自动调用嵌入模型生成向量。这大大简化了管道配置，将嵌入生成的责任委托给了写入阶段 4。</li>\n<li>增量更新与幂等性：<br />\n在 RAG 系统中，文档经常会被修改和重新上传。VectorStoreWriter 实现了智能的更新逻辑：在写入新分块之前，它会根据文档 ID 删除该文档旧版本的所有分块。这确保了数据库中不会残留过期的、导致幻觉的旧数据片段（Orphaned Chunks），保证了知识库的时效性和一致性 8。</li>\n</ol>\n<h3 id=\"73-广泛的连接器生态\"><strong>7.3 广泛的连接器生态</strong></h3>\n<p>得益于与 Semantic Kernel 团队的紧密合作，Microsoft.Extensions.VectorData 在发布之初就拥有了丰富的连接器支持。这些连接器以 Microsoft.SemanticKernel.Connectors.* 的形式发布，但实现了新的 VectorData 接口 17。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">支持的向量存储</th>\n<th style=\"text-align: left;\">NuGet 包名称</th>\n<th style=\"text-align: left;\">典型应用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>Qdrant</strong></td>\n<td style=\"text-align: left;\">Microsoft.SemanticKernel.Connectors.Qdrant</td>\n<td style=\"text-align: left;\">高性能、生产级开源向量数据库</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Azure AI Search</strong></td>\n<td style=\"text-align: left;\">Microsoft.SemanticKernel.Connectors.AzureAISearch</td>\n<td style=\"text-align: left;\">企业级、全托管、支持混合检索</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Redis</strong></td>\n<td style=\"text-align: left;\">Microsoft.SemanticKernel.Connectors.Redis</td>\n<td style=\"text-align: left;\">极低延迟的实时检索场景</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>PostgreSQL</strong></td>\n<td style=\"text-align: left;\">Microsoft.SemanticKernel.Connectors.PgVector</td>\n<td style=\"text-align: left;\">关系型数据与向量数据混合存储</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>SQLite</strong></td>\n<td style=\"text-align: left;\">Microsoft.SemanticKernel.Connectors.SqliteVec</td>\n<td style=\"text-align: left;\">本地开发、边缘计算、离线应用</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Azure Cosmos DB</strong></td>\n<td style=\"text-align: left;\">Microsoft.SemanticKernel.Connectors.Cosmos*</td>\n<td style=\"text-align: left;\">大规模分布式存储</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>InMemory</strong></td>\n<td style=\"text-align: left;\">Microsoft.SemanticKernel.Connectors.InMemory</td>\n<td style=\"text-align: left;\">单元测试、快速原型验证</td>\n</tr>\n</tbody>\n</table>\n<p><strong>特别是 SQLite 连接器 (SqliteVec)</strong>：这是一个非常重要的补充。它利用 sqlite-vec 扩展，使得.NET 开发者可以在没有任何外部数据库依赖的情况下，在本地构建全功能的 RAG 应用。这对于移动应用、桌面应用或开发测试环境具有巨大的价值 4。</p>\n<h2 id=\"8-与-semantic-kernel-的融合与迁移\"><strong>8. 与 Semantic Kernel 的融合与迁移</strong></h2>\n<p>对于现有的 Semantic Kernel (SK) 用户，这套新库代表了未来的方向。</p>\n<h3 id=\"81-从-memory-到-vectordata-的演进\"><strong>8.1 从 Memory 到 VectorData 的演进</strong></h3>\n<p>在早期的 Semantic Kernel 版本中，向量存储是通过 Microsoft.SemanticKernel.Memory.IMemoryStore 接口管理的。这个旧抽象存在一些设计上的局限性，例如强制固定的 Schema（ID, Text, Vector），难以支持复杂的元数据过滤或自定义的数据结构。</p>\n<p>新的 Microsoft.Extensions.VectorData.IVectorStore 提供了更泛型、更灵活的设计：</p>\n<ul>\n<li>支持自定义 POCO (Plain Old CLR Object) 作为记录模型。</li>\n<li>支持更复杂的查询和过滤语法。</li>\n<li>解耦了 Semantic Kernel 的核心编排逻辑，使其可以独立使用 20。</li>\n</ul>\n<h3 id=\"82-迁移指南\"><strong>8.2 迁移指南</strong></h3>\n<p>微软明确建议开发者迁移到新的抽象层。迁移的主要工作包括：</p>\n<ol>\n<li><strong>包替换</strong>：将旧的 Microsoft.SemanticKernel.Connectors.* 包升级到最新版本。</li>\n<li><strong>代码重构</strong>：将依赖 IMemoryStore 的代码改为依赖 IVectorStore。</li>\n<li><strong>命名空间更新</strong>：注意包名和类名的变化，例如 Sqlite 连接器更名为 SqliteVec，以明确其使用了向量扩展 。</li>\n</ol>\n<p>Semantic Kernel 团队已经完成了底层工作，确保新版本的 SK 连接器完全实现了 VectorData 抽象，因此对于使用 SK 高级功能的开发者，这种底层替换是相对平滑的 14。</p>\n<h2 id=\"9-实战案例分析net-ai-chat-模板\"><strong>9. 实战案例分析：.NET AI Chat 模板</strong></h2>\n<p>为了展示这些构建模块的综合运用，微软发布了 <strong>.NET AI Chat Template</strong> (dotnet new aichatweb)。这是一个参考架构，展示了如何将上述所有组件串联起来构建一个端到端的 RAG 应用 。</p>\n<h3 id=\"91-架构流程解析\"><strong>9.1 架构流程解析</strong></h3>\n<p>该模板项目演示了一个典型的 RAG 工作流：</p>\n<ol>\n<li><strong>数据源层</strong>：\n<ul>\n<li>模板默认包含 PDF 示例文件，位于 /wwwroot/Data 目录。</li>\n<li>使用 PDFReader (基于 MarkItDown) 将 PDF 解析为 IngestionDocument。</li>\n</ul>\n</li>\n<li><strong>处理管道层</strong>：\n<ul>\n<li>构建 IngestionPipeline。</li>\n<li>应用 SemanticSimilarityChunker 对文本进行智能分块。</li>\n<li>使用 Microsoft.Extensions.AI 进行嵌入生成。</li>\n</ul>\n</li>\n<li><strong>存储层</strong>：\n<ul>\n<li>默认配置使用 SqliteVectorStore 进行本地存储，方便开发者“开箱即用”而无需配置云资源。</li>\n<li>同时也支持通过配置切换到 Azure AI Search 进行生产部署 23。</li>\n</ul>\n</li>\n<li><strong>应用层</strong>：\n<ul>\n<li>基于 Blazor 的前端界面。</li>\n<li>后端服务接收用户提问，通过 IVectorStore 检索相关分块。</li>\n<li>将检索到的上下文注入到 Prompt 中，调用 Chat Client 生成回答。</li>\n<li>支持“引用跟踪”，即在回答中标记出信息来源（引用了哪个文件的哪一段）23。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"92-定制与扩展\"><strong>9.2 定制与扩展</strong></h3>\n<p>该模板不仅是一个示例，更是一个脚手架。开发者可以通过简单的配置修改（如更换 Vector Store 提供商），或者通过代码扩展（如添加自定义的 IngestionDocumentProcessor 来处理特定行业的文档格式）来快速构建垂直领域的 AI 应用。例如，结合 Auth0 等身份认证服务，可以在检索层实现基于用户权限的文档隔离（Document-level Authorization），确保数据安全 25。</p>\n<h2 id=\"10-结论\"><strong>10. 结论</strong></h2>\n<p>Microsoft.Extensions.DataIngestion 和 Microsoft.Extensions.VectorData 的发布，不仅仅是几个 NuGet 包的更新，它代表了.NET 在 AI 时代的自我革新。</p>\n<p>通过提供 <strong>统一的文档对象模型</strong>，微软解决了数据源异构的痛点；通过 <strong>流式管道架构</strong>，解决了大规模数据处理的性能瓶颈；通过 <strong>语义分块与 AI 增强</strong>，提升了 RAG 系统的智能高度；通过 <strong>标准化的向量存储抽象</strong>，构建了开放且兼容的数据库生态。</p>\n<p>对于企业架构师而言，这意味着现在可以使用成熟、类型安全且高性能的 C# 代码来构建复杂的 AI 数据基础设施，而不再需要依赖不熟悉的 Python 工具链或不稳定的实验性脚本。随着.NET 10 的临近以及 AI 生态的持续演进，掌握这些构建模块将成为每一位.NET 开发者的核心竞争力。现在，正是构建下一代智能应用的最佳时机。</p>\n<h4 id=\"引用的著作\"><strong>引用的著作</strong></h4>\n<ol>\n<li>Introducing Data Ingestion Building Blocks (Preview) - .NET Blog <a href=\"https://devblogs.microsoft.com/dotnet/introducing-data-ingestion-building-blocks-preview/\" rel=\"noopener nofollow\" target=\"_blank\">https://devblogs.microsoft.com/dotnet/introducing-data-ingestion-building-blocks-preview/</a></li>\n<li>Data ingestion - .NET | Microsoft Learn,<a href=\"https://learn.microsoft.com/en-us/dotnet/ai/conceptual/data-ingestion\" rel=\"noopener nofollow\" target=\"_blank\">https://learn.microsoft.com/en-us/dotnet/ai/conceptual/data-ingestion</a></li>\n<li>Microsoft.Extensions.DataIngestion Namespace, <a href=\"https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dataingestion?view=net-10.0-pp\" rel=\"noopener nofollow\" target=\"_blank\">https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dataingestion?view=net-10.0-pp</a></li>\n<li>Microsoft.Extensions.DataIngestion.MarkItDown 10.1.1-preview.1.25612.2</li>\n<li><a href=\"https://libraries.io/nuget/Microsoft.Extensions.DataIngestion.MarkItDown\" rel=\"noopener nofollow\" target=\"_blank\">https://libraries.io/nuget/Microsoft.Extensions.DataIngestion.MarkItDown</a></li>\n<li>Using IngestionPipeline for content not originating from the file system · Issue #7082 · dotnet/extensions <a href=\"https://github.com/dotnet/extensions/issues/7082\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/dotnet/extensions/issues/7082</a></li>\n<li>Luis Quintanilla, Author at .NET Blog - Microsoft Developer Blogs, <a href=\"https://devblogs.microsoft.com/dotnet/author/luquinta/feed/\" rel=\"noopener nofollow\" target=\"_blank\">https://devblogs.microsoft.com/dotnet/author/luquinta/feed/</a></li>\n<li>IngestionChunkerOptions.OverlapTokens Property <a href=\"https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dataingestion.ingestionchunkeroptions.overlaptokens?view=net-10.0-pp\" rel=\"noopener nofollow\" target=\"_blank\">https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dataingestion.ingestionchunkeroptions.overlaptokens?view=net-10.0-pp</a></li>\n<li>SummaryEnricher Class (Microsoft.Extensions.DataIngestion) <a href=\"https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dataingestion.summaryenricher?view=net-10.0-pp\" rel=\"noopener nofollow\" target=\"_blank\">https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dataingestion.summaryenricher?view=net-10.0-pp</a></li>\n<li>KeywordEnricher Class (Microsoft.Extensions.DataIngestion) <a href=\"https://learn.microsoft.com/dotnet/api/microsoft.extensions.dataingestion.keywordenricher\" rel=\"noopener nofollow\" target=\"_blank\">https://learn.microsoft.com/dotnet/api/microsoft.extensions.dataingestion.keywordenricher</a></li>\n<li>KeywordEnricher Class (Microsoft.Extensions.DataIngestion) <a href=\"https://learn.microsoft.com/ko-kr/dotnet/api/microsoft.extensions.dataingestion.keywordenricher?view=net-10.0-pp\" rel=\"noopener nofollow\" target=\"_blank\">https://learn.microsoft.com/ko-kr/dotnet/api/microsoft.extensions.dataingestion.keywordenricher?view=net-10.0-pp</a></li>\n<li>Introducing Microsoft.Extensions.VectorData Preview - .NET Blog <a href=\"https://devblogs.microsoft.com/dotnet/introducing-microsoft-extensions-vector-data/\" rel=\"noopener nofollow\" target=\"_blank\">https://devblogs.microsoft.com/dotnet/introducing-microsoft-extensions-vector-data/</a></li>\n<li>Microsoft.Extensions.VectorData.Abstractions: Now Available | Semantic Kernel <a href=\"https://devblogs.microsoft.com/semantic-kernel/microsoft-extensions-vectordata-abstractions-now-available/\" rel=\"noopener nofollow\" target=\"_blank\">https://devblogs.microsoft.com/semantic-kernel/microsoft-extensions-vectordata-abstractions-now-available/</a></li>\n<li>Microsoft.Extensions.VectorData.Abstractions 9.7.0 - NuGet,<a href=\"https://www.nuget.org/packages/Microsoft.Extensions.VectorData.Abstractions/\" rel=\"noopener nofollow\" target=\"_blank\">https://www.nuget.org/packages/Microsoft.Extensions.VectorData.Abstractions/</a></li>\n<li>Vector Store changes ， <a href=\"https://learn.microsoft.com/en-us/semantic-kernel/support/migration/vectorstore-april-2025\" rel=\"noopener nofollow\" target=\"_blank\">https://learn.microsoft.com/en-us/semantic-kernel/support/migration/vectorstore-april-2025</a></li>\n<li>Vector Data Extensions are now Generally Available (GA) | Semantic Kernel <a href=\"https://devblogs.microsoft.com/semantic-kernel/vector-data-extensions-are-now-generally-available-ga/\" rel=\"noopener nofollow\" target=\"_blank\">https://devblogs.microsoft.com/semantic-kernel/vector-data-extensions-are-now-generally-available-ga/</a></li>\n<li>NET AI Template Now Available in Preview - Microsoft Dev Blogs,<a href=\"https://devblogs.microsoft.com/dotnet/announcing-dotnet-ai-template-preview1/\" rel=\"noopener nofollow\" target=\"_blank\">https://devblogs.microsoft.com/dotnet/announcing-dotnet-ai-template-preview1/</a></li>\n<li>Preview 2 of the .NET AI Template Now Available - Microsoft Dev Blogs, 访问时间为 十二月 25, 2025， <a href=\"https://devblogs.microsoft.com/dotnet/announcing-dotnet-ai-template-preview2/\" rel=\"noopener nofollow\" target=\"_blank\">https://devblogs.microsoft.com/dotnet/announcing-dotnet-ai-template-preview2/</a></li>\n<li>Quickstart - Create a .NET AI app using the AI app template <a href=\"https://learn.microsoft.com/en-us/dotnet/ai/quickstarts/ai-templates\" rel=\"noopener nofollow\" target=\"_blank\">https://learn.microsoft.com/en-us/dotnet/ai/quickstarts/ai-templates</a></li>\n<li>Secure a .NET RAG System with Auth0 FGA, <a href=\"https://auth0.com/blog/secure-dotnet-rag-system-with-auth0-fga/\" rel=\"noopener nofollow\" target=\"_blank\">https://auth0.com/blog/secure-dotnet-rag-system-with-auth0-fga/</a></li>\n<li>Build a .NET AI vector search app - Microsoft Learn <a href=\"https://learn.microsoft.com/en-us/dotnet/ai/quickstarts/build-vector-search-app\" rel=\"noopener nofollow\" target=\"_blank\">https://learn.microsoft.com/en-us/dotnet/ai/quickstarts/build-vector-search-app</a></li>\n</ol>\n\n</div>\n<div id=\"MySignature\">\n    <p>欢迎大家扫描下面二维码成为我的客户，扶你上云</p>\n<img src=\"https://images.cnblogs.com/cnblogs_com/shanyou/57459/o_220125090408_%E9%82%80%E8%AF%B7%E4%BA%8C%E7%BB%B4%E7%A0%81-258px.jpeg\" width=\"170\" />\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-27 10:52</span>&nbsp;\n<a href=\"https://www.cnblogs.com/shanyou\">张善友</a>&nbsp;\n阅读(<span id=\"post_view_count\">25</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}