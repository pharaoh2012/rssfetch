{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "[大模型实战 03预备] 云端炼丹房 2：Kaggle 上手指南",
      "link": "https://www.cnblogs.com/algieba/p/19576331",
      "published": "",
      "description": "<div class=\"postcontent\">\n\t\t\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"[大模型实战 03预备] 云端炼丹房 2：Kaggle 上手指南\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3169973/202602/3169973-20260204195327324-384345256.png\" />\n        Colab 额度用完了？Kaggle 带着两张 T4 显卡来了！本文详解 Kaggle 账号手机验证、开启 Internet 联网、配置双 T4 GPU 环境，以及如何利用 Kaggle 特有的 Dataset 机制持久化保存 HuggingFace 模型。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"大模型实战-03预备-云端炼丹房-2kaggle-上手指南\">[大模型实战 03预备] 云端炼丹房 2：Kaggle 上手指南</h1>\n<blockquote>\n<p><strong>核心摘要 (TL;DR)</strong></p>\n<ul>\n<li><strong>痛点</strong>：Colab 免费额度耗尽，或者单张 T4 显存（16GB）无法满足更大参数模型的微调需求。</li>\n<li><strong>方案</strong>：利用 <strong>Kaggle</strong> 提供的 <strong>每周 30 小时免费双路 T4 GPU (T4 x2)</strong> 算力。</li>\n<li><strong>技巧</strong>：通过 <strong>手机号验证</strong> 解锁联网权限，利用 <strong>Kaggle Datasets</strong> 实现模型的持久化存储。</li>\n<li><strong>目标</strong>：作为 Colab 的强力替补（甚至上位），搭建备用云端炼丹环境。</li>\n</ul>\n</blockquote>\n<h2 id=\"前言\">前言</h2>\n<p>上一篇中，本来想直接写到Google Colab的大模型推理脚本，让各位友人们感受一下在全参数7B模型的能力，但是折腾了很久，Colab读driver老是失败，当我想直接下载到云端主机而不是driver的时候，GPU的额度已经耗尽。索性今天在Kaggle的这篇博文中来讲，应该之后也主要用Kaggle来进行云端开发，毕竟Colab额度少，还得盯着，长时间不看会断掉连接。</p>\n<p>好，我们来先介绍一下今天的主角，Google 旗下的另一个神器：<a href=\"https://www.kaggle.com/\" rel=\"noopener nofollow\" target=\"_blank\"><strong>Kaggle</strong></a>。Colab如果说其本职就是模型训练，那<strong>Kaggle</strong>本身其实是一个数据科学的竞赛平台，毕竟是数据科学竞赛嘛，那自然得需要算力资源，<strong>Kaggle</strong>为了方便，也发挥了谷歌大善人的优良品质，免费提供了大方的计算资源。跟Colab对比起来，Kaggle的优势就是，更稳定，更方便，资源给的额度更多。</p>\n<h2 id=\"1-kaggle-notebooks-核心概念\">1. Kaggle Notebooks 核心概念</h2>\n<p>Kaggle 的核心编程环境叫 <strong>Kernels (现在统称 Notebooks)</strong>,不用害怕，诶，它就是我们昨儿刚认识的熟人<strong>云端服务器版</strong>的<strong>Jupyter Notebook</strong>,但是和Colab不太相同的是Kaggle的文件结构，它明显得区分了输入区域，输出区域，暂存区域, 这是也我们刚上手容易懵的地方:</p>\n<ul>\n<li><strong>Input (<code>/kaggle/input</code>)</strong>：<strong>只读区域</strong>。这里存放你上传的数据集或挂载的模型。读取速度极快，但无法写入。</li>\n<li><strong>Output (<code>/kaggle/working</code>)</strong>：<strong>可读写区域</strong>。这是你的主工作区，代码运行结果、下载的模型必须存在这里。但注意，重启 Session 后，这里的内容如果不保存为 Dataset 也会消失。</li>\n<li><strong>Temp (<code>/kaggle/temp</code>)</strong>：<strong>临时暂存区</strong>。空间较大（只有当前会话有效），适合下载解压临时的大文件。</li>\n</ul>\n<p><img alt=\"Kaggle notebook 文件系统结构图，展示 input/working/temp 的区别的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/kaggle_input_working_temp.png\" /></p>\n<h2 id=\"2-快速上手注册与解锁\">2. 快速上手：注册与“解锁”</h2>\n<h3 id=\"21-注册与关键验证-必做\">2.1 注册与关键验证 (必做)</h3>\n<p>我们新用户登录创建notebook后会发现，我们没有硬件加速设备可选。<br />\n<img alt=\"新用户的accelerator部分是灰色的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/no_gpu.png\" /><br />\n根本原因就是咱们没有进行手机验证，哈哈哈，可以理解，毕竟本身kaggle就不用绑卡，加上手机验证可能会杜绝掉一大部分计算资源滥用。</p>\n<ol>\n<li>访问 <a href=\"https://www.kaggle.com/\" rel=\"noopener nofollow\" target=\"_blank\">Kaggle 官网</a> 并注册账号。</li>\n<li><strong>关键步骤</strong>：点击右上角头像 -&gt; <strong>Settings</strong>。</li>\n<li>找到 <strong>Phone Verification</strong>（手机验证）。<strong>必须完成这一步</strong>，否则无法开启 GPU 和 Internet（联网）功能。<br />\n<img alt=\"Kaggle 账户设置页面的截图，高亮 Phone Verification 区域\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/phone_verification.png\" /></li>\n</ol>\n<p>认证完毕就可以使用GPU资源了<br />\n<img alt=\"当认证了手机号之后显示accelerator中有可用的GPU资源的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/gpu_access.png\" /><br />\n如果继续做了<strong>Identity verification</strong>之后，可以使用TPU资源，不过我们暂时用不到，目前的GPU资源已经够咱们大玩一场了。</p>\n<h3 id=\"22-创建笔记本\">2.2 创建笔记本</h3>\n<ol>\n<li>点击左侧菜单栏的 <strong>Create</strong> -&gt; <strong>New Notebook</strong>。</li>\n<li>进入编辑器界面，你会发现界面布局比 Colab 更加紧凑且功能分区明确。<br />\n<img alt=\"kaggle的编辑器页面布局的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/the_whole_UI.png\" /></li>\n</ol>\n<h3 id=\"23-界面布局速览\">2.3 界面布局速览</h3>\n<ul>\n<li><strong>工作区</strong>：位于右侧，显示了Input-&gt;我们的挂载资源，上传的数据集和模型等等，Output-&gt;我们输出的结果资源。notebook内容速览,以及下面的session options环境快捷配置等等<br />\n<img alt=\"编辑器右侧的工作区，包含Input区和output区的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/workspace.png\" /><br />\n<img alt=\"编辑器右侧工作区剩余部分，报班session options的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/session_options.png\" /></li>\n<li><strong>快捷操作栏</strong>： 在代码区上方，和Colab差别不大，可以快速运行，插入单元格，复制粘贴等等<br />\n<img alt=\"在编辑器上方的快捷操作栏的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/quick_action.png\" /></li>\n<li><strong>代码区</strong>：和Colab一样, 标准的 Jupyter 单元格。</li>\n</ul>\n<p>注意，</p>\n<ol>\n<li>和Colab不一样的是，Kaggle的文件名没有后缀，不用加ipynb后缀</li>\n<li>咱们的硬件加速（GPU/TPU计算资源）被放到了顶部菜单栏的<strong>Settings</strong>中的<strong>accelerator</strong>中了</li>\n<li>和Colab不同，因为Kaggle是为竞赛服务，很多竞赛是要求模型不联网的，所以我们在训练模型的时候，需要手动开启网络，也在顶部菜单栏的<strong>Settings</strong>中，点击<strong>Turn On Internet</strong>打开即可联网下载模型或者数据集。<br />\n<img alt=\"Kaggle Notebook的Settings下拉菜单，包含硬件加速设备和开启联网选项的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/settings.png\" /></li>\n<li>密钥管理被放到了顶部菜单栏的<strong>Add-ons</strong>下了<br />\n<img alt=\"Kaggle Notebook的Add-on下来菜单，包含密钥管理选项的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/add-on.png\" /></li>\n</ol>\n<h2 id=\"3-环境配置开启双显卡与联网\">3. 环境配置：开启双显卡与联网</h2>\n<p>Kaggle 默认环境是 <strong>CPU</strong> 且 <strong>断网</strong> 的。我们需要手动“解除封印”。</p>\n<h3 id=\"31-开启联网-internet-on\">3.1 开启联网 (Internet On)</h3>\n<p>可以按照刚才说的在顶部菜单栏打开，也可以在右侧边栏的 <strong>Session Options</strong> 中，找到 <strong>Internet</strong> 选项。将开关拨到 <strong>On</strong>。<br />\n<em>注意：如果没有手机验证，此选项为灰色不可用。</em></p>\n<h3 id=\"32-开启-gpu-加速-t4-x2\">3.2 开启 GPU 加速 (T4 x2)</h3>\n<ol>\n<li>\n<p>在右侧边栏找到 <strong>Accelerator</strong>。</p>\n</li>\n<li>\n<p>下拉选择 <strong>GPU T4 x2</strong>。</p>\n<ul>\n<li><strong>GPU T4 x2</strong>：两张显卡，约 30GB 显存，适合大模型推理和微调。</li>\n<li><strong>GPU P100</strong>：单张旧架构卡，虽然速度快但显存仅 16GB，通常不推荐。</li>\n</ul>\n</li>\n<li>\n<p>开启后，顶部会显示 <strong>Session Storage</strong> 和 <strong>GPU Quota</strong>（每周 30 小时额度，通常周六刷新）。<br />\n点击自己的头像，可以看见自己的额度<strong>GPU Quata</strong><br />\n<img alt=\"点击自己的头像，可以看见自己的额度的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/GPU_Quata.png\" /></p>\n</li>\n</ol>\n<h3 id=\"33-验证双卡环境\">3.3 验证双卡环境</h3>\n<p>输入并运行以下代码，确认我们是否真的拥有了两张显卡：</p>\n<pre><code class=\"language-python\">!nvidia-smi\n</code></pre>\n<p>你应当能看到 <strong>两张</strong> Tesla T4 显卡的列表 (GPU 0 和 GPU 1)。<br />\n<img alt=\"nvidia-smi的运行结果，显示两张Tesla T4卡\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/nvidia-smi.png\" /></p>\n<h2 id=\"4-实战下载并运行大模型\">4. 实战：下载并运行大模型</h2>\n<p>在 Kaggle 上使用模型主要有两种“流派”：<strong>代码下载派</strong> 和 <strong>原生挂载派</strong>。</p>\n<h3 id=\"方式一利用-huggingface-cli-下载-工程化推荐\">方式一：利用 HuggingFace CLI 下载 (工程化推荐)</h3>\n<p>这种方式最灵活，适合需要精确控制模型版本的情况。由于 Kaggle 没有 Google Drive，我们将模型下载到 <code>/kaggle/working/</code> 目录。</p>\n<p><strong>步骤 1：安装与配置</strong></p>\n<pre><code class=\"language-python\"># Kaggle 预装库很多，但 transformers 版本可能滞后，建议更新\n!pip install -U transformers huggingface_hub accelerate bitsandbytes\n</code></pre>\n<p>点击顶部菜单 <strong>Add-ons</strong> -&gt; <strong>Secrets</strong>，添加 <code>HF_TOKEN</code>（你的 HuggingFace 访问令牌）。</p>\n<p><strong>步骤 2：下载脚本</strong></p>\n<pre><code class=\"language-python\">import os\nfrom huggingface_hub import login, snapshot_download\nfrom kaggle_secrets import UserSecretsClient\n\n# 1. 登录 (自动读取 Secrets)\nuser_secrets = UserSecretsClient()\nhf_token = user_secrets.get_secret(\"HF_TOKEN\")\nlogin(token=hf_token)\n\n# 2. 定义下载路径 (注意：必须在 /kaggle/working 下)\nmodel_dir = \"/kaggle/working/model_cache\"\nos.makedirs(model_dir, exist_ok=True)\n\n# 3. 下载模型\nmodel_id = \"Qwen/Qwen2.5-7B-Instruct\"\nprint(f\"开始下载 {model_id} ...\")\n\n# Kaggle 建议下载实文件 (local_dir_use_symlinks=False)\nsnapshot_download(\n    repo_id=model_id,\n    local_dir=model_dir,\n    local_dir_use_symlinks=False,\n    token=hf_token\n)\n\nprint(\"下载完成！\")\n</code></pre>\n<p><img alt=\"下载完成的结果截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/download_model.png\" /></p>\n<h3 id=\"方式二add-input-kaggle-原生方式\">方式二：Add Input (Kaggle 原生方式)</h3>\n<p>这是 Kaggle 最强大的功能。你可以直接在网页端搜索现成的模型，像挂载 U 盘一样挂载进来，<strong>不消耗下载流量和时间</strong>。</p>\n<ol>\n<li>点击右侧边栏的 <strong>Add Input</strong>。</li>\n<li>选择 <strong>Models</strong> 标签页。</li>\n<li>搜索 <code>Qwen2.5</code>。</li>\n<li>点击 <strong>+</strong> 号添加。<br />\n<img alt=\"Kaggle Add Input 搜索模型的弹窗截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/qwen_downloading.png\" /></li>\n<li>选择FRAMEWORK选择<strong>Transformers</strong>架构, VARIATION选择<strong>7b-instruct</strong>, 之后的博文会跟各位友人解释这些参数的差别<br />\n<img alt=\"下载Qwen2.5模型需要填写的架构和参数示意截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/qwen2_5_params.png\" /></li>\n<li>模型会直接出现在 <code>/kaggle/input/</code> 目录下（只读），路径通常长得像 <code>/kaggle/input/qwen2.5/transformers/7b-instruct/1</code>。</li>\n</ol>\n<h2 id=\"5-加载模型与双卡推理\">5. 加载模型与双卡推理</h2>\n<p>拥有双卡 T4 后，加载模型时有一个关键参数：<code>device_map=\"auto\"</code>。它会自动将模型切分到两张显卡上，从而让我们能运行更大的模型。</p>\n<pre><code class=\"language-python\">import torch\nfrom transformers import AutoTokenizer, AutoModelForCausalLM\n\n# 路径根据你的下载方式调整\n# 方式一路径: \"/kaggle/working/model_cache\"\n# 方式二路径: \"/kaggle/input/qwen2.5/transformers/7b-instruct/1/\" (具体可以运行默认创建的第一个单元格，查看input目录结构,到能看见config.json的目录即可)\nmodel_path = \"/kaggle/working/model_cache\"\n\nprint(\"正在加载模型 (双卡模式)...\")\n\ntokenizer = AutoTokenizer.from_pretrained(model_path, trust_remote_code=True)\n\n# 关键：device_map=\"auto\" 会自动利用两张 T4\nmodel = AutoModelForCausalLM.from_pretrained(\n    model_path,\n    device_map=\"auto\",\n    torch_dtype=torch.float16,\n    trust_remote_code=True\n)\n\nprint(f\"模型加载成功！显存分布: {model.hf_device_map}\")\n\n# 测试对话\nprompt = \"你好，请用一句话形容 Kaggle 的双 T4 显卡有多香？\"\nmessages = [{\"role\": \"user\", \"content\": prompt}]\ntext = tokenizer.apply_chat_template(messages, tokenize=False, add_generation_prompt=True)\ninputs = tokenizer([text], return_tensors=\"pt\").to(model.device)\n\nwith torch.no_grad():\n    generated_ids = model.generate(**inputs, max_new_tokens=200)\n\nresponse = tokenizer.batch_decode(generated_ids, skip_special_tokens=True)[0]\nprint(f\"Qwen: {response.split('assistant')[-1].strip()}\")\n</code></pre>\n<h2 id=\"6-进阶如何持久化保存save-version\">6. 进阶：如何持久化保存？(Save Version)</h2>\n<p>Kaggle 没有 Google Drive，那怎么保存下载好的模型或训练结果呢？</p>\n<p><strong>答案：把 Output 变成 Dataset。</strong></p>\n<ol>\n<li>当你的代码运行完毕，模型保存在 <code>/kaggle/working</code> 后。</li>\n<li>点击右上角的 <strong>Save Version</strong> 按钮。</li>\n<li>选择 <strong>Save &amp; Run All</strong> (重新跑一遍),必须等到下方弹出的保存任务完成。<br />\n<img alt=\"保存任务完成的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/job_running_done.png\" /></li>\n<li>保存成功后，你可以去主页的<strong>Your Work</strong>点击刚才的Notebook,进入<strong>Output</strong> 标签页里，点击最右边的Output的三个点，然后点击 <strong>New Dataset</strong>。<br />\n<img alt=\"在Output标签页的New Dataset示意图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/new_data.png\" /></li>\n<li>这样，我们刚才的模型就变成了一个可以在其他 Notebook 里直接 <strong>Add Input</strong> 的数据集了！</li>\n</ol>\n<p><strong>PS:除开自训练的特殊模型和一些在Input找不到的模型，最好都直接使用Input导入更为快捷</strong></p>\n<h2 id=\"7-常见问题-qa\">7. 常见问题 (Q&amp;A)</h2>\n<p><strong>Q: Colab 和 Kaggle 我该选谁？</strong><br />\n<strong>A:</strong></p>\n<ul>\n<li><strong>Colab</strong>: 适合快速实验、挂载 Google Drive 方便。但 T4 只有一张，且最近封号较严。</li>\n<li><strong>Kaggle</strong>: 适合需要大显存（T4 x2）的任务。环境更稳定，且有 30 小时/周的明确额度，不用担心用到一半被踢下线。</li>\n</ul>\n<p><strong>Q: 为什么我的代码报错 <code>Internet connection is closed</code>？</strong><br />\n<strong>A:</strong> 这是一个经典错误。请检查右侧边栏的 <strong>Internet</strong> 开关是否为 On。如果开关是灰色的，请检查是否完成了账号的 <strong>手机号验证</strong>。</p>\n<p><strong>Q: <code>/kaggle/working</code> 里的文件重启后还有吗？</strong><br />\n<strong>A:</strong> 没有了。Kaggle 的 Session 也是临时的。如果需要持久化，请务必使用 <strong>Save Version</strong> 功能将其保存为 Dataset，或者在代码最后加一段上传到 HuggingFace Hub 的代码。</p>\n<hr />\n<p><strong>本文作者：</strong> Algieba<br />\n<strong>本文链接：</strong> <a href=\"https://blog.algieba12.cn/llm02-2-online-environment-kaggle/\" rel=\"noopener nofollow\" target=\"_blank\">https://blog.algieba12.cn/llm02-2-online-environment-kaggle/</a><br />\n<strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</p>\n<pre><code>\n</code></pre>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"itemdesc\">\n\t\t\t发表于 \n<span id=\"post-date\">2026-02-04 19:53</span>&nbsp;\n<a href=\"https://www.cnblogs.com/algieba\">阿尔的代码屋</a>&nbsp;\n阅读(<span id=\"post_view_count\">7</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</div>"
    },
    {
      "title": "V8引擎 精品漫游指南--Ignition篇(上) 指令 栈帧 槽位 调用约定 内存布局 基础内容",
      "link": "https://www.cnblogs.com/f20171110/p/19576264",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/f20171110/p/19576264\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 19:19\">\n    <span>V8引擎 精品漫游指南--Ignition篇(上) 指令 栈帧 槽位 调用约定 内存布局 基础内容</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        这是第二篇的上半部分，我们主要学习ignition V8的解释器的一些基础和前置知识。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"二-ignition解释器上\">二. Ignition解释器(上)</h1>\n<p>这是第二篇的上半部分，我们主要学习ignition V8的解释器的一些基础和前置知识。</p>\n<p>这部分内容，主要是以了解为主，所以在学习的时候，除了第一篇中说的 有些细节做了省略  有些边界情况做了简化表述以外，也不需要过多的深入。 读完了就好。 目的就是对于ignition解释器的一个祛魅。</p>\n<p>当然，感兴趣的朋友也可以认真阅读，本文内容依旧保持一定的深度，依旧是力求高准确性，符合规范，贴合实现。 但需注意的是，为了文章的可读性，有可能<strong>在前面</strong>仅做简化的通俗的描述，<strong>在后面</strong>做了详细的讲解描述，所以，可能的情况下，请尽量阅读全文。</p>\n<p>通过上一篇的解析，我们手里已经拿到了一份完整的AST抽象语法树。 但是对于cpu来说，它只认指令。</p>\n<p>在早期版本的 V8 中，JavaScript 代码在解析完成后，会直接被编译成本机机器码执行。这种方式运行得很快，但机器码体积通常比较大，也不够灵活。</p>\n<p>在后来，直到现在，V8不再直接生成庞大复杂的机器码，而是生成了一种非常紧凑 小巧的中间代码，就是 字节码 bytecode。</p>\n<p>但是cpu也不认识字节码，V8使用 ignition 模拟了一个可以运行字节码的环境，相当于一个极其轻量的虚拟机。</p>\n<h2 id=\"1--ignition是什么\">1 . ignition是什么</h2>\n<p>Ignition 是 V8 引擎里的<strong>字节码解释器</strong>，它把 JavaScript 的 AST 编成紧凑的字节码，然后在虚拟机里解释执行，同时收集各种信息，供优化器生成更快的机器码。</p>\n<p>ignition的工作  最主要是下面三个：</p>\n<p><strong>翻译</strong>：把 AST 翻译成字节码。</p>\n<p><strong>执行</strong>：在一个虚拟的寄存器机里执行这些字节码。</p>\n<p><strong>收集情报</strong>：在执行过程中，偷偷记录类型信息，为后续的优化做准备。</p>\n<p>Ignition 在软件层面模拟了一套  <strong>类 CPU</strong> 的工作模式：<br />\n它不是只用栈，也不是纯寄存器机，而是采用“<strong>虚拟寄存器 + 累加器（Accumulator）</strong>”的模式。</p>\n<p>这里的寄存器并不是 CPU 里的硬件寄存器，而是函数栈帧里的一些槽位（slots），只是把它抽象成寄存器来使用，看起来更像 CPU 工作方式，但成本非常低。</p>\n<p>Ignition 还设计了一个<strong>解释器独占的累加器 acc</strong>。大多数运算的中间结果都会临时存放在 acc 里，这样指令只需要携带一个参数，就不用全部写出所有的目的寄存器，字节码就会变得非常短小。</p>\n<p>当一个函数开始执行时，Ignition 会在内存的 栈 (Stack) 上划出一块地盘， 跑起来的时候，本质上就是在那块栈内存上，不停地把数据从一个位置搬到另一个位置，计算，然后再搬回另一个位置，就是这样搬来搬去。ignition操作的并不是真正的cpu内的寄存器，它操作的是内存位置/槽位。</p>\n<h2 id=\"2--几个简单的指令\">2 . 几个简单的指令</h2>\n<p>ignition就像一个勤劳干活的老师傅，他有一个随身腰包，他不管干什么活，不管需要用什么工具，都是优先用随身腰包里的东西， 干完活得到的结果，也顺手塞回自己的随身腰包里。</p>\n<p><strong>老师傅有个随身腰包， 不管干什么，都优先使用随身腰包。</strong></p>\n<p><strong>摆放各种材料的原料架，一格一格的， r0 ，r1，r2.。。。编着号，上面摆满了原材料。</strong></p>\n<p>好了，这就是ignition的架构。就是这么简单。</p>\n<p>这个随身腰包，就是老师傅最重要的东西了。师傅偷懒全靠它了。</p>\n<p>假如没有这个随身包，想象一下，老板下达指令非常啰嗦麻烦：</p>\n<p>把 r1原料架 的东西 和 r2原料架 的东西拿下来，拼装好，然后再放回 r3原料架 去</p>\n<p>(类似于指令：ADD r1, r2, r3)</p>\n<p>​     而老师傅有了随身包，就简单了，老板只需要喊一声：</p>\n<p>“去把 r2 原料架的东西拼进来！”</p>\n<p>(指令：Add r2)</p>\n<p>老板完全不需要废话“跟谁拼”（默认跟包里的东西拼），也不需要废话“拼完放哪”（默认拼完还放在包里）。</p>\n<p>这就是 Ignition 的核心节省秘籍。通过强行规定“随身包优先”，每一条指令都能省掉好几个参数的位置。成千上万行代码跑下来，省下的内存就是一个天文数字。</p>\n<p>这个老师傅的<strong>随身包 就是累加器</strong>，原料架 就是内存位置/槽位</p>\n<ul>\n<li>\n<p><code>Lda</code> (Load Accumulator) ---Lda 是个前缀，实际使用时，后面可跟很多合法的数据来源，比如 LdaSmi<code>、</code>LdaConstant<code>、</code>LdaUndefined、Ldar 等等。。。</p>\n<p>这是使用最高频的指令，因为所有的活 都得在随身包里干，所以第一步，基本上都是把东西装进包里。</p>\n<ul>\n<li><strong>指令</strong>：<code>Ldar r1</code> (Load Accumulator from Register r1)</li>\n<li><strong>动作</strong>：老师傅走到 r1 原料架，把那里的材料拿下来，<strong>塞进随身包里</strong>。</li>\n<li><strong>状态</strong>：此时，随身包里的东西 = r1 的东西。</li>\n<li>Ldar 这个指令  很好记忆，ld是装载，a是累加器，r是寄存器，ldar就是装载累加器from寄存器，  <strong>把寄存器的内容装进累加器</strong>。</li>\n<li>Ldar r1  就是把寄存器r1里的东西 装进累加器。</li>\n<li>老师傅把r1的原料装进随身包里。</li>\n</ul>\n</li>\n<li>\n<p><code>Star</code> (Store Accumulator)</p>\n<p>活干完了，结果总不能一直烂在包里，得腾出地方干下一票，或者把结果存起来。</p>\n<ul>\n<li><strong>指令</strong>：<code>Star r2</code> (Store Accumulator to Register r2)</li>\n<li><strong>动作</strong>：老师傅把<strong>随身包里</strong>刚刚加工好的成品掏出来，放到 r2 原料架上去。</li>\n<li><strong>状态</strong>：此时，r2 原料架的东西 = 随身包里的东西。</li>\n<li>star 这个指令，也很好记忆，st是储存，a是累加器，r是寄存器，star就是存储累加器里的东西到寄存器。</li>\n</ul>\n</li>\n<li>\n<p><code>Add</code> / <code>Sub</code> ...</p>\n<p>这是真正的关键步骤。</p>\n<ul>\n<li><strong>指令</strong>：<code>Add r0</code></li>\n<li><strong>动作</strong>：老师傅走到 r0 原料架，拿个东西，直接跟<strong>随身包里</strong>原本的东西进行合体（相加）。</li>\n<li><strong>状态</strong>：随身包里的东西 = 原包里的值 + r0 的值。</li>\n<li><strong>重点</strong>：注意 <strong>结果依然留在包里</strong>，老师傅并没有急着去储存结果。</li>\n</ul>\n<p>指令都很简单，<strong>ld</strong>  <em>load</em>，<strong>st</strong>  <em>store</em>，<strong>a</strong>  <em>accumulator</em>，<strong>r</strong>  <em>register</em></p>\n<p>类似的  ldglobal  stglobal ldarg0  ldcurrentcontext  也都差不多，</p>\n<p>基本上都是  动作+对象  的模式。</p>\n<p>另外需要注意的是，累加器 Accumulator 通常会写作 acc。虽然它叫“累加器”，但千万不要理解成它只能做加法运算。<strong>从本质上讲，acc 就是解释器里唯一的“通用临时寄存器”</strong>：当前这条字节码要处理的值，或者运算后的中间结果，几乎都会暂时放在这里。</p>\n<p>acc 里可以装任何 JavaScript 的值，比如常量、小整数、字符串、对象引用、<code>undefined</code> 等。之所以要设计这么一个“统一的临时位置”，就是为了让大多数字节码只需要写明“另一个参与运算的对象是谁”，而不用每次都额外声明多个寄存器参数，从而<strong>让字节码更短、更规整，也让解释器实现更简单</strong>。</p>\n</li>\n</ul>\n<pre><code>  Ldar r1   ; acc = r1\n  Add r0    ; acc = acc + r0\n  Star r2   ; r2 = acc\n  \n  累加器acc的变化。    是不是非常简单。\n</code></pre>\n<h2 id=\"3--栈帧和槽位\">3 . 栈帧和槽位</h2>\n<p>在第一部分解析篇里  我们也提到过 槽位 这个术语， 上面又提到了，那么，槽位到底是什么呢？</p>\n<p><strong>槽位（slot）就是栈帧里一格一格固定大小的“存储单元”或“格子”，用于按索引存放函数的参数、局部变量、临时值、以及其它元数据。</strong> 它不仅是“位置”，还隐含了大小、类型（通常是指针/Tagged 值）、地址计算规则和生命周期语义。</p>\n<p>内存可寻址的最小单位是 8bit 即一字节， 虽然最小使用单位是8bit 即一字节。但是，因为需要字节对齐 和 机器指针大小的要求，所以 在32位系统上，  需要4字节表示指针， 64位系统上  需要8字节表示指针。 每个槽位的大小，也是按照操作系统机器指针的大小来划分的。 即   64位系统，一个槽位  占 8个字节 。 只有这样，<strong>64位系统</strong>使用指针寻址时，8字节，即64bit，才能够装得下一个指针。</p>\n<p>所以，每个槽位（slot）占 8个字节大小。</p>\n<p>当函数开始执行时，运行时runtime在栈上为它分配一段连续内存作为<strong>栈帧</strong>。在 Ignition 中，栈帧大致分为三部分：<strong>参数区</strong>、<strong>固定头部</strong>，  <strong>工作区</strong> 。栈帧里的每个“格子”称为<strong>槽位（slot）</strong>，按索引存放局部变量和临时值，槽位的大小通常等于机器指针大小， <strong>64 位</strong>下为 8 字节。</p>\n<p><strong>特别注意</strong>：前面我们一般并没有明确的区分栈帧里槽位和字段，现在明确一下，我们<strong>仅仅是把工作区中</strong>按索引的格子（<code>r0, r1, r2…</code>）称为<strong>槽位（frame slots）</strong>。固定头部里的字段（返回地址、saved FP、Context、BytecodeArray 等）我们<strong>不</strong>把它们称为槽位；参数一般称为 argument slots（<code>a0,a1</code>）或单独描述。</p>\n<p>严格从 V8 内存视角来看，栈帧中的每一个 8 字节存储单元（无论是 Context、返回地址还是局部变量）在源码中都统称为 <strong>Slot</strong>。</p>\n<p>但在解释器字节码的语句环境中，为了<strong>区分功能</strong>：</p>\n<ul>\n<li>我们将固定位置、用途单一的区域称为 <strong>“固定头部字段”</strong>（如 Function, Context）。</li>\n<li>我们将用于存储局部变量和临时结果、通过索引动态访问的区域特称为 <strong>“寄存器槽位”</strong> 或 <strong>“局部变量槽位”</strong> 或简称为 <strong>槽位</strong> 。</li>\n<li><strong>有时候可能会有混用，将栈上某字段也称为槽位，从规范从v8源码上来说，完全没有错误，只是因为手抖或者写快了，没有按照我们通常的按功能区分的约定称呼。</strong></li>\n<li>当然，你可以按照自己的意愿，区分或者不区分，<strong>都是正确的</strong>。前提是  你要知道观察的视角的不同。</li>\n</ul>\n<p>下面我们详细介绍一下栈帧的结构。</p>\n<p>栈的生长顺序，是<strong>从高地址到低地址</strong>，即入栈早的在高地址， 最后入栈的处于栈顶 在低地址。</p>\n<p>我们首先介绍个术语：Tagged Pointer</p>\n<blockquote>\n<h4 id=\"tagged-pointer--标签指针\">Tagged Pointer  标签指针</h4>\n<p>64位系统中，每个槽位都是 8 字节（64 位），V8 在这里面存数据时，使用了一个编码技巧，叫做 <strong>Tagged Pointer (带标签的指针)</strong>。</p>\n<p>在静态语言立，比如 C++ 这种静态语言，编译器知道变量是 <code>int</code> 还是 <code>Object*</code>。但在 JavaScript 中，类型是动态的。如果 V8 为每个变量额外存一个“类型字段”，内存消耗会翻倍。 V8 的做法是：<strong>把类型信息直接编码进这 64 位数据本身。</strong></p>\n<p><strong>方法就是复用“对齐留下的低位”</strong> 在 64 位平台上，内存地址通常是 <strong>8 字节对齐</strong> 的。合法地址的二进制形式，<strong>最低的几位通常都是 0</strong>。 V8 就是使用了这些闲置的低位，用来打上类型标签Tag。</p>\n<p><strong>Tagged Value 的分类：</strong> V8 把槽位里的机器字统称为 <strong>Tagged Value</strong>，根据低位标签不同，分为两类：</p>\n<p><strong>Smi (Small Integer，标签立即量)</strong></p>\n<ul>\n<li><strong>特征</strong>：最低位通常为 <code>0</code>。</li>\n<li><strong>含义</strong>：这 <strong>不是</strong> 指针，这 64 位数据本身就存着一个整数。</li>\n<li><strong>优势</strong>：整数直接住在栈上，不需要去堆里申请内存，速度极快。</li>\n<li><strong>还原</strong>：使用时，通过<strong>右移 (Shift)</strong> 运算去掉标签，就能得到整数值。</li>\n</ul>\n<p><strong>Tagged Pointer (堆对象引用)</strong></p>\n<ul>\n<li><strong>特征</strong>：最低位通常为 <code>1</code>。</li>\n<li><strong>含义</strong>：这是一个指向堆内存中对象（HeapObject）的 <strong>强引用</strong>。</li>\n<li><strong>注意</strong>：它不能直接当做物理地址用。</li>\n<li><strong>还原</strong>：使用时，必须通过<strong>位掩码 (Mask)</strong> 运算去掉标签（Untag），还原成纯净的内存地址，才能去访问堆里的对象。</li>\n</ul>\n<p>这样使用Tag以后， Tagged value 就像给数据穿了一件“马甲”。Ignition 看一眼马甲（标签位），就知道是整数还是对象。虽然使用前必须“脱马甲”（Untag），但这带来的性能提升和内存节省是巨大的。</p>\n<p>另外需要注意，使用tag标记，  能直接判定的类型集合很小（主要是 Smi 或HeapObject），更细的类型，需要读取对象头来获取。</p>\n</blockquote>\n<p>那么 ，栈帧的结构是怎样的呢？它的组成如下：</p>\n<ul>\n<li>\n<p>第一层  参数区 Arguments</p>\n<p>当调用一个函数时，调用者Caller需要给它传实参，同时还有个隐形参数this，这些内容，都在栈帧的第一层参数区。</p>\n<ul>\n<li><strong>Receiver (this)</strong>：\n<ul>\n<li>这是个隐形参数。当你写 <code>obj.func()</code> 时，<code>obj</code> 就是 Receiver。它是参数列表里的隐形老大哥。</li>\n</ul>\n</li>\n<li><strong>Arguments (<code>a0</code>, <code>a1</code>...)</strong>：\n<ul>\n<li>这就是 <code>function foo(x, y)</code> 里的 <code>x</code> 和 <code>y</code>。</li>\n<li>Ignition 给它们编的号是 <code>a0</code>, <code>a1</code>...</li>\n<li>要注意的是，这里的 <code>a</code> 代表 Argument，不要和 Accumulator 搞混了。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>第二层  固定头部  Fixed header / fixed frame part</p>\n<p>这是整个栈帧中最重要、最关键的区域。</p>\n<p>既然 Ignition 是个软件模拟的 CPU，那 CPU 运行时需要的那些状态  比如“我现在运行到哪一行了？”、“我的环境是谁？”  。。。等等信息， 都是存在哪的？</p>\n<p>没错，就存在这儿，固定头部。</p>\n<p>每个函数栈帧的中间，都夹着这么一块雷打不动的区域，保存着维持虚拟机运行的<strong>元数据</strong></p>\n<p>它里面的主要内容：</p>\n<ol>\n<li>\n<p><strong>Return Address (返回地址)</strong>：</p>\n<ul>\n<li><em>作用</em>：等这个函数执行完，底层调用栈就会根据这个返回地址，跳回调用处继续执行。</li>\n<li>这里腰注意，返回地址， 是控制流，是返回的应该到代码的哪个位置去继续执行。</li>\n</ul>\n</li>\n<li>\n<p><strong>Caller's Frame Pointer (上一层栈帧指针)</strong>：</p>\n<ul>\n<li>\n<p><em>作用</em>：链表指针。当前函数执行完、调用者的栈帧在哪里？</p>\n</li>\n<li>\n<p>这样依旧要注意，这个指针，指的是数据，上个字段返回地址，是控制流的返回，这里</p>\n</li>\n<li>\n<p>的上层栈帧指针，是控制流返回以后，继续执行， 应该从哪里去找变量，返回的是那个</p>\n</li>\n<li>\n<p>栈帧，可以理解为数据。</p>\n</li>\n<li>\n<p>在理解上，还可以大致认为，</p>\n</li>\n<li>\n<p>返回地址是等这个函数执行完，要回到哪一行继续执行代码，也就是<strong>控制流</strong>该跳回哪里。这是时间上的返回 ，代码继续从哪里跑。</p>\n<p>上一层栈帧指针是调用我的那个函数，它的栈帧从哪里开始？<br />\n这是空间上的返回 ，要去哪一块内存里继续访问局部变量和作用域数据。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Context (上下文指针)</strong></p>\n<ul>\n<li>\n<p><em>这是什么</em>：它指向 <strong>堆内存 (Heap)</strong> 中一个叫做 <code>Context</code> 的对象。</p>\n</li>\n<li>\n<p>为什么要它：</p>\n<p>如果函数里用到的变量是自己的 let a，直接去栈上找（r0）。</p>\n<p>但如果用到了闭包变量（外层函数的变量），Ignition 必须拿着这个 Context 指针，去堆里的上下文链表上一层层找。</p>\n</li>\n<li>\n<p><em>地位</em>：它是连接 <strong>“栈世界（临时数据）”</strong> 和 <strong>“堆世界（持久数据）”</strong> 的唯一桥梁。</p>\n</li>\n<li>\n<p>这个概念非常重要，值得我们深入了解。另外插一句，虽然说  这整个部分都可以了解为主，但是如果认真学习，能够掌握，还是有很大的用处。比如这个栈帧，对于js开发还是很重要的。</p>\n</li>\n<li>\n<p>上面有个上一层栈帧指针，这里又有个上下文指针，怎么正确而深入的理解他们呢？</p>\n</li>\n<li>\n<p>**上一层栈帧指针是“动态调用链” **</p>\n<ul>\n<li><strong>回答的问题：</strong> “我是被谁调用的？”</li>\n<li><strong>指向哪里：</strong> 指向<strong>栈（Stack）</strong>上的上一级栈帧。</li>\n<li><strong>作用：</strong> 函数执行完（return）后，底层会根据返回地址跳回调用者继续执行，而上一层栈帧指针则用来恢复调用者的栈帧布局，用于继续访问它的局部变量等数据。</li>\n</ul>\n<p>**Context 是“静态作用域链” **</p>\n<ul>\n<li><strong>回答的问题：</strong> “我是被定义在哪里的？”</li>\n<li><strong>指向哪里：</strong> 指向<strong>堆（Heap）</strong>上的 Context 对象。</li>\n<li><strong>作用：</strong> 它是<strong>数据流</strong>的查找路线。当函数访问一个不在自己内部的变量（自由变量）时，V8 会顺着这条链去查找。</li>\n</ul>\n</li>\n<li>\n<p>理解的关键点</p>\n</li>\n<li>\n<p><strong>上一层栈帧指向的是栈内存</strong>：栈帧是临时的，函数一返回，栈帧就销毁了。</p>\n<p><strong>Context 指向的是堆内存</strong>：这是为了实现 JavaScript 的<strong>闭包</strong>特性。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Function / Frame Marker (函数/帧类型标记)</strong>：</p>\n<ul>\n<li>\n<p>这个字段的<strong>位置</strong>在<code>[FP - 16]</code>  <strong>请注意</strong>  这里的偏移值 16 仅是<strong>示意</strong>。  这种表示方法，后面会详细介绍。</p>\n</li>\n<li>\n<p>这是一个具有<strong>多态性 (Polymorphic)</strong> 的关键槽位。它用于当前栈帧的身份识别。V8 引擎利用这个槽位来区分当前栈帧是属于标准的 JavaScript 函数调用，还是属于引擎内部的 C++ 调用。</p>\n</li>\n<li>\n<p>V8 的栈遍历器（Stack Walker）在扫描堆栈时（例如进行 GC 标记、生成错误堆栈或反优化时），会读取该槽位的值，并根据 <strong>指针标记位 (Tag Bit)</strong> 进行判断：</p>\n<ul>\n<li><strong>如果是对象指针（Heap Object）</strong>：判定为 <strong>Interpreted Frame</strong>（解释器帧）。</li>\n<li><strong>如果是小整数（Smi）</strong>：判定为 <strong>Internal Frame</strong>（内部帧）。</li>\n</ul>\n</li>\n<li>\n<p>具有两种可能的状态：</p>\n</li>\n<li>\n<p>状态 A：存放 <code>JSFunction</code> (Closure)</p>\n<ul>\n<li><strong>场景</strong>：当执行常规 JavaScript 代码时。</li>\n<li><strong>内容</strong>：指向当前正在执行的函数对象（闭包）的指针。</li>\n<li><strong>作用</strong>：\n<ol>\n<li>作为<strong>资源入口</strong>：解释器通过它访问 <code>SharedFunctionInfo</code>（获取字节码）和 <code>FeedbackVector</code>（获取优化反馈）。</li>\n<li>连接<strong>堆与栈</strong>：保持对堆上函数对象的强引用，防止被 GC 回收。</li>\n</ol>\n</li>\n</ul>\n<p><strong>状态 B：存放 <code>StackFrame::Type</code> (Marker)</strong></p>\n<ul>\n<li><strong>场景</strong>：当执行 V8 内部代码（如 <code>EntryFrame</code>, <code>ConstructFrame</code>, <code>BuiltinFrame</code>）时。</li>\n<li><strong>内容</strong>：一个枚举值（Smi），标识具体的帧类型。</li>\n<li><strong>作用</strong>：\n<ol>\n<li><strong>路标作用</strong>：告诉栈遍历器如何解析当前帧的其余部分（不同类型的内部帧，布局可能不同）。</li>\n<li><strong>边界界定</strong>：标记 JS 代码与 C++ 代码的转换边界</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Bytecode Array (字节码数组指针)</strong>：</p>\n<ul>\n<li>\n<p><strong>这个字段的位置：</strong> <code>[FP - 24]</code>   依旧请注意，偏移值 24 仅是示意。</p>\n</li>\n<li>\n<p><strong>这个字段的内容：</strong> 一个指向堆内存中 <code>BytecodeArray</code> 对象的 <strong>Tagged Pointer</strong>。</p>\n</li>\n<li>\n<p><strong>定义：</strong> 它是解释器 Ignition 真正“读取”和“执行”的指令序列源头。</p>\n</li>\n<li>\n<p>这个字段是一个指针，指向堆（Heap）上的一个<code>BytecodeArray</code> 对象。</p>\n<p>之所以叫 <code>Array</code>，是因为它的<strong>主体部分</strong>确实是一串连续的、变长的字节序列。</p>\n<p>在 V8 的底层 C++ 定义中，凡是符合 <strong>“定长头部 + 变长尾部”</strong> 结构的对象，通常都以此命名。</p>\n<ul>\n<li><strong>普通对象 (<code>JSObject</code>)</strong>：大小通常是固定的（或者由 Map 描述）。</li>\n<li><strong>数组类对象 (<code>FixedArray</code>, <code>ByteArray</code>)</strong>：\n<ol>\n<li>它是<strong>变长</strong>的（在分配时决定大小）。</li>\n<li>它的<strong>主要内容</strong>是可以通过索引（Index）访问的序列。</li>\n</ol>\n</li>\n</ul>\n<p>之所以叫 <code>BytecodeArray</code> 是为了强调它的<strong>存储形态</strong>是线性的字节序列。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Bytecode Offset (字节码偏移量 / PC)</strong>：</p>\n<ul>\n<li><em>作用</em>：<strong>程序计数器</strong>。记录当前执行到第几条指令了。</li>\n<li><strong>位置：</strong> <code>[FP - 32]</code> (即 <code>StandardFrameConstants::kBytecodeOffset</code>)  ，偏移值32，仅为示意，并非确定值。</li>\n<li><strong>形式：</strong> <strong>Smi (小整数)</strong>。</li>\n<li><strong>含义：</strong> 它记录了当前执行到了 <code>BytecodeArray</code> 中的<strong>第几个字节</strong>。</li>\n<li><em>细节</em>：在正常解释执行期间，PC 状态常驻在<strong>真实的物理寄存器</strong>，在之中不停的变动，只有在需要外部可见或恢复时（GC/中断/断点/反优化/进入 runtime 等），解释器会把寄存器的值写回栈帧 BytecodeOffset 字段）。恢复时会把它再装回物理寄存器。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>第三层   工作区  Work Area / Virtual Registers</p>\n<p>这是栈帧中位于固定头部后面、向低地址延伸的区域。</p>\n<p>Ignition 将这段连续的内存槽位，给它们编上号：<code>r0</code>, <code>r1</code>, <code>r2</code>...</p>\n<p>虽然它们在物理上只是连续的 8 字节内存格子，但在逻辑上，它们通常划分成了三种截然不同的用途。</p>\n<h4 id=\"1-显式局部变量-explicit-locals\">1. 显式局部变量 (Explicit Locals)</h4>\n<p>这是最好理解的部分。它们直接对应你在 JavaScript 代码中声明的局部变量。</p>\n<p>生成器（BytecodeGenerator）会按照特定算法（通常与声明顺序相关）为这些变量分配槽位。</p>\n<ul>\n<li>示例</li>\n</ul>\n<p>function demo() {<br />\nvar name = 'v8';  // 编译器决定：分配给 r0<br />\nlet age = 10;     // 编译器决定：分配给 r1<br />\n}</p>\n<p>当代码执行到这里时，<code>r0</code> 槽位里就填入了 <code>\"v8\"</code> 的指针，<code>r1</code> 槽位里填入了 <code>10</code> 的 Smi 值。</p>\n<ul>\n<li>\n<p><strong>关键点：作用域分析 (Scope Analysis)</strong></p>\n<p><strong>要注意</strong>  并不是你写的所有局部变量都能住在这个“栈上的工作区”。</p>\n<p>在生成字节码之前，V8 会先进行一次 <strong>作用域分析</strong>。</p>\n<ul>\n<li><strong>判断标准</strong>：如果一个变量被内部函数（闭包）<strong>捕获 (Captured)</strong> 了，它就不能住在栈上</li>\n<li><strong>原因</strong>：栈帧生命是有限的，函数执行完就销毁了。但闭包可能在函数执行完后还需要访问这个变量。</li>\n<li><strong>结果</strong>：被捕获的变量会被请到堆内存的 <strong>Context 对象</strong> 中。</li>\n<li><strong>结论</strong>：所以，能安稳住在 <code>r0, r1</code> 里的，都是身家清白的、<strong>未被捕获</strong>的局部变量。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-隐式临时变量-implicit-temporaries\">2. 隐式临时变量 (Implicit Temporaries)</h4>\n<p>这是在源代码里完全看不到，但机器执行时必须存在的变量。这也是 <strong>寄存器分配 (Register Allocation)</strong> 算法大显身手的地方。</p>\n<ul>\n<li>\n<p><strong>为什么要临时变量？</strong></p>\n<p>想象一下计算 <code>var x = a + b + c;</code></p>\n<p>Ignition 的累加器（老师傅的随身包）只有一个。</p>\n<ol>\n<li>先把 <code>a</code> 拿进包，把 <code>b</code> 加进来。包里现在是 <code>(a+b)</code>。</li>\n<li>下一步要加 <code>c</code>。指令要求 <code>Add c</code>。</li>\n<li><strong>发生冲突</strong>：如果 <code>c</code> 的获取过程很复杂（比如 <code>c</code> 是个函数调用 <code>getC()</code>），那么在执行 <code>getC()</code> 的过程中，累加器会被反复使用、覆盖。</li>\n<li><strong>如何解决</strong>：必须先把 <code>(a+b)</code> 的结果找个格子 <strong>暂存 Spill</strong> 起来。</li>\n</ol>\n</li>\n<li>\n<p><strong>物理存在</strong>：</p>\n<p>Ignition 会在局部变量后面，划出一些格子作为 <strong>临时寄存器</strong>。</p>\n<p>这些格子就像老师傅手边的“小黑板”。</p>\n<ul>\n<li><strong>复用性</strong>：这行代码算完了，这张“小黑板”擦干净，立刻给下一行代码复用。所以即使代码很长，只要不同时通过大量中间结果，Frame Size 也不会很大。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-神秘的洞-the-hole\">3. 神秘的洞 (The Hole)</h4>\n<p>这是 ES6 引入 <code>let/const</code> 后，V8 在底层实现 <strong>TDZ (暂时性死区)</strong> 的最硬核手段。</p>\n<p>在第一部分解析篇中，我们已经详细学习了这个 会吹哨子的警卫thehole，忘记了的朋友，可以复习一下第一篇中的相关内容。这里我们略微的再讲一下。</p>\n<p>在栈帧刚刚被创建，但代码还没执行到 <code>let a = ...</code> 这一行时，<code>rX</code> 槽位里放的是什么？</p>\n<ul>\n<li>\n<p><strong>对于 <code>var</code></strong>：</p>\n<p>V8 会把对应的槽位初始化为 <code>undefined</code>。所以在赋值前访问它，拿到的就是 <code>undefined</code>（变量提升）。</p>\n</li>\n<li>\n<p><strong>对于 <code>let / const</code></strong>：</p>\n<p>V8 会把对应的槽位填入一个特殊的 <strong>会吹哨子的警卫</strong>，在内部被称为 <strong><code>The Hole</code></strong>。</p>\n</li>\n<li>\n<p><strong>执行时的检查机制</strong>：</p>\n<p>Ignition 在执行读取变量的指令（如 <code>LdaRep</code>）时，内置了一段小逻辑：</p>\n<p>// 伪代码<br />\nvalue = load(r1);<br />\nif (value == The_Hole_Value) {<br />\nthrow ReferenceError(\"Cannot access before initialization\");<br />\n}</p>\n<p>TDZ 并不难理解，它在物理层面上，就是一个槽位里放着 <code>The Hole</code>，而解释器在读取时不仅读数据，还顺手做了一次安全检查，如果摸到的是警卫，哨子就响。</p>\n</li>\n</ul>\n<h4 id=\"4-寻址机制如何找到-r5\">4. 寻址机制：如何找到 <code>r5</code>？</h4>\n<p>工作区只是一段连续的内存，Ignition 怎么知道 <code>r5</code> 在哪？</p>\n<p>这就要用到汇编里的 <strong>基址寻址</strong> 了。</p>\n<ul>\n<li>\n<p><strong>基准点</strong>：<strong>FP (Frame Pointer)</strong>，指向固定头部的特定位置。</p>\n</li>\n<li>\n<p>有朋友可能会有疑问了，前面说栈帧有3部分，第一部分是参数区，可是为什么FP基准点指向固定头部 ，而不是指向参数部分。</p>\n</li>\n<li>\n<p>参数空间是<strong>调用者</strong>的区域，因此在语义上它属于caller 的部分 ，而不是 callee 用来分配本地变量/临时的 workspace。FP 作为被调用者的栈帧基准点，通常是不包括参数区的。</p>\n</li>\n<li>\n<p><strong>计算公式</strong>：</p>\n<p>由于栈是向低地址增长的，所以寄存器的地址是 FP 减去一个偏移量。</p>\n<p>Address(rn) = FP - fixed_header_size - (n * slot_size)</p>\n<p>其中 <code>fixed_header_size</code> 是固定头部的字节长度，<code>slot_size</code> 通常等于机器指针大小（在 64 位系统下常为 8 字节）</p>\n</li>\n<li>\n<p><strong>示例：</strong></p>\n<ul>\n<li><code>FP</code> 指向这里。</li>\n<li>往下走 8 字节... 是 <code>Context</code> <code>[FP-8]</code>。</li>\n<li>再往下... 是 <code>Function</code> <code>[FP-16]</code>。</li>\n<li>再往下... 是 <code>BytecodeArray</code> <code>[FP-24]</code>。</li>\n<li>再往下... 是 <code>BytecodeOffset</code> <code>[FP-32]</code>。<strong>(固定头部结束)</strong></li>\n<li><strong>再往下... 终于到了工作区的 r0</strong> <code>[FP-40]</code>。</li>\n<li><code>r0</code> 再往下 8 字节是 <code>r1</code>。</li>\n</ul>\n<p>所以，字节码里的简单指令 <code>Ldar r5</code>，翻译到底层 CPU 动作，就是去读更深处的内存地址。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4--调用约定和内存布局\">4 . 调用约定和内存布局</h2>\n<p>通过前面的学习，我们已经大致了解了栈帧的内容，现在我们就需要在脑子中建立起动态的栈帧模型。</p>\n<ul>\n<li>\n<p>建立我们自己的心智模型，内存的想象图</p>\n<p>那么 我们怎么想象内存呢？ 梯子，高耸入云的梯子，一格一格的代表内存单元。</p>\n<p><strong>地面（最底下）</strong>：是 <strong>高地址</strong>（比如 <code>0xFF...</code>）。对于栈帧来讲，这是稳固的地基。</p>\n<p><strong>天空（往上看）</strong>：是 <strong>低地址</strong>（比如 <code>0x00...</code>）。这是延伸空间。</p>\n<p>最底下是高地址，越往上，地址越低。</p>\n<p>有朋友可能会问：“书上或者 V8 源码注释里，通常都是画‘高地址在上，低地址在下’，栈是‘向下生长’的，为什么我们要反着来？”</p>\n<p>这其实是为了贴合<strong>直觉</strong>。 如果你使用过 OllyDbg、x64dbg 或 IDA 等调试工具，你会发现它们的内存视图通常是这样的：</p>\n<ul>\n<li><strong>上面</strong> 显示的是 <strong>低地址</strong>。</li>\n<li><strong>下面</strong> 显示的是 <strong>高地址</strong>。</li>\n</ul>\n<p><strong>这种视角的好处极其直观：</strong></p>\n<ul>\n<li><strong>入栈 Push</strong>：就像盖楼一样，在现有的楼顶上，<strong>往上</strong> 再盖一层（地址变低/变小）。</li>\n<li><strong>出栈 Pop</strong>：就像拆楼一样，把最上面的一层拆掉（地址变回高/变大）。</li>\n<li><strong>栈底</strong>：在最下面（高地址），通常存放着调用者的环境，在一个栈帧中，很少变动。</li>\n<li><strong>栈顶</strong>：在最上面（低地址），数据频繁进进出出出栈入栈，变动剧烈。</li>\n</ul>\n<p>所以，为了理解起来更顺畅，建议我们在脑海中建立的模型如下：</p>\n<ul>\n<li><strong>高地址在下</strong>（地基）。</li>\n<li><strong>低地址在上</strong>（天空）。</li>\n<li><strong>栈帧的生长方向</strong>：从下往上，<strong>向低地址生长</strong>。</li>\n</ul>\n</li>\n<li>\n<p>指针和内存单元</p>\n<p><strong>最小刻度：字节 (Byte)</strong> 在计算机里，<strong>8 bit (1字节)</strong> 是内存可寻址的最小单位。</p>\n<p><strong>实际步长：</strong>    虽然刻度是按 字节 画的，但在 64 位系统里，Ignition 这个老师傅手很大。 他干活时，<strong>不会像学友哥那样捏着兰花指去抓 1 个字节。</strong>   他<strong>每一次伸手，都要抓走 8 个字节</strong>（64 bit）。这 8 个字节合起来，才构成了一个完整的 <strong>槽位 (Slot)</strong>。</p>\n<p><strong>内存对齐：</strong> 每一次都要操作 8 个字节，所以，所操作的地址，都是8的倍数：</p>\n<p>0  8  16  24 。。。（这些数字仅仅是示意地址是8的倍数）</p>\n<p>这就是 <strong>内存对齐</strong>。</p>\n<p><strong>注意：</strong> 这并不代表地址 <code>1, 2, 3...7</code> 是“空闲”或者“没用”的。 当你向地址 <code>0</code> 写入一个 64 位指针或者数据时，这个指针或数据用64bit的庞大的身躯<strong>填满</strong>了从 <code>0</code> 到 <code>7</code> 的所有空间。 只不过，当我们想<strong>找到</strong>这个数据时，我们只在这个数据的<strong>头部（首地址）</strong> 找起。</p>\n<p><strong>地址 0</strong>：是第一个槽位的<strong>门口</strong>。<strong>地址 8</strong>：是第二个槽位的<strong>门口</strong>。</p>\n<p>这就解释了我们在前面内容中提到的 <strong>Tagged Pointer</strong> 原理： 因为地址只在 <code>0, 8, 16</code> 这些 <code>8</code> 的倍数上，所以这些地址的二进制表示，<strong>最后 3 位通常是 0</strong>。 V8 也是看准了这一点，才敢把这 3 位挪作他用（存类型 Tag）。</p>\n<p><strong>指针</strong>   如何理解？</p>\n<p>指针就是地址，之所以说是指针 而不是直接说地址，是因为 指针收紧了地址的概念。</p>\n<p>“地址”是物理层面的客观存在，而“指针”是软件层面的主观定义。指针对地址具有收紧和约束作用。</p>\n<p>准确的说  <strong>指针是对地址概念的一次“收紧”和“赋予语义”</strong>。</p>\n<ul>\n<li>\n<p><strong>地址</strong></p>\n</li>\n<li>\n<p><strong>本质</strong>：它只是一个冷冰冰的数字编号（比如 <code>0x0000FFFF</code>）。</p>\n</li>\n<li>\n<p><strong>缺陷</strong>：它没有任何约束。给你一个地址，你根本不知道那里住的是什么。</p>\n<ul>\n<li>是 4 个字节的整数？</li>\n<li>还是 1 个字节的字符？</li>\n<li>或者是一段可执行的代码？</li>\n<li>甚至可能是一个无效的垃圾值？</li>\n</ul>\n</li>\n<li>\n<p><strong>状态</strong>：如果你只拿到了一个地址，你面对的是未知的、混乱的内存空间。</p>\n</li>\n<li>\n<p>**指针 **</p>\n</li>\n<li>\n<p><strong>本质</strong>：<strong>指针 = 地址 + 类型约束（解释方式）</strong>。</p>\n</li>\n<li>\n<p><strong>收紧的概念</strong>：</p>\n<p>当我们定义一个指针（比如 C++ 里的 <code>int* p</code> 或 V8 里的 <code>Tagged Pointer</code>）时，我们实际上是<strong>收紧</strong>了对那个内存地址的操作权限和理解方式。</p>\n<ul>\n<li>它告诉 CPU：“别乱猜了，这个地址里存的一定是 <strong>对象</strong>，而不是整数。”</li>\n<li>它告诉编译器：“当你去读这个地址时，请按照 <strong>8 字节</strong> 为单位去读，不要只读 1 个字节。”</li>\n</ul>\n</li>\n</ul>\n<p>在 V8 的 Ignition 中，这种“收紧”体现得更全面：</p>\n<ol>\n<li>\n<p><strong>标签 (Tagging)</strong>：</p>\n<p>V8 的指针（Tagged Pointer）利用最低位（Tag Bit）强行规定了语义。</p>\n<ul>\n<li>如果最后一位是 <code>0</code>：<strong>收紧为“立即数”</strong>（Smi）。不需要去内存里找，它自己就是值。</li>\n<li>如果最后一位是 <code>1</code>：<strong>收紧为“堆指针”</strong>（HeapObject）。必须去堆里找。</li>\n</ul>\n</li>\n<li>\n<p><strong>隐藏类 (Map/Hidden Class)</strong>：</p>\n<p>当你顺着 V8 的指针找到堆里的对象时，对象的第一个属性通常是 <strong>Map</strong>（隐藏类）。</p>\n<p>这实际上是进一步的“收紧”：</p>\n<ul>\n<li>“这个地址不仅是个对象，而且它是一个 <strong>数组</strong>，长度是 10，元素类型是...”。</li>\n</ul>\n</li>\n</ol>\n<p>最后需要注意，越往底层，比如到了汇编  到了代码调试 ，对于指针和地址的区分，就越趋近于无，很多时候，都是混着叫的，基本上都是使用指针就是地址 这个本质概念了。因为约束已经剥离，只剩本质了。</p>\n<p><strong>调用约定</strong></p>\n<p>我们在前面学习了栈帧的物理结构：参数在高地址，返回地址在中间，变量在低地址。</p>\n<p>这时候，无中生友的朋友又出现了：为什么要这么放？我倒过来放不行吗  我混着放不行吗？</p>\n<p>这就引出了一个重要的概念 调用约定。</p>\n<ul>\n<li>\n<p>简单来说，调用约定就是 <strong>调用者 (Caller)</strong> 和 <strong>被调用者 (Callee)</strong> 之间达成的一份 <strong>“协议”</strong> 或 <strong>“合同”</strong>。</p>\n<p>想象一下两个人在玩球球：</p>\n<ul>\n<li>\n<p><strong>Caller</strong> 说：“我会把球抛到<strong>你的左手边</strong>。”</p>\n</li>\n<li>\n<p><strong>Callee</strong> 说：“好的，我会跑到<strong>左手边</strong>去接球。”</p>\n<p>这就是约定。如果 Caller 抛向左边，而 Callee 跑去右边接，球就掉了（程序崩溃）。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>在 V8 里，这份 协议/合同 规定了三个最核心的问题：</p>\n<ol>\n<li><strong>参数放哪？</strong> (传递方式)\n<ul>\n<li>是放在 CPU 寄存器里？还是压到栈内存里？</li>\n<li>如果是压栈，是从左往右压，还是从右往左压？</li>\n</ul>\n</li>\n<li><strong>结果放哪？</strong> (返回方式)\n<ul>\n<li>函数算完了，结果放在哪个寄存器里带回去？（通常是累加器/rax）。</li>\n</ul>\n</li>\n<li><strong>谁来打扫卫生？</strong> (堆栈平衡)\n<ul>\n<li>参数占用的栈空间，是 Caller 负责回收，还是 Callee 负责回收？</li>\n</ul>\n</li>\n</ol>\n<p><strong>V8的特殊之处：垃圾回收</strong></p>\n<p>在c / c++ 中， 标准约定通常会优先把前几个参数放在 <strong>物理寄存器</strong> 里传递，这样速度会达到极致。</p>\n<p>但是在V8的 Ignition 解释器里，我们看到参数几乎都是乖巧的排列在栈上。这是为什么？</p>\n<p>因为 V8 有一个幽灵暗卫 ，这就是 <strong>垃圾回收器 (GC)</strong>。</p>\n<ul>\n<li><strong>GC 的全年无休</strong>：GC 需要时刻扫描内存，看看哪些对象还活着（有指针指向它）。</li>\n<li><strong>寄存器无法跟踪</strong>：如果参数散落在各种物理寄存器里，这就很难追踪。</li>\n<li><strong>V8 的折中拖鞋</strong>：<strong>确保栈上有一份“可扫描”的备份。</strong></li>\n</ul>\n<p>即使某些参数是通过寄存器传进来的，为了方便 GC 撸羊肉串式的扫描，V8 通常也会保证这些参数在栈上有一个确定的位置（或者把寄存器的值“抄写”到栈上）。记得前面说PC的时候，提过一次。</p>\n<p>so  这就形成了我们在栈帧图中看到的那样,参数在内存里连续排列，GC 扫起来非常舒服。</p>\n<p><strong>再说栈帧的内存布局</strong></p>\n<p>在前面我们讲栈帧的结构时，从高地址到低地址，依次是  参数区--固定头部区--工作区，但是</p>\n<p>对于栈帧的分界和字段的所有者，并没有详细的说明。 现在我们有了足够的铺垫，可以详细了解了。</p>\n<p>我们需要按<strong>时间顺序</strong>走一遍流程。</p>\n<p>这对于理解 FP（栈帧指针）这个“界碑”至关重要。</p>\n<p><strong>第一阶段：调用者准备工作</strong></p>\n<p>调用者在执行 <code>CALL</code> 指令之前，需要先准备好贡品：</p>\n<ol>\n<li>\n<p><strong>Push 参数</strong>：调用者把参数（Receiver, a0, a1...）按顺序压入栈。</p>\n<ul>\n<li><em>(这是 Caller 划拨的内存，属于 Caller 的栈帧范围，但供 Callee 使用)</em></li>\n</ul>\n</li>\n<li>\n<p><strong>执行 CALL 指令</strong>：CPU 自动将 <strong>返回地址 (Return Address)</strong> 压入栈顶，并跳转到 Callee 的代码处。</p>\n<ul>\n<li><em>(此时，FP 指针依然指向 Caller 的老基准点)</em></li>\n</ul>\n</li>\n</ol>\n<p><strong>第二阶段：被调用者接手</strong></p>\n<p>控制权来到了 Ignition（被调用者）手中，它进门后的<strong>头等大事</strong>就是建立自己的宗门（栈帧）：</p>\n<ol>\n<li><strong>Push Caller's FP</strong>：Ignition 做的第一件事，就是把旧的 FP（上一层的基准点）压入栈中保存起来。\n<ul>\n<li><em>(这一步形成了 Saved FP，也就是栈帧中间的那个连接点)</em></li>\n</ul>\n</li>\n<li><strong>Set New FP</strong>：Ignition 把当前的栈顶指针 (SP) 赋值给 FP。\n<ul>\n<li><em>(从此，FP 指向了 Saved FP。新的栈帧基准点正式建立)</em></li>\n</ul>\n</li>\n<li><strong>Push Fixed Header</strong>：接着，Ignition 依次压入 Context、Function、BytecodeArray、BytecodeOffset 等固定字段。</li>\n<li><strong>Allocate Locals</strong>：最后，根据 Frame Size，一次性把栈顶指针 (SP) 往下移，为局部变量（r0, r1...）留出空间，并初始化为 <code>undefined</code> 或 <code>The Hole</code>。</li>\n</ol>\n<h3 id=\"_\"></h3>\n<p>有了这个流程，我们再看“户口归属”就非常清晰了：</p>\n<ul>\n<li>\n<p><strong>FP 及其上方 (参数、返回地址)</strong>： 虽然物理上和 FP 连在一起，但它们是 <strong>Caller</strong> 在第一阶段留下的“遗产”。</p>\n<ul>\n<li>参数是 Caller 带来的。</li>\n<li>返回地址是 Caller 带来的。</li>\n<li>Saved FP 是 Callee 为了保护 Caller 而存的。</li>\n</ul>\n</li>\n<li>\n<p><strong>FP 下方 (固定头部、工作区)</strong>： 这是 <strong>Callee</strong> 在第二阶段亲手创建的“资产”。</p>\n<ul>\n<li>Context 是 Callee 找来的。</li>\n<li>局部变量是 Callee 分配的。</li>\n</ul>\n</li>\n</ul>\n<p>这样，我们再来看栈帧的结构，理解上的逻辑就完全闭环了： <strong>Caller 给资源（参数） --- 硬件给退路（返回地址） ---  Callee 建地基（保存旧FP） ---  Callee 建房子（头部和变量）。</strong></p>\n<p><strong>FP和偏移量</strong></p>\n<p>在前面我们学习栈帧的固定头部中的字段时，我们使用了 FP加偏移值 的表示方式。</p>\n<p>爱琢磨的朋友肯定会有疑问：<strong>为什么所有东西都要盯着 FP 看？为什么是这些特定的数字？FP 里面到底装了什么？</strong></p>\n<ol>\n<li><strong>为什么选 FP (Frame Pointer) 做基准？</strong></li>\n</ol>\n<p>你可能会问：“栈顶指针 <strong>SP (Stack Pointer)</strong> 也是个指针，而且它就在栈顶，为什么不用 SP 来找数据，非要专门维护一个 FP 呢？”</p>\n<p><strong>原因就是：SP 是“动”的，FP 是“静”的。</strong></p>\n<ul>\n<li>\n<p><strong>SP 的动如脱兔</strong>：</p>\n<p>在函数执行过程中，Ignition 可能会频繁地入栈、出栈（比如压入临时变量、准备子函数参数）。</p>\n<p>这就导致 SP 的位置一直在变。</p>\n<p>如果用 SP 做基准，当你找 <code>变量 a</code> 时，上一行代码可能是 <code>[SP + 8]</code>，下一行代码因为压了个临时值，就变成 <code>[SP + 16]</code> 了。编译器计算起来会疯掉。</p>\n</li>\n<li>\n<p><strong>FP 的静如瘫痪</strong>：</p>\n<p>一旦栈帧建立完毕（Prologue 结束），在整个函数执行期间，<strong>FP 指针就是钉在栈帧的固定位置（Saved FP 那个槽位），雷打不动。</strong></p>\n<p>此时，我们以 FP 为原点，向上下看：</p>\n<p><strong>往下看（向地基/高地址）</strong>：不管栈顶怎么变，参数 <code>a0</code> 永远在 FP <strong>往下数</strong> 第 2 格的位置（偏移量是正数，如 <code>FP + 16</code>）。</p>\n<p><strong>往上看（向天空/低地址）</strong>：不管栈顶怎么变，变量 <code>r0</code> 永远在 FP <strong>往上数</strong> 第 5 格的位置（偏移量是负数，如 <code>FP - 40</code>）。</p>\n</li>\n</ul>\n<p><strong>所以</strong>：FP 提供了一个<strong>静态的、绝对的</strong>参考坐标系。</p>\n<ol start=\"2\">\n<li>**FP和地址和内容 **</li>\n</ol>\n<p>这是初接触的朋友，理解栈帧链表最容易迷糊的地方。</p>\n<p>我们要区分三个概念：</p>\n<ul>\n<li><strong>FP 寄存器</strong>：</li>\n</ul>\n<p>可以简化理解为，这是 CPU 里的一个物理部件（或 Ignition 的虚拟指针）。</p>\n<ul>\n<li><strong>FP 中的内容</strong>：</li>\n</ul>\n<p>FP中的内容就是 一个内存地址。</p>\n<p>这个内存地址是个指针，指向当前栈帧中的一个字段，</p>\n<p>同时，这个内存地址/指针，也是当前栈帧的 <strong>“零点”</strong>。即 <code>Offset = 0</code>。</p>\n<ul>\n<li><strong>FP 指向的内存地址里存的内容</strong>：</li>\n</ul>\n<p>那么 这个栈帧中的字段，里面的内容是什么？</p>\n<p><strong>答案是：Caller's FP (调用者的 FP)。</strong></p>\n<p>即：上一层栈帧的基准地址。</p>\n<p><strong>这同时也是“栈回溯”的原理：</strong></p>\n<ul>\n<li>当前 FP 指向 <code>Saved FP</code>。</li>\n<li><code>Saved FP</code> 里存着 <code>上一层 FP</code>。</li>\n<li><code>上一层 FP</code> 里存着 <code>上上层 FP</code>。</li>\n<li>...</li>\n<li>这就形成了一条<strong>链表</strong>。调试器（Debugger）就是顺着这条链子，一层层往上爬，才打印出了完整的调用栈。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>偏移量 (Offset) 是怎么确定的？</strong></li>\n</ol>\n<p>搞懂了 FP 是零点，那么，对于参数和变量的寻址，就非常容易理解了。</p>\n<p>让我们站在 FP 这个零点，开始巡视：</p>\n<p><strong>A. 往下看：Caller 留下的遗产 (因为我们使用高地址在下，低地址在上的模式)</strong></p>\n<p>这里是地址 <strong>增加</strong> 的方向（Offset 是 <strong>正数 +</strong>），因为我们在往高地址走。</p>\n<ul>\n<li><strong>Offset     +0 (<code>[FP + 0]</code>)</strong>： 就是脚下。这里存的是 <strong>Saved FP</strong>。</li>\n<li><strong>Offset     +8 (<code>[FP + 8]</code>)</strong>： <strong>往下</strong> 走 1 格。 这里是 <strong>Return Address</strong>。 <em>(为什么是 +8？因为往高地址走了 8 字节。)</em></li>\n<li><strong>Offset     +16 (<code>[FP + 16]</code>)</strong>： <strong>再往下</strong> 走 1 格。 这里是 <strong>Receiver (this)</strong>。 <em>(注：这是雷打不动的专座，离 FP 最近的参数。)</em></li>\n<li><strong>Offset     +24 (<code>[FP + 24]</code>)</strong>： <strong>再往下</strong> 走 1 格。 这里是 <strong>第一个显式参数 (Arguments a0)</strong>。 <em>(注：如果有更多参数 a1, a2... 会继续往下排在 +32, +40...)</em></li>\n</ul>\n<p><strong>B. 往上看：Callee 自己的资产 (低地址区)</strong></p>\n<p>关于偏移量的具体值，在前面，特别说明是用于  <strong>示意</strong>  ，  V8源码中的偏移如下，暂时可以作为确定值，但是以后很有<strong>可能会更改</strong>。</p>\n<blockquote>\n<p><strong>FP (基准)</strong></p>\n<p><strong>[FP - 8]</strong>: <code>StandardFrameConstants::kContextOffset</code> -&gt; <strong>Context</strong></p>\n<p><strong>[FP - 16]</strong>: <code>StandardFrameConstants::kFunctionOffset</code> -&gt; <strong>Function</strong></p>\n<p><strong>[FP - 24]</strong>: <code>InterpretedFrameConstants::kBytecodeArrayFromFp</code> -&gt; <strong>BytecodeArray</strong> (解释器特有)</p>\n<p><strong>[FP - 32]</strong>: <code>InterpretedFrameConstants::kBytecodeOffsetFromFp</code> -&gt; <strong>BytecodeOffset (PC)</strong></p>\n<p><strong>[FP - 40]</strong>: <code>InterpretedFrameConstants::kRegisterFileFromFp</code> -&gt; <strong>r0 (Register 0)</strong> (工作区起点)</p>\n</blockquote>\n<p>这里也需要加一个限定：</p>\n<p><strong>在 64 位系统下，Ignition 解释器栈帧的固定头部布局通常如下：</strong></p>\n<p>这里是地址 <strong>减小</strong> 的方向（Offset 是 <strong>负数 -</strong>），因为我们在往低地址（栈顶）方向爬。</p>\n<ul>\n<li><strong>Offset     -8 (<code>[FP - 8]</code>)</strong>： <strong>往上</strong> 爬 1 格。 这里是 <strong>Context</strong>。 <em>(为什么是负数？因为离天空更近了，地址变小了。)</em></li>\n<li><strong>Offset    -16 (<code>[FP - 16]</code>)</strong>： <strong>再往上</strong> 爬 1 格。 这里是 <strong>Function</strong>。</li>\n<li><strong>Offset    -24 (<code>[FP - 24]</code>)</strong>： <strong>再往上</strong> 爬 1 格。 这里是 <strong>BytecodeArray</strong>。</li>\n<li><strong>Offset    -32 (<code>[FP - 32]</code>)</strong>： <strong>再往上</strong> 爬 1 格。 这里是 <strong>BytecodeOffset (PC)</strong>。 <em>(注：到这里，固定头部结束)</em></li>\n<li><strong>Offset     -40 (<code>[FP - 40]</code>)</strong>： <strong>再往上</strong> 爬 1 格。 终于到了 <strong>工作区</strong>。这里是 <strong>r0</strong>。</li>\n</ul>\n</li>\n</ul>\n<hr />\n<p>ignition解释器的第一部分，已经完成了，后面将是ignition篇的第二部分BytecodeGenerator。</p>\n<p>本想控制篇幅，但是依旧是到了一万一千多字，这部分内容，难度不大，深度不深，主要都是一些前置和基础知识。感兴趣的朋友，多读几遍，都可以理解的。 我觉得  起码比解析篇容易理解多了。</p>\n<p>本文首发于： <a href=\"https://juejin.cn/user/565561530002222/posts\" rel=\"noopener nofollow\" target=\"_blank\">掘金社区</a></p>\n<p>同步发表于： <a href=\"https://blog.csdn.net/f20171110?type=blog\" rel=\"noopener nofollow\" target=\"_blank\">csdn</a></p>\n<p><a href=\"https://www.cnblogs.com/f20171110\" target=\"_blank\">博客园</a></p>\n<p><strong>码字虽不易 知识脉络的梳理更是不易 ，但是知识的传播更重要，</strong></p>\n<p><strong>欢迎转载，请保持全文完整。</strong></p>\n<p><strong>谢绝片段摘录。</strong></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 19:19</span>&nbsp;\n<a href=\"https://www.cnblogs.com/f20171110\">用户新</a>&nbsp;\n阅读(<span id=\"post_view_count\">3</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "LLVM Pass快速入门(四)：代码插桩",
      "link": "https://www.cnblogs.com/ClownLMe/p/19575719",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ClownLMe/p/19575719\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 17:49\">\n    <span>LLVM Pass快速入门(四)：代码插桩</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        从0到1，快速入门 LLVM pass 编写\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"代码插桩\">代码插桩</h1>\n<p>项目需求：在函数运行时打印出运行的函数名</p>\n<h1 id=\"项目目录如下\">项目目录如下</h1>\n<pre><code>/MyProject\n├── CMakeLists.txt # CMake 配置文件\n├── build/ #构建目录\n│   └── test.c #测试编译代码\n└── mypass3.cpp # pass 项目代码\n</code></pre>\n<h3 id=\"一测试代码示例\">一，测试代码示例</h3>\n<p><strong>test.c</strong></p>\n<pre><code class=\"language-c\">#include &lt;stdio.h&gt;\n\nvoid func_A() {\n    int a = 1;\n}\n\nvoid func_B() {\n    func_A();\n}\n\nint main() {\n    printf(\"hello world!\\n\");\n    func_A();\n    func_B();\n    return 0;\n}\n</code></pre>\n<h3 id=\"二编写pass\">二，编写Pass</h3>\n<p>其他的固定的模板之前文章注释有，这里我只注释当前项目重要的部分<br />\n<strong>代码流程：</strong> 遍历指令并匹配<code>ADD</code>指令-&gt;替换为<code>sub</code>指令</p>\n<pre><code class=\"language-cpp\">#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Passes/PassBuilder.h\"\n#include \"llvm/Passes/PassPlugin.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/IRBuilder.h\" \n\nusing namespace llvm;\n\nnamespace {\n\nstruct mypass3 : public PassInfoMixin&lt;mypass3&gt; {\n    \n    PreservedAnalyses run(Function &amp;F, FunctionAnalysisManager &amp;) {\n        //过滤函数\n        //过滤掉printf和printf有关的函数，防止在printf中插入printf造成递归（死循环）\n        if(F.isDeclaration() || F.getName().starts_with(\"_\") || F.getName().contains(\"printf\")){\n            return PreservedAnalyses::all();\n        }\n        errs() &lt;&lt; \"handle func:\" &lt;&lt; F.getName() &lt;&lt; \"\\n\";\n\t\t\n\t\t//获取模块\n        Module *M = F.getParent();\n        //获取模块上下文\n        //上下文中包含了数据的类型\n        LLVMContext &amp;Ctx = M-&gt;getContext();\n        \n        //下面是创建函数，类比java反射，或者frida的hook\n        //定义printf的参数类型，相当于函数括号中的内容，这里的PointerType是指针类型\n        std::vector&lt;Type*&gt; printfArgs = {PointerType::getUnqual(Ctx)};\n\t\t//定义函数类型，这里相当于定义：int (void*, ...)\n        FunctionType *printfType = FunctionType::get(\n            Type::getInt32Ty(Ctx),//函数返回值类型\n            printfArgs,//函数的参数类型(vector)\n            true//是否是可变参数\n        );\n\t\t//如果printf存在则引用，如果不存在，则创建一个新的printf\n        FunctionCallee printfFunc = M-&gt;getOrInsertFunction(\"printf\", printfType);\n\t\t\n\t\t//下面是插入函数\n\t\t//将修改的位置定位到要插桩函数的头部\n        IRBuilder&lt;&gt; builder(&amp;F.getEntryBlock().front());\n        //声明全局变量（这里是要传给printf的格式化字符串）\n        Value* formatStr = builder.CreateGlobalStringPtr(\"&gt;&gt; enter function %s &lt;&lt;\\n\", \"my_format\");\n        //声明全局变量，这里定义了函数名称的字符串变量\n        Value* funcName = builder.CreateGlobalStringPtr(F.getName(), \"my_func_name\");\n        //将上面定义的实际参数传入\n        std::vector&lt;Value*&gt; printfArgsVec = {formatStr, funcName};\n        //创建函数调用\n        builder.CreateCall(printfFunc, printfArgsVec);\n        \n        return PreservedAnalyses::none();\n    }\n};\n\n} \n\nextern \"C\" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo\nllvmGetPassPluginInfo() {\n    return {\n        LLVM_PLUGIN_API_VERSION,\n        \"mypass3\",\n        \"v0.1\",\n        [](PassBuilder &amp;PB) {\n            PB.registerPipelineParsingCallback(\n                [](StringRef Name, FunctionPassManager &amp;FPM,\n                   ArrayRef&lt;PassBuilder::PipelineElement&gt;) {\n                    if (Name == \"mypass3\") {\n                        FPM.addPass(mypass3());\n                        return true;\n                    }\n                    return false;\n                });\n        }};\n}\n</code></pre>\n<h3 id=\"三pass的构建\">三，Pass的构建</h3>\n<p><strong>下面引用的是之前文章的内容</strong><br />\n构建LLVM Pass需要写<code>CMakeLists.txt</code>构建声明</p>\n<h5 id=\"1-配置cmake配置文件\">1. 配置CMake配置文件</h5>\n<p><strong>CMakeLists.txt</strong><br />\n下面的<code>cmake</code>配置可以直接拿去用，我已经标注好需要修改的位置</p>\n<pre><code class=\"language-python\">#cmake 版本，可通过 cmake --version 判断\ncmake_minimum_required(VERSION 4.1.1) #----&gt;修改 cmake版本号\n#项目名字\nproject(mypass3) #----&gt;修改 项目名称\n\n#导入项目的 LLVM cmake 配置文件路径(如果根据我之前文章安装这里就相同)\nset(LLVM_DIR \"D:/LLVM/llvm-project/build/lib/cmake/llvm\")#----&gt;修改 llvm cmake配置路径\n#寻找 LLVM 的包文件\n#REQUIRED 找不到 LLVM 则停止构建\n#强制使用 LLVM 安装时生成的配置文件进行定位\nfind_package(LLVM REQUIRED CONFIG)\n#将 LLVM 的 CMake 模块路径添加到当前 CMake 搜索路径中，以便后续使用 include(AddLLVM)。\nlist(APPEND CMAKE_MODULE_PATH \"${LLVM_CMAKE_DIR}\")\n\n#引入 LLVM 提供的专用 CMake 宏\ninclude(AddLLVM)\n#将 LLVM 的头文件目录（如 llvm/IR/Function.h）加入编译器的搜索路径\ninclude_directories(${LLVM_INCLUDE_DIRS})\n#导入 LLVM 编译时使用的宏定义\nadd_definitions(${LLVM_DEFINITIONS})\n#设置 C++ 标准为 C++17。(这里如果不用17编译会报错)\nset(CMAKE_CXX_STANDARD 17)\n#强制要求必须支持 C++17，如果编译器不支持则失败。\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n#创建一个模块化的库(.dll)\nadd_library(mypass3 MODULE mypass3.cpp) #----&gt;修改 项目名称，文件名\n#windows不用会报错：导出符号\n#LLVM Pass 需要暴露一些特定的入口点（如 getAnalysisUsage）给 opt 工具调用。\nset_target_properties(mypass3 PROPERTIES WINDOWS_EXPORT_ALL_SYMBOLS ON) #----&gt;修改 项目名称\n# 指定该 Pass 需要链接的 LLVM 核心组件。 \n# LLVMCore: 提供 IR、Function、Module 等核心类。 \n# LLVMSupport: 提供各种辅助工具类（如 errs() 输出）。\ntarget_link_libraries(mypass3 LLVMCore LLVMSupport) #----&gt;修改 项目名称，文件名  \n# 为该目标设置特定的编译器选项。 \n# /utf-8: 告诉 MSVC 编译器使用 UTF-8 编码处理源代码，防止中文注释引起的乱码或编译错误。  \ntarget_compile_options(mypass3 PRIVATE /utf-8)#----&gt;修改 项目名称，文件名\n</code></pre>\n<h5 id=\"2编译并构建pass\">2.编译并构建Pass</h5>\n<p><strong>打开visual studio<code>的工作台，我这里是</code>x64 Native Tools Command Prompt for VS 2022`</strong></p>\n<p>进到<code>build</code>目录</p>\n<pre><code class=\"language-bash\">#构建项目\n#其中-DCMAKE_BUILD_TYPE=RelWithDebInfo不选会报错，由于我之前编译的是带符号的relase版本\ncmake -G \"Ninja\"  -DCMAKE_BUILD_TYPE=RelWithDebInfo ..\n#编译\nninja\n</code></pre>\n<p>最后出现下面提示，即为编译成功</p>\n<pre><code class=\"language-bash\">[2/2] Linking CXX shared module mypass3.dll\n</code></pre>\n<h3 id=\"四使用插桩pass对源码进行插桩\">四，使用插桩Pass对源码进行插桩</h3>\n<p>进到<code>build</code>目录</p>\n<pre><code class=\"language-bash\">#把.c文件编译为.ll\n#-O1 使用O1优化（这里我尝试-O0不优化，会导致我的pass无法应用）\n#-Xclang -disable-llvm-passes 不使用默认的pass优化\nclang -S -emit-llvm -O1 -Xclang -disable-llvm-passes test.c -S -o test.ll\n\n#使用pass\nopt -load-pass-plugin=mypass3.dll -passes=mypass3  test.ll -S -o test_opt.ll\n\n#编译使用pass后的exe\nclang test_opt.ll -o test_opt.exe\n#编译使用pass前的exe\nclang test.ll -o test.exe\n</code></pre>\n<p><strong>输出结果</strong><br />\n<code>运行test.exe</code>：<strong>不使用</strong>pass，输出结果如下：</p>\n<pre><code>hello world!\n</code></pre>\n<p><code>运行test_opt.exe</code>：<strong>使用</strong>pass后，输出结果如下：</p>\n<pre><code>&gt;&gt; enter function main &lt;&lt;\nhello world!\n&gt;&gt; enter function func_A &lt;&lt;\n&gt;&gt; enter function func_B &lt;&lt;\n&gt;&gt; enter function func_A &lt;&lt;\n</code></pre>\n<p><strong>我们成功在我们调用函数之前插桩，打印出调用的函数</strong></p>\n<p><strong>如果❤喜欢❤本系列教程，就点个关注吧，后续不定期更新~</strong></p>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/ClownLMe/\" target=\"_blank\">ClownLMe</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/ClownLMe/p/19575719\" target=\"_blank\">https://www.cnblogs.com/ClownLMe/p/19575719</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 17:49</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ClownLMe\">ClownLMe</a>&nbsp;\n阅读(<span id=\"post_view_count\">12</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "鸿蒙应用开发UI基础第二节：鸿蒙应用程序框架核心解析与实操",
      "link": "https://www.cnblogs.com/san-xiu/p/19575201",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/san-xiu/p/19575201\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 16:36\">\n    <span>鸿蒙应用开发UI基础第二节：鸿蒙应用程序框架核心解析与实操</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"学习目标\">学习目标</h2>\n<ol>\n<li>建立鸿蒙应用“宏观-微观”完整认知：明确应用、应用程序包、HAP/HSP、组件、页面的层级关系，理解 Stage 模型编译期与运行期概念的对应逻辑；</li>\n<li>清晰区分 Stage 模型与 FA 模型的核心差异，理解 Stage 模型在资源利用、配置管理、跨端适配等实际开发场景中的核心优势；</li>\n<li>掌握 Stage 模型进程/线程管理机制，理解 UIAbility 与 ExtensionAbility 的线程隔离特性，以及多线程开发的核心思路；</li>\n<li>熟练掌握 UIAbility 在 module.json5 中的核心配置项及规则，精准定位 Stage 工程核心文件并理清依赖链路；</li>\n<li>能独立完成应用名称/图标修改、UIAbility 配置调整、页面加载路径切换等实操，结合工程编译机制验证效果并排查基础配置与编译错误。</li>\n</ol>\n<p>上一节我们掌握了应用配置签名真机调试，本节开始从“应用整体架构”切入，聚焦 Stage 模型核心交互组件 UIAbility 核心能力展开，结合工程编译机制，帮助构建鸿蒙应用开发基础认知体系，为后续应用生命周期、Context 上下文、进程通信等进阶内容学习打下基础。</p>\n<h2 id=\"一回顾鸿蒙系统架构\">一、回顾鸿蒙系统架构</h2>\n<p>鸿蒙系统采用分层架构，共四层，开发者核心工作集中在顶层两层：</p>\n<ol>\n<li><strong>应用层</strong>：面向用户的应用载体，包含两种形态\n<ul>\n<li>原生应用：基于 ArkTS 开发，性能最优，能深度调用分布式能力，是鸿蒙生态核心；</li>\n<li>元服务：免安装、轻量便捷，适合高频次、低留存场景（如扫码支付）；</li>\n</ul>\n</li>\n<li><strong>框架层</strong>：开发聚焦在框架层，提供 ArkUI 组件、状态管理、路由/导航跳转等核心能力，后续组件开发、布局设计均依赖此层；</li>\n<li><strong>系统服务层</strong>：封装分布式能力、设备管理等基础服务，开发者通过 API 调用即可，无需关注底层实现；</li>\n<li><strong>内核层</strong>：负责进程调度、内存管理等底层操作，开发者无需深入接触。</li>\n</ol>\n<p><strong>图 1：鸿蒙系统架构图</strong> - 展示四层架构层级关系，标注开发者核心关注的应用层与框架层。</p>\n<p><img alt=\"鸿蒙系统架构教学版本\" class=\"lazyload\" /></p>\n<blockquote>\n<p>HarmonyOS 5.0 开始彻底完成 Linux 内核和安卓开放源代码项目（AOSP）的全面替换，采用纯鸿蒙内核（HarmonyOS Kernel），实现全栈自研。本阶段所有内容均基于鸿蒙 5.0~6.0 版本进行应用开发讲解。</p>\n</blockquote>\n<h2 id=\"二程序框架服务ability-kit\">二、程序框架服务（Ability Kit）</h2>\n<h3 id=\"一核心定义\">（一）核心定义</h3>\n<p>Ability Kit（程序框架服务）是鸿蒙系统为应用提供的核心运行时基础框架，抽象提炼应用开发所需核心能力，提供标准化组件体系和运行机制。<strong>核心价值是让开发者基于统一模型开发应用，同时保障应用在多设备、多场景下的兼容性与性能</strong>。</p>\n<h3 id=\"二核心能力与使用场景\">（二）核心能力与使用场景</h3>\n<table>\n<thead>\n<tr>\n<th>能力范围</th>\n<th>具体内容</th>\n<th>典型使用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>生命周期与进程管理</td>\n<td>应用/组件进程创建销毁、生命周期调度</td>\n<td>多 Module 应用开发，HAP/HSP 分工实现功能</td>\n</tr>\n<tr>\n<td>组件交互能力</td>\n<td>组件间/应用间跳转、跨设备流转</td>\n<td>办公应用内启动视频会议组件、购物应用跳转支付应用、视频跨设备流转</td>\n</tr>\n<tr>\n<td>基础支撑能力</td>\n<td>上下文环境、系统事件监听、启动框架、意图框架等</td>\n<td>应用快捷方式配置、程序访问控制、密码自动填充</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"三核心特征\">（三）核心特征</h3>\n<ol>\n<li><strong>标准化开发范式</strong>：抽象应用开发通用能力，提供统一的组件体系、生命周期规则，降低跨设备/跨版本适配成本；</li>\n<li><strong>高效资源调度</strong>：统一管理应用进程/线程，优化组件启动、内存占用等性能指标；</li>\n<li><strong>系统能力封装</strong>：内置意图框架、启动框架、流转能力等，无需开发者手动对接底层系统 API；</li>\n<li><strong>多场景支撑</strong>：通过 ExtensionAbility 覆盖备份、输入法、卡片等无 UI/轻 UI 场景，平衡功能扩展与系统管控。</li>\n</ol>\n<h3 id=\"四核心关联\">（四）核心关联</h3>\n<ul>\n<li><strong>ArkUI</strong>：UIAbility 组件中可使用 ArkUI 的组件、事件、动效、状态管理等能力实现界面开发；</li>\n<li><strong>ArkTS</strong>：提供语言运行时能力，支撑 Ability Kit 的代码执行；</li>\n<li><strong>Hvigor</strong>：鸿蒙官方构建工具，为 Ability Kit 相关组件与配置提供编译构建能力，实现代码与配置的工程化落地。</li>\n</ul>\n<h2 id=\"三鸿蒙应用模型\">三、鸿蒙应用模型</h2>\n<h3 id=\"一核心定义与构成要素\">（一）核心定义与构成要素</h3>\n<p>应用模型是 Ability Kit 对应用开发能力的抽象封装，定义应用的组件体系、运行机制、配置规范等核心规则，核心构成要素如下：</p>\n<table>\n<thead>\n<tr>\n<th>构成要素</th>\n<th>核心作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>应用组件</td>\n<td>应用运行入口，通过生命周期回调感知状态变化</td>\n</tr>\n<tr>\n<td>进程/线程模型</td>\n<td>定义进程/线程的创建、销毁及通信方式</td>\n</tr>\n<tr>\n<td>任务管理模型</td>\n<td>定义任务创建、销毁及与组件的关联（仅系统应用）</td>\n</tr>\n<tr>\n<td>应用配置文件</td>\n<td>存储应用/组件配置、权限等信息，供编译/运行阶段使用</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"二演进历程fa-模型--stage-模型\">（二）演进历程：FA 模型 → Stage 模型</h3>\n<table>\n<thead>\n<tr>\n<th>模型类型</th>\n<th>适配版本</th>\n<th>核心状态</th>\n<th>官方开发优势</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>FA 模型</td>\n<td>API 7~8</td>\n<td>已停止更新</td>\n<td>-</td>\n</tr>\n<tr>\n<td>Stage 模型</td>\n<td>API 9+</td>\n<td>主推且长期演进</td>\n<td>1. 组件职责清晰，开发效率更高；2. 资源占用更低，启动速度更快；3. 跨端适配更便捷；4. 系统能力集成更简单；5. 编译分层设计，支持模块按需编译，提升开发效率</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"三fa-模型与-stage-模型核心差异\">（三）FA 模型与 Stage 模型核心差异</h3>\n<table>\n<thead>\n<tr>\n<th>对比维度</th>\n<th>FA 模型</th>\n<th>Stage 模型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>组件体系</td>\n<td>Page/Service/DataAbility（匿名对象）</td>\n<td>UIAbility+ExtensionAbility（类继承）</td>\n</tr>\n<tr>\n<td>引擎机制</td>\n<td>每个组件独享 ArkTS 引擎实例</td>\n<td>所有组件共享一个 ArkTS 引擎实例</td>\n</tr>\n<tr>\n<td>进程模型</td>\n<td>主进程+渲染进程</td>\n<td>主进程+可配置独立进程（ExtensionAbility支持进程自定义）</td>\n</tr>\n<tr>\n<td>线程模型</td>\n<td>引擎实例在非主线程创建，不支持进程内对象共享</td>\n<td>引擎实例在主线程创建，支持进程内对象共享</td>\n</tr>\n<tr>\n<td>配置文件</td>\n<td>单一 config.json（混编全局/模块配置）</td>\n<td>app.json5（应用级）+ module.json5（模块级）</td>\n</tr>\n<tr>\n<td>编译机制</td>\n<td>整体工程编译，修改局部需重新编译全部</td>\n<td>分层编译，支持模块/全局编译，按需编译修改部分，效率更高</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"四stage-模型核心架构与组成\">（四）Stage 模型核心架构与组成</h3>\n<h4 id=\"1-stage-模型核心架构图\">1. Stage 模型核心架构图</h4>\n<p><strong>图 2：Stage 模型编译期-运行期架构图</strong> - 左侧为运行期概念（应用实例化流程），右侧为编译期概念（开发打包流程），展示“模块→组件→页面”的打包与实例化对应关系。</p>\n<p><img alt=\"Stage模型开发概述\" class=\"lazyload\" /></p>\n<h4 id=\"2-核心组成单元\">2. 核心组成单元</h4>\n<ol>\n<li><strong>AbilityStage</strong>：可选实现（若不实现，系统默认创建）；Entry/Feature 类型 HAP 的运行时载体，<strong>一个 HAP 对应一个 AbilityStage 实例</strong>，负责 HAP 的初始化、组件创建分发、模块级生命周期管理；</li>\n<li><strong>UIAbility</strong>：带 UI 的核心交互组件，通过 WindowStage 管理窗口，实现用户交互；</li>\n<li><strong>ExtensionAbility</strong>：面向特定场景的扩展组件（如 EntryBackupAbility、InputMethodExtensionAbility），是 UIAbility 的扩展，用于无界面的后台能力（如备份、输入法）；</li>\n<li><strong>WindowStage</strong>：与 UIAbility 实例绑定的窗口管理器，负责窗口创建、销毁，为 ArkUI 提供绘制区域；</li>\n<li><strong>Context</strong>：派生类（ApplicationContext/AbilityStageContext/UIAbilityContext）为不同层级提供运行期资源调用、权限管理等能力；</li>\n<li><strong>三级生命周期</strong>：Application（应用级）→ AbilityStage（模块级）→ UIAbility/ExtensionAbility（组件级），由 Ability Kit 统一调度，实现资源精细化管理。</li>\n</ol>\n<h4 id=\"3-核心层级关系说明\">3. 核心层级关系说明</h4>\n<ol>\n<li>层级关联：Application（应用全局）→ AbilityStage（HAP 模块）→ UIAbility/ExtensionAbility（组件），依次依赖创建；</li>\n<li>持有关系：UIAbility→WindowStage→Window→ArkUI Page，且各层级均持有对应 Context；</li>\n<li>对应关系：Application ↔ Bundle，AbilityStage ↔ HAP（1:1 绑定）。</li>\n</ol>\n<pre><code># 编译期（开发/打包）\n应用程序包（Bundle） → 模块（HAP/HSP） → 组件（UIAbility/ExtensionAbility） → 页面（Page）\n\n# 运行期（安装/启动）\nApplication（应用全局实例） → AbilityStage（HAP 模块实例） → 组件实例 → 页面渲染\n</code></pre>\n<h3 id=\"五stage-模型开发与运行全流程\">（五）Stage 模型开发与运行全流程</h3>\n<h4 id=\"1-开发阶段\">1. 开发阶段</h4>\n<p>开发者基于 Stage 模型完成应用功能开发与配置，核心工作包括：</p>\n<ul>\n<li><strong>应用组件开发</strong>：通过 UIAbility 组件开发带界面的用户交互模块（如应用主界面），通过 ExtensionAbility 等组件开发各类扩展功能模块；</li>\n<li><strong>模块解耦设计</strong>：为减少不同功能模块间的依赖和耦合，可将 UIAbility 和各类 ExtensionAbility 的实现分别放在不同的 HAP 包中，同时将两者共同依赖的通用功能放在 HSP 包中；</li>\n<li><strong>配置文件编写</strong>：在 app.json5 中配置应用名称、版本号、应用图标等全局信息，在 module.json5 中配置对应 HAP 包下的组件清单、组件权限、进程归属等模块级信息；配置信息会在应用编译、安装时被系统解析，便于系统和其他模块识别、交互。</li>\n</ul>\n<h4 id=\"2-运行阶段\">2. 运行阶段</h4>\n<p>当应用安装到设备运行时，系统通过一套应用进程和线程的管理机制，确保功能的有序运行：</p>\n<ul>\n<li>进程是应用运行的基础单元，负责资源分配和隔离；</li>\n<li>线程是进程内的执行单元，负责具体代码逻辑的执行；</li>\n<li>Ability Kit 统一管控进程/线程的创建、销毁和调度，保障应用稳定运行。</li>\n</ul>\n<h4 id=\"3-进程模型\">3. 进程模型</h4>\n<ul>\n<li>基础规则：UIAbility 组件默认运行在应用主进程中； ExtensionAbility 组件<strong>进程行为可配置</strong>，可通过<code>module.json5</code>中的<code>process</code>字段进行配置；</li>\n<li>配置方式：在 ExtensionAbility 组件的配置节点中添加<code>process</code>字段，值以<code>:</code>开头表示配置为独立进程运行，未配置则默认与 UIAbility 同进程运行；</li>\n<li>通信规则：ExtensionAbility 与 UIAbility 同进程时为线程隔离状态，数据和资源不直接互通；独立进程时需通过跨进程通信机制实现数据交互；</li>\n<li>核心价值：进程可配置性兼顾了应用性能和稳定性——轻量扩展组件与主进程共享资源，减少进程开销；核心/高隔离性扩展组件独立进程运行，避免单一组件异常影响整个应用。</li>\n</ul>\n<h4 id=\"4-组件通信机制\">4. 组件通信机制</h4>\n<p>鸿蒙提供多套通信机制，适配不同组件类型、不同进程归属的通信场景，核心分类如下：</p>\n<ul>\n<li><strong>进程内通信</strong>：适用于同一进程内的 UIAbility 与 ExtensionAbility、UIAbility 与页面间，优先使用<strong>EventHub</strong>，轻量高效、无需复杂配置；</li>\n<li><strong>跨进程通信</strong>：适用于跨应用、独立进程的 HAP 之间、独立进程 ExtensionAbility 与 UIAbility 之间，使用<strong>IPC</strong>基础通信机制；</li>\n<li><strong>ExtensionAbility 专属通信</strong>：不同类型的 ExtensionAbility 提供专属通信接口，适配自身业务场景，核心接口如下：\n<ul>\n<li>ServiceExtensionAbility：通过<code>connectServiceExtensionAbility()</code>建立连接，实现主从组件的双向通信；</li>\n<li>DataShareExtensionAbility：通过<code>createDataShareHelper()</code>创建助手实例，实现数据的增删改查共享。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>纯 ArkTS 单进程应用，优先使用 EventHub 实现组件/线程间通信；涉及独立进程或跨应用交互时，根据组件类型选择对应专属通信接口或基础 IPC 机制。</p>\n</blockquote>\n<h4 id=\"5-线程模型\">5. 线程模型</h4>\n<ul>\n<li>基础支撑：Stage 模型提供 worker、taskpool 等机制支撑应用多线程开发场景；</li>\n<li>开发建议：应用若有复杂的耗时逻辑（如大数据处理、网络请求、复杂计算），建议通过创建 worker 线程的方式处理，避免阻塞主线程（UI 线程），保障应用界面流畅性；</li>\n<li>线程隔离：无论 ExtensionAbility 与 UIAbility 同进程还是独立进程，其内部均为线程隔离设计，耗时逻辑均需放在子线程执行，不可直接在组件主线程处理。</li>\n</ul>\n<h3 id=\"六stage-模型开发流程\">（六）Stage 模型开发流程</h3>\n<table>\n<thead>\n<tr>\n<th>核心任务</th>\n<th>关键内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>应用组件开发</td>\n<td>开发 UIAbility/ExtensionAbility，按功能拆分到不同 HAP，通用能力抽离到 HSP</td>\n</tr>\n<tr>\n<td>进程/线程模型适配</td>\n<td>基于业务需求配置 ExtensionAbility 进程归属，耗时逻辑通过 worker 处理，遵循线程隔离规则</td>\n</tr>\n<tr>\n<td>配置文件编写</td>\n<td>配置 app.json5（全局）/module.json5（模块）的应用/组件/进程信息，保证路径与语法合规</td>\n</tr>\n<tr>\n<td>通信机制实现</td>\n<td>按进程归属和组件类型选择 EventHub、专属接口或 IPC 实现通信</td>\n</tr>\n<tr>\n<td>效果验证</td>\n<td>基于模块编译验证局部修改效果，全局编译生成完整应用包</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"四鸿蒙应用组成结构\">四、鸿蒙应用组成结构</h2>\n<h3 id=\"一应用程序包bundle\">（一）应用程序包（Bundle）</h3>\n<ul>\n<li>定义：鸿蒙应用分发、安装的最小单位（后缀<code>.app</code>），由全局编译整合所有 HAP/HSP 模块编译产物生成；</li>\n<li>构成：Entry HAP（必选，应用启动入口）、Feature HAP（可选，扩展功能）、HSP（可选，代码/资源共享）；</li>\n<li>多包机制：1 个 Bundle 可包含多个 HAP（Entry HAP 最多 1 个，Feature HAP 不限），HAP 之间通过 HSP 共享代码/资源，各模块可独立编译，最终整合至 Bundle。</li>\n</ul>\n<h3 id=\"二模块haphsp\">（二）模块（HAP/HSP）</h3>\n<table>\n<thead>\n<tr>\n<th>模块类型</th>\n<th>核心作用</th>\n<th>关键特征</th>\n<th>运行期关联实例</th>\n<th>典型使用场景</th>\n<th>编译特性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Entry HAP</td>\n<td>应用主模块，提供启动入口</td>\n<td>必选，包含主 UIAbility，可单独安装运行</td>\n<td>对应 1 个 AbilityStage 实例</td>\n<td>应用主界面、核心交互功能</td>\n<td>可独立编译为 HAP 包，支持单独运行验证</td>\n</tr>\n<tr>\n<td>Feature HAP</td>\n<td>扩展功能模块</td>\n<td>可选，依赖 Entry HAP 运行，支持按需加载</td>\n<td>对应 1 个 AbilityStage 实例</td>\n<td>备份、输入法等扩展功能</td>\n<td>可独立编译，需结合 Entry HAP 运行</td>\n</tr>\n<tr>\n<td>HSP</td>\n<td>代码/资源共享包</td>\n<td>可选，无独立运行组件，仅用于模块间复用</td>\n<td>无对应的 AbilityStage 实例</td>\n<td>通用工具类、常量定义、公共资源</td>\n<td>编译为共享包，被其他 HAP 依赖调用</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>关于包的类型以及使用创建方法，我们会在项目阶段学习掌握。</p>\n</blockquote>\n<h3 id=\"三核心组件stage-模型两类组件\">（三）核心组件（Stage 模型两类组件）</h3>\n<table>\n<thead>\n<tr>\n<th>组件类型</th>\n<th>核心作用</th>\n<th>交互方式</th>\n<th>开发方式</th>\n<th>进程默认配置</th>\n<th>细分类型/示例文件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>UIAbility</td>\n<td>应用入口+窗口管理，实现用户交互</td>\n<td>桌面启动、可视化交互</td>\n<td>面向对象开发（类继承）</td>\n<td>应用主进程</td>\n<td>EntryAbility.ets（应用主界面）</td>\n</tr>\n<tr>\n<td>ExtensionAbility</td>\n<td>备份/输入法等无 UI/轻 UI 场景</td>\n<td>系统/事件触发</td>\n<td>面向对象开发（派生类实现）</td>\n<td>应用主进程</td>\n<td>EntryBackupAbility.ets（备份）、DataShareExtensionAbility.ets（数据共享）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"五工程结构\">五、工程结构</h2>\n<p>延用上一节创建的项目<code>FirstApplication</code>（基于鸿蒙 5.0 API 12 + DevEco Studio 6.0+），工程核心结构如下，其中<code>build</code>目录为编译后自动生成，<code>build-profile.json5</code>和<code>hvigorfile.ts</code>为鸿蒙 Hvigor 构建工具的核心编译配置文件，实现工程与模块的分层编译管理：</p>\n<pre><code>FirstApplication                    \n├── AppScope/                # 应用全局配置目录\n│   ├── resources/           # 应用全局资源目录\n│   │   ├── base/            # 全局基础资源目录\n│   │   │   ├── element/     # 全局字符串、颜色等配置\n│   │   │   │   └── string.json\n│   │   │   ├── media/       # 全局媒体资源（层叠图标配置、兜底图标）\n│   │   │   │   ├── app_icon.png // 自定义的应用图标\n│   │   │   │   ├── background.png\n│   │   │   │   ├── foreground.png\n│   │   │   │   └── layered_image.json\n│   │   │   └── profile/     # 全局配置文件（如页面路由、备份配置等）\n│   └── app.json5            # 全局配置文件（包名、版本、图标、名称等，供全局编译解析）\n├── entry/                   # Entry HAP主模块（核心开发目录）\n│   ├── build/               # 模块编译产物目录（编译后自动生成，存放entry模块HAP包）\n│   ├── src/\n│   │   ├── main/            # entry模块核心源码目录\n│   │   │   ├── ets/         # ArkTS代码目录\n│   │   │   │   ├── entryability/ # UIAbility核心组件目录\n│   │   │   │   │   └── EntryAbility.ets\n│   │   │   │   ├── entrybackupability/ # 备份扩展组件目录\n│   │   │   │   │   └── EntryBackupAbility.ets\n│   │   │   │   └── pages/   # 页面目录\n│   │   │   │       ├── Index.ets\n│   │   │   │       └── Home.ets\n│   │   │   ├── resources/   # 模块级静态资源目录（编译时自动打包优化）\n│   │   │   │   ├── base/    # 基础资源目录（默认主题）\n│   │   │   │   │   ├── element/ # 模块级元素配置\n│   │   │   │   │   ├── media/   # 模块级媒体资源\n│   │   │   │   │   │   ├── background.png\n│   │   │   │   │   │   ├── foreground.png\n│   │   │   │   │   │   ├── startIcon.png // 默认的窗口图标\n│   │   │   │   │   │   └── layered_image.json\n│   │   │   │   ├── dark/    # 深色模式资源目录\n│   │   │   │   └── rawfile/ # 原生文件目录（无需编译的静态文件）\n│   │   │   └── module.json5 # Entry HAP模块配置文件（组件、权限、进程等，供模块编译解析）\n│   ├── mock/                # 模拟数据目录（测试用）\n│   ├── ohosTest/            # OpenHarmony测试目录\n│   ├── test/                # 本地测试目录\n│   ├── .gitignore           # Git忽略文件配置\n│   ├── build-profile.json5  # 模块编译配置文件（指定SDK版本、签名关联等编译规则）\n│   └── hvigorfile.ts        # 模块编译脚本（Hvigor构建工具模块级执行入口）\n├── build/                   # 工程全局编译产物目录（编译后自动生成，存放全局整合的HAP/APP包）\n├── build-profile.json5      # 工程全局编译配置文件（统一管理所有模块编译规则、编译模式）\n├── hvigorfile.ts            # 工程全局编译脚本（Hvigor构建工具全局执行入口，触发所有模块编译）\n├── oh-package.json5         # ohpm依赖配置文件（编译前自动解析下载依赖）\n└── oh-package-lock.json5    # ohpm依赖版本锁定文件\n</code></pre>\n<blockquote>\n<p>说明：鸿蒙工程基于<strong>Hvigor</strong>（鸿蒙官方自研构建工具）实现编译，采用<strong>按需编译</strong>原则，仅修改过的模块/文件会重新编译，未修改部分复用原有编译产物，提升开发效率；<code>build</code>目录删除后可通过重新编译生成，不影响工程源码。</p>\n</blockquote>\n<h2 id=\"六uiability-核心实操\">六、UIAbility 核心实操</h2>\n<h3 id=\"一核心定位\">（一）核心定位</h3>\n<ol>\n<li><strong>应用入口</strong>：用户点击应用图标后，系统首先创建并启动 UIAbility 实例；</li>\n<li><strong>窗口管理载体</strong>：每个 UIAbility 实例启动后会创建一个 WindowStage（窗口管理器），负责窗口的创建、销毁，并<strong>通过 WindowStage 加载 ArkUI 页面</strong>；</li>\n<li><strong>实例模式</strong>：支持单实例、多实例、指定实例等配置（通过 module.json5 的<code>launchType</code>字段），满足不同业务场景需求；</li>\n<li><strong>编译关联</strong>：UIAbility 的类名、文件路径需与 module.json5 中<code>name</code>、<code>srcEntry</code>配置完全一致，否则会导致模块编译失败，无法生成 HAP 包；</li>\n<li><strong>权限核心</strong>：作为应用核心交互组件，UIAbility 是应用权限申请和校验的核心载体，后台启动其他组件需依赖专属系统权限。</li>\n</ol>\n<h3 id=\"二核心配置\">（二）核心配置</h3>\n<h4 id=\"1-模块级配置modulejson5\">1. 模块级配置（module.json5）</h4>\n<pre><code class=\"language-json\">{\n  \"module\": {\n    \"name\": \"entry\", // 模块名称\n    \"type\": \"entry\", // 模块类型：entry/feature/har/hsp\n    \"description\": \"$string:module_desc\", // 模块描述\n    \"mainElement\": \"EntryAbility\", // 默认启动组件\n    \"deviceTypes\": [ // 支持的设备类型\n      \"phone\"\n    ],\n    \"deliveryWithInstall\": true, // 是否随应用安装交付\n    \"installationFree\": false, // 是否免安装\n    \"pages\": \"$profile:main_pages\", // 页面路由配置\n    \"abilities\": [ // UIAbility组件配置\n      {\n        \"name\": \"EntryAbility\", // 组件名称（与代码类名一致，编译校验关键）\n        \"srcEntry\": \"./src/main/ets/entryability/EntryAbility.ets\", // 入口路径（必须./开头，编译校验关键）\n        \"description\": \"$string:EntryAbility_desc\", // 组件描述\n        \"icon\": \"$media:layered_image\", // 组件图标（模块级，不重名的情况下优先生效）\n        \"label\": \"$string:EntryAbility_label\", // 组件显示名称（模块级，优先级更高）\n        \"startWindowIcon\": \"$media:startIcon\", // 启动窗口图标\n        \"startWindowBackground\": \"$color:start_window_background\", // 启动窗口背景\n        \"exported\": true, // 是否允许跨应用调用\n        \"launchType\": \"singleton\", // 默认的启动模式，可以不写\n        \"skills\": [ // 桌面图标必配：缺少则桌面无应用图标\n          {\n            \"entities\": [\n              \"entity.system.home\" // 桌面入口标识\n            ],\n            \"actions\": [\n              \"ohos.want.action.home\" // 桌面启动动作\n            ]\n          }\n        ]\n      }\n    ],\n    \"extensionAbilities\": [ // 扩展组件配置\n      {\n        \"name\": \"EntryBackupAbility\", // 备份扩展组件名称\n        \"srcEntry\": \"./src/main/ets/entrybackupability/EntryBackupAbility.ets\", \n        \"type\": \"backup\", // 扩展类型（backup/dataShare/inputMethod等）\n        \"exported\": false, // 仅内部使用\n        \"metadata\": [ // 扩展元数据\n          {\n            \"name\": \"ohos.extension.backup\", // 元数据名称\n            \"resource\": \"$profile:backup_config\" // 元数据配置文件\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre>\n<h4 id=\"2-配置关键规则\">2. 配置关键规则</h4>\n<ul>\n<li><code>mainElement</code>：Entry HAP 必须配置为 UIAbility，Feature HAP 无默认启动组件；</li>\n<li><code>name</code>：组件名称必须与代码中导出的类名一致，不可随意修改，编译时会严格校验；</li>\n<li><code>srcEntry</code>：路径需以<code>./</code>开头，严格匹配文件的目录/文件名（区分大小写），路径错误会直接导致编译失败；</li>\n<li><code>exported</code>：跨应用调用的组件需设为 true，仅内部使用的组件设为 false 即可；</li>\n<li><code>skills</code>：仅 UIAbility 需配置（桌面图标展示），ExtensionAbility 无需配置；缺失或配置不全则桌面无图标，点击图标进入应用详情页；</li>\n<li><code>type</code>：ExtensionAbility 必选字段，需与扩展类型匹配（如 backup、dataShare、inputMethod 等）；</li>\n<li><code>process</code>：ExtensionAbility 可选配置字段，用于设置进程归属，值以<code>:</code>开头表示独立进程，未配置则默认与主进程同进程；</li>\n<li>JSON 语法：禁止末尾多余逗号，配置项、文件/目录名称均区分大小写，语法错误会导致编译解析失败。</li>\n</ul>\n<h4 id=\"3-全局配置appjson5\">3. 全局配置（app.json5）</h4>\n<pre><code class=\"language-json\">{\n  \"app\": {\n    \"bundleName\": \"com.sanxiu.firstapp\",\n    \"vendor\": \"example\",\n    \"versionCode\": 1000000,\n    \"versionName\": \"1.0.0\",\n    \"icon\": \"$media:layered_image\", // 全局应用图标\n    \"label\": \"$string:app_name\" // 全局应用名称\n  }\n}\n</code></pre>\n<h4 id=\"4-层叠图标配置layered_imagejson\">4. 层叠图标配置（layered_image.json）</h4>\n<p><strong>路径</strong>：</p>\n<ul>\n<li>全局：AppScope/resources/base/media/layered_image.json</li>\n<li>模块级：entry/src/main/resources/base/media/layered_image.json</li>\n</ul>\n<pre><code class=\"language-json\">{\n  \"layered-image\": {\n    \"background\": \"$media:background\",\n    \"foreground\": \"$media:foreground\"\n  }\n}\n</code></pre>\n<p><strong>核心规则</strong>：</p>\n<ul>\n<li>资源覆盖：编译期 AppScope 和模块内重名资源，AppScope 资源优先级更高；</li>\n<li>模块级 icon 生效前提：UIAbility 的 <code>skills</code> 字段必须包含<code>entity.system.home</code>和<code>ohos.want.action.home</code>；多 Ability 时取<code>mainElement</code>对应配置；</li>\n<li>图标尺寸规范：鸿蒙层叠图标推荐基础尺寸：foreground/background 均为<strong>1024×1024</strong>（png 格式，透明背景），编译时系统会自动适配不同设备的图标尺寸，无需手动制作多尺寸版本。</li>\n</ul>\n<h4 id=\"5-页面路由配置main_pagesjson\">5. 页面路由配置（main_pages.json）</h4>\n<p>通过 <code>New -&gt; Page -&gt; Empty Page</code> 创建的页面会自动导入<code>main_pages.json</code>，其他方法创建的页面需要手动管理路由配置。</p>\n<pre><code class=\"language-json\">{\n  \"src\": [\n    \"pages/Index\",\n    \"pages/Home\" // 新增Home页面路径\n  ]\n}\n</code></pre>\n<h3 id=\"三页面加载核心逻辑entryabilityets\">（三）页面加载核心逻辑（EntryAbility.ets）</h3>\n<pre><code class=\"language-typescript\">import UIAbility from '@ohos.app.ability.UIAbility';\nimport window from '@ohos.window';\nimport hilog from '@ohos.hilog';\nimport { AbilityConstant, Want } from '@kit.AbilityKit';\nimport { BusinessError } from '@ohos.base'; \n\nconst DOMAIN: number = 0x0000;\nconst TAG: string = 'EntryAbility';\n\nexport default class EntryAbility extends UIAbility {\n  // 组件创建时触发，可初始化资源\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    hilog.info(DOMAIN, TAG, 'EntryAbility onCreate called');\n  }\n\n  // 组件销毁时触发，可释放资源\n  onDestroy() {\n    hilog.info(DOMAIN, TAG, 'EntryAbility onDestroy called');\n  }\n\n  // 窗口创建后触发，仅此处可加载页面\n  onWindowStageCreate(windowStage: window.WindowStage): void {\n    hilog.info(DOMAIN, TAG, '--- onWindowStageCreate 触发（加载页面）---');\n    // 加载页面\n    windowStage.loadContent('pages/Index', (err) =&gt; {\n      if (err.code) {\n        hilog.error(DOMAIN, TAG, `页面加载失败：code=${err.code}, message=${err.message}`);\n        return;\n      }\n      hilog.info(DOMAIN, TAG, 'Index页面加载成功');\n    });\n  }\n\n  onWindowStageDestroy(): void {\n    // Main window is destroyed, release UI related resources\n    hilog.info(DOMAIN, TAG, '%{public}s', '主窗口即将销毁，释放UI相关资源');\n  }\n\n  onForeground(): void {\n    // Ability has brought to foreground\n    hilog.info(DOMAIN, TAG, '%{public}s', '应用切换至前台，恢复业务逻辑');\n  }\n\n  onBackground(): void {\n    // Ability has back to background\n    hilog.info(DOMAIN, TAG, '%{public}s', '应用切换至后台，暂停业务逻辑，不可启动其他组件');\n  }\n}\n</code></pre>\n<h4 id=\"页面加载规则\">页面加载规则</h4>\n<ol>\n<li>仅能通过<code>WindowStage.loadContent()</code>加载页面；</li>\n<li>该方法仅可在<code>onWindowStageCreate</code>生命周期中调用；</li>\n<li>路径需严格遵循“无.ets后缀、区分大小写、基于pages根目录的相对路径”，且需与<code>main_pages.json</code>中注册的路径完全一致，否则编译通过但运行时页面加载失败；</li>\n<li>页面文件命名、路径错误会导致编译时资源打包失败，或运行时页面空白。</li>\n</ol>\n<h3 id=\"四自定义首页开发\">（四）自定义首页开发</h3>\n<h4 id=\"步骤-1创建-home-页面pageshomeets\">步骤 1：创建 Home 页面（pages/Home.ets）</h4>\n<pre><code class=\"language-typescript\">@Entry\n@Component\nstruct Home {\n  build() {\n    Column({ space: 20 }) {\n      Text('我的Stage应用首页')\n        .fontSize(30)\n        .fontWeight(FontWeight.Bold);\n    }\n    .width('100%')\n    .height('100%')\n    .justifyContent(FlexAlign.Center);\n  }\n}\n</code></pre>\n<h4 id=\"步骤-2注册-home-页面到路由配置main_pagesjson\">步骤 2：注册 Home 页面到路由配置（main_pages.json）</h4>\n<p>打开路径：<code>entry/src/main/resources/base/profile/main_pages.json</code>，在<code>src</code>数组中新增 Home 页面路径，确保与实际文件路径一致：</p>\n<pre><code class=\"language-json\">{\n  \"src\": [\n    \"pages/Index\",\n    \"pages/Home\" // 必须注册，否则运行时页面加载失败\n  ]\n}\n</code></pre>\n<h4 id=\"步骤-3修改页面加载路径entryabilityets\">步骤 3：修改页面加载路径（EntryAbility.ets）</h4>\n<p>将<code>windowStage.loadContent('pages/Index', ...)</code>修改为：</p>\n<pre><code class=\"language-typescript\">// 加载页面\nwindowStage.loadContent('pages/Home').then(()=&gt;{\n  hilog.info(DOMAIN, TAG, 'Home页面加载成功');\n}).catch((err: BusinessError)=&gt;{\n  hilog.error(DOMAIN, TAG, `页面加载失败：code=${err.code}, message=${err.message}`);\n})\n</code></pre>\n<h4 id=\"效果验证\">效果验证</h4>\n<p><img alt=\"修改加载页面.png\" class=\"lazyload\" /></p>\n<ol>\n<li><strong>应用内验证</strong>：正常展示<code>我的Stage应用首页</code>，无空白、无报错；</li>\n<li><strong>日志端验证</strong>：Logcat 中筛选<code>TAG:EntryAbility</code>，可看到“Home页面加载成功”相关日志。</li>\n</ol>\n<h3 id=\"五配置应用名称和图标\">（五）配置应用名称和图标</h3>\n<h4 id=\"1-层叠图标方案-模块级配置\">1. 层叠图标方案-模块级配置</h4>\n<p>默认工程中，全局应用图标、模块级图标、layered-image 及前后背景图的命名均一致。<br />\n若需让模块级应用图标生效，需删除<strong>AppScope/resources/base/media/</strong> 目录下的 layered-image 相关文件（含<code>layered_image.json</code>、<code>background.png</code>、<code>foreground.png</code>），避免全局重名资源覆盖（不推荐）。</p>\n<p><strong>推荐方案</strong>：确保资源不重名，使用自定义图标名称，同时保证<code>module.json5</code> 中配置了<code>skills</code>字段（桌面图标正常显示前提）：</p>\n<ul>\n<li>确认 entry 模块<code>layered_image.json</code>配置（路径：entry/src/main/resources/base/media/layered_image.json）；</li>\n<li>确保 module.json5 中 UIAbility 配置<code>\"icon\": \"$media:layered_image\"</code>。</li>\n</ul>\n<h4 id=\"2-层叠图标方案-全局级配置\">2. 层叠图标方案-全局级配置</h4>\n<p>直接将应用图标图片命名为<code>foreground</code>，或自定义 layered_image.json 中<code>foreground</code>的资源引用为<code>\"foreground\": \"$media:app_icon\"</code>：</p>\n<ol>\n<li>配置 AppScope 下<code>layered_image.json</code>（路径：AppScope/resources/base/media/layered_image.json）；</li>\n<li>在<code>AppScope/app.json5</code>中配置全局图标：<code>\"icon\": \"$media:layered_image\"</code>。</li>\n</ol>\n<h4 id=\"3-应用名称配置\">3. 应用名称配置</h4>\n<p>应用名称的配置优先级：<strong>模块级别 &gt; 全局级别</strong>。若需让全局资源配置的应用名称生效，需在 module.json5 中注释/删除 UIAbility 的 label 配置：<code>\"label\": \"$string:EntryAbility_label\"</code>。</p>\n<ul>\n<li>名称修改后需检查<code>string.json</code>中对应字符是否存在，字符缺失会导致编译时资源解析错误；</li>\n<li>配置完成后执行模块编译，验证桌面应用名称是否更新；</li>\n<li>全局名称路径：<code>AppScope/resources/base/element/string.json</code><pre><code class=\"language-json\">{\n  \"string\": [\n    {\n      \"name\": \"app_name\",\n      \"value\": \"第一个应用\"\n    }\n  ]\n}\n</code></pre>\n</li>\n</ul>\n<h4 id=\"运行验证\">运行验证</h4>\n<p>将应用运行至真机/模拟器，桌面端应用名称显示为<code>第一个应用</code>，图标为全局配置的层叠样式。</p>\n<p><img alt=\"修改应用名称和图标\" class=\"lazyload\" /></p>\n<h2 id=\"七清理构建hapapp包\">七、清理、构建HAP/APP包</h2>\n<p>鸿蒙工程基于Hvigor构建工具实现模块级编译和全局级构建，<strong>顶部菜单栏Build</strong>为核心操作入口，覆盖「清理-编译-构建-发布」全流程，以下为精准实操和工具说明：</p>\n<h3 id=\"1-清理操作\">1. 清理操作</h3>\n<ul>\n<li>操作：顶部菜单栏<code>Build &gt; Clean Project</code></li>\n<li>功能：删除全工程所有编译相关文件（缓存、临时产物、已生成的包文件等），仅保留源码、配置和资源文件</li>\n<li>作用：解决编译异常、缓存冲突、配置修改不生效等问题，清理完成控制台显示<code>BUILD SUCCESSFUL</code></li>\n</ul>\n<h3 id=\"2-模块编译\">2. 模块编译</h3>\n<p>适用于修改entry模块后快速验证局部效果，仅生成单模块HAP包：</p>\n<ol>\n<li>操作：选中<code>entry</code>文件，点击顶部菜单栏<code>Build &gt; Make Module 'entry'</code></li>\n<li>结果：控制台显示<code>BUILD SUCCESSFUL</code>即为成功，HAP包存放于<code>entry/build/outputs/hap/</code></li>\n<li>作用：快速验证entry模块代码/配置修改效果</li>\n</ol>\n<p><img alt=\"编译entry模块_20260203211239_98_1340\" class=\"lazyload\" /></p>\n<h3 id=\"3-构建完整应用包用于安装分发上架\">3. 构建完整应用包（用于安装/分发/上架）</h3>\n<p>适用于真机/模拟器部署、应用发布上架，整合全模块生成完整.app包：</p>\n<ol>\n<li>操作：顶部菜单栏<code>Build &gt; Build Hap(s)/APP(s) &gt; Build App(s)</code></li>\n<li>结果：控制台显示<code>BUILD SUCCESSFUL</code>即为成功，.app包存放于<code>build/outputs/app/</code>，主模块entry打包产出.hap包</li>\n<li>作用：生成可部署/发布的完整Bundle应用包</li>\n</ol>\n<p><img alt=\"构建应用程序包_20260203211834_100_1340\" class=\"lazyload\" /></p>\n<h3 id=\"4-build菜单核心工具选项全解\">4. Build菜单核心工具选项全解</h3>\n<table>\n<thead>\n<tr>\n<th>选项名称</th>\n<th>核心作用</th>\n<th>典型使用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Make Module 'entry'</td>\n<td>编译entry模块，生成单模块HAP包</td>\n<td>验证entry模块局部修改效果</td>\n</tr>\n<tr>\n<td>Build Hap(s)/APP(s)</td>\n<td>Build Hap(s)：编译单/多模块生成HAP包；Build App(s)：整合全模块生成.app包</td>\n<td>局部调试用Hap(s)；部署/发布用App(s)</td>\n</tr>\n<tr>\n<td>Generate Build Profile 'entry'</td>\n<td>生成entry模块专属编译配置文件</td>\n<td>自定义entry模块编译规则</td>\n</tr>\n<tr>\n<td>Clean Project</td>\n<td>删除全工程所有编译文件，彻底清理缓存</td>\n<td>编译异常、缓存冲突、配置修改不生效</td>\n</tr>\n<tr>\n<td>Rebuild Project</td>\n<td>先执行Clean Project，再全工程重新编译</td>\n<td>清理后仍编译失败、工程长期未编译</td>\n</tr>\n<tr>\n<td>Generate Key and CSR</td>\n<td>生成.p12密钥+CSR文件，用于申请官方发布签名</td>\n<td>应用正式发布上架</td>\n</tr>\n<tr>\n<td>Upload Product</td>\n<td>将正式版.app包上传至华为应用市场后台</td>\n<td>应用提交上架提审</td>\n</tr>\n<tr>\n<td>Build Analyzer</td>\n<td>分析构建耗时、资源占用，定位构建失败原因</td>\n<td>构建速度慢、排查构建失败问题</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"八代码仓库\">八、代码仓库</h2>\n<ul>\n<li>工程名称：FirstApplication</li>\n<li>仓库地址：<a href=\"https://gitee.com/HarmonyOS-UI-Basics/harmony-os-ui-basics.git\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/HarmonyOS-UI-Basics/harmony-os-ui-basics.git</a></li>\n</ul>\n<h2 id=\"九下节预告\">九、下节预告</h2>\n<p>下一节将深入学习 UIAbility 生命周期全解析，核心内容包括：</p>\n<ol>\n<li>UIAbility 全生命周期核心方法的触发时机、核心作用及执行次数约束；</li>\n<li>WindowStage 事件体系与生命周期的联动逻辑，掌握窗口状态（获焦/失焦、前台/后台）的合法监听方式；</li>\n<li><code>onDestroy</code> 方法的特殊触发规则（API 13+一键清理、调试模式、手动调用API等不同场景）；</li>\n<li>页面仅能在 <code>onWindowStageCreate</code> 加载的底层原因及生命周期相关开发避坑要点；</li>\n<li>实操验证启动/前后台切换/关闭等场景下的生命周期执行顺序，掌握关键数据的安全保存策略。</li>\n</ol>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 16:36</span>&nbsp;\n<a href=\"https://www.cnblogs.com/san-xiu\">鸿蒙-散修</a>&nbsp;\n阅读(<span id=\"post_view_count\">61</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Apache SeaTunnel Zeta、Flink、Spark 怎么选？底层原理 + 实战对比一次讲透",
      "link": "https://www.cnblogs.com/seatunnel/p/19575007",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/seatunnel/p/19575007\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 16:05\">\n    <span>Apache SeaTunnel Zeta、Flink、Spark 怎么选？底层原理 + 实战对比一次讲透</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文档将深入解析 Apache SeaTunnel 支持的三大执行引擎：Zeta (SeaTunnel Engine)、Flink 和 Spark。我们将从架构设计、核心特性、优缺点对比以及使用方法等多个维度进行详细讲解，帮助你根据业务需求选择最合适的引擎。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p><img alt=\"对比\" class=\"lazyload\" /></p>\n<p>本文档将深入解析 Apache SeaTunnel 支持的三大执行引擎：<strong>Zeta (SeaTunnel Engine)</strong>、<strong>Flink</strong> 和 <strong>Spark</strong>。我们将从架构设计、核心特性、优缺点对比以及使用方法等多个维度进行详细讲解，帮助你根据业务需求选择最合适的引擎。</p>\n<h2 id=\"1-引擎概览\">1. 引擎概览</h2>\n<p>SeaTunnel 的架构设计采用了 <strong>API 与执行引擎解耦</strong> 的策略。这意味着同一套数据同步逻辑（Config）可以无缝运行在不同的引擎上。</p>\n<ul>\n<li><strong>Zeta Engine</strong>: SeaTunnel 社区专门为数据集成场景自研的新一代引擎，专注于高性能、低延迟的数据同步。</li>\n<li><strong>Flink Engine</strong>: 利用 Flink 强大的流处理能力，适合已拥有 Flink 集群的用户。</li>\n<li><strong>Spark Engine</strong>: 利用 Spark 强大的批处理能力，适合离线大规模数据处理场景。</li>\n</ul>\n<h2 id=\"2-zeta-引擎核心推荐\">2. Zeta 引擎——核心推荐</h2>\n<p>Zeta 是目前 SeaTunnel 社区主推的默认引擎。它旨在解决 Flink/Spark 在简单数据同步场景下“资源消耗大、部署运维重”的问题。</p>\n<h3 id=\"21-核心架构\">2.1 核心架构</h3>\n<p>Zeta 采用无中心化（Decentralized）或 Master-Slave 架构（取决于部署模式），主要包含以下组件：</p>\n<ul>\n<li><strong>Coordinator (Master)</strong>:\n<ul>\n<li><strong>作业解析</strong>: 将逻辑 DAG (Logical DAG) 转换为物理 DAG (Physical DAG)。</li>\n<li><strong>资源调度</strong>: 管理 Slot，向 Worker 分配任务。</li>\n<li><strong>Checkpoint Coordinator</strong>: 负责触发和协调分布式快照（基于 Chandy-Lamport 算法），保障数据一致性。</li>\n</ul>\n</li>\n<li><strong>Worker (Slave)</strong>:\n<ul>\n<li><strong>Task Execution</strong>: 运行 Source, Transform, Sink 任务。</li>\n<li><strong>Data Transport</strong>: 负责节点间的数据传输。</li>\n</ul>\n</li>\n<li><strong>ResourceManager</strong>: 支持 Standalone, YARN, Kubernetes 等多种资源管理模式。</li>\n</ul>\n<p><img alt=\"SeaTunnel Engine\" class=\"lazyload\" /></p>\n<h3 id=\"22-关键特性\">2.2 关键特性</h3>\n<ol>\n<li><strong>Pipeline 级容错 (Pipeline-level Fault Tolerance)</strong>:\n<ul>\n<li>不同于 Flink 的“全图重启”，Zeta 可以只重启失败的 Pipeline（例如多表同步中，表 A 失败不影响表 B）。</li>\n</ul>\n</li>\n<li><strong>增量快照 (Incremental Checkpoint)</strong>:\n<ul>\n<li>支持高频 Checkpoint，最小化数据丢失风险，同时对性能影响极小。</li>\n</ul>\n</li>\n<li><strong>动态扩缩容 (Dynamic Scaling)</strong>:\n<ul>\n<li>支持在作业运行时动态增加或减少 Worker 节点，无需重启作业。</li>\n</ul>\n</li>\n<li><strong>Schema Evolution (表结构变更)</strong>:\n<ul>\n<li>原生支持 DDL 变更同步（如 Add Column），这对 CDC 场景至关重要。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"23-使用指南\">2.3 使用指南</h3>\n<p>Zeta 引擎通常包含在 SeaTunnel 的二进制包中，开箱即用。</p>\n<p><strong>启动命令 (Local 模式 - 开发测试):</strong></p>\n<pre><code class=\"language-bash\">./bin/seatunnel.sh --config ./config/your_job.conf -e local\n</code></pre>\n<p><strong>启动命令 (Cluster 模式 - 生产环境):</strong></p>\n<ol>\n<li>启动 Server (Master/Worker):<pre><code class=\"language-bash\">./bin/seatunnel-cluster.sh -d\n</code></pre>\n</li>\n<li>提交任务到集群:<pre><code class=\"language-bash\">./bin/seatunnel.sh --config ./config/your_job.conf -e cluster\n</code></pre>\n</li>\n</ol>\n<h2 id=\"3-flink-引擎\">3. Flink 引擎</h2>\n<p><img alt=\"flink-1_highres\" class=\"lazyload\" /></p>\n<p>SeaTunnel 通过翻译层（Translation Layer）将内部的 Source/Sink API 适配为 Flink 的 <code>SourceFunction</code> / <code>SinkFunction</code> (或 Flink 新版 Source/Sink API)。</p>\n<h3 id=\"31-架构原理\">3.1 架构原理</h3>\n<ul>\n<li><strong>Translation</strong>: SeaTunnel 在 Client 端将 Config 解析并翻译成 Flink JobGraph。</li>\n<li><strong>Execution</strong>: 提交给 Flink Cluster 执行。此时，SeaTunnel 任务就是一个标准的 Flink 任务。</li>\n<li><strong>State Backend</strong>: 依赖 Flink 的 Checkpoint 机制（RocksDB/FsStateBackend）管理状态。</li>\n</ul>\n<h3 id=\"32-优缺点\">3.2 优缺点</h3>\n<ul>\n<li><strong>优点</strong>: 生态成熟，运维工具丰富，适合复杂的流式计算+同步场景。</li>\n<li><strong>缺点</strong>: 版本耦合严重（需适配 Flink 1.13-1.18 等不同版本），对于纯同步任务显得过重。</li>\n</ul>\n<h3 id=\"33-使用指南\">3.3 使用指南</h3>\n<p>需要下载对应的 <code>seatunnel-flink-starter</code> jar 包，并确保 Flink 环境已准备好。</p>\n<p><strong>启动命令 (Flink 1.13+):</strong></p>\n<pre><code class=\"language-bash\">./bin/start-seatunnel-flink-13-connector-v2.sh \\\n    --config ./config/your_job.conf \\\n    --run-mode run # 或 run-application\n</code></pre>\n<p><em>(注意：不同 Flink 版本脚本名称略有不同，如 <code>flink-15</code>, <code>flink-18</code>)</em></p>\n<h2 id=\"4-spark-引擎\">4. Spark 引擎</h2>\n<p><img alt=\"spark\" class=\"lazyload\" /></p>\n<p>类似于 Flink，SeaTunnel 将 Source/Sink 适配为 Spark 的 <code>DataSource V2</code> API。</p>\n<h3 id=\"41-架构原理\">4.1 架构原理</h3>\n<ul>\n<li><strong>Batch</strong>: 使用 Spark RDD / DataFrame API 执行离线批处理。</li>\n<li><strong>Streaming</strong>: 使用 Spark Streaming (Micro-batch) 执行流式处理。</li>\n</ul>\n<h3 id=\"42-优缺点\">4.2 优缺点</h3>\n<ul>\n<li><strong>优点</strong>: 批处理性能强大，在大规模离线数据清洗/ETL 场景表现优异。</li>\n<li><strong>缺点</strong>: 流处理基于微批（Micro-batch），延迟通常高于 Flink/Zeta；资源调度较慢。</li>\n</ul>\n<h3 id=\"43-使用指南\">4.3 使用指南</h3>\n<p>需要下载对应的 <code>seatunnel-spark-starter</code> jar 包。</p>\n<p><strong>启动命令 (Spark 3.x):</strong></p>\n<pre><code class=\"language-bash\">./bin/start-seatunnel-spark-3-connector-v2.sh \\\n    --config ./config/your_job.conf \\\n    --master local[4] # 或 yarn, k8s\n</code></pre>\n<h2 id=\"5-三大引擎全方位对比\">5. 三大引擎全方位对比</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">特性</th>\n<th style=\"text-align: left;\">Zeta (SeaTunnel Engine)</th>\n<th style=\"text-align: left;\">Flink Engine</th>\n<th style=\"text-align: left;\">Spark Engine</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>定位</strong></td>\n<td style=\"text-align: left;\"><strong>数据同步专用</strong></td>\n<td style=\"text-align: left;\">通用流批计算</td>\n<td style=\"text-align: left;\">通用批流计算</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>适用场景</strong></td>\n<td style=\"text-align: left;\">海量数据集成、CDC 实时同步、多表整库同步</td>\n<td style=\"text-align: left;\">复杂流式计算 + 同步</td>\n<td style=\"text-align: left;\">大规模离线清洗、ETL</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>部署复杂度</strong></td>\n<td style=\"text-align: left;\"><strong>低</strong> (内置，开箱即用)</td>\n<td style=\"text-align: left;\">中 (需维护 Flink 集群)</td>\n<td style=\"text-align: left;\">中 (需维护 Spark 集群)</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>资源消耗</strong></td>\n<td style=\"text-align: left;\"><strong>低</strong> (针对同步优化，无多余开销)</td>\n<td style=\"text-align: left;\">中/高</td>\n<td style=\"text-align: left;\">中/高</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>延迟</strong></td>\n<td style=\"text-align: left;\"><strong>低</strong> (实时流)</td>\n<td style=\"text-align: left;\">低 (实时流)</td>\n<td style=\"text-align: left;\">中 (微批)</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>容错粒度</strong></td>\n<td style=\"text-align: left;\"><strong>Pipeline 级</strong> (局部重启)</td>\n<td style=\"text-align: left;\">Job 级 (全局重启)</td>\n<td style=\"text-align: left;\">Stage/Task 级</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>CDC 支持</strong></td>\n<td style=\"text-align: left;\"><strong>完美</strong> (支持 Schema Evolution)</td>\n<td style=\"text-align: left;\">良好</td>\n<td style=\"text-align: left;\">一般</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>多版本适配</strong></td>\n<td style=\"text-align: left;\">无需适配 (自带)</td>\n<td style=\"text-align: left;\">需严格匹配 Flink 版本</td>\n<td style=\"text-align: left;\">需严格匹配 Spark 版本</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"6-如何选择\">6. 如何选择？</h2>\n<ol>\n<li>\n<p><strong>如果你是新项目，或者主要需求是数据同步 (Data Integration)</strong>:</p>\n<ul>\n<li>👉 <strong>首选 Zeta 引擎</strong>。它最轻量、性能最好，且对 CDC 和多表同步有特殊优化。</li>\n</ul>\n</li>\n<li>\n<p><strong>如果你已经有现成的 Flink/Spark 集群，且运维团队不想维护新引擎</strong>:</p>\n<ul>\n<li>👉 选择 <strong>Flink</strong> 或 <strong>Spark</strong> 引擎，复用现有基础设施。</li>\n</ul>\n</li>\n<li>\n<p><strong>如果你的任务包含极其复杂的自定义计算逻辑 (Complex Computation)</strong>:</p>\n<ul>\n<li>👉 优先考虑 <strong>Flink</strong> (流) 或 <strong>Spark</strong> (批)，利用其丰富的算子生态。但也可以考虑 <strong>Zeta + SQL Transform</strong> 满足大部分需求。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"7-新手入门指南\">7. 新手入门指南</h2>\n<p>如果你是第一次接触 SeaTunnel，请按照以下步骤快速体验 Zeta 引擎的强大功能。</p>\n<h3 id=\"71-环境准备\">7.1 环境准备</h3>\n<p>确保你的机器上安装了 Java 8 或 Java 11。</p>\n<pre><code class=\"language-bash\">java -version\n</code></pre>\n<h3 id=\"72-下载与安装\">7.2 下载与安装</h3>\n<ol>\n<li><strong>下载</strong>: 从 <a href=\"https://seatunnel.apache.org/download\" rel=\"noopener nofollow\" target=\"_blank\">Apache SeaTunnel 官网</a> 下载最新版本的二进制包 (<code>apache-seatunnel-x.x.x-bin.tar.gz</code>)。</li>\n<li><strong>解压</strong>:<pre><code class=\"language-bash\">tar -zxvf apache-seatunnel-*.tar.gz\ncd apache-seatunnel-*\n</code></pre>\n</li>\n</ol>\n<h3 id=\"73-安装-connector-插件-重要\">7.3 安装 Connector 插件 (重要!)</h3>\n<p><strong>这是新手最容易忽略的一步</strong>。默认包不包含所有 Connector，你需要运行脚本自动下载。</p>\n<pre><code class=\"language-bash\"># 自动安装 plugin_config 配置文件中定义的所有插件\nsh bin/install-plugin.sh\n</code></pre>\n<h3 id=\"74-快速运行第一个任务\">7.4 快速运行第一个任务</h3>\n<p>创建一个简单的配置文件 <code>config/quick_start.conf</code>，将数据从 Fake 源生成并打印到控制台：</p>\n<pre><code class=\"language-hocon\">env {\n  execution.parallelism = 1\n  job.mode = \"BATCH\"\n}\n\nsource {\n  FakeSource {\n    result_table_name = \"fake\"\n    row.num = 100\n    schema = {\n      fields {\n        name = \"string\"\n        age = \"int\"\n      }\n    }\n  }\n}\n\ntransform {\n  # 简单的 SQL 处理\n  Sql {\n    source_table_name = \"fake\"\n    result_table_name = \"sql_result\"\n    query = \"select name, age from fake where age &gt; 50\"\n  }\n}\n\nsink {\n  Console {\n    source_table_name = \"sql_result\"\n  }\n}\n</code></pre>\n<p><strong>运行任务 (Local 模式)</strong>:</p>\n<pre><code class=\"language-bash\">./bin/seatunnel.sh --config ./config/quick_start.conf -e local\n</code></pre>\n<p>如果看到控制台输出了数据表格，恭喜你，你已经成功掌握了 SeaTunnel 的基本用法！</p>\n<h2 id=\"8-zeta-引擎原理深度学习路径\">8. Zeta 引擎原理深度学习路径</h2>\n<p>如果你希望深入了解 Zeta 引擎的内部运作机制，或者想参与社区贡献，可以按照以下路径进行源码阅读和调试。</p>\n<h3 id=\"81-核心模块概览\">8.1 核心模块概览</h3>\n<p>Zeta 引擎的代码主要集中在 <code>seatunnel-engine</code> 模块下：</p>\n<ul>\n<li><strong>seatunnel-engine-core</strong>: 定义了核心数据结构（如 <code>Job</code>, <code>Task</code>）和通信协议。</li>\n<li><strong>seatunnel-engine-server</strong>: 包含了 Coordinator 和 Worker 的具体实现逻辑。</li>\n<li><strong>seatunnel-engine-client</strong>: 客户端提交逻辑。</li>\n</ul>\n<h3 id=\"82-源码阅读推荐路径\">8.2 源码阅读推荐路径</h3>\n<h4 id=\"1-作业提交与解析-coordinator-侧\">1. 作业提交与解析 (Coordinator 侧)</h4>\n<p>从 <code>JobMaster</code> 类开始，了解作业是如何被接收和初始化的。</p>\n<ul>\n<li><strong>入口</strong>: <code>org.apache.seatunnel.engine.server.master.JobMaster</code></li>\n<li><strong>逻辑</strong>: 关注 <code>init</code> 和 <code>run</code> 方法，了解 <code>LogicalDag</code> 到 <code>PhysicalPlan</code> 的转换过程。</li>\n</ul>\n<h4 id=\"2-任务执行-worker-侧\">2. 任务执行 (Worker 侧)</h4>\n<p>了解 Task 是如何被调度和执行的。</p>\n<ul>\n<li><strong>服务入口</strong>: <a href=\"seatunnel-engine/seatunnel-engine-server/src/main/java/org/apache/seatunnel/engine/server/TaskExecutionService.java\" rel=\"noopener nofollow\" target=\"_blank\">TaskExecutionService.java</a>\n<ul>\n<li>该类负责管理 Worker 节点上的所有 TaskGroup。</li>\n</ul>\n</li>\n<li><strong>执行上下文</strong>: <code>org.apache.seatunnel.engine.server.execution.TaskExecutionContext</code></li>\n</ul>\n<h4 id=\"3-checkpoint-机制-核心难点\">3. Checkpoint 机制 (核心难点)</h4>\n<p>Zeta 的快照机制是保证数据一致性的关键。</p>\n<ul>\n<li><strong>协调器</strong>: <a href=\"seatunnel-engine/seatunnel-engine-server/src/main/java/org/apache/seatunnel/engine/server/checkpoint/CheckpointCoordinator.java\" rel=\"noopener nofollow\" target=\"_blank\">CheckpointCoordinator.java</a>\n<ul>\n<li>重点阅读 <code>triggerCheckpoint</code> 方法，了解 Barrier 是如何分发的。</li>\n</ul>\n</li>\n<li><strong>计划</strong>: <a href=\"seatunnel-engine/seatunnel-engine-server/src/main/java/org/apache/seatunnel/engine/server/checkpoint/CheckpointPlan.java\" rel=\"noopener nofollow\" target=\"_blank\">CheckpointPlan.java</a>\n<ul>\n<li>了解 Checkpoint 涉及的任务范围是如何计算的。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"83-调试技巧\">8.3 调试技巧</h3>\n<ol>\n<li><strong>修改日志级别</strong>: 在 <code>config/log4j2.properties</code> 中，将 <code>org.apache.seatunnel</code> 的级别调整为 <code>DEBUG</code>，可以看到详细的 RPC 通信和状态变更日志。</li>\n<li><strong>本地调试</strong>: 在 IDE 中直接运行 <code>org.apache.seatunnel.core.starter.seatunnel.SeaTunnelStarter</code> 类，传入 <code>-c config/your_job.conf -e local</code> 参数，即可断点调试整个流程。</li>\n</ol>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 16:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/seatunnel\">ApacheSeaTunnel</a>&nbsp;\n阅读(<span id=\"post_view_count\">70</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "从零开始学Flink：状态管理与容错机制",
      "link": "https://www.cnblogs.com/daimajiangxin/p/19574902",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/daimajiangxin/p/19574902\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 15:48\">\n    <span>从零开始学Flink：状态管理与容错机制</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"从零开始学Flink：状态管理与容错机制\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3365149/202602/3365149-20260204154757186-1959035735.png\" />\n        本文深入解析 Apache Flink 的核心特性——状态管理（State Management）与容错机制（Fault Tolerance），涵盖状态类型、State Backend 选择、Checkpoint 原理及配置、以及 Savepoint 的生产实践。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>流式计算任务通常需要 7x24 小时长期运行，面对网络抖动、机器故障或代码 Bug，如何保证任务不挂？或者挂了之后能自动恢复且数据不丢、不重？这正是 Flink 引以为傲的资本：<strong>强大的状态管理</strong>与<strong>基于 Checkpoint 的容错机制</strong>。</p>\n<p>本文将带你深入理解 Flink 是如何“记忆”数据的，以及它是如何在故障发生时“时光倒流”恢复现场的。</p>\n<h2 id=\"一什么是状态state\">一、什么是状态（State）</h2>\n<p>在流计算中，数据是一条条流过的。如果处理一条数据时，需要依赖<strong>之前</strong>的数据（例如：计算过去一小时的总和、去重、模式匹配），那么这些“之前的数据”或“中间计算结果”就是<strong>状态</strong>。</p>\n<h3 id=\"1-状态的分类\">1. 状态的分类</h3>\n<p>Flink 的状态分为两大类：<strong>Managed State（托管状态）</strong> 和 <strong>Raw State（原生状态）</strong>。我们日常开发 99% 使用的是托管状态，由 Flink 运行时自动管理内存、序列化和故障恢复。</p>\n<p>Managed State 又细分为：</p>\n<ul>\n<li><strong>Keyed State（键控状态）</strong>\n<ul>\n<li>只能在 <code>KeyedStream</code>（即 <code>keyBy</code> 之后）上使用。</li>\n<li>状态是跟 Key 绑定的。Flink 为每个 Key 维护一份独立的状态实例。</li>\n<li>常用类型：<code>ValueState</code>、<code>ListState</code>、<code>MapState</code>、<code>ReducingState</code>、<code>AggregatingState</code>。</li>\n</ul>\n</li>\n<li><strong>Operator State（算子状态）</strong>\n<ul>\n<li>绑定到算子并行实例（SubTask），与 Key 无关。</li>\n<li>常用于 Source Connector（记录读取的 Offset）或 Sink Connector（事务控制）。</li>\n<li>常用接口：<code>ListState</code>、<code>UnionListState</code>、<code>BroadcastState</code>。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"二状态后端state-backends\">二、状态后端（State Backends）</h2>\n<p>状态存在哪里？是内存还是磁盘？这由 <strong>State Backend</strong> 决定。在 Flink 1.13 之后，配置方式简化为以下两种主要模式：</p>\n<h3 id=\"1-hashmapstatebackend-基于内存\">1. HashMapStateBackend (基于内存)</h3>\n<ul>\n<li><strong>存储位置</strong>：Java 堆内存（Heap）。</li>\n<li><strong>特点</strong>：读写速度极快（对象直接访问，无序列化开销）。</li>\n<li><strong>适用场景</strong>：状态较小（例如仅仅是简单的 Count 或去重），对延迟极其敏感的场景。</li>\n<li><strong>缺点</strong>：受限于 JVM 堆大小，容易 GC；状态过大时可能 OOM。</li>\n</ul>\n<h3 id=\"2-embeddedrocksdbstatebackend-基于磁盘\">2. EmbeddedRocksDBStateBackend (基于磁盘)</h3>\n<ul>\n<li><strong>存储位置</strong>：TaskManager 本地磁盘（基于 RocksDB 数据库），内存中只作为缓存（Off-heap）。</li>\n<li><strong>特点</strong>：支持超大状态（TB 级别），不受 JVM 堆限制。</li>\n<li><strong>适用场景</strong>：超大窗口、超长周期的聚合、海量 Key 的去重。</li>\n<li><strong>缺点</strong>：需要序列化/反序列化，读写性能略低于内存版；需要调优 RocksDB 参数。</li>\n</ul>\n<h3 id=\"3-配置示例\">3. 配置示例</h3>\n<pre><code class=\"language-java\">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n// 设置状态后端为 RocksDB\nenv.setStateBackend(new EmbeddedRocksDBStateBackend());\n\n// 配合 Checkpoint 存储路径（存储在本地文件系统）\nenv.getCheckpointConfig().setCheckpointStorage(\"file:///tmp/flink/checkpoints\");\n</code></pre>\n<h2 id=\"三容错核心checkpoint\">三、容错核心：Checkpoint</h2>\n<p>Checkpoint（检查点）是 Flink 容错机制的灵魂。它是一个<strong>全局一致性快照</strong>，定期将所有算子的状态持久化到远程存储（如 HDFS）。</p>\n<h3 id=\"1-核心原理barrier-对齐\">1. 核心原理：Barrier 对齐</h3>\n<p>Flink 使用 <strong>Chandy-Lamport 算法</strong> 的变体。</p>\n<ol>\n<li><strong>Barrier 注入</strong>：JobManager 向 Source 发送 Checkpoint Barrier。</li>\n<li><strong>Barrier 流动</strong>：Barrier 像普通数据一样在流中传输。</li>\n<li><strong>对齐（Alignment）</strong>：当算子有多个输入流时，必须等待所有流的 Barrier 到齐，才能进行 Snapshot。这保证了状态的一致性（即 Exactly-Once）。</li>\n<li><strong>异步快照</strong>：算子将状态写入远程存储（异步过程），不阻塞数据处理。</li>\n<li><strong>确认完成</strong>：所有算子都完成快照后，JobManager 确认 Checkpoint 成功。</li>\n</ol>\n<h3 id=\"2-checkpoint-配置实战\">2. Checkpoint 配置实战</h3>\n<p>默认情况下 Checkpoint 是关闭的，生产环境<strong>必须开启</strong>。</p>\n<pre><code class=\"language-java\">// 1. 开启 Checkpoint，每 5000ms 触发一次\nenv.enableCheckpointing(5000);\n\n// 2. 设置 Checkpoint 模式（默认 EXACTLY_ONCE，也可以设为 AT_LEAST_ONCE）\nenv.getCheckpointConfig().setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE);\n\n// 3. 设置两次 Checkpoint 之间的最小间隔（防止频繁 Checkpoint 导致性能下降）\nenv.getCheckpointConfig().setMinPauseBetweenCheckpoints(1000);\n\n// 4. Checkpoint 超时时间（默认 10分钟）\nenv.getCheckpointConfig().setCheckpointTimeout(60000);\n\n// 5. 允许同时进行的 Checkpoint 数量（通常设为 1）\nenv.getCheckpointConfig().setMaxConcurrentCheckpoints(1);\n\n// 6. 开启作业取消时保留 Checkpoint（非常重要！否则 Cancel 任务会删除 Checkpoint）\nenv.getCheckpointConfig().setExternalizedCheckpointCleanup(\n    CheckpointConfig.ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION\n);\n\n// 7. 容忍 Checkpoint 失败次数（默认 0，即 Checkpoint 失败会导致任务重启）\nenv.getCheckpointConfig().setTolerableCheckpointFailureNumber(3);\n</code></pre>\n<h2 id=\"四savepoint手动的超级-checkpoint\">四、Savepoint：手动的超级 Checkpoint</h2>\n<p>虽然 Checkpoint 和 Savepoint 看起来很像（都是快照），但它们的定位完全不同：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">特性</th>\n<th style=\"text-align: left;\">Checkpoint</th>\n<th style=\"text-align: left;\">Savepoint</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>触发方式</strong></td>\n<td style=\"text-align: left;\">Flink 定时自动触发</td>\n<td style=\"text-align: left;\">用户手动命令触发</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>主要目的</strong></td>\n<td style=\"text-align: left;\"><strong>故障恢复</strong>（Failover）</td>\n<td style=\"text-align: left;\"><strong>运维操作</strong>（升级、扩容、迁移）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>存储格式</strong></td>\n<td style=\"text-align: left;\">增量存储（依赖 StateBackend 优化）</td>\n<td style=\"text-align: left;\">标准格式，全量存储（可跨版本）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>生命周期</strong></td>\n<td style=\"text-align: left;\">随作业生命周期管理（除非设置保留）</td>\n<td style=\"text-align: left;\">用户自行管理（删除需手动）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"常用命令\">常用命令</h3>\n<pre><code class=\"language-bash\"># 触发 Savepoint\nbin/flink savepoint &lt;jobId&gt; [targetDirectory]\n\n# 从 Savepoint 重启作业 (或者 Checkpoint)\nbin/flink run -s &lt;savepointPath&gt; ...\n</code></pre>\n<h2 id=\"五重启策略restart-strategies\">五、重启策略（Restart Strategies）</h2>\n<p>当任务发生故障（Exception）时，Flink 会尝试根据配置的策略自动重启。</p>\n<pre><code class=\"language-java\">// 1. 固定延迟重启（尝试 3 次，每次间隔 10秒）\nenv.setRestartStrategy(RestartStrategies.fixedDelayRestart(\n    3, \n    Duration.ofSeconds(10)\n));\n\n// 2. 失败率重启（在 5 分钟内失败超过 3 次则停止，否则每次间隔 10秒重启）\nenv.setRestartStrategy(RestartStrategies.failureRateRestart(\n    3, \n    Duration.ofMinutes(5), \n    Duration.ofSeconds(10)\n));\n\n// 3. 无重启（直接失败）\nenv.setRestartStrategy(RestartStrategies.noRestart());\n</code></pre>\n<h2 id=\"六总结\">六、总结</h2>\n<ul>\n<li><strong>State</strong> 是 Flink 实现复杂逻辑的记忆。</li>\n<li><strong>State Backend</strong> 决定了记忆存哪里（内存快但小，RocksDB 大但需序列化）。</li>\n<li><strong>Checkpoint</strong> 是自动化的定期备份，保证故障恢复后的数据一致性。</li>\n<li><strong>Savepoint</strong> 是手动的高级备份，用于版本升级和应用迁移。</li>\n</ul>\n<p>掌握了状态与容错，你的 Flink 任务才算真正具备了“生产级”的健壮性。下一篇，我们将探讨 Flink SQL，看看如何用 SQL 解决 80% 的流计算需求。</p>\n<hr />\n<p>原文来自：<a href=\"http://blog.daimajiangxin.com.cn\" rel=\"noopener nofollow\" target=\"_blank\">http://blog.daimajiangxin.com.cn</a></p>\n<p>源码地址：<a href=\"https://gitee.com/daimajiangxin/flink-learning\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/daimajiangxin/flink-learning</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 15:48</span>&nbsp;\n<a href=\"https://www.cnblogs.com/daimajiangxin\">代码匠心</a>&nbsp;\n阅读(<span id=\"post_view_count\">90</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "istio流量分发实战：从配置到踩坑全解析",
      "link": "https://www.cnblogs.com/MrVolleyball/p/19574573",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/MrVolleyball/p/19574573\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 15:04\">\n    <span>istio流量分发实战：从配置到踩坑全解析</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文通过一个真实的 Istio 流量分发案例，系统梳理按比例、按 Header、按 URL 前缀等常见路由方式，并重点分析 Host 不匹配导致流量失效的根因。结合 Nginx 与 Sidecar 共存场景，详细说明金丝雀、灰度、蓝绿及 A/B 测试在 Istio 中的落地方式，适合正在或即将引入 Istio 的工程实践参考\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>上一小节，istio成功的安装，并且还解决了常见的426的问题，本节内容主要探讨一下istio关于流量转发的问题</p>\n<h2 id=\"按比例分发\">按比例分发</h2>\n<h4 id=\"配置\">配置</h4>\n<p>需要创建一个backend-v1，它与backend的selector都是<code>app: backend</code>，backend-v1部署完成之后，它会立即分走50%的流量，为了测试istio流控，我们需要在不改变任何配置的情况下实现9:1分流，也就是90%进入原backend，10%进入新的backend-v1</p>\n<p><img alt=\"watermarked-istio_functions_1\" class=\"lazyload\" /></p>\n<ul>\n<li>\n<p>标记2个deployment，追加标签，backend为<code>version: v0</code>，backend-v1为<code>version: v1</code></p>\n<pre><code>kubectl patch deployment backend -p '{\"spec\":{\"template\":{\"metadata\":{\"labels\":{\"version\":\"v0\"}}}}}'\nkubectl patch deployment backend-v1 -p '{\"spec\":{\"template\":{\"metadata\":{\"labels\":{\"version\":\"v1\"}}}}}'\n</code></pre>\n</li>\n<li>\n<p>创建istio资源：DestinationRule，该资源主要用来标记istio要往哪个地方转发</p>\n<pre><code>apiVersion: networking.istio.io/v1\nkind: DestinationRule\nmetadata:\n  name: backend-dr\n  namespace: default\nspec:\n  host: backend-service\n  subsets:\n  - labels:\n      version: v0\n    name: v0\n  - labels:\n      version: v1\n    name: v1\n\n</code></pre>\n</li>\n<li>\n<p>创建istio资源：VirtualService，该资源用来确定转发的权重</p>\n<pre><code>apiVersion: networking.istio.io/v1\nkind: VirtualService\nmetadata:\n  name: backend-vs\n  namespace: default\nspec:\n  hosts:\n  - backend-service\n  http:\n  - route:\n    - destination:\n        host: backend-service\n        subset: v0\n      weight: 90\n    - destination:\n        host: backend-service\n        subset: v1\n      weight: 10\n</code></pre>\n</li>\n</ul>\n<h4 id=\"调试\">调试</h4>\n<ul>\n<li>\n<p>测试命令： <code>for i in {1..10}; do curl -s 10.22.12.178:30785/test &gt; /dev/null ; done</code></p>\n</li>\n<li>\n<p>登录到k8s的istio-proxy控制台查看： <code>kubectl logs -f -l app=backend -c istio-proxy</code></p>\n<pre><code>[2026-01-28T08:24:55.670Z] \"GET /test HTTP/1.1\" 200 - upstream=10.244.0.55:10000 duration=0ms route=default\n[2026-01-28T08:24:55.687Z] \"GET /test HTTP/1.1\" 200 - upstream=10.244.0.55:10000 duration=0ms route=default\n[2026-01-28T08:24:55.706Z] \"GET /test HTTP/1.1\" 200 - upstream=10.244.0.53:10000 duration=0ms route=default\n[2026-01-28T08:24:55.741Z] \"GET /test HTTP/1.1\" 200 - upstream=10.244.0.53:10000 duration=1ms route=default\n[2026-01-28T08:24:55.751Z] \"GET /test HTTP/1.1\" 200 - upstream=10.244.0.53:10000 duration=0ms route=default\n[2026-01-28T08:24:55.759Z] \"GET /test HTTP/1.1\" 200 - upstream=10.244.0.53:10000 duration=0ms route=default\n[2026-01-28T08:24:55.696Z] \"GET /test HTTP/1.1\" 200 - upstream=10.244.0.55:10000 duration=0ms route=default\n[2026-01-28T08:24:55.716Z] \"GET /test HTTP/1.1\" 200 - upstream=10.244.0.55:10000 duration=0ms route=default\n[2026-01-28T08:24:55.725Z] \"GET /test HTTP/1.1\" 200 - upstream=10.244.0.55:10000 duration=0ms route=default\n[2026-01-28T08:24:55.734Z] \"GET /test HTTP/1.1\" 200 - upstream=10.244.0.55:10000 duration=0ms route=default\n\n</code></pre>\n<pre><code>▶ kubectl get pod -owide\nNAME                          READY   STATUS    RESTARTS   AGE     IP            NODE     NOMINATED NODE   READINESS GATES\nbackend-86b958bdc-5zjgn       2/2     Running   0          21m     10.244.0.53   wilson   &lt;none&gt;           &lt;none&gt;\nbackend-v1-75ccff86dc-sl6bt   2/2     Running   0          119s    10.244.0.55   wilson   &lt;none&gt;           &lt;none&gt;\nnginx-test-7d87875694-8vsrp   2/2     Running   0          30m     10.244.0.61   wilson   &lt;none&gt;           &lt;none&gt;\n</code></pre>\n</li>\n<li>\n<p>明显不对，10.244.0.55与10.244.0.53的比例并没有呈现9:1，转发到backend要backend-v1还是5:5</p>\n</li>\n</ul>\n<h4 id=\"修复\">修复</h4>\n<p>可以直接修改nginx的配置</p>\n<pre><code>server {\n    listen       80;\n    listen  [::]:80;\n    server_name  localhost;\n\n    location /test {\n        proxy_http_version 1.1;\n        # proxy_set_header Host $host; # 原配置\n        proxy_set_header Host backend-service.default.svc.cluster.local; # 新配置\n        proxy_pass http://backend-service:10000;\n    }\n}\n</code></pre>\n<p>重启之后再次测试：</p>\n<pre><code>[2026-01-28T08:30:59.968Z] \"GET /test HTTP/1.1\" 200 - upstream=10.244.0.53:10000 duration=0ms route=default\n[2026-01-28T08:30:59.988Z] \"GET /test HTTP/1.1\" 200 - upstream=10.244.0.53:10000 duration=1ms route=default\n[2026-01-28T08:31:00.027Z] \"GET /test HTTP/1.1\" 200 - upstream=10.244.0.53:10000 duration=1ms route=default\n[2026-01-28T08:31:00.037Z] \"GET /test HTTP/1.1\" 200 - upstream=10.244.0.53:10000 duration=0ms route=default\n[2026-01-28T08:31:00.048Z] \"GET /test HTTP/1.1\" 200 - upstream=10.244.0.53:10000 duration=0ms route=default\n[2026-01-28T08:31:00.056Z] \"GET /test HTTP/1.1\" 200 - upstream=10.244.0.53:10000 duration=0ms route=default\n[2026-01-28T08:31:00.008Z] \"GET /test HTTP/1.1\" 200 - upstream=10.244.0.55:10000 duration=0ms route=default\n[2026-01-28T08:31:00.066Z] \"GET /test HTTP/1.1\" 200 - upstream=10.244.0.53:10000 duration=0ms route=default\n[2026-01-28T08:31:00.074Z] \"GET /test HTTP/1.1\" 200 - upstream=10.244.0.53:10000 duration=0ms route=default\n[2026-01-28T08:31:00.083Z] \"GET /test HTTP/1.1\" 200 - upstream=10.244.0.53:10000 duration=0ms route=default\n</code></pre>\n<p>已经生效了，这次只有1次10.244.0.55:10000</p>\n<h4 id=\"疑问\">疑问</h4>\n<p>有位大哥说了，如果这样配置的，明显影响了业务：</p>\n<ul>\n<li>nginx的配置被修改了</li>\n<li>所有的host被写死了，都成了：backend-service.default.svc.cluster.local，而后端业务是需要把客户端的host带入过去的，改了之后后端业务收到严重影响</li>\n</ul>\n<p>确实，固定host属于粗暴简单的写法，还有更加惊喜的解决方法，调整VirtualService，添加hosts</p>\n<pre><code>apiVersion: networking.istio.io/v1\nkind: VirtualService\nmetadata:\n  name: backend-vs\n  namespace: default\nspec:\n  hosts:\n  - backend-service\n  - api.wilsontest.com # 新增\n  http:\n  - route:\n    - destination:\n        host: backend-service\n        subset: v0\n      weight: 90\n    - destination:\n        host: backend-service\n        subset: v1\n      weight: 10\n</code></pre>\n<p>客户端访问的时候必须带上该域名： <code>for i in {1..10}; do curl -s -H 'host: api.wilsontest.com' 10.22.12.178:30785/test &gt; /dev/null ; done</code></p>\n<p>这样也可以解决问题，不过坑点也来了，年久失修，从无数前人继承的祖传代码，就需要好好的梳理到底有哪些host来访问，否则漏掉host的话，就会出现配置问题。-_-!</p>\n<p>再次凸显了istio之中，host是非常非常重要的，Istio 的路由决策、Service 的匹配完全依赖 Host 头</p>\n<ul>\n<li>Istio 的 VirtualService 本质上是一个“增强版”的路由器。如果发现请求的 Host 是 backend-service，就按 90:10 分配。</li>\n<li>之前的配置是$host，由于客户端没有传输host，当请求经过 Nginx 的 Sidecar时，它会检查Host，发现为空。由于路由表里没有对应的记录 ，sidecar并不认识，按普通 K8s 流量处理</li>\n</ul>\n<h2 id=\"按header分发\">按header分发</h2>\n<pre><code>apiVersion: networking.istio.io/v1\nkind: VirtualService\nmetadata:\n  name: backend-vs\n  namespace: default\nspec:\n  hosts:\n  - backend-service\n  - api.wilsontest.com\n  http:\n  - match:\n    - headers:\n        hellotest:\n          exact: \"true\"\n    route:\n    - destination:\n        host: backend-service\n        subset: v1\n  - route:\n    - destination:\n        host: backend-service\n        subset: v0\n</code></pre>\n<p><code>curl -s -H 'host: api.wilsontest.com' -H 'hellotest: true' 10.22.12.178:30785/test</code>。只有header里面匹配了<code>hellotest: true</code>才会去v1，否则全部去v0</p>\n<h2 id=\"按前缀分发\">按前缀分发</h2>\n<pre><code>apiVersion: networking.istio.io/v1\nkind: VirtualService\nmetadata:\n  name: backend-vs\n  namespace: default\nspec:\n  hosts:\n  - backend-service\n  - api.wilsontest.com\n  http:\n  - match:\n    - uri:\n        prefix: /test/v1\n    route:\n    - destination:\n        host: backend-service\n        subset: v1\n  - route:\n    - destination:\n        host: backend-service\n        subset: v0\n</code></pre>\n<p>带有/test/v1前缀的都会去新版本v1，满足不了条件都会走默认的版本v0</p>\n<h2 id=\"url改写\">url改写</h2>\n<pre><code>apiVersion: networking.istio.io/v1\nkind: VirtualService\nmetadata:\n  name: backend-vs\n  namespace: default\nspec:\n  hosts:\n  - backend-service\n  - api.wilsontest.com\n  http:\n  - match:\n    - uri:\n        prefix: /test/v1\n    route:\n    - destination:\n        host: backend-service\n        subset: v1\n  - match:\n    - uri:\n        prefix: /test/v2\n    rewrite:\n      uri: /test\n    route:\n    - destination:\n        host: backend-service\n        subset: v0\n  - route:\n    - destination:\n        host: backend-service\n        subset: v0\n\n</code></pre>\n<p>如果是/test/v1，就访问v1版本，/test/v2重写成/test并且访问v0版本，其余的默认都会走v0版本</p>\n<h2 id=\"蓝绿金丝雀灰度ab测试\">蓝绿、金丝雀、灰度、A/B测试</h2>\n<p>关于流量分流的各种操作，大部分都集中在以下场景：</p>\n<ul>\n<li>蓝绿：实现瞬间切换与零宕机回滚，消除发布期间的中间状态</li>\n<li>金丝雀：像矿工用金丝雀探测毒气一样，先让一小部分用户（如1%~5%）访问新版本，观察系统指标（如错误率、延迟），若无问题再逐步扩大范围</li>\n<li>灰度：将用户群体按比例或特定规则（如地域、设备）逐步切换到新版本（例如10%→30%→100%），持续观察反馈</li>\n<li>A/B：同时向随机分组的用户展示不同版本（A组用旧版，B组用新版），通过统计指标（如点击率、转化率）判断哪个版本更优</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>蓝绿发布</th>\n<th>金丝雀发布</th>\n<th>灰度发布</th>\n<th>A/B测试</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>主要目标</td>\n<td>零停机、瞬时回滚</td>\n<td>用真实流量快速发现技术风险</td>\n<td>平稳、可控地逐步替换所有用户</td>\n<td>验证不同版本的业务效果</td>\n</tr>\n<tr>\n<td>流量路由</td>\n<td>全量切换（100%→0%）</td>\n<td>极小比例引流（如1%-5%）</td>\n<td>按比例分阶段扩大（10%→50%→100%）</td>\n<td>按规则/随机分配（如50%/50%）</td>\n</tr>\n<tr>\n<td>关注重点</td>\n<td>系统可用性与回滚速度</td>\n<td>系统稳定性指标（错误率、延迟）</td>\n<td>发布过程平稳性与综合反馈</td>\n<td>业务指标（转化率、留存率）</td>\n</tr>\n<tr>\n<td>所需资源</td>\n<td>两套完整环境，成本高</td>\n<td>一套环境，新版本实例较少</td>\n<td>一套环境，新旧版本实例共存</td>\n<td>一套或多套环境，并行运行多个版本</td>\n</tr>\n<tr>\n<td>用户选择</td>\n<td>全体用户同时切换</td>\n<td>小部分用户随机或按基础设施选择</td>\n<td>用户按比例或属性逐步迁移</td>\n<td>用户随机分组或按属性定向分配</td>\n</tr>\n<tr>\n<td>持续时间</td>\n<td>极短（切换在几分钟内）</td>\n<td>短（几小时到一天）</td>\n<td>中长（几天到数周）</td>\n<td>长（数周到数月）</td>\n</tr>\n<tr>\n<td>典型场景</td>\n<td>关键业务大版本升级、基础设施更换</td>\n<td>后端服务、中间件、数据库变更</td>\n<td>前端功能、用户界面更新</td>\n<td>UI设计、文案、算法策略、定价优化</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"联系我\">联系我</h2>\n<ul>\n<li>联系我，做深入的交流</li>\n</ul>\n<p><img alt=\"\" class=\"lazyload\" height=\"200\" width=\"500\" /></p>\n<hr />\n<p>至此，本文结束<br />\n在下才疏学浅，有撒汤漏水的，请各位不吝赐教...</p>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/MrVolleyball/\" target=\"_blank\">it排球君</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/MrVolleyball/p/19574573\" target=\"_blank\">https://www.cnblogs.com/MrVolleyball/p/19574573</a></p>\n<div>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须在文章页面给出原文连接，否则保留追究法律责任的权利。 </div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 15:04</span>&nbsp;\n<a href=\"https://www.cnblogs.com/MrVolleyball\">it排球君</a>&nbsp;\n阅读(<span id=\"post_view_count\">91</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "你有多少次对着设计稿说\"感觉不对，但说不上来\"？",
      "link": "https://www.cnblogs.com/huizhudev/p/19576907",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/huizhudev/p/19576907\" id=\"cb_post_title_url\" title=\"发布于 2026-02-05 01:57\">\n    <span>你有多少次对着设计稿说\"感觉不对，但说不上来\"？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"你有多少次对着设计稿说&amp;quot;感觉不对，但说不上来&amp;quot;？\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3695776/202602/3695776-20260205015703204-495254137.png\" />\n        面对品牌设计的焦虑，大多数人不知道该如何准确描述需求。这条LOGO设计AI指令通过8个问题引导专业思考，将复杂的创作过程结构化为\"填空题\"，让普通人也能获得专业级的品牌设计方案，大幅降低与设计师的沟通成本。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"第一个问题你的品牌视觉人格分裂吗\">第一个问题：你的品牌视觉\"人格分裂\"吗？</h2>\n<p>名片上用的是蓝色渐变，官网却是橙色点缀；PPT里的Logo是圆角的，但海报上的又是直角的。</p>\n<p>你看着这些东西，总觉得哪里不对劲，又说不上来。</p>\n<h2 id=\"第二个问题新项目启动你的第一反应是什么\">第二个问题：新项目启动，你的第一反应是什么？</h2>\n<p>打开设计网站刷两小时灵感？找5家设计公司比价格？还是直接套个现成模板改改字？</p>\n<h2 id=\"第三个问题当设计师问你要什么风格你的答案是什么\">第三个问题：当设计师问你\"要什么风格\"，你的答案是什么？</h2>\n<p>\"要大气\"？\"要高级\"？\"要简约但有科技感\"？</p>\n<p>这些词，设计师听进去的都是废话。</p>\n<p><img alt=\"你有多少次对着设计稿说&quot;感觉不对，但说不上来&quot;？\" class=\"lazyload\" /></p>\n<p>这三个问题背后，是一个更残酷的真相：<strong>大多数人不懂品牌设计，但都在硬着头皮做品牌决策。</strong></p>\n<p>创业公司的创始人、市场部的品牌经理、自由职业者、甚至只是想给自己搞个个人IP的普通人——大家都在同一个坑里：<strong>视觉表达的焦虑</strong>。</p>\n<p>你很清楚，一个好的LOGO能让用户在0.5秒内记住你。一个专业的视觉系统能让你的品牌在人群中脱颖而出。</p>\n<p>但你没有几十万预算请4A公司，也不懂设计术语，更别说知道什么是\"负空间\"、\"色彩心理学\"、\"黄金比例\"。</p>\n<p>于是你只能碰运气。运气好遇到靠谱的设计师，运气不好——大概率就是那种改了10版还是\"感觉不对\"的噩梦。</p>\n<p>但今天我想分享一个可能改变你游戏规则的方法。</p>\n<p>不是教你学设计，也不是给你推荐设计师。</p>\n<p>而是教你如何用AI，让专业的设计思维为你工作。</p>\n<hr />\n<h2 id=\"设计师脑子里的地图\">设计师脑子里的\"地图\"</h2>\n<p>先说个故事。</p>\n<p>上个月，我和一位有10年经验的品牌设计师聊天。我问他：\"当客户跟你说'要大气'的时候，你脑子里在想什么？\"</p>\n<p>他笑了：\"如果只听这一句，我什么都不会做。我会先问这8个问题：\"</p>\n<ol>\n<li>你的目标用户是谁？年龄、性别、职业、收入、审美偏好？</li>\n<li>你的行业属性是什么？科技、餐饮、金融、教育？</li>\n<li>你的品牌定位是高端、中端还是大众？</li>\n<li>你想传递的核心价值是什么？信任、创新、亲和、专业？</li>\n<li>你的竞争对手是谁？他们用了什么风格？</li>\n<li>你有什么独特的文化基因或地域特色？</li>\n<li>你有固定的品牌色吗？或者讨厌的颜色？</li>\n<li>这个LOGO主要用在什么场景？APP图标、门店招牌、产品包装？</li>\n</ol>\n<p>\"只有把这些信息都收集齐了，我才能开始想设计。\"</p>\n<p>这8个问题，就是设计师脑子里的\"地图\"。没有这张地图，他们会在创作的迷宫里原地打转。</p>\n<p>而普通人做品牌设计时，几乎从来不问这些问题——因为我们根本不知道要问。</p>\n<p>于是沟通就变成了猜谜游戏。设计师猜你要什么，你猜设计师听懂了什么。大家都在黑暗中摸索，最后结果可想而知。</p>\n<p>但现在，这个\"地图\"有了新的主人。</p>\n<hr />\n<h2 id=\"️-一条指令把10年设计经验打包下载\">🗺️ 一条指令，把10年设计经验\"打包下载\"</h2>\n<p>下面这条指令，是我见过最完整的LOGO设计AI提示词之一。</p>\n<p>它把资深品牌设计师的创作流程——从品牌分析到创意产出——全部结构化、标准化。你不需要懂设计术语，只需要回答8个基础问题，AI就能帮你产出专业级的LOGO设计方案。</p>\n<pre><code class=\"language-markdown\"># 角色定义\n你是一位资深的品牌视觉设计师，拥有10年以上的LOGO设计经验。你精通品牌识别系统设计，擅长将品牌理念转化为简洁有力的视觉符号。你深谙设计心理学原理，熟悉不同行业的设计规范和流行趋势。你的作品曾服务于多家知名企业和创业公司，能够精准把握品牌调性，创造出兼具艺术性和商业价值的LOGO作品。\n\n# 任务描述\n根据用户提供的品牌信息，创作出专业、独特、易于识别的LOGO设计创意方案。LOGO应该能够准确传达品牌核心理念，具有强烈的视觉冲击力和记忆点，同时符合行业特征和目标受众审美。\n\n**输入信息**:\n- **品牌名称**: [品牌名称]\n- **品牌行业**: [所属行业]\n- **品牌定位**: [高端/中端/大众、年轻/成熟、专业/亲民等]\n- **核心理念/价值观**: [品牌想要传达的核心信息]\n- **目标受众**: [主要服务的人群特征]\n- **风格偏好**（可选）: [如：简约现代、复古经典、科技感、文艺手绘等]\n- **品牌颜色**（可选）: [已有品牌色或期望使用的颜色]\n- **竞争对手**（可选）: [主要竞品或参考品牌]\n- **设计偏好**（可选）: [图形类、文字类、图文结合等]\n\n# 输出要求\n\n## 1. 内容结构\n\n### 第一部分：品牌分析与设计定位\n- 品牌核心理念拆解\n- 目标受众审美特征分析\n- 行业设计风格趋势\n- 设计关键词提炼（3-5个）\n\n### 第二部分：创意方案展示（提供3-5个不同方向）\n每个方案包含：\n- **方案名称**: 简洁的方案标题\n- **设计理念**: 详细阐述创意来源和设计思路\n- **视觉描述**: 详细描述LOGO的图形元素、构成方式\n- **色彩方案**: 主色、辅助色的色彩代码及搭配说明\n- **字体建议**: 推荐的字体风格和具体字体名称\n- **应用场景**: 适合的应用场景示例（名片、网站、包装等）\n- **优势分析**: 该方案的独特优势和适用性\n\n### 第三部分：设计延展建议\n- 品牌辅助图形设计建议\n- LOGO在不同背景下的变体（深色/浅色背景）\n- 标志与品牌名称的组合方式\n- 标志禁用规范说明\n\n## 2. 质量标准\n- **独特性**: 创意新颖，避免与市场上现有LOGO雷同\n- **简洁性**: 视觉元素精炼，易于识别和记忆\n- **专业性**: 符合设计美学原则，具有商业价值\n- **适应性**: 能够适应不同尺寸和媒介的展示需求\n- **可延展性**: 为品牌VI系统延展留有足够空间\n\n## 3. 格式要求\n- 使用清晰的层级标题\n- 每个方案使用分隔线区分\n- 色彩代码使用HEX格式（如 #FF5733）\n- 方案描述使用段落形式，每段不超过3行\n- 总字数控制在800-1500字\n\n## 4. 风格约束\n- **语言风格**: 专业但不晦涩，兼顾设计术语和通俗易懂\n- **表达方式**: 客观描述为主，适当融入创意灵感\n- **专业程度**: 深入专业但能被非专业人士理解\n\n# 质量检查清单\n\n在完成输出后,请自我检查:\n- [ ] 是否分析了品牌核心理念和目标受众\n- [ ] 是否提供了至少3个不同风格的设计方案\n- [ ] 每个方案是否包含完整的设计描述和色彩说明\n- [ ] 色彩代码是否使用了正确的HEX格式\n- [ ] 是否提供了字体建议和应用场景示例\n- [ ] 设计思路是否清晰且有说服力\n- [ ] 是否考虑了LOGO的实际应用场景\n\n# 注意事项\n- 避免提供过于复杂的图形描述，确保描述能够被AI图像生成工具理解\n- 不要直接复制知名品牌的设计元素\n- 注意颜色搭配的专业性，考虑色彩心理学原理\n- 字体建议要兼顾美观性和易读性\n- 每个方案要有明确的差异化，避免风格重复\n- 注意品牌文化元素的恰当运用\n\n# 输出格式\n请按照以下结构输出：\n\n---\n**【LOGO创意设计方案】**\n\n**品牌**: [品牌名称]\n**行业**: [行业类别]\n\n---\n\n## 🎯 品牌分析与定位\n[品牌核心理念、目标受众、设计关键词分析]\n\n---\n\n## 💡 创意方案展示\n\n### 方案一：[方案名称]\n**设计理念**\n[详细描述创意来源]\n\n**视觉描述**\n[详细描述LOGO的视觉构成]\n\n**色彩方案**\n- 主色: #[HEX代码] [色彩说明]\n- 辅助色: #[HEX代码] [色彩说明]\n\n**字体建议**\n[推荐字体风格和具体名称]\n\n**应用场景**\n[列举适用的应用场景]\n\n**优势分析**\n[说明该方案的优势]\n\n---\n\n### 方案二：[方案名称]\n[重复上述结构]\n\n---\n\n### 方案三：[方案名称]\n[重复上述结构]\n\n---\n\n## 🎨 设计延展建议\n[品牌视觉延展建议]\n</code></pre>\n<hr />\n<h2 id=\"-真实对话从要大气到专业方案\">💬 真实对话：从\"要大气\"到专业方案</h2>\n<p>让我给你看一个真实的对话，感受一下这种转变的魔力。</p>\n<p><strong>Before（常见沟通方式）</strong>：</p>\n<blockquote>\n<p><strong>创始人</strong>：帮我设计个LOGO，要大气，要有科技感，要高端。</p>\n<p><strong>设计师</strong>：......能具体点吗？</p>\n<p><strong>创始人</strong>：就像那种...嗯...你懂的，就是那种一看就很厉害的感觉。</p>\n</blockquote>\n<p>3个月后，改了8版，双方都不开心。</p>\n<p><strong>After（用AI指令）</strong>：</p>\n<p>创始人先花5分钟填写信息：</p>\n<blockquote>\n<p><strong>品牌名称</strong>: 星云智汇<br />\n<strong>品牌行业</strong>: 企业级SaaS软件<br />\n<strong>品牌定位</strong>: 专业、可靠、创新<br />\n<strong>核心理念</strong>: 用AI赋能企业数字化转型<br />\n<strong>目标受众</strong>: 30-50岁企业决策者、IT负责人<br />\n<strong>风格偏好</strong>: 简约现代、科技感、稳重<br />\n<strong>品牌颜色</strong>: 希望用蓝色系，代表专业和信任</p>\n</blockquote>\n<p>然后把这些信息丢给DeepSeek（或任何国产AI）。</p>\n<p>30秒后，AI输出了3个完整的设计方案，每个都包含：</p>\n<ul>\n<li>设计理念（为什么这么设计）</li>\n<li>视觉描述（具体长什么样）</li>\n<li>色彩方案（精确的HEX色值）</li>\n<li>字体建议（具体字体名称）</li>\n<li>应用场景（适合哪里用）</li>\n<li>优势分析（这个方案好在哪里）</li>\n</ul>\n<p>创始人选了最喜欢的方案二，然后把这段描述发给设计师：</p>\n<blockquote>\n<p>\"你好，这是我想要的方向：云朵与芯片的抽象融合，用渐变蓝体现科技感，字体用思源黑体...\"</p>\n</blockquote>\n<p>设计师一看就懂，第一版草图就通过了80%。</p>\n<p>整个流程从3个月、8轮修改，变成了3天、1次沟通。</p>\n<p>这不是夸张，这是真实发生的效率提升。</p>\n<hr />\n<h2 id=\"-这套指令帮你解决什么\">🎯 这套指令帮你解决什么？</h2>\n<p>让我用更直白的话说：</p>\n<p><strong>问题1：你不知道该怎么描述你想要的设计</strong></p>\n<p>AI指令会引导你回答8个具体问题。回答完这些问题，你实际上已经完成了\"品牌定位\"的思考过程。</p>\n<p><strong>问题2：你不知道什么样的设计是\"对的\"</strong></p>\n<p>AI会基于品牌定位给出3-5个不同方向的专业方案。你只需要在已经\"对\"的方案里选最顺眼的一个。</p>\n<p><strong>问题3：你和设计师的沟通成本太高</strong></p>\n<p>用AI输出的方案作为沟通媒介，设计师不需要猜你想要什么，你也不需要猜设计师听懂了没有。</p>\n<p><strong>问题4：你没有预算请专业团队</strong></p>\n<p>AI输出的方案虽然不能直接用，但它给了你一个\"正确答案\"的参考。你可以拿着这个方案去找更便宜的设计师，或者用AI绘图工具直接生成初稿。</p>\n<p>简单说：<strong>它把设计决策的门槛，从\"专业知识\"降到了\"填空题\"。</strong></p>\n<hr />\n<h2 id=\"-现在就试试\">🚀 现在就试试</h2>\n<p>不管你现在有没有品牌项目，都可以用这条指令做个练习。</p>\n<p>随便想一个假设的品牌：</p>\n<ul>\n<li>想开一家咖啡店？试试设计个LOGO</li>\n<li>想做个个人博客？试试设计个LOGO</li>\n<li>甚至只是想给你的微信小号设计个头像？</li>\n</ul>\n<p>回答那8个问题，把结果丢给AI。</p>\n<p>你会发现，原本神秘的设计过程，原来可以被拆解得这么清晰。</p>\n<p>然后，下次当你真的需要做品牌决策时，你就不会再对着设计师说\"要大气\"了。</p>\n<p>你会说：\"我的品牌定位是...目标用户是...所以我希望设计能体现...\"</p>\n<p>这才是品牌决策该有的样子。</p>\n<p><strong>别让\"感觉不对\"成为你品牌发展的障碍。用AI，让专业的设计思维为你工作。</strong></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-05 01:57</span>&nbsp;\n<a href=\"https://www.cnblogs.com/huizhudev\">realhuizhu</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "接口自动化测试报告",
      "link": "https://www.cnblogs.com/xi-yongqi/p/19571986",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xi-yongqi/p/19571986\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 23:08\">\n    <span>接口自动化测试报告</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h4 id=\"前述\">前述：</h4>\n<ul>\n<li>博客系统主要包括登录接口、列表接口、博客详情接口、用户认证接口、编辑接口、作者信息接口。通过开发者工具抓取相关url,使用脑图设计出相关测试样例，对该系统进行接口测试。</li>\n</ul>\n<h4 id=\"脑图\">脑图</h4>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h4 id=\"测试环境\">测试环境</h4>\n<ul>\n<li>技术栈：pytest框架、request模块、PyYAML模块、jsonSchema模块、allure-pytest模块、logging模块</li>\n<li>集成开发环境：pycharm</li>\n</ul>\n<h4 id=\"编写测试代码\">编写测试代码</h4>\n<ol>\n<li>根据上面的脑图，针对每一个接口编写相应的测试代码。</li>\n<li>统一封装公共属性，提高代码的复用性。</li>\n<li>为了在测试过程中能够准确发现错误，在utils中加入日志模块，方便直接定位。</li>\n<li>使用yaml数据管理工具，实现测试数据与代码分离，便于数据管理和维护。</li>\n<li>通过JSON Schema验证响应格式,确保返回数据的结构正确性。</li>\n</ol>\n<h4 id=\"代码结构展示\">代码结构展示</h4>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<ul>\n<li><a href=\"https://gitee.com/xylophone-queen/write-with-python/tree/dev/\" rel=\"noopener nofollow\" target=\"_blank\">代码地址</a></li>\n</ul>\n<h5 id=\"公共类---utils\">公共类---utils</h5>\n<ol>\n<li>request_util.py:将requests库的功能进行二次封装，提供统一的接口调用方式;通过全局变量host统一管理被测系统的基地址。</li>\n<li>yaml_util.py:提供对YAML格式测试数据文件的读写操作,允许测试过程中动态写入和读取数据。</li>\n<li>logger_util.py:多层次日志输出,将不同级别的日志分开存储，便于定位错误。</li>\n</ol>\n<h5 id=\"登陆页面---test_loginpy\">登陆页面---test_login.py</h5>\n<ul>\n<li>使用@pytest.mark.order(1)确保登录测试最先执行，成功登录是进行其他页面接口测试的基础。</li>\n<li>使用@pytest.mark.parametrize，结合脑图上面的用例，设置不同的条件进行登录测试。\n<ul>\n<li>覆盖了各种异常登录场景</li>\n<li>新增测试场景只需添加新的参数组合</li>\n<li>通过一次定义，多次执行减少重复代码</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"列表页---test_listpy\">列表页---test_list.py</h5>\n<ul>\n<li>验证博客列表接口的正常功能,确保API按预期返回博客数据</li>\n<li>验证API的认证授权机制,确保未认证用户无法访问受保护资源</li>\n<li>从响应中提取关键数据供后续测试使用,实现测试间的数据传递</li>\n</ul>\n<h5 id=\"详情页---test_detailpy\">详情页---test_detail.py</h5>\n<ul>\n<li>验证博客详情接口的正常功能，确保API按预期返回博客详细信息</li>\n<li>使用@pytest.mark.parametrize，实现了异常场景覆盖</li>\n<li>从YAML文件读取登录时生成的token，确保测试在已认证状态下执行</li>\n</ul>\n<h5 id=\"用户认证接口---test_getauthorinfopy\">用户认证接口---test_getAuthorInfo.py</h5>\n<ul>\n<li>补充了博客与作者信息关联的功能验证，完善了用户信息获取的测试覆盖，提供了作者信息查询的专项测试</li>\n<li>test_getAuthorInfo验证在拥有合法 token 和有效 blogId 时，接口能返回正确的数据</li>\n<li>通过 @pytest.mark.parametrize 进行了等价类与边界值分析，测试了空值、负数、中文字符、超长数字等异常输入</li>\n</ul>\n<h5 id=\"编辑接口---test_addpy\">编辑接口---test_add.py</h5>\n<ul>\n<li>验证博客添加功能的完整性和正确性，确保用户能够成功创建新博客</li>\n<li>通过参数化测试覆盖各种边界条件，确保系统对异常输入的正确处理</li>\n<li>验证富文本内容（链接、图片等）的正确处理，确保系统对各种内容格式的支持</li>\n<li>验证标题和内容不能为空的业务规则，确保数据验证逻辑的正确性</li>\n</ul>\n<h5 id=\"用户信息接口---test_getuserinfopy\">用户信息接口---test_getUserInfo.py</h5>\n<ul>\n<li>验证用户信息获取功能的完整性和正确性,确保用户能够成功获取自己的账户信息</li>\n<li>验证API的认证授权机制,确保未认证用户无法访问用户信息</li>\n<li>验证用户信息获取的业务规则,确保数据验证逻辑的正确性</li>\n</ul>\n<h4 id=\"测试结果展示\">测试结果展示</h4>\n<ul>\n<li>配置好pytest.ini文件配置，输出详细测试结果<br />\n<img alt=\"image\" class=\"lazyload\" /></li>\n<li>使用allure在终端生成可视化测试报告\n<ul>\n<li>命令：<code>allure generate .\\allure-results\\ -o .\\allure-reports --clean</code><br />\n<img alt=\"image\" class=\"lazyload\" /><br />\n<img alt=\"image\" class=\"lazyload\" /></li>\n</ul>\n</li>\n<li>可以看到32个测试用例全部通过，通过率百分百。</li>\n</ul>\n<h4 id=\"小结\">小结</h4>\n<ul>\n<li>进行测试时需要关注代码执行的顺序，使用pytest-order第三⽅插件，控制测试用例的执⾏顺序。\n<ul>\n<li>在test_login.py中使用@pytest.mark.order(1)---&gt;访问任何接口都应该先进行登录，确保信息的隐私性。</li>\n</ul>\n</li>\n<li>使用jsonschema对返回的数据格式进行校验，提高测试的效率和质量。</li>\n<li>测试阶段修改pytest.ini的配置为<code>[pytest] addopts = -vs</code>，输出具体的测试结果到终端，便于测试人员快速定位测试中出现的问题。</li>\n<li>完成测试后修改配置为<code>[pytest] addopts = -vs --alluredir allure-results</code>，并配合命令<code>allure generate .\\allure-results\\ -o .\\allure-reports --clean</code>输出测试报告。</li>\n<li>使用简单的YAML文件存储关键数据，通过read_yaml和write_yaml函数统一管理数据存取，在测试开始前清空YAML文件防止数据污染。</li>\n<li>在编写某个测试接口的相关代码前，可以使用postman预测，确保接口地址的准确性。</li>\n<li>使用@pytest.mark.parametrize 进行参数化测试，极大地减少代码冗余；实现“测试数据”与“测试逻辑”的分离。</li>\n</ul>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 23:08</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xi-yongqi\">我会替风去</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MAF快速入门（14）快速集成A2A Agent",
      "link": "https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper14",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper14\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 22:17\">\n    <span>MAF快速入门（14）快速集成A2A Agent</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"MAF快速入门（14）快速集成A2A Agent\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/381412/202602/381412-20260204221255430-336185513.png\" />\n        A2A 即 Agent-to-Agent，翻译过来就是“智能代理之间的协议”，我们可以理解为它就是一个大模型Agent们用来“聊天”的“通用语言”。本文介绍了MAF中集成A2A Agent的核心操作：将A2A Agent转换为AIFunction工具，然后由主Agent自主选择调用一个或多个A2A Agent获取信息整合后最终生成回答。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>大家好，我是Edison。</p>\n<p>最近我一直在跟着圣杰的《<a class=\"normal_text_link mp_article_text_link\" href=\"https://mp.weixin.qq.com/s?__biz=MzA4NzQzNTg4Ng==&amp;mid=2651744458&amp;idx=1&amp;sn=139f7584e81aeecd0945133bdc2b4791&amp;scene=21#wechat_redirect\" rel=\"noopener nofollow\" target=\"_blank\">.NET+AI智能体开发进阶</a>》课程学习MAF开发多智能体工作流，我强烈推荐你也上车跟我一起出发！</p>\n<p><a class=\"normal_text_link mp_article_text_link\" href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper13\" target=\"_blank\"><span>上一篇</span></a><span>，我们学习了MAF中常见的多智能体编排模式<span>。本篇，我们来了解下在MAF中如何快速集成A2A (Agent to Agent)。</span></span></p>\n<h1>1 A2A协议介绍</h1>\n<p>在之前的系列文章中我们其实已经介绍过A2A协议了，这里我们快速温习一下。A2A 即 Agent-to-Agent，翻译过来就是“智能代理之间的协议”，我们可以理解为它就是一个大模型Agent们用来“聊天”的“通用语言”。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202602/381412-20260204220340896-177118451.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>A2A定义了一套清晰、标准的沟通方式，让Agent们可以顺畅地交流，让不同平台和框架下的Agent都能够说“同一种话”，实现无障碍的信息交换和协作。</p>\n<p>更多关于A2A协议的内容：</p>\n<ul>\n<li><strong><strong><span><a class=\"normal_text_link mp_article_text_link\" href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-agent-to-agent-part01\" target=\"_blank\"><span>多Agent协作入门：基于A2A协议的Agent通信（上）</span></a></span></strong></strong></li>\n<li><strong><strong><span><a class=\"normal_text_link mp_article_text_link\" href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-agent-to-agent-part02\" target=\"_blank\"><span>多Agent协作入门：基于A2A协议的Agent通信（中）</span></a></span></strong></strong></li>\n</ul>\n<h1><strong><span>2 将A2A Agent封装为Tool<strong><span><br /></span></strong></span></strong></h1>\n<p>在MAF集成A2A Agent，最主要的操作就是：<strong>将A2A Agent封装为一个Tool</strong>，这个Tool对应到MAF中就是一个<strong>AIFunction</strong>对象。</p>\n<p>前面我们提到可以将MCP服务也封装为一个Tool（AIFunction）让Agent调用，这里A2A Agent也是一样的道理。</p>\n<p>这样做的好处是：<strong>让MAF中的Agent像调用本地函数一样调用远程A2A Agent&nbsp;或 MCP Server</strong>。</p>\n<p>下面的代码展示了在MAF中将A2A Card转换为Agent，然后再将Agent转换为AIFunction：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">......\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> functionTools = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> List&lt;AIFunction&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n</span><span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> endpoint <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> agentEndpoints)\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> resolver = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> A2ACardResolver(<span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> Uri(endpoint));\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> card = <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> resolver.GetAgentCardAsync();\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> agent = card.AsAIAgent(); <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Convert A2A Agent to AIAgent instance</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">\n    functionTools.AddRange(AgentFunctionHelper.CreateFunctionTools(agent, card));\n}\n......</span></pre>\n</div>\n<p>下面是AgentFunctionHelper类的代码实现：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentFunctionHelper\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> IEnumerable&lt;AIFunction&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> CreateFunctionTools(AIAgent a2aAgent, AgentCard agentCard)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> skill <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> agentCard.Skills)\n        {\n            AIFunctionFactoryOptions options </span>= <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\">()\n            {\n                Name </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> Sanitize(skill.Id),\n                Description </span>= $$<span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"\n</span><span style=\"color: rgba(0, 0, 0, 1);\">                {\n                    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">description</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">{{skill.Description}}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">tags</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">[{{string.Join(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">, skill.Tags ?? [])}}]</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">examples</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">[{{string.Join(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">, skill.Examples ?? [])}}]</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">inputModes</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">[{{string.Join(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">, skill.InputModes ?? [])}}]</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">outputModes</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">[{{string.Join(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">, skill.OutputModes ?? [])}}]</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n                }\n                </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">,</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">            };\n\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">yield</span> <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> AIFunctionFactory.Create(RunAgentAsync, options);\n        }\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">async</span> Task&lt;<span style=\"color: rgba(0, 0, 255, 1);\">string</span>&gt; RunAgentAsync(<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> input, CancellationToken cancellationToken)\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> response = <span style=\"color: rgba(0, 0, 255, 1);\">await</span> a2aAgent.RunAsync(input, cancellationToken: cancellationToken).ConfigureAwait(<span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> response.Text;\n        }\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span> Regex InvalidNameCharsRegex = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> Regex(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">[^0-9A-Za-z]+</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, RegexOptions.Compiled);\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> staticstringSanitize(<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> name)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> InvalidNameCharsRegex.Replace(name, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">_</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    }\n}</span></pre>\n</div>\n<p>其中的CreateFunctionTools方法实现了将A2A Agent的所有公开技能转换为AIFunction工具。</p>\n<p><span>而Sanitize方法则实现了函数名称的规范化，因为AIFunction的名称必须符合一定规范（仅限字母、数字和下划线），因此需要主动对技能名称进行规范化。</span></p>\n<h1><strong><strong><span><span>3 完整集成示例</span></span></strong></strong></h1>\n<p><span>这次我们还是使用上次文章中的案例，即一个旅游助手，它可以通过A2A协议调用多个Agent的技能。</span></p>\n<p><img alt=\"image\" height=\"550\" src=\"https://img2024.cnblogs.com/blog/381412/202602/381412-20260204220618986-812169228.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"912\" /></p>\n<p><span><span>我们需要创建四个.NET项目，其中：</span></span></p>\n<ul class=\"list-paddingleft-1\">\n<li>\n<p><span><span>1个.NET控制台项目：主助手</span></span></p>\n</li>\n<li>\n<p><span><span>3个ASP.NET Web项目：天气智能体、酒店智能体、路线智能体</span></span></p>\n</li>\n</ul>\n<p><span>在VS中的项目结构如下：</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202602/381412-20260204220634044-600923620.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>本次案例我们希望实现主助手可以回答用户关于不同主题（景点，酒店，天气）的问题，它可以根据问题自主选择需要调用一个或多个Agent去获取必要的信息后进行整合优化后再回复用户。</p>\n<h3><span><span>3.1 天气Agent</span></span></h3>\n<p><span><span>添加NuGet包，后续A2A Agent项目都需要安装此包，不再赘述：</span></span></p>\n<div class=\"cnblogs_code\">\n<pre>A2A.AspNetCore</pre>\n</div>\n<p>创建一个 WeatherAgent类，定义其能力 和 AgentCard，这里我们需要公开一个AgentSkill即天气查询的能力：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> WeatherAgent\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> Attach(ITaskManager taskManager)\n    {\n        taskManager.OnMessageReceived </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> QueryWeatherAsync;\n        taskManager.OnAgentCardQuery </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> GetAgentCardAsync;\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> Task&lt;A2AResponse&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> QueryWeatherAsync(MessageSendParams messageSendParams, CancellationToken cancellationToken)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (cancellationToken.IsCancellationRequested)\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> Task.FromCanceled&lt;A2AResponse&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(cancellationToken);\n        }\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Process the message</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> messageText = messageSendParams.Message.Parts.OfType&lt;TextPart&gt;<span style=\"color: rgba(0, 0, 0, 1);\">().First().Text;\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Create and return an artifact</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> message = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentMessage()\n        {\n            Role </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> MessageRole.Agent,\n            MessageId </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> Guid.NewGuid().ToString(),\n            ContextId </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> messageSendParams.Message.ContextId,\n            Parts </span>= [<span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> TextPart() {\n                Text </span>= $<span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"\n</span>                    🌤️ **天气查询结果**<span style=\"color: rgba(0, 0, 0, 1);\">\n\n                    查询时间：{DateTime.Now:yyyy</span>-MM-<span style=\"color: rgba(0, 0, 0, 1);\">dd HH:mm}\n\n                    </span>**北京天气**\n                    - 今日：晴转多云，气温 -<span style=\"color: rgba(128, 0, 128, 1);\">2</span>°C ~ <span style=\"color: rgba(128, 0, 128, 1);\">8</span><span style=\"color: rgba(0, 0, 0, 1);\">°C\n                    </span>- 明日：多云，气温 <span style=\"color: rgba(128, 0, 128, 1);\">0</span>°C ~ <span style=\"color: rgba(128, 0, 128, 1);\">10</span><span style=\"color: rgba(0, 0, 0, 1);\">°C\n                    </span>- 后日：阴，气温 <span style=\"color: rgba(128, 0, 128, 1);\">2</span>°C ~ <span style=\"color: rgba(128, 0, 128, 1);\">9</span><span style=\"color: rgba(0, 0, 0, 1);\">°C\n\n                    </span>**上海天气**\n                    - 今日：多云，气温 <span style=\"color: rgba(128, 0, 128, 1);\">5</span>°C ~ <span style=\"color: rgba(128, 0, 128, 1);\">12</span><span style=\"color: rgba(0, 0, 0, 1);\">°C\n                    </span>- 明日：小雨，气温 <span style=\"color: rgba(128, 0, 128, 1);\">6</span>°C ~ <span style=\"color: rgba(128, 0, 128, 1);\">10</span><span style=\"color: rgba(0, 0, 0, 1);\">°C\n                    </span>- 后日：阴转晴，气温 <span style=\"color: rgba(128, 0, 128, 1);\">4</span>°C ~ <span style=\"color: rgba(128, 0, 128, 1);\">11</span><span style=\"color: rgba(0, 0, 0, 1);\">°C\n\n                    👔 穿衣建议：北京较冷，建议穿羽绒服；上海温和，建议穿夹克外套，带好雨具。\n                    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"\n</span><span style=\"color: rgba(0, 0, 0, 1);\">            }]\n        };\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> Task.FromResult&lt;A2AResponse&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(message);\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> Task&lt;AgentCard&gt; GetAgentCardAsync(<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> agentUrl, CancellationToken cancellationToken)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (cancellationToken.IsCancellationRequested)\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> Task.FromCanceled&lt;AgentCard&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(cancellationToken);\n        }\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> capabilities = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentCapabilities()\n        {\n            Streaming </span>= <span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            PushNotifications </span>= <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n        };\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> Task.FromResult(<span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentCard()\n        {\n            Name </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">weather agent</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            Description </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">weather information agent</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            Url </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> agentUrl,\n            Version </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">1.0.0</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            DefaultInputModes </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">text</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n            DefaultOutputModes </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">text</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n            Capabilities </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> capabilities,\n            Skills </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> [\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentSkill\n                {\n                    Id </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">weather-query</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                    Name </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">天气查询</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                    Description </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">查询指定城市的天气预报，包括温度、降水概率、穿衣建议等</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                    Tags </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">weather</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">forecast</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">climate</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n                    Examples </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">上海明天天气怎么样</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">成都这周的天气预报</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">杭州下雨吗</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n                    InputModes </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">text</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n                    OutputModes </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">text</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">]\n                }],\n        });\n    }\n}</span></pre>\n</div>\n<p>这里说明一下，这里为了方便是直接返回了一个固定的天气信息输出内容，但在实际应用中往往需要进行具体的<strong>业务逻辑处理</strong>&nbsp;或&nbsp;<strong>调用大模型</strong>进行处理。</p>\n<p>下面的几个Agent也是类似的情况，就不再赘述。<span>然后，在Program.cs中进行注册，完成端口映射：</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">using</span><span style=\"color: rgba(0, 0, 0, 1);\"> A2A;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">using</span><span style=\"color: rgba(0, 0, 0, 1);\"> A2A.AspNetCore;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">using</span><span style=\"color: rgba(0, 0, 0, 1);\"> WeatherAgentServer;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> builder =<span style=\"color: rgba(0, 0, 0, 1);\"> WebApplication.CreateBuilder(args);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> app =<span style=\"color: rgba(0, 0, 0, 1);\"> builder.Build();\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> taskManager = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> TaskManager();\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> agent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> WeatherAgent();\nagent.Attach(taskManager);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Add JSON-RPC endpoint for A2A</span>\napp.MapA2A(taskManager, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">/weather</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Add well-known agent card endpoint for A2A</span>\napp.MapWellKnownAgentCard(taskManager, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">/weather</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Add HTTP endpoint for A2A</span>\napp.MapHttpA2A(taskManager, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">/weather</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\napp.Run();</span></pre>\n</div>\n<h3><span><span>3.2 酒店Agent</span></span></h3>\n<p><span>创建一个HotelAgent类，定义其能力 和 AgentCard：</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> HotelAgent\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> Attach(ITaskManager taskManager)\n    {\n        taskManager.OnMessageReceived </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> QueryHotelsAsync;\n        taskManager.OnAgentCardQuery </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> GetAgentCardAsync;\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> Task&lt;A2AResponse&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> QueryHotelsAsync(MessageSendParams messageSendParams, CancellationToken cancellationToken)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (cancellationToken.IsCancellationRequested)\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> Task.FromCanceled&lt;A2AResponse&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(cancellationToken);\n        }\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Process the message</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> messageText = messageSendParams.Message.Parts.OfType&lt;TextPart&gt;<span style=\"color: rgba(0, 0, 0, 1);\">().First().Text;\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Create and return an artifact</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> message = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentMessage()\n        {\n            Role </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> MessageRole.Agent,\n            MessageId </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> Guid.NewGuid().ToString(),\n            ContextId </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> messageSendParams.Message.ContextId,\n            Parts </span>= [<span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> TextPart() {\n                Text </span>= $<span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"\n</span>                    🏨 **酒店推荐**<span style=\"color: rgba(0, 0, 0, 1);\">\n\n                    根据您的需求，为您推荐以下酒店：\n\n                    </span>**豪华型 ⭐⭐⭐⭐⭐**\n                    <span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">. 上海外滩华尔道夫酒店\n                       </span>-<span style=\"color: rgba(0, 0, 0, 1);\"> 📍 外滩核心位置，江景房\n                       </span>- 💰 ¥<span style=\"color: rgba(128, 0, 128, 1);\">2</span>,<span style=\"color: rgba(128, 0, 128, 1);\">500</span>/<span style=\"color: rgba(0, 0, 0, 1);\">晚起\n                       </span>- ⭐ 评分 <span style=\"color: rgba(128, 0, 128, 1);\">4.9</span>/<span style=\"color: rgba(128, 0, 128, 1);\">5.0</span>\n\n                    **舒适型 ⭐⭐⭐⭐**\n                    <span style=\"color: rgba(128, 0, 128, 1);\">2</span><span style=\"color: rgba(0, 0, 0, 1);\">. 上海静安香格里拉大酒店\n                       </span>-<span style=\"color: rgba(0, 0, 0, 1);\"> 📍 静安寺商圈，交通便利\n                       </span>- 💰 ¥<span style=\"color: rgba(128, 0, 128, 1);\">1</span>,<span style=\"color: rgba(128, 0, 128, 1);\">200</span>/<span style=\"color: rgba(0, 0, 0, 1);\">晚起\n                       </span>- ⭐ 评分 <span style=\"color: rgba(128, 0, 128, 1);\">4.7</span>/<span style=\"color: rgba(128, 0, 128, 1);\">5.0</span>\n\n                    **经济型 ⭐⭐⭐**\n                    <span style=\"color: rgba(128, 0, 128, 1);\">3</span><span style=\"color: rgba(0, 0, 0, 1);\">. 全季酒店（上海南京路店）\n                       </span>-<span style=\"color: rgba(0, 0, 0, 1);\"> 📍 南京路步行街旁\n                       </span>- 💰 ¥<span style=\"color: rgba(128, 0, 128, 1);\">380</span>/<span style=\"color: rgba(0, 0, 0, 1);\">晚起\n                       </span>- ⭐ 评分 <span style=\"color: rgba(128, 0, 128, 1);\">4.5</span>/<span style=\"color: rgba(128, 0, 128, 1);\">5.0</span><span style=\"color: rgba(0, 0, 0, 1);\">\n\n                    💡 提示：建议提前预订，周末和节假日价格可能上涨 </span><span style=\"color: rgba(128, 0, 128, 1);\">20</span>-<span style=\"color: rgba(128, 0, 128, 1);\">50</span>%<span style=\"color: rgba(0, 0, 0, 1);\">。\n                    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"\n</span><span style=\"color: rgba(0, 0, 0, 1);\">            }]\n        };\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> Task.FromResult&lt;A2AResponse&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(message);\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> Task&lt;AgentCard&gt; GetAgentCardAsync(<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> agentUrl, CancellationToken cancellationToken)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (cancellationToken.IsCancellationRequested)\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> Task.FromCanceled&lt;AgentCard&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(cancellationToken);\n        }\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> capabilities = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentCapabilities()\n        {\n            Streaming </span>= <span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            PushNotifications </span>= <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n        };\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> Task.FromResult(<span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentCard()\n        {\n            Name </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">hotel-a2a-agent</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            Description </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">hotel information agent</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            Url </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> agentUrl,\n            Version </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">1.0.0</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            DefaultInputModes </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">text</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n            DefaultOutputModes </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">text</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n            Capabilities </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> capabilities,\n            Skills </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> [\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentSkill\n                {\n                    Id </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">hotel-recommendation</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                    Name </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">酒店推荐</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                    Description </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">根据目的地和预算推荐合适的酒店，包括豪华型、舒适型、经济型</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                    Tags </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">hotel</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">accommodation</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">booking</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">travel</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n                    Examples </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">推荐上海的酒店</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">上海外滩附近有什么好酒店</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">预算500以内的北京酒店</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n                    InputModes </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">text</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n                    OutputModes </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">text</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">]\n                }\n                ],\n        });\n    }\n}</span></pre>\n</div>\n<p>同样，请参考天气Agent完成Program.cs中的注册。</p>\n<h3><span><span>3.3 景点Agent</span></span></h3>\n<p><span>创建一个PlanAgent类，定义其能力 和 AgentCard：</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> PlanAgent\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> Attach(ITaskManager taskManager)\n    {\n        taskManager.OnMessageReceived </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> QueryPlansAsync;\n        taskManager.OnAgentCardQuery </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> GetAgentCardAsync;\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> Task&lt;A2AResponse&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> QueryPlansAsync(MessageSendParams messageSendParams, CancellationToken cancellationToken)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (cancellationToken.IsCancellationRequested)\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> Task.FromCanceled&lt;A2AResponse&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(cancellationToken);\n        }\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Process the message</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> messageText = messageSendParams.Message.Parts.OfType&lt;TextPart&gt;<span style=\"color: rgba(0, 0, 0, 1);\">().First().Text;\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Create and return an artifact</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> message = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentMessage()\n        {\n            Role </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> MessageRole.Agent,\n            MessageId </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> Guid.NewGuid().ToString(),\n            ContextId </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> messageSendParams.Message.ContextId,\n            Parts </span>= [<span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> TextPart() {\n                Text </span>= $<span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"\n</span>                    🎡 **景点推荐**<span style=\"color: rgba(0, 0, 0, 1);\">\n\n                    为您推荐上海必游景点：\n\n                    </span>**历史文化类**\n                    <span style=\"color: rgba(128, 0, 128, 1);\">1</span>. 🏛️ 外滩 -<span style=\"color: rgba(0, 0, 0, 1);\"> 欣赏万国建筑博览群\n                    </span><span style=\"color: rgba(128, 0, 128, 1);\">2</span>. 🏯 豫园 -<span style=\"color: rgba(0, 0, 0, 1);\"> 江南古典园林代表\n                    </span><span style=\"color: rgba(128, 0, 128, 1);\">3</span>. 🕌 城隍庙 -<span style=\"color: rgba(0, 0, 0, 1);\"> 品尝地道上海小吃\n\n                    </span>**现代都市类**\n                    <span style=\"color: rgba(128, 0, 128, 1);\">4</span>. 🗼 东方明珠塔 -<span style=\"color: rgba(0, 0, 0, 1);\"> 上海地标，俯瞰浦江两岸\n                    </span><span style=\"color: rgba(128, 0, 128, 1);\">5</span>. 🌆 陆家嘴 -<span style=\"color: rgba(0, 0, 0, 1);\"> 金融中心，上海之巅\n                    </span><span style=\"color: rgba(128, 0, 128, 1);\">6</span>. 🛍️ 南京路步行街 -<span style=\"color: rgba(0, 0, 0, 1);\"> 购物天堂\n\n                    </span>**文艺休闲类**\n                    <span style=\"color: rgba(128, 0, 128, 1);\">7</span>. 🎨 田子坊 -<span style=\"color: rgba(0, 0, 0, 1);\"> 文艺小店聚集地\n                    </span><span style=\"color: rgba(128, 0, 128, 1);\">8</span>. 📚 武康路 -<span style=\"color: rgba(0, 0, 0, 1);\"> 梧桐树下的法式风情\n                    </span><span style=\"color: rgba(128, 0, 128, 1);\">9</span>. 🌳 世纪公园 -<span style=\"color: rgba(0, 0, 0, 1);\"> 城市绿肺，亲子游首选\n\n                    📅 建议游玩时间：</span><span style=\"color: rgba(128, 0, 128, 1);\">3</span>-<span style=\"color: rgba(128, 0, 128, 1);\">4</span><span style=\"color: rgba(0, 0, 0, 1);\"> 天可覆盖主要景点\n                    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"\n</span><span style=\"color: rgba(0, 0, 0, 1);\">            }]\n        };\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> Task.FromResult&lt;A2AResponse&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(message);\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> Task&lt;AgentCard&gt; GetAgentCardAsync(<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> agentUrl, CancellationToken cancellationToken)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (cancellationToken.IsCancellationRequested)\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> Task.FromCanceled&lt;AgentCard&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(cancellationToken);\n        }\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> capabilities = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentCapabilities()\n        {\n            Streaming </span>= <span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            PushNotifications </span>= <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n        };\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> Task.FromResult(<span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentCard()\n        {\n            Name </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">plan agent</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            Description </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">travel plan &amp; attraction agent</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            Url </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> agentUrl,\n            Version </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">1.0.0</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            DefaultInputModes </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">text</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n            DefaultOutputModes </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">text</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n            Capabilities </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> capabilities,\n            Skills </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> [\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentSkill\n                {\n                    Id </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">attraction-recommendation</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                    Name </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">景点推荐</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                    Description </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">推荐目的地的热门景点和游玩路线，包括历史文化、现代都市、文艺休闲等类型</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                    Tags </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">attraction</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">sightseeing</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">tourism</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">travel</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n                    Examples </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">上海有什么好玩的</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">北京必去的景点</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">杭州西湖怎么玩</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n                    InputModes </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">text</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n                    OutputModes </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">text</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">]\n                }\n                ],\n        });\n    }\n}</span></pre>\n</div>\n<p>同样，请参考天气Agent完成Program.cs中的注册。</p>\n<h3><span><span>3.4 主助手</span></span></h3>\n<p><span><span><span>这里我们暂且命名为TravelPlannerClient，在该项目中我们需要用到<span>MAF<span>，因此我们先安装一下相关NuGet包：</span></span></span></span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">Microsoft.Extensions.AI.OpenAI\nMicrosoft.Agents.AI.A2A\nMicrosoft.Agents.AI.Abstractions\nMicrosoft.Extensions.AI.Abstractions</span></pre>\n</div>\n<p>首先，创建一个ChatClient供主助手使用：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> chatClient = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> OpenAIClient(\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ApiKeyCredential(openAIProvider.ApiKey),\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> OpenAIClientOptions { Endpoint = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> Uri(openAIProvider.Endpoint) })\n    .GetChatClient(openAIProvider.ModelId)\n    .AsIChatClient();</span></pre>\n</div>\n<p>其次，将远程A2A Agents转换为AIFunction Tools：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> agentEndpoints = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\">[]\n{\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">https://localhost:7021/a2a</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> hotel agent </span>\n    <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">https://localhost:7011/a2a</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> weather agent</span>\n    <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">https://localhost:7031/a2a</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> plan agent</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">};\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Collecting all AI Tools</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> functionTools = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> List&lt;AIFunction&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n</span><span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> endpoint <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> agentEndpoints)\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> resolver = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> A2ACardResolver(<span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> Uri(endpoint));\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> card = <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> resolver.GetAgentCardAsync();\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> agent = card.AsAIAgent(); <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Convert A2A Agent to AIAgent instance</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">\n    functionTools.AddRange(AgentFunctionHelper.CreateFunctionTools(agent, card));\n}</span></pre>\n</div>\n<p>然后，创建一个可以调用A2A Agents的主Agent，这一步是核心所在：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> mainAgent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(\n    chatClient: chatClient,\n    instructions: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"\n</span><span style=\"color: rgba(0, 0, 0, 1);\">    你是一个智能旅行规划助手。你可以利用可用的工具来帮助用户完成任务。\n    当用户询问时，请使用合适的工具获取信息，然后回复用户。\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">,</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    tools: [.. functionTools]\n   );</span></pre>\n</div>\n<p>最后，我们可以做下测试：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 用户请求 - 测试不同的技能调用</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> userRequests = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\">[]\n{\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">查询一下上海的天气情况</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">推荐一下上海的酒店</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">帮我规划一下今日上海的一日游景点，并告诉我该如何穿衣服</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n};\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> userRequest <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> userRequests)\n{\n    Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">👤 用户请求: {userRequest}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 执行 Agent</span>\n    Console.WriteLine(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">⏱️ 主 Agent 处理中...</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> response = <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> mainAgent.RunAsync(userRequest);\n    Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">💬 回答:\\n{response.Text}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    Console.WriteLine();\n}</span></pre>\n</div>\n<p>现在，我们来看看测试结果：</p>\n<p><strong><strong><strong><span><span>case1：<span><span>查询一下上海的天气情况（<strong><strong><strong><span><span>简单任务</span></span></strong></strong></strong><span><span>）</span></span></span></span></span></span></strong></strong></strong></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202602/381412-20260204221026757-365275321.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>可以看到，主助手通过调用天气Agent获取天气信息完成了回答。</p>\n<p><span><span><strong><strong><span><span>case2：<span>推荐上海的酒店（简单任务）</span></span></span></strong></strong></span></span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202602/381412-20260204221108758-778672394.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>&nbsp;</p>\n<p><span>可以看到，主助手通过调用酒店Agent获取酒店信息完成了回答</span></p>\n<p><strong><strong><strong><strong><strong><span><span>case3：帮我规划一下今日上海的一日游景点，并告诉我该如何穿衣服<span><span>（复杂任务）</span></span></span></span></strong></strong></strong></strong></strong></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202602/381412-20260204221128267-114288133.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>可以看到，主助手调用了多个Agent（景点Agent 和 天气Agent）获取信息，还在此之上进行了整合优化，最后输出了完善的回复。</p>\n<h1>4 小结</h1>\n<p>本文介绍了MAF中集成A2A Agent的核心操作：将A2A Agent转换为AIFunction工具，然后由主Agent自主选择调用最终生成回答，希望本文的案例对你有所帮助。</p>\n<h1>示例源码</h1>\n<p>GitHub:&nbsp;<a href=\"https://github.com/EdisonTalk/MAFD\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/EdisonTalk/MAFD</a></p>\n<h1>参考资料</h1>\n<p><span><span>圣杰，《<a href=\"https://www.cnblogs.com/sheng-jie/p/19200934\" target=\"_blank\">.NET + AI 智能体开发进阶</a>》（推荐指数：★★★★★）</span></span></p>\n<p><span><span>Microsoft Learn，<span>《<a href=\"https://learn.microsoft.com/en-us/agent-framework/overview/agent-framework-overview?wt.mc_id=MVP_397012\" rel=\"noopener nofollow\" target=\"_blank\">Agent Framework Tutorials</a>》</span></span></span></p>\n<div><span><span>&nbsp;</span></span></div>\n<p style=\"text-align: center;\"><img alt=\"\" src=\"https://images.cnblogs.com/cnblogs_com/edisonchou/1647700/o_200902144330EdisonTalk-Footer.jpg\" /></p>\n<div id=\"Copyright\">\n<p>作者：<span style=\"text-decoration: underline;\">爱迪生</span></p>\n<p>出处：<a href=\"https://edisontalk.cnblogs.com\" target=\"_blank\" title=\"from\">https://edisontalk.cnblogs.com</a></p>\n<p>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。</p>\n</div>\n\n</div>\n<div id=\"MySignature\">\n    <div align=\"center\"><a href=\"https://weibo.com/u/2068032061?s=6uyXnP\" target=\"_blank\"><img border=\"0\" src=\"http://service.t.sina.com.cn/widget/qmd/2068032061/d643d182/10.png\" /></a></div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 22:17</span>&nbsp;\n<a href=\"https://www.cnblogs.com/edisontalk\">EdisonZhou</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}