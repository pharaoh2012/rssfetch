{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "P5607 [Ynoi2013] 无力回天 NOI2017 题解",
      "link": "https://www.cnblogs.com/WangNoNo/p/19423598",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/WangNoNo/p/19423598\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 23:05\">\n    <span>P5607 [Ynoi2013] 无力回天 NOI2017 题解</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>一道很好的题，如果做法不当（像我）可能需要一些卡常。</p>\n<h2 id=\"part-1-bitset-20tps\">Part 1. bitset 20tps</h2>\n<p>插入？并集？ <span class=\"math inline\">\\(1e5\\)</span> ？显然可以用 <span class=\"math inline\">\\(bitset\\)</span> 维护：</p>\n<ul>\n<li>每次修改把第 <span class=\"math inline\">\\(x\\)</span> 个 <span class=\"math inline\">\\(bitset\\)</span> 中的第 <span class=\"math inline\">\\(y\\)</span> 位修改成1</li>\n<li>每次查询将 <span class=\"math inline\">\\(x1\\)</span> 和 <span class=\"math inline\">\\(x2\\)</span> 两个 <span class=\"math inline\">\\(bitset\\)</span> 取或求1的个数即可</li>\n</ul>\n<p>这样可以轻松获得20tps。</p>\n<h3 id=\"code\">Code</h3>\n<pre><code class=\"language-cpp\">const int N = 1e5 + 5;\n\nint m;\nbitset&lt;N&gt; b[N];\nvoid solve(){\n\tcin &gt;&gt; m;\n\twhile(m--){\n\t\tll opt, x, y; cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y;\n\t\tif(opt == 1){\n\t\t\tb[x][y] = 1;\n\t\t}else{\n\t\t\tcout &lt;&lt; (b[x] | b[y]).count() &lt;&lt; \"\\n\";\n\t\t}\n\t}\n}\n</code></pre>\n<h2 id=\"part-2-哈希表-34tps\">Part 2. 哈希表 34tps</h2>\n<p>考虑其实只需要维护两两之间的答案，最多 <span class=\"math inline\">\\(m\\)</span> 组</p>\n<ul>\n<li>每次修改把所有修改过 <span class=\"math inline\">\\(y\\)</span> 的和当前的集合间的交集大小加1，并记录每个集合的大小</li>\n<li>每次查询将两个集合相加减去并集即可</li>\n</ul>\n<p>这样可以轻松获得34tps。（注：pb_ds哈希表使用方法在最后）</p>\n<h3 id=\"code-1\">Code</h3>\n<pre><code class=\"language-cpp\">const int N = 1e6 + 5;\n\nint m, maxn, siz[N];\ncc_hash_table&lt;int, int&gt; ans[N];\nvector&lt;int&gt; vc[N];\n\nvoid solve(){\n\tcin &gt;&gt; m;\n    for(int i = 1; i &lt;= m; i++){\n        int opt, x, y; cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y;\n        if(opt == 1){\n        \t++siz[x];\n        \tint x0, x1;\n            for(int num : vc[y]){\n            \tx0 = x, x1 = num;\n\t\t\t\tif(x0 &gt; x1) swap(x0, x1);\n\t\t\t\t++ans[x0][x1];\n\t\t\t}\n            vc[y].pb(x);\n        }\n        else{\n            if(x == y){\n            \tcout &lt;&lt; siz[x] &lt;&lt; \"\\n\";\n            \tcontinue;\n\t\t\t}\n            if(x &gt; y) swap(x, y);\n\t\t\tint ans1 = ans[x][y];\n\t\t\tcout &lt;&lt; siz[x] + siz[y] - ans1&lt;&lt; \"\\n\";\n        }\n    }\n}\n</code></pre>\n<h2 id=\"part-3-正解-100tps\">Part 3. 正解 100tps</h2>\n<p>我们思考，</p>\n<ul>\n<li><span class=\"math inline\">\\(bitset\\)</span> 的优势在于高效处理多次出现，缺点是空间开不下</li>\n<li>哈希表的优势在于空间小，缺点是多次出现时会TLE</li>\n</ul>\n<p>怎么办呢？考虑结合以上两种做法，对于多次出现交给 <span class=\"math inline\">\\(bitset\\)</span> 处理，其他数据由空间小的哈希表处理。</p>\n<p>具体的，考虑进行根号分治，设临界值为 <span class=\"math inline\">\\(B\\)</span> ，记 <span class=\"math inline\">\\(x\\)</span> 的出现次数为 <span class=\"math inline\">\\(cnt_x\\)</span> ，对于每个数 <span class=\"math inline\">\\(x\\)</span>：</p>\n<ul>\n<li>若 <span class=\"math inline\">\\(cnt_x&lt;B\\)</span> ，用哈希表处理</li>\n<li>若 <span class=\"math inline\">\\(cnt_x&gt;B\\)</span> ，用 <span class=\"math inline\">\\(bitset\\)</span> 处理</li>\n</ul>\n<p>考虑到 <span class=\"math inline\">\\(bitset\\)</span> 的复杂度，当 <span class=\"math inline\">\\(B=\\sqrt{m/w}\\)</span>时达到理论最优值</p>\n<p>直接写完你就会发现MLE，怎么办？只需要改成<s>出生</s>可可爱爱の指针就可以了！</p>\n<h3 id=\"code-2\">Code</h3>\n<pre><code class=\"language-cpp\">const int N = 1e6 + 5, B = 8192, B1 = N / B;\n\nint m, maxn, siz[N];\nstruct node{\n    int opt, x, y;\n} q[N];\nbitset&lt;B&gt; *b[N];\ncc_hash_table&lt;int, int&gt; *ans[N];\nvector&lt;int&gt; vc[N];\nint cnt[N], f[N], tot;\n\nvoid init(){\n\tcin &gt;&gt; m;\n    for(int i = 1; i &lt;= m; i++){\n        cin &gt;&gt; q[i].opt &gt;&gt; q[i].x &gt;&gt; q[i].y;\n        if(q[i].opt == 1) ++cnt[q[i].y];\n        else if(q[i].x &gt; q[i].y) swap(q[i].x, q[i].y);\n    }\n    for(int i = 1; i &lt;= m; i++) if(cnt[i] &gt; B1) f[i] = ++tot; maxn = tot;\n    for(int i = 1; i &lt;= m; i++) if(cnt[i] &lt;= B1) f[i] = ++tot;\n    for(int i = 1; i &lt;= m; i++) if(q[i].opt == 1) q[i].y = f[q[i].y];\n    for(int i = 1; i &lt;= m; i++) if(q[i].opt == 2){\n    \tif(!ans[q[i].x]) ans[q[i].x] = new cc_hash_table&lt;int, int&gt;();\n        (*ans[q[i].x])[q[i].y] = 0;\n\t}\n}\nvoid solve(){\n    for(int i = 1; i &lt;= m; i++){\n        if(q[i].opt == 1){\n        \t++siz[q[i].x];\n            if(q[i].y &lt;= maxn){\n            \tif(!b[q[i].x]) b[q[i].x] = new bitset&lt;B&gt;();\n            \t(*b[q[i].x])[q[i].y] = 1;\n\t\t\t}\n            else{\n            \tint x0, x1;\n            \tif(vc[q[i].y].size() != 0){\n\t                for(int num : vc[q[i].y]){\n\t                \tx0 = q[i].x, x1 = num;\n\t\t\t\t\t\tif(x0 &gt; x1) swap(x0, x1);\n\t\t\t\t\t\tif(!ans[x0]) continue;\n\t\t\t\t\t\tif(ans[x0] -&gt; find(x1) != ans[x0] -&gt; end()) ++(*ans[x0])[x1];\n\t                }\n\t\t\t\t}\n                vc[q[i].y].pb(q[i].x);\n            }\n        }else{\n            if(q[i].x == q[i].y){\n            \tcout &lt;&lt; siz[q[i].x] &lt;&lt; \"\\n\";\n            \tcontinue;\n\t\t\t}\n\t\t\tint ans1 = (*ans[q[i].x])[q[i].y], ans2 = 0;\n\t\t\tif(b[q[i].x] &amp;&amp; b[q[i].y]) ans2 = (*b[q[i].x] &amp; *b[q[i].y]).count();\n\t\t\tcout &lt;&lt; siz[q[i].x] + siz[q[i].y] - ans1 - ans2 &lt;&lt; \"\\n\";\n        }\n    }\n}\n</code></pre>\n<h2 id=\"part-4-补充\">Part 4. 补充</h2>\n<p>pb_ds使用须知：</p>\n<p>请使用以下头文件</p>\n<pre><code class=\"language-cpp\">#include&lt;ext/pb_ds/assoc_container.hpp&gt;\n#include&lt;ext/pb_ds/priority_queue.hpp&gt;\n#include&lt;ext/pb_ds/exception.hpp&gt;\n#include&lt;ext/pb_ds/hash_policy.hpp&gt;\n#include&lt;ext/pb_ds/list_update_policy.hpp&gt;\n#include&lt;ext/pb_ds/tree_policy.hpp&gt;\n#include&lt;ext/pb_ds/trie_policy.hpp&gt;\nusing namespace __gnu_pbds;\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 23:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/WangNoNo\">WangNoNo</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Claude Skills MCP 技术解析",
      "link": "https://www.cnblogs.com/smartloli/p/19423547",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/smartloli/p/19423547\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 22:48\">\n    <span>Claude Skills MCP 技术解析</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1>1.概述</h1>\n<p>如果说大模型的推理能力决定了“它有多聪明”，那么 MCP 决定了它到底能不能在真实世界里把事做完。这篇文章不是简单介绍一个新名词，而是试图回答一个很多工程师心里都在问的问题：<strong>Claude 的 Skills 和 MCP，到底解决了什么？为什么它看起来比传统的 Tool / Function Calling 更“重”？</strong></p>\n<h1><strong>2.内容</strong></h1>\n<h2><strong>2.1&nbsp;从一个真实问题说起</strong></h2>\n<p>先说一个很常见的场景。你让一个大模型帮你做一件事：</p>\n<div class=\"cnblogs_code\">\n<pre>“帮我查一下这个用户的资料、最近 <span style=\"color: rgba(128, 0, 128, 1);\">30</span> 天的订单，然后给出运营建议。”</pre>\n</div>\n<p>如果你做过相关系统，第一反应一定是：</p>\n<ul>\n<li>要查用户表</li>\n<li>要查订单表</li>\n<li>要聚合数据</li>\n<li>要分析结果</li>\n</ul>\n<p>而传统 LLM 的做法往往是：</p>\n<ul>\n<li>用 Prompt 告诉模型“假装你查了数据库”</li>\n<li>或者用 Function Calling 勉强调用一两个接口</li>\n<li>或者在外部代码里硬写流程</li>\n</ul>\n<p>问题是，这些方式都存在明显短板：</p>\n<ul>\n<li>Prompt 是假能力</li>\n<li>Function Calling 是半自动</li>\n<li>外部流程是模型被动执行</li>\n</ul>\n<p>Claude 的 Skill + MCP，试图从底层解决这个问题。</p>\n<h2>2.2&nbsp;什么是 Claude Skills？先把误解说清楚</h2>\n<p>很多人第一次听到 Skill，会下意识理解为：</p>\n<div class=\"cnblogs_code\">\n<pre>“哦，就是 Tool。”</pre>\n</div>\n<p>但实际上 Claude Skills 和传统 Tool 并不是一个层级的东西。</p>\n<p><strong>1.直观理解一下</strong></p>\n<ul>\n<li>Tool：“这是一个函数，你可以调用。”</li>\n<li>Skills：“这是一个你被允许使用的能力边界，我已经帮你定义好了输入、输出和规则。”</li>\n</ul>\n<p><strong>2.Skill 更像什么？</strong></p>\n<ul>\n<li><strong>像一个系统 API + 类型系统 + 权限边界的组合体</strong></li>\n</ul>\n<p><strong>3.一个 Skill 至少包含什么？</strong></p>\n<p>一个完整的 Claude Skill，通常包含：</p>\n<ul>\n<li>能力名称（Name）</li>\n<li>能力描述（给模型看的）</li>\n<li>输入参数结构（JSON Schema）</li>\n<li>输出结果结构（JSON Schema）</li>\n<li>实际执行逻辑（运行在 Skill Server 中）</li>\n</ul>\n<p>也就是说，Skill 本身是“声明式”的，模型并不关心你是 Python、Java 还是 Rust 实现的。</p>\n<h2>2.3&nbsp;MCP（Model Context Protocol）到底是什么？</h2>\n<p>先给一个不那么官方的定义：</p>\n<div class=\"cnblogs_code\">\n<pre>MCP 是一套让大模型“安全、可控地使用外部能力，并把结果纳入推理过程”的协议。</pre>\n</div>\n<p>注意关键词不是“调用”，而是：</p>\n<ul>\n<li>安全</li>\n<li>可控</li>\n<li>纳入推理</li>\n</ul>\n<p>这三点，恰恰是很多 Tool 方案做不到的。</p>\n<p><strong>1.MCP 解决的核心不是“怎么调函数”</strong></p>\n<p>而是这几个问题：</p>\n<ul>\n<li>模型怎么知道有哪些能力可以用？</li>\n<li>模型怎么理解这些能力能干嘛？</li>\n<li>模型怎么保证参数不会乱传？</li>\n<li>执行结果怎么回到上下文继续推理？</li>\n<li>整个过程怎么被人类治理？</li>\n</ul>\n<p>MCP 是在解决“<strong>模型与现实系统之间的协议问题</strong>”。</p>\n<h2>2.4&nbsp;整体架构：Claude 是大脑，MCP 是神经系统</h2>\n<p>先看一张整体结构图：</p>\n<p><img alt=\"image\" height=\"826\" src=\"https://img2024.cnblogs.com/blog/666745/202512/666745-20251230222618784-1569725605.png\" width=\"1196\" /></p>\n<p>&nbsp;关键点在这里：</p>\n<ul>\n<li>Claude 不直接接触数据库</li>\n<li>Claude 不直接发 HTTP 请求</li>\n<li>Claude 只和 MCP “说话”</li>\n</ul>\n<p>&nbsp;这就像：<strong>大脑不会直接控制肌肉纤维，而是通过神经系统发信号。</strong></p>\n<h2><strong>2.5&nbsp;一次完整的 MCP 调用流程</strong></h2>\n<p>我们把一次完整调用拆开来看。</p>\n<h3><strong>1.场景</strong></h3>\n<p><strong>用户说：</strong></p>\n<div class=\"cnblogs_code\">\n<pre>“帮我查一下 test@example.com 这个用户的信息。”</pre>\n</div>\n<p><strong>1️⃣ Claude 先做什么？</strong></p>\n<p>Claude 首先做的是 语义判断：</p>\n<ul>\n<li>这是一个“查用户”的请求</li>\n<li>当前上下文里有没有能完成这件事的 Skill？</li>\n<li>如果 MCP Client 注册过类似：</li>\n</ul>\n<div class=\"cnblogs_code\">\n<pre>get_user_by_email</pre>\n</div>\n<p>Claude 就会继续。</p>\n<p><strong>2️⃣ Claude 生成 MCP 调用（结构化）</strong></p>\n<p>不是自然语言，而是类似这样的结构化请求：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">{\n  </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">tool</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">get_user_by_email</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n  </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">arguments</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">: {\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">email</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">test@example.com</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n  }\n}</span></pre>\n</div>\n<p>这一步非常重要：<strong>模型已经从“生成文本”切换成“生成结构化意图”。</strong></p>\n<p><strong>3️⃣ MCP Client 做校验</strong></p>\n<p>MCP Client 会检查：</p>\n<ul>\n<li>Skill 是否存在</li>\n<li>参数是否符合 Schema</li>\n<li>是否有权限调用</li>\n</ul>\n<p>不通过，直接拦截。</p>\n<p><strong>4️⃣ Skill Server 执行真实逻辑</strong></p>\n<p>比如：</p>\n<ul>\n<li>查数据库</li>\n<li>调内部 API</li>\n<li>读取文件</li>\n</ul>\n<p><strong>5️⃣ 返回结构化结果</strong></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">{\n  </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">id</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">u_123</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n  </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">name</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Alice</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n  </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">email</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">test@example.com</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n  </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">level</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">VIP</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n}</span></pre>\n</div>\n<p><strong>6️⃣ Claude 把结果“吃”回上下文</strong></p>\n<p>注意这里不是“展示给用户”，而是：<strong>作为新上下文继续推理</strong>。Claude 可能会接着分析、对比、总结，最后才生成自然语言回复。</p>\n<h2>2.6&nbsp;一个最小可运行的 MCP Skill 示例</h2>\n<p>下面这个示例非常简单，但已经具备 MCP 的完整形态。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">from mcp.server import Server\n\nserver </span>= Server(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">user_service</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n\n@server.tool()\ndef get_user_by_email(email: str) </span>-&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> dict:\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"\n</span><span style=\"color: rgba(0, 0, 0, 1);\">    Query user information by email\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"\n</span>    <span style=\"color: rgba(0, 0, 255, 1);\">if</span> email == <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">test@example.com</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n        return {\n            </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">id</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">u_123</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">name</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Alice</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">email</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">: email,\n            </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">level</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">VIP</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n        }\n    return {}\n\nserver.run()</span></pre>\n</div>\n<p>你会发现：</p>\n<ul>\n<li>没有 prompt</li>\n<li>没有 AI 逻辑</li>\n<li>只是纯能力定义</li>\n</ul>\n<p>但 Claude 会自动理解：</p>\n<ul>\n<li>什么时候用它</li>\n<li>怎么用</li>\n<li>用完之后怎么继续思考</li>\n</ul>\n<h2>2.7&nbsp;为什么 MCP 对 Agent 特别重要？</h2>\n<p>如果你做过 Agent，一定踩过这些坑：</p>\n<ul>\n<li>流程写死</li>\n<li>状态难维护</li>\n<li>一步失败全盘崩</li>\n<li>能力越多越混乱</li>\n</ul>\n<p>MCP 的好处在于：</p>\n<ul>\n<li>Agent 不需要提前写死流程，模型可以动态规划。</li>\n</ul>\n<p><strong>一个典型 Agent 行为</strong>：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">用户需求：\n\n“帮我分析这个用户最近的消费情况，并给出建议。”</span></pre>\n</div>\n<p>Claude 可能会：</p>\n<ul>\n<li>调用 get_user_profile</li>\n<li>调用 search_orders</li>\n<li>汇总数据</li>\n<li>给出分析和建议</li>\n<li>你不需要写 if/else 流程。</li>\n</ul>\n<h2>2.8&nbsp;MCP 和 Function Calling 的本质区别</h2>\n<p>很多人会问：</p>\n<ul>\n<li>“这和 OpenAI 的 Function Calling 有什么区别？”</li>\n</ul>\n<p>简单说一句：</p>\n<ul>\n<li>Function Calling 是能力点，MCP 是能力体系。</li>\n</ul>\n<p><img alt=\"image\" height=\"751\" src=\"https://img2024.cnblogs.com/blog/666745/202512/666745-20251230224051152-69932232.png\" width=\"1378\" /></p>\n<h2>2.9&nbsp;在真实工程中如何用好 MCP？</h2>\n<p>一些经验之谈：</p>\n<p><strong>Skill 设计建议</strong></p>\n<ul>\n<li>一个 Skill 只做一件事</li>\n<li>输入输出一定要稳定</li>\n<li>不要返回自然语言</li>\n<li>错误也要结构化</li>\n</ul>\n<p><strong>不要做的事情</strong></p>\n<ul>\n<li>把业务逻辑写进 Prompt</li>\n<li>一个 Skill 干五六件事</li>\n<li>让模型自己拼 SQL</li>\n<li>让 Skill 返回“分析结论”</li>\n</ul>\n<h2>2.10&nbsp;我对 MCP 的一个判断</h2>\n<p>站在工程视角，我认为：</p>\n<ul>\n<li>MCP 是目前最接近“大模型操作系统接口”的设计之一。</li>\n</ul>\n<p>它做的不是让模型“更聪明”，而是让模型：</p>\n<ul>\n<li>更可靠</li>\n<li>更可控</li>\n<li>更像一个真正能落地的系统组件</li>\n</ul>\n<h1>3.总结</h1>\n<p>如果你只是做 Demo，MCP 可能显得有点“重”。</p>\n<p>但如果你在做的是：</p>\n<ul>\n<li>企业级 AI 助手</li>\n<li>AI 编程系统</li>\n<li>多 Agent 自动化平台</li>\n</ul>\n<p>那 MCP 不是“可选项”，而是迟早要走到的那一步。</p>\n<h1 class=\"ds-markdown-paragraph\">4.结束语</h1>\n<p>这篇博客就和大家分享到这里，如果大家在研究学习的过程当中有什么问题，可以加群进行讨论或发送邮件给我，我会尽我所能为您解答，与君共勉！</p>\n<p>另外，博主出新书了《<span style=\"color: rgba(255, 0, 0, 1);\"><strong><a href=\"https://item.jd.com/14421833.html\" rel=\"noopener nofollow\" target=\"_blank\"><span style=\"color: rgba(255, 0, 0, 1);\">Hadoop与Spark大数据全景解析</span></a></strong></span>》、同时已出版的《<strong><span style=\"color: rgba(0, 0, 255, 1);\"><a href=\"https://item.jd.com/14699434.html\" rel=\"noopener nofollow\" target=\"_blank\"><span style=\"color: rgba(0, 0, 255, 1);\">深入理解Hive</span></a></span></strong>》、《<span style=\"color: rgba(0, 0, 255, 1);\"><strong><a href=\"https://item.jd.com/12455361.html\" rel=\"noopener nofollow\" target=\"_blank\"><span style=\"color: rgba(0, 0, 255, 1);\">Kafka并不难学</span></a></strong></span>》和《<span style=\"color: rgba(0, 0, 255, 1);\"><strong><a href=\"https://item.jd.com/12371763.html\" rel=\"noopener nofollow\" target=\"_blank\"><span style=\"color: rgba(0, 0, 255, 1);\">Hadoop大数据挖掘从入门到进阶实战</span></a></strong></span>》也可以和新书配套使用，喜欢的朋友或同学， 可以<span style=\"color: rgba(255, 0, 0, 1);\"><strong>在公告栏那里点击购买链接购买博主的书</strong></span>进行学习，在此感谢大家的支持。关注下面公众号，根据提示，可免费获取书籍的教学视频。</p>\n</div>\n<div id=\"MySignature\">\n    <div>\n<b class=\"b1\"></b><b class=\"b2 d1\"></b><b class=\"b3 d1\"></b><b class=\"b4 d1\"></b>\n<div class=\"b d1 k\">  \n联系方式：\n<br />\n邮箱：smartloli.org@gmail.com\n<br />\n<strong style=\"color: green;\">QQ群（Hive与AI实战【新群】）：935396818</strong>\n<br />\nQQ群（Hadoop - 交流社区1）：424769183\n<br />\nQQ群（Kafka并不难学）：825943084\n<br />\n温馨提示：请大家加群的时候写上加群理由（姓名＋公司/学校），方便管理员审核，谢谢！\n<br />\n<h3>热爱生活，享受编程，与君共勉！</h3>  \n</div>\n<b class=\"b4b d1\"></b><b class=\"b3b d1\"></b><b class=\"b2b d1\"></b><b class=\"b1b\"></b>\n</div>\n<br />\n<div>\n<b class=\"b1\"></b><b class=\"b2 d1\"></b><b class=\"b3 d1\"></b><b class=\"b4 d1\"></b>\n<div class=\"b d1 k\">\n<h3>公众号：</h3>\n<h3><img src=\"https://www.cnblogs.com/images/cnblogs_com/smartloli/1324636/t_qr.png\" style=\"width: 8%; margin-left: 10px;\" /></h3>\n</div>\n<b class=\"b4b d1\"></b><b class=\"b3b d1\"></b><b class=\"b2b d1\"></b><b class=\"b1b\"></b>\n</div>\n<br />\n<div>\n<b class=\"b1\"></b><b class=\"b2 d1\"></b><b class=\"b3 d1\"></b><b class=\"b4 d1\"></b>\n<div class=\"b d1 k\">\n<h3>作者：哥不是小萝莉 ［<a href=\"http://www.kafka-eagle.org/\" style=\"color: green;\" target=\"_blank\">关于我</a>］［<a href=\"http://www.cnblogs.com/smartloli/p/4241701.html\" style=\"color: green;\" target=\"_blank\">犒赏</a>］</h3>\n<h3>出处：<a href=\"http://www.cnblogs.com/smartloli/\" style=\"color: green;\" target=\"_blank\">http://www.cnblogs.com/smartloli/</a></h3>\n<h3>转载请注明出处，谢谢合作！</h3>\n</div>\n<b class=\"b4b d1\"></b><b class=\"b3b d1\"></b><b class=\"b2b d1\"></b><b class=\"b1b\"></b>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 22:48</span>&nbsp;\n<a href=\"https://www.cnblogs.com/smartloli\">哥不是小萝莉</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "规划中主要使用的地图类型",
      "link": "https://www.cnblogs.com/zylyehuo/p/19419173",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zylyehuo/p/19419173\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 20:07\">\n    <span>规划中主要使用的地图类型</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>博客地址：<a href=\"https://www.cnblogs.com/zylyehuo/\" target=\"_blank\">https://www.cnblogs.com/zylyehuo/</a></p>\n</blockquote>\n<h1 id=\"occupancy-grid-map\">Occupancy Grid Map</h1>\n<blockquote>\n<p>【占据栅格地图】</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1GzwderECF/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4acdb875c05ce9dccfce3cd6cfaac651\" rel=\"noopener nofollow\" target=\"_blank\">移动机器人运动规划-第一章(运动规划介绍与地图构建)-第三节(地图构建方法-Occupancy Grid Map)</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV14C4y1r7Jd/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4acdb875c05ce9dccfce3cd6cfaac651\" rel=\"noopener nofollow\" target=\"_blank\">自动驾驶中的Occupancy Grid占用栅格算法</a></p>\n</blockquote>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230091555060-1199064499.png\" /></p>\n<ul>\n<li>基于贝叶斯公式</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230092048607-315558262.png\" /></p>\n<ul>\n<li>基于马尔科夫假设（当前的概率与之前的概率是独立的）</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230092203011-2028367547.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230092225738-123828824.png\" /></p>\n<ul>\n<li>发现存在相同项</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230092347064-1157737378.png\" /></p>\n<ul>\n<li>将两个概率进行相除，约去相同项</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230092755566-498805078.png\" /></p>\n<ul>\n<li>利用 log 函数，分离出先验状态</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230093031164-242106556.png\" /></p>\n<ul>\n<li>还剩下“逆传感器模型”部分【不直观】</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230093249678-366631429.png\" /></p>\n<ul>\n<li>再利用贝叶斯公式，将“逆传感器模型”转换为“传感器模型”【基于当前栅格地图的状态，得到的这一次观测值应该是0还是1的概率】，发现又出现相同项</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230093716424-1872441123.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230093825914-1423272760.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230094001016-1041041406.png\" /></p>\n<ul>\n<li>假设“传感器模型”是个定值【基于观测的更新方式】</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230094259734-1484359303.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230094533636-1069601382.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230094914148-745996427.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230095200901-845289928.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230095233736-1331029782.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230095347220-253112120.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230095358663-165236316.png\" /></p>\n<ul>\n<li>利用滚动的 Occupancy Grid Map，解决“大地图”问题</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230095538388-1548681780.png\" /></p>\n<h1 id=\"tsdf\">TSDF</h1>\n<blockquote>\n<p>(Truncated Signed Distance Field)【截断符号距离场】</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/personalrobotics/OpenChisel\" rel=\"noopener nofollow\" target=\"_blank\">An open-source version of the Chisel chunked TSDF library.</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1Xi4y1471W/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4acdb875c05ce9dccfce3cd6cfaac651\" rel=\"noopener nofollow\" target=\"_blank\">运动规划之 TSDF map</a></p>\n</blockquote>\n<ul>\n<li>障碍物外面的值为正值，障碍物外面的值为负值</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230151947608-384612791.png\" /></p>\n<h1 id=\"esdf\">ESDF</h1>\n<blockquote>\n<p>(Euclidean Signed Distance Field)【欧几里得符号距离场】</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1Hnwde9EFc?spm_id_from=333.788.player.switch&amp;vd_source=4acdb875c05ce9dccfce3cd6cfaac651&amp;trackid=web_related_0.router-related-2206419-gx8f2.1767056746104.238\" rel=\"noopener nofollow\" target=\"_blank\">移动机器人运动规划-第一章(运动规划介绍与地图构建)-第三节(地图构建方法-ESDF)</a></p>\n</blockquote>\n<ul>\n<li>“一层”的是 ESDF，上面的小栅格是 Occupancy Grid Map</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230095632105-2084501764.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230100013176-744146623.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230100121591-1498147498.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230100151782-1360282382.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230101513785-573529793.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230135055798-1520530407.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230135316095-806542410.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230135735490-663923292.png\" /></p>\n<ul>\n<li>仅针对一维的伪代码</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230135828974-1891255415.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230140300707-708995518.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230140520538-65060715.png\" /></p>\n<ul>\n<li>对于二维的情况，就是固定 x，根据不同的 y 求解到达障碍物的最小距离</li>\n<li>以第一列为例</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230140734954-316583447.png\" /></p>\n<ul>\n<li>以第二列为例（没有障碍物的情况，则每个位置的值都为 ∞）</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230141116066-773952293.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230141241727-845739716.png\" /></p>\n<ul>\n<li>接着固定 y，根据不同的 x 求解到达障碍物的最小距离</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230141744667-376666185.png\" /></p>\n<ul>\n<li>以下面三行为例</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230141817043-1907659702.png\" /></p>\n<ul>\n<li>对于第一个格子，x=1，选取【这个格子到别的格子的距离 + 别的格子里面的“值”】最小的结果</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230142536264-839975597.png\" /></p>\n<ul>\n<li>对于第二个格子，x=2</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230142732894-2092955561.png\" /></p>\n<ul>\n<li>利用两次“一维”的求解，获得二维的结果【三维类似】</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230142837572-2122723745.png\" /></p>\n<ul>\n<li>障碍物里面存放的值的意义：到最近的 free 的栅格的距离，同时这个值放的是负值</li>\n<li>先将障碍物和 free 栅格进行翻转，然后进行计算</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230143237644-1636509800.png\" /></p>\n<ul>\n<li>将计算后的值添加上负号</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230143311745-18788185.png\" /></p>\n<ul>\n<li>再和原来的场进行叠加</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230143344921-1946627573.png\" /></p>\n<ul>\n<li>先沿着 z 轴算，再沿着 y 轴算，最后沿着 x 轴算</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230143458985-408992367.png\" /></p>\n<ul>\n<li>进行翻转操作【反向 ESDF】，计算障碍物内部的值【先沿着 z 轴算，再沿着 y 轴算，最后沿着 x 轴算】</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230143811950-1709618967.png\" /></p>\n<ul>\n<li>最后进行叠加</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230143910379-1892087086.png\" /></p>\n<ul>\n<li>对于当前位置不在栅格中心的情况，利用插值进行解决</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230144224352-5167244.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230144333713-2132197098.png\" /></p>\n<ul>\n<li>ESDF 地图梯度的计算</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230144605924-1620303920.png\" /></p>\n<h1 id=\"gaussian-map\">Gaussian Map</h1>\n<h2 id=\"3dgs\">3DGS</h2>\n<blockquote>\n<p>(3D Gaussian Splatting)【3D 高斯溅射地图 / 前沿视觉地图】</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/7833648056\" rel=\"noopener nofollow\" target=\"_blank\">3D Gaussian Splatting算法及其实现细节</a></p>\n</blockquote>\n<blockquote>\n<p>论文：<a href=\"https://arxiv.org/pdf/2308.04079\" rel=\"noopener nofollow\" target=\"_blank\">3D Gaussian Splatting for Real-Time Radiance Field Rendering</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/graphdeco-inria/gaussian-splatting\" rel=\"noopener nofollow\" target=\"_blank\">代码</a></p>\n</blockquote>\n<h2 id=\"gp-map\">GP Map</h2>\n<blockquote>\n<p>(Gaussian Process Map)【高斯过程地图 / 概率连续地图】</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/2751630763\" rel=\"noopener nofollow\" target=\"_blank\">什么是高斯过程（Gaussian Processes, GP）</a></p>\n</blockquote>\n<blockquote>\n<p>论文：<a href=\"https://fabioramos.github.io/Publications_files/Simon_ISER2014.pdf\" rel=\"noopener nofollow\" target=\"_blank\">Gaussian process occupancy maps for dynamic environments</a></p>\n</blockquote>\n<h2 id=\"gmm\">GMM</h2>\n<blockquote>\n<p>(Gaussian Mixture Models)【高斯混合模型地图】</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/151671154\" rel=\"noopener nofollow\" target=\"_blank\">如何通俗的理解高斯混合模型（Gaussian Mixture Models））</a></p>\n</blockquote>\n<blockquote>\n<p>论文：<a href=\"https://zhuanlan.zhihu.com/p/151671154\" rel=\"noopener nofollow\" target=\"_blank\">Gaussian Mixture Models</a></p>\n</blockquote>\n<h1 id=\"nerf\">NeRF</h1>\n<blockquote>\n<p>(Neural Radiance Fields)【神经辐射场】</p>\n</blockquote>\n<blockquote>\n<p>论文：<a href=\"https://arxiv.org/pdf/2003.08934\" rel=\"noopener nofollow\" target=\"_blank\">Representing Scenes as Neural Radiance Fields for View Synthesis</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/bmild/nerf\" rel=\"noopener nofollow\" target=\"_blank\">代码</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.matthewtancik.com/nerf\" rel=\"noopener nofollow\" target=\"_blank\">官网</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/jiaoyangwm/article/details/133804918\" rel=\"noopener nofollow\" target=\"_blank\">NeRF 首篇经典论文介绍（ECCV2020）</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1CC411V7oq/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4acdb875c05ce9dccfce3cd6cfaac651\" rel=\"noopener nofollow\" target=\"_blank\">【较真系列】讲人话-NeRF全解（原理+代码+公式）</a></p>\n</blockquote>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230152646680-808967645.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230153232330-8093872.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230153304058-1966233738.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230153458012-810246374.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230153627018-1090646223.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230153701724-2140345591.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230153801636-51891141.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230153921564-421511957.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230154119566-421233492.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230154404671-1853328831.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230154452220-1182229856.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230154836620-1158102823.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230155102446-1293304585.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230155330237-169551366.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230155631408-2064100778.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230155728157-250263865.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230155820644-869689816.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230160626120-96920975.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230160754127-1769142361.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230160851194-233434887.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230160937600-1841363.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230161047152-122034867.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230161318891-1616916806.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230161437134-1545984944.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230161723359-1462419215.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230161925557-1973428927.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230174118921-38385255.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230174243818-575765853.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175016337-1136716337.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175052111-1485817129.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175157993-2141132230.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175345585-750664154.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175425714-1466271787.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175528313-2072746571.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175732929-1433112194.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175830148-1190162908.png\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 20:07</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zylyehuo\">zylyehuo</a>&nbsp;\n阅读(<span id=\"post_view_count\">2</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "代码考古学：如何让你的代码不再是“未解之谜”？",
      "link": "https://www.cnblogs.com/huizhudev/p/19422839",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/huizhudev/p/19422839\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 18:29\">\n    <span>代码考古学：如何让你的代码不再是“未解之谜”？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"代码考古学：如何让你的代码不再是“未解之谜”？\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3695776/202512/3695776-20251230182757218-218563489.png\" />\n        好的代码不只需要逻辑，更需要解释。本文挑战“代码即文档”的迷思，介绍如何利用AI指令充当“代码考古学家”，将晦涩的逻辑转化为清晰的“罗塞塔石碑”式文档，消除团队知识债务，提升项目的可维护性与专业度。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>你有没有经历过这种<strong>“灵魂出窍”</strong>的时刻：</p>\n<p>盯着一段三个月前自己亲手写的代码，感觉像是在看外星文明留下的天书。逻辑极其精妙，变量名简写得极其潇洒，但你就是死活想不起来——<strong>这玩意儿到底是用来干嘛的？</strong></p>\n<p>如果说写代码是构建一座宏伟的宫殿，那么写注释就是给这座宫殿绘制“导游图”。遗憾的是，在赶进度的修罗场里，我们往往只顾着添砖加瓦，却忘了留下任何文字线索。</p>\n<p>最终，项目变成了一座<strong>“数字迷宫”</strong>。新来的同事在里面晕头转向，接手的维护者在里面步步惊心，就连始作俑者你自己，过段时间回来也是一脸茫然。</p>\n<p><img alt=\"代码考古学：如何让你的代码不再是“未解之谜”？\" class=\"lazyload\" /></p>\n<h2 id=\"-打破代码即文档的迷思\">🏺 打破“代码即文档”的迷思</h2>\n<p>在程序员圈子里，流传着一个迷人的谎言：<em>“好的代码是自解释的（Self-documenting），不需要注释。”</em></p>\n<p>这句话只对了一半。<br />\n对于 <code>getUserName()</code> 这种显而易见的代码，注释确实是噪音。<br />\n但对于那些<strong>反直觉的业务逻辑、为了性能的Hack写法、以及复杂的算法实现</strong>，代码本身只能告诉你“它做了什么”，却永远无法告诉你“<strong>为什么要这么做</strong>”。</p>\n<p>缺失的注释，就是团队的<strong>“知识债务”</strong>。债务是有利息的，而利息的支付方式，就是无休止的 Bug 排查和高昂的沟通成本。</p>\n<h2 id=\"-ai你的罗塞塔石碑雕刻师\">🧩 AI：你的“罗塞塔石碑”雕刻师</h2>\n<p>如果是以前，我会劝你：“兄弟，咬咬牙，把文档补上吧。”<br />\n但现在，作为一名追求极致效率的工程师，我会说：<strong>“这种要把逻辑翻译成人类语言的活儿，为什么不交给最擅长处理自然语言的 AI 呢？”</strong></p>\n<p>我为你准备了一套<strong>「代码注释生成 AI 指令」</strong>。<br />\n它不是简单的“翻译机”，而是一位<strong>“代码考古学家”</strong>。它能深入分析你的代码逻辑，推断设计意图，并用最规范的格式，为你刻下清晰的“罗塞塔石碑”。</p>\n<h3 id=\"️-复制这个指令重塑代码可读性\">🛠️ 复制这个指令，重塑代码可读性</h3>\n<p>这套指令的精髓在于<strong>“分层解析”</strong>。它会根据你指定的规范（JSDoc/Javadoc等），自动区分<strong>接口契约</strong>（参数/返回值）和<strong>实现细节</strong>（行内逻辑），确保注释既不冗余，也不缺失。</p>\n<pre><code class=\"language-markdown\"># 角色定义\n你是一位资深代码文档工程师，拥有10年以上软件开发经验，精通多种编程语言的文档规范（如JSDoc、Javadoc、Python Docstring、XML Doc等）。你擅长分析代码逻辑、理解设计意图，并能用简洁清晰的语言编写高质量的代码注释。\n\n# 任务描述\n请为以下代码生成专业、规范的注释，确保注释能够帮助开发者快速理解代码功能、参数说明、返回值及使用场景。\n\n**输入信息**:\n- **编程语言**: [请指定：JavaScript/Python/Java/C#/Go/TypeScript/其他]\n- **注释规范**: [请指定：JSDoc/Javadoc/Python Docstring/XML Doc/自定义/自动识别]\n- **注释级别**: [请选择：函数级/类级/模块级/行内注释/全部]\n- **详细程度**: [请选择：简洁/标准/详细]\n\n**待注释代码**:\n```\n[在此粘贴你的代码]\n```\n\n# 输出要求\n\n## 1. 内容结构\n- **文件/模块头注释**: 描述文件用途、作者、创建日期\n- **类/接口注释**: 描述类的职责、设计目的、使用示例\n- **函数/方法注释**: 功能描述、参数说明、返回值、异常处理、使用示例\n- **关键逻辑注释**: 复杂算法或业务逻辑的行内说明\n\n## 2. 质量标准\n- **准确性**: 注释必须准确反映代码的实际功能，不能有歧义\n- **完整性**: 覆盖所有公共API、复杂逻辑和关键决策点\n- **简洁性**: 用最少的文字表达最完整的信息\n- **规范性**: 严格遵循指定的注释规范格式\n\n## 3. 格式要求\n- 遵循指定编程语言的注释语法\n- 保持一致的缩进和对齐\n- 使用规范的标签（如@param、@returns、@throws等）\n- 中英文之间添加空格，提升可读性\n\n## 4. 风格约束\n- **语言风格**: 技术专业但通俗易懂\n- **表达方式**: 第三人称客观叙述\n- **专业程度**: 面向开发者，假设读者具备基础编程知识\n\n# 质量检查清单\n\n在完成输出后，请自我检查:\n- [ ] 注释格式符合指定的文档规范\n- [ ] 函数的参数和返回值都已说明\n- [ ] 复杂逻辑处有行内注释解释\n- [ ] 没有拼写错误或语法问题\n- [ ] 注释与代码实际功能一致\n\n# 注意事项\n- 不要修改原有代码逻辑，只添加注释\n- 避免过度注释（如解释显而易见的代码）\n- 对于废弃的方法要标注 @deprecated 并说明替代方案\n- 敏感信息（如密码、密钥）不要在注释中出现\n\n# 输出格式\n请直接输出带有完整注释的代码，使用对应语言的代码块格式。如果有多个文件，请分别标注文件名。\n</code></pre>\n<h2 id=\"️-效果实测从天书到教科书\">⚡️ 效果实测：从“天书”到“教科书”</h2>\n<p>让我们来看一个真实的<strong>反直觉</strong>场景。<br />\n这是一段用于处理防抖（Debounce）的 JavaScript 代码。如果不看注释，你需要在大脑里模拟半天 Event Loop 才能看懂它是怎么工作的。</p>\n<p><strong>使用前（裸奔版）：</strong></p>\n<pre><code class=\"language-javascript\">function debounce(func, wait, immediate) {\n    let timeout;\n    return function() {\n        const context = this, args = arguments;\n        const later = function() {\n            timeout = null;\n            if (!immediate) func.apply(context, args);\n        };\n        const callNow = immediate &amp;&amp; !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(context, args);\n    };\n}\n</code></pre>\n<p><strong>使用指令后（教科书版）：</strong></p>\n<pre><code class=\"language-javascript\">/**\n * 创建一个防抖函数，在指定时间内多次调用只执行一次\n * \n * 防抖常用于处理频繁触发的事件，如窗口resize、输入框实时搜索等场景，\n * 可以有效减少不必要的函数调用，提升性能。\n * \n * @param {Function} func - 需要防抖处理的目标函数\n * @param {number} wait - 防抖延迟时间，单位毫秒\n * @param {boolean} [immediate=false] - 是否立即执行\n *   - true: 在延迟开始时立即执行，后续调用在延迟结束前被忽略\n *   - false: 在延迟结束后执行最后一次调用\n * @returns {Function} 经过防抖处理的新函数\n */\nfunction debounce(func, wait, immediate) {\n    // 用于存储定时器ID，实现延迟控制\n    let timeout;\n    \n    // 返回包装后的函数，保持原函数的 this 指向和参数\n    return function executedFunction() {\n        const context = this;\n        const args = arguments;\n        \n        // 延迟执行的回调函数\n        const later = function() {\n            timeout = null;\n            // 非立即执行模式下，在延迟结束后调用目标函数\n            if (!immediate) func.apply(context, args);\n        };\n        \n        // 判断是否需要立即执行：immediate 为 true 且当前没有等待中的定时器\n        const callNow = immediate &amp;&amp; !timeout;\n        \n        // 每次调用都重置定时器，实现\"重新计时\"效果\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        \n        // 立即执行模式下，首次调用直接执行\n        if (callNow) func.apply(context, args);\n    };\n}\n</code></pre>\n<p>注意到了吗？AI 不仅解释了参数，还解释了<strong>实现原理</strong>（如 \"保持原函数的 this 指向\"）。这不仅是文档，更是<strong>教学</strong>。</p>\n<h2 id=\"-工程师的第二大脑\">💡 工程师的第二大脑</h2>\n<p>使用这个 AI 指令，并不是为了让你偷懒，而是为了让你把宝贵的脑力从“解释代码”中解放出来，去专注于“设计代码”。</p>\n<p>试着把这个指令集成到你的工作流中：</p>\n<ol>\n<li><strong>接手遗留项目时</strong>：先用 AI 跑一遍核心模块，快速生成“地形图”。</li>\n<li><strong>提交 Code Review 前</strong>：用 AI 补全文档，让 Reviewer 少问几个“这是啥”。</li>\n<li><strong>编写开源库时</strong>：一键生成标准 JSDoc/Javadoc，让你的项目显得更专业。</li>\n</ol>\n<p>代码是写给机器执行的，但更是写给人看的。<br />\n<strong>别让你的代码，成为下一个需要解密的“未解之谜”。</strong></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 18:29</span>&nbsp;\n<a href=\"https://www.cnblogs.com/huizhudev\">realhuizhu</a>&nbsp;\n阅读(<span id=\"post_view_count\">4</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "海豚调度DolphinScheduler 和 Spring Cloud Data Flow 对比",
      "link": "https://www.cnblogs.com/kakarotto-chen/p/19421939",
      "published": "",
      "description": "<h2>\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/kakarotto-chen/p/19421939\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 16:22\">\n    <span>海豚调度DolphinScheduler 和 Spring Cloud Data Flow 对比</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"postbody\">\n            <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"spring-cloud-data-flow\">Spring Cloud Data Flow</h2>\n<p>Spring Cloud Data Flow是一个基于Spring Boot和Spring Cloud的开源框架，旨在简化云原生环境中数据流处理和批处理任务的开发、部署与管理。它提供了一种统一的编程和操作模型，用于编排可组合的数据微服务，支持在Cloud Foundry、Kubernetes等现代平台上运行.</p>\n<p>‌核心功能与架构：‌ Spring Cloud Data Flow的核心功能包括通过领域特定语言（DSL）或可视化界面定义数据流、管理数据管道的部署与监控，并支持实时数据处理、批处理任务、数据集成等场景。其架构基于微服务设计，主要包括数据流（Stream）和任务（Task）两大模块：数据流用于连续处理事件流（如日志分析、实时推荐），而任务则用于一次性批处理操作（如数据导入导出）。框架通过注册中心管理可复用的应用组件，并利用Spring Cloud Deployer在不同平台上自动化部署。‌</p>\n<h2 id=\"对比\">对比</h2>\n<ul>\n<li>原理上有相似性（都是调度框架），但DolphinScheduler是“任务级的调度”，Spring Cloud Data Flow是“应用级的编排”。</li>\n</ul>\n<h3 id=\"问题-spring-cloud-data-flow来调度seatunnel和dolphinscheduler调度seatunnel差不多\">问题： spring cloud data flow来调度seatunnel、和dolphinscheduler调度seatunnel差不多？</h3>\n<ul>\n<li>Spring Cloud Data Flow（SCDF）和 DolphinScheduler 都可以用来调度 SeaTunnel 任务，但它们在设计理念和实现方式上有一些关键区别：</li>\n</ul>\n<h4 id=\"1-设计理念与架构\">1. ‌设计理念与架构‌</h4>\n<p>Spring Cloud Data Flow‌：</p>\n<ul>\n<li>核心理念‌：SCDF 是一个数据流编排框架，专注于流式和批处理任务的定义、部署和管理。它通过 Spring Boot 和 Spring Cloud 提供统一的编程模型。</li>\n<li>架构‌：基于 Spring Cloud Deployer，支持多环境部署（如本地、Kubernetes、Cloud Foundry），通过 Skipper 实现应用版本管理和滚动更新。</li>\n<li>组件模型‌：SCDF 使用源（Source）、处理器（Processor）和接收器（Sink）的组件模型，通过 DSL（Domain Specific Language）或图形界面定义数据流。</li>\n</ul>\n<p>DolphinScheduler‌：</p>\n<ul>\n<li>核心理念‌：DolphinScheduler 是一个分布式任务调度平台，支持多种任务类型（如 Shell、Spark、Flink、DataX 等），强调任务编排和监控。</li>\n<li>架构‌：基于 Master-Worker 模型，通过 ZooKeeper 实现任务调度和资源管理。</li>\n<li>组件模型‌：DolphinScheduler 支持自定义任务插件，通过拖拽界面定义 DAG 工作流。</li>\n</ul>\n<h4 id=\"2-调度方式与灵活性\">2. ‌调度方式与灵活性‌</h4>\n<p>SCDF 调度 SeaTunnel‌：<br />\n方式‌：通过 SCDF 的 DSL 或图形界面定义 SeaTunnel 任务，SCDF 负责任务的部署和执行。<br />\n灵活性‌：支持多种计算引擎（如 Spark、Flink），但需要额外配置 SeaTunnel 的启动脚本和参数。<br />\nDolphinScheduler 调度 SeaTunnel‌：<br />\n方式‌：DolphinScheduler 3.1.5+ 版本内置 SeaTunnel 组件，通过任务节点直接配置 SeaTunnel 脚本。<br />\n灵活性‌：支持动态参数配置、任务级重试和失败处理机制。</p>\n<h4 id=\"3-适用场景与优势\">3. ‌适用场景与优势‌</h4>\n<p>SCDF 优势‌：<br />\n适合需要统一数据流管理和编排的场景，尤其是与 Spring 生态系统集成。<br />\n通过 Skipper 实现应用的版本管理和滚动更新。<br />\nDolphinScheduler 优势‌：<br />\n适合复杂任务编排和监控需求，支持丰富的任务类型和自定义插件。<br />\n提供秒级任务调度和故障恢复机制。</p>\n<h4 id=\"4-关键区别\">4. ‌关键区别‌</h4>\n<p>调度模型‌：SCDF 更侧重于数据流的定义和编排，DolphinScheduler 更侧重于任务的调度和监控。<br />\n组件集成‌：SCDF 需手动配置 SeaTunnel 启动脚本，DolphinScheduler 内置 SeaTunnel 组件简化配置。<br />\n总结</p>\n<p>两者都可以调度 SeaTunnel，但 SCDF 更适合数据流编排场景，DolphinScheduler 更适合复杂任务调度需求。选择时需根据具体业务需求和现有技术栈决定。</p>\n<h2 id=\"二-核心对比两种调度思路\">二、📊 <strong>核心对比：两种调度思路</strong></h2>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th><strong>DolphinScheduler</strong></th>\n<th><strong>Spring Cloud Data Flow (SCDF)</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>定位</strong></td>\n<td><strong>任务调度与工作流编排平台</strong></td>\n<td><strong>云原生流批数据处理平台</strong></td>\n</tr>\n<tr>\n<td><strong>设计理念</strong></td>\n<td>“任务的调度器”</td>\n<td>“数据管道的Kubernetes”</td>\n</tr>\n<tr>\n<td><strong>调度单位</strong></td>\n<td>任务/工作流（Task/DAG）</td>\n<td>数据流/批处理管道（Stream/Batch）</td>\n</tr>\n<tr>\n<td><strong>资源管理</strong></td>\n<td>Worker节点、租户、队列</td>\n<td>云平台（K8s、Cloud Foundry）</td>\n</tr>\n<tr>\n<td><strong>主要界面</strong></td>\n<td>完整的Web UI操作界面</td>\n<td>CLI + Dashboard（UI较简单）</td>\n</tr>\n<tr>\n<td><strong>部署复杂度</strong></td>\n<td>中等（需要DB、Zookeeper）</td>\n<td>高（依赖Spring Cloud生态）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"三-技术实现对比\">三、🔧 <strong>技术实现对比</strong></h2>\n<h3 id=\"1-dolphinscheduler调度seatunnel\"><strong>1. DolphinScheduler调度SeaTunnel</strong></h3>\n<pre><code class=\"language-yaml\"># 你的当前方案：明确、直接的任务调度\nDS工作流任务 → Shell任务 → 执行 seatunnel.sh\n\n# 特点：\n# 1. 像crontab增强版\n# 2. 手动配置每个任务的细节\n# 3. 直接控制执行服务器和用户\n</code></pre>\n<h3 id=\"2-spring-cloud-data-flow调度seatunnel\"><strong>2. Spring Cloud Data Flow调度SeaTunnel</strong></h3>\n<pre><code class=\"language-yaml\"># SCDF方案：声明式的数据管道\nSCDF Stream定义: source -&gt; seatunnel-processor -&gt; sink\n\n# 特点：\n# 1. 把SeaTunnel包装成Spring Cloud Stream应用\n# 2. 通过SCDF部署和管理应用生命周期\n# 3. 自动处理消息传递、扩缩容\n</code></pre>\n<h2 id=\"四-适用场景对比\">四、🎯 <strong>适用场景对比</strong></h2>\n<h3 id=\"dolphinscheduler更适合\"><strong>DolphinScheduler更适合：</strong></h3>\n<pre><code class=\"language-yaml\"># 传统ETL调度场景\n- 定时数据同步任务（每天凌晨1点跑）\n- 复杂依赖的工作流（A表跑完再跑B）\n- 需要人工介入（失败报警、手动重跑）\n- 多租户、资源隔离需求\n- 已有服务器（非K8s）环境\n\n# 典型工作流\n┌─────────┐    ┌──────────┐    ┌─────────┐\n│ 采集日志 │ →  │ SeaTunnel │ → │  入仓   │\n└─────────┘    └──────────┘    └─────────┘\n       │              │              │\n   每天1点      依赖采集完成    依赖ETL完成\n</code></pre>\n<h3 id=\"spring-cloud-data-flow更适合\"><strong>Spring Cloud Data Flow更适合：</strong></h3>\n<pre><code class=\"language-yaml\"># 云原生实时/微批场景\n- 持续运行的数据管道（7x24小时）\n- 微服务架构的数据处理\n- 需要自动扩缩容\n- 已使用Spring Cloud生态\n- K8s环境部署\n\n# 典型数据流\n┌─────────┐    ┌──────────────┐    ┌─────────┐\n│ Kafka   │ →  │ SeaTunnel    │ →  │  Redis  │\n│ 消息源  │    │ (实时清洗)   │    │  实时数  │\n└─────────┘    └──────────────┘    └─────────┘\n    持续产生          持续处理          持续更新\n</code></pre>\n<h2 id=\"五-具体实现方式差异\">五、🚀 <strong>具体实现方式差异</strong></h2>\n<h3 id=\"dolphinscheduler方式你正在用的\"><strong>DolphinScheduler方式（你正在用的）</strong></h3>\n<pre><code class=\"language-bash\"># 1. 编写SeaTunnel配置文件 config.conf\n# 2. 在DS中创建Shell任务\n# 3. 任务内容：/opt/seatunnel/bin/start.sh -c config.conf\n# 4. 设置定时、依赖、告警\n</code></pre>\n<h3 id=\"spring-cloud-data-flow方式\"><strong>Spring Cloud Data Flow方式</strong></h3>\n<pre><code class=\"language-bash\"># 1. 将SeaTunnel包装为Spring Boot应用\n# 2. 注册到SCDF作为自定义处理器(processor)\n# 3. 通过DSL定义流\nstream create --name my-etl-pipeline \\\n  --definition \"http --port=9000 | seatunnel-processor | jdbc\"\n\n# 4. 部署流\nstream deploy --name my-etl-pipeline \\\n  --properties \"app.seatunnel-processor.seatunnel-config=file:///config.conf\"\n\n# 5. SCDF自动管理应用实例\n</code></pre>\n<h2 id=\"六️-重要注意事项\">六、⚠️ <strong>重要注意事项</strong></h2>\n<h3 id=\"scdf的挑战\"><strong>SCDF的挑战：</strong></h3>\n<ol>\n<li><strong>强绑定Spring生态</strong>：需要将SeaTunnel改造为Spring Cloud Stream应用</li>\n<li><strong>学习曲线陡峭</strong>：需了解Stream、Task、Skipper等概念</li>\n<li><strong>部署复杂</strong>：依赖消息中间件（RabbitMQ/Kafka）、服务发现等</li>\n<li><strong>资源消耗</strong>：每个任务都是独立JVM进程，内存开销大</li>\n</ol>\n<h3 id=\"dolphinscheduler的优势对你当前情况\"><strong>DolphinScheduler的优势（对你当前情况）：</strong></h3>\n<ol>\n<li><strong>独立轻量</strong>：不依赖特定技术栈</li>\n<li><strong>直观易用</strong>：有完整UI，学习成本低</li>\n<li><strong>你已熟悉</strong>：已搭建环境并跑通流程</li>\n<li><strong>社区活跃</strong>：中文文档和社区支持好</li>\n</ol>\n\n</div>\n<div class=\"clear\"></div>\n\n        </div>\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\">2025-12-30 16:22</span>&nbsp;\n<a href=\"https://www.cnblogs.com/kakarotto-chen\">C_C_菜园</a>&nbsp;\n阅读(<span id=\"post_view_count\">44</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n        </p>"
    },
    {
      "title": "基于SqlSugar开发框架的基础上快速开发H5端的移动应用",
      "link": "https://www.cnblogs.com/wuhuacong/p/19420561",
      "published": "",
      "description": "<h2>\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wuhuacong/p/19420561\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 15:07\">\n    <span>基于SqlSugar开发框架的基础上快速开发H5端的移动应用</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"postbody\">\n                <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        在开发一些项目的时候，我们往往会基于一定的框架进行业务的开发，并结合一些辅助工具进行更高效率的快速开发和整合工作，SqlSugar开发框架是我们开发的一个多端整合的开发框架，基于它的后端WebAPI 基础上，我们可以对接WInform端、Vue3+ElementPlus的BS端，Vue3+Vant4的H5端，以及WPF、或者小程序等多端接入，本篇随笔介绍一个简单的项目录入功能，介绍基于SqlSugar开发框架的基础上快速开发H5端的移动应用。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>在开发一些项目的时候，我们往往会基于一定的框架进行业务的开发，并结合一些辅助工具进行更高效率的快速开发和整合工作，SqlSugar开发框架是我们开发的一个多端整合的开发框架，基于它的后端框架的WebAPI 基础上，我们可以对接WInform端、Vue3+ElementPlus的BS端，Vue3+Vant4的H5端，以及WPF、或者小程序等多端接入，本篇随笔介绍一个简单的项目录入功能，介绍基于SqlSugar开发框架的基础上快速开发H5端的移动应用。</p>\n<h3>1、设计数据库</h3>\n<p>俗话说万层高楼从底起，开发应用项目，数据库的设计很重要，它可能是业务对象，业务流程的综合设计，好的数据库设计可以减少后期的重复返工，提高开发效率。</p>\n<p>一般表名称，根据不同的业务关系，我们可以使用不同的前缀进行区分，使用前缀，可以非常方便区分不同的业务表，如我自己一般基础表使用 “TB_” 定义前缀，权限系统表使用\"T_ACL_\"定义前缀，工作流表使用“TBAPP_”，业务表使用\"T_\"等，这样对于区分不同的业务，方便管理很有好处。</p>\n<p>字段名称方面，我们可以约定一些规则，如约定主键使用ID；一般来说，ID作为主键，可以使用自增长的整形字段，也可以使用GUID的字符型字段，如果为了方便兼容不同的数据库且方便迁移或者开发基于网络方面的应用，我建议还是使用GUID的字符型字段，使用这种类型的字段，我们从创建数据的时候，就可以知道这个记录的主键，对于我们维护父子表等关系非常有利。</p>\n<p>由于如果采用字符型的ID主键，那么我们如果需要正确排序的时候，可能需要增加一个CreateTime的日期类型，方便我们根据日期进行排序，或者特定的需要增加一个SortOrder字段。</p>\n<p>如果这个表还有一个外键的引用，建议统一命名标准，我一般使用“表名称_ID这样的名称，如User_ID、Contact_ID等相似的名称作为外键，不需要表的前缀。</p>\n<p>数据库的模型设计，我们建议在第三方的数据库设计工具上进行设计，如PowerDesigner这样的设计工具，使用工具设计数据库有很多好处，一个是可以高效率进行调整，二是根据需要生成不同的数据库类型Sql语句，三是可以全局了解各个表之间的关系等等。</p>\n<p>使用PowerDesigner这样的数据库设计工具，能够在很大程度上提高我们数据库的设计效率。我们默认以SQLServer数据库创建表，如下所示。</p>\n<p><img alt=\"image\" height=\"278\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230115810545-678368233.png\" width=\"323\" /></p>\n<p>设计好的数据表，在设计状态下，添加相关的备注信息。</p>\n<p><img alt=\"image\" height=\"467\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230115835170-756890014.png\" width=\"796\" /></p>\n<p>&nbsp;然后生成相关的SQL代码，我们就可以再具体的数据库管理工具上执行创建对应的表信息了。&nbsp;</p>\n<p><img alt=\"image\" height=\"466\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230115908156-1344039466.png\" width=\"794\" /></p>\n<p>&nbsp; 完成数据库表创建后，我们就完成了第一阶段的工作了。</p>\n<p>&nbsp;</p>\n<h3>2、生成SqlSugar开发框架的后端基础代码并整合</h3>\n<p>设计好数据库后，我们通过代码生成工具进行基于项目框架的代码生成，这样对于我们在开发新项目上有很好的好处，里面的项目层级、引用关系，已经处理好了，这样对我们非常方便。</p>\n<p>不过大多数情况下，我们都是增量开发较多，也就是我们可能前面已经完成了一些其他业务的开发，可能新增一个两个表，或者一批业务表的处理，我们生成相关的代码文件后把它们复制到项目恰当位置上即可。</p>\n<p>由于项目生成的时候，指定了主命名空间和相关的表前缀，这样我们生成后的代码就方便阅读很多，减少累赘和出错的机会。</p>\n<p>利用代码生成工具Database2Sharp强大的数据库元数据和模板引擎，我们构建了对应的框架代码生成规则，因此统一生成即可，提高了代码开发的效能，同时也统一了代码的结构，便于大项目的维护。</p>\n<p>对于SQLSugar的项目框架，我们为了方便，分别单独提供后端代码和Web API代码的生成、Winform界面代码的生成，以及前面介绍到的Vue3+TypeScript+ElementPlus的代码生成操作。</p>\n<p>代码生成工具的界面效果如下所示，通过入口菜单，可以实现不同部分的代码快速生成。我们先使用【Sqlsugar框架代码生成】生成后端的相关代码文件。</p>\n<p><img alt=\"image\" height=\"636\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230125345005-735899731.png\" width=\"1033\" /></p>\n<p>选择我们刚才创建的表进行一步步的生成即可。</p>\n<p><img alt=\"image\" height=\"406\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230142927634-577910459.png\" width=\"534\" /></p>\n<p>生成代码，我们可以看到相关的目录，如下所示。</p>\n<p><img alt=\"image\" height=\"591\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230143200345-246629280.png\" width=\"850\" /></p>\n<p>复制整合文件到框架项目的合适位置上，暂时不需要增加任何方法代码，我们利用继承的基类方法就完全满足需求 。</p>\n<p><img alt=\"image\" height=\"964\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230151121521-1088455216.png\" width=\"1017\" /></p>\n<p>&nbsp;</p>\n<h3>3、基于Vant4+Vue3+TypeScript的H5移动前端进行开发</h3>\n<div><strong>关于Vant4</strong></div>\n<div>\n<p>Vant 是一个<strong>轻量、可定制的移动端组件库</strong>，于 2017 年开源。目前 Vant 官方提供了&nbsp;<a href=\"https://vant-ui.github.io/vant/v2/\" rel=\"noopener nofollow\" target=\"_blank\">Vue 2 版本</a>、<a href=\"https://vant-ui.github.io/vant/\" rel=\"noopener nofollow\" target=\"_blank\">Vue 3 版本</a>和<a href=\"https://vant-ui.github.io/vant-weapp/\" rel=\"noopener nofollow\" target=\"_blank\">微信小程序版本</a>，并由社区团队维护&nbsp;<a href=\"https://github.com/3lang3/react-vant\" rel=\"noopener nofollow\" target=\"_blank\">React 版本</a>和<a href=\"https://github.com/ant-move/Vant-Aliapp\" rel=\"noopener nofollow\" target=\"_blank\">支付宝小程序版本</a>。</p>\n<p>当前移动端 项目采用最新的Vant4进行开发，适合于Vue3的项目开发。</p>\n<p>Vant 4 是一款基于 Vue 3 的轻量、可靠的手机端组件库，主要用于快速搭建移动端应用。它提供了许多常用的 UI 组件，如按钮、卡片、表单、导航等，旨在帮助开发者提高开发效率，同时保持应用的性能和一致性。</p>\n<p>Vant 4 是完全基于 Vue 3 构建的，充分利用了 Vue 3 的新特性和性能优化，如 Composition API、Teleport、Fragments 等。通过 Vue 3 的优化，Vant 4 在渲染性能上有了显著提升，特别是在处理大型列表和复杂组件时。</p>\n<p><a href=\"http://www.iqidi.com:8849/\" rel=\"noopener nofollow\" target=\"_blank\"><img alt=\"移动端H5应用\" height=\"296\" src=\"https://www.iqidi.com/Framework/images/vant-mobile.png\" width=\"296\" /></a></p>\n<p>&nbsp;扫码进行了解&nbsp;Vant4+Vue3+TypeScript 的移动前端。</p>\n<p>&nbsp;</p>\n</div>\n<p>接下来就是针对H5端应用进行的界面开发了，我们可以参考案例的滚动到底部进行分页处理的页面案例，对内容进行分页展示处理，如下所示是几个界面的效果。</p>\n<p><img alt=\"image\" height=\"741\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230144121321-490674470.png\" width=\"346\" />&nbsp;&nbsp;<img alt=\"image\" height=\"742\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230144148794-1515596057.png\" width=\"346\" />&nbsp;&nbsp;<img alt=\"image\" height=\"741\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230144313426-902219873.png\" width=\"346\" /></p>\n<p>&nbsp;签名图片，我们通过调用通用的文件上传处理，把它上传到服务端的目录上了，使用的时候直接用其对应的地址即可。</p>\n<p><img alt=\"image\" height=\"334\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230144611192-2014570350.png\" width=\"686\" /></p>\n<p>了解了界面效果，我们来看看具体的代码实现过程。</p>\n<p>我们首先增加或者使用代码生成工具生成一个api对接后端的文件，如下所示。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230144808470-1588794631.png\" /></p>\n<p>这个文件很简单，就是继承基类即可，不需要增加任何自定义方法。</p>\n<div class=\"cnblogs_code\">\n<pre>import type { ListResult, PagedResult } from '@/api/types'<span style=\"color: rgba(0, 0, 0, 1);\">\nimport BaseApi from </span>'@/api/base-api'<span style=\"color: rgba(0, 0, 0, 1);\">\nimport { CommonResult } from </span>'@/api/types'<span style=\"color: rgba(0, 0, 0, 1);\">\nimport { http } from </span>'@/utils/http/axios'\n\n<span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 导入API基类对象,默认具有Get/GetAll/Create/Update/Delete/BatchDelete/SaveImport/Count等接口</span><span style=\"color: rgba(0, 128, 0, 1);\">\n//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 业务类自定义接口实现, 通用的接口已经在BaseApi中定义</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">class Api <span style=\"color: rgba(255, 0, 0, 1);\"><strong>extends BaseApi</strong></span> {\n  </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 参考下面案例，增加自定义函数</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> GET 方法例子</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 根据条件计算记录数量</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> async GetCount(params: object) {</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">   return await this.HttpGet&lt;number&gt;(this.baseurl + \"count\", params);</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> }</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> POST 方法例子</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 创建对象</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> async Create(data: object) {</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">   return await this.HttpPost&lt;boolean&gt;(this.baseurl + `create`, data);</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> }</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> PUT 方法例子</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 更新对象</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> async Update(data: object) {</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">   return await this.HttpPut&lt;boolean&gt;(this.baseurl + `update`, data);</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> }</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> DELETE 方法例子</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 删除指定ID的对象</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> async Delete(id: number | string) {</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">   return await this.HttpDelete&lt;boolean&gt;(this.baseurl + `${id}`);</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> }</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">}\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 构造测试工作项目 Api实例，并传递业务类接口地址</span>\nexport <span style=\"color: rgba(0, 0, 255, 1);\">default</span> <span style=\"color: rgba(0, 0, 255, 1);\">new</span> Api('<span style=\"color: rgba(255, 0, 0, 1);\"><strong>/api/testworkitem/</strong></span>')</pre>\n</div>\n<p>前端根据框架后端的接口进行前端JS端的类的封装处理，引入了ES6类的概念实现业务基类接口的统一封装，简化代码。这些类继承BaseApi，就会具有相关的接口了，如下所示继承关系。</p>\n<p><img alt=\"\" class=\"medium-zoom-image\" src=\"https://img2020.cnblogs.com/blog/8867/202007/8867-20200713152737929-890201160.png\" /></p>\n<p>我们已经在BaseApi的ES6类里面定义了对应Web API基类里面的操作方法，如下所示。</p>\n<p><img alt=\"\" class=\"medium-zoom-image\" height=\"595\" src=\"https://img2022.cnblogs.com/blog/8867/202207/8867-20220707112405599-7103386.png\" width=\"966\" /></p>\n<p>&nbsp;这样，我们在创建一个业务类的时候，如果没有特殊的自定义接口，只需要继承基类BaseApi即可具有所有的常规基类方法了。</p>\n<p>&nbsp;由于我们的ES6接口定义，是基于TypeScript的，它的数据类型可以推断出来，因此在编码或者查看对应属性的时候，会有非常好的提示信息。</p>\n<p>对应几个不同的页面场景，我们分别创建不同的视图文件，如下所示。</p>\n<p><img alt=\"image\" height=\"454\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230145310033-599021859.png\" width=\"479\" /></p>\n<p>&nbsp;由于Vue3+Typescript+Vant4的H5应用端是基于VueRouter的路由处理，因此，我们需要在路由模块中增加对应的路由定义，如下所示。</p>\n<p><img alt=\"image\" height=\"863\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230145553832-1840777761.png\" width=\"1065\" /></p>\n<p>&nbsp;最后我们就可以再主页面提供一个入口，访问当前的模块了。如我们在列表页面模块中，首先需要引入对应的API调用类，以及定义对应的实体对象。</p>\n<p><img alt=\"image\" height=\"833\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230145818721-1359007905.png\" width=\"1073\" /></p>\n<p>&nbsp;页面只需要调用BaseApi的基类封装函数即可实现滚动继续分页获取记录的处理。</p>\n<p><img alt=\"image\" height=\"1309\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230150032578-1409793504.png\" width=\"1078\" /></p>\n<p>&nbsp;结合Vant4的相关控件，我们可以把记录的内容展示出来。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">template</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n  <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">div </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"scroll-container\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">page-header </span><span style=\"color: rgba(255, 0, 0, 1);\">@click</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"goback\"</span> <span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-search </span><span style=\"color: rgba(255, 0, 0, 1);\">v-model</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"searchValue\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> placeholder</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"请输入搜索关键词\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> @search</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"onSearch\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> @clear</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"clearInput\"</span> <span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-list\n      </span><span style=\"color: rgba(255, 0, 0, 1);\">v-model:loading</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"loading\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n      :finished</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"finished\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n      finished-text</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"没有更多了\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n      @load</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"onRefresh\"</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n      <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-swipe-cell\n        </span><span style=\"color: rgba(255, 0, 0, 1);\">v-for</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"(item, index) in list\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n        :key</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"index\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n        class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"m-2 overflow-hidden border border-gray-300 rounded-[12px]\"</span>\n      <span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 128, 0, 1);\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1);\"> 主体内容 </span><span style=\"color: rgba(0, 128, 0, 1);\">--&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">template </span><span style=\"color: rgba(255, 0, 0, 1);\">#default</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n          <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">div </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"box-border min-w-0 w-full flex flex-row items-start p-2\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 128, 0, 1);\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1);\"> 图片区域 </span><span style=\"color: rgba(0, 128, 0, 1);\">--&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-image\n              </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"h-[100px] w-[100px] flex-shrink-0 rounded-md\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n              fit</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"contain\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n              :src</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"!isNullOrUnDef(item.creatsign) ? item.creatsign : '/images/img_nodata.png'\"</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n\n            <span style=\"color: rgba(0, 128, 0, 1);\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1);\"> 文本区域 </span><span style=\"color: rgba(0, 128, 0, 1);\">--&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">div\n              </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"ml-4 min-w-0 flex-1\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n              @click</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"showDetail(item.id ?? '')\"</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n              <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">div </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"whitespace-normal break-words text-base font-medium\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span><span style=\"color: rgba(0, 0, 0, 1);\">\n                {{ item.item1 }}/{{ item.item2 }}/{{ item.item3 }}/{{ item.item4 }}\n              </span><span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">div</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n\n              <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">div </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"mt-2 flex flex-col whitespace-normal break-words text-sm text-gray-500\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n                <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">span</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span><span style=\"color: rgba(0, 0, 0, 1);\">\n                    状态:\n                    </span><span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-tag </span><span style=\"color: rgba(255, 0, 0, 1);\">:type</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"getStatusTag(item.status ?? 0)\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span><span style=\"color: rgba(0, 0, 0, 1);\">\n                    {{ getStatus(item.status) }}\n                  </span><span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">van-tag</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n                <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">span</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n                <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">span</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>{{ format(item.createtime) }}<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">span</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n              <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">div</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">div</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n          <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">div</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">template</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n\n        <span style=\"color: rgba(0, 128, 0, 1);\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1);\"> 删除按钮 </span><span style=\"color: rgba(0, 128, 0, 1);\">--&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">template </span><span style=\"color: rgba(255, 0, 0, 1);\">#right</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n          <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">div </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"h-full w-[64px] flex items-center justify-center bg-red-500\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-icon </span><span style=\"color: rgba(255, 0, 0, 1);\">name</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"delete\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> color</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"#fff\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> size</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"20\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> @click</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"deleteItem(item)\"</span> <span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n          <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">div</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">template</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n      <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">van-swipe-cell</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">van-list</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-action-bar </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"m-2\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n      <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-action-bar-icon </span><span style=\"color: rgba(255, 0, 0, 1);\">text</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"返回\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> icon</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"arrow-left\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> @click</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"goback\"</span> <span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n      <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-action-bar-button </span><span style=\"color: rgba(255, 0, 0, 1);\">color</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"green\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> text</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"创建工作项目\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> @click</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"createItem\"</span> <span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">van-action-bar</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">div </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"mb-20\"</span> <span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-back-top </span><span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n  <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">div</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">template</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span></pre>\n</div>\n<p>从而实现了我们前面介绍的页面效果。</p>\n<p><img alt=\"image\" height=\"741\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230144121321-490674470.png\" width=\"346\" />&nbsp;&nbsp;<img alt=\"image\" height=\"746\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230150350899-1651155846.png\" width=\"348\" /></p>\n<p>&nbsp;其他页面的效果也是类似，参考相关的界面实现来调整展示效果即可，不在赘述。</p>\n<p>&nbsp;如需进一步了解H5应用端的功能介绍，可以参考随笔《<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wuhuacong/p/19039255\" id=\"cb_post_title_url\" title=\"发布于 2025-08-15 13:36\">基于Vant4+Vue3+TypeScript的H5移动前端</a>》，进行深入的了解。</p>\n</div>\n<div id=\"MySignature\">\n    <div style=\"border-right-color: #cccccc; border-right-width: 1px; border-right-style: solid; padding-right: 5px; border-top-color: #cccccc; border-top-width: 1px; border-top-style: solid; padding-left: 4px; font-size: 13px; padding-bottom: 4px; border-left-color: #cccccc; border-left-width: 1px; border-left-style: solid; width: 98%; padding-top: 4px; border-bottom-color: #cccccc; border-bottom-width: 1px; border-bottom-style: solid; background-color: #eeeeee;\">\n    <img align=\"top\" alt=\"\" src=\"http://www.cnblogs.com/Images/OutliningIndicators/None.gif\" />\n    <span style=\"color: #000000;\"><span class=\"Apple-tab-span\" style=\"white-space: pre;\"></span>\n     专注于代码生成工具、.Net/Python 框架架构及软件开发，以及各种Vue.js的前端技术应用。著有Winform开发框架/混合式开发框架、微信开发框架、Bootstrap开发框架、ABP开发框架、SqlSugar开发框架、Python开发框架等框架产品。\n     <br />&nbsp;&nbsp;转载请注明出处：撰写人：伍华聪&nbsp;&nbsp;<a href=\"http://www.iqidi.com/\" target=\"_blank\">http://www.iqidi.com</a>&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;</span></div>\n</div>\n<div class=\"clear\"></div>\n\n        </div>\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\">2025-12-30 15:07</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wuhuacong\">伍华聪</a>&nbsp;\n阅读(<span id=\"post_view_count\">257</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n        </p>"
    },
    {
      "title": "实用程序：Python打造进程网络监控与分析工具——全方位掌握你的网络与进程状态",
      "link": "https://www.cnblogs.com/ChenAI-TGF/p/19421354",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ChenAI-TGF/p/19421354\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 14:57\">\n    <span>实用程序：Python打造进程网络监控与分析工具——全方位掌握你的网络与进程状态</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文介绍了一款基于Python开发的GUI网络监控工具，能够实时监控进程网络活动、分析端口占用情况、诊断网络问题。该工具支持Windows系统，提供进程带宽管理、端口筛选、网速测试、路由追踪等功能，并可将数据导出为CSV或图表。界面简洁易用，集成实时刷新、带宽限制等高级功能，适合普通用户排查网络故障和开发者分析程序行为。项目已开源，包含详细功能展示和操作指南，后续将优化多平台兼容性。代码地址：https://github.com/ChenAI-TGF/SysNetMonitor_GUI\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"前言\">前言</h1>\n<p>在日常使用电脑的过程中，你是否好奇过这些困惑：为什么网络突然变卡？哪个进程在偷偷占用大量带宽？某个端口被哪个程序占用了？为了解决这些问题，博主用python开发了一款「进程网络监控与分析工具」，它能全方位监控网络状态、分析进程网络行为、诊断网络问题，帮你轻松掌握系统网络全貌。程序涵盖进程网络监控，系统总带宽波动查询，网络环境信息，端口占用监控，网络诊断服务，限制宽带等全面的功能，并配有UI界面，0上手门槛！</p>\n<p><strong>代码已开源到Github，欢迎访问下载：<a href=\"https://github.com/ChenAI-TGF/SysNetMonitor_GUI\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/ChenAI-TGF/SysNetMonitor_GUI</a><br />\n如果觉得好用的话可以点点Star，十分感谢！！</strong><br />\n<strong>也可以直接私信我要开源代码</strong></p>\n<p>先来个界面预览：<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h1 id=\"项目简介\">项目简介</h1>\n<p>这款工具是基于Python开发的GUI应用，旨在为用户提供直观、全面的网络与进程监控能力。无论是普通用户排查网络故障，还是开发者分析程序网络行为，都能满足需求。工具支持Windows主流系统，部分功能兼容Linux/macOS，界面简洁大方，操作简单易上手。</p>\n<h1 id=\"环境要求\">环境要求</h1>\n<p>在使用工具前，需确保你的环境满足以下要求：</p>\n<ul>\n<li><strong>Python版本</strong>：3.7及以上（推荐3.9+，兼容性更佳）</li>\n<li><strong>支持系统</strong>：主要支持Windows（部分功能兼容Linux/macOS）</li>\n<li><strong>依赖库</strong>：\n<ul>\n<li>内置库：tkinter、ctypes、platform、socket（无需额外安装）</li>\n<li>第三方库：psutil（进程与系统监控）、ttkbootstrap（UI美化）、matplotlib（图表绘制）、numpy（数据处理）、requests（网络请求）、netifaces（网络接口信息）、speedtest-cli（网速测试）</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"核心功能详解\">核心功能详解</h1>\n<p>工具包含多个大核心功能模块，覆盖从进程监控到网络诊断的全场景需求，以下是详细介绍：</p>\n<h2 id=\"1-进程网络监控\">1. 进程网络监控</h2>\n<p>这是工具的核心功能之一，能够实时展示系统中所有进程的网络活动状态。</p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<ul>\n<li><strong>实时监控</strong>：显示进程的PID、名称、本地/远程IP端口、上传/下载速度、总流量等关键信息。</li>\n<li><strong>详情查看</strong>：双击任意进程，可打开详情窗口，查看该进程的带宽变化曲线（支持实时刷新）、历史网络活动记录。</li>\n<li><strong>带宽管理</strong>：在进程详情窗口中，可设置上传/下载带宽预警阈值（当超过阈值时会触发提醒）；在主界面选中进程后，点击「限制进程带宽」可手动限制其网络速度。</li>\n</ul>\n<h2 id=\"2-端口占用监控\">2. 端口占用监控</h2>\n<p>轻松网络调试中，端口占用是常见问题，该模块可快速定位端口占用情况：</p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<ul>\n<li><strong>端口信息全展示</strong>：表格列出所有端口的协议类型（TCP/UDP）、本地IP和端口、远程IP和端口、连接状态、所属进程PID及名称。</li>\n<li><strong>精准筛选</strong>：支持通过端口号搜索和协议类型（TCP/UDP/全部）筛选，快速定位目标端口。</li>\n<li><strong>关联进程</strong>：双击端口查看端口对应的进程名称和PID，方便直接占用端口的程序（双击端口记录可跳进程详情）。</li>\n</ul>\n<h2 id=\"3-网络环境信息\">3. 网络环境信息</h2>\n<p>全面展示当前网络环境的基础信息，帮你快速了解当前网络配置：</p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<ul>\n<li><strong>网络概览</strong>：包含公网IP、运营商信息、ASN（自治系统编号）、网络类型（有线/无线）、默认网关、DNS服务器、网络延迟和丢包率。</li>\n<li><strong>网卡详情</strong>：显示所有网卡的详细信息，包括网卡名称、MAC地址、IP地址（IPv4/IPv6）、子网掩码、广播地址等。</li>\n<li><strong>一键刷新</strong>：点击「刷新网络信息」按钮，可实时更新所有网络环境数据。</li>\n</ul>\n<h3 id=\"4-网络诊断工具\">4. 网络诊断工具</h3>\n<p>集成网络故障排查提供实用功能：</p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<ul>\n<li><strong>网速测试</strong>：测试当前网络的上传/下载速度（基于speedtest-cli）。</li>\n<li><strong>Ping测试</strong>：输入目标IP或域名，执行Ping命令，查看延迟和丢包情况。</li>\n<li><strong>路由追踪</strong>：追踪数据包从本地到目标地址的路由路径，定位网络瓶颈节点。</li>\n</ul>\n<h2 id=\"5-数据导出与分析\">5. 数据导出与分析</h2>\n<p>支持将监控数据导出保存，方便后续分析：</p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<ul>\n<li><strong>数据导出</strong>：在「操作面板」标签页，可将进程网络数据、端口占用数据导出为CSV格式，便于用Excel等工具进一步分析。</li>\n<li><strong>图表导出</strong>：在进程详情窗口的带宽曲线图中，点击「导出图表」可将实时带宽曲线保存为PNG图片。</li>\n</ul>\n<p>导出效果如下<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /><br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h2 id=\"6-进程具体数据分析\">6. 进程具体数据分析</h2>\n<h3 id=\"61-基本信息\">6.1 基本信息</h3>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"62-网络信息\">6.2 网络信息</h3>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"62-带宽曲线图\">6.2 带宽曲线图</h3>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"64-连接详情\">6.4 连接详情</h3>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"65-流量分析\">6.5 流量分析</h3>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h1 id=\"使用方法\">使用方法</h1>\n<h2 id=\"1-运行应用\">1. 运行应用</h2>\n<ul>\n<li>直接执行脚本：<code>python 你的脚本文件名.py</code></li>\n<li>执行脚本之后，如果你不是以管理员权限运行的脚本，程序会询问你是否可以用管理员权限来执行，选择是既可<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></li>\n</ul>\n<h3 id=\"2-基本操作\">2. 基本操作</h3>\n<ul>\n<li>各标签页均均有「刷新」按钮，点击可手动更新数据。</li>\n<li>在「进程网络监控」标签页双击进程，打开详情窗口；在「端口占用监控」标签页双击端口记录，查看对应进程信息。</li>\n</ul>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"3-高级功能\">3. 高级功能</h3>\n<ul>\n<li>\n<p><strong>带宽限制设置</strong>：在进程详情窗口配置该进程上传和下载的带宽限制。<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p><strong>多条件筛选</strong>：端口监控支持组合筛选（端口号+协议），快速定位异常连接。</p>\n</li>\n</ul>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h2 id=\"项目亮点\">项目亮点</h2>\n<ol>\n<li><strong>功能全面</strong>：整合进程监控、端口分析、网络诊断、数据导出等功能，一站式解决网络监控需求。</li>\n<li><strong>界面友好</strong>：基于ttkbootstrap打造的UI，简洁美观，操作逻辑清晰，适合各类用户。</li>\n<li><strong>实时性强</strong>：数据刷新及时，带宽曲线实时绘制，能精准反映网络状态变化。</li>\n<li><strong>跨平台潜力</strong>：核心功能在Linux/macOS上可兼容，未来将进一步完善多平台支持。</li>\n</ol>\n<h2 id=\"总结\">总结</h2>\n<p>这款进程网络监控与分析工具旨在为用户提供透明、可控的网络管理能力。无论是普通用户解决网络卡顿问题，还是开发者调试程序网络行为，都能从中受益。目前工具已实现核心功能，后续将持续优化多平台兼容性，并增加更多高级分析功能（如网络流量趋势预测、异常连接智能预警等）。</p>\n<p><strong>代码已开源到Github，欢迎访问下载：<a href=\"https://github.com/ChenAI-TGF/SysNetMonitor_GUI\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/ChenAI-TGF/SysNetMonitor_GUI</a><br />\n如果觉得好用的话可以点点Star，十分感谢！！</strong></p>\n<p>如果你也有网络监控的需求，欢迎尝试这款工具，如有问题或建议，欢迎在项目仓库留言交流！<br />\n<strong>也可以直接私信我要开源代码</strong></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 14:57</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ChenAI-TGF\">TTGF</a>&nbsp;\n阅读(<span id=\"post_view_count\">110</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MyBatis 连接缓慢问题排查与解决实战",
      "link": "https://www.cnblogs.com/longlonglong777/p/19423391",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/longlonglong777/p/19423391\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 21:49\">\n    <span>MyBatis 连接缓慢问题排查与解决实战</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"mybatis-连接缓慢问题排查与解决实战\">MyBatis 连接缓慢问题排查与解决实战</h1>\n<h2 id=\"问题背景\">问题背景</h2>\n<p>最近在维护一个老项目时,遇到了一个令人头疼的问题:项目启动后,首次数据库连接异常缓慢,需要等待较长时间才能正常响应。这个问题严重影响了开发效率和用户体验。项目的技术栈比较老旧,使用的是Spring Boot 2.5.x版本,MyBatis 3.5.2版本,数据库是MySQL,同时还使用了第三方的Redis服务。由于这是一个历史项目,很多依赖版本都比较陈旧,但一直运行还算稳定,直到最近频繁出现连接缓慢的情况,才不得不着手解决这个问题。</p>\n<h2 id=\"排查过程\">排查过程</h2>\n<h3 id=\"第一阶段怀疑redis配置问题\">第一阶段:怀疑Redis配置问题</h3>\n<p>一开始我怀疑是Redis配置的问题。因为项目使用的是第三方Redis服务,我担心可能是Redis的配置不正确,导致连接失活,从而影响了整体的连接性能。于是我仔细检查了Redis的连接配置,包括host、port、timeout等参数,还验证了Redis连接池的配置是否合理,并且测试了Redis服务的可用性。但是经过一番折腾后发现,Redis连接一切正常,问题依然存在,这让我不得不转换思路。</p>\n<h3 id=\"第二阶段聚焦mysql连接\">第二阶段:聚焦MySQL连接</h3>\n<p>接着我把注意力转向了MySQL数据库。我开始怀疑可能是MySQL服务本身出现了问题,或者是Navicat客户端的配置有误导致的连接缓慢。为此我检查了MySQL服务的运行状态,调整了数据库连接池的各种配置参数,比如最大连接数、超时时间等,还验证了Navicat的连接配置,甚至测试了数据库的网络延迟情况。经过多次反复调整和排查,问题仍然没有得到解决,这让我开始怀疑是不是思路出现了偏差。</p>\n<h3 id=\"第三阶段版本兼容性问题定位\">第三阶段:版本兼容性问题定位</h3>\n<p>转机出现在我新建测试项目的时候。当我创建了一个新的简单项目进行测试时,竟然发现了同样的连接缓慢问题!这个发现让我豁然开朗,意识到问题很可能不在配置上,而是出在框架版本本身。经过仔细研究和查阅资料,我最终定位到了问题的根源:MyBatis 3.5.2版本存在已知的Bug,这才是导致连接缓慢的罪魁祸首。虽然Spring Boot 2.5.x版本也相对老旧,但主要问题还是出在MyBatis的版本上,老版本在连接管理和资源释放方面存在一些性能问题,这些问题在后续版本中已经得到了修复。</p>\n<h2 id=\"解决方案\">解决方案</h2>\n<p>既然定位到了问题所在,解决起来就比较简单了。我决定升级相关组件到更稳定的版本。首先在项目的pom.xml文件中修改版本属性配置:</p>\n<pre><code class=\"language-xml\">&lt;properties&gt;\n    &lt;!-- PageHelper 版本 --&gt;\n    &lt;pagehelper.boot.version&gt;1.4.6&lt;/pagehelper.boot.version&gt;\n    \n    &lt;!-- MyBatis 核心库版本 --&gt;\n    &lt;mybatis.version&gt;3.5.19&lt;/mybatis.version&gt;\n    \n    &lt;!-- MyBatis Spring 集成版本 --&gt;\n    &lt;mybatis.spring.version&gt;2.1.2&lt;/mybatis.spring.version&gt;\n&lt;/properties&gt;\n</code></pre>\n<p>然后在dependencies中添加或更新对应的依赖:</p>\n<pre><code class=\"language-xml\">&lt;dependencies&gt;\n    &lt;!-- MyBatis Spring Boot Starter --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\n        &lt;version&gt;2.3.2&lt;/version&gt;\n    &lt;/dependency&gt;\n    \n    &lt;!-- MyBatis 核心库 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;\n        &lt;version&gt;${mybatis.version}&lt;/version&gt;\n    &lt;/dependency&gt;\n    \n    &lt;!-- MyBatis Spring 集成 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;\n        &lt;version&gt;${mybatis.spring.version}&lt;/version&gt;\n    &lt;/dependency&gt;\n    \n    &lt;!-- PageHelper 分页插件 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;\n        &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;\n        &lt;version&gt;${pagehelper.boot.version}&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>\n<p>升级完成后,连接缓慢的问题彻底消失了,首次数据库操作的响应速度恢复正常,整个项目的性能都有了明显提升,开发和测试的效率也大大提高了。</p>\n<h2 id=\"问题复盘与经验总结\">问题复盘与经验总结</h2>\n<h3 id=\"排查思路优化\">排查思路优化</h3>\n<p>回顾整个排查过程,虽然走了一些弯路,但也让我积累了宝贵的经验。首先,排查思路要遵循先易后难、逐层深入的原则,从外部依赖开始,逐步深入到数据库层面,最后才关注框架本身,这样可以避免一开始就陷入复杂的底层问题。其次,复现问题是定位根因的关键,通过新建项目复现问题,我才能够排除业务代码的干扰,快速缩小问题范围,这是整个排查过程中最重要的转折点。</p>\n<h3 id=\"版本管理的重要性\">版本管理的重要性</h3>\n<p>对于老项目的维护,一定要特别关注版本兼容性问题,优先检查核心框架的版本是否过于陈旧,查阅官方的Release Notes和Issue Tracker,了解是否存在已知的Bug和对应的修复版本。在实际开发中,我们应该定期升级依赖版本,及时跟进安全补丁和Bug修复,选择稳定的LTS版本进行部署。版本过旧是技术债务的重要来源,定期升级维护不仅能避免潜在的Bug,还能享受新特性带来的性能提升和开发体验改善。</p>\n<h3 id=\"问题排查工具箱\">问题排查工具箱</h3>\n<p>建立系统的问题排查清单非常重要,包括网络连接、配置参数、版本兼容性、日志分析等各个方面,这样在遇到问题时可以有条不紊地进行排查。善用日志和监控工具也非常关键,开启MyBatis的SQL日志,监控数据库连接池的状态,分析慢查询日志,这些都能帮助我们更快地定位问题。当遇到复杂问题时,创建最小可复现示例来隔离测试环境,排除业务代码的干扰,可以大大提高问题定位的效率。</p>\n<h3 id=\"版本选择建议\">版本选择建议</h3>\n<p>对于MyBatis 3.5.2这个版本来说,它在连接管理方面确实存在一些已知问题,建议大家至少升级到3.5.10以上的版本。对于Spring Boot的选择,生产环境建议使用2.7.x版本(适配Java 8/11)或者3.x版本(需要Java 17以上),这些版本都有更好的长期支持和安全更新。在升级MyBatis时,还需要注意MyBatis Spring Boot Starter的版本要与MyBatis核心库版本相匹配,避免出现新的兼容性问题。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 21:49</span>&nbsp;\n<a href=\"https://www.cnblogs.com/longlonglong777\">java贼溜</a>&nbsp;\n阅读(<span id=\"post_view_count\">5</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "程序员必备！一款免费的（原文/译文）AI 双语对照网页翻译插件，信息获取效率飙升！",
      "link": "https://www.cnblogs.com/Can-daydayup/p/19423330",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Can-daydayup/p/19423330\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 21:25\">\n    <span>程序员必备！一款免费的（原文/译文）AI 双语对照网页翻译插件，信息获取效率飙升！</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2><span>前言</span></h2>\n<p><span>在信息爆炸的时代，掌握一手外文资料往往意味着抢占先机。然而，语言障碍常常成为程序员高效学习与工作的绊脚石。今天大姚给大家分享一款自己觉得非常实用且一直在用的一款免费的（原文/译文）AI 双语对照网页翻译插件：<strong>沉浸式翻译</strong><span>，一键开启双语阅读，提升信息获取效率。</span></span></p>\n<h2><span>插件介绍</span></h2>\n<p><strong>沉浸式翻译</strong><span>&nbsp;是一款免费的（原文/译文）AI 双语对照网页翻译插件，它不仅支持网页、PDF、视频字幕和电子书的双语对照翻译，还兼容 <span>DeepL、OpenAI、Deepseek、Gemini 等主流 AI 翻译引擎，真正实现“所见即所得”的无缝阅读体验。一键开启双语阅读，提升信息获取效率。</span></span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251230212034293-2131746995.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251230212039607-1186263693.png\" /></p>\n<h2><span>应用场景</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>外文资料查阅</strong><span>：帮助用户快速查阅并理解外文网页、学术论文、商业文件等。</span></li>\n<li><strong>视频学习</strong><span>：支持主流视频网站的双语实时字幕，辅助外语学习。</span></li>\n<li><strong>电子书阅读</strong><span>：将外文电子书转化为双语版本，提升阅读体验。</span></li>\n<li><strong>跨语言沟通</strong><span>：在输入框中直接翻译文本，辅助跨语言写作和对话。</span></li>\n</ul>\n<h2><span>插件安装</span></h2>\n<h3><span><span>微软Edge浏览器安装</span></span></h3>\n<ul class=\"list-paddingleft-1\">\n<li><strong>插件安装地址：<span style=\"color: rgba(0, 0, 255, 1);\"><a href=\"https://microsoftedge.microsoft.com/addons/detail/%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%BF%BB%E8%AF%91-%E7%BD%91%E9%A1%B5%E7%BF%BB%E8%AF%91%E6%8F%92%E4%BB%B6-pdf%E7%BF%BB%E8%AF%91-/amkbmndfnliijdhojkpoglbnaaahippg?form=MT001Y&amp;hl=zh-CN&amp;gl=CN\" rel=\"noopener nofollow\" target=\"_blank\"><span style=\"color: rgba(0, 0, 255, 1);\">https://microsoftedge.microsoft.com/addons/detail/%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%BF%BB%E8%AF%91-%E7%BD%91%E9%A1%B5%E7%BF%BB%E8%AF%91%E6%8F%92%E4%BB%B6-pdf%E7%BF%BB%E8%AF%91-/amkbmndfnliijdhojkpoglbnaaahippg?form=MT001Y&amp;hl=zh-CN&amp;gl=CN</span></a></span></strong></li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251230212058021-378881760.png\" /></p>\n<h3><span>Google浏览器安装</span></h3>\n<ul class=\"list-paddingleft-1\">\n<li><strong>插件安装教程：</strong><span style=\"color: rgba(0, 0, 255, 1);\"><strong><a href=\"https://immersivetranslate.cn/manual-chrome-extension/zip/\" rel=\"noopener nofollow\" target=\"_blank\"><span style=\"color: rgba(0, 0, 255, 1);\">https://immersivetranslate.cn/manual-chrome-extension/zip/</span></a></strong></span></li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251230212114802-1568175133.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251230212119908-721534196.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251230212128806-2018370631.png\" /></p>\n<h2><span>插件功能</span></h2>\n<h3><span>网页双语对照翻译</span></h3>\n<p><span>沉浸式翻译内置了包括 DeepL、谷歌翻译在内的 10 余种业界顶尖的翻译引擎，是国内外所有同类产品中支持翻译引擎最多的工具。</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251230212039607-1186263693.png\" /></p>\n<h3><span>视频双语字幕</span></h3>\n<p><span>沉浸式翻译支持100多个国外主流视频网站的双语实时字幕功能。</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251230212159198-634838073.png\" /></p>\n<h3><span>PDF 对照翻译</span></h3>\n<p><span>沉浸式翻译支持 PDF 对照翻译，无论您需要阅读外文学术论文，还是处理多语言商业文件，都可以通过沉浸式翻译一键获取优质的翻译结果。</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251230212213804-552098414.png\" /></p>\n<h3><span>鼠标悬停翻译</span></h3>\n<p><span>沉浸式翻译支持鼠标悬停翻译，你只需将鼠标悬停在任意段落，同时按下预设的快捷键（如 Ctrl），当前段落的译文便会立即呈现在段落之后。</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251230212336157-1986986819.png\" /></p>\n<h2><span>更多 AI 实用效率工具</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong><a href=\"https://github.com/YSGStudyHards/DotNetGuide\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/YSGStudyHards/DotNetGuide</a></strong></li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251230212359443-1740330971.png\" /></p>\n</div>\n<div id=\"MySignature\">\n    <blockquote>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者名称：</span><a href=\"https://www.cnblogs.com/Can-daydayup/\" target=\"_blank\">追逐时光者</a></p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者简介：</span>一个热爱编程、善于分享、喜欢学习、探索、尝试新事物和新技术的全栈软件工程师。</p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\">\n本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。如果该篇文章对您有帮助的话，可以点一下右下角的<a href=\"\" style=\"color: red;\">【♥推荐♥】</a>，希望能够持续的为大家带来好的技术文章，文中可能存在描述不正确的地方，欢迎指正或补充，不胜感激。\n</p>\n</blockquote>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 21:25</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Can-daydayup\">追逐时光者</a>&nbsp;\n阅读(<span id=\"post_view_count\">18</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "吴恩达深度学习课程四：计算机视觉 第四周：卷积网络应用 (二) 图像风格转换",
      "link": "https://www.cnblogs.com/Goblinscholar/p/19423276",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Goblinscholar/p/19423276\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 21:13\">\n    <span>吴恩达深度学习课程四：计算机视觉 第四周：卷积网络应用 (二) 图像风格转换</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>此分类用于记录吴恩达深度学习课程的学习笔记。<br />\n课程相关信息链接如下：</p>\n<ol>\n<li>原课程视频链接：<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?buvid=XU762317353676D786954061C192FE625463B&amp;from_spmid=playlist.playlist-detail.0.0&amp;is_story_h5=false&amp;mid=zqernykrmpf7XfIorMR%2FnA%3D%3D&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=ce0bc526-db69-428a-962e-c65ed8c267bc&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1713085655&amp;unique_k=DfBgvFW&amp;up_id=8654113&amp;vd_source=e035e9878d32f414b4354b839a4c31a4\" rel=\"noopener nofollow\" target=\"_blank\">[双语字幕]吴恩达深度学习deeplearning.ai</a></li>\n<li>github课程资料，含课件与笔记:<a href=\"https://github.com/robbertliu/deeplearning.ai-andrewNG\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习教学资料</a></li>\n<li>课程配套练习（中英）与答案：<a href=\"https://blog.csdn.net/u013733326/article/details/79827273\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习课后习题与答案</a></li>\n</ol>\n<p>本篇为第四课的第四周内容，<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=145\" rel=\"noopener nofollow\" target=\"_blank\">4.6</a>到<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=150\" rel=\"noopener nofollow\" target=\"_blank\">4.11</a>的内容，同时也是本篇理论部分的最后一篇。</p>\n<hr />\n<p>本周为第四课的第四周内容，这一课所有内容的中心只有一个：<strong>计算机视觉</strong>。应用在深度学习里，就是专门用来进行图学习的模型和技术，是在之前全连接基础上的“特化”，也是相关专业里的一个重要研究大类。<br />\n<strong>这一整节课都存在大量需要反复理解的内容和机器学习、数学基础。</strong> 因此我会尽可能的补足基础，用比喻和实例来演示每个部分，从而帮助理解。<br />\n第四周的内容是对前三周内容的综合应用，介绍了一些通过卷积网络实现的实际应用，它们在使用卷积网络的基础上又各有自己的特点来匹配不同的任务要求，是对<strong>如何真实应用卷积网络</strong>的良好演示。<br />\n本篇的内容关于<strong>图像风格转换</strong>。</p>\n<h1 id=\"1-什么是图像风格转换\">1. 什么是图像风格转换？</h1>\n<p>并不难理解，我们之前也提到过它，用课程里的例子来进行演示：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251230210604629-1505817373.png\" /><br />\n如图所示，使用图像风格转换，我们就可以把自己拍的照片在保证内容不变的同时，转换成名画，或者整蛊版的画风。这种应用更贴近我们的生活，在现在的手机应用里也十分普遍。<br />\n现在就来看看如何实现图像风格转换。</p>\n<h1 id=\"2-如何实现图像风格转换\">2. 如何实现图像风格转换？</h1>\n<p>我们已经不止一次提到，神经网络中的许多学习任务，本质上都可以抽象为一个<strong>优化问题</strong>：通过定义合适的目标函数，并借助梯度下降等方法，使优化目标不断减小，从而得到期望的结果。<br />\n在监督学习中，这一过程通常表现为不断更新模型参数，以减小模型输出与标签之间的差异。</p>\n<p>而在图像风格转换任务中，也沿用了同样的优化思想。<br />\n此时，我们需要回答的关键问题是：<strong>如何度量内容图像与风格图像之间的差异，使生成结果在保持内容结构的同时，逐步逼近目标风格？</strong></p>\n<p>答案就在于<strong>构造合适的代价函数</strong>。<br />\n代价函数这个名字已经很久没有出现过了，我们先回顾一下损失函数和代价函数的概念：前者是<strong>单个</strong>样本输出和标签之间的差距，后者是<strong>训练集中所有</strong>样本输出和标签之间差距的平均值。<br />\n但在实际工程实现和大量论文中，二者往往被混用，深度学习框架中也普遍使用 loss 来指代最终用于反向传播的优化目标。<br />\n因此，虽然<strong>二者数学上可区分，但在实际工程上经常不区分</strong>，我们明白含义就好。</p>\n<p>回到正题，在 2015 年，一篇名为<a href=\"https://arxiv.org/pdf/1508.06576\" rel=\"noopener nofollow\" target=\"_blank\">A Neural Algorithm of Artistic Style</a>的论文首次提出神经风格转换的概念。<br />\n这篇论文的核心思想是：在<strong>固定预训练卷积神经网络参数</strong>的前提下，利用网络中间层特征，将图像的内容结构与风格统计进行显式分离，并通过在特征空间中最小化相应的代价函数，直接对输入图像进行优化，从而重构出一幅同时匹配内容与风格约束的图像。</p>\n<p>简单来说，图像风格转换的代价函数被分成了两部分：<strong>内容代价函数和风格代价函数</strong>：</p>\n<p></p><div class=\"math display\">\\[\\mathcal{J}_{\\text{total}}(G)\n= \\alpha \\, \\mathcal{J}_{\\text{content}}(C,G)\n+ \\beta \\, \\mathcal{J}_{\\text{style}}(S,G)\n\\]</div><p></p><p>其中，<span class=\"math inline\">\\(\\mathcal{J}_{\\text{content}}\\)</span> 用于约束生成图像在高层特征空间中与内容图像保持一致，<span class=\"math inline\">\\(\\mathcal{J}_{\\text{style}}\\)</span> 则通过统计特征相关性来刻画并匹配目标风格，<span class=\"math inline\">\\(\\alpha\\)</span> 与 <span class=\"math inline\">\\(\\beta\\)</span> 用于平衡内容与风格在生成结果中的相对重要性。</p>\n<p>陈述偏学术，有些迷惑很正常，我们下面就来详细展开：</p>\n<h2 id=\"21-图像风格转换的训练逻辑\">2.1 图像风格转换的训练逻辑</h2>\n<p>在刚刚说明神经风格转换的核心思想时，你可能注意到了一个细节：<strong>固定预训练卷积神经网络参数</strong>。<br />\n这意味着，我们在优化的过程中<strong>不去改变网络本身的权重</strong>。<br />\n那问题来了：如果网络不动，代价函数还能下降吗？答案是肯定的——关键在于<strong>优化的对象变了</strong>。</p>\n<p>这便是神经风格转换的一个核心点：<strong>被优化的不是网络参数，而是生成图像本身</strong>。<br />\n这是什么意思？我们展开说明：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251230210605797-2058246293.png\" /><br />\n如图所示，你会发现，在这套训练逻辑中，<strong>网络只是一个工具，就像一把已经刻好的尺子，只负责提取图像的内容和风格特征。</strong><br />\n我们将生成图像输入网络，通过前向传播得到其内容特征和风格特征，再与内容图像和风格图像的预计算目标特征比较，得到代价函数。随后，<strong>通过梯度反向传播，更新生成图像像素，而网络参数保持固定。</strong><br />\n这样一来，虽然网络不训练，我们仍然可以通过迭代优化生成图像，使其内容与风格逐步逼近目标。<br />\n了解了基本的训练逻辑后，我们再来看看到底如何实现代价函数。</p>\n<h2 id=\"22-内容代价函数\">2.2 内容代价函数</h2>\n<p>我们先来看看较为直观的内容代价函数：<span class=\"math inline\">\\(\\mathcal{J}_{\\text{content}}(C,G)\\)</span><br />\n顾名思义，这部分代价函数的作用是用来<strong>衡量生成图像和内容图像之间的差异</strong>，显然，我们希望这部分能最小化来保持图像内容不变。</p>\n<p>如何实现这部分？<br />\n我们知道，在卷积神经网络中，随着网络层数的增加，输出特征图的抽象程度逐渐提高：</p>\n<ul>\n<li><strong>浅层特征</strong>主要捕捉局部纹理和边缘信息</li>\n<li><strong>深层特征</strong>则编码全局语义和高级抽象</li>\n</ul>\n<p>我们一般使用深层特征来进行分类或检测等任务，<strong>但如果直接使用深层特征来计算内容损失，虽然语义信息丰富，但局部结构可能丢失；如果只用浅层特征，又容易被细节干扰。</strong><br />\n因此，我们通常选择<strong>中间层特征</strong>来计算内容代价，它既能反映图像的整体结构，又保留足够的局部信息，正好适合衡量生成图像与内容图像之间的差异。<br />\n可以形象地理解为：我们不希望只对纹理“计较”，也不希望只看整体概念，而是找到一个<strong>中间尺度</strong>，既能保留结构，又不过于抽象。<br />\n也就是说，我们让用来计算内容代价的两组特征向量的抽象程度维持在一个合适的程度，既不是简单的纹理，也不是全局语义，就像这样：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251230210605054-1967661990.png\" /><br />\n明白了这一点后，我们现在就来看看到底如何计算内容代价:<br />\n并不复杂，一句话就可以说明：<strong>计算这两组向量中对应量差的平方和。</strong><br />\n公式表示为：</p>\n<p></p><div class=\"math display\">\\[\\mathcal{J}_{\\text{content}}(C,G)=|a^{[l](C)}-a^{[l](G)}|^2\n\\]</div><p></p><p>其中，<span class=\"math inline\">\\(l\\)</span> 为我们选定的输出特征抽象程度合适的层级。<br />\n你也可以加入归一化：</p>\n<p></p><div class=\"math display\">\\[\\mathcal{J}_{\\text{content}}(C,G)=\\frac{1}{2}|a^{[l](C)}-a^{[l](G)}|^2\n\\]</div><p></p><p>了解完计算方式后，我们来看一个实例加深一下印象：</p>\n<p>假设我们在某一中间层得到的特征图如下：</p>\n<ul>\n<li>内容图像 <span class=\"math inline\">\\(C\\)</span> 的特征向量：</li>\n</ul>\n<p></p><div class=\"math display\">\\[a^{[l](C)} = \n\\begin{bmatrix}\n0.2 &amp; 0.5 &amp; 0.3 \\\\\n0.1 &amp; 0.4 &amp; 0.6\n\\end{bmatrix}\n\\]</div><p></p><ul>\n<li>生成图像 <span class=\"math inline\">\\(G\\)</span> 的对应特征向量：</li>\n</ul>\n<p></p><div class=\"math display\">\\[a^{[l](G)} =\n\\begin{bmatrix}\n0.1 &amp; 0.7 &amp; 0.2 \\\\\n0.2 &amp; 0.3 &amp; 0.5\n\\end{bmatrix}\n\\]</div><p></p><p>代入内容代价公式计算：</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\n\\mathcal{J}_{\\text{content}}(C,G) &amp;= \\frac{1}{2} \\Big[\n(0.1-0.2)^2 + (0.7-0.5)^2 + (0.2-0.3)^2 \\\\\n&amp;\\quad + (0.2-0.1)^2 + (0.3-0.4)^2 + (0.5-0.6)^2\n\\Big] \\\\\n&amp;= \\frac{1}{2} \\Big[ 0.01 + 0.04 + 0.01 + 0.01 + 0.01 + 0.01 \\Big] \\\\\n&amp;= \\frac{1}{2} \\cdot 0.09 \\\\\n&amp;= 0.045\n\\end{aligned}\n\\]</div><p></p><p>可以看到，这个值就表示生成图像在该层特征上与内容图像的差异。<strong>优化的目标就是让这个值尽量减小</strong>，从而让生成图像尽量保留原有内容结构。</p>\n<p>这就是对内容代价的计算，下面我们继续看代价的另一部分：风格代价。</p>\n<h2 id=\"23-风格代价函数\">2.3 风格代价函数</h2>\n<p>相比内容代价，风格代价显得就抽象了些。我们把这节分为几部分，来进行较详细的介绍。</p>\n<h3 id=\"1量化风格\">（1）量化风格</h3>\n<p>显然，要计算风格代价的首要问题就在于：<strong>我们要如何量化一幅图像的“风格”？</strong></p>\n<p>直觉上，风格并不取决于“画的是什么”，而更多体现在<strong>颜色搭配、纹理分布、笔触规律</strong>等整体视觉特征上，也就是说，**风格是一种“统计特性”，而不是依赖具体空间位置的结构信息。</p>\n<p>因此，在计算风格代价时，我们需要一种统计方式：<strong>这种方式不关注具体的空间位置信息，而是聚焦于统计不同特征之间的相关性。</strong><br />\n我们展开解释一下这句话，就像这样：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251230210603103-954591223.png\" /><br />\n进一步地，我们把这样一幅彩色图像输入卷积网络，随着网络传播，输出特征图的通道数也不断增加，这时，<strong>每一个通道都可以粗略地理解为网络从图像中提取到的一类特征响应</strong>，它们可能对应颜色、纹理、局部形状或更复杂的视觉模式。<br />\n既然如此，不同特征通道之间自然也会存在某种统计上的关联关系，例如某些纹理特征往往与特定颜色分布同时出现，就像这样：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251230210604011-1547261915.png\" /></p>\n<p>因此，我们可以将一幅图像的风格，量化为<strong>其特征图中各通道之间的相关性统计</strong>。<br />\n而同时，下一个就自然而然的产生：我们怎么统计各通道的相关性？</p>\n<h3 id=\"2gram-矩阵\">（2）Gram 矩阵</h3>\n<p>在神经风格转换中，Gatys 等人选择使用 <strong>Gram Matrix（格拉姆矩阵）</strong> 来刻画特征通道之间的相关性。<br />\n先不急着摆公式，我们来看看为什么 Gram 矩阵是一个合适的选择：<br />\n我们刚刚提到过，如果某两类特征在同一幅图像中<strong>经常同时被强烈激活</strong>，那么我们就可以认为它们在统计意义上是“相关的”。<br />\n而 Gram 矩阵做的事情正是这一点：它不关心这些特征在图像的哪个位置出现，而只关心——<br />\n<strong>不同特征通道在整幅图像中是否倾向于一起出现，以及出现得有多强。</strong><br />\n也就是说，Gram 矩阵刻画的是一种 <strong>“特征与特征之间的共现关系”</strong>。</p>\n<p>了解了Gram 矩阵的作用后，我们先用人话解释一下Gram 矩阵的计算过程：<strong>对所有通道两两组合，计算其相同位置上两个元素乘积的和，作为 Gram 矩阵中以两通道索引为坐标处的值。</strong><br />\n然后，来看公式：<br />\n我们采用如下符号约定：</p>\n<ol>\n<li><span class=\"math inline\">\\(a_{i,j,k}^{[l]}\\)</span>：表示第 <span class=\"math inline\">\\(l\\)</span> 层中，空间位置 <span class=\"math inline\">\\((i,j)\\)</span> 处，第 <span class=\"math inline\">\\(k\\)</span> 个通道的激活值。</li>\n<li>特征图空间尺寸为 <span class=\"math inline\">\\(n_H^{[l]} \\times n_W^{[l]}\\)</span>，通道数为 <span class=\"math inline\">\\(n_C^{[l]}\\)</span>。</li>\n</ol>\n<p>在第 <span class=\"math inline\">\\(l\\)</span> 层中，输出特征图 的 Gram 矩阵 <span class=\"math inline\">\\(G^{[l]} \\in \\mathbb{R}^{n_C^{[l]} \\times n_C^{[l]}}\\)</span> 定义为：</p>\n<p></p><div class=\"math display\">\\[G_{k k'}^{[l]}=\n\\sum_{i=1}^{n_H^{[l]}}  \n\\sum_{j=1}^{n_W^{[l]}}  \na_{i,j,k}^{[l]}   \na_{i,j,k'}^{[l]}  \n\\]</div><p></p><p>其中：</p>\n<ul>\n<li><span class=\"math inline\">\\(k, k'\\)</span> 表示两个不同的特征通道。</li>\n<li>对所有空间位置 <span class=\"math inline\">\\((i,j)\\)</span> 求和，<strong>显式消除了空间位置信息</strong>。</li>\n</ul>\n<p>在实际计算中，通常会对 Gram 矩阵进行归一化：</p>\n<p></p><div class=\"math display\">\\[G_{k k'}^{[l]}=\n\\frac{1}{n_H^{[l]} n_W^{[l]}}  \n\\sum_{i=1}^{n_H^{[l]}}  \n\\sum_{j=1}^{n_W^{[l]}}  \na_{i,j,k}^{[l]}  \na_{i,j,k'}^{[l]}  \n\\]</div><p></p><p>这样可以避免特征图尺寸变化对风格代价产生不必要的影响。</p>\n<p>最后，我们发现：<strong>Gram 矩阵中的每一个元素 <span class=\"math inline\">\\(G_{k k'}^{[l]}\\)</span>，刻画的是第 <span class=\"math inline\">\\(k\\)</span> 个特征与第 <span class=\"math inline\">\\(k'\\)</span> 个特征在整幅图像中的共现强度，而不是它们出现的位置。</strong></p>\n<p>我们补充一个实例：<br />\n设第 <span class=\"math inline\">\\(l\\)</span> 层共有 <span class=\"math inline\">\\(n_C^{[l]} = 3\\)</span> 个通道，每个通道的特征图大小为 <span class=\"math inline\">\\(2\\times 2\\)</span>，三个通道的特征图分别为：</p>\n<p></p><div class=\"math display\">\\[\\mathbf{F}_1^{[l]} = \\begin{bmatrix} 1 &amp; 2 \\\\ 0 &amp; 1 \\end{bmatrix},\\quad\n\\mathbf{F}_2^{[l]} = \\begin{bmatrix} 2 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix},\\quad\n\\mathbf{F}_3^{[l]} = \\begin{bmatrix} 0 &amp; 1 \\\\ 2 &amp; 1 \\end{bmatrix}.\n\\]</div><p></p><p>Gram 矩阵计算公式为：</p>\n<p></p><div class=\"math display\">\\[G_{kk'}^{[l]} = \\sum_{i=1}^{2} \\sum_{j=1}^{2} a_{i,j,k}^{[l]} a_{i,j,k'}^{[l]}.\n\\]</div><p></p><ol>\n<li>计算对角项（通道自身的相关性）</li>\n</ol>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\nG_{11}^{[l]} &amp;= 1\\cdot1 + 2\\cdot2 + 0\\cdot0 + 1\\cdot1 = 1^2 + 2^2 + 0^2 + 1^2 = 6,\\\\\nG_{22}^{[l]} &amp;= 2\\cdot2 + 1\\cdot1 + 1\\cdot1 + 0\\cdot0 = 2^2 + 1^2 + 1^2 + 0^2 = 6,\\\\\nG_{33}^{[l]} &amp;= 0\\cdot0 + 1\\cdot1 + 2\\cdot2 + 1\\cdot1 = 0^2 + 1^2 + 2^2 + 1^2 = 6.\n\\end{aligned}\n\\]</div><p></p><ol start=\"2\">\n<li>计算非对角项（不同通道之间的相关性）</li>\n</ol>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\nG_{12}^{[l]} &amp;= 1\\cdot2 + 2\\cdot1 + 0\\cdot1 + 1\\cdot0 = 4,\\\\\nG_{13}^{[l]} &amp;= 1\\cdot0 + 2\\cdot1 + 0\\cdot2 + 1\\cdot1 = 3,\\\\\nG_{23}^{[l]} &amp;= 2\\cdot0 + 1\\cdot1 + 1\\cdot2 + 0\\cdot1 = 3.\n\\end{aligned}\n\\]</div><p></p><ol start=\"3\">\n<li>由于 Gram 矩阵是对称的：</li>\n</ol>\n<p></p><div class=\"math display\">\\[G_{21}^{[l]} = G_{12}^{[l]},\\quad G_{31}^{[l]} = G_{13}^{[l]},\\quad G_{32}^{[l]} = G_{23}^{[l]}.\n\\]</div><p></p><p>最终 Gram 矩阵即为：</p>\n<p></p><div class=\"math display\">\\[G^{[l]} = \n\\begin{bmatrix}\n6 &amp; 4 &amp; 3 \\\\\n4 &amp; 6 &amp; 3 \\\\\n3 &amp; 3 &amp; 6\n\\end{bmatrix}.\n\\]</div><p></p><p>最终，这个 <span class=\"math inline\">\\(3 \\times 3\\)</span> 的 Gram 矩阵完整地刻画了三种特征在整幅图像中的两两共现关系，而完全不包含任何空间位置信息。<br />\n到这一步，我们就实现了用一个矩阵来量化一幅图像的风格。</p>\n<h3 id=\"3计算风格代价\">（3）计算风格代价</h3>\n<p>在成功实现对图像风格的量化后，我们便可以计算风格代价:<span class=\"math inline\">\\(\\mathcal{J}_{\\text{style}}(S,G)\\)</span><br />\n它的计算逻辑并不复杂：<strong>对生成图像 G 和风格图像 S 的Gram 矩阵中对相应位置元素做差并平方，最后求和。</strong><br />\n为保证与特征图尺寸和通道数无关，我们通常会加入归一化。<br />\n最终，它的公式是这样的：</p>\n<p></p><div class=\"math display\">\\[\\mathcal{J}_{\\text{style}}^{[l]}(S,G) = \\frac{1}{(2 n_H^{[l]} n_W^{[l]} n_C^{[l]})^2} \\sum_{k=1}^{n_C^{[l]}} \\sum_{k'=1}^{n_C^{[l]}} \\big(G_{kk'}^{[l](S)} - G_{kk'}^{[l](G)}\\big)^2  \n\\]</div><p></p><p>再来演示一下：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251230211202414-382274127.png\" /><br />\n值得注意的是，上述公式严格来说只是<strong>单层风格代价</strong>，因为我们只使用了网络中某一层输出的特征图。<br />\n如果我们把图像传播到网络的多个卷积层，分别计算各层的 Gram 矩阵并得到对应的风格代价，再按权重加权求和，就得到<strong>多层风格代价</strong>：</p>\n<p></p><div class=\"math display\">\\[\\mathcal{J}_{\\text{style}}(S,G) = \\sum_{l} \\lambda^{[l]} \\, \\mathcal{J}_{\\text{style}}^{[l]}(S,G)\n\\]</div><p></p><ul>\n<li><span class=\"math inline\">\\(\\lambda^{[l]}\\)</span>：第 <span class=\"math inline\">\\(l\\)</span> 层风格代价的权重，可根据需要调节。</li>\n</ul>\n<p>多层加权的好处是<strong>兼顾不同层次的风格特征</strong>：低层更偏向纹理和颜色，高层更偏向整体图案和结构，从而生成的图像风格更加自然丰富。</p>\n<p>由此，我们便成功定义了可用于图像风格转换的代价函数，接下来就可以通过网络的反向传播实现风格转换。<br />\n在本周的实践内容中，我们也会实际演示一下这种应用。</p>\n<p>另外，在本周课程最后，吴恩达老师补充了一节对一维卷积和三维卷积的介绍。<br />\n简单来说：一维卷积通常用于处理序列数据，例如时间序列或文本信号，它在序列方向上滑动卷积核，提取局部模式或特征。<br />\n三维卷积则常用于处理视频或体数据，它在高度、宽度和时间（或深度）三个维度上同时滑动卷积核，从而能够捕捉空间和时间上的联合特征，适合分析动态场景或三维结构信息。<br />\n我们就不再多展开这部分内容了，等遇到了它们的具体应用时，我们再详细介绍它们。</p>\n<h1 id=\"4总结\">4.总结</h1>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>原理</th>\n<th>比喻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>图像风格转换</td>\n<td>利用预训练卷积神经网络提取图像内容和风格特征，通过优化生成图像使其内容保持不变、风格逼近目标图像</td>\n<td>网络像一把刻好的尺子，生成图像像橡皮泥，通过不断调整橡皮泥使其符合尺子刻度</td>\n</tr>\n<tr>\n<td>代价函数（总）</td>\n<td>将内容代价与风格代价加权求和：<span class=\"math inline\">\\(\\mathcal{J}_{\\text{total}} = \\alpha \\mathcal{J}_{\\text{content}} + \\beta \\mathcal{J}_{\\text{style}}\\)</span></td>\n<td>衡量生成图像与目标图像“差距”的指标，越小越匹配</td>\n</tr>\n<tr>\n<td>内容代价函数</td>\n<td>衡量生成图像与内容图像在中间层特征空间的差异，通常使用平方和计算</td>\n<td>找到“中间尺度”既保留结构，又不过于抽象，就像兼顾局部纹理与整体概念</td>\n</tr>\n<tr>\n<td>内容特征选择</td>\n<td>使用中间层特征，既保留全局结构，又不过分关注局部纹理</td>\n<td>不希望只对纹理计较，也不希望只看整体概念</td>\n</tr>\n<tr>\n<td>风格代价函数</td>\n<td>利用Gram矩阵刻画各特征通道之间的相关性，通过平方差和加权求和计算</td>\n<td>Gram矩阵像统计特征共现的表格，不关心位置，只关注不同特征同时出现的强度</td>\n</tr>\n<tr>\n<td>Gram矩阵</td>\n<td>对每对特征通道，在所有空间位置上求乘积并求和，归一化后得到</td>\n<td>特征通道之间的“共现强度矩阵”，类似观察特征是否喜欢一起出现</td>\n</tr>\n<tr>\n<td>单层 vs 多层风格代价</td>\n<td>单层只考虑某一层特征，多层将多层风格代价加权求和，更全面捕捉风格</td>\n<td>低层捕捉纹理与颜色，高层捕捉整体图案与结构</td>\n</tr>\n<tr>\n<td>一维卷积</td>\n<td>在序列方向上滑动卷积核，处理序列数据如时间序列或文本</td>\n<td>像沿着时间轴观察和提取局部模式</td>\n</tr>\n<tr>\n<td>三维卷积</td>\n<td>在高、宽、深/时间三个维度上滑动卷积核，处理视频或体数据</td>\n<td>像在空间和时间上同时观察动态或三维结构</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 21:13</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Goblinscholar\">哥布林学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">2</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}