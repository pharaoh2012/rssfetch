{"title":"主页 - 博客园","link":"https://www.cnblogs.com/","description":"主页 - 博客园 RSS","language":"zh-cn","lastBuildDate":"2025-12-23T04:15:30.597Z","items":[{"title":"论索引的重要性","link":"https://www.cnblogs.com/zhuancloud/p/19386304","description":"<h1 class=\"postTitle\">\n                <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zhuancloud/p/19386304\" title=\"发布于 2025-12-23 12:14\">\n    <span role=\"heading\" aria-level=\"2\">论索引的重要性</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div id=\"cnblogs_post_body\" class=\"blogpost-body blogpost-body-html\">\n<h1>开篇小测验</h1>\n<p>下面这样一个小SQL 你该怎么样添加最优索引</p>\n<p>两个表上现在只有聚集索引</p>\n<p>bigproduct 表上已经有聚集索引 ProductID</p>\n<p>bigtransactionhistory 表上已经有聚集索引 TransactionID</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/980582/202512/980582-20251223120456999-725818889.png\" alt=\"b44130128656738d3f4b780d89ab2eac\" loading=\"lazy\"></p>\n<p>&nbsp;</p>\n<p>你是否一眼就能看出来呢？</p>\n<p>答案将在文章中逐步揭晓~~~</p>\n<p><span style=\"font-size: 18px; color: rgba(128, 0, 128, 1)\">简单粗暴的添加索引</span></p>\n<p>首先我们看一下没有优化前的执行计划</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/980582/202512/980582-20251223120641375-577465385.png\" alt=\"ca7e2b86cd792b5d4d254d5f5d94ad86\" loading=\"lazy\"></p>\n<p>&nbsp;</p>\n<p>clustered index scan 这其实就是表扫描，不是table scan 只是因为表上有聚集索引<br><br></p>\n<p>可以看出这个查询俩表都使用了表扫描！</p>\n<p><strong>where </strong><strong>条件添加索引</strong></p>\n<p>首先大多数人都知道 where 条件中的字段需要添加索引! 我们添加一下看看效果创建</p>\n<p>在 bigproduct 表上创建 name 列索引，在bigtransactionhistory表上创建TransactionDate 列索引。</p>\n<p>再次执行语句看一下效果！</p>\n<p>&nbsp;</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/980582/202512/980582-20251223120724790-1339715259.jpg\" alt=\"530d49249ae3bf15365abcf4643f1f8c\" loading=\"lazy\"></p>\n<p>&nbsp;</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/980582/202512/980582-20251223120744822-2049170817.png\" alt=\"fabf0aadf5ac5e8beb9fac5fc3003a45\" loading=\"lazy\"></p>\n<p>&nbsp;</p>\n<p>添加where索引以后可以看到以下几个现象</p>\n<ul class=\"list-paddingleft-1\">\n<li>\n<p>bigproduct 从原来的clustered index scan 变成 index seek</p>\n</li>\n<li>\n<p>另外多出来个KEY Lookup(clustered)</p>\n</li>\n<li>\n<p>bigproduct 上添加的索引起了作用，逻辑读bigproduct 由 601 变成10。</p>\n</li>\n<li>\n<p>bigtransactionhistory 没啥变化啊还是clustered index scan</p>\n</li>\n</ul>\n<p>解释一下出现的现象 ：首先一点bigproduct 边添加的where条件索引，起到了作用，执行的时候不是全表扫描了，逻辑读有明显的下降，出现的 KEY Lookup 是因为选择（select）的列，在索引中没有，而需要通过聚集索引再查找一次，再找一次也意味着多一部分开销！那么同样添加了where 条件索引的bigtransactionhistory表为什么没起作用呢？那是因为SQL优化器在选择计划的时候认为，不使用TransactionDate 列索引查找效率会更好!</p>\n<p>真的么？我们来验证一下，通过指定选择索引，来让优化器选择索引查找！</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/980582/202512/980582-20251223120817365-1926397905.jpg\" alt=\"a27b79c2f98f8e77339b6c2820691ba2\" loading=\"lazy\"></p>\n<p>&nbsp;</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/980582/202512/980582-20251223120831833-1982298943.png\" alt=\"f05e632e55f36c304b12af2bd3444c92\" loading=\"lazy\"></p>\n<p>&nbsp;强制使用索引以后，可以看出逻辑读由 14W 变成1961W，语句时间也变得很长，这就是优化器为什么不选用你加的索引！优化器还是很智能的吧。</p>\n<p>高能预警：优化器可不是什么时候都这么智能的...由于缓存计划或优化器抽风等原因，也会出现优化器用了这种索引，导致你的语句奇慢，读飙升直接影响到你的内存、磁盘、CPU资源！另外如果这样一条语句是系统中一条很频繁运行的语句，你的系统就挂了！没错就挂了！这就是开篇抛出的问题就是因为一条语句！</p>\n<p><strong>消灭</strong><strong>Key Lookup </strong><strong>添加</strong><strong>select </strong><strong>字段</strong></p>\n<p>这就是传说中的覆盖索引！</p>\n<p>看到执行计划中存在Key Lookup　而且消耗占比很高，如上面强制索引的计划，那么我们就要想到的 在索引中包含那些SELECT 的列！如果消耗低，逻辑读少，如上面bigproduct 表中的Key Lookup 就可以忽略（如果你追求完美，也一样优化就可以了）。</p>\n<p>包含列的图形化创建：@秋仙 特意给你的说明</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/980582/202512/980582-20251223120901669-431129901.png\" alt=\"d3e35652e888862bf5ce375e2a02fb82\" loading=\"lazy\"></p>\n<p>语句创建就是：</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/980582/202512/980582-20251223120924631-188723058.png\" alt=\"bbe701c20ca02bfb982aa5c37db8cfd8\" loading=\"lazy\"></p>\n<p>下面我们添加一下看看效果：</p>\n<p>&nbsp;</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/980582/202512/980582-20251223121001485-1463459080.jpg\" alt=\"90d3a313bebda1b8554337aa18862e91\" loading=\"lazy\"></p>\n<p>&nbsp;</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/980582/202512/980582-20251223121015442-2136458470.png\" alt=\"f27448095c8648b6a608a7eb6c3dd77e\" loading=\"lazy\"></p>\n<p>&nbsp;</p>\n<p>添加select 索引字段后可以看出的现象：</p>\n<ul class=\"list-paddingleft-1\">\n<li>\n<p>优化器自己选择了index seek</p>\n</li>\n<li>\n<p>bigtransactionhistory占比最高的Key Lookup消失了</p>\n</li>\n<li>\n<p>逻辑读由原来无索引的14W变成1W</p>\n</li>\n<li>\n<p>bigtransactionhistory表还提示缺少索引？</p>\n</li>\n</ul>\n<p>通过优化索引添加select 字段，我们看出语句又一次得到了提升bigtransactionhistory 从表扫描变成索引查找，逻辑读由14W变成 1W！这是一个质的飞跃啊！</p>\n<p>CREATE NONCLUSTERED INDEXTransactionDate包含ProductID_QuantityON[dbo].[bigTransactionHistory] ([TransactionDate])------INCLUDE 就是包含列INCLUDE ([ProductID],[Quantity])GO</p>\n<p>那为什么还提示缺少索引呢？创建一下试试吧！</p>\n<p><strong>索引再优化加入表关联列</strong></p>\n<p>按照提示我们创建索引：和上一个索引的不同 ProductID 列由包含列变成了索引列！</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/980582/202512/980582-20251223121101411-980327210.png\" alt=\"287b334380012753900062827964990f\" loading=\"lazy\"></p>\n<p>&nbsp;</p>\n<p>我们看一下效果：</p>\n<p>&nbsp;</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/980582/202512/980582-20251223121123047-1821728972.png\" alt=\"88760d389647159b33b8e1ce933c2fa0\" loading=\"lazy\"></p>\n<p>&nbsp;</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/980582/202512/980582-20251223121135989-2002256099.png\" alt=\"aa14f00db9b127ff440e7e6ae7713bba\" loading=\"lazy\"></p>\n<p>&nbsp;</p>\n<p>再次优化索引以后可以看到以下几个现象</p>\n<ul class=\"list-paddingleft-1\">\n<li>\n<p>bigtransactionhistory表还是索引查找index seek</p>\n</li>\n<li>\n<p>bigtransactionhistory依然没有了Key Lookup</p>\n</li>\n<li>\n<p>两表关联的hash join 变成了nested loops</p>\n</li>\n<li>\n<p>并行计划变成了串行</p>\n</li>\n<li>\n<p>逻辑读又从1W 变成18</p>\n</li>\n</ul>\n<p>又一次质的飞跃！读从原来的14W 变成1W 又变成18，这样大大减少了内存和IO的消耗，另外并行计划也变成了串行，无疑又减少了大量CPU的消耗！语句时间，我想这里就不用多说了吧？</p>\n<p>高能预警：这里所说的hash join，并行变串行，不懂的朋友可以在百度自行学习，这里只是针对当前语句的情况，不能一概而论！</p>\n<p><strong>精简你的索引</strong></p>\n<p>大家都知道，索引会导致update、insert、delete操作变慢！那么尽量精简你的索引就是一个很重要的话题了！</p>\n<p>上面的优化过程中我们创建了几个索引，以bigTransactionHistory为例来看一下：</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/980582/202512/980582-20251223121217953-1004101723.png\" alt=\"a10260f123cbe86d9d08f309403aa708\" loading=\"lazy\"></p>\n<p>&nbsp;</p>\n<p>脚本这里就不贴了，其实我们最后创建的索引 ProductID_TransactionDate包含Quantity 已经包含了前两个索引，而且可以说无论任何类似语句都使用ProductID_TransactionDate包含Quantity 就可以了！</p>\n<p>那么我们就可以清除前两个索引！</p>\n<p>至此语句的优化算是结束了，留下的就是bigproduct 依然有一个Key Lookup可以优化，可以仿照上面的继续优化，这里就不细说了。</p>\n<p>这就是索引的重要性！</p>\n<p>开篇小测试你做对了么？如果没做对那么这么请你自行模拟一个场景再现本篇的话题吧！</p>\n<h1>总结</h1>\n<p>数据库整体缓慢往往都是因为索引问题导致的，不要小看一条语句的威力，一条高频的语句足可以让你的数据库彻底无法工作。在和大量的运维人员交流的过程中发现，对于索引的重要性恰恰没有足够的重视，一提到优化就是修改SQL语句、读写分离、分布式数据库等舍近求远的方案，优化索引才是对数据库最高性价比的优化。</p>\n<p>&nbsp;</p>\n<p>北京格瑞趋势科技有限公司是聚焦于数据服务的高新技术企业，成立于2008年，创始团队及核心技术人员来自微软和雅虎。微软数据平台长期合作伙伴，卫宁健康数据平台战略合作伙伴。通过产品+服务双轮驱动的业务模式，14年间累计服务4000+客户，覆盖互联网、市政、交通、电信、医疗、教育、电力、制造业等各个领域。</p>\n<p>&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\" data-last-update-days=\"0\" data-date-updated=\"2025-12-23 12:14\">2025-12-23 12:14</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zhuancloud\">格瑞趋势技术团队</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19386304);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19386304', targetLink: 'https://www.cnblogs.com/zhuancloud/p/19386304', title: '论索引的重要性' })\">举报</a>\n</div>","guid":{"value":"979c570a7d233b63a5c1ee0612e35918"}},{"title":"反向传播","link":"https://www.cnblogs.com/tokepson/p/19364232","description":"<h1 class=\"postTitle\">\n                <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/tokepson/p/19364232\" title=\"发布于 2025-12-23 11:31\">\n    <span role=\"heading\" aria-level=\"2\">反向传播</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\n<blockquote>\n<p>懂了懂了，还是这样好理解。。。。那么反向传播的计算呢？通过y1, y2, y3 求出x1 ?</p>\n</blockquote>\n<hr>\n<p>太好了！现在我们来推导<strong>反向传播</strong>的计算。这是深度学习中最核心的部分！</p>\n<hr>\n<h2 id=\"1-问题设定\"><strong>1. 问题设定</strong></h2>\n<p>我们有一个简单的三层结构：</p>\n<pre><code>输入 x → 线性层（得 z）→ softmax → 交叉熵损失 L\n</code></pre>\n<p>其中：</p>\n<ul>\n<li>$ z = Wx + b $（为了简化，我们先只考虑从 z 开始的反向传播）</li>\n<li>$ p = \\text{softmax}(z) $</li>\n<li>$ L = -\\sum y_i \\log p_i $</li>\n</ul>\n<p>我们要求 $ \\frac{\\partial L}{\\partial z_j} $，也就是损失对<strong>原始输出 z</strong> 的梯度。</p>\n<hr>\n<h2 id=\"2-已知关系\"><strong>2. 已知关系</strong></h2>\n<p>设类别数 $ C = 3 $，则：</p>\n<p></p><div class=\"math display\">\\[p_i = \\frac{e^{z_i}}{\\sum_{k=1}^C e^{z_k}}\n\\]</div><p></p><p></p><div class=\"math display\">\\[L = -\\sum_{i=1}^C y_i \\log p_i\n\\]</div><p></p><hr>\n<h2 id=\"3-计算梯度-\"><strong>3. 计算梯度</strong> <span class=\"math inline\">\\(\\frac{\\partial L}{\\partial z_j}\\)</span></h2>\n<p>这是一个<strong>非常重要的结果</strong>，也是 softmax 与交叉熵结合的美妙之处。</p>\n<p><strong>推导过程</strong>：</p>\n<p></p><div class=\"math display\">\\[\\frac{\\partial L}{\\partial z_j} = \\sum_{i=1}^C \\frac{\\partial L}{\\partial p_i} \\cdot \\frac{\\partial p_i}{\\partial z_j}\n\\]</div><p></p><p>第一步：<span class=\"math inline\">\\(\\frac{\\partial L}{\\partial p_i} = -\\frac{y_i}{p_i}\\)</span></p>\n<p>第二步：需要计算 <span class=\"math inline\">\\(\\frac{\\partial p_i}{\\partial z_j}\\)</span>，分两种情况：</p>\n<ul>\n<li><strong>当 $ i = j $时</strong>：</li>\n</ul>\n<p></p><div class=\"math display\">\\[\\frac{\\partial p_i}{\\partial z_i} = p_i(1 - p_i)\n\\]</div><p></p><ul>\n<li><strong>当 $ i \\neq j $时</strong>：</li>\n</ul>\n<p></p><div class=\"math display\">\\[\\frac{\\partial p_i}{\\partial z_j} = -p_i p_j\n\\]</div><p></p><p>现在代入：</p>\n<p></p><div class=\"math display\">\\[\\frac{\\partial L}{\\partial z_j} = \\sum_{i=1}^C \\left( -\\frac{y_i}{p_i} \\right) \\cdot \\frac{\\partial p_i}{\\partial z_j}\n\\]</div><p></p><p>分开求和：</p>\n<ol>\n<li>当 <span class=\"math inline\">\\(i = j\\)</span> 时：项为 <span class=\"math inline\">\\(-\\frac{y_j}{p_j} \\cdot p_j(1-p_j) = -y_j(1-p_j)\\)</span></li>\n<li>当 <span class=\"math inline\">\\(i \\neq j\\)</span> 时：项为 <span class=\"math inline\">\\(-\\frac{y_i}{p_i} \\cdot (-p_i p_j) = y_i p_j\\)</span></li>\n</ol>\n<p>所以：</p>\n<p></p><div class=\"math display\">\\[\\frac{\\partial L}{\\partial z_j} = -y_j(1-p_j) + \\sum_{i \\neq j} y_i p_j\n\\]</div><p></p><p>注意 <span class=\"math inline\">\\(\\sum_{i \\neq j} y_i = 1 - y_j\\)</span>（因为 y 是 one-hot，总和为1）</p>\n<p>因此：</p>\n<p></p><div class=\"math display\">\\[\\frac{\\partial L}{\\partial z_j} = -y_j + y_j p_j + p_j(1 - y_j)\n\\]</div><p></p><p></p><div class=\"math display\">\\[= -y_j + p_j(y_j + 1 - y_j)\n\\]</div><p></p><p></p><div class=\"math display\">\\[= p_j - y_j\n\\]</div><p></p><hr>\n<h2 id=\"4-最终简洁结果\"><strong>4. 最终简洁结果</strong></h2>\n<p></p><div class=\"math display\">\\[\\boxed{\\frac{\\partial L}{\\partial z_j} = p_j - y_j}\n\\]</div><p></p><p><strong>太漂亮了！</strong> 这个结果意味着：</p>\n<ul>\n<li>梯度 = <strong>预测概率 - 真实标签</strong></li>\n<li>对于真实类别（<span class=\"math inline\">\\(y_j=1\\)</span>）：梯度 = <span class=\"math inline\">\\(p_j - 1\\)</span>（负数，需要增大 <span class=\"math inline\">\\(z_j\\)</span>）</li>\n<li>对于其他类别（<span class=\"math inline\">\\(y_j=0\\)</span>）：梯度 = <span class=\"math inline\">\\(p_j - 0 = p_j\\)</span>（正数，需要减小 <span class=\"math inline\">\\(z_j\\)</span>）</li>\n</ul>\n<hr>\n<h2 id=\"5-例子验证\"><strong>5. 例子验证</strong></h2>\n<p>用我们刚才的例子：</p>\n<ul>\n<li>$ z = [3.0, 1.0, -1.0] $</li>\n<li>$ y = [1, 0, 0] $</li>\n<li>$ p = [0.88, 0.12, 0.00] $</li>\n</ul>\n<p>梯度：</p>\n<p></p><div class=\"math display\">\\[\\frac{\\partial L}{\\partial z} = p - y = [0.88-1, 0.12-0, 0.00-0] = [-0.12, 0.12, 0.00]\n\\]</div><p></p><p><strong>解释</strong>：</p>\n<ul>\n<li>对真实类别（猫）：梯度 -0.12 → 需要稍微增大 <span class=\"math inline\">\\(z_0\\)</span></li>\n<li>对其他类别（狗）：梯度 +0.12 → 需要减小 <span class=\"math inline\">\\(z_1\\)</span></li>\n<li>对鸟：梯度 0 → 不需要改变</li>\n</ul>\n<hr>\n<h2 id=\"6-扩展到-x-的梯度\"><strong>6. 扩展到 x 的梯度</strong></h2>\n<p>如果我们有 $ z = Wx + b $，那么：</p>\n<p></p><div class=\"math display\">\\[\\frac{\\partial L}{\\partial x} = W^T \\cdot \\frac{\\partial L}{\\partial z}\n\\]</div><p></p><p>因为 $ \\frac{\\partial z}{\\partial x} = W^T $。</p>\n<hr>\n<h2 id=\"总结反向传播流程\"><strong>总结反向传播流程</strong>：</h2>\n<ol>\n<li>前向计算：$ z → softmax → p → L = -\\sum y_i \\log p_i $</li>\n<li>反向传播：\n<ul>\n<li>$ \\frac{\\partial L}{\\partial z} = p - y $（极其简洁！）</li>\n<li>然后继续向后传播到 $ W, b, x $</li>\n</ul>\n</li>\n</ol>\n<p>这就是为什么 softmax + 交叉熵在深度学习中被广泛使用——梯度计算既简洁又数值稳定！</p>\n<hr>\n<h2 id=\"相关参考\">相关参考：</h2>\n<ul>\n<li><a href=\"http://neuralnetworksanddeeplearning.com/chap2.html\" target=\"_blank\" rel=\"noopener nofollow\">How the backpropagation algorithm works</a></li>\n<li><a href=\"https://blog.csdn.net/qq_36803941/article/details/136191848?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EPaidSort-2-136191848-blog-107242858.235%5Ev43%5Epc_blog_bottom_relevance_base5&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EPaidSort-2-136191848-blog-107242858.235%5Ev43%5Epc_blog_bottom_relevance_base5&amp;utm_relevant_index=4\" target=\"_blank\" rel=\"noopener nofollow\">深度学习：完全理解反向传播算法（一）</a></li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\" data-last-update-days=\"0\" data-date-updated=\"2025-12-23 11:31\">2025-12-23 11:31</span>&nbsp;\n<a href=\"https://www.cnblogs.com/tokepson\">TokE648</a>&nbsp;\n阅读(<span id=\"post_view_count\">8</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19364232);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19364232', targetLink: 'https://www.cnblogs.com/tokepson/p/19364232', title: '反向传播' })\">举报</a>\n</div>","guid":{"value":"9582a51fcca2e442dfadaa0af5ec5026"}},{"title":"使用Vite+ Lit 构建webcomponent 组件","link":"https://www.cnblogs.com/mykai/p/19385542","description":"<h1 class=\"postTitle\">\n                <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/mykai/p/19385542\" title=\"发布于 2025-12-23 11:08\">\n    <span role=\"heading\" aria-level=\"2\">使用Vite+ Lit 构建webcomponent 组件</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\n<h2 id=\"vitelitjs-构建web-component\">Vite+Lit.js 构建Web Component</h2>\n<p><strong>web component</strong>作为前一个时代的方案，在特定场景下确有不一样的妙用<br>\n，在维护<strong>前后端不分离</strong>的项目，web component 是为数不多的选择，整理一下使用Lit 构建自己的web component组件库为传统项目提提速的过程。</p>\n<h3 id=\"使用vite-创建项目\">使用vite 创建项目</h3>\n<p>Vite 里带了Lit模板，我们这里选用Lit+ts模板<br>\n<code>pnpm create vite</code></p>\n<h5 id=\"目录结构\">目录结构</h5>\n<ul>\n<li>src\n<ul>\n<li>hello\n<ul>\n<li>index.ts // 具体组件</li>\n</ul>\n</li>\n<li>index.ts // 组件收集</li>\n</ul>\n</li>\n<li>vite.config.ts 打包配置！</li>\n<li>index.ts // 组件注入!</li>\n</ul>\n<blockquote>\n<p>适用于构建基础组件库，不适用太复杂的逻辑，利用web-components 自带的样式隔离等，可以很好的避免被上下文干扰。</p>\n</blockquote>\n<h3 id=\"构建打包项目\">构建打包项目</h3>\n<h5 id=\"编写入口文件注入组件\">编写入口文件，注入组件</h5>\n<pre><code>import * as allComponents from './src/main.ts'\n\nconst components = allComponents\nconst toKebabCase = (str: string): string =&gt; {\n  return str\n    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')\n    .replace(/([A-Z])([A-Z])(?=[a-z])/g, '$1-$2')\n    .toLowerCase()\n}\nif (typeof window !== 'undefined') {\n  (window as any).WebComponents = components\n  \n  Object.entries(components).forEach(([name, component]) =&gt; {\n    const elementName = toKebabCase(name)\n    const fullElementName = 'xk-' + elementName // 这里定义了全局组件名开头\n\n    if (!customElements.get(fullElementName)) {\n      customElements.define(fullElementName, component)\n    } \n  })\n}\n</code></pre>\n<blockquote>\n<p>除了组件，也可以在这里注入全局方法等</p>\n</blockquote>\n<h5 id=\"构建打包脚本\">构建打包脚本</h5>\n<p>使用vite 来构建很简单。</p>\n<pre><code class=\"language-ts\">import { defineConfig } from 'vite'\nimport { resolve } from 'path'\nimport { fileURLToPath, URL } from 'node:url'\n\nexport default defineConfig({\n  build: {\n    lib: {\n      entry: resolve(fileURLToPath(new URL('.', import.meta.url)), 'index.ts'),\n      name: 'WebComponents',\n      fileName: (format) =&gt; `lit-web-components.${format === 'es' ? 'js' : 'umd.js'}`,\n      formats: ['es', 'umd']\n    },\n    outDir:\"../dist/js\", // 打包输出目录\n    rollupOptions: {\n      output: {\n        extend: true,\n        assetFileNames: 'lit-web-components.[ext]',\n        manualChunks: undefined,\n        compact: true, // 紧凑输出\n      },\n      treeshake: {\n        moduleSideEffects: false,\n        propertyReadSideEffects: false,\n        tryCatchDeoptimization: false\n      },\n    },\n    sourcemap: false, // 移除 source map\n    minify: 'terser',\n    target: 'es2022',\n    terserOptions: {\n      compress: {\n        drop_console: true, // 移除所有 console\n        drop_debugger: true, // 移除 debugger\n        pure_funcs: ['console.log', 'console.info', 'console.debug', 'console.warn'], // 移除指定的纯函数\n        unused: true, // 移除未使用的代码\n        dead_code: true, // 移除死代码\n        conditionals: true, // 优化条件语句\n        evaluate: true, // 计算常量表达式\n        booleans: true, // 优化布尔值\n        sequences: true, // 连接连续语句\n        switches: true, // 移除重复的 switch 分支\n        reduce_vars: true, // 减少变量引用\n        collapse_vars: true, // 内联变量\n        passes: 3 // 多次压缩以获得更好的效果\n      },\n      mangle: {\n        toplevel: true, // 混淆顶级作用域\n        reserved: ['lit', 'LitElement', 'html', 'css', 'customElements'] // 保留重要的库名称\n      },\n      format: {\n        comments: false // 移除所有注释\n      }\n    }\n  },\n  resolve: {\n    alias: {\n      '@': resolve(fileURLToPath(new URL('.', import.meta.url)), 'src')\n    }\n  }\n}) \n</code></pre>\n<h3 id=\"编写一个简单的组件\">编写一个简单的组件</h3>\n<blockquote>\n<p>src/hello/index.ts</p>\n</blockquote>\n<pre><code class=\"language-ts\">import { LitElement,html,css } from \"lit\";\nimport { property } from \"lit/decorators.js\";\n\nexport class Hello extends LitElement{\n    @property({type:String})\n    text='Hello,Web Component'\n\n    @property({type:String})\n    color='#222'\n    static style=css`\n    :host{\n\n    }\n    `\n    render(){\n        return html`\n            &lt;span style=\"color:${this.color};\"&gt;${this.text}&lt;/span&gt;\n        `\n    }\n}\n</code></pre>\n<h5 id=\"在maints-里导入\">在main.ts 里导入</h5>\n<pre><code class=\"language-ts\">export {Hello} from \"./hello/index\"\n</code></pre>\n<h4 id=\"打包输出结果\">打包输出结果</h4>\n<p>lit-web-components.umd.js  16.92 kB │ gzip: 6.44 kB<br>\n注意：这里包含了lit 本身这个库，</p>\n<h3 id=\"使用\">使用</h3>\n<blockquote>\n<p>打包构建带入lit本身的库（<strong>建议</strong>） ，使用就很简单了</p>\n</blockquote>\n<pre><code> 引入\n&lt;script src=\"./js/lit-web-components.umd.js\"&gt;&lt;/script&gt;    \n使用\n&lt;xk-hello color=\"red\"&gt; &lt;/xk-hello&gt; &lt;/br&gt;\n&lt;xk-hello text=\"hello world\"&gt; &lt;/xk-hello&gt;\n\n</code></pre>\n<h4 id=\"输出效果和dom\">输出效果和Dom</h4>\n<p><img src=\"https://img2024.cnblogs.com/blog/2152650/202512/2152650-20251223104127644-462548091.png\" alt=\"image\" loading=\"lazy\"></p>\n<h3 id=\"实际应用和思考\">实际应用和思考</h3>\n<p>web component 可以为传统的老项目注入现代化开发能力，Lit 则大大减轻了这个过程，经过我在项目中的深入使用，明显带来的好处</p>\n<ul>\n<li><strong>样式隔离</strong>： 自带的样式隔离和行为，不会被之前的公共css等影响。减少了<strong>心智负担</strong>。</li>\n<li><strong>复用</strong>：沉淀了一大批组件，快速构建页面，统一了整站的交互性和ui 一致性。</li>\n<li><strong>跨框架</strong>: 后续升级框架时，之前的组件依然能用。减少了升级成本，还能保持原来的ui细节。</li>\n</ul>\n<h3 id=\"缺点\">缺点</h3>\n<ul>\n<li>额外的学习成本：可以使用ai 来开发维护</li>\n<li>SEO影响 对于组件内部的一些隐藏属性，可能会影响SEO：建议增加描述，关键内容通过Slot可以消除</li>\n</ul>\n<h2 id=\"总结\">总结</h2>\n<p>如果无法对大型项目重构，大型项目开发起来又很痛苦，尝试webcomponent 方案吧。升级平滑，组件复用，还有样式隔离，插槽等现代化概念。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\" data-last-update-days=\"0\" data-date-updated=\"2025-12-23 11:08\">2025-12-23 11:08</span>&nbsp;\n<a href=\"https://www.cnblogs.com/mykai\">MyKai</a>&nbsp;\n阅读(<span id=\"post_view_count\">23</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19385542);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19385542', targetLink: 'https://www.cnblogs.com/mykai/p/19385542', title: '使用Vite+ Lit 构建webcomponent 组件' })\">举报</a>\n</div>","guid":{"value":"2d17e781aad3c2b42395cebd1d0ec0ba"}},{"title":"vite7+deepseek流式ai模板|vue3.5+deepseek3.2+markdown打字输出ai助手","link":"https://www.cnblogs.com/xiaoyan2017/p/19385909","description":"<h1 class=\"postTitle\">\n                <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaoyan2017/p/19385909\" title=\"发布于 2025-12-23 11:06\">\n    <span role=\"heading\" aria-level=\"2\">vite7+deepseek流式ai模板|vue3.5+deepseek3.2+markdown打字输出ai助手</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div id=\"cnblogs_post_body\" class=\"blogpost-body blogpost-body-html\">\n<p><span style=\"font-size: 18px; font-family: 宋体, &quot;Songti SC&quot;; color: rgba(149, 20, 234, 1)\">2026最新款爆肝<span style=\"background-color: rgba(251, 217, 250, 1)\">vite7.2+deepseek-v3.2+vant4+markdown</span>流式打字输出AI对话模板。</span></p>\n<p><span style=\"font-size: 12px\"><strong>vue3-mobile-deepseek</strong>：基于<span style=\"background-color: rgba(204, 255, 204, 1)\">vue3.5+vite7.2+vant4+markdown+openai</span>深度集成<strong>deepseek-v3.2</strong>聊天大模型。支持<span style=\"background-color: rgba(255, 255, 153, 1)\"><strong>浅色+深色主题、stream流式输出、代码高亮、复制代码、katex公式、mermaid图表</strong></span>等功能。</span></p>\n<p><img alt=\"未标题-2\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223095028752-606844753.png\" class=\"lazyload\"></p>\n<p><img alt=\"p2_2\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223095502103-480557904.gif\" class=\"lazyload\"></p>\n<h3>技术栈</h3>\n<ul>\n<li><span style=\"font-size: 12px\">编辑器：vscode</span></li>\n<li><span style=\"font-size: 12px\">技术框架：vite^7.2.4+vue^3.5.24+vue-router^4.6.4</span></li>\n<li><span style=\"font-size: 12px\">大模型框架：deepseek-v3.2 + openai</span></li>\n<li><span style=\"font-size: 12px\">UI组件库：vant^4.9.21 (有赞vue3移动端组件库)</span></li>\n<li><span style=\"font-size: 12px\">状态管理：pinia^3.0.4</span></li>\n<li><span style=\"font-size: 12px\">高亮插件：highlight.js^11.11.1</span></li>\n<li><span style=\"font-size: 12px\">markdown解析：markdown-it</span></li>\n<li><span style=\"font-size: 12px\">katex公式：@mdit/plugin-katex^0.24.1</span></li>\n<li><span style=\"font-size: 12px\">本地缓存：pinia-plugin-persistedstate^4.7.1</span></li>\n</ul>\n<p><img alt=\"p3\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223095301964-489954613.gif\" class=\"lazyload\"></p>\n<p><img alt=\"p5\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223100008878-2134758406.gif\" class=\"lazyload\"></p>\n<h3>功能性</h3>\n<ol>\n<li><span style=\"font-size: 12px\">Vue3.5+DeepSeek-V3.2流式打字输出效果</span></li>\n<li><span style=\"font-size: 12px\">基于Vite7.2构建，集成DeepSeek-Chat模型，性能更优，对话丝滑流畅</span></li>\n<li><span style=\"font-size: 12px\">支持各种代码高亮（<strong>复制代码+收缩功能</strong>），方便展示和分享代码片段</span></li>\n<li><span style=\"font-size: 12px\">支持输出<strong>Katex数学公式、Mermaid图表</strong></span></li>\n<li><span style=\"font-size: 12px\">使用vant4组件库，风格统一，时尚大气</span></li>\n<li><span style=\"font-size: 12px\">支持<strong>移动端+PC端750px像素</strong>适配</span></li>\n</ol>\n<p><img alt=\"未标题-4\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223100653751-1334957329.png\" class=\"lazyload\"></p>\n<blockquote>\n<h3><em>目前vue3-deepseek流式ai对话项目已经更新到我的原创作品集，欢迎下载使用。</em></h3>\n<p><span style=\"font-size: 12px\"><a href=\"https://mall.bilibili.com/neul-next/detailuniversal/detail.html?isMerchant=1&amp;page=detailuniversal_detail&amp;saleType=10&amp;itemsId=11721604&amp;loadingShow=1&amp;noTitleBar=1&amp;msource=merchant_share\" target=\"_blank\" rel=\"noopener nofollow\">Vue3+DeepSeek+Vant4智能聊天AI流式对话模板</a></span></p>\n</blockquote>\n<h3>项目框架结构</h3>\n<p><span style=\"font-size: 12px\">整个项目使用最新<strong>vite7.2</strong>搭建项目模板，遵循<span style=\"background-color: rgba(204, 255, 204, 1)\">vue3 setup</span>语法编码。</span></p>\n<p><img alt=\"360截图20251222233502584\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223101243748-1689844727.png\" class=\"lazyload\"></p>\n<h3>vue3环境变量.env配置</h3>\n<p><span style=\"font-size: 12px\">申请一个deepseek apikey，替换掉项目根目录下<strong>.env</strong>文件里的key即可畅快体验deepseek-v3.2流式输出功能。</span></p>\n<p><img alt=\"image\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223101608080-727506622.png\" class=\"lazyload\"></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1)\"># title\nVITE_APP_TITLE </span>= 'Vue3-DeepSeek-Chat'<span style=\"color: rgba(0, 0, 0, 1)\">\n\n# port 默认http:</span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">localhost:5173/</span>\nVITE_PORT = 3001<span style=\"color: rgba(0, 0, 0, 1)\">\n\n# 运行时自动打开浏览器\nVITE_OPEN </span>= <span style=\"color: rgba(0, 0, 255, 1)\">true</span><span style=\"color: rgba(0, 0, 0, 1)\">\n\n# 开启https\nVITE_HTTPS </span>= <span style=\"color: rgba(0, 0, 255, 1)\">false</span><span style=\"color: rgba(0, 0, 0, 1)\">\n\n# 是否删除生产环境 console\nVITE_DROP_CONSOLE </span>= <span style=\"color: rgba(0, 0, 255, 1)\">true</span><span style=\"color: rgba(0, 0, 0, 1)\">\n\n# DeepSeek API配置\nVITE_DEEPSEEK_API_KEY </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> 替换为你的 API Key\nVITE_DEEPSEEK_BASE_URL </span>= https:<span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">api.deepseek.com</span></pre>\n</div>\n<h3>项目入口main.js</h3>\n<div class=\"cnblogs_code\">\n<pre>import { createApp } from 'vue'<span style=\"color: rgba(0, 0, 0, 1)\">\nimport </span>'./style.scss'<span style=\"color: rgba(0, 0, 0, 1)\">\nimport App from </span>'./App.vue'\n\n<span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 引入路由/状态管理</span>\nimport Router from './router'<span style=\"color: rgba(0, 0, 0, 1)\">\nimport Pinia from </span>'./pinia'<span style=\"color: rgba(0, 0, 0, 1)\">\n\nimport Plugins from </span>'./plugins'<span style=\"color: rgba(0, 0, 0, 1)\">\n\nconst app </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> createApp(App)\n\napp\n.use(Router)\n.use(Pinia)\n.use(Plugins)\n.mount(</span>'#app')</pre>\n</div>\n<p><img alt=\"未标题-3\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223101727948-845129722.png\" class=\"lazyload\"></p>\n<p><img alt=\"015360截图20251222210330994\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223102137659-2062357504.png\" class=\"lazyload\"></p>\n<h3>项目布局结构</h3>\n<p><img alt=\"image\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223102355099-271621583.png\" class=\"lazyload\"></p>\n<p><span style=\"font-size: 12px\">整体项目结构分为<strong>顶部导航栏+聊天会话区+底部编辑栏</strong>三个模块。</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">template</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n  <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">div </span><span style=\"color: rgba(255, 0, 0, 1)\">class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"flexbox flex-col\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> style</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"height:100%;\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">Toolbar </span><span style=\"color: rgba(255, 0, 0, 1)\">:title</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"chatSession?.title\"</span> <span style=\"color: rgba(0, 0, 255, 1)\">/&gt;</span>\n\n    <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">div </span><span style=\"color: rgba(255, 0, 0, 1)\">class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"v3ai__scrollview flex1\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n      <span style=\"color: rgba(0, 128, 0, 1)\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1)\"> Chat对话 </span><span style=\"color: rgba(0, 128, 0, 1)\">--&gt;</span>\n      <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">div </span><span style=\"color: rgba(255, 0, 0, 1)\">v-if</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"chatSession &amp;&amp; !isEmpty(chatSession.data)\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"v3ai__chatbot\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> ref</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"scrollRef\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> @scroll</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"onScroll\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">div </span><span style=\"color: rgba(255, 0, 0, 1)\">class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"v3ai__chatbot-sessions\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span><span style=\"color: rgba(0, 0, 0, 1)\">\n          ...\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">div</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n        <span style=\"color: rgba(0, 128, 0, 1)\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1)\"> 滚动底部 </span><span style=\"color: rgba(0, 128, 0, 1)\">--&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">div </span><span style=\"color: rgba(255, 0, 0, 1)\">class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"v3ai__scrollbottom\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> :class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"{'is-bottom': reachBottom}\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> @click</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"scrollToBottom\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">i </span><span style=\"color: rgba(255, 0, 0, 1)\">class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"iconfont ai-arrD\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">i</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">div</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n      <span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">div</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n      <span style=\"color: rgba(0, 128, 0, 1)\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1)\"> 导语 </span><span style=\"color: rgba(0, 128, 0, 1)\">--&gt;</span>\n      <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">div </span><span style=\"color: rgba(255, 0, 0, 1)\">v-else class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"v3ai__chatbot-intro\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">i </span><span style=\"color: rgba(255, 0, 0, 1)\">class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"logo iconfont ai-deepseek\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">i</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">h3 </span><span style=\"color: rgba(255, 0, 0, 1)\">class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"name\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">span </span><span style=\"color: rgba(255, 0, 0, 1)\">class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"txt text-gradient\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>嗨~ Vue3-DeepSeek<span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">span</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">h3</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">p </span><span style=\"color: rgba(255, 0, 0, 1)\">class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"desc\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>你身边的智能小帮手，我可以帮你搜索、答疑、写作，请把你的任务交给我吧~<span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">p</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">div </span><span style=\"color: rgba(255, 0, 0, 1)\">class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"prompt\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n          <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">p </span><span style=\"color: rgba(255, 0, 0, 1)\">class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"tip\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">span</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>你可以这样问<span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">span</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">span</span><span style=\"color: rgba(255, 0, 0, 1)\"> @click</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"refreshPrompt\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>换一换<span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">i </span><span style=\"color: rgba(255, 0, 0, 1)\">class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"iconfont ai-shuaxin\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">i</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">span</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">p</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n          <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">ul </span><span style=\"color: rgba(255, 0, 0, 1)\">class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"list\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">li </span><span style=\"color: rgba(255, 0, 0, 1)\">v-for</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"(item,index) in promptList\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> :key</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"index\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n              <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">div </span><span style=\"color: rgba(255, 0, 0, 1)\">class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"txt\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> @click</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"changePrompt(item.prompt)\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>{{item.emoji}} {{item.prompt}}<span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">div</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">li</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n          <span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">ul</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">div</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n      <span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">div</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">div</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n\n    <span style=\"color: rgba(0, 128, 0, 1)\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1)\"> 编辑器 </span><span style=\"color: rgba(0, 128, 0, 1)\">--&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">ChatEditor </span><span style=\"color: rgba(255, 0, 0, 1)\">ref</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"editorRef\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> :value</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"promptValue\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> :reachBottom</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"reachBottom\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> :scrollBottom</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"scrollToBottom\"</span> <span style=\"color: rgba(0, 0, 255, 1)\">/&gt;</span>\n  <span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">div</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n<span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">template</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span></pre>\n</div>\n<p><img alt=\"p4\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223102648231-1480552356.gif\" class=\"lazyload\"></p>\n<h3>自定义katex公式+mermaid图表</h3>\n<p><span style=\"font-size: 12px\">在页面引入katex和mermaid插件。</span></p>\n<div class=\"cnblogs_code\">\n<pre>import { imgSize } from '@mdit/plugin-img-size' <span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 支持带尺寸图片</span>\nimport { katex } from \"@mdit/plugin-katex\"; <span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 支持数学公式</span>\nimport 'katex/dist/katex.min.css'\n<span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 渲染mermaid图表</span>\nimport { markdownItMermaidPlugin } from '@/components/markdown/plugins/mermaidPlugin'</pre>\n</div>\n<p>渲染markdown流式</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">Markdown\n  </span><span style=\"color: rgba(255, 0, 0, 1)\">:source</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"item.content\"</span><span style=\"color: rgba(255, 0, 0, 1)\">\n  :html</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"true\"</span><span style=\"color: rgba(255, 0, 0, 1)\">\n  :linkify</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"true\"</span><span style=\"color: rgba(255, 0, 0, 1)\">\n  :typographer</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"true\"</span><span style=\"color: rgba(255, 0, 0, 1)\">\n  :plugins</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"[\n    imgSize,\n    [katex, {delimiters: 'all'}],\n    [markdownItMermaidPlugin, { ... }]\n  ]\"</span><span style=\"color: rgba(255, 0, 0, 1)\">\n  @copy</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"onCopy\"</span>\n<span style=\"color: rgba(0, 0, 255, 1)\">/&gt;</span></pre>\n</div>\n<p>封装一个mermaid图表解析插件</p>\n<div class=\"cnblogs_code\">\n<pre>export const markdownItMermaidPlugin = (md, options) =&gt;<span style=\"color: rgba(0, 0, 0, 1)\"> {\n  const defaultFence </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> md.renderer.rules.fence\n  md.renderer.rules.fence </span>= (...args) =&gt;<span style=\"color: rgba(0, 0, 0, 1)\"> {\n    const [tokens, idx] </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> args\n    const token </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> tokens[idx]\n    const lang </span>= token.info.replace(/\\[.*\\]/, '').trim() || ''\n\n    <span style=\"color: rgba(0, 0, 255, 1)\">if</span>(lang === 'mermaid'<span style=\"color: rgba(0, 0, 0, 1)\">) {\n      const code </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> token.content.trim()\n      const hash </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> generateHash(code)\n      const uuid </span>= `${hash}-${Date.now()}-${Math.random().toString(36).substring(2, 9<span style=\"color: rgba(0, 0, 0, 1)\">)}`\n\n      </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 如果有缓存，加载缓存图表</span>\n      <span style=\"color: rgba(0, 0, 255, 1)\">if</span><span style=\"color: rgba(0, 0, 0, 1)\">(renderCache.has(hash)) {\n        </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> console.log('加载缓存mermaid图表')</span>\n        <span style=\"color: rgba(0, 0, 255, 1)\">return</span><span style=\"color: rgba(0, 0, 0, 1)\"> `\n          ${ defaultFence(...args) }\n          </span>&lt;div class=\"mermaid-container\"&gt;${renderCache.get(hash)}&lt;/div&gt;\n<span style=\"color: rgba(0, 0, 0, 1)\">        `\n      }\n</span>\n<span style=\"color: rgba(0, 0, 0, 1)\">      nextTickRender(uuid)\n\n      </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span><span style=\"color: rgba(0, 0, 0, 1)\"> `\n        ${ defaultFence(...args) }\n        </span>&lt;div class=\"mermaid-container\" id=\"${uuid}\" data-mermaid-hash=\"${hash}\" data-mermaid-code=\"${encodeURIComponent(code)}\"&gt;\n          &lt;div class=\"mermaid-loading\"&gt;📊Mermaid 图表加载中...&lt;/div&gt;\n        &lt;/div&gt;\n<span style=\"color: rgba(0, 0, 0, 1)\">      `\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span><span style=\"color: rgba(0, 0, 0, 1)\"> defaultFence(...args)\n  }\n\n  </span><span style=\"color: rgba(0, 0, 255, 1)\">function</span><span style=\"color: rgba(0, 0, 0, 1)\"> nextTickRender(containerId) {\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 如果容器存在，直接渲染</span>\n    <span style=\"color: rgba(0, 0, 255, 1)\">if</span><span style=\"color: rgba(0, 0, 0, 1)\">(document.getElementById(containerId)) {\n      renderMermaidDiagram(containerId)\n      </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span><span style=\"color: rgba(0, 0, 0, 1)\">\n    }\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 使用MutationObserver监听DOM更新</span>\n    const observer = <span style=\"color: rgba(0, 0, 255, 1)\">new</span> MutationObserver((mutations, ob) =&gt;<span style=\"color: rgba(0, 0, 0, 1)\"> {\n      const container </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> document.getElementById(containerId)\n      </span><span style=\"color: rgba(0, 0, 255, 1)\">if</span><span style=\"color: rgba(0, 0, 0, 1)\">(container) {\n        ob.disconnect()\n        renderMermaidDiagram(containerId)\n      }\n    })\n    observer.observe(document.body, {\n      childList: </span><span style=\"color: rgba(0, 0, 255, 1)\">true</span><span style=\"color: rgba(0, 0, 0, 1)\">,\n      subtree: </span><span style=\"color: rgba(0, 0, 255, 1)\">true</span><span style=\"color: rgba(0, 0, 0, 1)\">\n    })\n  }\n  \n  async </span><span style=\"color: rgba(0, 0, 255, 1)\">function</span><span style=\"color: rgba(0, 0, 0, 1)\"> renderMermaidDiagram(containerId) {\n    const container </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> document.getElementById(containerId)\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1)\">container) {\n      console.warn(`Mermaid container #${containerId} not found`)\n      </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span><span style=\"color: rgba(0, 0, 0, 1)\">\n    }\n  \n    const code </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> decodeURIComponent(container.dataset.mermaidCode)\n    const hash </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> container.dataset.mermaidHash\n\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1)\">code) {\n      </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span><span style=\"color: rgba(0, 0, 0, 1)\">\n    }\n\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 检查 mermaid 是否可用</span>\n    <span style=\"color: rgba(0, 0, 255, 1)\">if</span> (<span style=\"color: rgba(0, 0, 255, 1)\">typeof</span> window.mermaid === 'undefined'<span style=\"color: rgba(0, 0, 0, 1)\">) {\n      showError(container, </span>'Mermaid 库未加载!'<span style=\"color: rgba(0, 0, 0, 1)\">)\n      </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span><span style=\"color: rgba(0, 0, 0, 1)\">\n    }\n  \n    </span><span style=\"color: rgba(0, 0, 255, 1)\">try</span><span style=\"color: rgba(0, 0, 0, 1)\"> {\n      </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 配置 mermaid（如果还未配置）</span>\n      <span style=\"color: rgba(0, 0, 255, 1)\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1)\">window.mermaid.initialized) {\n        window.mermaid.initialize({\n          startOnLoad: </span><span style=\"color: rgba(0, 0, 255, 1)\">false</span><span style=\"color: rgba(0, 0, 0, 1)\">,\n          theme: </span>'default'<span style=\"color: rgba(0, 0, 0, 1)\">,\n          securityLevel: </span>'loose'<span style=\"color: rgba(0, 0, 0, 1)\">,</span><span style=\"color: rgba(0, 0, 0, 1)\">\n        })\n        window.mermaid.initialized </span>= <span style=\"color: rgba(0, 0, 255, 1)\">true</span><span style=\"color: rgba(0, 0, 0, 1)\">\n      }\n  \n      let svg\n  \n      </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 检查缓存</span>\n      <span style=\"color: rgba(0, 0, 255, 1)\">if</span><span style=\"color: rgba(0, 0, 0, 1)\">(renderCache.has(hash)) {\n        svg </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> renderCache.get(hash)\n      }</span><span style=\"color: rgba(0, 0, 255, 1)\">else</span><span style=\"color: rgba(0, 0, 0, 1)\"> {\n        const { isValid } </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> await verifyMermaid(code)\n\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">if</span>(!<span style=\"color: rgba(0, 0, 0, 1)\">isValid) {\n          showError(container, `</span>&lt;pre&gt;渲染语法错误：\\n${ code }\\n&lt;/pre&gt;`)\n          <span style=\"color: rgba(0, 0, 255, 1)\">return</span><span style=\"color: rgba(0, 0, 0, 1)\">\n        }\n\n        </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 使用唯一ID渲染(避免图表冲突)</span>\n        const {svg: renderedSvg} = await window.mermaid.render(`mermaid-<span style=\"color: rgba(0, 0, 0, 1)\">${containerId}`, code)\n        svg </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> renderedSvg\n        renderCache.set(hash, svg)\n      }\n\n      </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 更新容器内容</span>\n      container.innerHTML =<span style=\"color: rgba(0, 0, 0, 1)\"> svg\n      container.removeAttribute(</span>'data-mermaid-hash'<span style=\"color: rgba(0, 0, 0, 1)\">)\n      container.removeAttribute(</span>'data-mermaid-code'<span style=\"color: rgba(0, 0, 0, 1)\">)\n\n      </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 触发回调</span>\n      <span style=\"color: rgba(0, 0, 255, 1)\">if</span>(options?<span style=\"color: rgba(0, 0, 0, 1)\">.reachBottom) {\n        options</span>?.onRender?<span style=\"color: rgba(0, 0, 0, 1)\">.()\n      }\n    } </span><span style=\"color: rgba(0, 0, 255, 1)\">catch</span><span style=\"color: rgba(0, 0, 0, 1)\"> (error) {\n      console.error(</span>'Mermaid 渲染失败:'<span style=\"color: rgba(0, 0, 0, 1)\">, error)\n      showError(container, `</span>&lt;pre&gt;渲染图表时出错: \\n ${error.message}\\n&lt;/pre&gt;`)\n<span style=\"color: rgba(0, 0, 0, 1)\">    }\n  }\n}</span></pre>\n</div>\n<p><img alt=\"001360截图20251222193621367\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223103538181-209659643.png\" class=\"lazyload\"></p>\n<p><img alt=\"001360截图20251222193715663\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223103552216-1545436278.png\" class=\"lazyload\"></p>\n<p><img alt=\"002360截图20251222193937688\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223103612440-1597186190.png\" class=\"lazyload\"></p>\n<p><img alt=\"004360截图20251222194733968\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223103703349-1708451451.png\" class=\"lazyload\"></p>\n<p><img alt=\"007360截图20251222201320598\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223103717238-1614729462.png\" class=\"lazyload\"></p>\n<p><img alt=\"005360截图20251222194921868\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223103756064-1584305930.png\" class=\"lazyload\"></p>\n<p><img alt=\"006360截图20251222195419077\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223103816759-904170540.png\" class=\"lazyload\"></p>\n<p><img alt=\"009360截图20251222202431855\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223103852560-1881261749.png\" class=\"lazyload\"></p>\n<p><img alt=\"010360截图20251222203811582\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223103906992-975747501.png\" class=\"lazyload\"></p>\n<p><img alt=\"012360截图20251222204251442\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223103919280-136041562.png\" class=\"lazyload\"></p>\n<p><img alt=\"013360截图20251222204308421\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223104000680-1481731266.png\" class=\"lazyload\"></p>\n<p><img alt=\"014360截图20251222204432469\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223103939973-1523425268.png\" class=\"lazyload\"></p>\n<p>支持运行到pc端以750px宽度显示页面布局。</p>\n<p><img alt=\"015360截图20251222205211925\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223104049841-876451429.png\" class=\"lazyload\"></p>\n<p><img alt=\"015360截图20251222210111883\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223104115293-1216317344.png\" class=\"lazyload\"></p>\n<p><img alt=\"015360截图20251222210330996\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223104139497-1047165356.png\" class=\"lazyload\"></p>\n<p><img alt=\"image\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223104354641-1844699074.png\" class=\"lazyload\"></p>\n<h3>vue3集成deepseek流式打字输出</h3>\n<p><strong>非流式请求输出</strong></p>\n<div class=\"cnblogs_code\">\n<pre>const completion =<span style=\"color: rgba(0, 0, 0, 1)\"> await openai.chat.completions.create({\n  messages: [\n    {role: </span>'user'<span style=\"color: rgba(0, 0, 0, 1)\">, content: editorValue}\n  ],\n  model: </span>'deepseek-chat', <span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> deepseek-chat对话模型 deepseek-reasoner推理模型</span>\n  stream: <span style=\"color: rgba(0, 0, 255, 1)\">false</span>, <span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 流式输出</span>\n  max_tokens: 8192, <span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 限制一次请求中模型生成 completion 的最大 token 数(默认使用 4096)</span>\n  temperature: 0.4, <span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 严谨采样 越低越严谨(默认1)</span>\n<span style=\"color: rgba(0, 0, 0, 1)\">})\n</span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 处理返回数据</span>\nconsole.log(completion.choices[0].message.content)</pre>\n</div>\n<p><strong>流式请求输出</strong></p>\n<p>上下文多轮会话。</p>\n<div class=\"cnblogs_code\">\n<pre>const completion =<span style=\"color: rgba(0, 0, 0, 1)\"> await openai.chat.completions.create({\n  </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 单一会话</span>\n  <span style=\"color: rgba(0, 128, 0, 1)\">/*</span><span style=\"color: rgba(0, 128, 0, 1)\"> messages: [\n    {role: 'user', content: editorValue}\n  ], </span><span style=\"color: rgba(0, 128, 0, 1)\">*/</span>\n  <span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 多轮会话</span>\n  messages: props.multiConversation ? historySession.value : [{role: 'user'<span style=\"color: rgba(0, 0, 0, 1)\">, content: editorValue}],\n  model: </span>'deepseek-chat', <span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> deepseek-chat对话模型 deepseek-reasoner推理模型</span>\n  stream: <span style=\"color: rgba(0, 0, 255, 1)\">true</span>, <span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 流式输出</span>\n  max_tokens: 8192, <span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 限制一次请求中模型生成 completion 的最大 token 数(默认使用 4096)</span>\n  temperature: 0.4, <span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 严谨采样 越低越严谨(默认1)</span>\n})</pre>\n</div>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 处理流式输出</span>\n<span style=\"color: rgba(0, 0, 255, 1)\">for</span><span style=\"color: rgba(0, 0, 0, 1)\"> await (const chunk of completion) {\n  </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 检查是否已终止</span>\n  <span style=\"color: rgba(0, 0, 255, 1)\">if</span>(chatState.aborted) <span style=\"color: rgba(0, 0, 255, 1)\">break</span><span style=\"color: rgba(0, 0, 0, 1)\">\n\n  const content </span>= chunk.choices[0]?.delta?<span style=\"color: rgba(0, 0, 0, 1)\">.content\n  </span><span style=\"color: rgba(0, 0, 255, 1)\">if</span><span style=\"color: rgba(0, 0, 0, 1)\">(content) {\n    streamText </span>+=<span style=\"color: rgba(0, 0, 0, 1)\"> content\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 限制更新频率：每100ms最多更新一次</span>\n    const now =<span style=\"color: rgba(0, 0, 0, 1)\"> Date.now()\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">if</span>(now - lastUpdate &gt; 100<span style=\"color: rgba(0, 0, 0, 1)\">) {\n      lastUpdate </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> now\n      requestAnimationFrame(() </span>=&gt;<span style=\"color: rgba(0, 0, 0, 1)\"> {\n        </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> ...</span>\n<span style=\"color: rgba(0, 0, 0, 1)\">      })\n    }\n  }\n  </span><span style=\"color: rgba(0, 0, 255, 1)\">if</span>(chunk.choices[0]?.finish_reason === 'stop'<span style=\"color: rgba(0, 0, 0, 1)\">) {\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 确保最终内容完整更新</span>\n    ...<span style=\"color: rgba(0, 0, 0, 1)\">\n  }\n}</span></pre>\n</div>\n<p>综上就是vite7.2+vue3对接deepseek实现流式ai对话的一些项目分享，希望对大家有点帮助！</p>\n<p><strong>附上几个最新项目实例</strong></p>\n<blockquote>\n<p><span style=\"font-size: 12px\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaoyan2017/p/18853514\" target=\"_blank\">Uniapp-DeepSeek跨三端AI助手|uniapp+vue3+deepseek-v3流式ai聊天模板</a></span></p>\n<p><span style=\"font-size: 12px\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaoyan2017/p/18795796\" target=\"_blank\">vue3-webseek网页版AI问答|Vite6+DeepSeek+Arco流式ai聊天打字效果</a></span></p>\n<p><span style=\"font-size: 12px\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaoyan2017/p/19313982\" target=\"_blank\">最新版Flutter3.38+Dart3.10仿写抖音APP直播+短视频+聊天应用程序</a></span></p>\n<p><span style=\"font-size: 12px\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaoyan2017/p/19235565\" target=\"_blank\">Tauri2.9+Vue3桌面版OS系统|vite7+tauri2+arcoDesign电脑端os后台模板</a></span></p>\n<p><span style=\"font-size: 12px\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaoyan2017/p/19116145\" target=\"_blank\">electron38-admin桌面端后台|Electron38+Vue3+ElementPlus管理系统</a></span></p>\n<p><span style=\"font-size: 12px\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaoyan2017/p/19088804\" target=\"_blank\">Electron38-Wechat电脑端聊天|vite7+electron38仿微信桌面端聊天系统</a></span></p>\n<p><span style=\"font-size: 12px\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaoyan2017/p/19136187\" target=\"_blank\">Electron38-Vue3OS客户端OS系统|vite7+electron38+arco桌面os后台管理</a></span></p>\n<p><span style=\"font-size: 12px\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaoyan2017/p/19181509\" target=\"_blank\">Tauri2-Vite7Admin客户端管理后台|tauri2.9+vue3+element-plus后台系统</a></span></p>\n<p><span style=\"font-size: 12px\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaoyan2017/p/19157445\" target=\"_blank\">Tauri2.8+Vue3聊天系统|vite7+tauri2+element-plus客户端仿微信聊天程序</a></span></p>\n<p><span style=\"font-size: 12px\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaoyan2017/p/18962574\" target=\"_blank\">最新版uniapp+vue3+uv-ui跨三端短视频+直播+聊天【H5+小程序+App端】</a></span></p>\n<p><span style=\"font-size: 12px\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaoyan2017/p/19031695\" target=\"_blank\">最新版uni-app+vue3+uv-ui跨三端仿微信app聊天应用【h5+小程序+app端】</a></span></p>\n<p><span style=\"font-size: 12px\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaoyan2017/p/19018641\" target=\"_blank\">Flutter3-MacOS桌面OS系统|flutter3.32+window_manager客户端OS模板</a></span></p>\n</blockquote>\n<p><img alt=\"20190422-204556-c922\" width=\"121\" height=\"121\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223105455421-2130771465.gif\" class=\"lazyload\"></p>\n<p>&nbsp;</p>\n</div>\n<div id=\"MySignature\" role=\"contentinfo\">\n    本文为博主原创文章，未经博主允许不得转载，欢迎大家一起交流 QQ（282310962） wx（xy190310）\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\" data-last-update-days=\"0\" data-date-updated=\"2025-12-23 11:06\">2025-12-23 11:06</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xiaoyan2017\">xiaoyan2017</a>&nbsp;\n阅读(<span id=\"post_view_count\">15</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19385909);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19385909', targetLink: 'https://www.cnblogs.com/xiaoyan2017/p/19385909', title: 'vite7+deepseek流式ai模板|vue3.5+deepseek3.2+markdown打字输出ai助手' })\">举报</a>\n</div>","guid":{"value":"bae9aa4667b7b08dfd6fd88728d55b79"}},{"title":"Java单元测试、集成测试，区别","link":"https://www.cnblogs.com/kakarotto-chen/p/19385864","description":"<h2>\n            <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/kakarotto-chen/p/19385864\" title=\"发布于 2025-12-23 10:58\">\n    <span role=\"heading\" aria-level=\"2\">Java单元测试、集成测试，区别</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"postbody\">\n            <div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\n<h2 id=\"-单元测试-vs-集成测试\">📚 <strong>单元测试 vs 集成测试</strong></h2>\n<h3 id=\"1-单元测试unit-test\"><strong>1. 单元测试（Unit Test）</strong></h3>\n<p><strong>定义</strong>：测试<strong>最小代码单元</strong>（通常是一个方法或类），<strong>隔离所有外部依赖</strong>。</p>\n<p><strong>特点</strong>：</p>\n<ul>\n<li>测试单个类/方法</li>\n<li>所有依赖都用Mock代替</li>\n<li>不启动Spring容器</li>\n<li>运行极快（毫秒级）</li>\n<li>数量最多</li>\n</ul>\n<p><strong>示例</strong>：</p>\n<pre><code class=\"language-java\">// 测试OrderService的calculateTotal方法\nclass OrderServiceTest {\n    @Test\n    void calculateTotal_ShouldReturnCorrectSum() {\n        // 1. Mock所有依赖\n        DiscountService discountMock = mock(DiscountService.class);\n        when(discountMock.calculate(any())).thenReturn(10.0);\n        \n        // 2. 创建被测试对象（不通过Spring）\n        OrderService service = new OrderService(discountMock);\n        \n        // 3. 调用并验证\n        Order order = new Order(100.0);\n        double total = service.calculateTotal(order);\n        \n        assertEquals(90.0, total);  // 100 - 10折扣\n    }\n}\n</code></pre>\n<h3 id=\"2-集成测试integration-test\"><strong>2. 集成测试（Integration Test）</strong></h3>\n<p><strong>定义</strong>：测试<strong>多个组件协同工作</strong>，验证它们之间的集成是否正确。</p>\n<p><strong>特点</strong>：</p>\n<ul>\n<li>测试组件间交互</li>\n<li>启动部分或全部Spring容器</li>\n<li>可能连接真实数据库/外部服务</li>\n<li>运行较慢（秒级）</li>\n<li>数量较少</li>\n</ul>\n<p><strong>典型集成测试</strong>：</p>\n<pre><code class=\"language-java\">@SpringBootTest  // ← 启动完整Spring Boot应用\nclass DolphinSchedulerApiDemoApplicationTests {\n    @Autowired  // ← Spring注入真实bean\n    WorkerGroupRequest workerGroupRequest;  // ← 测试这个bean与其他组件的集成\n    \n    @Test\n    void contextLoads() {\n        // 调用真实方法，可能涉及：\n        // 1. WorkerGroupRequest内部逻辑\n        // 2. 它依赖的其他Service\n        // 3. 可能的HTTP调用（如果用了RestTemplate）\n        // 4. 数据库操作（如果用了DAO）\n        workerGroupRequest.getWorkerPaths();\n    }\n}\n</code></pre>\n<h2 id=\"-两种测试对比\">📊 <strong>两种测试对比</strong></h2>\n<table>\n<thead>\n<tr>\n<th>方面</th>\n<th>单元测试</th>\n<th>集成测试</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>测试范围</strong></td>\n<td>单个类/方法</td>\n<td>多个组件/模块</td>\n</tr>\n<tr>\n<td><strong>外部依赖</strong></td>\n<td>全部Mock</td>\n<td>部分或全部真实</td>\n</tr>\n<tr>\n<td><strong>Spring容器</strong></td>\n<td>不启动</td>\n<td>启动</td>\n</tr>\n<tr>\n<td><strong>运行速度</strong></td>\n<td>快（ms级）</td>\n<td>慢（s级）</td>\n</tr>\n<tr>\n<td><strong>测试目的</strong></td>\n<td>验证逻辑正确性</td>\n<td>验证集成正确性</td>\n</tr>\n<tr>\n<td><strong>数量比例</strong></td>\n<td>70-80%</td>\n<td>20-30%</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"-测试分析\">🔧 <strong>测试分析</strong></h2>\n<h3 id=\"当前情况\"><strong>当前情况</strong>：</h3>\n<pre><code class=\"language-java\">@SpringBootTest  // 启动整个应用 → 集成测试\nclass DolphinSchedulerApiDemoApplicationTests {\n    @Autowired  // Spring注入 → 集成测试\n    WorkerGroupRequest workerGroupRequest;\n    \n    @Test\n    void contextLoads() {\n        // 测试API客户端与DolphinScheduler的集成\n        // 可能涉及：网络调用、JSON解析、错误处理等\n    }\n}\n</code></pre>\n<h3 id=\"应该改吗要看测试目的\"><strong>应该改吗？要看测试目的：</strong></h3>\n<p><strong>情况1：如果你是想测\"WorkerGroupRequest与真实DolphinScheduler服务的交互\"</strong></p>\n<pre><code class=\"language-java\">// ✅ 保持集成测试（需要真实后端）\n@SpringBootTest\nclass WorkerGroupIntegrationTest {\n    @Autowired WorkerGroupRequest request;\n    \n    @Test\n    void shouldConnectToRealDolphinScheduler() {\n        // 验证是否能真正连接到部署的DolphinScheduler\n        List&lt;String&gt; paths = request.getWorkerPaths();\n        assertNotNull(paths);\n        // 可能还需要验证路径格式等\n    }\n}\n</code></pre>\n<p><strong>情况2：如果你是想测\"WorkerGroupRequest内部的逻辑\"</strong></p>\n<pre><code class=\"language-java\">// ✅ 改为单元测试（更快、更稳定）\nclass WorkerGroupRequestTest {\n    \n    @Test\n    void parseWorkerPaths_ShouldHandleEmptyResponse() {\n        // 1. Mock HTTP客户端\n        RestTemplate restTemplateMock = mock(RestTemplate.class);\n        when(restTemplateMock.exchange(any(), any(), any(), eq(String.class)))\n            .thenReturn(new ResponseEntity&lt;&gt;(\"[]\", HttpStatus.OK));\n        \n        // 2. 创建测试对象\n        WorkerGroupRequest request = new WorkerGroupRequest(restTemplateMock, \"http://localhost\");\n        \n        // 3. 测试内部逻辑\n        List&lt;String&gt; paths = request.getWorkerPaths();\n        \n        assertTrue(paths.isEmpty());\n    }\n    \n    @Test\n    void parseWorkerPaths_ShouldParseJsonCorrectly() {\n        RestTemplate restTemplateMock = mock(RestTemplate.class);\n        String jsonResponse = \"[\\\"192.168.1.1:1234\\\", \\\"192.168.1.2:1234\\\"]\";\n        when(restTemplateMock.exchange(any(), any(), any(), eq(String.class)))\n            .thenReturn(new ResponseEntity&lt;&gt;(jsonResponse, HttpStatus.OK));\n        \n        WorkerGroupRequest request = new WorkerGroupRequest(restTemplateMock, \"http://localhost\");\n        \n        List&lt;String&gt; paths = request.getWorkerPaths();\n        \n        assertEquals(2, paths.size());\n        assertEquals(\"192.168.1.1:1234\", paths.get(0));\n    }\n}\n</code></pre>\n<h2 id=\"-具体建议\">🎯 <strong>具体建议</strong></h2>\n<h3 id=\"方案a保持集成测试但要改进\"><strong>方案A：保持集成测试，但要改进</strong></h3>\n<pre><code class=\"language-java\">@SpringBootTest\n// 限制测试范围，加速启动\n@AutoConfigureMockMvc\n@TestPropertySource(locations = \"classpath:test.properties\")\nclass WorkerGroupRequestIntegrationTest {\n    \n    @Autowired\n    private WorkerGroupRequest workerGroupRequest;\n    \n    @MockBean  // Mock某些不想真实调用的依赖\n    private SomeExternalService externalService;\n    \n    @Test\n    void getWorkerPaths_ShouldReturnListFromDolphinScheduler() {\n        // 配置Mock行为\n        when(externalService.someCall()).thenReturn(\"mocked\");\n        \n        // 执行测试\n        List&lt;String&gt; result = workerGroupRequest.getWorkerPaths();\n        \n        // 更专业的断言\n        assertNotNull(result);\n        assertFalse(result.isEmpty());\n        // 可以验证特定的业务逻辑\n    }\n}\n</code></pre>\n<h3 id=\"方案b拆分为两种测试\"><strong>方案B：拆分为两种测试</strong></h3>\n<pre><code class=\"language-java\">// 1. 单元测试：测逻辑（80%的测试）\nclass WorkerGroupRequestUnitTest {\n    // 测试各种场景：正常情况、异常情况、边界情况\n    @Test void testNormalCase() { ... }\n    @Test void testEmptyResponse() { ... }\n    @Test void testMalformedJson() { ... }\n    @Test void testNetworkError() { ... }\n}\n\n// 2. 集成测试：测真实连接（20%的测试）\n@SpringBootTest\nclass WorkerGroupRequestIntegrationTest {\n    // 只测真正需要集成验证的部分\n    @Test void testRealConnection() { ... }\n}\n</code></pre>\n<h3 id=\"方案c添加测试配置\"><strong>方案C：添加测试配置</strong></h3>\n<p>在 <code>src/test/resources/application-test.yml</code>：</p>\n<pre><code class=\"language-yaml\"># 测试专用配置\ndolphinscheduler:\n  url: http://localhost:12345\n  # 或者使用测试专用的Mock服务器\n</code></pre>\n<h2 id=\"-判断标准\">📝 <strong>判断标准</strong></h2>\n<p>问自己几个问题：</p>\n<ol>\n<li>\n<p><strong>这个测试需要真实DolphinScheduler服务运行吗？</strong></p>\n<ul>\n<li>是 → 集成测试</li>\n<li>否 → 单元测试</li>\n</ul>\n</li>\n<li>\n<p><strong>测试失败是因为我的代码逻辑问题，还是外部服务问题？</strong></p>\n<ul>\n<li>代码问题 → 应该用单元测试</li>\n<li>外部问题 → 集成测试合理</li>\n</ul>\n</li>\n<li>\n<p><strong>这个测试运行速度重要吗？</strong></p>\n<ul>\n<li>要快速反馈 → 单元测试</li>\n<li>可以接受较慢 → 集成测试</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"-结论\">✅ <strong>结论</strong></h2>\n<p><strong>测试作为集成测试是合理的</strong>，特别是：</p>\n<ul>\n<li>你在开发DolphinScheduler客户端</li>\n<li>需要验证与真实API的交互</li>\n<li>早期开发阶段需要端到端验证</li>\n</ul>\n<p><strong>但建议补充单元测试</strong>来覆盖各种逻辑分支，这样：</p>\n<ol>\n<li>单元测试：快速验证逻辑（开发时频繁运行）</li>\n<li>集成测试：验证真实集成（提交前或CI中运行）</li>\n</ol>\n<p>现在可以这样做：</p>\n<pre><code class=\"language-java\">// 保持现有的集成测试\n@SpringBootTest\nclass WorkerGroupIntegrationTest {\n    // 验证真实连接\n}\n\n// 新增单元测试\nclass WorkerGroupRequestUnitTest {\n    // 测试所有可能的响应处理逻辑\n    @Test void testParseResponse() { ... }\n    @Test void testBuildUrl() { ... }\n    @Test void testHandleError() { ... }\n}\n</code></pre>\n<p>这样既有快速反馈的单元测试，又有保障集成的集成测试。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n        </div>\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\" data-last-update-days=\"0\" data-date-updated=\"2025-12-23 10:59\">2025-12-23 10:58</span>&nbsp;\n<a href=\"https://www.cnblogs.com/kakarotto-chen\">C_C_菜园</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19385864);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19385864', targetLink: 'https://www.cnblogs.com/kakarotto-chen/p/19385864', title: 'Java单元测试、集成测试，区别' })\">举报</a>\n\n        </p>","guid":{"value":"44af6db22ea61c546306eb14b29a7acc"}},{"title":"Lit 的响应式系统为什么这么轻？——从 ReactiveElement 的设计说起","link":"https://www.cnblogs.com/zxlh1529/p/19370810","description":"<h1 class=\"postTitle\">\n                <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zxlh1529/p/19370810\" title=\"发布于 2025-12-23 10:33\">\n    <span role=\"heading\" aria-level=\"2\">Lit 的响应式系统为什么这么轻？——从 ReactiveElement 的设计说起</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\n<p>在使用 Lit 时，很多人都会有一个直观感受：</p>\n<blockquote>\n<p><strong>“它居然没有状态管理系统？”</strong><br>\n<strong>“也没有复杂的依赖收集？”</strong></p>\n</blockquote>\n<p>但实际使用下来却发现：</p>\n<ul>\n<li>状态更新是正确的</li>\n<li>DOM 更新是精准的</li>\n<li>性能非常稳定</li>\n</ul>\n<p>那么问题来了：</p>\n<blockquote>\n<p><strong>Lit 的响应式系统到底是怎么工作的？</strong><br>\n<strong>它为什么可以这么轻？</strong></p>\n</blockquote>\n<p>本文将从 <strong>ReactiveElement 的设计目标、实现方式、与 Vue/React 的根本差异</strong> 三个角度来解释这个问题。</p>\n<hr>\n<h2 id=\"一先说结论important\">一、先说结论（Important）</h2>\n<p>在 Lit 中：</p>\n<blockquote>\n<p><strong>响应式系统的职责不是“计算依赖”，</strong><br>\n<strong>而是“调度更新”</strong></p>\n</blockquote>\n<p>这是理解 Lit 响应式系统的第一把钥匙。</p>\n<hr>\n<h2 id=\"二reactiveelement-在-lit-架构中的位置\">二、ReactiveElement 在 Lit 架构中的位置</h2>\n<p>先回顾 Lit 的继承链：</p>\n<pre><code class=\"language-text\">HTMLElement\n  └── ReactiveElement\n        └── LitElement\n              └── YourComponent\n</code></pre>\n<p>其中：</p>\n<ul>\n<li><strong>ReactiveElement</strong>：负责响应式属性 &amp; 更新调度</li>\n<li><strong>LitElement</strong>：负责生命周期 &amp; render 调用</li>\n<li><strong>lit-html</strong>：负责 DOM 更新</li>\n</ul>\n<blockquote>\n<p>ReactiveElement 不关心 DOM<br>\n它只关心：<strong>什么时候需要更新</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"三lit-的响应式系统到底响应了什么\">三、Lit 的响应式系统到底“响应”了什么？</h2>\n<h3 id=\"31-lit-的响应式单位是属性不是依赖\">3.1 Lit 的响应式单位是「属性」，不是「依赖」</h3>\n<p>在 Vue 中：</p>\n<pre><code class=\"language-ts\">effect(() =&gt; {\n  div.textContent = state.count\n})\n</code></pre>\n<ul>\n<li>响应的是 <strong>依赖关系</strong></li>\n<li>自动追踪 <code>state.count</code></li>\n</ul>\n<p>而在 Lit 中：</p>\n<pre><code class=\"language-ts\">@property()\ncount = 0\n</code></pre>\n<ul>\n<li>响应的是 <strong>属性赋值行为</strong></li>\n<li>不存在依赖收集</li>\n</ul>\n<hr>\n<h3 id=\"32-本质区别\">3.2 本质区别</h3>\n<table>\n<thead>\n<tr>\n<th>框架</th>\n<th>响应式关注点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Vue</td>\n<td>“谁用到了这个值”</td>\n</tr>\n<tr>\n<td>React</td>\n<td>“状态是否发生变化”</td>\n</tr>\n<tr>\n<td>Lit</td>\n<td>“属性是否被 set”</td>\n</tr>\n</tbody>\n</table>\n<p>Lit 的选择非常克制。</p>\n<hr>\n<h2 id=\"四reactiveelement-的核心机制\">四、ReactiveElement 的核心机制</h2>\n<h3 id=\"41-property-做了什么\">4.1 @property 做了什么</h3>\n<pre><code class=\"language-ts\">@property({ type: Number })\ncount = 0\n</code></pre>\n<p>背后本质是：</p>\n<ol>\n<li>把字段变成 getter / setter</li>\n<li>在 setter 中调用 <code>requestUpdate</code></li>\n</ol>\n<hr>\n<h3 id=\"42-伪代码示意\">4.2 伪代码示意</h3>\n<pre><code class=\"language-ts\">set count(value) {\n  const oldValue = this._count\n  this._count = value\n  this.requestUpdate('count', oldValue)\n}\n</code></pre>\n<p>没有 Proxy<br>\n没有依赖收集<br>\n没有 effect</p>\n<hr>\n<h2 id=\"五requestupdatelit-响应式系统的核心\">五、requestUpdate：Lit 响应式系统的核心</h2>\n<h3 id=\"51-requestupdate-并不立即更新\">5.1 requestUpdate 并不立即更新</h3>\n<pre><code class=\"language-ts\">this.requestUpdate()\n</code></pre>\n<p>它做的事情是：</p>\n<ul>\n<li>标记“需要更新”</li>\n<li>把更新放入 <strong>microtask 队列</strong></li>\n<li>合并多次更新</li>\n</ul>\n<hr>\n<h3 id=\"52-批量更新机制\">5.2 批量更新机制</h3>\n<pre><code class=\"language-ts\">this.count = 1\nthis.count = 2\nthis.count = 3\n</code></pre>\n<p>最终只会：</p>\n<pre><code class=\"language-text\">render 一次\n</code></pre>\n<p>这是 Lit 响应式系统<strong>最重要的性能保证</strong>。</p>\n<hr>\n<h3 id=\"53-更新调度流程\">5.3 更新调度流程</h3>\n<pre><code class=\"language-text\">property set\n  ↓\nrequestUpdate\n  ↓\nPromise.resolve().then()\n  ↓\nperformUpdate\n  ↓\nrender()\n</code></pre>\n<hr>\n<h2 id=\"六为什么-lit-不需要依赖收集\">六、为什么 Lit 不需要依赖收集？</h2>\n<p>答案非常关键：</p>\n<blockquote>\n<p><strong>因为 lit-html 已经知道“哪里会变”</strong></p>\n</blockquote>\n<p>在前一篇 Part 更新机制中讲过：</p>\n<ul>\n<li>DOM 更新是由 Part 精确定位的</li>\n<li>render() 每次都会重新执行</li>\n<li>但更新只发生在表达式对应位置</li>\n</ul>\n<p>因此：</p>\n<blockquote>\n<p><strong>Lit 不需要知道“你在模板中用了哪些属性”</strong></p>\n</blockquote>\n<p>它只需要保证：</p>\n<ul>\n<li>属性变化 → render 执行</li>\n<li>render 执行 → Part 精确更新</li>\n</ul>\n<hr>\n<h2 id=\"七shouldupdatelit-给你的唯一判断点\">七、shouldUpdate：Lit 给你的“唯一判断点”</h2>\n<pre><code class=\"language-ts\">shouldUpdate(changedProperties) {\n  return true\n}\n</code></pre>\n<ul>\n<li><code>changedProperties</code> 是一个 Map</li>\n<li>记录了哪些属性发生了变化</li>\n</ul>\n<p>你可以非常明确地控制：</p>\n<pre><code class=\"language-ts\">shouldUpdate(changed) {\n  return changed.has('count')\n}\n</code></pre>\n<p>这比 Vue/React 的依赖优化<strong>更显式、更可控</strong>。</p>\n<hr>\n<h2 id=\"八lit-的生命周期为什么这么少\">八、Lit 的生命周期为什么这么少？</h2>\n<p>Lit 的生命周期几乎完全围绕「更新」展开：</p>\n<pre><code class=\"language-ts\">connectedCallback()\nshouldUpdate()\nwillUpdate()\nrender()\nupdated()\n</code></pre>\n<p>没有：</p>\n<ul>\n<li>computed</li>\n<li>watch</li>\n<li>effect</li>\n<li>memo</li>\n</ul>\n<p>因为：</p>\n<blockquote>\n<p><strong>Lit 不试图管理你的状态<br>\n它只负责把状态变化“反映到 DOM”</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"九和-vue--react-的响应式系统对比\">九、和 Vue / React 的响应式系统对比</h2>\n<h3 id=\"91-架构层面对比\">9.1 架构层面对比</h3>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>Lit</th>\n<th>Vue</th>\n<th>React</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>响应式基础</td>\n<td>getter/setter</td>\n<td>Proxy</td>\n<td>setState</td>\n</tr>\n<tr>\n<td>依赖收集</td>\n<td>❌</td>\n<td>✅</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>更新调度</td>\n<td>microtask</td>\n<td>scheduler</td>\n<td>scheduler</td>\n</tr>\n<tr>\n<td>DOM 更新</td>\n<td>定点 Part</td>\n<td>Diff</td>\n<td>Diff</td>\n</tr>\n<tr>\n<td>系统复杂度</td>\n<td>极低</td>\n<td>高</td>\n<td>中</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"92-为什么-lit-可以这么简单\">9.2 为什么 Lit 可以这么“简单”</h3>\n<p>因为 Lit <strong>放弃了三件事</strong>：</p>\n<ol>\n<li>自动依赖追踪</li>\n<li>状态派生（computed）</li>\n<li>跨组件状态管理</li>\n</ol>\n<p>这些都不是组件底层必须解决的问题。</p>\n<hr>\n<h2 id=\"十lit-响应式系统的适用边界\">十、Lit 响应式系统的适用边界</h2>\n<h3 id=\"101-非常适合的场景\">10.1 非常适合的场景</h3>\n<ul>\n<li>UI 组件</li>\n<li>Design System</li>\n<li>跨框架组件</li>\n<li>微前端子模块</li>\n</ul>\n<hr>\n<h3 id=\"102-不适合的场景\">10.2 不适合的场景</h3>\n<ul>\n<li>大型应用状态管理</li>\n<li>复杂状态派生逻辑</li>\n<li>需要大量 computed / watch 的业务</li>\n</ul>\n<p>Lit 的哲学是：</p>\n<blockquote>\n<p><strong>把“状态复杂度”交给使用者或上层架构</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"十一a-very-important-总结\">十一、A Very Important 总结</h2>\n<blockquote>\n<p><strong>Lit 的响应式系统不是“弱”，<br>\n而是“目标非常明确”</strong></p>\n</blockquote>\n<p>它只做三件事：</p>\n<ol>\n<li>监听属性变化</li>\n<li>合并更新</li>\n<li>触发 render</li>\n</ol>\n<p>而剩下的一切，都交给：</p>\n<ul>\n<li>JavaScript 本身</li>\n<li>浏览器本身</li>\n<li>应用架构本身</li>\n</ul>\n<hr>\n<h2 id=\"十二最后\">十二、最后</h2>\n<p>到现在应该可以已经完整理解了：</p>\n<ol>\n<li>Lit 的整体架构</li>\n<li>为什么不需要 Virtual DOM</li>\n<li>lit-html 的 Part 更新机制</li>\n<li>ReactiveElement 的响应式设计</li>\n</ol>\n<p>如果把这些拼起来，you 会发现：</p>\n<blockquote>\n<p><strong>Lit 是一个“极端相信浏览器”的体系</strong></p>\n</blockquote>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\" data-last-update-days=\"0\" data-date-updated=\"2025-12-23 10:33\">2025-12-23 10:33</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zxlh1529\">幼儿园技术家</a>&nbsp;\n阅读(<span id=\"post_view_count\">4</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19370810);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19370810', targetLink: 'https://www.cnblogs.com/zxlh1529/p/19370810', title: 'Lit 的响应式系统为什么这么轻？——从 ReactiveElement 的设计说起' })\">举报</a>\n</div>","guid":{"value":"adc38fbb8be4193bc15835723afd4b18"}},{"title":"一款轻量级 WinForm 开源控件库，让老界面秒变高颜值","link":"https://www.cnblogs.com/1312mn/p/19201142","description":"<h1 class=\"postTitle\">\n                <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/1312mn/p/19201142\" title=\"发布于 2025-12-23 10:25\">\n    <span role=\"heading\" aria-level=\"2\">一款轻量级 WinForm 开源控件库，让老界面秒变高颜值</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\n<h2 id=\"前言\">前言</h2>\n<p>用户界面的美观与易用性始终是开发关注的焦点。随着技术的不断进步，传统的WinForm控件虽然稳定可靠，但在视觉效果上往往难以满足现代用户对美学的追求。</p>\n<p>本文将介绍一个基于 WinForm 的自绘控件项目，摆脱原生 WinForm 控件的方方正正的按钮、灰白单调的输入框。</p>\n<h2 id=\"项目介绍\">项目介绍</h2>\n<p>一个开源的WinForm自绘控件库，通过自定义绘制技术，为 WinForm 应用程序提供更加丰富、灵活的界面元素。</p>\n<p>项目不仅继承了WinForm控件的稳定性与易用性，更在视觉效果上实现了质的飞跃，让WinForm应用也能拥有媲美现代UI框架的视觉体验。</p>\n<h2 id=\"项目功能\">项目功能</h2>\n<p>项目涵盖多种常用控件的自绘实现，包括但不限于按钮（Button）、面板（Panel）、文本框（TextBox）等。其中，最为引人注目的当属PPFlodPanel控件，该控件在原有Panel的基础上增加了动画效果，使得面板的展开与折叠过程更加流畅自然，极大地提升用户界面的交互体验。</p>\n<p>另外，PPSkin还支持控件的皮肤定制，可以根据项目需求轻松更换控件的外观风格，实现界面个性化。</p>\n<h2 id=\"项目特点\">项目特点</h2>\n<p><strong>高度可定制性</strong></p>\n<p>对控件的每一个细节进行定制，从颜色、字体到边框样式，均可根据实际需求进行调整。</p>\n<p><strong>动画效果丰富</strong></p>\n<p>通过引入动画机制，PPSkin的控件在状态变化时能够展现出流畅的过渡效果，增强了用户界面的动态美感。</p>\n<h2 id=\"项目技术\">项目技术</h2>\n<p>通过重写控件的OnPaint方法，使用GDI+图形库进行控件的绘制工作。可以精确控制每一个像素的绘制，从而实现高度定制化的界面效果。为了实现动画效果，P还引入了定时器（Timer）机制，通过定时触发重绘事件来更新控件的显示状态，营造出流畅的动画效果。</p>\n<pre><code class=\"language-csharp\">private void Timer_bar_Tick(object sender, EventArgs e)\n{\n    ledBar1.Text = DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss.fff\");\n    Random random = new Random();\n    ledBar1.NumColor = Color.FromArgb(random.Next(0, 255), random.Next(0, 255), random.Next(0, 255));\n\n    foreach (Control c in tabPage3.Controls)\n    {\n        if (c is PPVScrollBarExt)\n        {\n            (c as PPVScrollBarExt).Value += 1;\n            if ((c as PPVScrollBarExt).Value == ((c as PPVScrollBarExt).Maximum - (c as PPVScrollBarExt).VisibleValue))\n            {\n                (c as PPVScrollBarExt).Value = (c as PPVScrollBarExt).Minimum;\n            }\n        }\n        if (c is PPHScrollBarExt)\n        {\n            (c as PPHScrollBarExt).Value += 1;\n            if ((c as PPHScrollBarExt).Value == ((c as PPHScrollBarExt).Maximum - (c as PPHScrollBarExt).VisibleValue))\n            {\n                (c as PPHScrollBarExt).Value = (c as PPHScrollBarExt).Minimum;\n            }\n        }\n        if (c is PPRoundProgressBar)\n        {\n            (c as PPRoundProgressBar).Value += 1;\n            if ((c as PPRoundProgressBar).Value == (c as PPRoundProgressBar).Maximum)\n            {\n                (c as PPRoundProgressBar).Value = (c as PPRoundProgressBar).Minimum;\n            }\n        }\n\n        if (c is PPProgressBar)\n        {\n            (c as PPProgressBar).Value += 1;\n            if ((c as PPProgressBar).Value == (c as PPProgressBar).Maximum)\n            {\n                (c as PPProgressBar).Value = (c as PPProgressBar).Minimum;\n            }\n        }\n\n        if (c is PPTrackBar)\n        {\n            (c as PPTrackBar).Value += 1;\n            if ((c as PPTrackBar).Value == (c as PPTrackBar).MaxValue)\n            {\n                (c as PPTrackBar).Value = (c as PPTrackBar).MinValue;\n            }\n        }\n\n        if (c is PPWaveProgressBar)\n        {\n            (c as PPWaveProgressBar).Value += 1;\n            if ((c as PPWaveProgressBar).Value == (c as PPWaveProgressBar).Maximum)\n            {\n                (c as PPWaveProgressBar).Value = (c as PPWaveProgressBar).Minimum;\n            }\n        }\n    }\n}\n</code></pre>\n<h2 id=\"项目效果\">项目效果</h2>\n<p>当用户点击展开或折叠按钮时，面板会以一种优雅的方式逐渐展开或收缩，整个过程流畅无卡顿，给人一种愉悦的视觉体验。</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/576536/202511/576536-20251107232412388-867672129.png\" width=\"50%\" loading=\"lazy\" style=\"display: block; margin-left: auto; margin-right: auto\"></p>\n<p><img src=\"https://img2024.cnblogs.com/blog/576536/202511/576536-20251107232401517-1560501345.png\" width=\"50%\" loading=\"lazy\" style=\"display: block; margin-left: auto; margin-right: auto\"></p>\n<p><img src=\"https://img2024.cnblogs.com/blog/576536/202511/576536-20251107232346894-1312855456.png\" width=\"50%\" loading=\"lazy\" style=\"display: block; margin-left: auto; margin-right: auto\"></p>\n<p><img src=\"https://img2024.cnblogs.com/blog/576536/202511/576536-20251107232339716-975949764.png\" width=\"50%\" loading=\"lazy\" style=\"display: block; margin-left: auto; margin-right: auto\"></p>\n<p><img src=\"https://img2024.cnblogs.com/blog/576536/202511/576536-20251107232330102-1359569775.png\" width=\"50%\" loading=\"lazy\" style=\"display: block; margin-left: auto; margin-right: auto\"></p>\n<p><img src=\"https://img2024.cnblogs.com/blog/576536/202511/576536-20251107232319426-192110568.png\" width=\"50%\" loading=\"lazy\" style=\"display: block; margin-left: auto; margin-right: auto\"></p>\n<p><img src=\"https://img2024.cnblogs.com/blog/576536/202511/576536-20251107232309764-645145512.png\" width=\"50%\" loading=\"lazy\" style=\"display: block; margin-left: auto; margin-right: auto\"></p>\n<p><img src=\"https://img2024.cnblogs.com/blog/576536/202511/576536-20251107232249108-1032944892.png\" width=\"50%\" loading=\"lazy\" style=\"display: block; margin-left: auto; margin-right: auto\"></p>\n<p><img src=\"https://img2024.cnblogs.com/blog/576536/202511/576536-20251107232301863-513407702.png\" width=\"50%\" loading=\"lazy\" style=\"display: block; margin-left: auto; margin-right: auto\"></p>\n<h2 id=\"项目源码\">项目源码</h2>\n<p>源码中包含详细的注释与示例代码，方便大家快速上手并理解项目的实现原理。</p>\n<p>Gitee：<a href=\"https://gitee.com/ppcc1596/PPSkin\" target=\"_blank\" rel=\"noopener nofollow\">https://gitee.com/ppcc1596/PPSkin</a></p>\n<h2 id=\"总结\">总结</h2>\n<p>基于WinForm的自绘控件库，以其高度可定制性、丰富的动画效果以及良好的兼容性。通过自定义绘制，成功打破了传统WinForm控件在视觉效果上的局限，为WinForm应用程序带来了全新的界面体验。</p>\n<h2 id=\"关键词\">关键词</h2>\n<p>WinForm、自绘控件、动画效果、皮肤定制、开源项目、GDI+、兼容性、C#、.NET Framework、UI定制、轻量级</p>\n<h2 id=\"最后\">最后</h2>\n<p>如果你觉得这篇文章对你有帮助，不妨点个赞支持一下！你的支持是我继续分享知识的动力。如果有任何疑问或需要进一步的帮助，欢迎随时留言。</p>\n<p>也可以加入微信公众号[DotNet技术匠] 社区，与其他热爱技术的同行一起交流心得，共同成长！</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/576536/202505/576536-20250527195524293-1794896295.png\" width=\"50%\" loading=\"lazy\" style=\"display: block; margin-left: auto; margin-right: auto\"></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\" data-last-update-days=\"0.0006944444444444445\" data-date-updated=\"2025-12-23 10:26\">2025-12-23 10:25</span>&nbsp;\n<a href=\"https://www.cnblogs.com/1312mn\">小码编匠</a>&nbsp;\n阅读(<span id=\"post_view_count\">45</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19201142);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19201142', targetLink: 'https://www.cnblogs.com/1312mn/p/19201142', title: '一款轻量级 WinForm 开源控件库，让老界面秒变高颜值' })\">举报</a>\n</div>","guid":{"value":"3926d8443664d039008b88440c476ac3"}},{"title":"高并发下如何防止重复提交订单？","link":"https://www.cnblogs.com/12lisu/p/19385452","description":"<h1 class=\"postTitle\">\n                <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/12lisu/p/19385452\" title=\"发布于 2025-12-23 10:09\">\n    <span role=\"heading\" aria-level=\"2\">高并发下如何防止重复提交订单？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\n<h2 id=\"前言\">前言</h2>\n<p>当你的用户疯狂点击提交按钮时，你的系统准备好迎接这场“连击风暴”了吗？</p>\n<p>在电商系统的实战中，我见过太多因重复提交导致的资损事故——用户一次点击，系统却创建了多个订单，导致库存错乱、用户重复支付、客服投诉爆棚。</p>\n<p>有些小伙伴在工作中可能遇到过这样的场景：大促期间，用户反馈“明明只点了一次，为什么扣了两次款？”</p>\n<p>开发同学查了半天日志，发现同一个用户请求在毫秒级内真的到达了服务器两次。</p>\n<p>今天这篇文章就跟大家聊聊高并发下防止重复提交订单，希望对你会有所帮助。</p>\n<h2 id=\"01-为什么会重复提交\">01 为什么会重复提交？</h2>\n<p>在深入解决方案前，我们必须搞清楚重复提交是如何发生的。</p>\n<p>常见的场景有：</p>\n<ol>\n<li><strong>用户无意识重复点击</strong>：网络延迟时，用户心急多次点击提交按钮</li>\n<li><strong>前端防抖失效</strong>：前端做了防抖处理，但被绕过或配置不当</li>\n<li><strong>网络超时重试</strong>：请求超时后，客户端或网关自动重试</li>\n<li><strong>恶意攻击</strong>：竞争对手或黑客故意重复提交</li>\n<li><strong>后端处理超时</strong>：第一个请求处理慢，客户端以为失败又发一次</li>\n</ol>\n<p>来看一个典型的用户操作流程，以及其中可能发生重复的各个环节：</p>\n<p><img alt=\"image\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/2238006/202512/2238006-20251223100838751-1951210640.png\" class=\"lazyload\"></p>\n<p>从图中可以看到，从用户点击到订单落库，几乎每个环节都可能成为重复提交的“案发现场”。</p>\n<p>下面，我们就针对这些环节，层层布防。</p>\n<h2 id=\"02-第一道防线前端防抖与按钮控制\">02 第一道防线：前端防抖与按钮控制</h2>\n<p>这是最直观、成本最低的防护措施。</p>\n<p>原则是：<strong>在用户交互层面尽量减少无效请求</strong>。</p>\n<h3 id=\"21-按钮状态控制\">2.1 按钮状态控制</h3>\n<pre><code class=\"language-javascript\">// 前端防抖实现示例（Vue + Element UI）\n&lt;template&gt;\n  &lt;el-button \n    :loading=\"submitting\" \n    :disabled=\"submitting\"\n    @click=\"handleSubmitOrder\"\n  &gt;\n    {{ submitting ? '提交中...' : '提交订单' }}\n  &lt;/el-button&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  data() {\n    return {\n      submitting: false,\n      submitToken: null // 用于标识当前提交的token\n    }\n  },\n  methods: {\n    async handleSubmitOrder() {\n      if (this.submitting) {\n        this.$message.warning('正在提交，请勿重复点击')\n        return\n      }\n      \n      this.submitting = true\n      \n      try {\n        // 生成唯一token，用于后端幂等性校验\n        this.submitToken = this.generateSubmitToken()\n        \n        const result = await this.$api.order.submit({\n          orderData: this.orderData,\n          submitToken: this.submitToken\n        })\n        \n        this.$message.success('订单提交成功')\n        this.$router.push(`/order/detail/${result.orderId}`)\n      } catch (error) {\n        this.$message.error(`提交失败: ${error.message}`)\n        this.submitting = false // 失败后重置状态\n      }\n    },\n    \n    generateSubmitToken() {\n      // 生成唯一标识，可以用UUID或时间戳+随机数\n      return `order_submit_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n    }\n  }\n}\n&lt;/script&gt;\n</code></pre>\n<h3 id=\"22-请求防抖与拦截\">2.2 请求防抖与拦截</h3>\n<pre><code class=\"language-javascript\">// 使用axios拦截器实现请求防抖\nimport axios from 'axios'\n\n// 存储正在进行的请求\nconst pendingRequests = new Map()\n\n// 生成请求key\nconst generateReqKey = (config) =&gt; {\n  const { method, url, params, data } = config\n  return [method, url, JSON.stringify(params), JSON.stringify(data)].join('&amp;')\n}\n\n// 请求拦截器\naxios.interceptors.request.use(config =&gt; {\n  const key = generateReqKey(config)\n  \n  if (pendingRequests.has(key)) {\n    // 请求已存在，取消当前请求\n    config.cancelToken = new axios.CancelToken(cancel =&gt; {\n      cancel(`重复请求已被拦截: ${key}`)\n    })\n  } else {\n    // 新请求，添加到pending中\n    pendingRequests.set(key, config)\n  }\n  \n  return config\n})\n\n// 响应拦截器\naxios.interceptors.response.use(\n  response =&gt; {\n    const key = generateReqKey(response.config)\n    pendingRequests.delete(key)\n    return response\n  },\n  error =&gt; {\n    if (axios.isCancel(error)) {\n      console.log('请求被取消:', error.message)\n      return Promise.reject(error)\n    }\n    \n    // 错误处理完成后，也要从pending中移除\n    if (error.config) {\n      const key = generateReqKey(error.config)\n      pendingRequests.delete(key)\n    }\n    \n    return Promise.reject(error)\n  }\n)\n</code></pre>\n<p><strong>前端防护小结</strong>：</p>\n<ul>\n<li><strong>优点</strong>：实现简单，能拦截大部分用户无意识的重复点击</li>\n<li><strong>缺点</strong>：可被绕过（如直接调用API、禁用JS、使用Postman等工具）</li>\n<li><strong>结论</strong>：前端防护是<strong>必要但不充分</strong>的措施，绝不能作为唯一防线</li>\n</ul>\n<h2 id=\"03-第二道防线后端接口幂等性设计\">03 第二道防线：后端接口幂等性设计</h2>\n<p>幂等性是解决重复提交的<strong>核心理念</strong>。</p>\n<p>所谓幂等，就是<strong>同一个操作执行多次的结果与执行一次的结果相同</strong>。</p>\n<h3 id=\"31-什么是幂等性\">3.1 什么是幂等性？</h3>\n<p>对于订单提交接口：</p>\n<ul>\n<li><strong>幂等</strong>：无论调用1次还是N次，都只创建一个订单</li>\n<li><strong>非幂等</strong>：调用N次可能创建N个订单</li>\n</ul>\n<h3 id=\"32-基于token的幂等实现\">3.2 基于Token的幂等实现</h3>\n<p>这是最常用的幂等实现方案，流程如下：</p>\n<ol>\n<li>客户端在提交前，先向后端申请一个唯一Token</li>\n<li>提交订单时携带此Token</li>\n<li>服务端检查Token是否已使用过</li>\n</ol>\n<pre><code class=\"language-java\">// 幂等性Token服务\n@Service\npublic class IdempotentTokenService {\n    \n    @Autowired\n    private RedisTemplate&lt;String, String&gt; redisTemplate;\n    \n    private static final String IDEMPOTENT_PREFIX = \"idempotent:token:\";\n    private static final long TOKEN_EXPIRE_SECONDS = 300; // Token有效期5分钟\n    \n    /**\n     * 生成幂等性Token\n     */\n    public String generateToken(String userId) {\n        String token = UUID.randomUUID().toString();\n        String redisKey = IDEMPOTENT_PREFIX + userId + \":\" + token;\n        \n        // 存储Token，设置过期时间\n        redisTemplate.opsForValue().set(\n            redisKey, \n            \"1\", \n            TOKEN_EXPIRE_SECONDS, \n            TimeUnit.SECONDS\n        );\n        \n        return token;\n    }\n    \n    /**\n     * 检查并消费Token\n     * @return true: Token有效且消费成功; false: Token无效或已消费\n     */\n    public boolean checkAndConsumeToken(String userId, String token) {\n        String redisKey = IDEMPOTENT_PREFIX + userId + \":\" + token;\n        \n        // 使用Lua脚本保证原子性\n        String luaScript = \"\"\"\n            if redis.call('get', KEYS[1]) == '1' then\n                redis.call('del', KEYS[1])\n                return 1\n            else\n                return 0\n            end\n            \"\"\";\n        \n        DefaultRedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;();\n        redisScript.setScriptText(luaScript);\n        redisScript.setResultType(Long.class);\n        \n        Long result = redisTemplate.execute(\n            redisScript, \n            Collections.singletonList(redisKey)\n        );\n        \n        return result != null &amp;&amp; result == 1L;\n    }\n}\n\n// 使用AOP实现幂等性校验\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Idempotent {\n    String key() default \"\"; // 幂等键，支持SpEL表达式\n    long expireTime() default 300; // 过期时间，秒\n}\n\n@Aspect\n@Component\npublic class IdempotentAspect {\n    \n    @Autowired\n    private RedisTemplate&lt;String, String&gt; redisTemplate;\n    \n    @Around(\"@annotation(idempotent)\")\n    public Object around(ProceedingJoinPoint joinPoint, Idempotent idempotent) throws Throwable {\n        // 1. 获取方法参数\n        Object[] args = joinPoint.getArgs();\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n        Method method = signature.getMethod();\n        \n        // 2. 解析幂等键（支持SpEL）\n        String keyExpression = idempotent.key();\n        String redisKey = parseKey(keyExpression, method, args);\n        \n        // 3. 尝试获取分布式锁（防止并发请求同时通过检查）\n        String lockKey = redisKey + \":lock\";\n        boolean lockAcquired = false;\n        try {\n            // 尝试加锁\n            lockAcquired = redisTemplate.opsForValue()\n                .setIfAbsent(lockKey, \"1\", 10, TimeUnit.SECONDS);\n            \n            if (!lockAcquired) {\n                throw new BusinessException(\"系统繁忙，请稍后重试\");\n            }\n            \n            // 4. 检查Token是否已使用\n            Boolean exists = redisTemplate.hasKey(redisKey);\n            if (Boolean.TRUE.equals(exists)) {\n                // Token已使用，直接返回之前的处理结果（这里需要根据实际业务调整）\n                throw new BusinessException(\"请勿重复提交订单\");\n            }\n            \n            // 5. 执行业务逻辑\n            Object result = joinPoint.proceed();\n            \n            // 6. 标记Token已使用\n            redisTemplate.opsForValue().set(\n                redisKey, \n                \"processed\", \n                idempotent.expireTime(), \n                TimeUnit.SECONDS\n            );\n            \n            return result;\n            \n        } finally {\n            // 释放锁\n            if (lockAcquired) {\n                redisTemplate.delete(lockKey);\n            }\n        }\n    }\n    \n    private String parseKey(String expression, Method method, Object[] args) {\n        // 这里实现SpEL表达式解析，获取实际的幂等键\n        // 例如可以从参数中提取userId+orderToken\n        return \"parsed:key:from:expression\";\n    }\n}\n\n// 在订单提交接口上使用\n@RestController\n@RequestMapping(\"/order\")\npublic class OrderController {\n    \n    @PostMapping(\"/submit\")\n    @Idempotent(key = \"#request.userId + ':' + #request.submitToken\", expireTime = 300)\n    public ApiResponse&lt;OrderSubmitResult&gt; submitOrder(@RequestBody OrderSubmitRequest request) {\n        // 这里是真正的订单创建逻辑\n        OrderSubmitResult result = orderService.createOrder(request);\n        return ApiResponse.success(result);\n    }\n}\n</code></pre>\n<h3 id=\"33-基于唯一业务标识的幂等\">3.3 基于唯一业务标识的幂等</h3>\n<p>除了Token方案，还可以利用业务的自然唯一性实现幂等：</p>\n<pre><code class=\"language-java\">@Service\npublic class OrderService {\n    \n    @Autowired\n    private OrderMapper orderMapper;\n    \n    @Transactional\n    public OrderSubmitResult createOrder(OrderSubmitRequest request) {\n        // 方法1：先查询是否存在\n        Order existingOrder = orderMapper.selectByUniqueKey(\n            request.getUserId(), \n            request.getProductId(), \n            request.getSubmitTime()\n        );\n        \n        if (existingOrder != null) {\n            // 订单已存在，直接返回\n            return convertToResult(existingOrder);\n        }\n        \n        // 方法2：利用数据库唯一约束\n        try {\n            Order newOrder = buildOrder(request);\n            orderMapper.insert(newOrder);\n            return convertToResult(newOrder);\n        } catch (DuplicateKeyException e) {\n            // 捕获唯一键冲突异常\n            log.warn(\"订单重复提交，uniqueKey={}\", request.getUniqueKey());\n            \n            // 查询已创建的订单并返回\n            Order createdOrder = orderMapper.selectByUniqueKey(\n                request.getUserId(), \n                request.getProductId(), \n                request.getSubmitTime()\n            );\n            \n            if (createdOrder == null) {\n                throw new BusinessException(\"订单处理异常，请稍后重试\");\n            }\n            \n            return convertToResult(createdOrder);\n        }\n    }\n    \n    // 订单表可添加唯一索引\n    // ALTER TABLE t_order ADD UNIQUE KEY uk_user_product_time (user_id, product_id, submit_time);\n}\n</code></pre>\n<p><strong>幂等性设计小结</strong>：</p>\n<ul>\n<li><strong>Token方案</strong>：通用性强，适合大多数场景</li>\n<li><strong>业务标识方案</strong>：更自然，但依赖业务的天然唯一性</li>\n<li><strong>关键点</strong>：所有幂等性检查<strong>必须在事务开始前完成</strong>，否则可能失效</li>\n</ul>\n<h2 id=\"04-第三道防线数据库层防护\">04 第三道防线：数据库层防护</h2>\n<p>数据库是数据持久化的最后一道关卡，在这里设置防护至关重要。</p>\n<h3 id=\"41-唯一约束与乐观锁\">4.1 唯一约束与乐观锁</h3>\n<pre><code class=\"language-sql\">-- 订单表设计示例\nCREATE TABLE `t_order` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `order_no` varchar(32) NOT NULL COMMENT '订单号，业务唯一',\n  `user_id` bigint(20) NOT NULL COMMENT '用户ID',\n  `product_id` bigint(20) NOT NULL COMMENT '商品ID',\n  `quantity` int(11) NOT NULL COMMENT '购买数量',\n  `amount` decimal(10,2) NOT NULL COMMENT '订单金额',\n  `status` tinyint(4) NOT NULL DEFAULT '1' COMMENT '订单状态：1-待支付，2-已支付',\n  `submit_token` varchar(64) DEFAULT NULL COMMENT '提交Token，用于幂等',\n  `version` int(11) NOT NULL DEFAULT '1' COMMENT '版本号，用于乐观锁',\n  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `uk_order_no` (`order_no`), -- 订单号唯一\n  UNIQUE KEY `uk_user_submit_token` (`user_id`, `submit_token`), -- 提交Token唯一\n  UNIQUE KEY `uk_user_product_time` (`user_id`, `product_id`, `create_time`), -- 业务维度唯一\n  KEY `idx_user_id` (`user_id`),\n  KEY `idx_create_time` (`create_time`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='订单表';\n</code></pre>\n<h3 id=\"42-数据库层面的幂等实现\">4.2 数据库层面的幂等实现</h3>\n<pre><code class=\"language-java\">// 使用数据库事务+唯一约束保证最终一致性\n@Service\npublic class OrderServiceV2 {\n    \n    @Autowired\n    private OrderMapper orderMapper;\n    \n    @Autowired\n    private IdempotentTokenService tokenService;\n    \n    @Transactional(rollbackFor = Exception.class)\n    public OrderSubmitResult submitOrderWithDBProtection(OrderSubmitRequest request) {\n        String userId = request.getUserId();\n        String submitToken = request.getSubmitToken();\n        \n        // 1. 检查幂等Token（在事务外先检查一次）\n        if (!tokenService.checkAndConsumeToken(userId, submitToken)) {\n            throw new BusinessException(\"请勿重复提交订单\");\n        }\n        \n        try {\n            // 2. 生成订单号（雪花算法等分布式ID生成器）\n            String orderNo = generateOrderNo();\n            \n            // 3. 创建订单对象\n            Order order = new Order();\n            order.setOrderNo(orderNo);\n            order.setUserId(userId);\n            order.setProductId(request.getProductId());\n            order.setQuantity(request.getQuantity());\n            order.setAmount(calculateAmount(request));\n            order.setSubmitToken(submitToken);\n            \n            // 4. 插入订单（这里依赖数据库唯一约束）\n            orderMapper.insert(order);\n            \n            // 5. 更新库存等后续操作...\n            updateProductStock(request.getProductId(), request.getQuantity());\n            \n            return new OrderSubmitResult(orderNo, \"订单创建成功\");\n            \n        } catch (DuplicateKeyException e) {\n            // 6. 处理唯一约束冲突\n            log.warn(\"订单重复提交，userId={}, token={}\", userId, submitToken);\n            \n            // 查询已创建的订单\n            Order existingOrder = orderMapper.selectBySubmitToken(userId, submitToken);\n            if (existingOrder != null) {\n                return new OrderSubmitResult(\n                    existingOrder.getOrderNo(), \n                    \"订单已创建成功，请勿重复提交\"\n                );\n            }\n            \n            // 理论上不会走到这里，除非有极端情况\n            throw new BusinessException(\"订单处理异常，请稍后重试\");\n        }\n    }\n}\n</code></pre>\n<h2 id=\"05-第四道防线分布式锁\">05 第四道防线：分布式锁</h2>\n<p>在分布式环境下，多个实例可能同时处理同一个请求，需要分布式锁来保证只有一个实例执行核心逻辑。</p>\n<h3 id=\"51-基于redis的分布式锁\">5.1 基于Redis的分布式锁</h3>\n<pre><code class=\"language-java\">@Component\npublic class DistributedLockService {\n    \n    @Autowired\n    private RedissonClient redissonClient;\n    \n    /**\n     * 尝试获取分布式锁\n     * @param lockKey 锁的key\n     * @param waitTime 等待时间（毫秒）\n     * @param leaseTime 持有时间（毫秒）\n     * @return 锁对象，获取失败返回null\n     */\n    public RLock tryLock(String lockKey, long waitTime, long leaseTime) {\n        RLock lock = redissonClient.getLock(lockKey);\n        try {\n            boolean acquired = lock.tryLock(waitTime, leaseTime, TimeUnit.MILLISECONDS);\n            return acquired ? lock : null;\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return null;\n        }\n    }\n    \n    /**\n     * 订单提交分布式锁\n     */\n    public RLock lockForOrderSubmit(String userId, String submitToken) {\n        String lockKey = String.format(\"order:submit:lock:%s:%s\", userId, submitToken);\n        return tryLock(lockKey, 100, 5000); // 等待100ms，锁持有5秒\n    }\n}\n\n// 在订单服务中使用分布式锁\n@Service\npublic class OrderServiceV3 {\n    \n    @Autowired\n    private DistributedLockService lockService;\n    \n    @Autowired\n    private OrderMapper orderMapper;\n    \n    public OrderSubmitResult submitOrderWithDistributedLock(OrderSubmitRequest request) {\n        String userId = request.getUserId();\n        String submitToken = request.getSubmitToken();\n        \n        // 1. 获取分布式锁\n        RLock lock = lockService.lockForOrderSubmit(userId, submitToken);\n        if (lock == null) {\n            throw new BusinessException(\"系统繁忙，请稍后重试\");\n        }\n        \n        try {\n            // 2. 检查是否已处理\n            Order existingOrder = orderMapper.selectBySubmitToken(userId, submitToken);\n            if (existingOrder != null) {\n                return new OrderSubmitResult(\n                    existingOrder.getOrderNo(), \n                    \"订单已创建成功，请勿重复提交\"\n                );\n            }\n            \n            // 3. 执行业务逻辑\n            return doCreateOrder(request);\n            \n        } finally {\n            // 4. 释放锁\n            if (lock.isHeldByCurrentThread()) {\n                lock.unlock();\n            }\n        }\n    }\n    \n    private OrderSubmitResult doCreateOrder(OrderSubmitRequest request) {\n        // 实际的订单创建逻辑\n        // 这里已经保证了同一时刻只有一个线程在处理同一个提交请求\n        // ...\n    }\n}\n</code></pre>\n<h3 id=\"52-分布式锁的注意事项\">5.2 分布式锁的注意事项</h3>\n<p>使用分布式锁时要注意：</p>\n<ol>\n<li><strong>锁粒度</strong>：不要太粗（影响性能）也不要太细（增加复杂度）</li>\n<li><strong>锁超时</strong>：必须设置合理的超时时间，防止死锁</li>\n<li><strong>锁续期</strong>：对于长时间操作，需要实现锁续期机制</li>\n<li><strong>可重入性</strong>：同一个线程可以重复获取锁</li>\n<li><strong>容错性</strong>：Redis集群故障时要有降级方案</li>\n</ol>\n<h2 id=\"06-第五道防线异步处理与消息队列\">06 第五道防线：异步处理与消息队列</h2>\n<p>对于高并发场景，可以采用异步处理模式，将同步请求转为异步任务。</p>\n<p><img alt=\"image\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/2238006/202512/2238006-20251223100906726-1694946967.png\" class=\"lazyload\"></p>\n<p>实现代码示例：</p>\n<pre><code class=\"language-java\">// 异步订单处理实现\n@Component\npublic class AsyncOrderService {\n    \n    @Autowired\n    private RocketMQTemplate rocketMQTemplate;\n    \n    @Autowired\n    private RedisTemplate&lt;String, String&gt; redisTemplate;\n    \n    /**\n     * 异步提交订单\n     */\n    public AsyncSubmitResult asyncSubmitOrder(OrderSubmitRequest request) {\n        // 1. 生成唯一请求ID\n        String requestId = generateRequestId(request.getUserId());\n        \n        // 2. 快速验证（库存、用户状态等）\n        quickValidate(request);\n        \n        // 3. 将请求ID与用户关联（用于查询结果）\n        String pendingKey = \"order:pending:\" + request.getUserId() + \":\" + requestId;\n        redisTemplate.opsForValue().set(pendingKey, \"processing\", 10, TimeUnit.MINUTES);\n        \n        // 4. 发送到消息队列\n        OrderMessage message = new OrderMessage();\n        message.setRequestId(requestId);\n        message.setRequest(request);\n        message.setTimestamp(System.currentTimeMillis());\n        \n        rocketMQTemplate.asyncSend(\n            \"ORDER_SUBMIT_TOPIC\", \n            message, \n            new SendCallback() {\n                @Override\n                public void onSuccess(SendResult sendResult) {\n                    log.info(\"订单消息发送成功: {}\", requestId);\n                }\n                \n                @Override\n                public void onException(Throwable throwable) {\n                    log.error(\"订单消息发送失败: {}\", requestId, throwable);\n                    // 发送失败，更新状态\n                    redisTemplate.opsForValue().set(\n                        pendingKey, \n                        \"failed\", \n                        5, \n                        TimeUnit.MINUTES\n                    );\n                }\n            }\n        );\n        \n        // 5. 立即返回，告知用户处理中\n        return new AsyncSubmitResult(requestId, \"订单提交成功，正在处理中\");\n    }\n}\n\n// 消息消费者\n@Component\n@RocketMQMessageListener(\n    topic = \"ORDER_SUBMIT_TOPIC\",\n    consumerGroup = \"order-submit-consumer-group\"\n)\npublic class OrderSubmitConsumer implements RocketMQListener&lt;OrderMessage&gt; {\n    \n    @Autowired\n    private OrderMapper orderMapper;\n    \n    @Override\n    public void onMessage(OrderMessage message) {\n        String requestId = message.getRequestId();\n        OrderSubmitRequest request = message.getRequest();\n        \n        // 1. 幂等检查（基于requestId）\n        Order existing = orderMapper.selectByRequestId(requestId);\n        if (existing != null) {\n            log.info(\"订单已处理，跳过: {}\", requestId);\n            return;\n        }\n        \n        // 2. 创建订单\n        Order order = createOrder(request, requestId);\n        \n        try {\n            orderMapper.insert(order);\n            log.info(\"订单创建成功: {}\", order.getOrderNo());\n            \n            // 3. 更新处理状态\n            updateProcessingStatus(request.getUserId(), requestId, \"success\", order.getOrderNo());\n            \n        } catch (DuplicateKeyException e) {\n            log.warn(\"订单重复，requestId={}\", requestId);\n            // 查询已创建的订单\n            Order created = orderMapper.selectByRequestId(requestId);\n            if (created != null) {\n                updateProcessingStatus(request.getUserId(), requestId, \"success\", created.getOrderNo());\n            }\n        }\n    }\n}\n</code></pre>\n<h2 id=\"07-综合方案多层次联合防护\">07 综合方案：多层次联合防护</h2>\n<p>在实际生产环境中，我们通常会采用多层次、立体化的防护策略。</p>\n<p>以下是一个完整的综合方案流程图：</p>\n<p><img alt=\"image\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/2238006/202512/2238006-20251223100921825-1853544980.png\" class=\"lazyload\"></p>\n<p>这个多层次方案中，每一层都有其特定作用：</p>\n<ul>\n<li><strong>前端层</strong>：用户体验优化，拦截大部分无意识重复</li>\n<li><strong>网关层</strong>：安全防护，防刷、限流</li>\n<li><strong>业务层</strong>：核心幂等逻辑，分布式锁保证并发安全</li>\n<li><strong>数据层</strong>：最终保障，唯一约束防止数据不一致</li>\n<li><strong>异步层</strong>：削峰填谷，提升系统吞吐量</li>\n</ul>\n<h2 id=\"08-实战不同场景下的方案选择\">08 实战：不同场景下的方案选择</h2>\n<p>不同的业务场景需要不同的防护策略，这里给出一些实践建议：</p>\n<h3 id=\"81-普通电商订单\">8.1 普通电商订单</h3>\n<pre><code class=\"language-java\">// 普通电商订单推荐方案\n@Service  \npublic class StandardOrderService {\n    \n    // 综合使用：前端防抖 + Token幂等 + 数据库唯一约束\n    public OrderSubmitResult submitStandardOrder(OrderSubmitRequest request) {\n        // 1. 参数校验\n        validateRequest(request);\n        \n        // 2. 幂等Token检查（Redis）\n        if (!idempotentCheck(request.getUserId(), request.getSubmitToken())) {\n            return getExistingOrderResult(request.getUserId(), request.getSubmitToken());\n        }\n        \n        // 3. 分布式锁（防并发）\n        RLock lock = acquireOrderLock(request.getUserId(), request.getProductId());\n        try {\n            // 4. 库存检查等业务校验\n            checkInventory(request.getProductId(), request.getQuantity());\n            \n            // 5. 创建订单（依赖数据库唯一约束）\n            return createOrderInTransaction(request);\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n</code></pre>\n<h3 id=\"82-秒杀订单\">8.2 秒杀订单</h3>\n<pre><code class=\"language-java\">// 秒杀订单需要更极致的优化\n@Service\npublic class FlashSaleOrderService {\n    \n    // 秒杀方案：异步处理 + 库存预扣 + 最终一致性\n    public FlashSaleSubmitResult submitFlashSaleOrder(FlashSaleRequest request) {\n        // 1. 验证用户资格和活动状态（缓存中检查）\n        if (!checkUserQualification(request.getUserId(), request.getActivityId())) {\n            throw new BusinessException(\"您不具备参与资格\");\n        }\n        \n        // 2. 预扣库存（Redis原子操作）\n        boolean stockDeducted = preDeductStock(\n            request.getActivityId(), \n            request.getProductId(), \n            request.getUserId()\n        );\n        \n        if (!stockDeducted) {\n            throw new BusinessException(\"库存不足\");\n        }\n        \n        // 3. 生成唯一请求ID\n        String requestId = generateRequestId(request.getUserId(), request.getActivityId());\n        \n        // 4. 发送到消息队列（快速返回）\n        sendToMQ(request, requestId);\n        \n        // 5. 立即返回\n        return new FlashSaleSubmitResult(requestId, \"秒杀请求已接受，处理中\");\n    }\n    \n    // 消费者异步创建订单\n    @Transactional\n    public void processFlashSaleOrder(FlashSaleRequest request, String requestId) {\n        // 这里只需要处理真正的订单创建\n        // 因为库存已在Redis中预扣，只需保证最终一致性\n        try {\n            createOrder(request, requestId);\n            // 同步库存到数据库\n            syncStockToDB(request.getProductId(), request.getActivityId());\n        } catch (Exception e) {\n            // 失败时回滚Redis库存\n            rollbackStockInRedis(request.getActivityId(), request.getProductId(), request.getUserId());\n            throw e;\n        }\n    }\n}\n</code></pre>\n<h2 id=\"10-总结\">10 总结</h2>\n<p>防止重复提交订单是一个系统工程，需要从前到后、多层次的防护。</p>\n<p>让我们回顾一下关键点：</p>\n<ol>\n<li><strong>前端防护是体验，不是保障</strong>：按钮防抖、请求拦截能改善用户体验，但不能作为唯一防线。</li>\n<li><strong>幂等性是核心理念</strong>：无论是Token方案还是业务唯一标识，都要保证同一操作执行多次的结果一致。</li>\n<li><strong>分布式锁解决并发问题</strong>：在分布式环境下，防止多个实例同时处理同一请求。</li>\n<li><strong>数据库是最后防线</strong>：唯一约束、乐观锁等机制能在应用层防护失效时保证数据一致性。</li>\n<li><strong>异步处理提升吞吐</strong>：对于高并发场景，将同步请求转为异步处理，提高系统整体吞吐量。</li>\n<li><strong>监控告警必不可少</strong>：没有监控的系统就像没有仪表的飞机，无法发现问题和优化性能。</li>\n</ol>\n<p>在实际架构设计中，我通常建议采用 <strong>\"前端防抖 + 网关限流 + Token幂等 + 分布式锁 + 数据库唯一约束\"</strong> 的综合方案，对于秒杀等极致场景再加入异步处理。</p>\n<p>有些小伙伴可能会觉得这些防护措施太复杂，影响开发效率。</p>\n<p>但请记住：<strong>预防的成本远低于修复的成本</strong>。</p>\n<p>一次重复提交导致的资损事故，可能就需要整个团队加班数周来修复数据和安抚用户。</p>\n<p>技术方案没有银弹，只有最适合业务场景的平衡。</p>\n<h2 id=\"最后说一句求关注别白嫖我\">最后说一句(求关注，别白嫖我)</h2>\n<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>\n<p>求一键三连：点赞、转发、在看。</p>\n<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>\n<p>更多项目实战在我的技术网站：<a href=\"http://www.susan.net.cn/project\" target=\"_blank\" rel=\"noopener nofollow\">http://www.susan.net.cn/project</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\" data-last-update-days=\"0\" data-date-updated=\"2025-12-23 10:10\">2025-12-23 10:09</span>&nbsp;\n<a href=\"https://www.cnblogs.com/12lisu\">苏三说技术</a>&nbsp;\n阅读(<span id=\"post_view_count\">70</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19385452);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19385452', targetLink: 'https://www.cnblogs.com/12lisu/p/19385452', title: '高并发下如何防止重复提交订单？' })\">举报</a>\n</div>","guid":{"value":"609f99fec6caf5bfcd4bfda848352fe1"}},{"title":"【译】Azure MCP 服务器现已内置到 Visual Studio 2026 中：智能体工作流的新时代","link":"https://www.cnblogs.com/MeteorSeed/p/19381988","description":"<h1 class=\"postTitle\">\n                <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/MeteorSeed/p/19381988\" title=\"发布于 2025-12-23 10:01\">\n    <span role=\"heading\" aria-level=\"2\">【译】Azure MCP 服务器现已内置到 Visual Studio 2026 中：智能体工作流的新时代</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div id=\"cnblogs_post_body\" class=\"blogpost-body blogpost-body-html\">\n<p><span>　　管理云资源通常意味着要同时处理多个工具、编写自定义脚本，还要在集成开发环境（IDE）和云管理门户之间切换工作环境。这些额外步骤会拖慢开发速度，也让高效构建智能且安全的应用程序变得更加困难。</span></p>\n<p><span>　　我们很高兴地宣布，Azure MCP 服务器工具现已在 Visual Studio 2026 中开箱即用，将智能云自动化直接引入您信赖的集成开发环境中。这种集成使开发人员能够更快速地构建智能、安全的应用程序，同时降低复杂性并增强信心。</span></p>\n<h1><span><span>为何如此重要</span></span></h1>\n<p><span>　　Azure MCP 服务器是一个基于标准 MCP 协议<span data-pm-slice=\"1 1 [&quot;para&quot;,{&quot;tagName&quot;:&quot;p&quot;,&quot;attributes&quot;:{&quot;style&quot;:&quot;text-align: left;&quot;},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;}]\">的<span>服务器，它使人工智能代理能够通过自然语言安全地访问和管理 Azure 资源，无需自定义集成就能帮助团队简化云操作并提高开发人员的工作效率。</span></span></span></p>\n<p><span>　　Visual Studio 2026 被设计为一款原生支持人工智能的集成开发环境，而 Azure MCP 服务器是其完美的补充。借助这些开箱即用的 MCP 工具，开发人员能够：</span></p>\n<p><span>　　- 使用自然语言生成与 Azure 相关的代码和 IaC。</span></p>\n<p><span>　　- 查询和管理 Azure Kubernetes Service, Azure Container Apps, Cosmos DB, AI Foundry 等资源。</span></p>\n<p><span>　　- 应用 Azure 最佳实践以实现企业级安全性。</span></p>\n<p><span>　　- 通过直接访问日志、诊断和遥测数据，轻松进行诊断和故障排除。</span></p>\n<p><span>　　这意味着更少的上下文切换、更少的手动步骤，以及更多用于开发优秀软件的时间。</span></p>\n<h1><span><span>附加的 Azure 开发工具</span></span></h1>\n<p><span>　　除了核心的 Azure MCP 服务器工具外，Visual Studio 2026 还推出了一套扩展的 Azure 开发工具，旨在简化和增强常见的工作流程：</span></p>\n<p><span><span>　　- Automated CI/CD Setup&nbsp;为 ASP.NET、Blazor 或 Azure Functions 项目生成 Azure DevOps 或 GitHub Actions 工作流，包含完整的 YAML 文件和安全管理的凭据。</span></span></p>\n<p><span><span>　　- Effortless Publishing&nbsp;创建并验证发布配置文件，选择合适的 Azure Web App，然后进行部署 —— 所有操作都可通过自然语言提示完成。</span></span></p>\n<p><span><span>　　- Azure CLI Command Generation&nbsp;需要 Azure CLI 命令吗？尽管问。Copilot 会将您的意图转化为精确的 az 命令。</span></span></p>\n<h1><span><span>开始使用</span></span></h1>\n<p><span>　　1 下载 Visual Studio 2026 或 Visual Studio 2026&nbsp;<span>Insiders<span>，并通过 Visual Studio&nbsp;<span>Installer&nbsp;<span>进行安装。</span></span></span></span></span></p>\n<p><span>　　如果已安装 Visual Studio 2026，打开安装程序并选择“Modify ”以查看可用的工作负载。</span></p>\n<p><span>　　2 在“Workloads”选项卡上，选择“Azure and AI development”并启用 GitHub Copilot。</span></p>\n<p><span>　　3 点击“Install while downloading”以完成安装。</span></p>\n<p><span>　　4 启动 Visual Studio 2026 并创建或加载项目。</span></p>\n<p><span>　　5 打开 GitHub Copilot Chat。</span></p>\n<p><span>　　6 在聊天区域，选择“Select tools”按钮（两个扳手图标）以显示可用工具列表。通过勾选 Azure 和 Azure MCP Server 的顶级节点来启用所有 Azure 工具。</span></p>\n<p><span><img src=\"https://img2024.cnblogs.com/blog/270073/202512/270073-20251222135715292-2015048313.png\" alt=\"20251222\" loading=\"lazy\" style=\"display: block; margin-left: auto; margin-right: auto\"></span></p>\n<h1><span><span>小结</span></span></h1>\n<p><span>　　将 Azure MCP 集成到 Visual Studio 2026 中，标志着向智能体工作流迈出了重要一步 —— 在这种工作流中，人工智能驱动的自动化与开发者的创造力相遇。通过减少摩擦并支持与 Azure 进行自然语言交互，我们正帮助开发者专注于最重要的事情：构建创新、安全且可扩展的应用程序。</span></p>\n<p><span>&nbsp;</span></p>\n<p><span>原文链接：https://devblogs.microsoft.com/visualstudio/azure-mcp-server-now-built-in-with-visual-studio-2026-a-new-era-for-agentic-workflows/</span></p>\n<p><span><img src=\"https://img2024.cnblogs.com/blog/270073/202508/270073-20250825145337681-1658462272.png\" alt=\"me\" loading=\"lazy\" style=\"display: block; margin-left: auto; margin-right: auto\"></span></p>\n<p>&nbsp;</p>\n</div>\n<div id=\"MySignature\" role=\"contentinfo\">\n    <blockquote>\n<p><strong>作者：</strong><a href=\"http://www.cnblogs.com/MeteorSeed\">MeteorSeed</a></p>\n<p><strong>我希望您喜欢这篇博文，并一如既往地感谢您阅读并与朋友和同事分享我的博文。</strong></p>\n<p><strong>转载请注明出处。</strong></p>\n</blockquote>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\" data-last-update-days=\"0\" data-date-updated=\"2025-12-23 10:02\">2025-12-23 10:01</span>&nbsp;\n<a href=\"https://www.cnblogs.com/MeteorSeed\">MeteorSeed</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19381988);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19381988', targetLink: 'https://www.cnblogs.com/MeteorSeed/p/19381988', title: '【译】Azure MCP 服务器现已内置到 Visual Studio 2026 中：智能体工作流的新时代' })\">举报</a>\n</div>","guid":{"value":"82c69e158f71d89c99c3ff6284ab5fc8"}},{"title":"【面试题】MySQL 的覆盖索引是什么？","link":"https://www.cnblogs.com/sun-10387834/p/19370857","description":"<h1 class=\"postTitle\">\n                <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sun-10387834/p/19370857\" title=\"发布于 2025-12-23 09:55\">\n    <span role=\"heading\" aria-level=\"2\">【面试题】MySQL 的覆盖索引是什么？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\n<h1 id=\"-mysql-覆盖索引详解\">📚 MySQL 覆盖索引详解</h1>\n<h2 id=\"-什么是覆盖索引\">🎯 什么是覆盖索引？</h2>\n<p><strong>覆盖索引</strong>是指一个索引包含了查询所需的所有字段，MySQL 可以直接从索引中获取数据而<strong>无需回表</strong>查询数据行。</p>\n<h2 id=\"-核心原理\">🔍 核心原理</h2>\n<pre><code class=\"language-sql\">-- 示例表结构\nCREATE TABLE users (\n    id INT PRIMARY KEY,\n    name VARCHAR(50),\n    age INT,\n    city VARCHAR(50),\n    created_at DATETIME,\n    INDEX idx_age_city_name (age, city, name)  -- 复合索引\n);\n\n-- 情况1：需要回表\nSELECT * FROM users WHERE age = 25;\n-- 虽然用到了索引，但SELECT *需要回表获取所有字段\n\n-- 情况2：覆盖索引（无需回表）\nSELECT age, city, name FROM users WHERE age = 25;\n-- 所有需要的字段都在索引中，无需访问数据行\n</code></pre>\n<h2 id=\"-工作原理对比\">📊 工作原理对比</h2>\n<h3 id=\"普通索引查询流程\"><strong>普通索引查询流程</strong></h3>\n<pre><code>1. 通过索引找到符合条件的行主键\n2. 使用主键回表查询数据行\n3. 从数据行中取出需要的字段\n</code></pre>\n<h3 id=\"覆盖索引查询流程\"><strong>覆盖索引查询流程</strong></h3>\n<pre><code>1. 通过索引找到符合条件的索引记录\n2. 直接从索引记录中取出需要的字段\n3. 无需回表！\n</code></pre>\n<h2 id=\"-判断是否使用覆盖索引\">✅ 判断是否使用覆盖索引</h2>\n<p>使用 <code>EXPLAIN</code> 查看执行计划：</p>\n<pre><code class=\"language-sql\">EXPLAIN SELECT age, city FROM users WHERE age = 25;\n</code></pre>\n<ul>\n<li><strong>Extra列显示</strong>：<code>Using index</code> ✅（使用覆盖索引）</li>\n<li><strong>Extra列显示</strong>：<code>Using index condition</code> ❌（需要回表）</li>\n</ul>\n<h2 id=\"-实际应用示例\">💡 实际应用示例</h2>\n<h3 id=\"示例1理想的覆盖索引\"><strong>示例1：理想的覆盖索引</strong></h3>\n<pre><code class=\"language-sql\">-- 创建覆盖索引\nCREATE INDEX idx_covering ON orders(user_id, status, amount, created_at);\n\n-- 查询：所有需要的字段都在索引中\nSELECT user_id, status, amount \nFROM orders \nWHERE user_id = 100 AND status = 'paid';\n-- ✅ 完全覆盖，Extra: Using index\n</code></pre>\n<h3 id=\"示例2部分覆盖\"><strong>示例2：部分覆盖</strong></h3>\n<pre><code class=\"language-sql\">-- 假设索引：idx_name_age_city (name, age, city)\nSELECT name, age FROM users WHERE name LIKE '张%';\n-- ✅ 覆盖索引：只查询索引包含的字段\n\nSELECT name, age, email FROM users WHERE name LIKE '张%';\n-- ❌ 需要回表：email不在索引中\n</code></pre>\n<h2 id=\"-覆盖索引的优势\">🚀 覆盖索引的优势</h2>\n<table>\n<thead>\n<tr>\n<th>优势</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>减少I/O</strong></td>\n<td>索引通常比数据行小，减少磁盘读取</td>\n</tr>\n<tr>\n<td><strong>避免回表</strong></td>\n<td>无需访问数据行，减少随机I/O</td>\n</tr>\n<tr>\n<td><strong>利用索引排序</strong></td>\n<td>如果ORDER BY字段在索引中，可直接使用索引排序</td>\n</tr>\n<tr>\n<td><strong>减少内存使用</strong></td>\n<td>索引数据更紧凑，缓冲池效率更高</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"性能对比示例\"><strong>性能对比示例</strong></h3>\n<pre><code class=\"language-sql\">-- 没有覆盖索引：0.5秒\nSELECT user_id, product_name \nFROM orders \nWHERE user_id = 1000;\n\n-- 添加覆盖索引后：0.02秒\nCREATE INDEX idx_user_product ON orders(user_id, product_name);\nSELECT user_id, product_name \nFROM orders \nWHERE user_id = 1000;  -- Extra: Using index\n</code></pre>\n<h2 id=\"️-注意事项和限制\">⚠️ 注意事项和限制</h2>\n<h3 id=\"1-索引列顺序很重要\"><strong>1. 索引列顺序很重要</strong></h3>\n<pre><code class=\"language-sql\">-- 索引：idx_a_b_c (a, b, c)\n\n-- 覆盖索引：✅\nSELECT a, b FROM users WHERE a = 1;\n\n-- 覆盖索引：✅（c在WHERE中）\nSELECT a, b FROM users WHERE a = 1 AND c = 2;\n\n-- 覆盖索引：❌（缺少a，索引失效）\nSELECT b, c FROM users WHERE b = 2;\n</code></pre>\n<h3 id=\"2-textblob字段的限制\"><strong>2. TEXT/BLOB字段的限制</strong></h3>\n<pre><code class=\"language-sql\">-- 对于TEXT/BLOB字段，即使包含在索引中也可能需要回表\nCREATE INDEX idx_content ON articles(title, content(100));\n\nSELECT title, content FROM articles WHERE title = 'MySQL';\n-- 可能无法完全覆盖，取决于存储引擎和配置\n</code></pre>\n<h3 id=\"3-主键的特殊情况\"><strong>3. 主键的特殊情况</strong></h3>\n<pre><code class=\"language-sql\">-- InnoDB二级索引自动包含主键\nCREATE INDEX idx_age ON users(age);\n-- 实际上存储的是: (age, id)\n\n-- 这些查询可以使用覆盖索引：\nSELECT id FROM users WHERE age = 25;            -- ✅\nSELECT age, id FROM users WHERE age = 25;       -- ✅\nSELECT age FROM users WHERE age = 25;           -- ✅\n</code></pre>\n<h2 id=\"-优化建议\">🔧 优化建议</h2>\n<h3 id=\"1-设计合适的复合索引\"><strong>1. 设计合适的复合索引</strong></h3>\n<pre><code class=\"language-sql\">-- 根据查询模式设计索引\n-- 常见查询：\nSELECT user_id, order_date, total \nFROM orders \nWHERE user_id = ? AND status = 'completed' \nORDER BY order_date DESC;\n\n-- 最佳索引：\nCREATE INDEX idx_user_status_date_total \nON orders(user_id, status, order_date DESC, total);\n-- 完全覆盖查询需求\n</code></pre>\n<h3 id=\"2-利用覆盖索引优化分页\"><strong>2. 利用覆盖索引优化分页</strong></h3>\n<pre><code class=\"language-sql\">-- 低效的分页（需要回表）\nSELECT * FROM users ORDER BY created_at LIMIT 100000, 20;\n\n-- 高效的分页（使用覆盖索引）\nSELECT id FROM users ORDER BY created_at LIMIT 100000, 20;\n-- 先通过覆盖索引获取id，再关联查询\nSELECT u.* FROM users u\nJOIN (\n    SELECT id FROM users ORDER BY created_at LIMIT 100000, 20\n) AS tmp ON u.id = tmp.id;\n</code></pre>\n<h3 id=\"3-监控覆盖索引使用情况\"><strong>3. 监控覆盖索引使用情况</strong></h3>\n<pre><code class=\"language-sql\">-- 查看索引使用统计\nSELECT \n    OBJECT_SCHEMA,\n    OBJECT_NAME,\n    INDEX_NAME,\n    ROWS_READ,\n    ROWS_INSERTED,\n    ROWS_UPDATED,\n    ROWS_DELETED\nFROM performance_schema.table_io_waits_summary_by_index_usage\nWHERE OBJECT_SCHEMA = 'your_database';\n</code></pre>\n<h2 id=\"-最佳实践总结\">🎯 最佳实践总结</h2>\n<ol>\n<li><strong>分析查询模式</strong>：找出高频查询，针对性创建覆盖索引</li>\n<li><strong>遵循最左前缀原则</strong>：合理安排索引列顺序</li>\n<li><strong>避免过度索引</strong>：权衡查询性能与写入开销</li>\n<li><strong>定期审查索引</strong>：使用 <code>pt-duplicate-key-checker</code> 等工具</li>\n<li><strong>考虑存储成本</strong>：大字段的覆盖索引可能占用大量空间</li>\n</ol>\n<h2 id=\"-性能影响示例\">📈 性能影响示例</h2>\n<pre><code class=\"language-sql\">-- 测试覆盖索引效果\nSET profiling = 1;\n\n-- 查询1：需要回表\nSELECT * FROM large_table WHERE category = 'electronics';\n\n-- 查询2：使用覆盖索引\nSELECT id, category, name FROM large_table WHERE category = 'electronics';\n\nSHOW PROFILES;\n-- 通常覆盖索引查询速度快2-10倍\n</code></pre>\n<p>覆盖索引是 MySQL 查询优化的重要技术，合理使用可以显著提升查询性能，特别是在处理大量数据的 OLTP 系统中。</p>\n\n</div>\n<div id=\"MySignature\" role=\"contentinfo\">\n    \n<p>❤️ 如果你喜欢这篇文章，请点赞支持！ 👍 同时欢迎关注我的博客，获取更多精彩内容！</p>\n\n<p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/sun-10387834/\" target=\"_blank\">佛祖让我来巡山</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/sun-10387834/p/19370857\" target=\"_blank\">https://www.cnblogs.com/sun-10387834/p/19370857</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\" data-last-update-days=\"0\" data-date-updated=\"2025-12-23 09:56\">2025-12-23 09:55</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sun-10387834\">佛祖让我来巡山</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19370857);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19370857', targetLink: 'https://www.cnblogs.com/sun-10387834/p/19370857', title: '【面试题】MySQL 的覆盖索引是什么？' })\">举报</a>\n</div>","guid":{"value":"67bfa96fc86eebbd60b6ee2a5f039d46"}}]}