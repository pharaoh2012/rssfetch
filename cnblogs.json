{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "一阶低通滤波器（LPF）使用详讲",
      "link": "https://www.cnblogs.com/lsksp/p/19406964",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lsksp/p/19406964\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 00:10\">\n    <span>一阶低通滤波器（LPF）使用详讲</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        一阶低通滤波器（Low Pass Filter，LPF）的核心作用是：允许输入信号中频率低于设定截止频率的成分通过（衰减极小），阻隔或大幅衰减高于截止频率的高频噪声，从而获得更纯净的目标信号。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>一阶低通滤波器（Low Pass Filter，LPF）的核心作用是：允许输入信号中频率低于设定截止频率的成分通过（衰减极小），阻隔或大幅衰减高于截止频率的高频噪声，从而获得更纯净的目标信号。</p>\n<hr />\n<h3 id=\"一一阶低通滤波器定义\">一、一阶低通滤波器定义</h3>\n<p>对于一阶低通滤波而言，从控制模型上分析就是一个一阶惯性环节，其描述形式如式所示：</p>\n<p></p><div class=\"math display\">\\[H\\left( s \\right) =\\frac{1}{Ts+1}\n\\]</div><p></p><p></p><div class=\"math display\">\\[\\text{注：}T=\\frac{1}{w_c}\\text{，}w_c=2\\pi \\cdot f_c\\text{；}\n\\text{其中，}T\\text{为时间常数，}w_c\\text{为角频率，}f_c\\text{为截止频率}\n\\]</div><p></p><p><img alt=\"bode图\" class=\"lazyload\" /></p>\n<p>幅频响应：</p>\n<p></p><div class=\"math display\">\\[\\begin{equation}\n\n|H(j\\omega)| = \\frac{1}{\\sqrt{1+(\\omega T)^2}} = \\frac{1}{\\sqrt{1+\\left(\\frac{\\omega}{\\omega_c}\\right)^2}}\n\n\\end{equation}\n\\]</div><p></p><p>相频响应：</p>\n<p></p><div class=\"math display\">\\[\\begin{equation}\n\\angle H(j\\omega) = -\\arctan(\\omega T) = -\\arctan\\left(\\frac{\\omega}{\\omega_c}\\right)\n\\end{equation}\n\\]</div><p></p><p>简单来说，一阶低通滤波器就做了一件事：<strong>让慢的变化通过，阻隔快的变化。</strong> 在实际工程中使用一阶低通滤波器时，需特别注意以下特点：</p>\n<ol>\n<li><strong>平滑效果</strong>：它能滤除高频噪声（如 ADC 抖动、电源纹波）。截止频率设得越低，对输入信号变化的响应越慢。</li>\n<li><strong>相位滞后</strong>：输出信号总是比输入信号“慢半拍”。在闭环控制系统（如 PID）中，如果滤波强度过大，会导致系统响应迟钝甚至震荡。</li>\n<li><strong>衰减特性</strong>：在截止频率 <code>fc</code> 处，信号幅度衰减至<code> -3dB</code>（约为 0.707 倍），相位滞后<code> -45°</code></li>\n</ol>\n<p>滤波效果对比图如下：</p>\n<p><img alt=\"lpf_cutoff_freq_comparison\" class=\"lazyload\" /></p>\n<h3 id=\"二一阶低通滤波器的使用\">二、一阶低通滤波器的使用</h3>\n<p>在使用滤波器前，需厘清四个核心概念（以车载 IMU 为例）：</p>\n<ul>\n<li><strong>信号频率</strong>：车辆加速度的变化（你想测的，较慢）；</li>\n<li><strong>噪声频率</strong>：发动机的震动（你想滤的，较快）；</li>\n<li><strong>采样频率</strong>：你采集数据的频率（干活速度，必须足够快以看清噪声并滤除）；</li>\n<li><strong>截止频率</strong>：设定的“分界线”，应介于信号和噪声之间。</li>\n</ul>\n<p>在实际工程中，我们设计滤波器主要有两个方向：</p>\n<h4 id=\"1设计传感器为了达到目标去选硬件\">1、设计传感器（为了达到目标去选硬件）</h4>\n<p>这是<strong>自顶向下</strong>的设计思路。当我们明确了需要测量的信号和需要滤除的噪声时，反过来推算硬件需求。</p>\n<ul>\n<li><strong>确定范围</strong>：已知信号频率（如 5 Hz）和噪声频率（如 50 Hz）。</li>\n<li><strong>设定分界线</strong>：选择截止频率<code> fc</code> 介于二者之间（如 10 Hz）。</li>\n<li><strong>推算采样频率</strong>：为了保证数字滤波算法的准确性，工程上通常要求采样频率大于 10 倍的截止频率（经验值，确保滤波精度）。因此，我们需要选择采样频率至少为 100 Hz 的传感器。</li>\n</ul>\n<h4 id=\"2使用传感器有了硬件去调参数\">2、使用传感器（有了硬件去调参数）</h4>\n<p>这是<strong>自底向上</strong>的调试思路。在硬件采样频率固定（如 IMU 锁定在 100 Hz）的情况下，寻找截止频率的最佳设置区间。</p>\n<ul>\n<li><strong>算上限</strong>：工程上通常要求采样频率大于 10 倍的截止频率（经验值，确保滤波精度），即截止频率小于 10 Hz。</li>\n<li><strong>看下限</strong>：为了保留有效信号，截止频率必须大于信号频率（如 5 Hz）。</li>\n<li><strong>定参数</strong>：在“上限”和“下限”的夹缝中选择一个值（如 8 Hz）。如果信号频率高于上限（如想测 50 Hz 震动），则说明该传感器采样频率不足，无法胜任。</li>\n</ul>\n<h3 id=\"三c语言实现\">三、C语言实现</h3>\n<p>使用以下代码，请包含以下公共内容</p>\n<pre><code class=\"language-C\">#include &lt;stdint.h&gt;\n#include &lt;math.h&gt;  /* 双线性变换法需要用到 tanf */\n\n#ifndef PI\n#define PI 3.14159265358979323846f\n#endif\n\n</code></pre>\n<h4 id=\"1后向差分方法backward-difference\">1、后向差分方法（Backward Difference）</h4>\n<p>这是最经典、最稳健的实现方式。它利用上一时刻的输出值进行递推，数值稳定性高，<strong>无条件稳定</strong>。适用于绝大多数传感器滤波、电机控制等通用场景。若调试中发现数据有明显的相位滞后，可适当增大截止频率。</p>\n<pre><code class=\"language-C\">#include &lt;stdint.h&gt; /* 推荐包含标准类型定义 */\n\n\n/**\n * @brief       后向差分法一阶低通滤波器结构体\n */\ntypedef struct\n{\n\tfloat alpha;           /* 滤波系数 */\n\tfloat one_minus_alpha; /* 预计算的 (1 - alpha) */\n\tfloat last_output;     /* 上一次滤波输出值 */\n\tfloat cutoff_freq;     /* 截止频率 */\n\tfloat sample_freq;     /* 采样频率 */\n} LPF_BackwardEuler;\n\n/**\n * @brief       后向差分法一阶低通滤波器初始化函数\n * @param       filter : 滤波器结构体指针\n * @param       cutoff_freq : 截止频率\n * @param       sample_freq : 采样频率\n * @retval      0:成功, -1:参数错误\n * @note        建议 sample_freq 至少为 cutoff_freq 的 10 倍以获得较好的效果\n */\nint lpf_backward_euler_init(LPF_BackwardEuler *filter, float cutoff_freq, float sample_freq)\n{\n\tif (filter == NULL || cutoff_freq &lt;= 0.0f || sample_freq &lt;= 0.0f)\n\t{\n\t\treturn -1;\n\t}\n    \n\t/* \n\t* 限制采样率不得低于奈奎斯特频率 (2倍)，否则无法重构信号。\n\t* 实际工程中为了滤波效果，通常建议 10 倍以上。\n\t*/\n\tif (sample_freq &lt; 2.0f * cutoff_freq)\n\t{\n\t\treturn -1; \n\t}\n\t\n\n\tfloat tau = 1.0f / (2.0f * PI * cutoff_freq);\n\tfloat ts = 1.0f / sample_freq;\n\tfilter-&gt;alpha = ts / (tau + ts);\n\t\n\tfilter-&gt;one_minus_alpha = 1.0f - filter-&gt;alpha;\n\t\n\t/* 初始化结构体成员 */\n\tfilter-&gt;cutoff_freq = cutoff_freq;\n\tfilter-&gt;sample_freq = sample_freq;\n\tfilter-&gt;last_output = 0.0f;\n\t\n\treturn 0;\n}\n\n/**\n * @brief       后向差分法一阶低通滤波器计算函数\n * @param       filter : 滤波器结构体指针\n * @param       input : 当前输入值\n * @retval      滤波后的输出值\n */\nfloat lpf_backward_euler_update(LPF_BackwardEuler *filter, float input)\n{\n\tfloat output;\n\t\n\tif (filter == NULL)\n\t{\n\t\treturn input; \n\t}\n\t\n\t/* 核心公式：y[n] = alpha * x[n] + (1 - alpha) * y[n-1] */\n\toutput = filter-&gt;alpha * input + filter-&gt;one_minus_alpha * filter-&gt;last_output;\n\t\n\tfilter-&gt;last_output = output;\n\t\n\treturn output;\n}\n\n/**\n * @brief       重置后向差分法一阶低通滤波器状态\n * @param       filter : 滤波器结构体指针\n * @param       init_val : 重置后的初始输出值\n * @retval      0:成功, -1:参数错误\n */\nint lpf_backward_euler_reset(LPF_BackwardEuler *filter, float init_val)\n{\n\tif (filter == NULL)\n\t{\n\t\treturn -1;\n\t}\n\t\n\tfilter-&gt;last_output = init_val;\n\treturn 0;\n}\n\n</code></pre>\n<h4 id=\"2前向差分法forward-difference\">2、前向差分法（Forward Difference）</h4>\n<p>公式简单，但属于<strong>显式欧拉法</strong>，只有在特定情况下才稳定。由于对采样频率和截止频率的比例敏感，容易出现发散。除非有特殊的极低频需求或对代码极其简化，否则一般不推荐。</p>\n<pre><code class=\"language-c\">/**\n * @brief       前向差分法一阶低通滤波器结构体\n */\ntypedef struct\n{\n\tfloat alpha;           /* 滤波系数 (omega * Ts) */\n\tfloat one_minus_alpha; /* 预计算的 (1 - alpha) */\n\tfloat last_input;      /* 上一次滤波输入值 x[n-1] */\n\tfloat last_output;     /* 上一次滤波输出值 y[n-1] */\n\tfloat cutoff_freq;     /* 截止频率 */\n\tfloat sample_freq;     /* 采样频率 */\n} LPF_ForwardDifference;\n\n/**\n * @brief       前向差分法一阶低通滤波器初始化函数\n * @param       filter : 滤波器结构体指针\n * @param       cutoff_freq : 截止频率\n * @param       sample_freq : 采样频率\n * @retval      0:成功, -1:参数错误\n */\nint lpf_forward_difference_init(LPF_ForwardDifference *filter, float cutoff_freq, float sample_freq)\n{\n\tif (filter == NULL || cutoff_freq &lt;= 0.0f || sample_freq &lt;= 0.0f)\n\t{\n\t\treturn -1;\n\t}\n\t\n\t/* \n\t* 前向差分法虽然有理论稳定极限 (PI * fc)，但在接近极限时误差极大。\n\t* 此处强制执行 10 倍规则，确保工程应用的可靠性。\n\t*/\n\tif (sample_freq &lt; 10.0f * cutoff_freq)\n\t{\n\t\treturn -1; \n\t}\n\t\n\t/* 计算过程系数 */\n\tfloat tau = 1.0f / (2.0f * PI * cutoff_freq);\n\tfloat ts = 1.0f / sample_freq;\n\tfilter-&gt;alpha = ts / tau;\n\tfilter-&gt;one_minus_alpha = 1.0f - filter-&gt;alpha;\n\t\n\t/* 初始化结构体成员 */\n\tfilter-&gt;cutoff_freq = cutoff_freq;\n\tfilter-&gt;sample_freq = sample_freq;\n\tfilter-&gt;last_input = 0.0f;\n\tfilter-&gt;last_output = 0.0f;\n\t\n\treturn 0;\n}\n\n/**\n * @brief       前向差分法一阶低通滤波器计算函数\n * @param       filter : 滤波器结构体指针\n * @param       input : 当前输入值\n * @retval      滤波后的输出值\n */\nfloat lpf_forward_difference_update(LPF_ForwardDifference *filter, float input)\n{\n\tfloat output;\n\t\n\tif (filter == NULL)\n\t{\n\t\treturn input; \n\t}\n\t\n\t/* y[n] = (1 - Ts/Tau)y[n-1] + (Ts/Tau)x[n-1] */\n\toutput = filter-&gt;one_minus_alpha * filter-&gt;last_output + filter-&gt;alpha * filter-&gt;last_input;\n\t\n\t/* 更新历史值：当前输入作为下一次的历史输入 */\n\tfilter-&gt;last_input = input;\n\tfilter-&gt;last_output = output;\n\t\n\treturn output;\n}\n\n/**\n * @brief       重置前向差分法一阶低通滤波器状态\n * @param       filter : 滤波器结构体指针\n * @param       init_val : 重置后的初始输出值\n * @retval      0:成功, -1:参数错误\n */\nint lpf_forward_difference_reset(LPF_ForwardDifference *filter, float init_val)\n{\n\tif (filter == NULL)\n\t{\n\t\treturn -1;\n\t}\n\t\n\tfilter-&gt;last_input = init_val;\n\tfilter-&gt;last_output = init_val;\n\t\n\treturn 0;\n}\n</code></pre>\n<h4 id=\"3双线性变换法tustin--bilinear\">3、双线性变换法（Tustin / Bilinear）</h4>\n<p>通过双线性变换将模拟域映射到数字域。它不仅能利用当前输入，还利用了历史输入和输出，其<strong>频率响应特性最接近</strong>理论模拟滤波器。适用于对幅频特性要求较高的音频处理、信号分析，或采样频率相对较低的精密控制场合。</p>\n<pre><code class=\"language-C\">/**\n * @brief       双线性变换法一阶低通滤波器结构体\n */\ntypedef struct\n{\n\tfloat b0;             /* 输入系数 b0 */\n\tfloat b1;             /* 输入系数 b1 */\n\tfloat a1;             /* 反馈系数 a1 */\n\tfloat last_input;     /* 上一次滤波输入值 x[n-1] */\n\tfloat last_output;    /* 上一次滤波输出值 y[n-1] */\n\tfloat cutoff_freq;    /* 截止频率 */\n\tfloat sample_freq;    /* 采样频率 */\n} LPF_BilinearTransform;\n\n/**\n * @brief       双线性变换法一阶低通滤波器初始化函数\n * @param       filter : 滤波器结构体指针\n * @param       cutoff_freq : 截止频率\n * @param       sample_freq : 采样频率\n * @retval      0:成功, -1:参数错误\n */\nint lpf_bilinear_transform_init(LPF_BilinearTransform *filter, float cutoff_freq, float sample_freq)\n{\n\tif (filter == NULL || cutoff_freq &lt;= 0.0f || sample_freq &lt;= 0.0f)\n\t{\n\t\treturn -1;\n\t}\n\t\n\t/* 奈奎斯特频率限制 */\n\tif (sample_freq &lt; 2.0f * cutoff_freq)\n\t{\n\t\treturn -1; \n\t}\n\t\n\tfloat wc = 2.0f * PI * cutoff_freq;\n\tfloat T = 1.0f / sample_freq;\n\t\n\t/* 频率预扭曲，目的是消除双线性变换在高频处的非线性频率畸变，确保截止频率准确 */\n\tfloat wc_twisted = (2.0f / T) * tanf((wc * T) / 2.0f);\n\t\n\t/* 计算双线性变换系数 */\n\tfloat K = (wc_twisted * T) / 2.0f;\n\tfloat denominator = 1.0f + K;\n\t\n\tfilter-&gt;b0 = K / denominator;\n\tfilter-&gt;b1 = filter-&gt;b0;  \n\tfilter-&gt;a1 = (K - 1.0f) / denominator;\n\t\n\t/* 初始化结构体成员 */\n\tfilter-&gt;cutoff_freq = cutoff_freq;\n\tfilter-&gt;sample_freq = sample_freq;\n\tfilter-&gt;last_input = 0.0f;\n\tfilter-&gt;last_output = 0.0f;\n\t\n\treturn 0;\n}\n\n/**\n * @brief       双线性变换法一阶低通滤波器计算函数\n * @param       filter : 滤波器结构体指针\n * @param       input : 当前输入值\n * @retval      滤波后的输出值\n */\nfloat lpf_bilinear_transform_update(LPF_BilinearTransform *filter, float input)\n{\n\tfloat output;\n\t\n\tif (filter == NULL)\n\t{\n\t\treturn input; \n\t}\n\t\n\t/* 核心公式：y[n] = b0*x[n] + b1*x[n-1] - a1*y[n-1] */\n\toutput = filter-&gt;b0 * input \n\t+ filter-&gt;b1 * filter-&gt;last_input \n\t- filter-&gt;a1 * filter-&gt;last_output;\n\t\n\t/* 更新历史状态 */\n\tfilter-&gt;last_input = input;\n\tfilter-&gt;last_output = output;\n\t\n\treturn output;\n}\n\n/**\n * @brief       重置双线性变换法一阶低通滤波器状态\n * @param       filter : 滤波器结构体指针\n * @param       init_val : 重置后的初始输出值\n * @retval      0:成功, -1:参数错误\n */\nint lpf_bilinear_transform_reset(LPF_BilinearTransform *filter, float init_val)\n{\n\tif (filter == NULL)\n\t{\n\t\treturn -1;\n\t}\n\t\n\tfilter-&gt;last_input = init_val;\n\tfilter-&gt;last_output = init_val;\n\t\n\treturn 0;\n}\n</code></pre>\n<h4 id=\"4工程选择速查表\">4、工程选择速查表</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">方法</th>\n<th style=\"text-align: left;\">稳定性</th>\n<th style=\"text-align: left;\">计算量</th>\n<th style=\"text-align: left;\">相位/延迟特性</th>\n<th style=\"text-align: left;\">核心特点</th>\n<th style=\"text-align: left;\">适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>后向差分法</strong></td>\n<td style=\"text-align: left;\"><strong>无条件稳定</strong></td>\n<td style=\"text-align: left;\"><strong>极低</strong> (1次乘法 + 1次乘加)</td>\n<td style=\"text-align: left;\">存在相位滞后 (隐式欧拉)</td>\n<td style=\"text-align: left;\">最常用，最稳健。系数计算简单，不涉及三角函数。</td>\n<td style=\"text-align: left;\"><strong>绝大多数场景</strong>。 电机控制、传感器去噪、PID滤波。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>双线性变换法</strong></td>\n<td style=\"text-align: left;\"><strong>无条件稳定</strong></td>\n<td style=\"text-align: left;\">中等 ( 3 次乘加)</td>\n<td style=\"text-align: left;\">频率响应最准 (需预扭曲)</td>\n<td style=\"text-align: left;\"><strong>精度最高</strong>。在截止频率处的幅值衰减最准确（-3dB），频率映射保真度最好。</td>\n<td style=\"text-align: left;\"><strong>高精度要求</strong>。 音频处理、精密仪器、精密测量、电源闭环控制。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>前向差分法</strong></td>\n<td style=\"text-align: left;\"><strong>有条件稳定</strong> (需 fs &gt; π·fc)</td>\n<td style=\"text-align: left;\">极低</td>\n<td style=\"text-align: left;\"><strong>延迟最大</strong> (显式，多拍滞后)</td>\n<td style=\"text-align: left;\">算法简单，但天然引入 1 个采样周期的纯延迟，且易发散。</td>\n<td style=\"text-align: left;\">极少推荐。 仅在处理极低频信号且计算资源极其受限时考虑。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"四总结\">四、总结</h3>\n<p>一阶低通滤波器是嵌入式信号处理中最基础、最常用的工具。正确使用它的关键，在于理解<strong>信号频率、噪声频率、采样频率与截止频率</strong>之间的制约关系。在实际开发中，建议优先采用<strong>后向差分法</strong>进行实现，根据实际的采样频率和信号带宽，灵活调整截止频率，以达到去噪与响应速度的最佳平衡。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-27 00:10</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lsksp\">比特向阳</a>&nbsp;\n阅读(<span id=\"post_view_count\">4</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一款由字节跳动推出的 AI 提示词生成和优化工具，为你提供更精准，专业，可持续迭代提示词！",
      "link": "https://www.cnblogs.com/Can-daydayup/p/19406862",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Can-daydayup/p/19406862\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 23:11\">\n    <span>一款由字节跳动推出的 AI 提示词生成和优化工具，为你提供更精准，专业，可持续迭代提示词！</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2><span>前言</span></h2>\n<p><span>在AI技术迅猛发展的当下，高效且精准的提示词成为与AI模型有效交互的关键。今天大姚给大家分享一款由字节跳动推出的 AI 提示词生成和优化工具，为你提供更精准，专业，可持续迭代提示词！</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226230859325-1349637768.png\" /></p>\n<h2><span>工具介绍</span></h2>\n<p><span>PromptPilot 是由字节跳动推出的一款专注于 AI 提示词优化与提示词生成的实用工具。该工具旨在帮助用户更高效地生成和优化 AI 提示词，提升与 AI 模型的交互效率和质量。通过 PromptPilot，用户可以轻松地创建、调试和管理提示词，以满足多样化的应用场景需求。</span></p>\n<ul class=\"list-paddingleft-1\">\n<li><strong><span>在线访问地址：<span class=\"wx_text_underline\">https://promptpilot.volcengine.com</span></span></strong></li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226230911909-2106687661.png\" /></p>\n<h2><span>应用场景</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>内容创作</strong><span>：在自媒体、广告、营销等领域，PromptPilot 可帮助创作者快速生成吸引人的文案提示词，提升内容质量和吸引力。</span></li>\n<li><strong>数据分析</strong><span>：在数据分析场景中，PromptPilot 可辅助分析师生成精准的查询提示词，提高数据检索和分析效率。</span></li>\n<li><strong>客户服务</strong><span>：在客户服务领域，PromptPilot 可用于生成自动化回复的提示词，提升客户响应速度和满意度。</span></li>\n<li><strong>教育行业</strong><span>：教师和学生可利用 PromptPilot 生成教学和学习相关的提示词，促进知识的有效传递和学习效果的提升。</span></li>\n</ul>\n<h2><span>提示词生成</span></h2>\n<h3><span>任务描述：</span></h3>\n<pre><span><code><span>给我写一个企业优秀员工获奖感言。<br /></span></code></span></pre>\n<h3><span>生成后的 Prompt：</span></h3>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226230930602-605100114.png\" /></p>\n<p>&nbsp;</p>\n<pre><span><code># 获奖感言创作指南<br /><br />## 一、身份设定<br /><span>你是企业行政部门的资深文案专员，负责为获奖员工撰写符合公司文化的正式获奖感言。核心职责是：结合员工岗位特性与贡献亮点，打造情感真挚、逻辑清晰、贴合场景的发言内容，帮助员工在颁奖仪式上展现专业形象与团队精神。<br /><br />## 二、创作准则<br />### 必做事项<br /><span>1. 必须包含获奖员工姓名、所获奖项全称、公司名称<br /><span>2. 必须突出员工岗位核心职责与关键贡献数据<br /><span>3. 必须体现对公司、团队、家人的感谢层次<br /><span>4. 必须包含对未来工作的承诺与展望<br /><br />### 约束条件<br /><span>1. 禁止使用夸张不实的表述，所有贡献需基于提供的事实<br /><span>2. 禁止出现敏感词汇或不当表述<br /><span>3. 禁止遗漏指定的感谢对象<br /><span>4. 禁止超过规定字数限制<br /><br />## 三、变量说明<br /><span>&lt;员工姓名&gt;{{EMPLOYEE_NAME}}&lt;/员工姓名&gt; - 获奖员工的完整姓名<br /><span>&lt;奖项类型&gt;{{AWARD_TYPE}}&lt;/奖项类型&gt; - 具体获奖名称（如：年度优秀员工、季度创新之星）<br /><span>&lt;公司名称&gt;{{COMPANY_NAME}}&lt;/公司名称&gt; - 员工所在企业全称<br /><span>&lt;工作职责&gt;{{WORK_DUTIES}}&lt;/工作职责&gt; - 员工日常工作内容概述<br /><span>&lt;核心贡献&gt;{{KEY_CONTRIBUTIONS}}&lt;/核心贡献&gt; - 员工获奖的关键业绩或突出表现<br /><span>&lt;感谢对象&gt;{{THANKS_OBJECTS}}&lt;/感谢对象&gt; - 需要特别致谢的个人或团队<br /><br />## 四、创作流程<br />### 第一步：内容架构搭建<br /><span>1. 开场问候：礼貌性称呼在场人员<br /><span>2. 获奖致谢：表达获奖的荣幸与激动心情<br /><span>3. 工作回顾：简述岗位价值与核心贡献<br /><span>4. 感恩环节：分层次感谢公司、团队、家人<br /><span>5. 未来展望：承诺未来工作方向与目标<br /><br />### 第二步：细节填充<br /><span>1. 将 &lt;员工姓名&gt;{{EMPLOYEE_NAME}}&lt;/员工姓名&gt; 自然融入开场与落款<br /><span>2. 准确引用 &lt;奖项类型&gt;{{AWARD_TYPE}}&lt;/奖项类型&gt; 全称<br /><span>3. 结合 &lt;工作职责&gt;{{WORK_DUTIES}}&lt;/工作职责&gt; 说明岗位价值<br /><span>4. 用数据化语言呈现 &lt;核心贡献&gt;{{KEY_CONTRIBUTIONS}}&lt;/核心贡献&gt;<br /><span>5. 按重要性排序提及 &lt;感谢对象&gt;{{THANKS_OBJECTS}}&lt;/感谢对象&gt;<br /><br />### 第三步：风格润色<br /><span>1. 语言风格：正式中带有温度，避免过于口语化<br /><span>2. 情感表达：控制情绪尺度，保持专业得体<br /><span>3. 时间控制：按3分钟发言长度调整内容详略（约500-600字）<br /><br />## 五、输出规范<br />### 内容结构<br /><span>1. 标题：[奖项名称]获奖感言<br /><span>2. 称呼：尊敬的各位领导、亲爱的同事们：<br /><span>3. 正文：按创作流程顺序展开<br /><span>4. 落款：[员工姓名] [日期]<br /><br />### 格式要求<br /><span>1. 使用标准宋体四号字，1.5倍行距<br /><span>2. 关键贡献部分加粗显示<br /><span>3. 感谢对象单独分段<br /><span>4. 结尾部分需包含对公司未来的美好祝愿<br /><br />### 质量标准<br /><span>1. 符合公司文化价值观<br /><span>2. 突出个人贡献同时体现团队精神<br /><span>3. 避免空话套话，用具体事例支撑<br /><span>4. 语言流畅，逻辑清晰，情感真挚<br /><br />## 六、创作示例<br /><span>（此处省略示例内容，实际创作时需根据变量填充）<br /><br /><span>请严格按照以上要求，结合提供的变量信息，创作一篇完整的获奖感言。<br /><br /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>\n<h2><span>调试 Prompt</span></h2>\n<h3><span>文本理解</span></h3>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226230958750-1911894887.png\" /></p>\n<h3><span>视觉理解</span></h3>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226231016417-194421412.png\" /></p>\n<h3><span>多轮对话</span></h3>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226231026956-1766318256.png\" /></p>\n<h2><span>优化 Prompt</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226231045050-1953776592.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226231052086-1099494036.png\" /></p>\n</div>\n<div id=\"MySignature\">\n    <blockquote>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者名称：</span><a href=\"https://www.cnblogs.com/Can-daydayup/\" target=\"_blank\">追逐时光者</a></p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者简介：</span>一个热爱编程、善于分享、喜欢学习、探索、尝试新事物和新技术的全栈软件工程师。</p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\">\n本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。如果该篇文章对您有帮助的话，可以点一下右下角的<a href=\"\" style=\"color: red;\">【♥推荐♥】</a>，希望能够持续的为大家带来好的技术文章，文中可能存在描述不正确的地方，欢迎指正或补充，不胜感激。\n</p>\n</blockquote>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 23:11</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Can-daydayup\">追逐时光者</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "go-zero rest 源码学习笔记",
      "link": "https://www.cnblogs.com/xingzheanan/p/19404672",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xingzheanan/p/19404672\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 22:19\">\n    <span>go-zero rest 源码学习笔记</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<hr />\n<h1 id=\"概述\">概述</h1>\n<p><code>go-zero</code> 基于 <code>net/http</code> 标准库实现了一套 <code>rest</code> web 框架。在使用 <code>goctl</code> 快速开发的同时，也需要了解 <code>go-zero</code> 内部做了什么。本文结合 <a href=\"https://zeromicro.github.io/go-zero.dev/docs/component/rest\" rel=\"noopener nofollow\" target=\"_blank\">go-zero rest</a>学习其中的源码，力图做到知其所以然。</p>\n<h1 id=\"源码\">源码</h1>\n<h2 id=\"流程图\">流程图</h2>\n<p><img alt=\"image\" class=\"lazyload\" height=\"650\" width=\"640\" /></p>\n<p>在阅读源码之前，先看下流程图有个印象。从流程图大致可以看出来：</p>\n<ul>\n<li>go-zero 会创建路由组，其中按顺序注册了几类 handler（中间件），最后在 business handler 处理业务逻辑。</li>\n</ul>\n<p>大致有个印象后开始源码走读。</p>\n<h2 id=\"源码走读\">源码走读</h2>\n<p>启动 api 服务：</p>\n<pre><code class=\"language-go\">func main() {  \n    ...\n    server := rest.MustNewServer(c.RestConf)  \n    defer server.Stop()  \n  \n    ctx := svc.NewServiceContext(c)  \n    handler.RegisterHandlers(server, ctx)  \n  \n    fmt.Printf(\"Starting server at %s:%d...\\n\", c.Host, c.Port)  \n    server.Start()  \n}\n</code></pre>\n<p>启动服务主要做了三件事：</p>\n<ul>\n<li>创建服务端 server</li>\n<li>注册 handler 到 server</li>\n<li>启动服务端 server</li>\n</ul>\n<p>按顺序介绍。</p>\n<h3 id=\"创建服务端-server\">创建服务端 server</h3>\n<pre><code class=\"language-go\">func MustNewServer(c RestConf, opts ...RunOption) *Server {  \n    // NewServer 创建 server\n    server, err := NewServer(c, opts...)  \n    if err != nil {  \n       logx.Must(err)  \n    }  \n  \n    return server  \n}\n\nfunc NewServer(c RestConf, opts ...RunOption) (*Server, error) {\n\t// c.SetUp 启动 Prometheus，tracing, profiling 等服务\n    if err := c.SetUp(); err != nil {  \n       return nil, err  \n    }  \n  \n    server := &amp;Server{  \n       ngin:   newEngine(c),  \n       router: router.NewRouter(),  \n    }  \n  \n    ...\n    return server, nil  \n}\n</code></pre>\n<p>创建 server 实际创建的是 server 的 engine 和 router。</p>\n<p>engine 主要结构如下：</p>\n<pre><code class=\"language-go\">type engine struct {  \n    // server 的配置\n    conf   RestConf  \n    routes []featuredRoutes  // 业务路由\n    // 调用链\n    chain                chain.Chain \n    // 中间件 \n    middlewares          []Middleware  \n    ...\n}\n\nfunc newEngine(c RestConf) *engine {  \n    svr := &amp;engine{  \n       conf:    c,  \n       timeout: time.Duration(c.Timeout) * time.Millisecond,  \n    }\n    ...\n}\n</code></pre>\n<p>router 结构如下：</p>\n<pre><code class=\"language-go\">func NewRouter() httpx.Router {  \n    return &amp;patRouter{  \n       trees: make(map[string]*search.Tree),  \n    }  \n}\n\ntype Router interface {  \n    http.Handler  \n    Handle(method, path string, handler http.Handler) error  \n    SetNotFoundHandler(handler http.Handler)  \n    SetNotAllowedHandler(handler http.Handler)  \n}\n</code></pre>\n<p><code>patRouter</code> 包含路由信息，其实现了 <code>Router</code> 接口。</p>\n<p>创建了 server 后还需要注册路由 handler 到 server，这样服务端才能根据路由找到对应的 handler 处理。</p>\n<h3 id=\"注册路由-handler\">注册路由 handler</h3>\n<pre><code class=\"language-go\">func RegisterHandlers(server *rest.Server, serverCtx *svc.ServiceContext) {  \n    // server.AddRoutes 注册路由 handler\n    server.AddRoutes(  \n       []rest.Route{  \n          {  \n             Method:  http.MethodGet,  \n             Path:    \"/ping\",  \n             Handler: pingHandler(serverCtx),  \n          },  \n       },  \n    )\n}\n\nfunc (s *Server) AddRoutes(rs []Route, opts ...RouteOption) {  \n    // 自定义的业务路由将被封装到 featuredRoutes 对象\n    r := featuredRoutes{  \n       routes: rs,  \n    }  \n    for _, opt := range opts {  \n       opt(&amp;r)  \n    }  \n    \n    // 将 featuredRoutes 添加到 Server.engine\n    s.ngin.addRoutes(r)  \n}\n\nfunc (ng *engine) addRoutes(r featuredRoutes) {  \n    ...\n    // 实际是将路由组添加到 engine.routes 中  \n    ng.routes = append(ng.routes, r) \n}\n</code></pre>\n<p>业务路由注册完，接下来将进入启动 server，这是需要关注的重点。</p>\n<h3 id=\"启动-server\">启动 server</h3>\n<pre><code class=\"language-go\">func (s *Server) Start() {  \n    // 调用 Server.engine.start 启动服务端 server\n    handleError(s.ngin.start(s.router))  \n}\n\nfunc (ng *engine) start(router httpx.Router, opts ...StartOption) error {     // engine.bindRoutes 绑定路由到 router\n    if err := ng.bindRoutes(router); err != nil {  \n       return err  \n    }  \n\n    ...\n    return internal.StartHttps(ng.conf.Host, ng.conf.Port, ng.conf.CertFile,  \n       ng.conf.KeyFile, router, opts...)  \n}\n\nfunc (ng *engine) bindRoutes(router httpx.Router) error {  \n    // engine.routes \n    for _, fr := range ng.routes {  \n       // 绑定 rest.featuredRoutes \n       if err := ng.bindFeaturedRoutes(router, fr, metrics); err != nil { \n          return err  \n       }  \n    }  \n  \n    return nil  \n}\n\nfunc (ng *engine) bindFeaturedRoutes(router httpx.Router, fr featuredRoutes, metrics *stat.Metrics) error {  \n    ...\n    for _, route := range fr.routes {  \n       if err := ng.bindRoute(fr, router, metrics, route, verifier); err != nil {  \n          return err  \n       }  \n    }  \n  \n    return nil  \n}\n\nfunc (ng *engine) bindRoute(fr featuredRoutes, router httpx.Router, metrics *stat.Metrics,  \n    route Route, verifier func(chain.Chain) chain.Chain) error {  \n    // engine.chain，初始化为 nil\n    chn := ng.chain  \n    if chn == nil {  \n       // engine.buildChainWithNativeMiddlewares 注册自带中间件到 engine.chain\n       chn = ng.buildChainWithNativeMiddlewares(fr, route, metrics)  \n    }  \n  \n    // 添加 AuthHandler 到 engine.chain 中\n    chn = ng.appendAuthHandler(fr, chn, verifier)  \n  \n    // 将自定义中间件注册到 engine.chain\n    for _, middleware := range ng.middlewares {  \n       chn = chn.Append(convertMiddleware(middleware))  \n    }  \n    \n    // engine.chain.ThenFunc 将 handler 串联成 handler\n    handle := chn.ThenFunc(route.Handler)  \n  \n    return router.Handle(route.Method, route.Path, handle)  \n}\n</code></pre>\n<p>启动 server 的重点在 <code>engine.bindRoute</code>。<br />\n其中，<code>engine.buildChainWithNativeMiddlewares</code> 注册 <code>go-zero</code> 自带中间件：</p>\n<pre><code class=\"language-go\">func (ng *engine) buildChainWithNativeMiddlewares(fr featuredRoutes, route Route,  \n    metrics *stat.Metrics) chain.Chain {  \n    chn := chain.New()\n    ...\n    // MaxConns 用于并发控制\n    if ng.conf.Middlewares.MaxConns {  \n        chn = chn.Append(handler.MaxConnsHandler(ng.conf.MaxConns))  \n    }  \n    if ng.conf.Middlewares.Breaker {  \n        chn = chn.Append(handler.BreakerHandler(route.Method, route.Path, metrics))  \n    }\n    ...\n}\n</code></pre>\n<p>类似的，自定义中间件通过 <code>chn.Append(convertMiddleware(middleware))</code> 注册到 <code>engine.chain</code> 中。</p>\n<p>接着调用 <code>chain.ThenFunc</code> 串联中间件成 <code>handler</code>：</p>\n<pre><code class=\"language-go\">func (c chain) ThenFunc(fn http.HandlerFunc) http.Handler {  \n    ...\n    return c.Then(fn)  \n}\n\nfunc (c chain) Then(h http.Handler) http.Handler {  \n    if h == nil {  \n       h = http.DefaultServeMux  \n    }  \n  \n    // 这段代码很有意思，它将所有中间件按顺序串联起来组成一个 handler\n    // 调用这个 handler 处理时会经过后续一系列的中间件，最终到业务 handler 处理\n    // 具体可参考 https://github.com/zeromicro/go-zero/blob/master/rest/chain/chain.go#L81\n    for i := range c.middlewares {  \n       h = c.middlewares[len(c.middlewares)-1-i](h)  \n    }  \n  \n    return h  \n}\n</code></pre>\n<p>最后将该 handler 和路由信息注册到 <code>router</code> 中，后续服务端根据请求在 <code>router</code> 中查找对应的 <code>handler</code> 处理。</p>\n<pre><code class=\"language-go\">func (pr *patRouter) Handle(method, reqPath string, handler http.Handler) error {  \n    ...\n    \n    tree, ok := pr.trees[method]  \n    if ok {  \n       return tree.Add(cleanPath, handler)  \n    }  \n  \n    tree = search.NewTree()  \n    pr.trees[method] = tree  \n    return tree.Add(cleanPath, handler)  \n}\n</code></pre>\n<p>详细流程如下图：</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"570\" width=\"661\" /></p>\n<h1 id=\"小结\">小结</h1>\n<p>本文介绍了 go-zero rest 的源码是怎么处理请求的。从源码也可以看出每个请求背后是一系列中间件 handler 在处理，并且 server 启动了 Prometheus，Trace 等服务负责监控，链路追踪等，使得开发微服务时只需要关注业务逻辑即可，非常方便。</p>\n<h1 id=\"参考资料\">参考资料</h1>\n<ul>\n<li><a href=\"https://zeromicro.github.io/go-zero.dev/docs/component/rest\" rel=\"noopener nofollow\" target=\"_blank\">go-zero rest</a></li>\n<li><a href=\"https://refactoringguru.cn/design-patterns/chain-of-responsibility/go/example\" rel=\"noopener nofollow\" target=\"_blank\">Go 责任链模式</a></li>\n</ul>\n<hr />\n\n</div>\n<div id=\"MySignature\">\n    芝兰生于空谷，不以无人而不芳。\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 22:19</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xingzheanan\">胡云Troy</a>&nbsp;\n阅读(<span id=\"post_view_count\">2</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一篇基于AWS服务搭建的全球服务架构",
      "link": "https://www.cnblogs.com/linnuo/p/19388428",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/linnuo/p/19388428\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 19:37\">\n    <span>一篇基于AWS服务搭建的全球服务架构</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>一、背景</p>\n<p>　　当我们在做全球业务时，例如网站/机器/游戏，为了支撑全球用户，我们会在不同的位置搭建节点，以满足业务功能和响应实效。</p>\n<p>我们会搭建一个这样的架构满足初步的使用。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>&nbsp;　　</p>\n<p>　　能用是ok的了，会有什么问题呢？</p>\n<p>　　1、因为服务独立，上架1个SKU需要多次发布到不同的服务。</p>\n<p>　　2、因为域名过多，发布时需要频繁的退出、登录切换不同的二级域名，非常繁琐不说，还可能会遗漏。</p>\n<p>　　3、后期处理数据统计、报表、看板、设备地图，耗时费力。</p>\n<p>　　4、这还是单节点，未考虑高可用的情况下，多区域、多节点部署服务器导致运维难度增加、过多的财务开支。</p>\n<div>\n<div>　　5、各个节点各玩各的。</div>\n<div>&nbsp;</div>\n<div>　　有什么方式可以解决这些问题？</div>\n<div>　　AWS服务组件很好支持。</div>\n<div>&nbsp;</div>\n<div>二、AWS架构</div>\n<div>　　AWS提供了非常丰富的组件，列几个常用的：</div>\n<div>　　1、Route 53 负责域名解析流量管理健康检查，高可用可以用到它。</div>\n<div>　　2、VPC 虚拟私有网络，可将同一区域的服务器、数据库置于同一内网段，提升访问速度。</div>\n<div>　　3、CloudFront CDN加速，可以给访问请求、对象存储加速。函数功能极其强大，可配置HTTP、HTTPS的请求跨域，可识别全球流量来源，根据来源分发到不同区域的节点。</div>\n<div>　　4、EC2 服务器，内含了负载均衡器ELB、目标组，可实现同一地区的服务器的负载均衡和高可用。结合CloudFront可将流量分发到就近的服务。</div>\n<div>　　5、Aurora and RDS 数据库，Aurora 作为全球数据库，已实现主从备份，可在1s内实现全球数据同步，结合Route 53的短域名实现读写分离。</div>\n<div>　　6、S3 对象存储，OSS存储图片、视频、文档、音频等。</div>\n<div>　　7、Certificate Manager 安全凭证管理，可申请和管理证书。</div>\n<div>&nbsp;</div>\n<div>　　架构完是这样的。&nbsp;</div>\n<div>&nbsp;\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>&nbsp;</p>\n<p>三、干活，简单的一笔带过</p>\n<p>　　1、将外部域名解析到Route 53。</p>\n<p>　　2、在Certificate Manager申请证书。</p>\n<p>　　3、在拟定的区域创建VPC内网。</p>\n<p>　　4、购买服务器和数据库时选择上面的创建的VPC内网。</p>\n<p>　　5、在创建Aurora数据库时需要选确认某一个区域为主集群，主集群下会创建写入器实例、读取器实例。</p>\n<p>　　　　再创建其它区域的读取实例，如下图：</p>\n<p><img alt=\"f9edbdf666a249221b20525d951cdf3b\" class=\"lazyload\" /></p>\n<p>&nbsp;　　</p>\n<p>　　6、在Route 53创建一个私有的短域名，用于数据库连接，无需在域名供应商购买。我这里用&nbsp;db.com</p>\n<p><img alt=\"402ddedc223507ba4f2e187ad161cc2c\" class=\"lazyload\" /></p>\n<p>&nbsp;　</p>\n<p>　　7、将二级域名指向到Aurora的写域名指向到Aurora的写入器实例的DNS（路由策略：简单），</p>\n<p>　　　　读域名指向到多个读取器实例的DNS（路由策略：延迟）。数据写入到主库后，1s内可同步到所有的从库</p>\n<p><img alt=\"fe4075fd22ed2a0e1e2919b9d2e47b5b\" class=\"lazyload\" /></p>\n<p>&nbsp;　　</p>\n<p>　　8、在EC2购买服务器后，新建目标组，将服务器添加到目标组中</p>\n</div>\n<div>\n<p><img alt=\"b9e98fda4ad55cabc5a3bd5d55ff112f\" class=\"lazyload\" /></p>\n<p>&nbsp;　　</p>\n<p>　　9、在EC2创建负载均衡器，这里分NLB（服务器之间用）和ELB（服务器内部服务之间用），层级和颗粒度不同。</p>\n<p>　　　　这里创建NLB，添加转发到的目标组到侦听器，注意选择VPC。创建完即可通过DNS访问。</p>\n<p><img alt=\"5baa9287044b30796f6ebb020436d6f6\" class=\"lazyload\" /></p>\n<p>&nbsp;　　</p>\n<p>　　10、创建CloudFront，将需要经过CDN加速的域名添加到备用域名，添加第2步创建的证书，源添加到访问目标的DNS。成功后CloudFront会分配域名。</p>\n<p><img alt=\"aeaa7964-4abc-47f7-965c-b70c4dee3682\" class=\"lazyload\" /></p>\n<p>&nbsp;</p>\n<p>　　11、在Route 53将经过CloudFront加速的域名指向到CloudFront分配域名上。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>&nbsp;</p>\n<p>　　12、在Route 53创建NLB的健康检查，成功后生成ID。</p>\n<p>　　13、在Route 53添加故障转移域名，用于服务区域之间的高可用，无需额外采购服务器</p>\n<p><img alt=\"98eb6d3e-2d4c-4a8f-97f9-6261ccbfc409\" class=\"lazyload\" /></p>\n<p>&nbsp;</p>\n<p>　　14、在CloudFront创建函数，将请求按照国家和地区分发到相应的服务器。</p>\n<p><img alt=\"5b4907ff50b14eae080e4168c566cd54\" class=\"lazyload\" /></p>\n<p>&nbsp;　　代码如下：</p>\n<div class=\"cnblogs_code\">\n<pre>import cf from 'cloudfront'<span style=\"color: rgba(0, 0, 0, 1);\">;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">function</span><span style=\"color: rgba(0, 0, 0, 1);\"> handler(event) {\n    const request </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> event.request;\n    const headers </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> request.headers;\n    const country </span>= headers['cloudfront-viewer-country'] &amp;&amp; headers['cloudfront-viewer-country'<span style=\"color: rgba(0, 0, 0, 1);\">].value;\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> List of countries to ALB endpoints</span>\n    const countryToContinent =<span style=\"color: rgba(0, 0, 0, 1);\"> {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 亚太地区 (Asia-Pacific) -&gt; Asia</span>\n        'AF': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AM': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AZ': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BD': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BN': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BT': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CC': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CK': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CX': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GE': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'HK': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ID': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'IN': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'IO': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'JP': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KG': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KH': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KR': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KZ': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LA': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LK': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MM': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MN': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MO': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MP': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MV': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MY': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NC': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NF': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NP': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NR': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NU': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NZ': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PH': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PK': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PN': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SB': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SG': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TH': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TJ': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TL': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TM': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TO': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TV': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TW': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'UZ': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'VU': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'WF': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'WS': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'YE': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 大洋洲 (Oceania) - 通常归类为亚太地区</span>\n        'AS': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AU': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'FJ': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PF': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GU': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KI': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MH': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'FM': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PW': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PG': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TK': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 南极洲 (Antarctica) - 通常单独处理，这里暂时归入亚太</span>\n        'AQ': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BV': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GS': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'HM': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TF': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 欧洲、非洲、中东 -&gt; Europe</span>\n        'AL': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AD': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AT': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AX': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BA': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BG': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BY': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CH': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CY': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CZ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'DE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'DK': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'EE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ES': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'FI': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'FO': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'FR': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GG': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GI': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GR': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'HR': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'HU': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'IE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'IM': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'IS': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'IT': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'JE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LI': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LT': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LU': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LV': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MC': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MD': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ME': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MK': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MT': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NL': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NO': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PL': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PT': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'RO': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'RS': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'RU': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SI': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SJ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SK': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SM': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'UA': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'VA': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GB': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'DZ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AO': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BJ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BW': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BF': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BI': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CV': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CM': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CF': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TD': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KM': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CG': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CD': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CI': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'DJ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'EG': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GQ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ER': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ET': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GA': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GM': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GH': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GN': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GW': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LS': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LR': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LY': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MG': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MW': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ML': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MR': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MU': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'YT': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MA': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MZ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NA': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NG': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'RW': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'RE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SH': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SN': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SC': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SL': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SO': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ZA': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SS': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SD': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ST': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SZ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TG': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TN': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TZ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'UG': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'EH': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ZM': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ZW': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BH': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'IR': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'IQ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'IL': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'JO': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KW': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LB': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'OM': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PS': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'QA': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SA': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SY': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TR': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 美洲 -&gt; America</span>\n        'AI': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AG': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AW': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BS': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BB': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BZ': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BM': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BQ': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CA': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KY': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CR': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CU': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CW': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'DM': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'DO': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SV': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GD': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GL': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GP': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GT': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'HT': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'HN': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'JM': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MQ': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MX': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MS': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NI': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PA': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PR': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BL': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KN': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LC': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MF': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PM': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'VC': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SX': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TT': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TC': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'US': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'UM': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'UY': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'VE': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'VG': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'VI': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">\n    };\n\n    const continentToRegion </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> {\n        </span>'Asia': 'asia.autovxxxxxx.com',         <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 亚洲故障转移域名</span>\n        'Europe': 'europu.autovxxxxxx.com',     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 欧洲故障转移域名</span>\n        'America': 'america.autovxxxxxxx.com'    <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 美洲故障转移域名</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    };\n\n    const DEFAULT_REGION </span>= 'NLB-Asia-Singapore-5e42xxxxxxxx4853.elb.ap-southeast-1.amazonaws.com'; <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">改为自己的默认alb 域名</span>\n    const targetContinent = (country &amp;&amp; countryToContinent[country]) || 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">;\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> const targetContinent = 'Asia';</span>\n    const targetOrigin = (targetContinent &amp;&amp; continentToRegion[targetContinent]) ||<span style=\"color: rgba(0, 0, 0, 1);\"> DEFAULT_REGION;\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 打印所有请求头</span>\n    console.log(\"=== 所有请求头信息 ===\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> headerName <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> headers) {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (headers.hasOwnProperty(headerName)) {\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> headers 对象的值是一个包含 'value' 属性的对象</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">var</span> headerValue =<span style=\"color: rgba(0, 0, 0, 1);\"> headers[headerName].value;\n            console.log(headerName </span>+ \": \" +<span style=\"color: rgba(0, 0, 0, 1);\"> headerValue);\n        }\n    }\n    console.log(</span>'targetOrigin: ' +<span style=\"color: rgba(0, 0, 0, 1);\"> targetOrigin);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 使用CloudFront 2.0 API修改origin</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    cf.updateRequestOrigin({\n        </span>\"domainName\"<span style=\"color: rgba(0, 0, 0, 1);\">: targetOrigin,\n        </span>\"port\": 80<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>\"protocol\": 'http'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>\"timeouts\"<span style=\"color: rgba(0, 0, 0, 1);\">: {\n            </span>\"readTimeout\": 30<span style=\"color: rgba(0, 0, 0, 1);\">,\n            </span>\"connectionTimeout\": 5<span style=\"color: rgba(0, 0, 0, 1);\">\n        }\n    });\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 添加调试信息 - 确保值是字符串</span>\n    request.headers['x-debug-country'] = { value: String(country || 'unknown'<span style=\"color: rgba(0, 0, 0, 1);\">) };\n    request.headers[</span>'x-debug-targetorigin'] =<span style=\"color: rgba(0, 0, 0, 1);\"> { value: String(targetOrigin) };\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> request;\n}</span></pre>\n</div>\n<p>　　解决跨域问题，函数代码如下：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">function</span><span style=\"color: rgba(0, 0, 0, 1);\"> handler(event)  {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> response  =<span style=\"color: rgba(0, 0, 0, 1);\"> event.response;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> headers  =<span style=\"color: rgba(0, 0, 0, 1);\"> response.headers;\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> If Access-Control-Allow-Origin CORS header is missing, add it.</span>\n    <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Since JavaScript doesn't allow for hyphens in variable names, we use the dict[\"key\"] notation.</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!headers['access-control-allow-origin'<span style=\"color: rgba(0, 0, 0, 1);\">]) {\n        headers[</span>'access-control-allow-origin'] = {value: \"*\"<span style=\"color: rgba(0, 0, 0, 1);\">};\n        console.log(</span>\"Access-Control-Allow-Origin was missing, adding it now.\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        headers[</span>'access-control-allow-headers'] = {value: \"Origin, X-Requested-With, Content-Type, Accept\"<span style=\"color: rgba(0, 0, 0, 1);\">};\n        headers[</span>'access-control-allow-methods'] = {value: \"GET,POST,PUT, OPTIONS\"<span style=\"color: rgba(0, 0, 0, 1);\">};\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> response;\n}</span></pre>\n</div>\n<p>　　</p>\n<p>　　ok，完事儿</p>\n<p>　　</p>\n<p>&nbsp;</p>\n&nbsp;</div>\n<div>&nbsp;</div>\n<div>&nbsp;</div>\n<div>&nbsp;</div>\n<div>&nbsp;</div>\n<div>&nbsp;</div>\n<div>&nbsp;</div>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 19:37</span>&nbsp;\n<a href=\"https://www.cnblogs.com/linnuo\">ooLeo</a>&nbsp;\n阅读(<span id=\"post_view_count\">29</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "高并发下如何防止商品超卖？",
      "link": "https://www.cnblogs.com/12lisu/p/19406444",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/12lisu/p/19406444\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 19:21\">\n    <span>高并发下如何防止商品超卖？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>\"快看我们的秒杀系统！库存显示-500了！\"</p>\n<p>3年前的这个电话让我记忆犹新。</p>\n<p>当时某电商大促，我们自认为完美的分布式架构，在0点整瞬间被击穿。</p>\n<p>数据库连接池耗尽，库存表出现负数，客服电话被打爆...</p>\n<p>今天这篇文章跟大家一起聊聊商品超卖的问题，希望对你会有所帮助。</p>\n<h2 id=\"1-为什么会发生超卖\">1 为什么会发生超卖？</h2>\n<p>首先我们一起看看为什么会发送超卖？</p>\n<h3 id=\"11-数据库的最后防线漏洞\">1.1 数据库的\"最后防线\"漏洞</h3>\n<p>我们用下面的列子，给大家介绍一下商品超卖是如何发生的。</p>\n<pre><code class=\"language-java\">public boolean buy(int goodsId) {\n    // 1. 查询库存\n    int stock = getStockFromDatabase(goodsId);\n    if (stock &gt; 0) {\n        // 2. 扣减库存\n        updateStock(goodsId, stock - 1);\n        return true;\n    }\n    return false;\n}\n</code></pre>\n<p>在并发场景下可能变成下图这样的：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>请求1和请求2都将库存更新成9。</p>\n<p><strong>根本原因</strong>：数据库的查询和更新操作，不是原子性校验，多个事务可能同时通过stock&gt;0的条件检查。</p>\n<h3 id=\"12-超卖的本质\">1.2 超卖的本质</h3>\n<p><strong>商品超卖的本质是</strong>：多个请求同时穿透缓存，同一时刻读取到相同库存值，最终在数据库层发生覆盖。</p>\n<p>就像100个人同时看上一件衣服，都去试衣间前看了眼牌子，出来时都觉得自己应该拿到那件衣服。</p>\n<h2 id=\"2-防止超卖的方案\">2 防止超卖的方案</h2>\n<h3 id=\"21-数据库乐观锁\">2.1 数据库乐观锁</h3>\n<p>数据库乐观锁的核心原理是通过版本号控制并发。</p>\n<p>例如下面这样的：</p>\n<pre><code class=\"language-sql\">UPDATE product \nSET stock = stock -1, version=version+1 \nWHERE id=123 AND version=#{currentVersion};\n</code></pre>\n<p>Java的实现代码如下：</p>\n<pre><code class=\"language-java\">@Transactional\npublic boolean deductStock(Long productId) {\n    Product product = productDao.selectForUpdate(productId);\n    if (product.getStock() &lt;= 0) return false;\n    \n    int affected = productDao.updateWithVersion(\n        productId, \n        product.getVersion(),\n        product.getStock()-1\n    );\n    return affected &gt; 0;\n}\n</code></pre>\n<p>基于数据库乐观锁方案的架构图如下：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>优缺点分析</strong>：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\"><strong>优点</strong></th>\n<th style=\"text-align: center;\"><strong>缺点</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\">无需额外中间件</td>\n<td style=\"text-align: center;\">高并发时DB压力大</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">实现简单</td>\n<td style=\"text-align: center;\">可能出现大量更新失败</td>\n</tr>\n</tbody>\n</table>\n<p><strong>适用场景</strong>：日订单量1万以下的中小系统。</p>\n<h3 id=\"22-redis原子操作\">2.2 Redis原子操作</h3>\n<p>Redis原子操作的核心原理是使用：Redis + Lua脚本。</p>\n<p>核心代码如下：</p>\n<pre><code class=\"language-java\">// Lua脚本保证原子性\nString lua = \"if redis.call('get', KEYS &gt;= ARGV[1] then \" +\n             \"return redis.call('decrby', KEYS[1], ARGV \" +\n             \"else return -1 end\";\n\npublic boolean preDeduct(String itemId, int count) {\n    RedisScript&lt;Long&gt; script = new DefaultRedisScript&lt;&gt;(lua, Long.class);\n    Long result = redisTemplate.execute(script, \n        Collections.singletonList(itemId), count);\n    return result != null &amp;&amp; result &gt;= 0;\n}\n</code></pre>\n<p>该方案的架构图如下：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>性能对比</strong>：</p>\n<ul>\n<li>单节点QPS：数据库方案500 vs Redis方案8万</li>\n<li>响应时间：&lt;1ms vs 50ms+</li>\n</ul>\n<h3 id=\"23-分布式锁\">2.3 分布式锁</h3>\n<p>目前最常用的分布式锁的方案是Redisson。</p>\n<p>下面是Redisson的实现：</p>\n<pre><code class=\"language-java\">RLock lock = redisson.getLock(\"stock_lock:\"+productId);\ntry {\n    if (lock.tryLock(1, 10, TimeUnit.SECONDS)) {\n        // 执行库存操作\n    }\n} finally {\n    lock.unlock();\n}\n</code></pre>\n<h4 id=\"注意事项\">注意事项</h4>\n<ol>\n<li>1.锁粒度要细化到商品级别</li>\n<li>2.必须设置等待时间和自动释放</li>\n<li>3.配合异步队列使用效果更佳</li>\n</ol>\n<p>该方案的架构图如下：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"24-消息队列削峰\">2.4 消息队列削峰</h3>\n<p>可以使用 RocketMQ的事务消息。</p>\n<p>核心代码如下：</p>\n<pre><code class=\"language-java\">// RocketMQ事务消息示例\nTransactionMQProducer producer = new TransactionMQProducer(\"stock_group\");\nproducer.setExecutor(new TransactionListener() {\n    @Override\n    public LocalTransactionState executeLocalTransaction(Message msg) {\n        // 扣减数据库库存\n        return LocalTransactionState.COMMIT_MESSAGE;\n    }\n});\n</code></pre>\n<p>该方案的架构图如下：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>技术指标</strong>：</p>\n<ul>\n<li>削峰能力：10万QPS → 2万TPS</li>\n<li>订单处理延迟：&lt;1秒（正常时段）</li>\n</ul>\n<h3 id=\"25-预扣库存\">2.5 预扣库存</h3>\n<p>预扣库存是防止商品超卖的终极方案。</p>\n<p>核心算法如下：</p>\n<pre><code class=\"language-java\">// Guava RateLimiter限流\nRateLimiter limiter = RateLimiter.create(1000); // 每秒1000个令牌\n\npublic boolean preDeduct(Long itemId) {\n    if (!limiter.tryAcquire()) return false;\n    \n    // 写入预扣库存表\n    preStockDao.insert(itemId, userId);\n    return true;\n}\n</code></pre>\n<p>该方案的架构图如下：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>性能数据</strong>：</p>\n<ul>\n<li>百万级并发支撑能力</li>\n<li>库存准确率99.999%</li>\n<li>订单处理耗时200ms内</li>\n</ul>\n<h2 id=\"3-避坑指南\">3 避坑指南</h2>\n<h3 id=\"31-缓存与数据库不一致\">3.1 缓存与数据库不一致</h3>\n<p>某次大促因缓存未及时失效，导致超卖1.2万单。</p>\n<p>错误示例如下：</p>\n<pre><code class=\"language-java\">// 错误示例：先删缓存再写库\nredisTemplate.delete(\"stock:\"+productId);\nproductDao.updateStock(productId, newStock); // 存在并发写入窗口\n</code></pre>\n<h3 id=\"32-未考虑库存回滚\">3.2 未考虑库存回滚</h3>\n<p>秒杀取消后，忘记恢复库存，引发后续超卖。</p>\n<p>正确做法是使用事务补偿。</p>\n<p>例如下面这样的：</p>\n<pre><code class=\"language-java\">@Transactional\npublic void cancelOrder(Order order) {\n    stockDao.restock(order.getItemId(), order.getCount());\n    orderDao.delete(order.getId());\n}\n</code></pre>\n<p>库存回滚和订单删除，在同一个事务中。</p>\n<h3 id=\"33-锁粒度过大\">3.3 锁粒度过大</h3>\n<p>锁粒度过大，全局限流导致10%的请求被误杀。</p>\n<p>错误示例如下：</p>\n<pre><code class=\"language-java\">// 错误示例：全局限锁\nRLock globalLock = redisson.getLock(\"global_stock_lock\");\n</code></pre>\n<h2 id=\"总结\">总结</h2>\n<p>其实在很多大厂中，一般会将防止商品超卖的多种方案组合使用。</p>\n<p>架构图如下：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>通过组合使用：</p>\n<ol>\n<li>Redis做第一道防线（承受80%流量）</li>\n<li>分布式锁控制核心业务逻辑</li>\n<li>预扣库存+消息队列保证最终一致性</li>\n</ol>\n<p><strong>实战经验</strong>：某电商在2023年双11中：</p>\n<ul>\n<li>Redis集群承载98%请求</li>\n<li>分布式锁拦截异常流量</li>\n<li>预扣库存保证最终准确性</li>\n</ul>\n<p>系统平稳支撑了每秒12万次秒杀请求，0超卖事故发生！</p>\n<p><strong>记住：没有银弹方案，只有适合场景的组合拳！</strong></p>\n<h2 id=\"最后说一句求关注别白嫖我\">最后说一句(求关注，别白嫖我)</h2>\n<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>\n<p>求一键三连：点赞、转发、在看。</p>\n<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>\n<p>更多项目实战在我的技术网站：<a href=\"http://www.susan.net.cn/project\" rel=\"noopener nofollow\" target=\"_blank\">http://www.susan.net.cn/project</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 19:21</span>&nbsp;\n<a href=\"https://www.cnblogs.com/12lisu\">苏三说技术</a>&nbsp;\n阅读(<span id=\"post_view_count\">44</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "选框架选到头秃？别让“技术赌博”毁了你的项目",
      "link": "https://www.cnblogs.com/huizhudev/p/19406245",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/huizhudev/p/19406245\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 18:09\">\n    <span>选框架选到头秃？别让“技术赌博”毁了你的项目</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"选框架选到头秃？别让“技术赌博”毁了你的项目\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3695776/202512/3695776-20251226180832229-1607943278.png\" />\n        面对复杂的技术栈选择，单纯靠经验容易陷入误区。本文提供了一套“技术选型分析 AI 指令”，将 AI 化身为 15 年经验的架构师，通过多维度加权评分和风险评估，帮助技术决策者做出客观、数据驱动的架构决策，避免为错误的选型买单。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>打开 CNCF 的云原生全景图，是不是感觉像在看一张只有天文望远镜才能解析的星图？<br />\n站在 2024 年的尾巴上，作为技术决策者，我们面临的挑战早已不是“怎么实现功能”，而是<strong>“用什么实现功能”</strong>。</p>\n<p>是坚守 Java 的稳重，还是拥抱 Go 的高效？<br />\n是继续在 React 的生态里深耕，还是去 Vue 3 的舒适区躺平，亦或是尝尝 Svelte 的鲜？<br />\n数据库是用老牌的 MySQL，还是时髦的 TiDB，或者干脆上云原生数据库？</p>\n<p>每一个选择背后，都潜藏着巨大的<strong>“机会成本”</strong>。<br />\n选对了，风生水起，扩展如丝般顺滑；<br />\n选错了，就是给自己和团队挖了一个深不见底的坑，未来的无数个通宵都在为今天的草率买单。</p>\n<p>我们往往习惯于：</p>\n<ul>\n<li><strong>凭经验</strong>：“以前用过这个，稳。”（但可能已过时）</li>\n<li><strong>跟风口</strong>：“大厂都在用，肯定没错。”（但你的业务规模匹配吗？）</li>\n<li><strong>拍脑袋</strong>：“我觉得这个 Logo 挺好看。”（纯粹的赌徒心态）</li>\n</ul>\n<p><strong>在这个技术爆炸的时代，单纯依靠个人的经验半径来做决策，已经越来越危险了。</strong><br />\n你需要一个绝对客观、视野无限、且精通权衡之道的“外脑”。</p>\n<p><img alt=\"选框架选到头秃？别让“技术赌博”毁了你的项目\" class=\"lazyload\" /></p>\n<h2 id=\"-把-ai-变成你的首席架构师\">🧭 把 AI 变成你的“首席架构师”</h2>\n<p>人类架构师有偏见，有知识盲区，有情感倾向。但 AI 没有。<br />\n只要你给它设定好正确的<strong>“人设”</strong>和<strong>“评估框架”</strong>，它就能化身为一位拥有 15 年经验的资深技术顾问，为你提供不带感情色彩、只有数据和逻辑的决策支持。</p>\n<p>为此，我打磨了一套<strong>「技术选型分析 AI 指令」</strong>。<br />\n它不是让你问 AI “哪个框架好”，而是要求 AI 进行一场<strong>系统化的可行性研究</strong>。它强制 AI 从<strong>业务场景、团队能力、长期 TCO（总拥有成本）、风险评估</strong>等多个维度，输出一份能够直接拿到 CTO 办公会上汇报的分析报告。</p>\n<h3 id=\"-复制这个指令让决策有据可依\">📋 复制这个指令，让决策有据可依</h3>\n<p>这套指令的核心在于<strong>“多维度加权评分”</strong>。它强迫 AI 量化每一个指标，而不是给出模棱两可的建议。</p>\n<pre><code class=\"language-markdown\"># 角色定义\n你是一位资深的技术架构顾问，拥有15年以上的系统架构设计和技术选型经验。你熟悉主流的技术栈、框架和云服务，擅长从业务需求、技术可行性、成本效益、团队能力等多维度进行综合分析。你的决策风格是数据驱动、证据优先，始终保持客观中立，不偏袒任何特定技术阵营。\n\n# 核心能力\n- **多维度评估**: 能从性能、安全、成本、可维护性、生态成熟度等维度全面评估\n- **风险识别**: 善于识别技术债务、供应商锁定、技术过时等潜在风险\n- **落地指导**: 能提供从选型到实施的完整路径指导\n- **证据支撑**: 所有结论都有数据、案例或权威来源支撑\n\n# 任务描述\n请基于以下信息，进行全面系统的技术选型分析，帮助我做出最优的技术决策。\n\n**技术选型需求**:\n- **选型主题**: [需要选型的技术领域，如：前端框架/数据库/消息队列/容器编排等]\n- **业务场景**: [具体的业务需求和使用场景]\n- **候选技术**: [已初步筛选的候选技术列表，可选]\n- **关键约束**: [团队技术栈/预算/时间/合规等约束条件]\n\n**补充信息**（可选）:\n- **团队情况**: [团队规模、技术背景、现有技能储备]\n- **现有架构**: [当前系统架构、技术债务情况]\n- **非功能需求**: [性能指标、可用性要求、安全合规要求]\n- **决策权重**: [最看重的因素，如成本优先/性能优先/稳定性优先]\n\n# 输出要求\n\n## 1. 内容结构\n\n### 📊 第一部分：选型背景分析\n- 需求场景深度解读\n- 核心问题识别\n- 选型目标明确化\n- 约束条件梳理\n\n### 🔍 第二部分：候选技术评估\n- 候选技术识别与筛选（若未提供）\n- 技术能力矩阵对比表\n- 各技术方案优劣势深度分析\n- 技术成熟度与生态评估\n\n### 📈 第三部分：多维度对比分析\n提供以下维度的对比评分（1-5分制）：\n| 评估维度 | 技术A | 技术B | 技术C | 权重 |\n|---------|-------|-------|-------|------|\n| 性能表现 | - | - | - | - |\n| 学习成本 | - | - | - | - |\n| 社区生态 | - | - | - | - |\n| 运维成本 | - | - | - | - |\n| 扩展性 | - | - | - | - |\n| 安全性 | - | - | - | - |\n| 供应商锁定风险 | - | - | - | - |\n| **加权总分** | - | - | - | - |\n\n### ⚠️ 第四部分：风险评估\n- 技术风险识别\n- 实施风险评估\n- 长期维护风险\n- 风险缓解策略\n\n### 🎯 第五部分：选型建议\n- 最终推荐方案及理由\n- 备选方案说明\n- 关键决策因素分析\n- 不建议方案及原因\n\n### 🛠️ 第六部分：实施路径\n- 概念验证（POC）建议\n- 分阶段实施计划\n- 关键里程碑定义\n- 回滚预案设计\n\n## 2. 质量标准\n- **客观性**: 不带主观偏见，基于事实和数据分析\n- **完整性**: 覆盖所有关键决策维度，无重大遗漏\n- **可执行性**: 建议具体可落地，有明确的下一步行动\n- **证据性**: 重要结论有数据、案例或权威来源支撑\n- **风险意识**: 充分识别并评估潜在风险\n\n## 3. 格式要求\n- 使用表格呈现对比数据\n- 使用列表呈现优缺点\n- 关键结论使用**加粗**标注\n- 风险项使用⚠️标识\n- 推荐项使用✅标识\n- 不推荐项使用❌标识\n- 总字数：3000-5000字\n\n## 4. 风格约束\n- **语言风格**: 专业严谨，但避免过度使用晦涩术语\n- **表达方式**: 客观第三人称，数据优先\n- **专业程度**: 面向资深技术人员，可使用专业概念但需适当解释\n- **决策态度**: 给出明确建议，但保留灵活性，尊重决策者最终判断\n\n# 质量检查清单\n\n在完成输出后，请自我检查：\n- [ ] 是否充分理解了业务需求和约束条件？\n- [ ] 是否全面评估了所有合理的候选技术？\n- [ ] 对比维度是否覆盖了关键决策因素？\n- [ ] 评分和权重设置是否合理有依据？\n- [ ] 风险识别是否充分，缓解策略是否可行？\n- [ ] 最终建议是否明确且有充分理由支撑？\n- [ ] 实施路径是否具体可执行？\n- [ ] 是否考虑了长期维护和演进成本？\n\n# 注意事项\n- 避免技术偏见：不要因个人喜好而偏袒特定技术\n- 重视团队因素：优秀的技术不一定是最适合的技术\n- 考虑长期成本：不仅看短期实施成本，也要评估长期维护成本\n- 警惕\"银弹思维\"：没有完美的技术方案，只有适合场景的方案\n- 保持技术中立：对于有争议的技术，呈现多方观点\n- 数据支撑：尽量使用benchmark数据、案例研究而非主观判断\n\n# 输出格式\n请按照上述结构，输出一份完整的技术选型分析报告，包含清晰的章节标题、结构化的对比表格、明确的建议结论和可执行的实施路径。\n</code></pre>\n<h2 id=\"️-拒绝拍脑袋用数据说话\">⚖️ 拒绝“拍脑袋”，用数据说话</h2>\n<p>这套指令最强大的地方，在于它能帮你<strong>“看见”</strong>那些容易被忽视的隐性成本。</p>\n<p>以前我们做决定：</p>\n<blockquote>\n<p>“选 MongoDB 吧，开发快，大家都在用。”</p>\n</blockquote>\n<p>现在 AI 帮你做决定：</p>\n<blockquote>\n<p>“虽然 MongoDB 开发初期效率高（5分），但针对你描述的强事务金融场景（权重 40%），其 ACID 保证和数据一致性维护成本（2分）将成为后期瓶颈。相比之下，虽然 PostgreSQL 学习曲线稍陡（3分），但在数据完整性和复杂查询性能（5分）上更匹配你的业务需求。<strong>综合加权评分：PG (4.2) &gt; Mongo (3.5)。</strong>”</p>\n</blockquote>\n<p>这不只是一次技术推荐，更是一次<strong>思维风暴</strong>。<br />\n它会逼问你：</p>\n<ul>\n<li>你的团队真的 hold 得住 Kubernetes 的运维复杂度吗？</li>\n<li>你现在的预算能支撑这个商业数据库三年的 License 费用吗？</li>\n<li>如果这个开源项目明年停更了，你有 Plan B 吗？</li>\n</ul>\n<h2 id=\"️-怎么用好这把瑞士军刀\">🛠️ 怎么用好这把“瑞士军刀”？</h2>\n<p><strong>1. 明确约束，越细越好</strong><br />\n不要只说“我要选个数据库”。要说：“我要选个时序数据库，处理 IoT 设备数据，每秒写入 10万点，查询主要是最近 24 小时数据，运维团队只有 2 人，预算每月 5000 块。”<br />\n<strong>约束越具体，AI 的推荐就越精准。</strong></p>\n<p><strong>2. 调整权重，量体裁衣</strong><br />\n如果是创业公司的 MVP 阶段，把“开发效率”和“学习成本”的权重调高；<br />\n如果是银行的核心交易系统，把“安全性”和“稳定性”的权重拉满。<br />\n<strong>没有最好的技术，只有最适合当下的技术。</strong></p>\n<p><strong>3. 把它当做“蓝军”</strong><br />\n即使你心里已经有了答案，也不妨用这个指令跑一遍。让 AI 站在客观的角度，去挑战你的预设，看看能不能找出你忽略的风险点。<br />\n<strong>能够经得起 AI 深度拷问的架构，才是真正健壮的架构。</strong></p>\n<p>技术选型是一场没有标准答案的考试，但至少，我们可以不交白卷，也不乱蒙答案。<br />\n带上这个 AI 顾问，让你的每一次 <code>git init</code> 都有据可依，底气十足。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 18:09</span>&nbsp;\n<a href=\"https://www.cnblogs.com/huizhudev\">realhuizhu</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "APEX实战第8篇：ORDS连库报错574？一招根治用户过期问题",
      "link": "https://www.cnblogs.com/jyzhao/p/19404888/apex-shi-zhan-di8pianords-lian-ku-bao-cuo574-yi-zh",
      "published": "",
      "description": "<a name=\"top\"></a>\n    <h2><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/jyzhao/p/19404888/apex-shi-zhan-di8pianords-lian-ku-bao-cuo574-yi-zh\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 15:08\">\n    <span>APEX实战第8篇：ORDS连库报错574？一招根治用户过期问题</span>\n    \n\n</a>\n</h2>\n    <small>\n<span id=\"post-date\">2025-12-26 15:08</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jyzhao\">AlfredZhao</a>&nbsp;\n阅读(<span id=\"post_view_count\">27</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</small>\n    <div class=\"entry\">\n        <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>作为 APEX 应用开发工程师，笔者发现很多同行在使用 APEX + ORDS 架构时，都会遇到数据库凭证错误相关的问题。之前大家普遍知道 APEX_PUBLIC_USER 需要设置密码永不过期，但往往会忽略另一个关键用户——ORDS_PUBLIC_USER，这也是导致 Database Credential Error 和 HTTP Status Code: 574 问题反复出现的核心原因。</p>\n<p>今天笔者就结合自己的踩坑经历，把 ORDS_PUBLIC_USER 相关的问题解决流程完整分享出来，帮大家快速解决问题，避免重复踩坑。</p>\n<h2 id=\"01--先明确问题ords-连不上数据库报错到底啥意思\">01 | 先明确问题：ORDS 连不上数据库，报错到底啥意思？</h2>\n<p>当你启动 ORDS 后，访问 APEX 应用或 ORDS 接口时，可能会遇到这样的错误提示：</p>\n<blockquote>\n<p>ORDS was unable to make a connection to the database. The database user specified by db.username configuration setting is expired. The connection pool named: |default|lo| had the following error(s): UCP-29: Failed to get a connection</p>\n</blockquote>\n<p><img alt=\"ords1\" src=\"https://img2024.cnblogs.com/blog/635610/202512/635610-20251226145736856-1853445170.jpg\" /></p>\n<p>简单说，就是 ORDS 配置的数据库用户过期了，导致连接池拿不到连接。这里的关键用户，就是我们今天的主角——ORDS_PUBLIC_USER。</p>\n<p>很多同学之前只关注了 APEX_PUBLIC_USER，却不知道 ORDS 正常运行也依赖专属的 ORDS_PUBLIC_USER，这个用户默认使用数据库的 DEFAULT 密码策略，一旦密码过期，就会触发上述错误。</p>\n<h2 id=\"02--解决步骤从定位问题到彻底解决一步都不能少\">02 | 解决步骤：从定位问题到彻底解决，一步都不能少</h2>\n<p>下面笔者就把完整的解决流程拆解开，每个步骤都讲清楚操作方法和注意事项，小白也能跟着做。</p>\n<h3 id=\"-第一步定位问题用户确认是-ords_public_user-过期\">① 第一步：定位问题用户，确认是 ORDS_PUBLIC_USER 过期</h3>\n<p>首先我们需要通过 ORDS 命令，确认配置的数据库用户到底是谁，避免操作错用户。</p>\n<p>在命令行执行以下命令：</p>\n<pre><code class=\"language-bash\">ords config list\n</code></pre>\n<p>这个命令会列出 ORDS 的所有配置信息，找到<code>db.username</code> 对应的 value 值，不出意外的话，会显示<code>ORDS_PUBLIC_USER</code>，这就确认了是这个用户过期导致的问题。</p>\n<h3 id=\"-第二步给-ords_public_user-配置永不过期策略\">② 第二步：给 ORDS_PUBLIC_USER 配置永不过期策略</h3>\n<p>既然是密码过期问题，核心就是给 ORDS_PUBLIC_USER 设置密码永不过期的策略。这里笔者假设你已经创建好了名为 <code>PASSWORD_UNLIMITED</code> 的永不过期配置文件（如果没有，可先执行 <code>CREATE PROFILE PASSWORD_UNLIMITED LIMIT PASSWORD_LIFE_TIME UNLIMITED PASSWORD_GRACE_TIME UNLIMITED;</code> 创建）。</p>\n<p>以 SYSDBA 身份登录数据库，执行以下 SQL 命令：</p>\n<pre><code class=\"language-sql\">alter user ORDS_PUBLIC_USER profile PASSWORD_UNLIMITED;\n</code></pre>\n<p>这一步的作用是把 ORDS_PUBLIC_USER 关联到永不过期的配置文件，从根源上避免后续再次过期。</p>\n<h3 id=\"-第三步重启-ords-测试发现新问题\">③ 第三步：重启 ORDS 测试，发现新问题</h3>\n<p>配置完永不过期策略后，我们重启 ORDS 看看效果，执行命令：</p>\n<pre><code class=\"language-bash\"># 1. 查找 ORDS 进程并终止\nps -ef | grep ords\n# 找到进程号（第二列数字），执行 kill 命令终止进程\nkill -9 进程号\n\n# 2. 后台启动 ORDS 并将日志输出到 ords.log 文件\nnohup ords serve &gt; ords.log &amp;\n</code></pre>\n<p>此时大概率会发现，错误变了！新错误提示为：</p>\n<blockquote>\n<p>ORA-28001: The account has expired.</p>\n</blockquote>\n<p>这是因为我们虽然修改了密码策略，但已经过期的账号状态不会自动恢复。这时候有同学会尝试用 <code>ALTER USER ORDS_PUBLIC_USER ACCOUNT UNLOCK;</code>命令解锁，但笔者亲测，这个命令对已经过期的账号状态无效，无法将其从 expired 改为 open。</p>\n<h3 id=\"-第四步重置-ords_public_user-密码恢复账号状态\">④ 第四步：重置 ORDS_PUBLIC_USER 密码，恢复账号状态</h3>\n<p>要彻底解除 expired 状态，必须重置 ORDS_PUBLIC_USER 的密码。以 SYSDBA 身份登录数据库，执行以下 SQL 命令：</p>\n<pre><code class=\"language-sql\">ALTER USER ORDS_PUBLIC_USER identified by \"newpassword\";\n</code></pre>\n<p>注意：这里的 <code>newpassword</code> 替换成你自己的密码，建议设置一个复杂度高、不容易忘记的密码，比如 <code>Ords_2025@Pub</code>（包含大小写、数字和特殊字符）。</p>\n<p>执行完这个命令后，ORDS_PUBLIC_USER 的账号状态就会恢复为 open，过期问题就解决了。</p>\n<h3 id=\"-第五步关键坑点用正确命令同步-ords-密码配置\">⑤ 第五步：关键坑点！用正确命令同步 ORDS 密码配置</h3>\n<p>重置完数据库用户密码后，很多同学会直接重启 ORDS，但此时会遇到新的错误：</p>\n<blockquote>\n<p>The connection pool named: |default|lo| had the following error(s): ORA-01017: invalid credential or not authorized; logon denied</p>\n</blockquote>\n<p>这是因为 ORDS 配置里的密码还是旧的，没有同步我们刚重置的新密码。这里要重点提醒大家，不同 ORDS 版本设置密码的命令不一样！</p>\n<p>笔者使用的是 ORDS 25.1 版本，这个版本及以后的新版本，敏感配置（比如密码）必须用 <code>secret</code> 子命令设置，普通的 <code>ords config set db.password</code> 命令会失效。</p>\n<p>正确的操作是在命令行执行：</p>\n<pre><code class=\"language-bash\">ords config secret db.password\n</code></pre>\n<p>执行后会提示你输入密码，直接输入我们刚才重置的 <code>newpassword</code> 即可（交互式输入更安全，避免密码暴露在命令行历史记录中）。</p>\n<p>如果你的 ORDS 版本较低（比如 21 之前），可能需要用 <code>ords config set db.password \"newpassword\"</code>，但建议优先用 <code>secret</code> 命令，更符合安全规范。</p>\n<h3 id=\"-第六步最终测试确认问题解决\">⑥ 第六步：最终测试，确认问题解决</h3>\n<p>完成密码同步后，我们再次重启 ORDS：</p>\n<pre><code class=\"language-bash\"># 1. 查找 ORDS 进程并终止\nps -ef | grep ords\nkill -9 进程号\n\n# 2. 后台启动 ORDS\nnohup ords serve &gt; ords.log &amp;\n</code></pre>\n<p>此时访问 APEX 应用或 ORDS 接口，就不会再出现之前的数据库连接错误了。为了确保万无一失，也可以通过以下方式验证 ORDS 状态：</p>\n<pre><code class=\"language-bash\"># 方式1：查看 ORDS 进程是否存在（确认启动成功）\nps -ef | grep ords\n\n# 方式2：查看 ORDS 日志，确认无报错\ntail -f ords.log\n\n# 方式3：查看 ORDS 配置信息，确认核心配置正确\nords config list\n</code></pre>\n<p>如果通过 ps 命令能看到 ORDS 进程，且日志中无数据库连接相关报错，就说明 ORDS 正常运行，问题彻底解决。</p>\n<h2 id=\"03--避坑指南这些关键要点帮你避免重复踩坑\">03 | 避坑指南：这些关键要点，帮你避免重复踩坑</h2>\n<p>在解决问题的过程中，笔者踩了几个坑，这里总结出来，帮大家少走弯路：</p>\n<h3 id=\"-不要只关注-apex_public_user忽略-ords_public_user\">① 不要只关注 APEX_PUBLIC_USER，忽略 ORDS_PUBLIC_USER</h3>\n<p>APEX_PUBLIC_USER 是 APEX 应用的核心用户，ORDS_PUBLIC_USER 是 ORDS 服务的核心用户，两者缺一不可。建议在安装配置初期，就同时给这两个用户设置永不过期策略，一劳永逸。</p>\n<h3 id=\"-账号过期后仅解锁无效必须重置密码\">② 账号过期后，仅解锁无效，必须重置密码</h3>\n<p>很多同学误以为 <code>ALTER USER ... ACCOUNT UNLOCK</code> 能解决过期问题，但实际上这个命令只能解决账号锁定问题，无法解除过期状态。过期状态必须通过重置密码才能恢复，这一步不能省。</p>\n<h3 id=\"-注意-ords-版本差异密码配置命令要选对\">③ 注意 ORDS 版本差异，密码配置命令要选对</h3>\n<p>ORDS 21 版本及以后，敏感配置必须用<code>ords config secret</code> 命令设置，普通的 <code>set</code> 命令无效；另外要注意，ORDS 没有 <code>status</code> 命令，无法直接查看运行状态，需通过查看进程、日志或配置信息验证。如果设置密码后仍报错，先检查自己的 ORDS 版本和配置是否正确。</p>\n<h3 id=\"-密码要保持一致数据库用户密码--ords-配置密码\">④ 密码要保持一致：数据库用户密码 ≡ ORDS 配置密码</h3>\n<p>重置 ORDS_PUBLIC_USER 的数据库密码后，一定要同步更新 ORDS 配置里的密码，两者必须完全一致（包括大小写、特殊字符），否则会报 ORA-01017 认证失败错误。</p>\n<h2 id=\"04--总结一劳永逸的核心方案\">04 | 总结：一劳永逸的核心方案</h2>\n<p>其实解决这个问题的核心很简单：给 ORDS_PUBLIC_USER 配置永不过期的密码策略，同时确保 ORDS 配置里的密码与数据库用户密码一致。</p>\n<p>完整流程可以简化为：定位用户 → 配置永不过期策略 → 重置密码 → 同步 ORDS 密码配置 → 重启 ORDS。</p>\n<p>建议大家在搭建 APEX + ORDS 环境时，就提前完成这两个用户（APEX_PUBLIC_USER、ORDS_PUBLIC_USER）的永不过期配置，避免后续运行中突然出现问题，影响业务使用。</p>\n<p>如果大家在操作过程中遇到其他问题，欢迎在评论区留言交流，笔者会尽力为大家解答～</p>\n\n</div>\n<div id=\"MySignature\">\n    <a href=\"https://www.cnblogs.com/jyzhao/\" target=\"_blank\">AlfredZhao</a>©版权所有「从Oracle起航，领略精彩的IT技术。」<br />\n转载请注明原文链接：<a href=\"https://www.cnblogs.com/jyzhao/p/19404888/apex-shi-zhan-di8pianords-lian-ku-bao-cuo574-yi-zh\" target=\"_blank\">https://www.cnblogs.com/jyzhao/p/19404888/apex-shi-zhan-di8pianords-lian-ku-bao-cuo574-yi-zh</a>\n<hr />\n<div style=\"text-align: center; margin-top: 30px;\">\n  <p style=\"font-size: 14px; color: #555;\">\n    👋 感谢阅读，欢迎关注我的公众号 <b>「赵靖宇」</b>\n  </p>\n  <img src=\"https://images.cnblogs.com/cnblogs_com/jyzhao/824234/o_250208075013_qrcode-zjy.jpg\" style=\"border: 1px solid #ddd; border-radius: 8px;\" width=\"160\" />\n</div>\n</div>\n<div class=\"clear\"></div>\n\n        <div class=\"clear\"></div>\n        \n</div>\n    <ul class=\"postmetadata\">\n        \n    </ul>"
    },
    {
      "title": "分库分表数据源ShardingSphereDataSource的Connection元数据误用问题分析",
      "link": "https://www.cnblogs.com/wuyuegb2312/p/19405814",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wuyuegb2312/p/19405814\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 22:00\">\n    <span>分库分表数据源ShardingSphereDataSource的Connection元数据误用问题分析</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"背景\">背景</h1>\n<p>对于分库分表应用来说，使用org.apache.shardingsphere.driver.jdbc.core.datasource.ShardingSphereDataSource是一个不错的解决方案，你可以通过配置文件编写分库分表规则，从而在编码时透明地使用分表（当然，路由规则的相关字段还是要传的，之前也有文章分析过这些字段的处理过程：<a href=\"https://www.cnblogs.com/wuyuegb2312/p/18685884\" target=\"_blank\">深入理解Mybatis分库分表执行原理</a>）。</p>\n<p>但是，在一些场景中是需要绕过mybatis直接做一些操作的，特别是和数据库元数据相关的操作（包括表的结构变更）。</p>\n<p>比如我遇到的场景：先查询各个分库中有哪些前缀为<code>table_</code>的表，并给这些表加一列<code>col_x</code>。</p>\n<p>我结合现有代码和大语言模型，先写了一版，线下运行良好，但是线上的某些分库死活找不到对应的分表，没法进行后续的处理。这个问题查了很久，昨天终于解决了，因此分享出来。</p>\n<h1 id=\"存在问题的代码\">存在问题的代码</h1>\n<pre><code class=\"language-Java\">@Componet\npublic class TableAlterHandler {\n    @Resource private ShardingSphereDataSource dataSource;\n    \n    public List&lt;String&gt; findTablesByPrefix(String prefix, String physicalSchemaName) {\n        if (StringUtils.isBlank(prefix) || StringUtils.isBlank(physicalSchemaName)) {\n            throw new RuntimeException(\"分表前缀或分库名为空\");\n        }\n        List&lt;String&gt; tableNames = Lists.newArrayList();\n        try (HintManager hintManager = HintManager.getInstance();\n             Connection conn = dataSource.getConnection()) {\n             hintManager.setDataSourceName(DBUtil.queryLogicalSchemaName(physicalSchemaName));\n            DatabaseMetaData metaData = conn.getMetaData();\n            try (ResultSet rs = metaData.getTables(physicalSchemaName, null, prefix + \"%\", new String[] {\"TABLE\"})) {\n                while (rs.next()) {\n                    String tableName = rs.getString(\"TABLE_NAME\");\n                    tableNames.add(tableName);\n                }\n            }\n        } catch (SQLException e) {\n            throw new RuntimeException(\"处理大结果集失败\", e);\n        }\n        return tableNames;\n    }\n}\n</code></pre>\n<h2 id=\"逻辑库和物理库\">逻辑库和物理库</h2>\n<p>在分析问题之前，首先要明确两个概念：物理库名physicalSchemaName和逻辑库名logicalSchemaName，如果用错了，可能会让你没办法发现后续问题的本质原因。上面的代码，hintManager必须用逻辑库名，而metaData.getTables必须用物理库名。</p>\n<p>所谓物理库和逻辑库，可以看作是我定义的概念。正如其名，物理库名就是你jdbcUrl里的库名，比如一个典型的阿里云Mysql的JDBC链接<code>jdbc:mysql://``rm-bpxxxx.mysql.rds.aliyuncs.com/bizcenter_1?useSSL=false&amp;autoReconnect=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai</code></p>\n<p>其中的bizcenter_1就是物理库名。这个名称也会在MySql元数据中出现，比如</p>\n<pre><code class=\"language-SQL\">select * from information_schema.tables;\n</code></pre>\n<p>可以看到这个库的所有表，而TABLE_SCHEMA列就是物理库名。</p>\n<p>而逻辑库，则是ShardingSphereDataSource对物理库的映射，在application的配置文件(properties或yml)里，spring.shardingsphere.datasource配置下，你需要配置逻辑库名以及对应的JDBC链接。</p>\n<p>你可以将多个逻辑库配置为同一个物理库，这是一种实践方式，可以用于后续的扩容。</p>\n<h1 id=\"问题现象\">问题现象</h1>\n<p>线下的三个逻辑库分别对应一个物理库，而这三个物理库在同一个阿里云RDS实例上，可以找到每个库对应的表。</p>\n<p>而线上的仍然是三个逻辑库对应各自的物理库，每个物理库在不同的阿里云RDS实例上，会出现有时候能找到某个库对应的表，而另外两个库一个表都找不到的情况。</p>\n<h1 id=\"排查\">排查</h1>\n<p>遇到问题后，百思不得其解，因为线下环境一切正常，线上却总能复现问题。由于线上环境管控比较严，既不能远程debug，又不能直连线上库，很难定位原因。</p>\n<p>第一阶段排查，我反复确认了上面代码中需要传数据库名的地方到底是逻辑库还是物理库。中间某个版本的确搞错了，但是为何在写错的前提下还能运行，没有做记录。</p>\n<p>然后，我删掉了<code>connection.setAutoCommit(false)</code>、<code>resultSet.setFetchSize(batchSize)</code>这样的用于降低每次查询元数据结果数量的代码，也没效果。</p>\n<p>最后，我把代码移到了另一个连接同样数据库的应用中，因为那个应用有我之前类似的代码。移过去以后倒是歪打正着地解决了。</p>\n<p>第二阶段的排查，是在一段时间后，我在原先的应用中开发新的功能，对原先代码进行改动，自以为修复好了，但是上线后发现还是和之前一样。</p>\n<h1 id=\"分析\">分析</h1>\n<p>线下线上最大的区别就是线下几个库是同一个MySql实例，而线上分属三个。我的代码里，疑点最大的是查询元数据<code>metaData.getTables()</code>这段。</p>\n<p>好巧不巧，在我排查的第一阶段和第二阶段中间，我写了一个迁移表的功能，完全新写了查询表名的代码，并且为了不再犯物理库和逻辑库搞混的错误，特别地写了对应的工具类：</p>\n<pre><code class=\"language-Java\">/**\n * 数据源持有组件，便于应用直接访问数据源\n *\n */\n@Component\npublic class DataSourceHolder {\n\n  @Resource protected ShardingSphereDataSource dataSource;\n\n  /** 物理库名(jdbc链接里的库名)和数据源的关系 */\n  private Map&lt;String, HikariDataSource&gt; hikariDataSourceMap;\n\n  /** 逻辑库名-物理库名关系 多个逻辑库可能对应同一个物理库 */\n  private Map&lt;String, String&gt; dsNameMap;\n\n  /**\n   * 通过物理库名获取ds\n   *\n   * @param physicalSchemaName\n   * @return\n   */\n  public HikariDataSource getDataSourceByPhysicalSchemaName(String physicalSchemaName) {\n    return hikariDataSourceMap.get(physicalSchemaName);\n  }\n\n  /**\n   * 通过逻辑库名获取对应物理库名\n   *\n   * @param dsName\n   * @return\n   */\n  public String getPhysicalSchemaName(String dsName) {\n    return dsNameMap.get(dsName);\n  }\n\n  /**\n   * 通过逻辑库名获取ds\n   *\n   * @param logicalSchemaName\n   * @return\n   */\n  public HikariDataSource getDataSourceByLogicalSchemaName(String logicalSchemaName) {\n    String physicalSchemaName = getPhysicalSchemaName(logicalSchemaName);\n    if (StringUtils.isBlank(physicalSchemaName)) {\n      throw new RuntimeException(\"逻辑库名找不到对应物理库, logicalSchemaName=\" + logicalSchemaName);\n    }\n    return hikariDataSourceMap.get(physicalSchemaName);\n  }\n\n  @PostConstruct\n  public void initHikariDataSourceMap() {\n    dsNameMap = Maps.newHashMap();\n    hikariDataSourceMap = Maps.newHashMap();\n    Map&lt;String, DataSource&gt; dataSourceMap =\n        dataSource.getContextManager().getDataSourceMap(dataSource.getSchemaName());\n    dataSourceMap.forEach(\n        (dsName, ds) -&gt; {\n          HikariDataSource hds = (HikariDataSource) ds;\n          try (Connection connection = hds.getConnection(); ) {\n            hikariDataSourceMap.put(connection.getCatalog(), hds);\n            dsNameMap.put(dsName, connection.getCatalog());\n          } catch (SQLException e) {\n            throw new RuntimeException(\"组装数据源map失败\", e);\n          }\n        });\n  }\n}\n</code></pre>\n<p>对应地，获取数据库Connection的方法是：</p>\n<pre><code class=\"language-Java\">HikariDataSource hikariDataSource = dataSourceHolder.getDataSourceByPhysicalSchemaName(dsName);\nConnection connection = hikariDataSource.getConnection();\n</code></pre>\n<p>并且也不再使用HintManager指定逻辑库。</p>\n<p>联想到线上线下MySql实例的差异，我猜测是因为：</p>\n<p>线下三个库是同一个MySql实例，那么元数据information_schema.tables是一样的，在哪个库都能查到对应表。</p>\n<p>线上则是不同的实例，直接使用ShardingSphereDataSource对应Connection的元数据，并不总是预期的库。</p>\n<p>这个猜测原因，也在之前第一阶段的排查吻合，能正常工作的代码所在应用，获取数据源的方式实际是</p>\n<pre><code class=\"language-Java\">Map&lt;String, DataSource&gt; allDataSource =\n    shardingSphereDataSource.getContextManager().getDataSourceMap(\"logic_db\");\nConnection connection = allDataSouce.get(logicalSchemaName).getConnection();\n</code></pre>\n<p>虽然它也用了HintManger，但我认为是没有意义的。</p>\n<h1 id=\"修复\">修复</h1>\n<p>综合以上的分析，最终的修复代码如下</p>\n<pre><code class=\"language-Java\">    List&lt;String&gt; tableNames = Lists.newArrayList();\n    try (Connection conn =\n        dataSourceHolder.getDataSourceByPhysicalSchemaName(physicalSchemaName).getConnection()) {\n      DatabaseMetaData metaData = conn.getMetaData();\n      try (ResultSet rs =\n          metaData.getTables(physicalSchemaName, null, prefix + \"%\", new String[] {\"TABLE\"})) {\n        while (rs.next()) {\n          String tableName = rs.getString(\"TABLE_NAME\");\n          tableNames.add(tableName);\n        }\n      }\n    } catch (SQLException e) {\n      throw new RuntimeException(\"处理大结果集失败\", e);\n    }\n    return tableNames;\n</code></pre>\n<p>这次再部署到生产环境，运行符合预期。</p>\n<p>可见，当你需要实际分库对应的元数据时，不要用shardingSphereDataSource，而是应该用它关联具体分库的dataSource，也即shardingSphereDataSource.getContextManager().getDataSourceMap()，再用这个分库dataSource获取元数据。</p>\n<p>否则，线下线上不同的MySql实例配置，会导致不同的现象，难以排查真正的原因。</p>\n\n</div>\n<div id=\"MySignature\">\n    <div id=\"AllanboltSignature\">\n        <p id=\"PSignature\">\n            <br />\n            作者：<a href=\"http://www.cnblogs.com/wuyuegb2312\" target=\"_blank\">五岳</a>\n            <br />\n            出处：<a href=\"http://www.cnblogs.com/wuyuegb2312\" target=\"_blank\">http://www.cnblogs.com/wuyuegb2312</a>\n            <br />\n            对于标题未标注为“转载”的文章均为原创，其版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。\n        </p>\n    　</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 22:00</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wuyuegb2312\">五岳</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "搜索数据库表的性能优化过程",
      "link": "https://www.cnblogs.com/yadelei/p/19406737/the-performance-optimization-process-of-searching-database-tables",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yadelei/p/19406737/the-performance-optimization-process-of-searching-database-tables\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 21:54\">\n    <span>搜索数据库表的性能优化过程</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"问题背景\">问题背景</h2>\n<p>做一个数据库表查看、标注与分析的工具软件。</p>\n<p><span class=\"math inline\">\\(Table\\)</span>是数据库中表的信息（<code>information_schema.tables</code>）；<span class=\"math inline\">\\(Documentation\\)</span>是<span class=\"math inline\">\\(Table\\)</span>的数据字典文档，存储在本地文件中；<span class=\"math inline\">\\(Annotation\\)</span>是对<span class=\"math inline\">\\(Table\\)</span>的额外标注信息，存储在另一个数据库中。每一条<span class=\"math inline\">\\(Table\\)</span>，最多关联到一条<span class=\"math inline\">\\(Documentation\\)</span>和一条<span class=\"math inline\">\\(Annotation\\)</span>。</p>\n<p>现在想搜索<span class=\"math inline\">\\(Table\\)</span>。前端向后端提供3个参数，搜索关键词列表、当前页码、每页条数；后端的搜索逻辑是，如果一条完整数据（<span class=\"math inline\">\\(Table\\)</span>+<span class=\"math inline\">\\(Documentation\\)</span>+<span class=\"math inline\">\\(Annotation\\)</span>）包含所有搜索关键词，则将<span class=\"math inline\">\\(Table\\)</span>加入搜索结果中。</p>\n<p><span class=\"math inline\">\\(Table\\)</span>的数量目前为6000+，要做到秒级搜索。</p>\n<h2 id=\"初步实现\">初步实现</h2>\n<p>因为跨数据源，所以不能简单连表查询。</p>\n<p>对于每个<span class=\"math inline\">\\(Table\\)</span>，查出<span class=\"math inline\">\\(Documentation\\)</span>、<span class=\"math inline\">\\(Annotation\\)</span>，然后将<span class=\"math inline\">\\(Table\\)</span>、<span class=\"math inline\">\\(Documentation\\)</span>、<span class=\"math inline\">\\(Annotation\\)</span>中要搜索的字段值取出来，用空格隔开拼接为字符串，形如<code>\"Table字段值 Documentation字段值 Annotation字段值\"</code>，我们称之为<span class=\"math inline\">\\(SearchKey\\)</span>（搜索键）。如果每个关键词都包含在<span class=\"math inline\">\\(SearchKey\\)</span>中，则将<span class=\"math inline\">\\(Table\\)</span>加入搜索结果。</p>\n<p>搜索时，先获取所有<span class=\"math inline\">\\(Table\\)</span>，然后遍历每个<span class=\"math inline\">\\(Table\\)</span>，获取<span class=\"math inline\">\\(SearchKey\\)</span>并判断是否加入搜索结果。</p>\n<p>为了提高速度，用Redis缓存<span class=\"math inline\">\\(Table\\)</span>对应的<span class=\"math inline\">\\(SearchKey\\)</span>。</p>\n<p>分析数据情况：</p>\n<ul>\n<li><span class=\"math inline\">\\(Table\\)</span>只增、不删、不改，因此，搜索时要重新获取所有<span class=\"math inline\">\\(Table\\)</span>，确保搜索到新<span class=\"math inline\">\\(Table\\)</span>；不必考虑驱逐（evict）<span class=\"math inline\">\\(SearchKey\\)</span>的缓存。</li>\n<li><span class=\"math inline\">\\(Documentation\\)</span>不增、不删、不改，因此，不必考虑驱逐<span class=\"math inline\">\\(SearchKey\\)</span>的缓存。</li>\n<li><span class=\"math inline\">\\(Annotation\\)</span>增、删、改，因此，要在<span class=\"math inline\">\\(Annotation\\)</span>增删改之后驱逐对应<span class=\"math inline\">\\(SearchKey\\)</span>的缓存，确保搜索到<span class=\"math inline\">\\(Annotation\\)</span>的最新信息。</li>\n</ul>\n<p>实测结果：</p>\n<ul>\n<li>实现了功能，支持同时按<span class=\"math inline\">\\(Table\\)</span>、<span class=\"math inline\">\\(Documentation\\)</span>、<span class=\"math inline\">\\(Annotation\\)</span>的字段搜索。</li>\n<li>有性能问题，即使缓存已经全部完成，但每次搜索都要耗时30s左右，原因是6000+个<span class=\"math inline\">\\(Table\\)</span>遍历从Redis获取<span class=\"math inline\">\\(SearchKey\\)</span>，每次耗时1~15ms，累计耗时非常长。</li>\n</ul>\n<h2 id=\"第一次性能优化\">第一次性能优化</h2>\n<p>优化缓存策略。</p>\n<p>获取所有<span class=\"math inline\">\\(Table\\)</span>后，构建<span class=\"math inline\">\\(SearchKeyMap\\)</span>（<span class=\"math inline\">\\(Table\\)</span>→<span class=\"math inline\">\\(SearchKey\\)</span>），然后将<span class=\"math inline\">\\(SearchKeyMap\\)</span>缓存，这样，下一次搜索时，只需要从Redis获取一次，提高传输效率。</p>\n<p>为了确保搜索到新<span class=\"math inline\">\\(Table\\)</span>，缓存<span class=\"math inline\">\\(SearchKeyMap\\)</span>时将<span class=\"math inline\">\\(Table\\)</span>列表的长度作为缓存键，如果新增了<span class=\"math inline\">\\(Table\\)</span>，则<span class=\"math inline\">\\(SearchKeyMap\\)</span>不会命中缓存，而是重新构建。</p>\n<p>为了减少构建<span class=\"math inline\">\\(SearchKeyMap\\)</span>的时间，仍然保留单个<span class=\"math inline\">\\(SearchKey\\)</span>的缓存，仍然在<span class=\"math inline\">\\(Annotation\\)</span>增删改之后驱逐单个<span class=\"math inline\">\\(SearchKey\\)</span>的缓存，但不同的是，还要同时驱逐<span class=\"math inline\">\\(SearchKeyMap\\)</span>的缓存。</p>\n<p>实测结果：</p>\n<ul>\n<li>性能提升明显，在缓存全部完成的情况下，搜索耗时降至1.3s左右。</li>\n<li>仍然有性能问题，对一个<span class=\"math inline\">\\(Annotation\\)</span>做了增删改，会驱逐整个<span class=\"math inline\">\\(SearchKeyMap\\)</span>缓存，重建<span class=\"math inline\">\\(SearchKeyMap\\)</span>就又回到了遍历<span class=\"math inline\">\\(Table\\)</span>的情况，仍然要耗时30s左右。</li>\n</ul>\n<h2 id=\"第二次性能优化\">第二次性能优化</h2>\n<p>优化缓存策略。</p>\n<p>取消单个<span class=\"math inline\">\\(SearchKey\\)</span>的缓存，只缓存<span class=\"math inline\">\\(SearchKeyMap\\)</span>。</p>\n<p>搜索<span class=\"math inline\">\\(Table\\)</span>时，要获取<span class=\"math inline\">\\(SearchKeyMap\\)</span>。先获取现有的<span class=\"math inline\">\\(SearchKeyMap\\)</span>缓存（固定缓存键，不再使用列表长度作为缓存键；没有缓存则取得空Map），然后遍历<span class=\"math inline\">\\(Table\\)</span>，如果<span class=\"math inline\">\\(Table\\)</span>不在<span class=\"math inline\">\\(SearchKeyMap\\)</span>中，则计算<span class=\"math inline\">\\(SearchKey\\)</span>并放入<span class=\"math inline\">\\(SearchKeyMap\\)</span>。这样，第一次搜索时会计算每个<span class=\"math inline\">\\(Table\\)</span>的<span class=\"math inline\">\\(SearchKey\\)</span>，后续搜索就只需要计算新<span class=\"math inline\">\\(Table\\)</span>的<span class=\"math inline\">\\(SearchKey\\)</span>。</p>\n<p><span class=\"math inline\">\\(Annotation\\)</span>增删改后，要更新<span class=\"math inline\">\\(SearchKeyMap\\)</span>。先获取现有的<span class=\"math inline\">\\(SearchKeyMap\\)</span>缓存，然后重新计算指定<span class=\"math inline\">\\(Table\\)</span>的<span class=\"math inline\">\\(SearchKey\\)</span>并放入<span class=\"math inline\">\\(SearchKeyMap\\)</span>。这样，无需每次都重建整个<span class=\"math inline\">\\(SearchKeyMap\\)</span>。</p>\n<p>实测结果：<span class=\"math inline\">\\(Annotation\\)</span>增删改后再搜索，耗时降至1.3s左右。</p>\n<h2 id=\"第三次性能优化\">第三次性能优化</h2>\n<p>优化缓存实现方式。</p>\n<p>既然现在只需要简单地缓存一个<span class=\"math inline\">\\(SearchKeyMap\\)</span>，那么不一定要用Redis。</p>\n<p>使用Redis作为缓存（<code>RedisCacheManager</code>），虽然内网通信快，但仍有网络开销。实测平均1092.9ms。</p>\n<p>使用Map作为缓存（<code>ConcurrentMapCacheManager</code>），其他代码完全不变。实测平均968.3ms。</p>\n<p>修改代码，直接用类中的<code>Map</code>字段作为缓存，省去缓存管理器的开销。实测平均915.2ms。</p>\n<p>可见，性能有提升，但幅度不大。由于软件在开发中，要频繁重新运行，Redis能保持缓存，Map不能，因此保持上一版方案不做修改。</p>\n<h2 id=\"第四次性能优化\">第四次性能优化</h2>\n<p>第三次优化其实是盲目的，应该要用事实找出性能瓶颈。</p>\n<p>对搜索过程计时分析发现，一次耗时1105ms的搜索，其中获取所有<span class=\"math inline\">\\(Table\\)</span>耗时1028ms，占比93%，是绝对的性能瓶颈。</p>\n<p>思路1：先只获取所有表名，而不是<span class=\"math inline\">\\(Table\\)</span>对象，如果表名对应的<span class=\"math inline\">\\(SearchKey\\)</span>匹配，再获取<span class=\"math inline\">\\(Table\\)</span>。实测发现，如果匹配的表名很多（例如关键词列表为空时），则即使有表名→<span class=\"math inline\">\\(Table\\)</span>的缓存（Redis实现），逐个获取也远远慢于直接从数据库一次性获取。因此，此思路<strong>不可行</strong>。</p>\n<p>思路2：<span class=\"math inline\">\\(Table\\)</span>只增、不删、不改，因此可以考虑增量获取。缓存<span class=\"math inline\">\\(Table\\)</span>列表，每次获取时跳过缓存的长度，只获取增量部分。然而，<code>information_schema.tables</code>中没有<code>id</code>，无法保证新<span class=\"math inline\">\\(Table\\)</span>一定排在最后。因此，此思路<strong>不可行</strong>。</p>\n<p>思路3：获取所有<span class=\"math inline\">\\(Table\\)</span>说到底只是为了搜索到新<span class=\"math inline\">\\(Table\\)</span>，如果能知道什么时候新增了<span class=\"math inline\">\\(Table\\)</span>，就可以放心地使用<span class=\"math inline\">\\(Table\\)</span>列表的缓存，或者从数据库重新获取。那么怎么知道？由于<span class=\"math inline\">\\(Table\\)</span>只增，所以可以用<span class=\"math inline\">\\(Table\\)</span>的数量判断。缓存<span class=\"math inline\">\\(Table\\)</span>列表，每次先从数据库查出数量（比直接查出<span class=\"math inline\">\\(Table\\)</span>列表明显更快），如果数量与缓存一致，则用缓存，否则查库。实测，此思路<strong>可行</strong>。</p>\n<p>实现思路3后，再次计时分析。无新增<span class=\"math inline\">\\(Table\\)</span>时，搜索耗时降至360ms左右（只查库数量）；有新增时，耗时升至1.5s左右（查库数量+列表）。由于搜索<span class=\"math inline\">\\(Table\\)</span>的频率远远高于新增<span class=\"math inline\">\\(Table\\)</span>，因此，总体性能提升显著。</p>\n<h2 id=\"总结\">总结</h2>\n<p>经过数次性能优化，在满足功能的前提下，搜索时间从30s左右降至稳定0.4s左右，效果显著。0.4s已经没有缓慢感，性能优化工作可以结束了。</p>\n<p>从上述优化过程可见，做优化要因地制宜，具体问题具体分析，选择合适的策略；优化效果的衡量要以实测结果为准。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 21:54</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yadelei\">亚德雷</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "使用Gradio构建AI前端 - RAG召回测试",
      "link": "https://www.cnblogs.com/aspnetx/p/19406675",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aspnetx/p/19406675\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 21:27\">\n    <span>使用Gradio构建AI前端 - RAG召回测试</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        构建AI应用的前端方案有很多，这里介绍一个开源前端库---Gradio，通过它可以使用简短的代码就可以快速的实现简单的AI应用前端。这里我们选择的场景为做RAG召回测试，通过调用先前封装好的LangChain代码，来快速的搭建这个前端页面。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"使用gradio构建ai前端---rag召回测试\">使用Gradio构建AI前端 - RAG召回测试</h1>\n<h2 id=\"一摘要\">一、摘要</h2>\n<p>构建AI应用的前端方案有很多，这里介绍一个开源前端库---Gradio，通过它可以使用简短的代码就可以快速的实现简单的AI应用前端。这里我们选择的场景为做RAG召回测试，通过调用先前封装好的LangChain代码，来快速的搭建这个前端页面。</p>\n<h2 id=\"二ai项目前端方案的对比\">二、AI项目前端方案的对比</h2>\n<p>可以做AI的前端方案很多，这里主要介绍比较热门的三个方案：</p>\n<ul>\n<li>Gradio 是一款开源的 Python 库，核心定位是快速构建机器学习 / 深度学习模型的交互式 Web 演示界面，无需前端开发经验，一行代码即可将模型（或任意 Python 函数）转化为可通过浏览器访问的交互页面，方便开发者、研究者快速展示、测试和分享模型。</li>\n<li>Streamlit 是一款开源的 Python 库，主打快速构建数据科学 / 机器学习领域的交互式 Web 应用，无需前端开发经验，以 “脚本即应用” 为核心理念 —— 普通的 Python 脚本只需添加少量 Streamlit 语法，就能一键转化为可交互的 Web 应用，是数据分析师、算法工程师快速落地可视化 / 分析工具的首选。</li>\n<li>Vue（读音 /vjuː/，类似 view）是一款渐进式 JavaScript 框架，核心聚焦于前端视图层（UI）开发，由尤雨溪开发并开源，是目前最主流的前端框架之一（与 React、Angular 并称）。<br />\n相对三种方案，Gradio是直接被设计成AI的前端的，Streamlit适合做数据科学的前端。而Vue是一个更专业的前端框架。<br />\n这里我们介绍的就是Gradio。所以我们使用Gradio构建了一个RAG（检索增强生成）召回测试系统界面，主要功能是通过调用<code>LC_RAG_02_RecallTest.py</code>中的<code>recall</code>函数实现相似度检索，用户可以输入查询文本并设置返回结果数量，系统会展示检索到的最相似文档。</li>\n</ul>\n<h2 id=\"三环境介绍\">三、环境介绍</h2>\n<p>这里基于我另外一篇笔记：<br />\n<a href=\"https://www.cnblogs.com/aspnetx/p/19173914\" target=\"_blank\">https://www.cnblogs.com/aspnetx/p/19173914</a><br />\n在这个笔记中，介绍了如何使用python构建RAG系统，使用的是LangChain1.0的库。<br />\n整个项目可以在以下仓库中找到：<br />\n<a href=\"https://github.com/microsoftbi/Langchain_DEMO/tree/main/RAG\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/microsoftbi/Langchain_DEMO/tree/main/RAG</a><br />\n我会用到在其中的一个文件中封装好的做RAG召回测试的代码，来构建前端应用，借此展示Gradio环境中如何快速的搭建前端页面。<br />\n本文创建的代码文件名为：LC_RAG_07b_Gradio.py<br />\n调用先前召回测试的代码文件为：LC_RAG_02_RecallTest.py</p>\n<h2 id=\"四主要功能模块\">四、主要功能模块</h2>\n<h3 id=\"1-召回测试函数-run_recall_test\">1. 召回测试函数 <code>run_recall_test</code></h3>\n<ul>\n<li>功能：调用LC_RAG_02_RecallTest.py文件中封装好的<code>recall</code>函数执行检索并捕获输出结果。</li>\n</ul>\n<pre><code class=\"language-Python\">def run_recall_test(query, top_k):\n    \"\"\"运行召回测试并返回结果\"\"\"\n    try:\n        # 调用recall函数，但需要捕获其输出\n        import io\n        from contextlib import redirect_stdout\n        \n        # 创建一个字符串IO对象来捕获输出\n        f = io.StringIO()\n        with redirect_stdout(f):\n            recall(\n                query=query,\n                top_k=top_k,\n                vectorstore_dir=\"./RAG/chroma_db\",\n                embedding_model=\"text-embedding-v4\"\n            )\n        \n        # 获取捕获的输出\n        output = f.getvalue()\n        return output\n    except Exception as e:\n        return f\"错误: {str(e)}\"\n</code></pre>\n<ul>\n<li>实现要点：\n<ul>\n<li>使用<code>io.StringIO()</code>创建字符串缓冲区</li>\n<li>通过<code>redirect_stdout</code>上下文管理器捕获<code>recall</code>函数的打印输出</li>\n<li>调用<code>recall</code>函数时指定参数：查询文本、返回数量、向量存储目录和嵌入模型<br />\n因为在先前封装好的代码中并没有返回值，而是直接通过print来输出结果，所以这里需要调用相关的包来读取这些输出。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-gradio界面构建\">2. Gradio界面构建</h3>\n<p>首先需要确保Gradio的库已经被安装：</p>\n<pre><code>pip install gradio \n</code></pre>\n<p>然后在代码中引入这个库。</p>\n<pre><code>import gradio as gr \n</code></pre>\n<p>随后使用<code>gr.Blocks</code>创建结构化界面，在其下再通过gr.Row()以及gr.Column()，就可以往这个框架下分割出来不同的行和列来堆放需要的组件。<br />\n顺便说一下，Gradid有两种方式的布局，一个是interface, 通过绑定的函数自动生成界面，另一个就是Block，通过行列的方式自己组织界面。这里用到的就是Blocks方式。</p>\n<p>以下是几种常用的设置前端界面的方法：</p>\n<h4 id=\"1页面标题与说明\">（1）页面标题与说明</h4>\n<p>直接做markdown格式的输出：</p>\n<pre><code class=\"language-python\">gr.Markdown(\"# RAG召回测试系统\")\ngr.Markdown(\"使用Gradio构建的RAG召回测试界面，调用LC_RAG_02_RecallTest.py实现相似度检索\")\n</code></pre>\n<h4 id=\"2输入区域左侧\">（2）输入区域（左侧）</h4>\n<p>也就是在gr.Row()的第一个gr.Column()</p>\n<pre><code class=\"language-Python\">        with gr.Column(scale=1):\n            gr.Markdown(\"## 查询设置\")\n            \n            # 查询文本输入\n            query_input = gr.Textbox(\n                label=\"查询文本\",\n                placeholder=\"请输入您要检索的问题或关键词\",\n                lines=3,\n                info=\"例如: '什么是未成年?' 或 '哪些节假日应该安排休假?'\"\n            )\n            \n            # Top-K设置\n            top_k_slider = gr.Slider(\n                label=\"Top-K检索数量\",\n                minimum=1,\n                maximum=10,\n                value=5,\n                step=1,\n                info=\"设置返回的最相似文档数量\"\n            )\n            \n            # 提交按钮\n            submit_btn = gr.Button(\n                \"执行召回测试\",\n                variant=\"primary\",\n                size=\"lg\"\n            )\n            \n            # 重置按钮\n            clear_btn = gr.Button(\"重置\", variant=\"secondary\")\n</code></pre>\n<p>这段代码包括创建以下界面：</p>\n<ul>\n<li>查询文本输入框：<code>gr.Textbox</code>，支持多行输入</li>\n<li>Top-K设置滑块：<code>gr.Slider</code>，范围1-10，默认值5</li>\n<li>操作按钮：\"执行召回测试\"（主按钮）和\"重置\"（次要按钮）</li>\n</ul>\n<p>可以看到通过gr.对应的方法，就可以创建不同的组件。</p>\n<h4 id=\"3输出区域右侧\">（3）输出区域（右侧）</h4>\n<p>gr.Row()的第二个gr.Column()</p>\n<pre><code class=\"language-Python\">        # 右侧：输出区域\n        with gr.Column(scale=2):\n            gr.Markdown(\"## 召回结果\")\n            \n            # 结果输出\n            result_output = gr.Textbox(\n                label=\"相似度检索结果\",\n                lines=20,\n                interactive=False,\n                placeholder=\"召回结果将显示在这里...\"\n            )\n            \n            # 状态信息\n            status_info = gr.Markdown(\"状态: 就绪\")\n</code></pre>\n<ul>\n<li>结果输出框：<code>gr.Textbox</code>，展示检索结果</li>\n<li>状态信息：<code>gr.Markdown</code>，显示系统当前状态</li>\n</ul>\n<h3 id=\"3-按钮事件\">3. 按钮事件</h3>\n<p>这里主要是调用前面定义的方法：run_recall_test<br />\n然后下面封装了一个响应按钮的方法：</p>\n<pre><code class=\"language-Python\"># 按钮事件\ndef on_submit(query, top_k):\n    if not query:\n        return \"请输入查询文本\", \"状态: 错误 - 查询文本不能为空\"\n        \n    status_info.value = \"状态: 正在执行召回测试...\"\n    result = run_recall_test(query, top_k)\n    return result, \"状态: 测试完成\"\n</code></pre>\n<p>最后挂载按钮的click方法：</p>\n<pre><code># 绑定事件\nsubmit_btn.click(\n    fn=lambda query, top_k: on_submit(query, top_k),\n    inputs=[query_input, top_k_slider],\n    outputs=[result_output, status_info]\n</code></pre>\n<p>需要留意的是这里的事件响应的方法跟其它编程语言的会有些不同。</p>\n<h3 id=\"5-应用启动\">5. 应用启动</h3>\n<pre><code class=\"language-python\">demo.launch(\n    server_name=\"0.0.0.0\",  # 允许外部访问\n    server_port=7860,       # 端口号\n    share=False,            # 不生成公共链接\n    debug=False             # 非调试模式\n)\n</code></pre>\n<p>指定端口号和其它信息，直接运行这个代码就可以在浏览器里访问了。<br />\n以下是代码所构建的界面。</p>\n<p><img alt=\"img\" src=\"https://img2024.cnblogs.com/blog/8622/202512/8622-20251226211747483-484824576.png\" /></p>\n<p>可以看到相比用Vue来封装，代码量就少了很多，尤其是不需要创建，构建项目，以及为前端去专门写API。<br />\n所以对于快速的开发来说，Gradio是非常合适的。但是对于企业级的专业开发，还是建议选择Vue。<br />\n还有一种建议就是，通过Gradio来做快速的原型开发，然后用Vue来做生产开发。</p>\n<details>\n以下是代码的全部内容，点击展开。\n<pre><code class=\"language-Python\">import os\nimport gradio as gr\nfrom dotenv import load_dotenv\nfrom LC_RAG_02_RecallTest import recall\n\n# 加载环境变量\nload_dotenv()\n\ndef run_recall_test(query, top_k):\n    \"\"\"运行召回测试并返回结果\"\"\"\n    try:\n        # 调用recall函数，但需要捕获其输出\n        import io\n        from contextlib import redirect_stdout\n        \n        # 创建一个字符串IO对象来捕获输出\n        f = io.StringIO()\n        with redirect_stdout(f):\n            recall(\n                query=query,\n                top_k=top_k,\n                vectorstore_dir=\"./RAG/chroma_db\",\n                embedding_model=\"text-embedding-v4\"\n            )\n        \n        # 获取捕获的输出\n        output = f.getvalue()\n        return output\n    except Exception as e:\n        return f\"错误: {str(e)}\"\n\n# 创建界面\nwith gr.Blocks(title=\"RAG召回测试系统\", theme=gr.themes.Soft()) as demo:\n    # 页面标题\n    gr.Markdown(\"# RAG召回测试系统\")\n    gr.Markdown(\"使用Gradio构建的RAG召回测试界面，调用LC_RAG_02_RecallTest.py实现相似度检索\")\n    \n    with gr.Row():\n        # 左侧：输入区域\n        with gr.Column(scale=1):\n            gr.Markdown(\"## 查询设置\")\n            \n            # 查询文本输入\n            query_input = gr.Textbox(\n                label=\"查询文本\",\n                placeholder=\"请输入您要检索的问题或关键词\",\n                lines=3,\n                info=\"例如: '什么是未成年?' 或 '哪些节假日应该安排休假?'\"\n            )\n            \n            # Top-K设置\n            top_k_slider = gr.Slider(\n                label=\"Top-K检索数量\",\n                minimum=1,\n                maximum=10,\n                value=5,\n                step=1,\n                info=\"设置返回的最相似文档数量\"\n            )\n            \n            # 提交按钮\n            submit_btn = gr.Button(\n                \"执行召回测试\",\n                variant=\"primary\",\n                size=\"lg\"\n            )\n            \n            # 重置按钮\n            clear_btn = gr.Button(\"重置\", variant=\"secondary\")\n        \n        # 右侧：输出区域\n        with gr.Column(scale=2):\n            gr.Markdown(\"## 召回结果\")\n            \n            # 结果输出\n            result_output = gr.Textbox(\n                label=\"相似度检索结果\",\n                lines=20,\n                interactive=False,\n                placeholder=\"召回结果将显示在这里...\"\n            )\n            \n            # 状态信息\n            status_info = gr.Markdown(\"状态: 就绪\")\n    \n    # 按钮事件\n    def on_submit(query, top_k):\n        if not query:\n            return \"请输入查询文本\", \"状态: 错误 - 查询文本不能为空\"\n        \n        status_info.value = \"状态: 正在执行召回测试...\"\n        result = run_recall_test(query, top_k)\n        return result, \"状态: 测试完成\"\n    \n    def on_clear():\n        return \"\", 5, \"\", \"状态: 已重置\"\n    \n    # 绑定事件\n    submit_btn.click(\n        fn=lambda query, top_k: on_submit(query, top_k),\n        inputs=[query_input, top_k_slider],\n        outputs=[result_output, status_info]\n    )\n    \n    clear_btn.click(\n        fn=on_clear,\n        inputs=[],\n        outputs=[query_input, top_k_slider, result_output, status_info]\n    )\n    \n    # 示例查询\n    gr.Markdown(\"## 示例查询\")\n    with gr.Row():\n        example1 = gr.Button(\"什么是未成年?\")\n        example2 = gr.Button(\"哪些节假日应该安排休假?\")\n        example3 = gr.Button(\"足球比赛的基本规则是什么?\")\n    \n    def set_example(example_text):\n        return example_text, 5, \"\", \"状态: 就绪\"\n    \n    example1.click(fn=lambda: set_example(\"什么是未成年?\"), inputs=[], outputs=[query_input, top_k_slider, result_output, status_info])\n    example2.click(fn=lambda: set_example(\"哪些节假日应该安排休假?\"), inputs=[], outputs=[query_input, top_k_slider, result_output, status_info])\n    example3.click(fn=lambda: set_example(\"足球比赛的基本规则是什么?\"), inputs=[], outputs=[query_input, top_k_slider, result_output, status_info])\n\n# 启动应用\nif __name__ == \"__main__\":\n    demo.launch(\n        server_name=\"0.0.0.0\",\n        server_port=7860,\n        share=False,\n        debug=False\n    )\n</code></pre>\n</details>\n</div>\n<div id=\"MySignature\">\n    <p>&nbsp;</p>\n<p>---------------------------------------------------------------</p>\n<p style=\"margin: 0in 0in 10pt;\">aspnetx<span style=\"font-family: SimSun;\">的</span>BI<span style=\"font-family: SimSun;\">笔记系列索引：</span></p>\n<p style=\"margin: 0in 0in 10pt;\"><a href=\"http://www.cnblogs.com/aspnetx/archive/2013/02/25/2931603.html\" target=\"_blank\">使用SQL Server Analysis Services数据挖掘的关联规则实现商品推荐功能</a></p> \n<p style=\"margin: 0in 0in 10pt;\"><a href=\"http://www.cnblogs.com/aspnetx/archive/2013/03/24/2978347.html\" target=\"_blank\">一起玩转SQL Server 2012 下的分析服务</a></p> \n<p style=\"margin: 0in 0in 10pt;\"><a href=\"http://www.cnblogs.com/aspnetx/archive/2013/04/05/3000448.html\" target=\"_blank\">使用SQL Server分析服务定位目标用户  </a></p> \n\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>---------------------------------------------------------------<br /></p>\n<p>来自<a href=\"http://www.cnblogs.com/\" target=\"_blank\">博客园</a>的<a href=\"http://aspnetx.cnblogs.com/\" target=\"_blank\">aspnetx</a><font color=\"white\">宋卫东</font></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 21:27</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aspnetx\">哥本哈士奇(aspnetx)</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}