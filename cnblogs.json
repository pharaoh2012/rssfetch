{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "【面试题】MySQL 中 count(*)、count(1) 和 count(字段名) 有什么区别？",
      "link": "https://www.cnblogs.com/sun-10387834/p/19452600",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sun-10387834/p/19452600\" id=\"cb_post_title_url\" title=\"发布于 2026-02-02 16:25\">\n    <span>【面试题】MySQL 中 count(*)、count(1) 和 count(字段名) 有什么区别？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"mysql-中的-count-三兄弟效率大比拼\">MySQL 中的 count 三兄弟：效率大比拼！🚀</h1>\n<h2 id=\"一快速结论先看结论再看分析\">一、快速结论（先看结论再看分析）</h2>\n<table>\n<thead>\n<tr>\n<th>方式</th>\n<th>作用</th>\n<th>效率</th>\n<th>一句话总结</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>count(*)</code></td>\n<td><strong>统计所有行数</strong></td>\n<td>⭐⭐⭐⭐ <strong>最高</strong></td>\n<td>我是专业的！我为统计而生</td>\n</tr>\n<tr>\n<td><code>count(1)</code></td>\n<td>统计所有行数</td>\n<td>⭐⭐⭐⭐ 同样高效</td>\n<td>我是 count(*) 的马甲兄弟</td>\n</tr>\n<tr>\n<td><code>count(列名)</code></td>\n<td>统计该列<strong>非 NULL</strong> 的行数</td>\n<td>⭐⭐⭐ 较慢</td>\n<td>我挑剔，我只数非空值</td>\n</tr>\n</tbody>\n</table>\n<p><strong>结论：用 <code>count(*)</code> 就对了！</strong> ✅</p>\n<h2 id=\"二代码示例亲测三兄弟的差别\">二、代码示例：亲测三兄弟的差别</h2>\n<h3 id=\"准备测试数据\">准备测试数据</h3>\n<pre><code class=\"language-sql\">-- 创建测试表\nCREATE TABLE user_test (\n    id INT PRIMARY KEY AUTO_INCREMENT,\n    name VARCHAR(50),\n    age INT,\n    email VARCHAR(100)\n);\n\n-- 插入测试数据（故意插入一些NULL值）\nINSERT INTO user_test (name, age, email) VALUES\n('张三', 25, 'zhangsan@example.com'),\n('李四', NULL, NULL),\n('王五', 30, 'wangwu@example.com'),\n(NULL, 28, 'unknown@example.com'),\n('赵六', 35, NULL);\n</code></pre>\n<h3 id=\"测试查询\">测试查询</h3>\n<pre><code class=\"language-sql\">-- 查看表中的数据\nSELECT * FROM user_test;\n/*\n+----+--------+------+--------------------+\n| id | name   | age  | email              |\n+----+--------+------+--------------------+\n|  1 | 张三   |   25 | zhangsan@example...|\n|  2 | 李四   | NULL | NULL               |\n|  3 | 王五   |   30 | wangwu@example.com |\n|  4 | NULL   |   28 | unknown@example.com|\n|  5 | 赵六   |   35 | NULL               |\n+----+--------+------+--------------------+\n*/\n\n-- 测试1：count(*) 统计所有行数\nSELECT count(*) FROM user_test;  -- 结果：5 ✅\n-- 翻译：\"老板，我有多少行数据？全都要！\"\n\n-- 测试2：count(1) 统计所有行数  \nSELECT count(1) FROM user_test;  -- 结果：5 ✅\n-- 翻译：\"老板，你给我个固定值1，我数有多少个1\"\n\n-- 测试3：count(列名) 统计非NULL的行数\nSELECT count(name) FROM user_test;  -- 结果：4 ❗（NULL的那行没算）\nSELECT count(age) FROM user_test;   -- 结果：4 ❗（NULL的那行没算）\nSELECT count(email) FROM user_test; -- 结果：3 ❗（两个NULL都没算）\n-- 翻译：\"我只数有身份证的人，黑户不算\"\n</code></pre>\n<h2 id=\"三深入剖析它们到底有啥不同\">三、深入剖析：它们到底有啥不同？</h2>\n<h3 id=\"1-语义区别最重要的区别\">1. <strong>语义区别（最重要的区别！）</strong></h3>\n<pre><code class=\"language-sql\">-- count(*) 是 SQL 标准写法\n-- 意思：给我这个表有多少行数据\n-- 相当于：\"这个会议室有多少个座位？\"\n\n-- count(1) 是 count(*) 的一种写法\n-- 意思：统计有多少个1\n-- 相当于：\"给每个座位发个苹果，最后数苹果\"\n\n-- count(列名) 是统计该列非NULL值的数量\n-- 意思：这个会议室有多少人带了手机\n-- 相当于：\"检查每个座位，如果有人带了手机就计数\"\n</code></pre>\n<h3 id=\"2-性能区别神话与现实\">2. <strong>性能区别（神话与现实）</strong></h3>\n<h4 id=\"传说中的误解\">传说中的误解：</h4>\n<blockquote>\n<p>\"count(1) 比 count(*) 快\" ❌<br />\n\"count(主键) 最快\" ❌</p>\n</blockquote>\n<h4 id=\"现实真相\">现实真相：</h4>\n<p><strong>MySQL 5.7 及以后版本</strong>：</p>\n<ul>\n<li><code>count(*)</code> 和 <code>count(1)</code> 性能<strong>完全相同</strong></li>\n<li>MySQL 优化器会把它们当作一回事</li>\n</ul>\n<p><strong>查看执行计划证明</strong>：</p>\n<pre><code class=\"language-sql\">EXPLAIN SELECT count(*) FROM user_test;\nEXPLAIN SELECT count(1) FROM user_test;\nEXPLAIN SELECT count(id) FROM user_test;\n-- 你会看到：前两个的执行计划完全一样！\n</code></pre>\n<p><strong>性能排序</strong>（一般情况）：</p>\n<ol>\n<li><code>count(*)</code> ≈ <code>count(1)</code> ⭐⭐⭐⭐⭐</li>\n<li><code>count(主键列)</code> ⭐⭐⭐⭐</li>\n<li><code>count(非主键有索引列)</code> ⭐⭐⭐</li>\n<li><code>count(非主键无索引列)</code> ⭐⭐</li>\n</ol>\n<p><strong>为什么 <code>count(列名)</code> 可能更慢？</strong></p>\n<pre><code class=\"language-sql\">-- 假设 email 列有索引\nSELECT count(email) FROM user_test;\n/*\nMySQL 需要：\n1. 读取索引（如果该列有索引）\n2. 检查每个值是否为 NULL\n3. 只计数非 NULL 的\n\n如果 email 列没有索引：\n1. 读取整行数据（比 count(*) 读的更多）\n2. 检查 email 是否为 NULL\n3. 只计数非 NULL 的\n*/\n</code></pre>\n<h3 id=\"3-特殊情况分析\">3. <strong>特殊情况分析</strong></h3>\n<pre><code class=\"language-sql\">-- 情况1：所有列都不允许NULL\nCREATE TABLE user_not_null (\n    id INT PRIMARY KEY NOT NULL,\n    name VARCHAR(50) NOT NULL\n);\n-- 这时候：count(*) = count(id) = count(name)\n\n-- 情况2：空表 vs NULL值\nCREATE TABLE empty_table (id INT);\nSELECT count(*) FROM empty_table;    -- 结果：0\nSELECT count(id) FROM empty_table;   -- 结果：0\n\nINSERT INTO empty_table VALUES (NULL);\nSELECT count(*) FROM empty_table;    -- 结果：1\nSELECT count(id) FROM empty_table;   -- 结果：0 ❗\n</code></pre>\n<h2 id=\"四实际工作中的选择指南\">四、实际工作中的选择指南</h2>\n<h3 id=\"-场景1统计总行数\">🎯 <strong>场景1：统计总行数</strong></h3>\n<pre><code class=\"language-sql\">-- ✅ 正确做法\nSELECT count(*) FROM orders;\n\n-- ❌ 错误做法\nSELECT count(order_id) FROM orders;  -- 万一有NULL呢？\nSELECT count(1) FROM orders;         -- 能用，但不是标准\n</code></pre>\n<h3 id=\"-场景2统计有效数据数量\">🎯 <strong>场景2：统计有效数据数量</strong></h3>\n<pre><code class=\"language-sql\">-- 统计有多少用户填写了邮箱\nSELECT count(email) FROM users;  -- ✅ 这个场景就该用 count(列名)\n\n-- 统计已完成订单数量（假设 status=2 是已完成）\nSELECT count(*) FROM orders WHERE status = 2;  -- ✅\n</code></pre>\n<h3 id=\"-场景3统计非重复值\">🎯 <strong>场景3：统计非重复值</strong></h3>\n<pre><code class=\"language-sql\">-- 统计有多少个不同的城市\nSELECT count(DISTINCT city) FROM users;  -- ✅ count + DISTINCT\n\n-- 统计有多少个城市，排除 NULL\nSELECT count(DISTINCT city) FROM users;  -- DISTINCT 会自动排除 NULL\n</code></pre>\n<h2 id=\"五性能优化技巧\">五、性能优化技巧</h2>\n<h3 id=\"1-大表优化方案\">1. <strong>大表优化方案</strong></h3>\n<pre><code class=\"language-sql\">-- 方案1：使用近似值（适用于统计概览）\nSELECT TABLE_ROWS \nFROM information_schema.TABLES \nWHERE TABLE_SCHEMA = 'your_db' AND TABLE_NAME = 'big_table';\n\n-- 方案2：分页总数缓存（适用于列表页）\n-- 第一次查询时缓存总数，后面定时更新\n\n-- 方案3：使用汇总表\nCREATE TABLE stats_daily (\n    date DATE PRIMARY KEY,\n    user_count INT,\n    order_count INT\n);\n</code></pre>\n<h3 id=\"2-索引优化\">2. <strong>索引优化</strong></h3>\n<pre><code class=\"language-sql\">-- 为 count(列名) 创建索引\nCREATE INDEX idx_email ON users(email);\n\n-- 但注意：count(*) 不一定需要索引，InnoDB有优化\n</code></pre>\n<h2 id=\"六有趣比喻帮你记忆\">六、有趣比喻帮你记忆</h2>\n<h3 id=\"-汉堡店排队比喻\">🍔 <strong>汉堡店排队比喻</strong></h3>\n<pre><code class=\"language-sql\">-- 有10个人在排队买汉堡\n\ncount(*) = \"队列里有10个人\" ✅\ncount(1) = \"我给每人发个号码牌，数有10个牌\" ✅  \ncount(现金) = \"只有8个人带了现金\" ❗\ncount(会员卡) = \"只有5个人有会员卡\" ❗\n</code></pre>\n<h3 id=\"-教室点名比喻\">🏫 <strong>教室点名比喻</strong></h3>\n<pre><code class=\"language-sql\">-- 教室里有50个座位\n\ncount(*) = \"教室有50个座位\" ✅\ncount(1) = \"我在每个座位放本书，最后数有50本\" ✅\ncount(学生) = \"今天来了45个学生上课\" ❗（空座位不算）\n</code></pre>\n<h2 id=\"七总结与最佳实践\">七、总结与最佳实践</h2>\n<h3 id=\"-最终建议\">📋 <strong>最终建议</strong></h3>\n<ol>\n<li>\n<p><strong>统计总行数，一律用 <code>count(*)</code></strong></p>\n<ul>\n<li>这是 SQL 标准写法</li>\n<li>性能最优（MySQL有专门优化）</li>\n<li>语义最明确</li>\n</ul>\n</li>\n<li>\n<p><strong>统计某列非 NULL 数量，用 <code>count(列名)</code></strong></p>\n<ul>\n<li>这是它的本职工作</li>\n<li>不要用它统计总行数</li>\n</ul>\n</li>\n<li>\n<p><strong>关于 <code>count(1)</code></strong></p>\n<ul>\n<li>性能与 <code>count(*)</code> 一样</li>\n<li>但不够\"标准\"，像方言</li>\n<li>建议统一用 <code>count(*)</code></li>\n</ul>\n</li>\n<li>\n<p><strong>性能关键点</strong></p>\n<ul>\n<li>大表避免频繁 count</li>\n<li>考虑使用缓存或汇总表</li>\n<li>为 count(列名) 的列加索引</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"-一张图看懂\">📊 <strong>一张图看懂</strong></h3>\n<pre><code>count(*)       -&gt; 总数 -&gt; 最快 -&gt; 推荐使用\n    ↓\ncount(1)       -&gt; 总数 -&gt; 一样快 -&gt; 可用但不标准\n    ↓\ncount(主键)    -&gt; 总数 -&gt; 次快 -&gt; 主键非NULL时可用\n    ↓\ncount(索引列)  -&gt; 非NULL数 -&gt; 较慢 -&gt; 有索引时可用\n    ↓  \ncount(普通列)  -&gt; 非NULL数 -&gt; 最慢 -&gt; 谨慎使用\n</code></pre>\n<p>记住口诀：<strong>\"数总数，用星号；数非空，列名好；数字1，虽高效，不是标准别当宝\"</strong> 🎯</p>\n\n\n</div>\n<div id=\"MySignature\">\n    \n<p>❤️ 如果你喜欢这篇文章，请点赞支持！ 👍 同时欢迎关注我的博客，获取更多精彩内容！</p>\n\n<p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/sun-10387834/\" target=\"_blank\">佛祖让我来巡山</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/sun-10387834/p/19452600\" target=\"_blank\">https://www.cnblogs.com/sun-10387834/p/19452600</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-02 16:25</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sun-10387834\">佛祖让我来巡山</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MWGA让千亿行代码在Web端“复活”！",
      "link": "https://www.cnblogs.com/xdesigner/p/19565029",
      "published": "",
      "description": "<h2>\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xdesigner/p/19565029\" id=\"cb_post_title_url\" title=\"发布于 2026-02-02 16:09\">\n    <span>MWGA让千亿行代码在Web端“复活”！</span>\n    \n\n</a>\n\n\t\t</h2>\n\t\t<div class=\"postText\">    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        南京都昌信息研发的 MWGA——一款能够帮助企业和开发者将使用GDI+绘图的复杂的传统Winforms程序快速、低成本迁移到Blazor WASM平台的迁移工具！它打破了Winforms程序难以跨平台、适配性差的困境，仅需极低修改量（通常不超过10%）就能将传统Winforms程序无缝转为可网页加载的Blazor WASM版本。\n这意味着，企业无需重写业务逻辑，无需学习全新前端框架，更无需招募额外的前端开发人员——一套代码，同时编译为.exe与.wasm，双端运行，体验一致！为企业节省大量开发成本与时间，尤其适配医疗等对信创有迫切需求的行业！\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><span>特大喜讯！南京都昌信息研发的&nbsp;MWGA——一款能够帮助企业和开发者将使用GDI+绘图的复杂的传统Winforms程序快速、低成本迁移到Blazor WASM平台的迁移工具！它打破了Winforms程序难以跨平台、适配性差的困境，仅需极低修改量（通常不超过10%）就能将传统Winforms程序无缝转为可网页加载的Blazor WASM版本。</span></p>\n<p><span>这意味着，企业无需重写业务逻辑，无需学习全新前端框架，更无需招募额外的前端开发人员——一套代码，同时编译为.exe与.wasm，双端运行，体验一致！为企业节省大量开发成本与时间，尤其适配医疗等对信创有迫切需求的行业！</span></p>\n<h1><strong class=\"135brush\"><strong>一、</strong></strong><strong class=\"135brush\"><strong>极低修改，极高还原</strong></strong></h1>\n<p><span>通过MWGA，原本只能在Windows桌面运行的Winforms程序，无需重写，即可转变为通过浏览器访问的WebAssembly应用。以下为三个案例展示：</span></p>\n<span><strong>案例一：经典扫雷游戏（2500行代码）</strong></span>\n<p><span><em>图1：winfrom版</em></span></p>\n<p><span><em>扫雷是一个经典的Windows游戏程序，这是一个10年前写的Winforms程序，包含约2500行C#代码以及若干图片资源文件</em></span></p>\n<p><img alt=\"扫雷游戏\" src=\"https://img2024.cnblogs.com/blog/12406/202601/12406-20260119115236297-958633113.png\" /></p>\n<p><span><em>图2：转换后</em></span></p>\n<p><span><em>我们对旧代码修改了不超过50行(占比2%)就让同一套代码可以无需修改即可编译成 .exe 和.wasm文件。</em></span></p>\n<p><span><img alt=\"图片2\" src=\"https://img2024.cnblogs.com/blog/12406/202601/12406-20260119115330834-395365830.png\" /></span></p>\n<p><span>综上</span></p>\n<p><span><strong>（1）原项目：</strong>10年前编写的Winforms扫雷游戏，依赖GDI+进行界面绘制。</span></p>\n<p><span><strong>（2）迁移过程：</strong>使用MWGA导入项目，仅修改约50行代码（占比2%），主要使用&nbsp;#if&nbsp; MWGA&nbsp;条件编译，将部分同步方法改为异步适配。</span></p>\n<p><span><strong>（3）结果：</strong>同一套代码无需改动绘图逻辑，直接编译为.wasm文件，在Chrome、Firefox、Safari等浏览器中完美运行，界面与交互与原生一致！</span></p>\n<p><span>若没有MWGA，用户还需从前端重写整个游戏，耗时耗力，成本高。而现在，原开发人员可直接在Winforms项目上继续迭代，同步生成网页版！</span></p>\n<p>&nbsp;</p>\n<span><strong>案例二：智能计算器（460行代码）</strong></span>\n<p><span><em>图3：winfrom版</em></span></p>\n<p><span><em>这是一个Winform.NET的计算器程序，包含460行C#代码</em></span></p>\n<p><span style=\"font-size: 16px;\"><em><img alt=\"计算器\" src=\"https://img2024.cnblogs.com/blog/12406/202601/12406-20260119115427518-107951139.png\" /></em></span></p>\n<p><span style=\"font-size: 16px;\"><em>图4：转换后</em></span></p>\n<p><span style=\"font-size: 16px;\"><em>代码未做任何修改，借助MWGA，它在Blazor WASM中运行界面如下图所示。</em></span></p>\n<p><span><img alt=\"图片4\" src=\"https://img2024.cnblogs.com/blog/12406/202601/12406-20260119115505304-749089367.png\" /></span></p>\n<p><span>综上</span></p>\n<p><span><strong>（1）原项目：</strong>Winforms计算器，支持窗体拖拽自适应布局。</span></p>\n<p><span><strong>（2）迁移过程：</strong>代码零修改，直接通过MWGA迁移至Blazor WASM。</span></p>\n<p><span><strong>（3）结果：</strong>在浏览器中运行，窗体大小调整、按钮自适应布局等行为完全保留，用户体验无损迁移！</span></p>\n<p><span>&nbsp;</span></p>\n<span><strong>案例三：时间轴产品，1%代码修改量）</strong></span>\n<p><span>时间轴产品是南京都昌公司的一个WinForms软件产品，现已开源，这是一个面向医院的专业软件产品。</span></p>\n<p><span><strong><img alt=\"图片5\" src=\"https://img2024.cnblogs.com/blog/12406/202602/12406-20260202160302680-1041140241.png\" /></strong></span></p>\n<p><span><strong>原项目：</strong>这是一个7万行代码的WinForms医疗绘图软件，重度依赖Windows的GDI+图形库。</span></p>\n<p><span><strong>迁移过程：</strong>借助MWGA框架，通过添加极少量（约1%）的异步适配代码，使同一套代码能同时编译为桌面程序和WebAssembly应用。</span></p>\n<p><span><strong>迁移结果：</strong>该软件成功在浏览器中原样运行，证明了无需重写即可将复杂C#桌面软件低成本迁移至Web平台。</span></p>\n<p><strong class=\"135brush\"><strong><img alt=\"图片6\" src=\"https://img2024.cnblogs.com/blog/12406/202602/12406-20260202160321078-1847393760.jpg\" /></strong></strong></p>\n<h1><strong class=\"135brush\"><strong>二、广泛适配</strong></strong></h1>\n<p><span>MWGA全面兼容多平台操作系统，包括Windows 7/10/11、Linux、Android、macOS以及统信UOS、麒麟、方德等国产信创系统。应用完全基于浏览器运行，不依赖特定Windows版本，也无需安装独立客户端。转换后的应用可直接部署于标准Web服务器，用户通过Chrome（v95+）、Edge、Firefox（v133+）、Safari等主流浏览器即可访问，无需更换硬件或升级系统，轻松实现应用现代化与合规化。</span></p>\n<p><strong><span>（1）在Windows 7中运行界面如下：</span></strong></p>\n<p><strong><span><img alt=\"图片7\" src=\"https://img2024.cnblogs.com/blog/12406/202602/12406-20260202160401296-9140087.jpg\" /></span></strong></p>\n<p>&nbsp;</p>\n<p><span><strong>（2）在谷歌浏览器中运行的效果如下：</strong></span></p>\n<p><strong><span><img alt=\"图片8\" src=\"https://img2024.cnblogs.com/blog/12406/202602/12406-20260202160426956-315964826.jpg\" /></span></strong></p>\n<p>&nbsp;</p>\n<p><strong><span>（3）在Firefox中运行的效果：</span></strong></p>\n<p><strong><span><img alt=\"图片9\" src=\"https://img2024.cnblogs.com/blog/12406/202602/12406-20260202160758522-570347954.jpg\" /></span></strong></p>\n<p>&nbsp;</p>\n<p><strong><span>（4）在苹果系统中运行的效果：</span></strong></p>\n<p><span><strong><img alt=\"图片10\" src=\"https://img2024.cnblogs.com/blog/12406/202602/12406-20260202160815014-1508511479.jpg\" /></strong></span></p>\n<p><span><strong>（5）在苹果pad中运行的效果：</strong></span></p>\n<p><img alt=\"图片11.jpg\" src=\"https://bexp.135editor.com/files/users/1658/16581196/202602/XIfaemfq_Q74w.jpg?auth_key=1770566399-0-0-85b73e984965158d622f0244d80518dc\" /></p>\n<p><span><strong>（6）在华为pad中运行的效果：</strong></span></p>\n<p><img alt=\"图片12.jpg\" src=\"https://bexp.135editor.com/files/users/1658/16581196/202602/RFUdjSbk_GMNP.jpg?auth_key=1770566399-0-0-086fb31ad63bdcef31fbcf8017898bcd\" /></p>\n<p><span><strong>（7）在苹果手机端运行效果如下：</strong></span></p>\n<p><img alt=\"图片13.png\" src=\"https://bexp.135editor.com/files/users/1658/16581196/202602/yH2Z4tOe_K8re.png?auth_key=1770566399-0-0-9319348da9ee7e23d623be43400fcbb6\" /></p>\n<p><span><strong>（8）在安卓手机端运行效果如下：</strong></span></p>\n<p><img alt=\"图片14.jpg\" src=\"https://bexp.135editor.com/files/users/1658/16581196/202602/HfAKpuk9_92EL.jpg?auth_key=1770566399-0-0-36fcf28439eb68eb75956bd8f7c11587&amp;x-bce-process=image/crop,x_0,y_0,w_394,h_337\" /></p>\n<p><img alt=\"图片15.jpg\" src=\"https://bexp.135editor.com/files/users/1658/16581196/202602/LSFhnIMh_zEkM.jpg?auth_key=1770566399-0-0-13d14553adfd143ec49f771e0423d178\" /></p>\n<h1>&nbsp;三、<strong class=\"135brush\"><strong>转化后的优势，为什么选择MWGA？</strong></strong></h1>\n<p><span><strong>1、迁移效率高：</strong>导入即渲染，适配快，从WinForms到Web仅需数小时</span></p>\n<p><span><strong>2、代码改动少：</strong>平均修改量＜10%，大量业务逻辑与绘图代码可直接复用</span></p>\n<p><span><strong>3、技术门槛低：</strong>无需Blazor或前端经验，WinForms开发人员直接上手</span></p>\n<p><span><strong>4、成本极低：</strong>省去重写人力、学习成本与长期维护成本</span></p>\n<p><span><strong>5、支持GDI+绘图：</strong>系统绘图代码无需重构，直接迁移至Canvas渲染</span></p>\n<p><span><strong>6、跨平台运行：</strong>支持Windows、Linux、Android及主流国产系统</span></p>\n<p><span>对于企业而言，将Winforms应用重写为Web版通常意味着从零开始、高昂的成本与漫长的周期。MWGA的出现，彻底改变了这一局面。企业无需招聘专门的前端开发团队，无需废弃经过多年积累的业务逻辑代码。只需在原有Winforms项目基础上，通过MWGA进行转换，即可同步获得Web版本。未来功能迭代，也只需在Winforms项目中修改一次，便能同步至Web端，极大降低了维护成本和双端不一致的风险。</span></p>\n<h1>&nbsp;四、<strong class=\"135brush\"><strong>立即体验</strong></strong></h1>\n<p>M<span>WGA现已开放下载与试用，欢迎访问我们的GitHub主页获取演示项目与使用指南：</span></p>\n<p><span>🔗 下载地址：<a href=\"https://github.com/dcsoft-yyf/MWGA\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/dcsoft-yyf/MWGA</a></span></p>\n<p><span>📧 联系我们：<a href=\"mailto:28348092@qq.com\" rel=\"noopener nofollow\">28348092@qq.com</a></span></p>\n<p>&nbsp;</p>\n<p><span>迁移前后代码量对比图（图示为示例，实际修改量依项目复杂度而定）：</span></p>\n<p><strong class=\"135brush\"><img alt=\"图片16\" src=\"https://img2024.cnblogs.com/blog/12406/202602/12406-20260202160902626-1390836694.png\" /></strong></p>\n<p><strong class=\"135brush\">END</strong></p>\n<p><img height=\"145\" src=\"https://bexp.135editor.com/files/users/1658/16581196/202602/7rG2PuJH_shWu.jpg?auth_key=1770566399-0-0-5bf797861484c19f5b5976bcb153f14d\" width=\"145\" /></p>\n<p><strong class=\"135brush\">扫码关注</strong></p>\n<p><span class=\"135brush\">南京都昌信息</span></p>\n<p><span class=\"135brush\">一起共创美好未来</span></p>\n\n</div>\n<div class=\"clear\"></div>\n</div>\n\t\t<p class=\"postfoot\">\n\t\t\tposted on \n<span id=\"post-date\">2026-02-02 16:09</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xdesigner\">袁永福 电子病历，医疗信息化</a>&nbsp;\n阅读(<span id=\"post_view_count\">26</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</p>"
    },
    {
      "title": "LLVM Pass快速入门(二)：运行第一个pass",
      "link": "https://www.cnblogs.com/ClownLMe/p/19564658",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ClownLMe/p/19564658\" id=\"cb_post_title_url\" title=\"发布于 2026-02-02 15:17\">\n    <span>LLVM Pass快速入门(二)：运行第一个pass</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"认识pass层级结构\">认识Pass层级结构</h1>\n<p><strong>Pass</strong>范围从上到下一共分为5个层级：</p>\n<ul>\n<li><strong>模块层级</strong>：单个<code>.ll</code>或<code>.bc</code>文件</li>\n<li><strong>调用图层级</strong>：函数调用的关系。</li>\n<li><strong>函数层级</strong>：单个函数。</li>\n<li><strong>基本块层级</strong>：单个代码块。例如C语言中<code>{}</code>括起来的最小代码。</li>\n<li><strong>指令层级</strong>：单个IR指令。</li>\n</ul>\n<p><strong>注意：下面代码最好不要用中文，使用起来非常麻烦，控制台，编译，目标文件的编码不同会造成乱码。</strong></p>\n<h1 id=\"项目目录如下\">项目目录如下</h1>\n<pre><code>/MyProject\n├── CMakeLists.txt # CMake 配置文件\n├── build/ #构建目录\n│   └── test.c #测试编译代码\n└── mypass1.cpp # pass 项目代码\n</code></pre>\n<h3 id=\"一测试代码示例\">一，测试代码示例</h3>\n<p><strong>test.c</strong></p>\n<pre><code class=\"language-c\">#include &lt;stdio.h&gt;\n\nvoid secret_function() {\n&nbsp; &nbsp; printf(\"I am secret\\n\");\n}\n\nint main() {\n&nbsp; &nbsp; secret_function();\n&nbsp; &nbsp; return 0;\n}\n</code></pre>\n<h3 id=\"二pass编写\">二，Pass编写</h3>\n<p>项目描述：通过解析下面代码的IR，将下面代码中的函数名打印出来。<br />\n<strong>mypass1.cpp</strong></p>\n<pre><code class=\"language-c\">#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Passes/PassBuilder.h\"\n#include \"llvm/Passes/PassPlugin.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\nusing namespace llvm;\n\n// 这个结构体基本是固定模板\nnamespace {\n    struct mypass1 : public PassInfoMixin&lt;mypass1&gt; {\n\t    //函数回调，每次遇到函数时调用（这里有重载，存在多种入口方式，可以以模块为入口）\n        PreservedAnalyses run(Function &amp;F, FunctionAnalysisManager &amp;) {\n\t        //这里是主要的逻辑代码，我们主要学习的代码在这\n\t        \n\t        //打印出当前函数的名字\n            errs() &lt;&lt; \"Found Function: \" &lt;&lt; F.getName() &lt;&lt; \"\\n\";\n            \n            //只读时返回：PreservedAnalyses::all()\n            //存在修改时：PreservedAnalyses::none()\n            return PreservedAnalyses::all();\n        }\n    };\n\n}\n\n//下面基本上是固定的模板，每个pass没什么变化，可以直接复制粘贴，或者背熟。\n//直接使用需要修改的是下面的&lt;模块名称，版本号，调用参数，和调用的pass结构体&gt;\nextern \"C\" LLVM_ATTRIBUTE_WEAK::llvm::PassPluginLibraryInfo\nllvmGetPassPluginInfo() {\n    return {\n        LLVM_PLUGIN_API_VERSION,//版本信息\n        \"mypass1\",//模块信息，自定义\n        \"v0.1\",//版本号，自定义\n        [](PassBuilder &amp;PB) {\n            PB.registerPipelineParsingCallback(\n                [](StringRef Name, FunctionPassManager &amp;FPM,\n                   ArrayRef&lt;PassBuilder::PipelineElement&gt;) {\n                    if (Name == \"mypass1\") {//调用参数\n                        FPM.addPass(mypass1());//上面pass结构体\n                        return true;\n                    }\n                    return false;\n                }\n            );\n        }\n    };\n}\n</code></pre>\n<h3 id=\"三pass的构建\">三，Pass的构建</h3>\n<p>构建LLVM Pass需要写<code>CMakeLists.txt</code>构建声明</p>\n<h5 id=\"1-配置cmake配置文件\">1. 配置CMake配置文件</h5>\n<p><strong>CMakeLists.txt</strong><br />\n下面的<code>cmake</code>配置可以直接拿去用，我已经标注好需要修改的位置</p>\n<pre><code class=\"language-python\">#cmake 版本，可通过 cmake --version 判断\ncmake_minimum_required(VERSION 4.1.1) #----&gt;修改 cmake版本号\n#项目名字\nproject(mypass1) #----&gt;修改 项目名称\n\n#导入项目的 LLVM cmake 配置文件路径(如果根据我之前文章安装这里就相同)\nset(LLVM_DIR \"D:/LLVM/llvm-project/build/lib/cmake/llvm\")#----&gt;修改 llvm cmake配置路径\n#寻找 LLVM 的包文件\n#REQUIRED 找不到 LLVM 则停止构建\n#强制使用 LLVM 安装时生成的配置文件进行定位\nfind_package(LLVM REQUIRED CONFIG)\n#将 LLVM 的 CMake 模块路径添加到当前 CMake 搜索路径中，以便后续使用 include(AddLLVM)。\nlist(APPEND CMAKE_MODULE_PATH \"${LLVM_CMAKE_DIR}\")\n\n#引入 LLVM 提供的专用 CMake 宏\ninclude(AddLLVM)\n#将 LLVM 的头文件目录（如 llvm/IR/Function.h）加入编译器的搜索路径\ninclude_directories(${LLVM_INCLUDE_DIRS})\n#导入 LLVM 编译时使用的宏定义\nadd_definitions(${LLVM_DEFINITIONS})\n#设置 C++ 标准为 C++17。(这里如果不用17编译会报错)\nset(CMAKE_CXX_STANDARD 17)\n#强制要求必须支持 C++17，如果编译器不支持则失败。\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n#创建一个模块化的库(.dll)\nadd_library(mypass8 MODULE mypass8.cpp) #----&gt;修改 项目名称，文件名\n#windows不用会报错：导出符号\n#LLVM Pass 需要暴露一些特定的入口点（如 getAnalysisUsage）给 opt 工具调用。\nset_target_properties(mypass8 PROPERTIES WINDOWS_EXPORT_ALL_SYMBOLS ON) #----&gt;修改 项目名称\n# 指定该 Pass 需要链接的 LLVM 核心组件。 \n# LLVMCore: 提供 IR、Function、Module 等核心类。 \n# LLVMSupport: 提供各种辅助工具类（如 errs() 输出）。\ntarget_link_libraries(mypass8 LLVMCore LLVMSupport) #----&gt;修改 项目名称，文件名  \n# 为该目标设置特定的编译器选项。 \n# /utf-8: 告诉 MSVC 编译器使用 UTF-8 编码处理源代码，防止中文注释引起的乱码或编译错误。  \ntarget_compile_options(mypass8 PRIVATE /utf-8)#----&gt;修改 项目名称，文件名\n</code></pre>\n<h5 id=\"2编译并构建pass\">2.编译并构建Pass</h5>\n<p><strong>打开visual studio<code>的工作台，我这里是</code>x64 Native Tools Command Prompt for VS 2022`</strong></p>\n<p>进到<code>build</code>目录</p>\n<pre><code class=\"language-bash\">#构建项目\n#其中-DCMAKE_BUILD_TYPE=RelWithDebInfo不选会报错，由于我之前编译的是带符号的relase版本\ncmake -G \"Ninja\"  -DCMAKE_BUILD_TYPE=RelWithDebInfo ..\n#编译\nninja\n</code></pre>\n<p>最后出现下面提示，即为编译成功</p>\n<pre><code class=\"language-bash\">[2/2] Linking CXX shared module mypass1.dll\n</code></pre>\n<h3 id=\"四使用你第一个pass\">四，使用你第一个Pass</h3>\n<p>进到<code>build</code>目录</p>\n<pre><code class=\"language-bash\">#把.c文件编译为.ll\n#-O1 使用O1优化（这里我尝试-O0不优化，会导致我的pass无法应用）\n#-Xclang -disable-llvm-passes 不使用默认的pass优化\nclang -S -emit-llvm -O1 -Xclang -disable-llvm-passes test.c -S -o test.ll\n\n#使用pass\nopt -load-pass-plugin=mypass1.dll -passes=mypass1  test.ll -S -o test_opt.ll\n</code></pre>\n<p><strong>输出结果</strong></p>\n<pre><code class=\"language-bash\">Found Function: sprintf\nFound Function: vsprintf\nFound Function: _snprintf\nFound Function: _vsnprintf\nFound Function: secret_function\nFound Function: printf\nFound Function: main\nFound Function: _vsprintf_l\nFound Function: _vsnprintf_l\nFound Function: __local_stdio_printf_options\nFound Function: _vfprintf_l\n</code></pre>\n<p><strong>如果❤喜欢❤本系列教程，就点个关注吧，后续不定期更新~</strong></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-02 15:17</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ClownLMe\">ClownLMe</a>&nbsp;\n阅读(<span id=\"post_view_count\">26</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MySQL 5.6 2000 万行高频读写表新增字段实战：从慢执行到无锁落地全解析",
      "link": "https://www.cnblogs.com/xxhxs-21/p/19564624",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xxhxs-21/p/19564624\" id=\"cb_post_title_url\" title=\"发布于 2026-02-02 15:13\">\n    <span>MySQL 5.6 2000 万行高频读写表新增字段实战：从慢执行到无锁落地全解析</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"MySQL 5.6 2000 万行高频读写表新增字段实战：从慢执行到无锁落地全解析\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/1869035/202602/1869035-20260202151226843-1773744596.png\" />\n        MySQL 5.6 2000 万行高频读写表新增字段实战：从慢执行到无锁落地全解析\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2><span>一、背景与问题缘起</span></h2>\n<p><span>MySQL 5.6.51 版本下 2000 万行核心业务表开展新增字段操作，需求为新增<code></code><code>BIGINT(19) NOT NULL DEFAULT 0 COMMENT '注释'</code>（因业务实际需要存储大数值关联字段）。</span></p>\n<p><span>表的核心特性为Java 多线程密集读写，业务请求持续高频，初始执行原生<code>ALTER TABLE</code>语句时出现两大核心问题：</span></p>\n<ol>\n<li><span>72 万行测试表执行耗时 203 秒，线性推算 2000 万行表耗时超 1.5 小时；</span></li>\n<li><span>生产执行时触发表锁、查询失效，严重影响业务正常运行。</span></li>\n</ol>\n<div><span>本次实操的核心挑战集中在：MySQL 5.6 版本未支持高版本的表结构元数据原地修改优化、大表全量数据拷贝的 IO 资源占用、高频读写场景下的资源竞争、MDL 锁等待导致的锁表风险，需通过针对性方案实现无锁、无业务感知、高效的字段新增。</span></div>\n<h2><span>二、核心问题根源剖析</span></h2>\n<h3><span>2.1 MySQL 5.6 Online DDL 的先天局限</span></h3>\n<div><span>MySQL 5.6 虽引入 InnoDB Online DDL 特性，解决了传统 DDL 锁表阻塞业务的问题，但未支持高版本（5.7/8.0）的元数据原地修改优化—— 新增任何类型字段均需全表拷贝数据，而拷贝过程会占用大量磁盘 IO，这是大表 DDL 执行慢的核心根源。尤其对于 2000 万行表，全表拷贝的 IO 开销成为性能瓶颈，72 万行小表测试耗时 203 秒的核心原因也在于此。</span></div>\n<div>\n<h3><span>2.2&nbsp;显式默认值对 DDL 的优化作用</span></h3>\n</div>\n<div><span>MySQL 5.6 对原生数值类型（TINYINT/INT/BIGINT）+ 简单常量默认值（如 0）的 DDL 操作有轻量级优化：无默认值时需全表拷贝 + 逐行初始化字段值，而显式指定默认值后会优化为全表拷贝 + 批量赋值默认值，减少 60% 以上的 IO 开销，且该优化对数值类型的适配性远优于 VARCHAR 类型（BIGINT 比 VARCHAR 的执行效率更高、资源占用更低）。</span></div>\n<div>\n<h3><span>2.3&nbsp;锁表的真正元凶：MDL 锁等待与长事务阻塞</span></h3>\n</div>\n<div><span>执行<code>ALTER TABLE</code>时出现的表锁、查询失效，并非 DDL 本身锁表，而是 MySQL 5.6 的 MDL（元数据锁）机制导致：</span><ol>\n<li><span>DDL 执行前需获取表的MDL 排他锁（X 锁），而普通读写操作会持有MDL 共享锁（S 锁），X 锁与任何锁互斥；</span></li>\n<li><span>若执行 DDL 时表上存在未提交长事务、慢查询、空闲长连接（持有 S 锁未释放），DDL 会进入<code>Waiting for table metadata lock</code>状态；</span></li>\n<li><span>MySQL 5.6 的 MDL 锁等待为阻塞式且无超时机制，后续所有读写请求（包括新的 SELECT）都会排队阻塞，表现为 “表被锁、查询失效”。</span></li>\n</ol>\n<h3><span>2.4&nbsp;耗时非线性的核心原因</span></h3>\n<p><span>72 万行表 203 秒的测试结果无法线性推算 2000 万行表耗时，因 MySQL 5.6 执行优化后的 DDL 时，单位行耗时会随数据量增大而降低：</span></p>\n<ol>\n<li><span>大表支持批量块拷贝，能充分发挥磁盘连续 IO 优势，减少寻道时间；</span></li>\n<li><span>大表处理过程中InnoDB 缓冲池缓存命中率更高，减少物理 IO 次数；</span></li>\n<li><span>小表数据分散，存在部分随机 IO，调度和 IO 开销相对更高。</span></li>\n</ol>\n<h2><span>三、适配 MySQL 5.6 的最优 DDL 语句</span></h2>\n<p><span>针对 2000 万行表、BIGINT 类型、默认值 0 的需求，结合 MySQL 5.6 的优化特性，确定最优 DDL 语句，显式指定所有属性以最大化触发优化：</span></p>\n<div class=\"cnblogs_code\">\n<pre><span><span style=\"color: rgba(0, 0, 255, 1);\">ALTER</span> <span style=\"color: rgba(0, 0, 255, 1);\">TABLE</span><span style=\"color: rgba(0, 0, 0, 1);\"> 表名 \n</span><span style=\"color: rgba(0, 0, 255, 1);\">ADD</span> <span style=\"color: rgba(0, 0, 255, 1);\">COLUMN</span> 字段名 <span style=\"color: rgba(0, 0, 255, 1);\">BIGINT</span>(<span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">19</span>) <span style=\"color: rgba(128, 128, 128, 1);\">NOT</span> <span style=\"color: rgba(0, 0, 255, 1);\">NULL</span> <span style=\"color: rgba(0, 0, 255, 1);\">DEFAULT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">0</span> COMMENT <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">注释</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>;</span></pre>\n</div>\n<p><span>语句关键属性说明</span></p>\n<ol>\n<li><span><code>BIGINT(19)</code>：原生数值类型，取值范围覆盖超大整数（-9223372036854775808~9223372036854775807），19 为显示宽度（匹配有符号最大位数，不限制实际取值）；</span></li>\n<li><span><code>NOT NULL DEFAULT 0</code>：核心优化点，简单常量默认值触发 MySQL 5.6 批量赋值优化，非空设置避免 NULL 值，简化业务代码空值判断；</span></li>\n<li><span>显式注释：提升表结构可读性，便于后续维护。</span></li>\n</ol>\n<div><span>若需新增 VARCHAR 类型字段，需显式指定<code>DEFAULT ''</code>触发优化：</span></div>\n<div>\n<div class=\"cnblogs_code\">\n<pre><span><span style=\"color: rgba(0, 0, 255, 1);\">ALTER</span> <span style=\"color: rgba(0, 0, 255, 1);\">TABLE</span><span style=\"color: rgba(0, 0, 0, 1);\"> 表名\n</span><span style=\"color: rgba(0, 0, 255, 1);\">ADD</span> <span style=\"color: rgba(0, 0, 255, 1);\">COLUMN</span> 字段名 <span style=\"color: rgba(0, 0, 255, 1);\">VARCHAR</span>(<span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">50</span>) <span style=\"color: rgba(0, 0, 255, 1);\">DEFAULT</span> <span style=\"color: rgba(255, 0, 0, 1);\">''</span> COMMENT <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">注释</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>;</span></pre>\n</div>\n</div>\n<h2><span>四、生产环境无锁落地全流程方案</span></h2>\n<h3><span>4.1 执行前准备：清锁源 + 低峰期 + 参数调优（核心避坑）</span></h3>\n<h4><span>4.1.1 选择极致低峰期执行</span></h4>\n<div><span>建议：优先选择凌晨 2:00-4:00，或其他业务低峰期，减少活跃事务，降低 MDL 锁等待概率。</span></div>\n<h4><span>4.1.2 强制清理锁源（必做，避免 MDL 锁等待）</span></h4>\n<div><span>执行 DDL 前踢掉空闲长连接、终止长事务 / 慢查询，释放所有未提交的 S 锁：</span></div>\n<div>\n<div class=\"cnblogs_code\">\n<pre><span><span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> 1. 临时缩短长连接超时时间，踢掉空闲连接</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">SET</span> GLOBAL wait_timeout <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">10</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">SET</span> GLOBAL interactive_timeout <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">10</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> SLEEP(<span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">15</span>); <span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> 等待15秒让连接自动断开</span><span style=\"color: rgba(0, 128, 128, 1);\">\n--</span><span style=\"color: rgba(0, 128, 128, 1);\"> 2. 恢复长连接超时默认值（8小时）</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">SET</span> GLOBAL wait_timeout <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">28800</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">SET</span> GLOBAL interactive_timeout <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">28800</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> 3. 主动终止目标表上的慢查询/长事务（替换库名、表名）</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> CONCAT(<span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">KILL </span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, id, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">;</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">) \n</span><span style=\"color: rgba(0, 0, 255, 1);\">FROM</span><span style=\"color: rgba(0, 0, 0, 1);\"> INFORMATION_SCHEMA.PROCESSLIST \n</span><span style=\"color: rgba(0, 0, 255, 1);\">WHERE</span> db <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">数据库名</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span> \n  <span style=\"color: rgba(128, 128, 128, 1);\">AND</span> info <span style=\"color: rgba(128, 128, 128, 1);\">LIKE</span> <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">%表名%</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span> \n  <span style=\"color: rgba(128, 128, 128, 1);\">AND</span> Time <span style=\"color: rgba(128, 128, 128, 1);\">&gt;</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">30</span> \n  <span style=\"color: rgba(128, 128, 128, 1);\">AND</span> Command <span style=\"color: rgba(128, 128, 128, 1);\">IN</span> (<span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">Query</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">Sleep</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> 执行上述查询生成的KILL语句，释放S锁</span></span></pre>\n</div>\n</div>\n<h4><span>4.1.3 临时 MySQL 参数调优（提速 + 减少资源竞争）</span></h4>\n<div><span>可选：动态调整参数，无需重启，DDL 完成后恢复，核心优化 DDL 执行效率和 IO 利用率：</span></div>\n<div>\n<div class=\"cnblogs_code\">\n<pre><span><span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> 调大DDL专用缓冲区，提升批量拷贝效率（默认1M，调至16M）</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">SET</span> GLOBAL innodb_ddl_buffer_size <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">16</span><span style=\"color: rgba(128, 128, 128, 1);\">*</span><span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1024</span><span style=\"color: rgba(128, 128, 128, 1);\">*</span><span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1024</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> 减少写操作IO开销，避免新的长事务</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">SET</span> GLOBAL innodb_flush_log_at_trx_commit <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">2</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> 调大读写缓冲区，缓解缓存竞争</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">SET</span> GLOBAL innodb_read_buffer_size <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">16</span><span style=\"color: rgba(128, 128, 128, 1);\">*</span><span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1024</span><span style=\"color: rgba(128, 128, 128, 1);\">*</span><span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1024</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">SET</span> GLOBAL innodb_write_buffer_size <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">8</span><span style=\"color: rgba(128, 128, 128, 1);\">*</span><span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1024</span><span style=\"color: rgba(128, 128, 128, 1);\">*</span><span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1024</span>;</span></pre>\n</div>\n</div>\n<h3><span>4.2 执行中：实时监控 + 状态判断 + 资源管控</span></h3>\n<h4><span>4.2.1 核心状态判断（确认 MDL 锁获取成功）</span></h4>\n<div><span>通过<code>SHOW FULL PROCESSLIST;</code>查看 DDL 进程状态，脱离锁表风险期的核心标志：</span></div>\n<ul>\n<li><span>风险状态：<code>State = Waiting for table metadata lock</code>（未获取 MDL 锁，阻塞后续所有读写）；</span></li>\n<li><span>正常状态：<code>State = executing</code> 或 <code>State = copying to tmp table</code>（MDL 锁已成功获取，DDL 无锁执行中，二者为 MySQL 5.6 命名差异，等效无锁）。</span></li>\n</ul>\n<div><span>精准过滤 DDL 进程的查询语句（避免翻找）：</span></div>\n<div>\n<div class=\"cnblogs_code\">\n<pre><span><span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span><span style=\"color: rgba(0, 0, 0, 1);\"> id, command, state, info, time \n</span><span style=\"color: rgba(0, 0, 255, 1);\">FROM</span><span style=\"color: rgba(0, 0, 0, 1);\"> INFORMATION_SCHEMA.PROCESSLIST \n</span><span style=\"color: rgba(0, 0, 255, 1);\">WHERE</span> info <span style=\"color: rgba(128, 128, 128, 1);\">LIKE</span> <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">%表名%</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span> \n  <span style=\"color: rgba(128, 128, 128, 1);\">AND</span> command <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">ALTER TABLE</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>;</span></pre>\n</div>\n</div>\n<h4><span>4.2.2 实时资源监控</span></h4>\n<div><span>无需持续盯守，1 分钟查看 1 次核心指标，避免资源耗尽：</span></div>\n<div>\n<div class=\"cnblogs_code\">\n<pre><span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 监控磁盘IO（核心，%util为关键指标，控制在≤80%）</span>\niostat -x 1\n<span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 监控MySQL的CPU/内存占用</span>\ntop -p `pidof mysqld`</span></pre>\n</div>\n<div class=\"cnblogs_code\">\n<pre><span><span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> 查看InnoDB DDL执行状态，确认增量日志同步正常</span>\nSHOW ENGINE INNODB STATUS\\G;</span></pre>\n</div>\n</div>\n<h4><span>4.2.3 读写量突增的应对方案</span></h4>\n<div><span>可选：若执行期间业务读写量增加（IO 利用率 &gt; 90%），无需中断 DDL（中断会导致之前的工作白费），通过轻量操作缓解资源竞争：</span></div>\n<div>\n<div class=\"cnblogs_code\">\n<pre><span><span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> 临时关闭自适应刷新，减少后台IO</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">SET</span> GLOBAL innodb_adaptive_flushing <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(0, 0, 255, 1);\">OFF</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> 若业务支持，临时动态限流（Java业务侧开关），将QPS限制在日常60%-70%</span></span></pre>\n</div>\n</div>\n<h3><span>4.3 执行后：恢复配置 + 全维度验证（必做）</span></h3>\n<h4><span>4.3.1 恢复 MySQL 默认配置</span></h4>\n<div><span>将临时调整的参数恢复默认，保证数据库长期运行的性能和数据安全性：</span></div>\n<div>\n<div class=\"cnblogs_code\">\n<pre><span><span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> 恢复DDL缓冲区</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">SET</span> GLOBAL innodb_ddl_buffer_size <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span><span style=\"color: rgba(128, 128, 128, 1);\">*</span><span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1024</span><span style=\"color: rgba(128, 128, 128, 1);\">*</span><span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1024</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> 恢复日志刷盘安全级别（保证宕机不丢数据，核心）</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">SET</span> GLOBAL innodb_flush_log_at_trx_commit <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> 恢复读写缓冲区</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">SET</span> GLOBAL innodb_read_buffer_size <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span><span style=\"color: rgba(128, 128, 128, 1);\">*</span><span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1024</span><span style=\"color: rgba(128, 128, 128, 1);\">*</span><span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1024</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">SET</span> GLOBAL innodb_write_buffer_size <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">8</span><span style=\"color: rgba(128, 128, 128, 1);\">*</span><span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1024</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> 恢复自适应刷新</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">SET</span> GLOBAL innodb_adaptive_flushing <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(0, 0, 255, 1);\">ON</span>;</span></pre>\n</div>\n</div>\n<h4><span>4.3.2 DDL 执行成功的全维度验证</span></h4>\n<p><span>表结构验证：确认新字段属性完全符合预期</span></p>\n<div>\n<div class=\"cnblogs_code\">\n<pre><span><span style=\"color: rgba(0, 0, 255, 1);\">DESC</span> 表名; <span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> 快速查看字段属性</span>\nSHOW <span style=\"color: rgba(0, 0, 255, 1);\">CREATE</span> <span style=\"color: rgba(0, 0, 255, 1);\">TABLE</span> 表名; <span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> 精准确认完整定义</span></span></pre>\n</div>\n</div>\n<p><span>数据验证：确认新字段默认值赋值正常，无空值</span></p>\n<div>\n<div class=\"cnblogs_code\">\n<pre><span><span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> id, 新增字段名 <span style=\"color: rgba(0, 0, 255, 1);\">FROM</span> 表名LIMIT <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">20</span>; <span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> 随机查询默认值</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(255, 0, 255, 1);\">COUNT</span>(<span style=\"color: rgba(128, 128, 128, 1);\">*</span>) <span style=\"color: rgba(0, 0, 255, 1);\">FROM</span> 表名 <span style=\"color: rgba(0, 0, 255, 1);\">WHERE</span> 新增字段名 <span style=\"color: rgba(0, 0, 255, 1);\">IS</span> <span style=\"color: rgba(128, 128, 128, 1);\">NOT</span> <span style=\"color: rgba(0, 0, 255, 1);\">NULL</span>; <span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> 全量验证非空</span></span></pre>\n</div>\n</div>\n<p><span>读写验证：模拟业务操作，确认读写正常</span></p>\n<div>\n<div class=\"cnblogs_code\">\n<pre><span><span style=\"color: rgba(0, 0, 255, 1);\">UPDATE</span> 表名 <span style=\"color: rgba(0, 0, 255, 1);\">SET</span> 新增字段名<span style=\"color: rgba(128, 128, 128, 1);\">=</span><span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">2</span> <span style=\"color: rgba(0, 0, 255, 1);\">WHERE</span> id<span style=\"color: rgba(128, 128, 128, 1);\">=</span>xxx; <span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> 模拟更新</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">INSERT</span> <span style=\"color: rgba(0, 0, 255, 1);\">INTO</span> 表名 (id, 新增字段名) <span style=\"color: rgba(0, 0, 255, 1);\">VALUES</span> (xxx, <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">3</span>); <span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> 模拟插入</span></span></pre>\n</div>\n</div>\n<p><span>业务验证：观察 Java 多线程业务日志，确认无超时、报错、事务回滚等异常。</span></p>\n<h2><span>五、关键问题与解决方案汇总</span></h2>\n<div><span>&nbsp;</span></div>\n<div>\n<div>\n<table>\n<thead>\n<tr><th><span>核心问题</span></th><th><span>解决方案</span></th><th><span>关键要点</span></th></tr>\n</thead>\n<tbody>\n<tr>\n<td><span>DDL 执行慢（全表拷贝）</span></td>\n<td><span>显式指定简单默认值，触发 MySQL 5.6 批量赋值优化</span></td>\n<td><span>数值类型优化效果优于 VARCHAR，BIGINT (19) DEFAULT 0 最优</span></td>\n</tr>\n<tr>\n<td><span>线性推算耗时偏差大</span></td>\n<td><span>无需推算，2000 万行表 SSD 磁盘 5-8 分钟，机械硬盘 12-18 分钟</span></td>\n<td><span>大表批量拷贝、缓存命中率高、连续 IO 优势降低单位行耗时</span></td>\n</tr>\n<tr>\n<td><span>MDL 锁等待导致锁表</span></td>\n<td><span>低峰期执行 + 清理锁源（踢长连接、终止长事务）</span></td>\n<td><span>执行前必做，避免 DDL 进入 Waiting for table metadata lock 状态</span></td>\n</tr>\n<tr>\n<td><span>高频读写场景资源竞争</span></td>\n<td><span>临时参数调优 + 轻量限流（可选）</span></td>\n<td><span>仅引发 IO/CPU 竞争，无锁表风险，业务延迟轻微波动</span></td>\n</tr>\n<tr>\n<td><span>执行期间读写量突增</span></td>\n<td><span>监控资源指标 + 临时降低 IO 刷盘频率</span></td>\n<td><span>无需中断 DDL，MySQL 会自动适配资源，优先保障业务</span></td>\n</tr>\n<tr>\n<td><span>DDL 状态判断困难</span></td>\n<td><span>通过 SHOW FULL PROCESSLIST 查看 State 列</span></td>\n<td><span>executing/copying to tmp table 为正常无锁状态</span></td>\n</tr>\n</tbody>\n</table>\n</div>\n</div>\n<div><span>&nbsp;</span></div>\n<h2><span>六、避坑指南：绝对禁止的操作</span></h2>\n<ol>\n<li><span>禁止在业务高峰期 / 中峰期执行 DDL：即使做了调优，高峰期 IO 已接近瓶颈，会导致业务延迟大幅增加，触发超时重试；</span></li>\n<li><span>禁止新增 “非空无默认值” 字段：MySQL 5.6 会全表逐行初始化，2000 万行表耗时数小时，且占用大量资源；</span></li>\n<li><span>禁止 DDL 等待 MDL 锁时无动于衷：MySQL 5.6 MDL 锁无超时，需手动终止持锁进程，否则会无限阻塞后续所有操作；</span></li>\n<li><span>禁止修改 MySQL 参数后不恢复：尤其是<code>innodb_flush_log_at_trx_commit=2</code>，会降低数据持久性，宕机可能丢失数据；</span></li>\n<li><span>禁止在 DDL 执行中手动中断进程：中断会导致之前的拷贝工作白费，重新执行需再次获取 MDL 锁，耗时翻倍；</span></li>\n<li><span>禁止忽略表结构验证：DDL 进程消失后，必须通过 DESC/SHOW CREATE TABLE 确认字段属性，避免定义缺失。</span></li>\n</ol>\n<h2><span>七、延伸优化：长期解决方案</span></h2>\n<div><span>本次实操为 MySQL 5.6 环境的临时最优解，若业务侧允许，升级至 MySQL 5.7/8.0是处理大表 DDL 的终极方案：</span></div>\n<ol>\n<li><span>高版本支持表结构元数据原地修改：新增数值类型 / VARCHAR 类型（允许空 / 简单默认值）字段时，仅修改元数据，无需全表拷贝，2000 万行表耗时毫秒级；</span></li>\n<li><span>MDL 锁机制优化：支持锁超时、排队机制优化，减少锁表概率；</span></li>\n<li><span>整体性能提升：查询优化、并发控制、锁机制均优于 5.6，高频读写表的整体性能提升 30%-50%；</span></li>\n<li><span>生态更完善：支持 JSON 类型、窗口函数、并行复制等新特性，满足业务后续发展需求。</span></li>\n</ol>\n<div><span>升级注意事项：升级前全量备份数据库，选择低峰期执行，主从切换可实现业务无感知升级，5.7/8.0 与 5.6 兼容性极高，普通业务代码无需修改。</span></div>\n<h2><span>八、总结</span></h2>\n<div><span>本次 MySQL 5.6 2000 万行高频读写表新增字段的实操，核心围绕 **“利用版本特性做优化、规避 MDL 锁机制坑、平衡资源竞争与业务稳定性”展开，最终实现了无锁、无业务感知、高效 ** 的落地，核心结论如下：</span></div>\n<ol>\n<li><span>MySQL 5.6 虽无高版本的元数据原地修改优化，但通过显式指定简单默认值，可大幅降低 DDL 执行时间，是 2000 万行表的最优临时方案；</span></li>\n<li><span>锁表的核心根源并非 DDL 本身，而是MDL 锁等待 + 长事务阻塞，执行前清理锁源是避坑关键；</span></li>\n<li><span>Online DDL 的无锁特性仅存在于MDL 锁获取成功后（executing/copying to tmp table 状态），此阶段脱离锁表风险，后续仅存在资源竞争；</span></li>\n<li><span>高频读写场景下执行 DDL，无需暂停业务，仅需低峰期执行 + 临时参数调优，业务延迟仅为毫秒级→十毫秒级，完全无感知；</span></li>\n<li><span>所有操作均为 MySQL 内置命令 + 动态参数调整，无需安装额外工具，适配生产环境紧急排查和日常实操。</span></li>\n</ol>\n<div><span>本次实操的方案可复用于 MySQL 5.6 环境下所有大表（千万级）的普通字段新增操作，为同版本、同场景的数据库运维提供可落地的参考。</span></div>\n</div>\n\n</div>\n<div id=\"MySignature\">\n    <div style=\"border: 2px solid yellow;\">\n<p style=\"font-weight: bold;\">  时间仓促，如有错误欢迎指出，欢迎在评论区讨论，如对您有帮助还请点个推荐、关注支持一下</p>\n<p style=\"font-weight: bold;\">  作者：<a href=\"http://www.cnblogs.com/xxhxs-21/\" target=\"_blank\">博客园 - 凉年技术</a></p>\n<p style=\"font-weight: bold;\">  出处：<a href=\"http://www.cnblogs.com/xxhxs-21/\" target=\"_blank\">http://www.cnblogs.com/xxhxs-21/</a></p>\n<p>  本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须在文章页面给出原文链接，否则保留追究法律责任的权利。</p>\n<p>  若内容有侵犯您权益的地方，请公告栏处联系本人，本人定积极配合处理解决。</p>\n</div>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-02 15:13</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xxhxs-21\">凉年技术</a>&nbsp;\n阅读(<span id=\"post_view_count\">41</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "spring6-多种类型的注入方式",
      "link": "https://www.cnblogs.com/alineverstop/p/19563560",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/alineverstop/p/19563560\" id=\"cb_post_title_url\" title=\"发布于 2026-02-02 12:12\">\n    <span>spring6-多种类型的注入方式</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"ocp原则\">OCP原则</h1>\n<p>ocp指开闭原则，对扩展开放，对修改关闭。是七大原则中最基本的一个原则。</p>\n<h1 id=\"依赖倒置原则dip\">依赖倒置原则（DIP）</h1>\n<h2 id=\"什么是依赖倒置原则\">什么是依赖倒置原则</h2>\n<p>核心是面向接口编程、面向抽象编程， 不是面向具体编程。</p>\n<h2 id=\"依赖倒置原则的目的\">依赖倒置原则的目的</h2>\n<p>降低耦合度，提高扩展力</p>\n<h1 id=\"什么是控制反转\">什么是控制反转</h1>\n<p>控制反转：Ioc（Inversion of Controll），一种编程思想、设计模式。为了降低程序耦合度</p>\n<p>反转有两点：</p>\n<ol>\n<li>不在程序中采用硬编码的方式new对象，把创建对象交给别人（UserService userService = new UserServiceImplForMysql()）。</li>\n<li>不在程序中采用硬编码的方式维护对象关系。</li>\n</ol>\n<h1 id=\"spring框架\">spring框架</h1>\n<p>spring实现了Ioc，因此可以创建和维护对象见的关系。</p>\n<p>控制反转实现方式主要有 <strong>依赖注入（Dependency Injection DI）</strong></p>\n<p>依赖注入的方式有以下方式：</p>\n<ol>\n<li>Set注入（执行Set方法赋值）</li>\n<li>构造方法注入（执行构造方法赋值）</li>\n</ol>\n<h2 id=\"依赖注入中的依赖注入的含义\">依赖注入中的“依赖”、“注入”的含义</h2>\n<p>依赖：A对象和B对象的关系</p>\n<p>注入：是一种手段，通过这种手段让A和B产生关系。</p>\n<p>依赖注入的实现方式有：set注入和构造方法注入。</p>\n<h3 id=\"set注入\">set注入</h3>\n<ol>\n<li>配置文件配置bean</li>\n</ol>\n<pre><code class=\"language-xml\">&lt;!--    配置dao--&gt;\n    &lt;bean id=\"userDao\" class=\"com.ali.dao.UserDao\"&gt;\n    &lt;/bean&gt;\n&lt;!--    配置Service--&gt;\n    &lt;bean id=\"userService\" class=\"com.ali.service.UserService\"&gt;\n        &lt;!--注入dao，这里的name是 set方法名去掉set字符后剩下的单词首字母小写--&gt;\n&lt;!--        ref后面指定要注入的bean的id--&gt;\n        &lt;property name=\"userDao\" ref=\"userDao\"/&gt;\n    &lt;/bean&gt;\n</code></pre>\n<ol start=\"2\">\n<li>在类中写set方法</li>\n</ol>\n<pre><code class=\"language-java\">package com.ali.service;\n\nimport com.ali.dao.UserDao;\n\npublic class UserService {\n\n    private UserDao userDao;\n\n    // set注入需要提供一个set方法，方法名以set开头，spring容器调用这个set方法注入UserDao\n        public void setUserDao(UserDao userDao) {\n        this.userDao = userDao;\n    }\n\n    public void saveUser(){\n        userDao.insertUser();\n    }\n}\n</code></pre>\n<p>这样即可注入成功。</p>\n<h4 id=\"注入外部bean\">注入外部bean</h4>\n<pre><code class=\"language-xml\">&lt;!--    声明bean--&gt;\n    &lt;bean id=\"orderDao\" class=\"com.ali.dao.OrderDao\" /&gt;\n\n    &lt;bean id=\"orderService\" class=\"com.ali.service.OrderService\"&gt;\n&lt;!--    使用ref 来    注入外部bean--&gt;\n        &lt;property name=\"orderDao\" ref=\"orderDao\"/&gt;\n    &lt;/bean&gt;\n</code></pre>\n<h4 id=\"注入内部bean\">注入内部bean</h4>\n<pre><code class=\"language-xml\">    &lt;bean id=\"orderService2\" class=\"com.ali.service.OrderService\"&gt;\n      &lt;property name=\"orderDao\"&gt;\n&lt;!--          在property标签中使用嵌套bean，这就是内部bean--&gt;\n          &lt;bean class=\"com.ali.dao.OrderDao\" &gt;&lt;/bean&gt;\n      &lt;/property&gt;\n    &lt;/bean&gt;\n</code></pre>\n<h4 id=\"注入简单类型\">注入简单类型</h4>\n<pre><code class=\"language-xml\">&lt;!--    注入简单类型属性--&gt;\n&lt;bean id=\"userBean\" class=\"com.ali.bean.User\"&gt;\n&lt;!--    简单类型赋值使用value属性--&gt;\n    &lt;property name=\"name\" value=\"张三\"&gt;&lt;/property&gt;\n    &lt;property name=\"age\" value=\"30\"&gt;&lt;/property&gt;\n    &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n</code></pre>\n<p>实际开发中，一般不会吧Date类型当作简单类型，会使用ref来注入Date类型</p>\n<h4 id=\"级联属性赋值\">级联属性赋值</h4>\n<pre><code class=\"language-xml\">&lt;!--     使用级联属性赋值，给studentBean的clazz属性赋值必须有set、get方法--&gt;\n&lt;!--        先配置clazz  再配置clazz.name--&gt;\n    &lt;bean id=\"studentBean\" class=\"com.ali.bean.Student\"&gt;\n        &lt;property name=\"name\" value=\"李四\"&gt;&lt;/property&gt;\n        &lt;property name=\"clazz\" ref=\"clazzBean\"&gt;&lt;/property&gt;\n        &lt;!--级联属性赋值，给studentBean的clazz属性赋值\n        这里的clazz是Student类中的属性名\n        clazz 必须有set、get方法--&gt;\n        &lt;property name=\"clazz.name\" value=\"高三二班\"&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n    &lt;bean id=\"clazzBean\" class=\"com.ali.bean.Clazz\"&gt;\n    &lt;/bean&gt;\n</code></pre>\n<h4 id=\"注入数组\">注入数组</h4>\n<pre><code class=\"language-xml\">   &lt;!--    注入简单类型属性--&gt;\n&lt;bean id=\"userBean1\" class=\"com.ali.bean.User\"&gt;\n&lt;!--    简单类型赋值使用value属性--&gt;\n    &lt;property name=\"name\" value=\"张三\"&gt;&lt;/property&gt;\n    &lt;property name=\"age\" value=\"30\"&gt;&lt;/property&gt;\n    &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n    &lt;bean id=\"userBean2\" class=\"com.ali.bean.User\"&gt;\n        &lt;!--    简单类型赋值使用value属性--&gt;\n        &lt;property name=\"name\" value=\"张三\"&gt;&lt;/property&gt;\n        &lt;property name=\"age\" value=\"30\"&gt;&lt;/property&gt;\n        &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n    &lt;bean id=\"userBean3\" class=\"com.ali.bean.User\"&gt;\n        &lt;!--    简单类型赋值使用value属性--&gt;\n        &lt;property name=\"name\" value=\"张三\"&gt;&lt;/property&gt;\n        &lt;property name=\"age\" value=\"30\"&gt;&lt;/property&gt;\n        &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n   \n   &lt;bean id=\"qdyBean\" class=\"com.ali.bean.QDY\"&gt;\n&lt;!--        aihao属性是一个字符串数组--&gt;\n        &lt;property name=\"aihao\"&gt;\n            &lt;array&gt;\n                &lt;value&gt;吃&lt;/value&gt;\n                &lt;value&gt;喝&lt;/value&gt;\n            &lt;/array&gt;\n        &lt;/property&gt;\n&lt;!--        friends是一个User对象数组--&gt;\n        &lt;property name=\"friends\"&gt;\n            &lt;array&gt;\n                &lt;ref bean=\"userBean1\"&gt;&lt;/ref&gt;\n                &lt;ref bean=\"userBean2\"&gt;&lt;/ref&gt;\n                &lt;ref bean=\"userBean3\"&gt;&lt;/ref&gt;\n            &lt;/array&gt;\n        &lt;/property&gt;\n    &lt;/bean&gt;\n</code></pre>\n<h4 id=\"注入list和set类型\">注入List和Set类型</h4>\n<pre><code class=\"language-xml\">    &lt;bean id=\"personBean\" class=\"com.ali.bean.Person\"&gt;\n&lt;!--        names是 List&lt;String&gt; 类型--&gt;\n        &lt;property name=\"names\"&gt;\n            &lt;list&gt;\n                &lt;value&gt;张三&lt;/value&gt;\n                &lt;value&gt;里斯&lt;/value&gt;\n                &lt;value&gt;詹姆思&lt;/value&gt;\n            &lt;/list&gt;\n        &lt;/property&gt;\n&lt;!--        address 是 Set&lt;String&gt;   类型--&gt;\n        &lt;property name=\"address\"&gt;\n            &lt;set&gt;\n                &lt;value&gt;北京&lt;/value&gt;\n                &lt;value&gt;上海&lt;/value&gt;\n                &lt;value&gt;广州&lt;/value&gt;\n            &lt;/set&gt;\n        &lt;/property&gt;\n    &lt;/bean&gt;\n</code></pre>\n<h4 id=\"注入map集合\">注入Map集合</h4>\n<pre><code class=\"language-xml\">&lt;!--      phone 是一个Map&lt;Integer, String&gt;类型\n      如果key是简单类型，可以直接使用entry标签的key属性赋值\n      如果key是复杂类型，可以使用\n      &lt;entry key-ref=\"keyBean\" value-ref=\"valueBean\"&gt;&lt;/entry&gt;\n      value同理--&gt;\n      &lt;property name=\"phone\"&gt;\n          &lt;map&gt;\n              &lt;entry key=\"1\" value=\"13800138000\"&gt;&lt;/entry&gt;\n              &lt;entry key=\"2\" value=\"13900139000\"&gt;&lt;/entry&gt;\n              &lt;entry key=\"3\" value=\"13700137000\"&gt;&lt;/entry&gt;\n          &lt;/map&gt;\n      &lt;/property&gt;\n</code></pre>\n<h4 id=\"注入properties类型\">注入Properties类型</h4>\n<pre><code class=\"language-xml\">&lt;!--        Properties 的key 和value只能是字符串类型--&gt;\n        &lt;property name=\"properties\"&gt;\n            &lt;props&gt;\n                &lt;prop key=\"k1\"&gt;v1&lt;/prop&gt;\n                &lt;prop key=\"k2\"&gt;v2&lt;/prop&gt;\n                &lt;prop key=\"k3\"&gt;v3&lt;/prop&gt;\n            &lt;/props&gt;\n        &lt;/property&gt;\n</code></pre>\n<h4 id=\"注入null和空字符串\">注入null和空字符串</h4>\n<pre><code class=\"language-xml\">&lt;!--        以下是手动注入null--&gt;\n        &lt;property name=\"name\" &gt;\n            &lt;null&gt;&lt;/null&gt;\n        &lt;/property&gt;\n        &lt;!--        不给属性注入，属性的默认值是null--&gt;\n&lt;!--        &lt;property name=\"name\" value=\"tom\"&gt;&lt;/property&gt;--&gt;\n&lt;!--       注入空字符串方式一 --&gt;\n        &lt;property name=\"name\" value=\"\"&gt;&lt;/property&gt;\n&lt;!--        注入空字符串方式二 --&gt;\n        &lt;property name=\"name\" &gt;\n            &lt;value&gt;&lt;/value&gt;\n        &lt;/property&gt;\n        &lt;property name=\"age\" value=“31”&gt;&lt;/property&gt;\n</code></pre>\n<h4 id=\"注入特殊字符串\">注入特殊字符串</h4>\n<pre><code class=\"language-xml\"> &lt;bean id=\"mathBean\" class=\"com.ali.bean.MathBean\"&gt;\n        &lt;!--     第一种：使用实体符号代替特殊符号    2&lt;3 --&gt;\n&lt;!--        &lt;property name=\"result\" value=\"2 &amp;lt; 3\"&gt;&lt;/property&gt;--&gt;\n        &lt;!--     第二种：使用&lt;![CDATA[]]&gt; 这里面的内容不会被xml解析    2&lt;3 --&gt;\n        &lt;property name=\"result\"&gt;\n&lt;!--            只能使用value标签--&gt;\n            &lt;value&gt;&lt;![CDATA[2&lt;3]]&gt;&lt;/value&gt;\n        &lt;/property&gt;\n    &lt;/bean&gt;\n</code></pre>\n<h3 id=\"构造注入\">构造注入</h3>\n<ol>\n<li>配置文件配置bean</li>\n</ol>\n<pre><code class=\"language-xml\">    &lt;bean id=\"userDaoBean\" class=\"com.ali.dao.UserDao\"&gt;\n    &lt;/bean&gt;\n&lt;!--     构造注入--&gt;\n    &lt;bean class=\"com.ali.service.CustomerService\" id=\"customerService\"&gt;\n&lt;!--        指定构造方法的第一个参数，下标是0--&gt;\n        &lt;constructor-arg index=\"0\" ref=\"userDaoBean\"&gt;&lt;/constructor-arg&gt;\n        &lt;!--        根据参数名注入--&gt;\n        &lt;constructor-arg name=\"userDao\" ref=\"userDaoBean“&gt;&lt;/constructor-arg&gt;\n    &lt;/bean&gt;\n</code></pre>\n<ol start=\"2\">\n<li>在类中写构造方法</li>\n</ol>\n<pre><code class=\"language-java\">public class CustomerService {\n\n    private UserDao userDao;\n\n    public CustomerService(UserDao userDao) {\n        this.userDao = userDao;\n    }\n\n    public  void save(){\n        userDao.insertUser();\n    }\n}\n</code></pre>\n<h3 id=\"p命名空间注入简化set注入\">p命名空间注入（简化set注入）</h3>\n<pre><code class=\"language-xml\">&lt;!--  p命名空间注入底层还是set注入（类中的属性必须有set方法），只不过p命名空间注入让spring配置更加简单\n  1.在spring配置文件头部添加p命名空间。  xmlns:p=\"http://www.springframework.org/schema/p\"\n  2.使用p命名空间注入属性，语法：p:属性名=\"属性值\"  p:属性名-ref=\"引用类型属性值\"--&gt;\n  &lt;bean id=\"dogBean\" class=\"com.ali.bean.Dog\" p:age=\"22\" p:name=\"张三\" p:birthday-ref=\"birthdayBean\"/&gt;\n\n  &lt;bean id=\"birthdayBean\" class=\"java.util.Date\" /&gt;\n</code></pre>\n<h3 id=\"c命名空间注入简化构造注入\">c命名空间注入（简化构造注入）</h3>\n<pre><code class=\"language-xml\">&lt;!--  c命名空间注入底层还是构造器注入（类中必须有对应的构造器），只不过c命名空间注入让spring配置更加简单\n  1.在spring配置文件头部添加c命名空间。  xmlns:c=\"http://www.springframework.org/schema/c\"\n  2.使用c命名空间注入属性，语法：c:属性名=\"属性值\"  c:属性名-ref=\"引用类型属性值\"\n  c:_0 下标方式   c:name  参数名方式--&gt;\n&lt;bean id=\"peopleBean\" class=\"com.ali.bean.People\" c:name=\"咪咪\" c:age=\"3\" c:sex=\"true\"/&gt;\n</code></pre>\n<h3 id=\"基于xml的自动装配byname\">基于xml的自动装配byName</h3>\n<pre><code class=\"language-xml\">&lt;!--        自动装配：byName、 也是基于set的--&gt;\n&lt;!--    根据名字自动装配，其中OrderDao是OrderService里面的一个属性。必须有set方法--&gt;\n    &lt;bean id=\"orderServiceBean\" class=\"com.ali.service.OrderService\" autowire=\"byName\"&gt;&lt;/bean&gt;\n\n&lt;!--    这个id 必须是OrderService中set方法去掉“set”后首字母小写--&gt;\n    &lt;bean id=\"orderDao\" class=\"com.ali.dao.OrderDao\"&gt;&lt;/bean&gt;\n</code></pre>\n<h3 id=\"基于xml的自动装配bytype\">基于xml的自动装配byType</h3>\n<pre><code class=\"language-xml\">&lt;!--     根据类型自动装配，自动装配是基于set方法的\n         根据类型进行自动装配时，配置文件中某个类型的实例只能有一个\n         --&gt;\n    &lt;bean class=\"com.ali.dao.VipDao\"&gt;&lt;/bean&gt;\n    &lt;bean class=\"com.ali.dao.UserDao\"&gt;&lt;/bean&gt;\n&lt;!--    CustomerService类里面VipDao和UserDao属性，这2个属性必须有set方法才能自动注入上面2个bean--&gt;\n    &lt;bean id=\"customerServiceBean\" class=\"com.ali.service.CustomerService\" autowire=\"byType\"&gt;&lt;/bean&gt;\n\n&lt;/beans&gt;\n</code></pre>\n<h3 id=\"引入外部的属性配置文件\">引入外部的属性配置文件</h3>\n<pre><code class=\"language-xml\">   &lt;!-- 引入外部的properties文件\n     第一步：引入context命名空间 xmlns:context=\"http://www.springframework.org/schema/context\"\n    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n     第二步：使用&lt;context:property-placeholder&gt;标签引入外部的properties文件,默认从类的根路径下加载\n     --&gt;\n    &lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt;\n\n    &lt;bean id=\"mydataSource\" class=\"com.ali.bean.MyDataSource\"&gt;\n        &lt;!-- 使用${}占位符引用外部properties文件中的属性值 这4个属性必须有set方法--&gt;\n        &lt;property name=\"driver\" value=\"${jdbc.diverClass}\"/&gt;\n        &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt;\n        &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt;\n        &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt;\n    &lt;/bean&gt;\n</code></pre>\n<p>jdbc.properties文件</p>\n<pre><code class=\"language-properties\">jdbc.diverClass=com.mysql.cj.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/spring6db?useSSL=false&amp;server\njdbc.username=root\njdbc.password=123456\n</code></pre>\n<h1 id=\"spring怎么实例化对象\">spring怎么实例化对象？</h1>\n<p>默认情况下spring通过反射机制，调用类的无参数构造方法实例化对象</p>\n<p>把创建好的对象存储到Map结构中。</p>\n<p>当有多个配置文件时，可读取多个配置文件</p>\n<pre><code class=\"language-java\">ApplicationContext context = new ClassPathXmlApplicationContext(\"spring.xml\",\"spring-dao.xml\");\n</code></pre>\n<p>可以在配置文件中注入jdk自带的类，只要这个类有无参数构造方法就行。</p>\n<p>getBean（）时，Bean的id不存在时会报错</p>\n<h2 id=\"从类路径之外的路径获取xml配置文件\">从类路径之外的路径获取xml配置文件</h2>\n<pre><code class=\"language-java\">// 读取类路径之外的配置文件\nApplicationContext context = new FileSystemXmlApplicationContext(\"D:/applicationContext.xml\");\nObject user=  context.getBean(\"user\"); // 获取spring容器中的对象\n</code></pre>\n<p>ApplicationContext的超级父接口是BeanFactory。</p>\n<p>BeanFactory是Ioc容器的顶级接口。</p>\n<p>spring的Ioc容器底层使用了工厂模式。</p>\n<h1 id=\"启用log4j2\">启用Log4j2</h1>\n<p>spring5之后支持Log4j2框架。</p>\n<ol>\n<li>引入依赖</li>\n</ol>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;\n    &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt;\n    &lt;version&gt;2.19.0&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;\n    &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;\n    &lt;version&gt;2.19.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<ol>\n<li>编写配置文件，文件名必须是log4j2.xml，放在类根路径下</li>\n</ol>\n<pre><code class=\"language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n&lt;configuration&gt;\n\n    &lt;loggers&gt;\n        &lt;!--\n            level指定日志级别，从低到高的优先级：\n                ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF\n        --&gt;\n        &lt;root level=\"DEBUG\"&gt;\n            &lt;appender-ref ref=\"spring6log\"/&gt;\n        &lt;/root&gt;\n    &lt;/loggers&gt;\n\n    &lt;appenders&gt;\n        &lt;!--输出日志信息到控制台--&gt;\n        &lt;console name=\"spring6log\" target=\"SYSTEM_OUT\"&gt;\n            &lt;!--控制日志输出的格式--&gt;\n            &lt;PatternLayout pattern=\"%d{yyyy-MM-dd HH:mm:ss SSS} [%t] %-3level %logger{1024} - %msg%n\"/&gt;\n        &lt;/console&gt;\n    &lt;/appenders&gt;\n\n&lt;/configuration&gt;\n</code></pre>\n<ol>\n<li>使用日志框架 ，在SpringTest01类中使用如下代码</li>\n</ol>\n<pre><code class=\"language-java\">Logger logger = LoggerFactory.getLogger(SpringTest01.class);\nlogger.info(\"日志信息\");\n</code></pre>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/alineverstop/\" target=\"_blank\">NE_STOP</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/alineverstop/p/19563560\" target=\"_blank\">https://www.cnblogs.com/alineverstop/p/19563560</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-02 12:12</span>&nbsp;\n<a href=\"https://www.cnblogs.com/alineverstop\">NE_STOP</a>&nbsp;\n阅读(<span id=\"post_view_count\">8</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "天翼云全面上线Moltbot，通过云主机、AI云电脑、息壤应用托管一键开启AI助手体验！",
      "link": "https://www.cnblogs.com/developer-tianyiyun/p/19563414",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/developer-tianyiyun/p/19563414\" id=\"cb_post_title_url\" title=\"发布于 2026-02-02 11:41\">\n    <span>天翼云全面上线Moltbot，通过云主机、AI云电脑、息壤应用托管一键开启AI助手体验！</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p align=\"left\">在人工智能从技术演示走向规模化商业应用的关键时期，一个核心挑战是如何将极客圈层的创新转化为企业级可用的稳健生产力。近期，在海外开发者社区引发现象级关注的开源AI智能体Moltbot（原Clawdbot），展示了个人AI助理的全新可能性。</p>\n<p align=\"left\">近日，天翼云宣布全面上线Moltbot，为用户提供“7×24小时在线的AI助手”助力企业及个人低门槛、高效率地拥抱AI生产力。</p>\n<p align=\"left\">据悉，Moltbot此前在海外已积累超高人气，其在Github星数超6万，收藏数突破7200，搜索指数快速攀升并超越Claude Code，成为硅谷极客圈追捧的焦点工具，被不少开发者称为“能真正做事的AI”。不同于普通聊天机器人，Moltbot以“扎根工作流、主动解难题”为核心定位，可接入Claude、GPT系列等多种主流LLM，集各家技术之长，轻松集成于iMessage、QQ、飞书、钉钉等常用平台，实现随时随地调用。</p>\n<p>在天翼云平台，用户可通过多种方式便捷部署Moltbot，享受企业级的高可用保障与极简操作体验。无需Node.js、Docker知识，也无需操心服务器运维，天翼云提供坚实的算力底座，确保云端服务稳定可靠、算力弹性扩展，实现持续响应，不掉线。支持按需付费模式，用户仅为实际消耗的资源买单，无需预先投入硬件成本，极大降低了使用门槛与资源浪费。</p>\n<p align=\"center\"><img alt=\"\" class=\"lazyload\" />&nbsp;</p>\n<p><strong>配置完成后，用户还可尝试其他场景，解锁更多玩法。</strong>例如<strong>搜索桌面内文件并总结，实现高效办公：</strong>Moltbot可遍历云电脑内相关文件，高效输出包含文件名称、类型、核心摘要、关键数据的结构化总结内容，无需用户再一个个找文件，快速掌握文件核心信息。</p>\n<p align=\"left\">&nbsp;<img alt=\"\" class=\"lazyload\" /></p>\n<p>Moltbot还可以自动打开浏览器访问淘宝、搜索关键词，过滤广告和无货商品，最终输出包含商品名称、售价、店铺、链接的列表，方便用户快速选择，实现智能购物。</p>\n<p align=\"left\">&nbsp;<img alt=\"\" class=\"lazyload\" /></p>\n<p>依托云基础设施的坚实底座，Moltbot全方位赋能办公全场景：7×24小时弹性云主机保障AI助手永不离线，Moltbot天翼AI云电脑将云端AI能力融入工作流，微信、WPS、飞书、钉钉、QQ等常用办公软件一键导入、无缝衔接，零部署零学习，智能办公高效直达，让效率时刻在线。</p>\n<p>随着类似Moltbot等开源项目与云服务的深度结合，以及国内厂商推出更多“本土化、安全可控”的企业级Agent产品，AI正加速转变为各行各业触手可及的新质生产力。天翼云此次集成Moltbot，正是云厂商作为AI应用“助推器”与“稳定器”角色的一次具体实践，为AI智能体的规模化、规范化应用提供了新的范本。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-02 11:41</span>&nbsp;\n<a href=\"https://www.cnblogs.com/developer-tianyiyun\">天翼云开发者社区</a>&nbsp;\n阅读(<span id=\"post_view_count\">22</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "揭开 C#中的异步/等待：隐藏状态机",
      "link": "https://www.cnblogs.com/powertoolsteam/p/19563347",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/powertoolsteam/p/19563347\" id=\"cb_post_title_url\" title=\"发布于 2026-02-02 11:28\">\n    <span>揭开 C#中的异步/等待：隐藏状态机</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"引言\">引言</h2>\n<p>作为.NET开发者，我们每天都在使用async和await关键字来编写异步代码。这些关键字让异步代码看起来像同步代码一样直观易读，同时避免了回调地狱的问题。但你是否好奇过，当C#编译器遇到async方法时，底层究竟发生了什么魔法？本文将基于微软官方文档，深入剖析async/await背后的秘密——编译器生成的状态机机制。</p>\n<h2 id=\"正文\">正文</h2>\n<h3 id=\"异步等待解决了什么问题\">异步/等待解决了什么问题？</h3>\n<p>在传统同步I/O操作中（如文件读取或Web API调用），调用线程会被阻塞直到操作完成。这在UI应用中会导致界面冻结，在服务器应用中则造成线程资源的浪费。async/await通过非阻塞的异步操作解决了这些问题，同时保持了代码的线性结构和可读性。</p>\n<h3 id=\"编译器的转换从方法到状态机\">编译器的转换：从方法到状态机</h3>\n<p>当你用async标记一个方法时，C#编译器并不会直接执行你的代码。相反，它会将该方法重写为一个状态机结构体。这个结构体实现了IAsyncStateMachine接口，包含以下关键部分：</p>\n<ul>\n<li>当前状态（整数，表示执行暂停的位置）</li>\n<li>捕获的局部变量和参数（提升为字段以便在await之间保持状态）</li>\n<li>方法构建器（如AsyncTaskMethodBuilder用于Task返回）</li>\n</ul>\n<p>原始方法被转换为一个存根(stub)方法：它在栈上创建状态机实例，初始化并启动它。而你的主要代码逻辑则被移动到状态机的MoveNext()方法中，通过状态值和switch语句实现执行点的跳转。</p>\n<p>特别重要的是：如果异步方法同步完成（所有等待的操作已经完成），状态机将保留在栈上，不会发生堆分配。只有当真正的await暂停执行时，结构体才会被装箱到堆中。</p>\n<h3 id=\"一个简单示例\">一个简单示例</h3>\n<p>考虑以下异步方法：</p>\n<pre><code class=\"language-csharp\">public async Task&lt;int&gt; DownloadDataAsync(string url)\n{\n    using var client = new HttpClient();\n    string data = await client.GetStringAsync(url);\n    return data.Length;\n}\n</code></pre>\n<p>在编译时，编译器会将该方法重写为状态机结构体，并生成一个存根方法替换原始方法签名。方法体被拆分并移入状态机的MoveNext()方法中，按状态组织。</p>\n<p>运行时调用流程：</p>\n<ol>\n<li>生成的存根创建状态机实例（初始在栈上）</li>\n<li>初始化状态机（状态设为-1，捕获必要参数/局部变量）</li>\n<li>调用MoveNext()开始执行</li>\n</ol>\n<p>在MoveNext()内部：</p>\n<ul>\n<li>执行从当前状态开始，直到遇到await</li>\n<li>如果等待的任务已完成，继续同步执行（快速路径，无堆分配）</li>\n<li>如果任务未完成，注册继续回调，立即返回控制（非阻塞），并暂停执行</li>\n<li>任务完成后，继续回调会再次调用MoveNext()，从await点恢复执行</li>\n</ul>\n<h3 id=\"编译器生成的状态机\">编译器生成的状态机</h3>\n<p>以下是编译器生成的状态机简化伪代码（基于Release模式下的反编译结果）：</p>\n<pre><code class=\"language-csharp\">private struct &lt;DownloadDataAsync&gt;d__1 : IAsyncStateMachine\n{\n    public int &lt;&gt;1__state;                      // 状态：-1=开始，0=等待中，-2=完成\n    public AsyncTaskMethodBuilder&lt;int&gt; &lt;&gt;t__builder;\n    public string url;                          // 捕获的参数\n    private string &lt;data&gt;5__2;                  // 提升的局部变量\n    private HttpClient &lt;client&gt;5__3;            // using变量也被提升\n\n    private void MoveNext()\n    {\n        int num = this.&lt;&gt;1__state;\n        try\n        {\n            if (num == -1)                          // 初始执行\n            {\n                this.&lt;client&gt;5__3 = new HttpClient();\n                Task&lt;string&gt; getTask = this.&lt;client&gt;5__3.GetStringAsync(this.url);\n\n                var awaiter = getTask.GetAwaiter();\n                if (!awaiter.IsCompleted)\n                {\n                    this.&lt;&gt;1__state = 0;            // 标记为等待中\n                    this.&lt;&gt;t__builder.AwaitUnsafeOnCompleted(ref awaiter, ref this);\n                    return;                         // 在此暂停 - 继续回调稍后调用MoveNext\n                }\n\n                // 已完成时的快速路径\n                this.&lt;data&gt;5__2 = awaiter.GetResult();\n            }\n            else                                    // num == 0 → await后恢复\n            {\n                this.&lt;data&gt;5__2 = /* awaiter.GetResult()逻辑 */;\n            }\n\n            // await之后的代码\n            int result = this.&lt;data&gt;5__2.Length;\n\n            // 清理\n            this.&lt;client&gt;5__3?.Dispose();\n\n            // 设置最终结果\n            this.&lt;&gt;1__state = -2;\n            this.&lt;&gt;t__builder.SetResult(result);\n        }\n        catch (Exception exception)\n        {\n            this.&lt;&gt;1__state = -2;\n            this.&lt;&gt;t__builder.SetException(exception);\n        }\n    }\n\n    void IAsyncStateMachine.MoveNext() =&gt; MoveNext();\n    // SetStateMachine(...)为简洁省略\n}\n</code></pre>\n<p>原始方法被转换为类似这样的存根：</p>\n<pre><code class=\"language-csharp\">public Task&lt;int&gt; DownloadDataAsync(string url)\n{\n    var stateMachine = new &lt;DownloadDataAsync&gt;d__1();\n    stateMachine.&lt;&gt;t__builder = AsyncTaskMethodBuilder&lt;int&gt;.Create();\n    stateMachine.url = url;\n    stateMachine.&lt;&gt;1__state = -1;\n    stateMachine.&lt;&gt;t__builder.Start(ref stateMachine);\n    return stateMachine.&lt;&gt;t__builder.Task;\n}\n</code></pre>\n<h3 id=\"理解状态机的重要性\">理解状态机的重要性</h3>\n<p>理解状态机的工作机制有助于我们：</p>\n<ol>\n<li>认识同步完成时的零分配快速路径</li>\n<li>理解为什么局部变量需要被捕获（它们成为结构体的字段以便在暂停和恢复状态时使用）</li>\n<li>掌握正确的性能特征（当操作正确时开销最小）</li>\n</ol>\n<p>正如微软文档所述：\"编译器会把你的程序转化为状态机。该构造会追踪代码中的各种操作和状态，比如当代码达到等待表达式时放弃执行，以及在后台作业完成时恢复执行。\"</p>\n<h2 id=\"结论\">结论</h2>\n<p>async/await不仅仅是让异步代码更简洁的语法糖，其背后是编译器将顺序逻辑转换为高效状态机的复杂过程。通过深入理解这一机制，我们可以：</p>\n<ul>\n<li>编写更高效的异步代码</li>\n<li>避免常见的性能陷阱</li>\n<li>更好地调试异步程序</li>\n</ul>\n<p>下次使用async/await时，请记住：你正在利用C#编译器的强大魔法，将看似简单的顺序代码转换为高效的状态机实现。这种理解将帮助你成为更优秀的.NET开发者。</p>\n\n\n</div>\n<div id=\"MySignature\">\n    <hr />\n<br />\n<p>本文是由葡萄城技术开发团队发布，转载请注明出处：<a href=\"https://www.grapecity.com.cn/\" target=\"_blank\">葡萄城官网</a></p>\n<!--p style=\"font-size: 16px; font-family: 微软雅黑, 黑体, Arial; color: #000\">了解企业级低代码开发平台，请前往<a href=\"https://www.grapecity.com.cn/solutions/huozige\" target=\"_blank\">活字格</a>\n</p><p style=\"font-size: 16px; font-family: 微软雅黑, 黑体, Arial; color: #000\">了解可嵌入您系统的在线 Excel，请前往<a href=\"https://www.grapecity.com.cn/developer/spreadjs\" target=\"_blank\">SpreadJS纯前端表格控件</a></p>\n<p style=\"font-size: 16px; font-family: 微软雅黑, 黑体, Arial; color: #000\">了解嵌入式的商业智能和报表软件，请前往<a href=\"https://www.grapecity.com.cn/solutions/wyn\" target=\"_blank\">Wyn Enterprise\n</a></p-->\n\n<br />\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-02 11:28</span>&nbsp;\n<a href=\"https://www.cnblogs.com/powertoolsteam\">葡萄城技术团队</a>&nbsp;\n阅读(<span id=\"post_view_count\">39</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "在 Cloudflare 平台上构建垂直微前端",
      "link": "https://www.cnblogs.com/didispace/p/19563285",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/didispace/p/19563285\" id=\"cb_post_title_url\" title=\"发布于 2026-02-02 11:21\">\n    <span>在 Cloudflare 平台上构建垂直微前端</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>想象一下，你正在开发一个大型Web应用。营销团队想要用Astro构建他们的页面以获得最佳的SEO效果，而产品团队却坚持要用React来构建功能丰富的后台管理系统。更糟糕的是，每次发布新版本时，十几个团队的代码都需要一起打包、一起测试、一起上线——只要其中一个团队引入了一个bug，整个发布就要回滚。这种\"一荣俱荣、一损俱损\"的耦合方式，是不是让你感到无比头疼？</p>\n<p>或者，你的公司刚刚收购了一个创业公司，他们的产品是用Vue写的，而你们的主站是用React写的。你想把他们的功能整合进来，但又不希望把两个完全不同的代码库强行混在一起。</p>\n<p>这些都是现代Web开发中真实存在的难题。传统的微前端架构通常是\"水平\"的——同一个页面上的不同组件来自不同的服务。但如果有一种方式，能让每个团队完全独立地开发、部署和维护自己的功能模块，而用户却感觉在使用一个无缝的、统一的应用呢？</p>\n<p>这就是垂直微前端（Vertical Microfrontends）要解决的问题。现在，Cloudflare推出了一款全新的Worker模板，让这种架构变得前所未有的简单。</p>\n<h2 id=\"什么是垂直微前端\">什么是垂直微前端？</h2>\n<p>垂直微前端是一种架构模式，单个独立团队拥有应用程序功能的完整切片，从用户界面一直到底层的CI/CD流水线。这些切片通过域名上的路径来定义，你可以将各个独立的Worker与特定路径关联起来：</p>\n<pre><code class=\"language-text\">/      = 营销网站\n/docs  = 文档\n/blog  = 博客\n/dash  = 仪表盘\n</code></pre>\n<p>我们还可以进一步细化，在更细粒度的子路径上关联不同的Worker。比如在仪表盘中，你可能通过各种功能或产品来划分URL路径的深度（例如 <code>/dash/product-a</code>），在两个产品之间导航可能意味着两个完全不同的代码库。</p>\n<p>现在有了垂直微前端，我们还可以这样设计：</p>\n<pre><code class=\"language-text\">/dash/product-a  = WorkerA\n/dash/product-b  = WorkerB\n</code></pre>\n<p>上面的每个路径都是独立的前端项目，它们之间没有任何共享代码。<code>product-a</code> 和 <code>product-b</code> 路由映射到分别部署的前端应用，它们有自己的框架、库、CI/CD流水线，由各自的团队定义和拥有。</p>\n<p>你可以端到端地拥有自己的代码。但现在我们需要找到一种方法将这些独立的项目缝合在一起，更重要的是，让它们感觉像是一个统一的体验。</p>\n<p>Cloudflare自己也在经历这个痛点，因为仪表盘有许多独立的团队负责各自的产品。团队必须面对一个事实：在他们控制范围之外所做的更改会影响用户对其产品的体验。</p>\n<p>在内部，我们现在对自己的仪表盘也采用了类似的策略。当用户从核心仪表盘导航到我们的ZeroTrust产品时，实际上它们是两个完全独立的项目，用户只是通过路径 <code>/:accountId/one</code> 被路由到那个项目。</p>\n<h2 id=\"视觉上的统一体验\">视觉上的统一体验</h2>\n<p>将这些独立项目缝合在一起，让它们感觉像一个统一的体验，并没有你想象的那么困难：只需要几行CSS魔法。我们绝对不希望发生的事情是将我们的实现细节和内部决策泄露给用户。如果我们无法让这个用户体验感觉像一个统一的前端，那我们就对用户犯下了严重的错误。</p>\n<p>要实现这种巧妙的手法，让我们先了解一下视图过渡和文档预加载是如何发挥作用的。</p>\n<h3 id=\"视图过渡\">视图过渡</h3>\n<p>当我们想要在两个不同页面之间无缝导航，同时让最终用户感觉流畅时，视图过渡非常有用。在页面上定义特定的DOM元素，让它们一直保留到下一页可见，并定义任何变化的处理方式，这成为了多页应用的强大缝合工具。</p>\n<p>然而，在某些情况下，让各个垂直微前端感觉不同也是完全可以接受的。比如我们的营销网站、文档和仪表盘，它们各自都有独特的定义。用户不会期望这三者在导航时都感觉统一。但是……如果你决定在单个体验中引入垂直切片（例如 <code>/dash/product-a</code> 和 <code>/dash/product-b</code>），那么用户绝对不应该知道它们底层是两个不同的仓库/Worker/项目。</p>\n<p>好了，说得够多了——让我们开始动手吧。我说过让两个独立的项目对用户来说感觉像是一个是低成本的，如果你还没有听说过CSS视图过渡，那么接下来我要让你大开眼界了。</p>\n<p>如果我告诉你，你可以在单页应用（SPA）或多页应用（MPA）的不同视图之间创建动画过渡，让它们感觉像是一个整体？在添加任何视图过渡之前，如果我们导航属于两个不同Worker的页面，中间加载状态会是浏览器中的白色空白屏幕，持续几百毫秒，直到下一页开始渲染。页面不会感觉统一，当然也不会像单页应用。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>如果希望元素保留，而不是看到白色空白页，我们可以通过定义CSS视图过渡来实现。通过下面的代码，我们告诉当前文档页面，当视图过渡事件即将发生时，将<code>nav</code> DOM元素保留在屏幕上，如果现有页面和目标页面之间存在任何外观差异，我们将使用<code>ease-in-out</code>过渡来动画展示。</p>\n<p>突然之间，两个不同的Worker感觉就像一个了。</p>\n<pre><code class=\"language-css\">@supports (view-transition-name: none) {\n  ::view-transition-old(root),\n  ::view-transition-new(root) {\n    animation-duration: 0.3s;\n    animation-timing-function: ease-in-out;\n  }\n  nav { view-transition-name: navigation; }\n}\n</code></pre>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"预加载\">预加载</h3>\n<p>在两个页面之间过渡让它\"看起来\"无缝——我们还希望它\"感觉\"像客户端SPA一样即时。虽然目前Firefox和Safari不支持Speculation Rules，但Chrome/Edge/Opera确实支持这个较新的API。Speculation Rules API旨在提高未来导航的性能，特别是对于文档URL，让多页应用感觉更像单页应用。</p>\n<p>分解成代码，我们需要定义一个特定格式的脚本规则，告诉支持的浏览器如何预取与我们Web应用程序连接的其他垂直切片——可能通过某些共享导航链接。</p>\n<pre><code class=\"language-html\">&lt;script type=\"speculationrules\"&gt;\n  {\n    \"prefetch\": [\n      {\n        \"urls\": [\"https://product-a.com\", \"https://product-b.com\"],\n        \"requires\": [\"anonymous-client-ip-when-cross-origin\"],\n        \"referrer_policy\": \"no-referrer\"\n      }\n    ]\n  }\n&lt;/script&gt;\n</code></pre>\n<p>有了这些，我们的应用程序会预取其他微前端并将它们保留在内存缓存中，所以如果我们导航到那些页面，会感觉几乎是即时的。</p>\n<p>对于明显可区分的垂直切片（营销、文档、仪表盘），你可能不需要这样做，因为用户在它们之间导航时会预期有轻微的加载。然而，当垂直切片定义在特定可见体验内时（例如在仪表盘页面中），强烈建议使用。</p>\n<p>通过视图过渡和推测规则，我们能够将完全不同的代码仓库联系在一起，感觉就像它们来自单页应用一样。如果你问我，这太神奇了。</p>\n<h2 id=\"零配置请求路由\">零配置请求路由</h2>\n<p>现在我们需要一种机制来托管多个应用程序，以及一种在请求流入时将它们缝合在一起的方法。定义一个Cloudflare Worker作为\"路由器\"，允许在边缘的单个逻辑点处理网络请求，然后将它们转发给负责该URL路径的垂直微前端。而且我们可以将单个域名映射到该路由器Worker，其余的就\"正常工作\"了。</p>\n<h3 id=\"服务绑定\">服务绑定</h3>\n<p>如果你还没有探索过Cloudflare Worker服务绑定，那么值得花点时间了解一下。</p>\n<p>服务绑定允许一个Worker调用另一个Worker，而无需经过公开可访问的URL。服务绑定允许Worker A调用Worker B上的方法，或将请求从Worker A转发到Worker。进一步分解，路由器Worker可以调用已定义的每个垂直微前端Worker（例如营销、文档、仪表盘），假设它们都是Cloudflare Workers。</p>\n<p>这为什么重要？这正是将这些垂直切片\"缝合\"在一起的机制。我们将在下一节深入探讨请求路由如何处理流量分割。但要定义这些微前端中的每一个，我们需要更新路由器Worker的wrangler定义，这样它就知道允许调用哪些前端。</p>\n<pre><code class=\"language-json\">{\n  \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n  \"name\": \"router\",\n  \"main\": \"./src/router.js\",\n  \"services\": [\n    {\n      \"binding\": \"HOME\",\n      \"service\": \"worker_marketing\"\n    },\n    {\n      \"binding\": \"DOCS\",\n      \"service\": \"worker_docs\"\n    },\n    {\n      \"binding\": \"DASH\",\n      \"service\": \"worker_dash\"\n    }\n  ]\n}\n</code></pre>\n<p>上面的示例定义在我们的路由器Worker中，然后告诉我们被允许向三个独立的额外Worker（营销、文档和仪表盘）发出请求。授予权限就这么简单，但让我们深入研究一些更复杂的逻辑，包括请求路由和HTML重写网络响应。</p>\n<h3 id=\"请求路由\">请求路由</h3>\n<p>了解了在需要时可以调用的各种其他Worker之后，现在我们需要一些逻辑来确定何时将网络请求定向到哪里。由于路由器Worker被分配到我们的自定义域名，所有传入的请求首先在网络边缘到达它。然后它确定哪个Worker应该处理请求，并管理结果响应。</p>\n<p>第一步是将URL路径映射到关联的Worker。当收到某个请求URL时，我们需要知道它需要被转发到哪里。我们通过定义规则来实现这一点。虽然我们支持通配符路由、动态路径和参数约束，但我们将专注于基础——字面路径前缀——因为它更清楚地说明了要点。</p>\n<p>在这个例子中，我们有三个微前端：</p>\n<pre><code class=\"language-text\">/      = 营销\n/docs  = 文档\n/dash  = 仪表盘\n</code></pre>\n<p>上面的每个路径都需要映射到一个实际的Worker（参见上面章节中的wrangler服务定义）。对于我们的路由器Worker，我们定义一个额外的变量，包含以下数据，这样我们就知道哪些路径应该映射到哪些服务绑定。现在我们知道当请求进来时应该将用户路由到哪里！定义一个名为ROUTES的wrangler变量，内容如下：</p>\n<pre><code class=\"language-json\">{\n  \"routes\": [\n    {\"binding\": \"HOME\", \"path\": \"/\"},\n    {\"binding\": \"DOCS\", \"path\": \"/docs\"},\n    {\"binding\": \"DASH\", \"path\": \"/dash\"}\n  ]\n}\n</code></pre>\n<p>让我们设想一个用户访问我们网站的路径 <code>/docs/installation</code>。在底层，发生的情况是请求首先到达我们的路由器Worker，它负责了解什么URL路径映射到哪个独立的Worker。它理解 <code>/docs</code> 路径前缀映射到我们的 <code>DOCS</code> 服务绑定，参照我们的wrangler文件指向我们的 <code>worker_docs</code> 项目。我们的路由器Worker知道 <code>/docs</code> 被定义为垂直微前端路由，从路径中移除 <code>/docs</code> 前缀，将请求转发给我们的 <code>worker_docs</code> Worker来处理请求，然后最终返回我们得到的任何响应。</p>\n<p>为什么要删除 <code>/docs</code> 路径呢？这是一个实现细节的选择，目的是当Worker通过路由器Worker访问时，它可以清理URL来处理请求，就像它是从路由器Worker外部调用的一样。像任何Cloudflare Worker一样，我们的 <code>worker_docs</code> 服务可能有自己的独立URL可以访问。我们决定希望该服务URL继续独立工作。当它附加到我们的新路由器Worker时，它会自动处理移除前缀，这样服务就可以从自己定义的URL或通过我们的路由器Worker访问……任何地方都可以，无所谓。</p>\n<h3 id=\"htmlrewriter\">HTMLRewriter</h3>\n<p>用URL路径分割我们的各种前端服务（例如 <code>/docs</code> 或 <code>/dash</code>）让我们很容易转发请求，但当我们的响应包含不知道它被通过路径组件反向代理的HTML时……嗯，这就会出问题。</p>\n<p>假设我们的文档网站在响应中有一个图片标签 <code>&lt;img src=\"./logo.png\" /&gt;</code>。如果我们的用户正在访问页面 <code>https://website.com/docs/</code>，那么加载 <code>logo.png</code> 文件可能会失败，因为我们的 <code>/docs</code> 路径只是由我们的路由器Worker人为定义的。</p>\n<p>只有当我们的服务通过路由器Worker访问时，我们才需要对一些绝对路径进行HTML重写，这样我们返回的浏览器响应才能引用有效的资源。实际上发生的是，当请求通过我们的路由器Worker时，我们将请求传递给正确的服务绑定，并从中接收响应。在将其传回客户端之前，我们有机会重写DOM——所以在看到绝对路径的地方，我们继续用代理路径预先填充它。以前我们的HTML返回的图片标签是 <code>&lt;img src=\"./logo.png\" /&gt;</code>，现在我们修改为在返回客户端浏览器之前 <code>&lt;img src=\"./docs/logo.png\" /&gt;</code>。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>让我们回到CSS视图过渡和文档预加载的魔法。我们当然可以把那段代码手动放到我们的项目中并让它工作，但这个路由器Worker也会使用HTMLRewriter自动为我们处理这些逻辑。</p>\n<p>在你的路由器Worker <code>ROUTES</code> 变量中，如果你在根级别设置 <code>smoothTransitions</code> 为 <code>true</code>，那么CSS过渡视图代码会自动添加。此外，如果你在路由中设置 <code>preload</code> 键为 <code>true</code>，那么该路由的推测规则脚本代码也会自动添加。</p>\n<p>下面是两者结合使用的示例：</p>\n<pre><code class=\"language-json\">{\n  \"smoothTransitions\": true,\n  \"routes\": [\n    {\"binding\": \"APP1\", \"path\": \"/app1\", \"preload\": true},\n    {\"binding\": \"APP2\", \"path\": \"/app2\", \"preload\": true}\n  ]\n}\n</code></pre>\n<h2 id=\"开始使用\">开始使用</h2>\n<p>你今天就可以开始使用垂直微前端模板构建了。</p>\n<p>访问Cloudflare仪表盘的链接，或者进入\"Workers &amp; Pages\"并点击\"创建应用程序\"按钮开始。从那里，点击\"选择模板\"然后\"创建微前端\"，你就可以开始配置你的设置了。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>更多使用指南，可以点击<a href=\"https://developers.cloudflare.com/workers/framework-guides/web-apps/microfrontends\" rel=\"noopener nofollow\" target=\"_blank\">查看文档</a> ，如果您对各种云原生架构的内容感兴趣，也可以<a href=\"https://didispace.com\" rel=\"noopener nofollow\" target=\"_blank\">关注我的博客：程序猿DD</a>，第一时间获得干货更新。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-02 11:21</span>&nbsp;\n<a href=\"https://www.cnblogs.com/didispace\">程序猿DD</a>&nbsp;\n阅读(<span id=\"post_view_count\">23</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "AI开发-python-langchain框架（1-8-2 缓存机制——验证缓存的效果）",
      "link": "https://www.cnblogs.com/yclh/p/19563034",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yclh/p/19563034\" id=\"cb_post_title_url\" title=\"发布于 2026-02-02 10:51\">\n    <span>AI开发-python-langchain框架（1-8-2 缓存机制——验证缓存的效果）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>　　在AI应用中，缓存机制的经济价值不仅节省Token成本，还能消除用户等待焦虑、提升系统吞吐量、保障服务稳定性——这才是企业级应用的真正痛点。<br />　　当用户提出一个常见问题时，首次调用大模型需要经历网络传输、排队等待、模型推理等完整链路，响应时间通常在1至3秒。这个时长已超过人类对“流畅交互”的心理阈值（200毫秒），用户会明显感知到“卡顿”和“等待焦虑”。而启用缓存后，相同问题的后续请求直接从本地数据库读取结果，响应时间骤降至10毫秒以内——这种“无感秒回”的体验，让用户感觉系统始终在线、反应迅捷，极大提升了产品专业度和信任感。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;下面看看这段代码，就能清晰的体现使用缓存后能提升的用户体验。（同一个问题问大模型三次，第一次没有缓存，后两次有缓存）</p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:python;gutter:true;\">import os\nimport time\nfrom langchain_community.cache import SQLiteCache\nfrom langchain_openai import ChatOpenAI\nfrom langchain.globals import set_llm_cache, get_llm_cache\n\n# ========== 1. 清理旧缓存（确保演示纯净）==========\nCACHE_DB = \"langchain_demo.db\"\nif os.path.exists(CACHE_DB):\n    os.remove(CACHE_DB)\n    print(f\" 已清理旧缓存: {CACHE_DB}\")\n\n# ========== 2. 启用缓存 ==========\nset_llm_cache(SQLiteCache(database_path=CACHE_DB))\nprint(f\" 缓存已启用: {get_llm_cache()}\\n\")\n\n# ========== 3. 配置 LLM ==========\nllm = ChatOpenAI(\n    api_key=os.getenv(\"DEEPSEEK_API_KEY\"),\n    base_url=os.getenv(\"DEEP_URL\"),  # Deepseek 的 API 基础地址\n    model=\"deepseek-v3:671b\",  # Deepseek 对话模型（可选：deepseek-chat-pro 等高级模型）\n    temperature=0.7,  # 温度参数（0-1，越低越稳定）\n    max_tokens=1024  # 最大生成 tokens\n)\n\n\n# ========== 4. 核心演示函数 ==========\ndef demonstrate_cache_effect(query: str, repeat: int = 3):\n    \"\"\"\n    演示缓存效果：首次调用（慢） vs 后续调用（快）\n\n    Args:\n        query: 要提问的问题\n        repeat: 重复调用次数（第1次未缓存，后续应命中缓存）\n    \"\"\"\n    print(\"=\" * 60)\n    print(f\" 测试问题: \\\"{query}\\\"\")\n    print(f\" 将重复调用 {repeat} 次（第1次无缓存，后续应命中缓存）\")\n    print(\"=\" * 60 + \"\\n\")\n\n    durations = []\n\n    for i in range(repeat):\n        print(f\"\\n[第 {i + 1} 次调用]\")\n        start = time.perf_counter()  # 高精度计时\n\n        # 关键：使用完全相同的输入触发缓存\n        response = llm.invoke(query)\n\n        duration = (time.perf_counter() - start) * 1000  # 转为毫秒\n        durations.append(duration)\n\n        # 判断是否命中缓存（通过耗时阈值粗略判断）\n        is_cached = i &gt; 0   # 首次通常 &gt;500ms，缓存通常 &lt;50ms\n\n        if i &gt; 0:\n            print('缓存命中,耗时：'+str(duration))\n        else:\n            print('真实请求,耗时：'+str(duration))\n        print(f\" 回答: {response.content[:60]}...\")\n\n\n\n# ========== 5. 执行演示 ==========\nif __name__ == \"__main__\":\n    # 测试标准问题（确保完全相同的字符串）\n    demonstrate_cache_effect(\"太阳系哪个行星最大？\", repeat=3)\n</pre>\n</div>\n<p>&nbsp;运行结果：</p>\n<p>&nbsp;<br />&nbsp;已清理旧缓存: langchain_demo.db<br />&nbsp;缓存已启用: &lt;langchain_community.cache.SQLiteCache object at 0x000001D668B50410&gt;<br /><br />============================================================<br />&nbsp;测试问题: \"太阳系哪个行星最大？\"<br />&nbsp;将重复调用 3 次（第1次无缓存，后续应命中缓存）<br />============================================================<br /><br /><br />[第 1 次调用]<br />真实请求,耗时：17445.118000000093<br />&nbsp;回答: 太阳系中最大的行星是**木星**。以下是关于木星的一些关键信息：<br /><br />### 木星的基本特征：<br />1. **体积与质量** ...<br /><br />[第 2 次调用]<br />缓存命中,耗时：410.93799999998737<br />&nbsp;回答: 太阳系中最大的行星是**木星**。以下是关于木星的一些关键信息：<br /><br />### 木星的基本特征：<br />1. **体积与质量** ...<br /><br />[第 3 次调用]<br />缓存命中,耗时：1.475199999731558<br />&nbsp;回答: 太阳系中最大的行星是**木星**。以下是关于木星的一些关键信息：<br /><br />### 木星的基本特征：<br />1. **体积与质量** ...<br /><br />&nbsp;<br />结论：从时间消耗上看，缓存命中几何倍数的缩短了用户等待时间，提升了用户的使用体验。</p>\n<p>&nbsp;</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-02 10:51</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yclh\">万笑佛</a>&nbsp;\n阅读(<span id=\"post_view_count\">7</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "FastAPI部署中间件实战：从CORS到自定义，让你的API更健壮",
      "link": "https://www.cnblogs.com/ymtianyu/p/19562887",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ymtianyu/p/19562887\" id=\"cb_post_title_url\" title=\"发布于 2026-02-02 10:32\">\n    <span>FastAPI部署中间件实战：从CORS到自定义，让你的API更健壮</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文深入浅出地讲解了FastAPI中间件的核心概念与实战应用。从解决最常见的CORS跨域问题入手，逐步演示如何编写自定义中间件（如日志记录），并重点剖析了多个中间件的执行顺序这一关键难点。同时，对比了HTTP中间件与ASGI中间件的区别与选用场景，最后分享了作者在实际开发中总结的踩坑经验与最佳实践，帮助你构建更健壮、易维护的Web应用。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><em>本文摘要：你是否为FastAPI应用的跨域请求（CORS）头疼过？或者想给所有请求统一加点“料”却不知从何下手？本文通过实战演示FastAPI中间件的使用，涵盖CORS处理、自定义中间件编写、多个中间件执行顺序等核心内容，帮你构建更安全、高效的Web应用。</em></p>\n<hr />\n<p>你的FastAPI应用在本地跑得风生水起，一部署上线，前端同学就火急火燎地找你：“老大，接口跨域了，报错！” 🚨</p>\n<p>或者，你突然接到需求：<strong style=\"color: rgba(186, 55, 42, 1);\">“所有请求都要记录日志，敏感接口还要额外校验一个自定义Header。”</strong> 难不成要给每个路由都加一遍代码？</p>\n<p>别慌，这就是今天要聊的“中间件”（Middleware）要解决的经典问题。它就像你API的“前厅经理”，所有请求和响应都得先经过它手，验身份、记日志、处理跨域……妥妥的。</p>\n<h2>🎯 一、中间件是啥？咱用“餐厅”打个比方</h2>\n<p>想象一下，你的FastAPI应用是个高级餐厅。</p>\n<div>\n<p>👉 顾客（客户端请求）来到门口。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;- <strong style=\"color: rgba(186, 55, 42, 1);\">迎宾（CORS中间件）</strong>：先看你是不是从允许的街区（域名）来的，不是就直接劝退（返回CORS错误）。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;- <strong style=\"color: rgba(186, 55, 42, 1);\">领位员（日志中间件）</strong>：记下顾客几点来的、几个人。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;- <strong style=\"color: rgba(186, 55, 42, 1);\">安检（认证中间件）</strong>：检查你有没有预约码（Token）。</p>\n<p>👉 之后，顾客才能见到<strong style=\"color: rgba(186, 55, 42, 1);\">真正的厨师（你的路径操作函数）</strong>点菜吃饭（处理业务逻辑）。</p>\n<p>👉 吃完离开时，还得经过<strong style=\"color: rgba(186, 55, 42, 1);\">传菜员（响应处理中间件）</strong>，可能给打包盒贴个标签（添加响应头）。</p>\n</div>\n<p>这一系列站在“核心业务”前后的服务人员，就是中间件。<strong style=\"color: rgba(186, 55, 42, 1);\">它的核心价值在于：全局处理、业务无侵入。</strong></p>\n<p>官方文档讲得比较散，咱们今天就把这块硬骨头啃透，直接上代码。</p>\n<h2>🔧 二、核心：怎么用？从最常用的CORS开始</h2>\n<p>好，咱们先来解决开头的“跨域”问题。这是99%的Web应用都会遇到的。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\n\napp = FastAPI()\n\n# 1. 配置允许的源、方法、请求头\norigins = [\n    \"http://localhost:3000\",  # 你的前端开发地址\n    \"https://your-production-site.com\",\n]\n\n# 2. 添加中间件\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=origins,  # 允许的源列表，也可以用 [\"*\"] 放行所有（不安全！）\n    allow_credentials=True, # 允许携带Cookie\n    allow_methods=[\"*\"],    # 允许所有方法 (GET, POST, 等)\n    allow_headers=[\"*\"],    # 允许所有请求头\n)\n\n@app.get(\"/\")\nasync def main():\n    return {\"message\": \"Hello World\"}</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">这里千万别学我当初偷懒，图省事直接上 `allow_origins=[\"*\"]`</strong>，这在生产环境是安全大忌，相当于餐厅大门敞开，谁都能进。线上务必明确指定前端域名！</p>\n<h2>🧪 三、动手：写一个自己的中间件</h2>\n<p>接下来重点来了，自定义中间件。比如，我们要给每个请求记日志，并计算处理耗时。</p>\n<pre class=\"language-python highlighter-hljs\"><code>import time\nfrom fastapi import FastAPI, Request\napp = FastAPI()\n\n@app.middleware(\"http\") # 这是关键装饰器\nasync def log_request_time(request: Request, call_next):\n    # 1. 请求进来时\n    # 这里我们使用 time.perf_counter() 而不是 time.time()，因为它对于这些用例可能更精确\n    start_time = time.perf_counter()\n    path = request.url.path\n    method = request.method\n    print(f\"👉 收到请求: {method} {path}\")\n\n    # 2. 把请求交给下一个处理环节（可能是其他中间件，或者是最终的路由）\n    response = await call_next(request)\n\n    # 3. 响应返回前\n    process_time = time.perf_counter() - start_time\n    response.headers[\"X-Process-Time\"] = str(process_time) # 可以往响应头加东西\n    print(f\"✅ 请求完成: {method} {path}, 耗时: {process_time:.4f}秒\")\n    return response\n\n@app.get(\"/test\")\nasync def test():\n    return {\"message\": \"ok\"}</code></pre>\n<p>访问 <code style=\"color: rgba(186, 55, 42, 1);\">/test</code>，看看控制台，是不是日志和响应头都有了？这就是一个最基础的HTTP中间件。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">划重点：</strong> 中间件函数接收一个 <code style=\"color: rgba(186, 55, 42, 1);\">call_next</code>，它就像接力棒，你必须调用它（<code style=\"color: rgba(186, 55, 42, 1);\">await call_next(request)</code>），请求才能继续往后走。你在它前面和后面写的代码，就分别对应了“请求处理”和“响应处理”两个阶段。</p>\n<h2>🔄 四、灵魂拷问：多个中间件，谁先谁后？</h2>\n<p>你是不是以为加完就完事了？<strong style=\"color: rgba(186, 55, 42, 1);\">多个中间件的执行顺序是超级易错点！</strong></p>\n<p>想象一下，你既加了CORS中间件，又加了上面的日志中间件，还加了一个认证中间件。它们怎么排队？</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">结论：按照添加的<span style=\"text-decoration: underline; font-size: 16px;\">相反顺序</span>执行“请求阶段”，再按照添加的<span style=\"text-decoration: underline; font-size: 16px;\">正序</span>执行“响应阶段”。</strong> 像洋葱一样，一层层进去，再一层层出来。</p>\n<pre class=\"language-python highlighter-hljs\"><code>app = FastAPI()\n\n# 假设我们按顺序添加三个中间件\napp.add_middleware(MiddlewareC) # 第三个添加\napp.add_middleware(MiddlewareB) # 第二个添加\napp.middleware(\"http\")(middleware_a) # 第一个添加（装饰器写法）\n\n# 实际执行顺序（请求阶段）：\n# 1. middleware_a 的请求处理代码\n# 2. MiddlewareB 的请求处理代码\n# 3. MiddlewareC 的请求处理代码\n# --- 到达路由函数 ---\n# 4. MiddlewareC 的响应处理代码\n# 5. MiddlewareB 的响应处理代码\n# 6. middleware_a 的响应处理代码\n# --- 响应返回给客户端 ---</code></pre>\n<p>官方文档虽然说了是“装饰器顺序”，但用 <code style=\"color: rgba(186, 55, 42, 1);\">app.add_middleware()</code> 添加时更容易迷糊。记不住就背下这个口诀：<strong style=\"color: rgba(186, 55, 42, 1);\">“后来居上（请求），原路返回（响应）”。</strong> 设计时，要把依赖关系想清楚，比如认证应该放在靠“里”层（后添加），日志可以放在最“外”层（先添加）。</p>\n<h2>🚀 五、进阶：更底层的ASGI中间件</h2>\n<p>再说个容易翻车的点。上面我们用 <code style=\"color: rgba(186, 55, 42, 1);\">@app.middleware(\"http\")</code> 叫HTTP中间件，是FastAPI封装好的。还有一种更底层、更强大的叫<strong style=\"color: rgba(186, 55, 42, 1);\">ASGI中间件</strong>。</p>\n<p>它和HTTP中间件啥区别？好比一个是高级餐厅的固定流程（HTTP），另一个是后厨的原子操作（ASGI），能处理WebSocket等更多协议。</p>\n<p>怎么用？通常你需要一个第三方库，比如 <code style=\"color: rgba(186, 55, 42, 1);\">starlette-context</code> 来在请求中传递全局数据，或者自己封装（FastAPI在<span style=\"color: rgba(186, 55, 42, 1);\"><code>fastapi.middleware</code></span>中提供了几个中间件，仅仅是为了方便开发者，但大多数可用的中间件直接来自Starlette）：</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import FastAPI\nfrom starlette.middleware.base import BaseHTTPMiddleware\n\nclass CustomHeaderMiddleware(BaseHTTPMiddleware):\n    async def dispatch(self, request, call_next):\n        response = await call_next(request)\n        response.headers[\"X-Custom-Header\"] = \"MyValue\"\n        return response\n\napp = FastAPI()\napp.add_middleware(CustomHeaderMiddleware) # 这里添加的就是ASGI中间件</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">注意：</strong> <code style=\"color: rgba(186, 55, 42, 1);\">BaseHTTPMiddleware</code> 使用简单，但官方提示可能有轻微性能损耗，因为每个请求都会创建新的类实例。对于超高并发场景，用之前的函数式 <code style=\"color: rgba(186, 55, 42, 1);\">@app.middleware(\"http\")</code> 或直接写纯ASGI中间件是更优解。</p>\n<h2>💎 六、我的踩坑经验与最佳实践</h2>\n<p>最后啰嗦几句，都是实战中总结的血泪教训：</p>\n<div>\n<p>1️⃣ <strong style=\"color: rgba(186, 55, 42, 1);\">响应式中间件要小心：</strong> 如果你想在中间件里读取响应的body，比如做全局响应体格式化，需要先把它读出来（<code style=\"color: rgba(186, 55, 42, 1);\">body = await response.body()</code>），但这会让响应体在内存中多存一份。对于大文件流响应，慎用！</p>\n<p>2️⃣ <strong style=\"color: rgba(186, 55, 42, 1);\">异常处理要覆盖：</strong> 中间件里的 <code style=\"color: rgba(186, 55, 42, 1);\">call_next</code> 可能会抛出异常，记得用 <code style=\"color: rgba(186, 55, 42, 1);\">try...except</code> 包住，并返回一个合理的错误响应，而不是让服务崩掉。</p>\n<p>3️⃣ <strong style=\"color: rgba(186, 55, 42, 1);\">区分中间件和依赖注入：</strong> 像认证这种，每个路由可能要求不同（有的需要登录，有的不需要），用依赖注入（<code style=\"color: rgba(186, 55, 42, 1);\">Depends</code>）更灵活。中间件更适合做<strong style=\"color: rgba(186, 55, 42, 1);\">全局的、无差异的</strong>处理，比如CORS、全局日志、GZip压缩。</p>\n</div>\n<p>工具的选择，好比选螺丝刀，不是最贵的就好，而是<strong style=\"color: rgba(186, 55, 42, 1);\">“合适”</strong>最好。对于大部分业务场景，HTTP中间件+依赖注入的组合，已经能解决99%的问题了。</p>\n<hr />\n<p>好了，关于FastAPI中间件的实战经验，今天就先聊到这。中间件就像你应用的“基础设施”，搭建好了，后面写业务代码才能安心、省心。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">老规矩，代码片段都跑过，放心参考。</strong> 如果你在配置中间件时还遇到了其他妖魔鬼怪，欢迎留言，咱们一起降妖除魔。</p>\n<p>觉得有用的话，<strong style=\"color: rgba(186, 55, 42, 1);\">点赞、收藏、关注</strong>三连一下呗？你的支持是我熬夜写干货的最大动力。下期咱们可以聊聊FastAPI的依赖注入怎么玩出花，或者部署上线的那些坑。回见！👩💻</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-02 10:32</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ymtianyu\">一名程序媛呀</a>&nbsp;\n阅读(<span id=\"post_view_count\">17</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}