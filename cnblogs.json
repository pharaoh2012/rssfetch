{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "数据不够代码凑？用 Albumentations 让你的 AI 模型“看”得更广，训练快 10 倍！",
      "link": "https://www.cnblogs.com/swizard/p/19410908",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/swizard/p/19410908\" id=\"cb_post_title_url\" title=\"发布于 2025-12-28 09:16\">\n    <span>数据不够代码凑？用 Albumentations 让你的 AI 模型“看”得更广，训练快 10 倍！</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h3>引言：贫穷限制了我的数据集，但不能限制我的模型</h3>\n<p>作为一名 CV 算法工程师，你一定经历过这种绝望： 老板丢给你 100 张产品瑕疵照片，让你训练一个准确率 99% 的检测模型。 你看着那少得可怜的数据，内心在咆哮：“这肯定会过拟合（Overfitting）啊！模型根本学不到特征，只会死记硬背！”</p>\n<p>去采集更多数据？成本太高，周期太长。 自己写代码用 OpenCV 做旋转、裁剪？处理完图片还得手动算坐标变换（Bounding Box），稍微搞错一点，训练数据就变成了“垃圾数据”。</p>\n<p><strong>这就是 Albumentations 登场的时刻。</strong></p>\n<p>它不仅能帮你把 100 张图片“变”成 10000 张，还能自动处理最让人头疼的<strong>坐标映射</strong>和<strong>掩膜（Mask）对齐</strong>问题。最重要的是，它基于高度优化的 OpenCV 和 SIMD 指令集，速度快到飞起。</p>\n<hr />\n<h3>&nbsp;概念拆解：给模型来一场“魔鬼特训”</h3>\n<h4>1. 生活化类比：驾校练车</h4>\n<p>想象一下你在考驾照。 如果你的教练只让你在<strong>晴天、平坦、无人的直路</strong>上练习，你练得再熟，一旦考试那天<strong>下雨、路面有坑、或者光线刺眼</strong>，你立马就会挂科。</p>\n<p><strong>深度学习模型的训练也是一样的：</strong></p>\n<ul>\n<li>\n<p><strong>原始数据</strong>：就是那条“晴天直路”。</p>\n</li>\n<li>\n<p><strong>过拟合</strong>：你只会开晴天直路，换个环境就歇菜。</p>\n</li>\n<li>\n<p><strong>数据增强（Albumentations）</strong>：就是那个严厉的“魔鬼教练”。</p>\n<ul>\n<li>\n<p>它故意把图片变暗（模拟夜间）；</p>\n</li>\n<li>\n<p>故意把图片旋转（模拟摄像头歪了）；</p>\n</li>\n<li>\n<p>故意在图片上挖几个洞（模拟遮挡）。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>通过这种“折磨”，模型虽然在训练时更痛苦了，但它学会了<strong>本质特征</strong>（比如：车就是车，不管它是亮的还是暗的），而不是死记硬背像素点。</p>\n<h4>2. 工作流图解</h4>\n<p>Albumentations 的工作逻辑非常像工厂的<strong>流水线（Pipeline）</strong>：</p>\n<blockquote>\n<p><strong>[输入] 原始图片 + 标签（如边框坐标）</strong> ⬇️ <strong>[流水线 A.Compose]</strong> ├─ 随机裁剪 (RandomCrop) -&gt; 可能是左上角，可能是中心 ├─ 水平翻转 (HorizontalFlip) -&gt; 像照镜子一样 ├─ 随机亮度对比度 (RandomBrightnessContrast) -&gt; 忽明忽暗 ⬇️ <strong>[输出] 增强后的图片 + 自动调整好的标签坐标</strong></p>\n</blockquote>\n<p>你只需要定义好这个流水线，剩下的脏活累活，库全包了。</p>\n<hr />\n<h3>动手实战：三分钟上手 Hello World</h3>\n<p>别光说不练，我们来写代码。假设你已经安装好了库： <code>pip install albumentations opencv-python matplotlib</code></p>\n<h4>1. 最小可行性代码 (MVP)</h4>\n<p>我们将一张普通图片，通过 Albumentations 变成一张“面目全非”但特征犹在的训练样本。</p>\n<div class=\"code-block ng-tns-c3098535048-154 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-154 ng-star-inserted\"><span class=\"ng-tns-c3098535048-154\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-154 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-154\">\n<div class=\"animated-opacity ng-tns-c3098535048-154\">\n<pre class=\"ng-tns-c3098535048-154 highlighter-hljs\"><code>import albumentations as A\nimport cv2\nimport matplotlib.pyplot as plt\n\n# 1. 读取一张图片 (假设你有一张 cat.jpg)\n# 注意：OpenCV 读取的是 BGR 格式，为了显示正常我们需要转为 RGB\nimage = cv2.imread(\"cat.jpg\")\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n\n# 2. 定义我们的“魔鬼教练”流水线\ntransform = A.Compose([\n    # 随机裁剪一块 450x450 的区域\n    A.RandomCrop(width=450, height=450),\n    \n    # 50% 的概率水平翻转图片\n    A.HorizontalFlip(p=0.5),\n    \n    # 随机调整亮度和对比度，让模型适应不同光照\n    A.RandomBrightnessContrast(p=0.2),\n    \n    # 随机旋转 -30 到 30 度\n    A.Rotate(limit=30, p=0.5)\n])\n\n# 3. 执行变换！\n# Albumentations 接受关键字参数，所以必须显式写 image=...\naugmented = transform(image=image)\naugmented_image = augmented[\"image\"]\n\n# 4. 展示结果\nplt.figure(figsize=(10, 5))\nplt.subplot(1, 2, 1)\nplt.title(\"Original\")\nplt.imshow(image)\nplt.subplot(1, 2, 2)\nplt.title(\"Augmented\")\nplt.imshow(augmented_image)\nplt.show()</code></pre>\n</div>\n</div>\n</div>\n<h4>2. 代码解析：为什么这么写？</h4>\n<ul>\n<li>\n<p><strong><code>A.Compose([...])</code></strong>：这是核心容器。你可以把它理解为一个“动作列表”。当你调用它时，它会按顺序（或按概率）对图片执行列表里的操作。</p>\n</li>\n<li>\n<p><strong><code>p=0.5</code></strong>：这是 Albumentations 的灵魂——<strong>概率</strong>。如果每次增强都一模一样，那就没有随机性了。<code>p=0.5</code> 意味着这张图有 50% 的概率被翻转，50% 的概率保持原样。这就保证了生成数据的多样性。</p>\n</li>\n<li>\n<p><strong><code>augmented[\"image\"]</code></strong>：注意，返回值是一个字典。因为如果你还传入了 <code>mask</code> 或 <code>bboxes</code>，它们也会在这个字典里被返回。</p>\n</li>\n</ul>\n<hr />\n<h3>进阶深潜：解决最头疼的坐标变换</h3>\n<p>普通的库（比如 PIL 或 torchvision）做图片旋转很容易，但如果你在做<strong>目标检测（Object Detection）</strong>，图片旋转了，你标注的那个**方框（Bounding Box）**如果不跟着旋转，数据就废了。</p>\n<p>手动计算这个坐标变换涉及复杂的几何数学，极易出错。<strong>Albumentations 最强大的功能就是自动处理这个问题。</strong></p>\n<h4>场景：带 Bounding Box 的增强</h4>\n<div class=\"code-block ng-tns-c3098535048-155 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-155 ng-star-inserted\"><span class=\"ng-tns-c3098535048-155\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-155 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-155\">\n<div class=\"animated-opacity ng-tns-c3098535048-155\">\n<pre class=\"ng-tns-c3098535048-155 highlighter-hljs\"><code># 假设我们有一个标注框 [x_min, y_min, x_max, y_max]\n# 比如猫的脸在图片的位置\nbboxes = [[100, 100, 200, 200, 1]] # 最后的 1 是类别 ID\n\ntransform = A.Compose([\n    A.HorizontalFlip(p=1), # 强制翻转，方便观察效果\n    A.Rotate(limit=45, p=1)\n], bbox_params=A.BboxParams(format='pascal_voc', label_fields=['category_ids']))\n\n# 魔法发生的时刻\naugmented = transform(image=image, bboxes=bboxes, category_ids=[1])\n\n# 获取变换后的图片和坐标\naug_img = augmented['image']\naug_bboxes = augmented['bboxes']\n\nprint(f\"原坐标: {bboxes[0][:4]}\")\nprint(f\"变换后坐标: {aug_bboxes[0]}\") \n# 输出的坐标已经自动适配了翻转和旋转！</code></pre>\n</div>\n</div>\n</div>\n<p><strong>最佳实践与避坑指南：</strong></p>\n<ol start=\"1\">\n<li>\n<p><strong>坐标格式（Format）要对齐</strong>：Albumentations 支持 <code>pascal_voc</code> ([x_min, y_min, x_max, y_max]), <code>coco</code> ([x_min, y_min, w, h]), <code>yolo</code> (归一化中心点) 等格式。<strong>千万别填错 <code>format</code> 参数</strong>，否则你的框会飞到天上去。</p>\n</li>\n<li>\n<p><strong>验证你的增强</strong>：在开始大规模训练前，务必写脚本可视化几张增强后的图片和标签。有些强烈的变换（如 <code>ElasticTransform</code> 弹性形变）可能会导致标签严重失真，不适合用于精细的检测任务。</p>\n</li>\n<li>\n<p><strong>OneOf 的使用</strong>：有时候你需要“二选一”。比如你可以用 <code>A.OneOf([A.Blur, A.MotionBlur], p=0.2)</code>，这意味着每次要么用普通模糊，要么用运动模糊，不会同时叠加，这能防止图片被破坏得太厉害。</p>\n</li>\n</ol>\n<hr />\n<h3>总结与延伸</h3>\n<p>Albumentations 就像是给你的深度学习模型吃了一顿“自助大餐”，用极低的成本极大地丰富了数据的多样性。</p>\n<p><strong>核心知识点回顾：</strong></p>\n<ol start=\"1\">\n<li>\n<p><strong>流水线机制</strong>：使用 <code>Compose</code> 组合多个变换。</p>\n</li>\n<li>\n<p><strong>概率控制</strong>：利用 <code>p</code> 参数引入随机性，模拟真实世界的复杂情况。</p>\n</li>\n<li>\n<p><strong>空间一致性</strong>：它可以自动、准确地变换 Bounding Boxes 和 Masks，无需手动计算几何映射。</p>\n</li>\n</ol>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-28 09:16</span>&nbsp;\n<a href=\"https://www.cnblogs.com/swizard\">Swizard</a>&nbsp;\n阅读(<span id=\"post_view_count\">16</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "前后端分离框架 CatchAdmin V5 beta.2 发布 插件化与开发效率的进一步提升",
      "link": "https://www.cnblogs.com/catchadmin/p/19410766",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19410766\" id=\"cb_post_title_url\" title=\"发布于 2025-12-28 08:20\">\n    <span>前后端分离框架 CatchAdmin V5 beta.2 发布 插件化与开发效率的进一步提升</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"前后端分离框架-catchadmin-v5-beta2-发布-插件化与开发效率的进一步提升\">前后端分离框架 CatchAdmin V5 beta.2 发布 插件化与开发效率的进一步提升</h1>\n<h2 id=\"关于-catchadmin\">关于 CatchAdmin</h2>\n<p>CatchAdmin 是一款基于 Laravel 和 Element Plus 二次开发而成后台管理系统。Laravel 社区也有许多非常优秀的后台管理系统，例如 Nova，官方出品，当然是收费的，免费的有基于 Livewire 的 Filament，还有不得不说的 Laravel Admin。它采用前后端分离架构，CatchAdmin 集成了 Token 鉴权、权限管理、动态路由、动态表格、分页封装、资源权限、上传下载、代码生成器支持一键导出导入，数据回收站，附件管理的一款模块化框架。Laravel 框架仅仅作为 Api 输出。将管理系统模块之间的耦合降到了最低限度。每个模块之间都有独立的控制器，路由，模型，数据表。在开发上尽可能将模块之间的影响降到最低，降低了开发上的难度。基于 CatchAdmin 可以开发 CMS，CRM，OA 等等系统。也封装了很多实用的工具，提升开发体验。</p>\n<h2 id=\"本次更新亮点\">本次更新亮点</h2>\n<h3 id=\"导入导出功能增强\">导入导出功能增强</h3>\n<p>Beta.3 版本对数据导入导出功能进行了核心层面的增强。在实际业务中，批量导入用户、订单、商品等数据是高频需求。此次更新优化了导入导出的底层逻辑，支持更大数据量的处理，并提供了更灵活的字段映射配置。在代码生成器中勾选\"支持导入导出\"，即可为模块自动生成完整的导入导出功能，无需手写 Excel 处理代码。</p>\n<h3 id=\"插件系统正式支持\">插件系统正式支持</h3>\n<p>插件系统是 v5.0 的核心特性之一。CatchAdmin 没有自己发明一套插件机制，而是直接绑定 Composer 生态——任何符合 Laravel Package 规范的 Composer 包都可以作为 CatchAdmin 插件使用。</p>\n<p>本次更新增强了插件安装的 Hook 功能，开发者可以在插件安装、卸载时执行自定义逻辑（如初始化配置、创建数据表等）。同时优化了插件安装页面，支持在后台可视化管理插件的启用、禁用与卸载。</p>\n<p>这种设计让 CatchAdmin 可以无缝集成第三方服务（支付、短信、OSS 等），也方便将业务逻辑封装成插件在不同项目间复用。</p>\n<h3 id=\"sfc-远程加载性能优化\">SFC 远程加载性能优化</h3>\n<p>CatchAdmin 的前端支持\"即时渲染\"，即无需编译即可直接加载 Vue 单文件组件（SFC）。这在开发阶段非常方便，但远程加载会影响首屏渲染速度。</p>\n<p>Beta.3 版本优化了 SFC 的加载机制，通过缓存策略和按需加载，显著提升了页面渲染速度。在实际测试中，列表页的首次加载时间缩短了约 30%。</p>\n<h3 id=\"安装体验优化\">安装体验优化</h3>\n<p>简化了项目初始化流程，修复了因 Composer 依赖冲突导致的安装失败问题。现在从创建项目到启动后台，整个过程更加流畅，基本不需要手动干预。</p>\n<p>此外，左侧菜单现在支持自动更新——安装新模块或插件后，刷新页面即可看到对应的菜单项，无需手动配置路由。</p>\n<h2 id=\"插件市场已正式上线\">插件市场已正式上线</h2>\n<p><a href=\"https://catchadmin.vip/plugins\" rel=\"noopener nofollow\" target=\"_blank\">CatchAdmin 插件市场</a></p>\n<h2 id=\"快速开始\">快速开始</h2>\n<pre><code class=\"language-shell\">composer global -W require catchadmin/installer\n\n# 新建项目\ncatch new catchadmin\n\n# 安装项目\ncd catchadmin &amp;&amp; php artisan catch:install\n\n# 启动项目\ncomposer run dev\n</code></pre>\n<h2 id=\"功能\">功能</h2>\n<ul>\n<li>☑️<strong>用户管理</strong> 完成用户添加、修改、删除配置，支持不同用户登录后台看到不同的首页</li>\n<li>☑️<strong>部门管理</strong> 部门组织机构（公司、部门、小组），树结构展现</li>\n<li>☑️<strong>岗位管理</strong> 可以给用户配置所担任职务</li>\n<li>☑️<strong>角色管理</strong> 树结构设计，支持角色菜单和按钮权限分配，支持角色数据权限分配、强大的角色管理体系</li>\n<li>☑️<strong>菜单管理</strong> 配置系统菜单和按钮等</li>\n<li>☑️<strong>字典管理</strong> 对系统中经常使用并且固定的数据可以重复使用和维护</li>\n<li>☑️<strong>系统配置</strong> 系统的一些常用设置管理</li>\n<li>☑️<strong>操作日志</strong> 用户对系统的一些正常操作的查询</li>\n<li>☑️<strong>登录日志</strong> 用户登录系统的记录查询</li>\n<li>☑️<strong>文件上传</strong> 支持<code>本地</code>、<code>七牛云</code>、<code>阿里云</code>、<code>腾讯云</code></li>\n<li>☑️<strong>附件管理</strong> 管理当前系统上传的文件及图片等信息</li>\n<li>☑️<strong>数据表维护</strong> 对系统的数据表可以进行清理碎片和优化，并且管理所有数据的回收和销毁</li>\n<li>☑️<strong>代码生成</strong> 前后端代码的生成（php、vue、 数据库迁移），支持一键生成到模块</li>\n<li>☑️<strong>支持 Vue 即时渲染</strong> 支持前端 Vue 即时渲染 无需编译</li>\n<li>☑️<strong>支持插件系统</strong> CatchAdmin 插件即 Composer 包，无需再学一次插件开发，完全绑定 Composer 生态</li>\n</ul>\n<h2 id=\"在线体验\">在线体验</h2>\n<ul>\n<li>演示地址：<a href=\"https://pro.catchadmin.com\" rel=\"noopener nofollow\" target=\"_blank\">https://pro.catchadmin.com</a></li>\n<li>账户：<code>catch@admin.com</code></li>\n<li>密码：<code>catchadmin</code></li>\n</ul>\n<h2 id=\"项目地址\">项目地址</h2>\n<ul>\n<li>GitHub：<a href=\"https://github.com/JaguarJack/catch-admin\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/JaguarJack/catch-admin</a></li>\n<li>Gitee：<a href=\"https://gitee.com/catchadmin/catchadmin\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/catchadmin/catchadmin</a></li>\n</ul>\n<h2 id=\"界面预览\">界面预览</h2>\n<p><img alt=\"CatchAdmin v5.0 Beta 欢迎页\" class=\"lazyload\" /><br />\n<img alt=\"CatchAdmin v5.0 Beta 数据面板\" class=\"lazyload\" /><br />\n<img alt=\"CatchAdmin v5.0 Beta 用户管理\" class=\"lazyload\" /><br />\n<img alt=\"CatchAdmin v5.0 Beta 代码生成\" class=\"lazyload\" /></p>\n<p><a href=\"https://catchadmin.com/post/2025-12/catchadmin-v5-beta\" rel=\"noopener nofollow\" target=\"_blank\">原文- 前后端分离框架 CatchAdmin V5 beta.2 发布 插件化与开发效率的进一步提升</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-28 08:20</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">17</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "如何使用『页脚HTML代码』-实现自推广 -『AI实现的小程序&小游戏』",
      "link": "https://www.cnblogs.com/uoky/p/19410177",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/uoky/p/19410177\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 23:32\">\n    <span>如何使用『页脚HTML代码』-实现自推广 -『AI实现的小程序&amp;小游戏』</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<div class=\"article-container\">\n<h1 style=\"font-size: 28px; font-weight: bold; margin: 0; color: rgba(44, 62, 80, 1);\">个人博客-自定义推广方案</h1>\n<p>&nbsp;</p>\n<div class=\"summary-section\">\n<h2 style=\"color: rgba(44, 62, 80, 1); font-size: 20px; margin-top: 0; display: flex;\"><span style=\"color: rgba(255, 255, 255, 1); width: 28px; height: 28px; border-radius: 50%; display: inline-flex; margin-right: 10px; font-size: 14px;\">!</span> 摘要</h2>\n<p style=\"font-size: 15px; line-height: 1.7; color: rgba(44, 62, 80, 1); margin: 10px 0;\"><strong style=\"color: rgba(52, 152, 219, 1); display: block; margin-bottom: 8px;\">使用AI写了超简易的微信小程序『Uoky统计』微信小游戏『木木玩躲避』，如何使用博客实现自定义推广</strong></p>\n</div>\n<div class=\"content-section\">\n<p style=\"font-size: 15px; line-height: 1.7; color: rgba(51, 51, 51, 1); margin: 0 0 15px; padding-left: 20px;\"><span style=\"color: rgba(52, 152, 219, 1); font-weight: bold;\">•</span> 目前AI写的小程序与小游戏均已上线，考虑推广。 <span style=\"text-decoration: line-through; color: rgba(149, 165, 166, 1); font-style: italic; background-color: rgba(248, 249, 250, 1); padding: 2px 6px; border-radius: 4px; margin-left: 5px;\"> 这个小程序和小游戏十分简易，没有任何技术含量，目前是纯浪费时间玩一下。 </span></p>\n<div class=\"image-crossed\" style=\"text-align: center; margin: 20px 0;\"><span style=\"text-decoration: line-through; color: rgba(149, 165, 166, 1); font-style: italic; display: block;\"> <img alt=\"生成特定内容的图片\" height=\"185\" src=\"https://img2024.cnblogs.com/blog/2115870/202512/2115870-20251227223009141-400083286.png\" width=\"185\" /> </span></div>\n<p style=\"font-size: 15px; line-height: 1.7; color: rgba(51, 51, 51, 1); margin: 15px 0 0; padding-left: 20px;\"><span style=\"color: rgba(52, 152, 219, 1); font-weight: bold;\">•</span> 虽然作者本人没有做什么开发方面的努力 <span style=\"text-decoration: line-through; color: rgba(149, 165, 166, 1); background-color: rgba(248, 249, 250, 1); padding: 2px 6px; border-radius: 4px; margin: 0 3px;\"> <em>找字体、音乐、音效、图标</em> </span> <span style=\"text-decoration: line-through; color: rgba(149, 165, 166, 1); background-color: rgba(248, 249, 250, 1); padding: 2px 6px; border-radius: 4px; margin: 0 3px;\"> <em>备案等后勤工作</em> </span> 。但毕竟上线了，还是想着推广一下</p>\n</div>\n<div class=\"emoji-section\" style=\"text-align: center; margin: 30px 0;\"><img alt=\"生成年迈感叹表情包 (2)\" height=\"273\" src=\"https://img2024.cnblogs.com/blog/2115870/202512/2115870-20251227224329737-1023925099.png\" width=\"273\" /></div>\n<div class=\"effect-section\">\n<div>&nbsp;</div>\n<h3 style=\"color: rgba(39, 174, 96, 1); font-size: 20px; margin-top: 0; display: flex; padding-top: 10px;\"><span style=\"color: rgba(255, 255, 255, 1); width: 30px; height: 30px; border-radius: 50%; display: inline-flex; margin-right: 12px; font-size: 14px;\">✓</span> 实现效果：</h3>\n<p style=\"font-size: 15px; line-height: 1.7; color: rgba(44, 62, 80, 1); margin: 15px 0 0; font-weight: 500;\">画面右下角显示：</p>\n<div class=\"image-center\"><br />\n<p>&nbsp;</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/2115870/202512/2115870-20251227232209151-931241342.png\" style=\"border-radius: 18px;\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n\n\n</div>\n\n\n</div>\n<div class=\"steps-section\">\n<div>&nbsp;</div>\n<h3 style=\"color: rgba(41, 128, 185, 1); font-size: 22px; margin-top: 0; padding-left: 15px;\"><span><br /></span>&nbsp; &nbsp; 实现步骤</h3>\n<div class=\"step\">\n<div style=\"display: flex; margin-bottom: 15px;\">\n<div style=\"color: rgba(255, 255, 255, 1); width: 36px; height: 36px; border-radius: 50%; display: flex; font-weight: bold; font-size: 18px; margin-right: 15px;\">1</div>\n<p style=\"font-size: 16px; color: rgba(44, 62, 80, 1); font-weight: 600; margin: 0;\">进入博客园设置</p>\n\n\n\n\n\n\n\n\n</div>\n<div class=\"image-center\" style=\"text-align: center; margin: 15px 0;\"><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/2115870/202512/2115870-20251227220723565-782831602.png\" /></div>\n\n\n\n\n\n\n\n\n</div>\n<div class=\"step\">\n<div style=\"display: flex; margin-bottom: 15px;\">\n<div style=\"color: rgba(255, 255, 255, 1); width: 36px; height: 36px; border-radius: 50%; display: flex; font-weight: bold; font-size: 18px; margin-right: 15px;\">2</div>\n<p style=\"font-size: 16px; color: rgba(44, 62, 80, 1); font-weight: 600; margin: 0;\">指定页脚HTML代码</p>\n\n\n\n\n\n\n\n\n</div>\n<div class=\"image-center\" style=\"text-align: center; margin: 15px 0;\"><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/2115870/202512/2115870-20251227221106222-787541671.png\" /></div>\n\n\n\n\n\n\n\n\n</div>\n<div class=\"success-message\">\n<p>添加超简单固定div即可，超级简单！</p>\n\n\n\n\n\n\n\n\n</div>\n<div class=\"code-section\">\n<h4 style=\"color: rgba(52, 152, 219, 1); font-size: 18px; margin: 0 0 20px; display: flex;\"><span style=\"width: 34px; height: 24px; border-radius: 4px; display: inline-flex; margin-right: 10px; color: rgba(255, 255, 255, 1); font-size: 14px;\">&lt;/&gt;</span> 代码示例：</h4>\n<div class=\"image-center\" style=\"text-align: center; margin: 0;\"><img alt=\"image\" height=\"auto\" src=\"https://img2024.cnblogs.com/blog/2115870/202512/2115870-20251227221829466-798413403.png\" width=\"100%\" /></div>\n\n\n\n\n\n\n\n\n</div>\n\n\n\n\n\n\n\n\n</div>\n<div class=\"tip-section\">\n<div style=\"font-size: 30px; color: rgba(33, 150, 243, 1);\">💡</div>\n<h4 style=\"color: rgba(13, 71, 161, 1); font-size: 18px; margin-top: 0; display: flex;\"><span style=\"color: rgba(255, 255, 255, 1); width: 30px; height: 30px; border-radius: 50%; display: inline-flex; margin-right: 12px; font-size: 16px;\">i</span> 推广建议</h4>\n<p style=\"font-size: 15px; line-height: 1.7; color: rgba(13, 71, 161, 1); margin: 15px 0 0; font-weight: 500;\">如果你也有一些工具想要推广，建议在不影响自身博客内容显示的情况下，酌情添加。</p>\n\n\n\n\n\n\n\n\n</div>\n\n\n\n\n\n\n\n\n</div>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-27 23:32</span>&nbsp;\n<a href=\"https://www.cnblogs.com/uoky\">人间春风意</a>&nbsp;\n阅读(<span id=\"post_view_count\">51</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Sidecar不就是在Pod里多跑一个容器吗！",
      "link": "https://www.cnblogs.com/ydswin/p/19396769",
      "published": "",
      "description": "<h2>\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ydswin/p/19396769\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 19:05\">\n    <span>Sidecar不就是在Pod里多跑一个容器吗！</span>\n    \n\n</a>\n\n\t\t</h2>\n\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>深入理解云原生时代的核心设计模式</p>\n</blockquote>\n<p>乍看之下，Sidecar 模式确实只是在 Pod 里多运行一个容器而已。但这种表面理解，就像说“互联网不过是一堆电缆和服务器”一样，忽略了其背后的精妙设计思想和革命性价值。今天，我们就来深入探讨这个看似简单却极具威力的云原生核心模式。</p>\n<h2 id=\"从一个认知误区说起\">从一个认知误区说起</h2>\n<p><strong>\"Pod 就是容器\"</strong>——这是许多 Kubernetes 初学者最常见的误解。事实上，Pod 并不是容器，而是<strong>容器的容器</strong>，是一个可以容纳一个或多个紧密关联容器的“逻辑主机”。</p>\n<p>当我们说“在 Pod 里多跑一个容器”时，这意味着什么？意味着这个额外的容器与主应用容器共享着几乎所有关键资源：<strong>网络命名空间</strong>（同一 IP，通过 localhost 直接通信）、<strong>存储卷</strong>（Volume）以及<strong>生命周期</strong>（同生共死）。</p>\n<p>这种共享关系，正是 Sidecar 魔力的源泉。</p>\n<h2 id=\"sidecar-的本质不只是多一个容器\">Sidecar 的本质：不只是“多一个容器”</h2>\n<h3 id=\"设计模式而非技术实现\">设计模式而非技术实现</h3>\n<p>Sidecar 本质上是一种<strong>容器设计模式</strong>，而不是简单的技术实现。它代表了一种架构哲学：将辅助功能从主业务逻辑中解耦，让专业容器做专业事。</p>\n<p>举个例子，想象一位主厨（主应用容器）在厨房工作。主厨专注炒菜（业务逻辑），而配菜、打扫、菜单更新等杂事由助手（Sidecar 容器）完成。这种分工协作大大提升了效率和专业性。</p>\n<h3 id=\"云原生时代的功能扩展槽\">云原生时代的“功能扩展槽”</h3>\n<p>在云原生架构中，Sidecar 如同计算机主板上的<strong>扩展槽</strong>，允许我们为应用动态添加各种能力而无须修改应用本身。</p>\n<ul>\n<li><strong>日志收集</strong>：主容器写日志到共享卷，Sidecar 容器负责收集和发送到日志系统</li>\n<li><strong>服务网格</strong>：如 Istio 使用 Envoy 作为 Sidecar 代理，实现服务间通信的监控、安全和控制</li>\n<li><strong>配置管理</strong>：Sidecar 监听配置中心，动态更新配置文件，主容器只需读取本地文件</li>\n<li><strong>安全代理</strong>：如 Vault Agent Sidecar，负责与密钥管理系统交互，主应用无感知</li>\n</ul>\n<h2 id=\"为什么多跑一个容器如此重要\">为什么“多跑一个容器”如此重要？</h2>\n<h3 id=\"1-无侵入式架构设计\">1. 无侵入式架构设计</h3>\n<p>传统做法中，要为应用添加监控、安全或通信功能，通常需要修改应用代码。而 Sidecar 模式通过“多跑一个容器”实现了<strong>零侵入</strong>的功能增强。</p>\n<p>以服务网格为例，应用代码无需关心服务发现、熔断、重试等复杂逻辑，所有这些都由 Sidecar 代理透明处理。</p>\n<h3 id=\"2-技术栈无关性\">2. 技术栈无关性</h3>\n<p>Sidecar 容器可以用任何语言编写，与主应用容器的技术栈无关。一个 Java 应用可以搭配一个 Go 或 Rust 编写的 Sidecar，充分发挥各语言优势。</p>\n<h3 id=\"3-独立性和可复用性\">3. 独立性和可复用性</h3>\n<p>Sidecar 容器可以<strong>独立开发、升级和部署</strong>。一个精心设计的日志收集 Sidecar 可以被全公司所有服务复用，大大降低开发维护成本。</p>\n<h2 id=\"实战示例sidecar-如何工作\">实战示例：Sidecar 如何工作</h2>\n<p>让我们通过一个具体例子看看“多跑一个容器”如何实际运作：</p>\n<pre><code class=\"language-yaml\">apiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx-with-logger\nspec:\n  volumes:\n  - name: nginx-logs\n    emptyDir: {}  # 临时共享目录\n\n  containers:\n  - name: nginx\n    image: nginx\n    volumeMounts:\n    - name: nginx-logs\n      mountPath: /var/log/nginx\n\n  - name: log-sidecar  # 这就是“多跑”的容器\n    image: busybox\n    command: [\"/bin/sh\", \"-c\"]\n    args:\n    - while true; do\n        if [ -f /var/log/nginx/access.log ]; then\n          tail -n 10 /var/log/nginx/access.log;\n        fi;\n        sleep 5;\n      done\n    volumeMounts:\n    - name: nginx-logs\n      mountPath: /var/log/nginx\n</code></pre>\n<p>在这个例子中：</p>\n<ul>\n<li><strong>nginx 容器</strong>：专注提供 Web 服务，将日志写入 <code>/var/log/nginx</code></li>\n<li><strong>log-sidecar 容器</strong>：负责读取日志并处理（示例中只是打印，实际可发送到日志系统）</li>\n</ul>\n<p>两个容器通过 <strong>emptyDir 卷</strong>共享日志目录，通过 <strong>localhost</strong> 通信（如果需要），共同构成一个完整的 Web 服务单元。</p>\n<h2 id=\"超越多一个容器sidecar-的高级模式\">超越“多一个容器”：Sidecar 的高级模式</h2>\n<h3 id=\"服务网格中的-sidecar\">服务网格中的 Sidecar</h3>\n<p>在服务网格（如 Istio）中，Sidecar 模式发挥到极致。每个 Pod 中注入的 Envoy 代理容器透明地拦截和处理所有进出流量，实现精细化的流量管理、安全加密和可观测性。</p>\n<p>这时，“多跑的容器”不再是简单的辅助角色，而是构成了<strong>分布式系统的通信基础设施</strong>。</p>\n<h3 id=\"适配器模式\">适配器模式</h3>\n<p>Sidecar 可以作为<strong>适配器</strong>，在不同接口或协议间进行转换。例如，主容器暴露 <code>/metrics</code> 接口，而监控系统需要 <code>/health</code> 接口，Sidecar 容器负责协议转换，无需修改主应用。</p>\n<h2 id=\"最佳实践与注意事项\">最佳实践与注意事项</h2>\n<p>虽然 Sidecar 功能强大，但也需要谨慎使用：</p>\n<h3 id=\"启动顺序协调\">启动顺序协调</h3>\n<p>Kubernetes 不保证容器启动顺序，如果 Sidecar 需要先于主容器就绪（如配置同步 Sidecar），需要通过 initContainers 或健康检查机制协调。</p>\n<h3 id=\"资源管理\">资源管理</h3>\n<p>为 Sidecar 设置合理的资源请求和限制，避免与主容器资源争抢。</p>\n<pre><code class=\"language-yaml\">resources:\n  requests:\n    cpu: 100m\n    memory: 128Mi\n  limits:\n    cpu: 200m\n    memory: 256Mi\n</code></pre>\n<h3 id=\"避免过度使用\">避免过度使用</h3>\n<p>不是所有功能都适合 Sidecar 模式。如果架构不复杂，直接使用 API 网关或传统中间件可能更简单。</p>\n<h2 id=\"与其他模式的关系\">与其他模式的关系</h2>\n<h3 id=\"sidecar-vs-init-容器\">Sidecar vs Init 容器</h3>\n<ul>\n<li><strong>Init 容器</strong>：在 Pod 启动前运行，完成即退出，用于初始化工作</li>\n<li><strong>Sidecar 容器</strong>：与主容器并行运行，在整个生命周期内提供辅助功能</li>\n</ul>\n<h3 id=\"sidecar-vs-daemonset\">Sidecar vs DaemonSet</h3>\n<ul>\n<li><strong>Sidecar</strong>：每个应用实例一个，与特定应用紧密绑定</li>\n<li><strong>DaemonSet</strong>：每个节点一个，提供节点级别服务</li>\n</ul>\n<h2 id=\"总结简单概念背后的深远影响\">总结：简单概念背后的深远影响</h2>\n<p>回到最初的问题：“Sidecar 不就是 Pod 里多跑一个容器吗？”——<strong>是，但远不止于此</strong>。</p>\n<p>这个看似简单的“多跑一个容器”设计，实际上代表了云原生架构的核心思想：<strong>关注点分离、松散耦合、可复用性</strong>。它让应用开发者专注业务逻辑，而将通用能力下沉到基础设施层。</p>\n<p>从简单的日志收集到复杂的服务网格，从配置管理到安全代理，Sidecar 模式已经成为现代云原生架构不可或缺的组成部分。它不是什么银弹，但当合理使用时，确实能够极大地提升系统的可维护性、可观测性和灵活性。</p>\n<p>所以，需要理解这简单表象背后蕴含的深厚架构智慧。</p>\n<p><em>是的，它就是多跑一个容器，但正是这个“多跑”的容器，让云原生应用架构变得如此强大而优雅。</em></p>\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/ydswin/\" target=\"_blank\">dashery</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/ydswin/p/19396769\" target=\"_blank\">https://www.cnblogs.com/ydswin/p/19396769</a></p>\n</div>\n<div class=\"clear\"></div>\n\n\t\t<p class=\"postfoot\">\n\t\t\tposted on \n<span id=\"post-date\">2025-12-27 19:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ydswin\">dashery</a>&nbsp;\n阅读(<span id=\"post_view_count\">62</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</p>"
    },
    {
      "title": "基于莱布尼茨公式的编程语言计算性能基准测试",
      "link": "https://www.cnblogs.com/shanyou/p/19408361",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/shanyou/p/19408361\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 19:03\">\n    <span>基于莱布尼茨公式的编程语言计算性能基准测试</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><font face=\"微软雅黑 Light\" size=\"3\">利用莱布尼茨公式（Leibniz formula）计算圆周率 $\\pi$。尽管在现代数学计算库中，莱布尼茨级数因其收敛速度极慢而鲜被用于实际精算 Π 值，但其算法结构——高密度的浮点运算、紧凑的循环逻辑以及对算术逻辑单元（ALU）的持续压力——使其成为测试 CPU 单核吞吐量、浮点运算单元（FPU）效率以及编译器自动向量化（Auto-vectorization）能力的绝佳“试金石” 。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\">GitHub 开源项目 </font><a href=\"https://github.com/niklas-heer/speed-comparison\" rel=\"noopener nofollow\" target=\"_blank\"><font face=\"微软雅黑 Light\" size=\"3\">niklas-heer/speed-comparison</font></a><code></code><font face=\"微软雅黑 Light\" size=\"3\"> 在 2025 年 12 月产生的最新数据，涵盖了从底层系统级语言（如 C++、Rust）到托管型语言（如 Java、C#），再到动态解释型语言（如 Python、Ruby）的 62 种不同实现。通过对 10 亿次迭代运算的详尽分析，我们不仅试图排列出“谁最快”，更致力于揭示“为什么快”背后的深层技术逻辑，探讨单指令多数据（SIMD）技术、即时编译（JIT）机制以及内存模型对计算性能的决定性影响。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\"><img alt=\"Speed comparison chart\" src=\"https://niklas-heer.github.io/speed-comparison/history/2025-12-21T203810/combined_results.png\" /></font></p><p><font face=\"微软雅黑 Light\" size=\"3\">上图来自：</font><a href=\"https://niklas-heer.github.io/speed-comparison/\" rel=\"noopener nofollow\" title=\"https://niklas-heer.github.io/speed-comparison/\"><font face=\"微软雅黑 Light\" size=\"3\">https://niklas-heer.github.io/speed-comparison/</font></a></p><p><font face=\"微软雅黑 Light\" size=\"3\">莱布尼茨公式，作为 arctan(x) 的泰勒级数在 x=1时的特例，其数学表达为：</font></p><p><a href=\"https://img2024.cnblogs.com/blog/510/202512/510-20251227190234460-627552407.png\"></a><a href=\"https://img2024.cnblogs.com/blog/510/202512/510-20251227190235042-730543600.png\"><font face=\"微软雅黑 Light\" size=\"3\"><img alt=\"image\" border=\"0\" height=\"159\" src=\"https://img2024.cnblogs.com/blog/510/202512/510-20251227114212916-1845415606.png\" style=\"display: inline; background-image: none;\" title=\"image\" width=\"833\" /></font></a></p><p><font face=\"微软雅黑 Light\" size=\"3\">从算法实现的角度审视，该公式具有以下显著特征，这些特征直接决定了其作为基准测试的有效性：</font></p><ol><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>极端的计算密集度</b>：算法核心仅包含基本的加、减、乘、除运算，几乎不涉及复杂的内存分配或系统调用（System Calls）。这使得测试结果能够高度纯粹地反映语言运行时的计算开销和指令生成质量 。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>可预测的分支逻辑</b>：公式中的符号交替项 (-1)^k 引入了潜在的分支预测（Branch Prediction）挑战。朴素的实现可能会在循环内部使用 <code>if (i % 2 == 0)</code> 判断奇偶性，这将导致大量的 CPU 分支预测失败，从而严重拖慢流水线。而高效的实现通常采用无分支（Branchless）技巧，利用位运算或数学变换来消除条件跳转，这考验了程序员对底层硬件的理解以及编译器的优化智能 。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>浮点精度与收敛性</b>：虽然本基准测试明确声明“不关注 pi的精确度”，仅关注运算速度，但浮点数（IEEE 754 标准）的累加特性使得计算顺序对结果有微小影响。编译器是否开启 <code>-ffast-math</code> 等激进优化选项（允许改变浮点结合律）对性能有着数量级的影响，这成为了不同语言实现之间性能差异的主要变量之一 。</font></font></p></li></ol><p><font face=\"微软雅黑 Light\" size=\"3\">基于 2025 年 12 月的最新基准测试数据，我们将 62 种语言实现划分为四个具有显著特征的性能梯队。</font></p><h5><font face=\"微软雅黑 Light\" size=\"3\"> 第一梯队：极限性能层 (&lt; 300ms) —— 编译器的极致</font></h5><p><font face=\"微软雅黑 Light\" size=\"3\">这一梯队的语言代表了当前通用 CPU 单核计算的物理极限。它们几乎完全消除了语言本身的运行时开销，性能瓶颈仅在于 CPU 的 ALU 吞吐量和内存带宽。</font></p><p><b><font face=\"微软雅黑 Light\" size=\"3\">深度剖析：</font></b></p><ul><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>LLVM 的霸权</b>：前 10 名中，C++ (Clang)、Zig、D (LDC)、Rust (Nightly) 均依赖 LLVM 编译器后端。这证明了 LLVM 在现代处理器指令调度和向量化分析上的卓越能力。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>C# 的惊人逆袭</b>：C# (SIMD) 位列第二，仅落后 C++ 不到 4 毫秒。这打破了“托管语言一定慢”的刻板印象。通过.NET 的 <code>System.Numerics.Vectors</code> 库，C# 能够生成与 C++ 几乎相同的 AVX-512 机器码，同时享受 JIT 针对当前硬件动态优化的优势 。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>手写 vs 自动</b>：排名第 4 的 C++ (avx2) 是手写 SIMD 代码，却输给了编译器自动优化的 Clang (第 1)。这说明在简单的循环逻辑中，现代编译器对流水线气泡（Pipeline Bubble）和寄存器分配的掌控已经超越了普通人类专家 。</font></font></p></li></ul><h5><font face=\"微软雅黑 Light\" size=\"3\">第二梯队：亚秒级高性能层 (300ms - 1000ms) —— 标量优化的极限</font></h5><p><font face=\"微软雅黑 Light\" size=\"3\">这一梯队的语言性能非常出色，通常在 0.5 秒到 1 秒之间。它们大多生成了高效的机器码，但因未开启激进的 SIMD 优化或受到运行时轻微拖累，未能进入第一梯队。</font></p><p><b><font face=\"微软雅黑 Light\" size=\"3\">深度剖析：</font></b></p><ul><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>Rust 的版本鸿沟</b>：Rust (Stable) 耗时 633ms，而 Nightly 版仅需 234ms。这种巨大的差距源于 Rust 稳定版对 IEEE 754 浮点行为的严格遵守，阻止了编译器进行改变运算顺序的向量化优化。只有在 Nightly 版中显式启用相关特性，才能释放硬件潜力 。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>Go 的妥协</b>：Go 语言（888ms）稳定地处于这一梯队。Go 的编译器（gc）设计初衷是编译速度快，而非生成的代码最快。它在自动向量化方面远不如 LLVM 激进，且 Go 运行时包含的调度器和垃圾回收（GC）屏障（Write Barriers）在微观层面引入了额外开销 。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>JavaScript 的运行时之战</b>：Bun (928ms) 显著快于 Node.js (1.28s)。Bun 使用的 JavaScriptCore (JSC) 引擎在特定数值计算优化上表现出了相比 Google V8 的优势，证明了现代 JS 引擎的 JIT 能力已能逼近原生代码（仅慢 3-4 倍）。</font></font></p></li></ul><h5><font face=\"微软雅黑 Light\" size=\"3\">第三梯队：解释与混合层 (1s - 5s) —— JIT 的战场</font></h5><p><font face=\"微软雅黑 Light\" size=\"3\">这一梯队主要包含动态类型语言的高性能 JIT 实现，或启动开销较大的静态语言环境。</font></p><p><b><font face=\"微软雅黑 Light\" size=\"3\">深度剖析：</font></b></p><ul><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>PyPy 的惊艳表现</b>：PyPy 将 Python 的运行时间压缩至 1.06 秒，仅比 C# 标准版慢一点。这得益于其 Tracing JIT 技术，能够动态记录循环的执行路径并编译为机器码，消除了动态类型检查的巨大开销 。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>NumPy 的陷阱</b>：虽然 NumPy 底层是 C，但在此测试中（2.46s）表现平平。这是因为测试代码使用了 Python 层的 <code>for</code> 循环逐个调用 NumPy 的标量运算。NumPy 的威力在于数组操作（Vectorization），在标量调用场景下，Python 与 C 之间的上下文切换（Function Call Overhead）反而成为了负担。若允许重写为数组操作，NumPy 可能会进入第一梯队，但这违反了“算法一致性”规则 。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>Java 的启动与优化</b>：标准 Java (1.70s) 表现中规中矩。HotSpot 编译器虽然强大，但在无法自动向量化浮点循环的情况下，受限于 JVM 的栈操作开销。此外，Java 巨大的启动时间（JVM 初始化、类加载）在短时任务中占比显著。</font></font></p></li></ul><h5><font face=\"微软雅黑 Light\" size=\"3\">第四梯队：纯解释器层 (&gt; 10s) —— 动态类型的代价</font></h5><p><font face=\"微软雅黑 Light\" size=\"3\">最慢的梯队，主要是未优化的脚本语言解释器。</font></p><p><b><font face=\"微软雅黑 Light\" size=\"3\">深度剖析：</font></b></p><ul><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>CPython 的性能瓶颈</b>：标准 Python（CPython）以 86.32 秒垫底，比 C++ 慢了近 400 倍。这归因于其虚拟机架构：每一次加法操作都需要进行对象类型检查（Type Checking）、引用计数更新（Reference Counting）和字节码分发（Dispatch）。对于 10 亿次循环，这些微小的开销累积成了巨大的时间鸿沟 。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>解释器的局限</b>：这一梯队的语言（PHP, Ruby, Perl, Raku）在处理紧凑循环时，CPU 主要忙于解释器自身的逻辑（解析字节码、管理栈），而非执行实际的数学运算。</font></font></p></li></ul><h5><font face=\"微软雅黑 Light\" size=\"3\"> C#：.NET Core 的高性能复兴</font></h5><p><font face=\"微软雅黑 Light\" size=\"3\">在本次测试中，C# (SIMD) 的表现（227ms）是最令人瞩目的亮点之一。这主要归功于.NET Core（现称为.NET 5/6/7+）引入的硬件内建支持（Hardware Intrinsics）。</font></p><ul><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>实现细节</b>：通过引用 <code>System.Runtime.Intrinsics</code> 或使用更高级的 <code>System.Numerics.Vector&lt;T&gt;</code>，C# 开发者可以编写出直接映射到 CPU 向量指令的代码。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>JIT 的优势</b>：与 C++ 的 AOT（提前编译）不同，C# 的 JIT 编译器在程序运行时知道当前 CPU 确切支持哪些指令集（是 AVX2 还是 AVX-512）。这使得 C# 程序可以在旧机器上安全运行，而在新机器上自动全速狂奔，无需像 C++ 那样发布多个二进制版本。基准测试结果证明，这种机制在数值计算领域已经完全成熟 。</font></font></p></li></ul><p><font face=\"微软雅黑 Light\" size=\"3\"><br /></font></p>\n</div>\n<div id=\"MySignature\">\n    <p>欢迎大家扫描下面二维码成为我的客户，扶你上云</p>\n<img src=\"https://images.cnblogs.com/cnblogs_com/shanyou/57459/o_220125090408_%E9%82%80%E8%AF%B7%E4%BA%8C%E7%BB%B4%E7%A0%81-258px.jpeg\" width=\"170\" />\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-27 19:03</span>&nbsp;\n<a href=\"https://www.cnblogs.com/shanyou\">张善友</a>&nbsp;\n阅读(<span id=\"post_view_count\">90</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "FFmpeg开发笔记（九十五）国产的开源视频美颜工具VideoEditorForAndroid",
      "link": "https://www.cnblogs.com/aqi00/p/19319684",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aqi00/p/19319684\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 12:00\">\n    <span>FFmpeg开发笔记（九十五）国产的开源视频美颜工具VideoEditorForAndroid</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<span><span>​</span></span><span id=\"cke_bm_178S\">《FFmpeg开发实战：从零基础到短视频上线》一书的“第 12 章 &nbsp;FFmpeg的移动开发”介绍了如何使用FFmpeg在手机上剪辑视频，方便开发者更好地开发类似剪映那样的视频剪辑软件。那么在Android系统上还有一款国产的开源视频美颜框架VideoEditor-For-Android，通过该框架可以更方便地给视频添加各种滤镜，下面就来介绍如何在App工程中使用VideoEditor-For-Android。</span>\n<p><span id=\"cke_bm_178S\"> VideoEditor-For-Android是一款基于Android硬编码的视频编辑器，包含视频录制、剪切、增加bgm、美白、加滤镜、加水印等多种功能。该框架通过Android的api完成视频采集，通过OpenGL完成视频数据帧的处理，通过MeidaCodec对采集到的视频流进行硬编码。它利用OpenGL完成视频的美白、加滤镜、加水印等功能，利用MediaCodec完成音视频的分离和音频的一些混音处理。<br />\nVideoEditor-For-Android的源码托管地址为https://github.com/qqchenjian318/VideoEditor-For-Android（星星数1.3k），最近版本更新于2021年9月，该版本的压缩包下载地址为https://github.com/qqchenjian318/VideoEditor-For-Android/archive/refs/heads/master.zip。<br />\n由于VideoEditor-For-Android源码的发布时间较早，为了让小海豚版本的Android Studio Dolphin能够打开它们，需要对App工程作如下修改：<br />\n1、升级Gradle版本和SDK版本；<br />\n2、把使用的jdk版本从默认的JDK8改为JDK11；<br />\n3、把Support库迁移为Androidx库；<br />\n4、build.gradle给NDK的指令集过滤器增加arm64-v8a；<br />\n5、App代码在录像和操作存储空间时增加运行时授权校验；<br />\n6、另外修复了若干bug；<br />\n因为上述修改涉及到的内容较多，这里不再一一列出，博主把修改后的App源码上传到了Github，具体地址为https://github.com/aqi00/note/tree/master/VideoEditor-For-Android。大家可以拉取Github上修改好的VideoEditor-For-Android源码，就能用小海豚版本的Android Studio Dolphin导入带Demo界面的VideoEditor-For-Android工程了。<br />\n那么通过Android Studio Dolphin编译VideoEditor-For-Android并安装到真机上，点击【本地视频美颜】后进入视频文件的挑选页面如下图所示：</span></p>\n<div>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"vefa2\" class=\"lazyload\" height=\"407\" width=\"345\" /></span></span></span></span></p>\n\n\n</div>\n<p>先到相册选择一个待加工的视频文件，再点击弹窗右下角的【加滤镜】按钮，App就转到视频的预览界面如下图所示：</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"vefa3\" class=\"lazyload\" height=\"681\" width=\"317\" /></span></span></span></span></p>\n<p>在视频预览界面左右滑动，可以切换不同的美颜效果，如下图所示：<span class=\"cke_image_resizer_wrapper\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\">​</span></span></p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"vefa4\" class=\"lazyload\" height=\"680\" width=\"317\" /></span></span></span></div>\n<p>点击界面右下角的打勾按钮，App就开始执行对应的美颜加工操作。美颜之后的视频片段默认放在App安装路径下的files目录，完整路径为“我的手机/Android/data/com.example.cj.videoeditor/files/video/clip/123456789.mp4”，其中123456789代表一串数字。使用手机自带的文件管理App找到新保存的视频片段，即可观看美颜后的视频效果。</p>\n<p>更多详细的FFmpeg开发知识参见<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\"><a class=\"cke_widget_editable cke_widget_element\" href=\"https://item.jd.com/14020415.html\" rel=\"noopener nofollow\" title=\"《FFmpeg开发实战：从零基础到短视频上线》\">《FFmpeg开发实战：从零基础到短视频上线》</a>一书。</span></p>\n\n<span>\n<span>​</span></span>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-27 12:00</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aqi00\">aqi00</a>&nbsp;\n阅读(<span id=\"post_view_count\">154</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "使用Gradio构建AI前端 - RAG的QA模块",
      "link": "https://www.cnblogs.com/aspnetx/p/19408276",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aspnetx/p/19408276\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 11:28\">\n    <span>使用Gradio构建AI前端 - RAG的QA模块</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文将基于Gradio的Interface，继续构建RAG系统的QA前端页面，对比上一篇对召回测试前端页面的构建，来对比在Gradio下，Blocks和Interface的两种区别。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"使用gradio构建ai前端---rag的qa模块\">使用Gradio构建AI前端 - RAG的QA模块</h1>\n<h2 id=\"摘要\">摘要</h2>\n<p>本文将基于Gradio的Interface，继续构建RAG系统的QA前端页面，对比上一篇对召回测试前端页面的构建，来对比在Gradio下，Blocks和Interface的两种区别。</p>\n<h2 id=\"gradio-interface简介\">Gradio Interface简介</h2>\n<p>Gradio 是一个用于快速创建机器学习和数据科学演示界面的Python库，允许开发者通过简单代码将函数转换为交互式Web应用，无需前端开发经验。<code>gr.Interface</code> 是 Gradio 提供的一种快速创建界面的方式，适用于简单的输入输出场景，采用\"函数驱动\"模式，直接将函数与输入输出组件绑定。</p>\n<h3 id=\"核心特点\">核心特点：</h3>\n<ul>\n<li>结构简单，适合快速原型开发</li>\n<li>输入输出组件按固定布局排列</li>\n<li>基于函数映射，直接将输入传递给函数并展示输出</li>\n</ul>\n<p>综上汇总，主要的特点就是简单，快。</p>\n<h3 id=\"interface-与-blocks-的区别\">Interface 与 Blocks 的区别</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Interface</th>\n<th>Blocks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>复杂度</td>\n<td>简单，适合快速搭建</td>\n<td>灵活，适合复杂界面</td>\n</tr>\n<tr>\n<td>布局控制</td>\n<td>自动布局，结构固定</td>\n<td>完全自定义布局</td>\n</tr>\n<tr>\n<td>交互逻辑</td>\n<td>基于单一函数映射</td>\n<td>支持多函数、事件触发</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>简单输入输出场景</td>\n<td>复杂交互、多步骤流程</td>\n</tr>\n</tbody>\n</table>\n<p>相对来说，Interface的构建方式比Blocks要更简单，代码量更少。<br />\n通过下面的代码，可以看到跟Blocks有明显的区别。</p>\n<h3 id=\"代码示例\">代码示例：</h3>\n<pre><code class=\"language-python\"># 创建Gradio Interface\niface = gr.Interface(\n    fn=run_qa,  # 核心处理函数\n    inputs=[    # 输入组件列表\n        gr.Textbox(\n            label=\"问题\",\n            placeholder=\"请输入您的问题...\",\n            lines=3,\n            info=\"例如: '哪些节假日应该安排休假？' 或 '什么是未成年？'\"\n        ),\n        gr.Slider(\n            label=\"Top-K检索数量\",\n            minimum=1,\n            maximum=10,\n            value=5,\n            step=1,\n            info=\"设置返回的最相似文档数量\"\n        )\n    ],\n    outputs=gr.Markdown(  # 输出组件\n        label=\"回答结果\"\n    ),\n    title=\"🤖 RAG问答系统\",\n    description=\"基于LangChain和Gradio构建的RAG问答系统，使用向量数据库进行知识检索\",\n    examples=[  # 示例问题\n        [\"哪些节假日应该安排休假？\", 5],\n        [\"什么是未成年？\", 3],\n        [\"足球比赛的基本规则是什么？\", 4]\n    ],\n    theme=gr.themes.Soft(),\n    allow_flagging=\"never\"  # 禁用标记功能\n)\n</code></pre>\n<p>下面是构建界面的样子：<br />\n<img alt=\"img\" src=\"https://img2024.cnblogs.com/blog/8622/202512/8622-20251227112605131-876188573.png\" /></p>\n<p>通过以上代码，可以看到在gr.Interface里，首先指定捆绑的是哪一个function，然后在inputs和outputs，依次创建对应的前端组件，并且对应function里的输入参数和返回值。<br />\n这段代码调用项目里已经封装好的LC_RAG_03_QA.py里的方法。</p>\n<h3 id=\"关键区别点\">关键区别点：</h3>\n<p>对比上一篇，这里汇总了Interface方式和Blocks两种方式的区别。</p>\n<ol>\n<li>\n<p><strong>布局控制</strong>：</p>\n<ul>\n<li>Interface：自动排列输入输出，无需手动控制布局</li>\n<li>Blocks：通过 <code>gr.Row()</code>、<code>gr.Column()</code> 等手动控制组件布局</li>\n</ul>\n</li>\n<li>\n<p><strong>事件处理</strong>：</p>\n<ul>\n<li>Interface：自动关联输入输出和处理函数</li>\n<li>Blocks：需要显式通过 <code>.click()</code> 等方法绑定事件</li>\n</ul>\n</li>\n<li>\n<p><strong>灵活性</strong>：</p>\n<ul>\n<li>Interface：适合简单场景，代码量少</li>\n<li>Blocks：适合复杂界面，支持条件显示、多步骤交互等高级功能</li>\n</ul>\n</li>\n<li>\n<p><strong>结构组织</strong>：</p>\n<ul>\n<li>Interface：通过参数配置界面元素</li>\n<li>Blocks：使用上下文管理器（<code>with</code> 语句）组织界面结构</li>\n</ul>\n</li>\n</ol>\n<p>在本案例中，使用 <code>gr.Interface</code> 代码更简洁高效。如果需要更复杂的交互（如多步骤处理、条件显示组件等），则应选择 <code>gr.Blocks</code>。<br />\n所以如果是对模型功能的评估，建议选择gr.Interface，如果是做原型设计，建议选择gr.Blocks。</p>\n<p>本文项目代码可以在以下仓库里找到：<br />\n<a href=\"https://github.com/microsoftbi/Langchain_DEMO/tree/main/RAG\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/microsoftbi/Langchain_DEMO/tree/main/RAG</a><br />\n此篇对应的代码是：LC_RAG_07c_Gradio.py</p>\n<p>这里再补充一个快速的方法，就是借助AI开发工具，比如TRAE，以下是我用的提示词，仅供参考：</p>\n<pre><code class=\"language-Prompt\">在当前python文件中，编写一个QA的前端界面，前端框架使用Gradio，不要使用blocks的方式构建页面，直接使用interface的方式来构建，使用的方法，调用LC_RAG_03_QA.py里的answer_question方法。\n</code></pre>\n<p>虽然在我使用的过程中，代码无法一次通过，但基本上通过一次反馈就可以修补成功，从而省下了这部分代码的工作量。</p>\n<details>\n以下是代码的全部内容，点击展开。\n<pre><code class=\"language-Python\">import gradio as gr\nfrom LC_RAG_03_QA import answer_question\n\ndef run_qa(question, top_k=5):\n    \"\"\"运行QA并返回结果\"\"\"\n    try:\n        answer, sources = answer_question(\n            question=question,\n            top_k=top_k,\n            vectorstore_dir=\"./RAG/chroma_db\",\n            embedding_model=\"text-embedding-v4\"\n        )\n        \n        # 格式化结果\n        result = f\"# 🎯 答案\\n\\n{answer}\\n\"\n        \n        if sources:\n            result += \"\\n# 📚 参考来源\\n\"\n            for source in sources:\n                result += f\"- {source}\\n\"\n        \n        return result\n    except Exception as e:\n        return f\"❌ 错误: {str(e)}\"\n\n# 创建Gradio Interface\niface = gr.Interface(\n    fn=run_qa,\n    inputs=[\n        gr.Textbox(\n            label=\"问题\",\n            placeholder=\"请输入您的问题...\",\n            lines=3,\n            info=\"例如: '哪些节假日应该安排休假？' 或 '什么是未成年？'\"\n        ),\n        gr.Slider(\n            label=\"Top-K检索数量\",\n            minimum=1,\n            maximum=10,\n            value=5,\n            step=1,\n            info=\"设置返回的最相似文档数量\"\n        )\n    ],\n    outputs=gr.Markdown(\n        label=\"回答结果\"\n    ),\n    title=\"🤖 RAG问答系统\",\n    description=\"基于LangChain和Gradio构建的RAG问答系统，使用向量数据库进行知识检索\",\n    examples=[\n        [\"哪些节假日应该安排休假？\", 5],\n        [\"什么是未成年？\", 3],\n        [\"足球比赛的基本规则是什么？\", 4]\n    ],\n    theme=gr.themes.Soft(),\n    allow_flagging=\"never\"\n)\n\n# 启动应用\nif __name__ == \"__main__\":\n    iface.launch(\n        server_name=\"0.0.0.0\",\n        server_port=7861,\n        share=False,\n        debug=False\n    )\n</code></pre>\n</details>\n</div>\n<div id=\"MySignature\">\n    <p>&nbsp;</p>\n<p>---------------------------------------------------------------</p>\n<p style=\"margin: 0in 0in 10pt;\">aspnetx<span style=\"font-family: SimSun;\">的</span>BI<span style=\"font-family: SimSun;\">笔记系列索引：</span></p>\n<p style=\"margin: 0in 0in 10pt;\"><a href=\"http://www.cnblogs.com/aspnetx/archive/2013/02/25/2931603.html\" target=\"_blank\">使用SQL Server Analysis Services数据挖掘的关联规则实现商品推荐功能</a></p> \n<p style=\"margin: 0in 0in 10pt;\"><a href=\"http://www.cnblogs.com/aspnetx/archive/2013/03/24/2978347.html\" target=\"_blank\">一起玩转SQL Server 2012 下的分析服务</a></p> \n<p style=\"margin: 0in 0in 10pt;\"><a href=\"http://www.cnblogs.com/aspnetx/archive/2013/04/05/3000448.html\" target=\"_blank\">使用SQL Server分析服务定位目标用户  </a></p> \n\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>---------------------------------------------------------------<br /></p>\n<p>来自<a href=\"http://www.cnblogs.com/\" target=\"_blank\">博客园</a>的<a href=\"http://aspnetx.cnblogs.com/\" target=\"_blank\">aspnetx</a><font color=\"white\">宋卫东</font></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-27 11:28</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aspnetx\">哥本哈士奇(aspnetx)</a>&nbsp;\n阅读(<span id=\"post_view_count\">68</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "成为高级 PHP 开发者需要的思维转变",
      "link": "https://www.cnblogs.com/catchadmin/p/19407447",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19407447\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 08:14\">\n    <span>成为高级 PHP 开发者需要的思维转变</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"成为高级-php-开发者需要的思维转变\">成为高级 PHP 开发者需要的思维转变</h1>\n<p>想成为 PHP 高手?先从调整思维开始</p>\n<p>想成为专业的 PHP 开发者?这很好。但在深入研究 PHP 语法或最新框架之前,有一件事你需要明确:你的思维方式。</p>\n<p>事实上,这不仅仅是写代码——成为 PHP 专业人士意味着用不同的方式思考。这关乎你如何处理问题、如何与他人协作,以及如何成长。当然,深入了解 PHP 很重要,但正确的思维方式才是在 PHP 领域脱颖而出的真正关键。</p>\n<p>本文将讨论能让你从 PHP 新手成长为专业开发者的关键思维转变。准备好提升了吗?开始吧。</p>\n<p><a href=\"https://catchadmin.com/post/2025-12/the-mindset-shifts-you-need-to-become-a-rockstar-php-developer\" rel=\"noopener nofollow\" target=\"_blank\">原文链接 成为高级 PHP 开发者需要的思维转变</a></p>\n<h2 id=\"转变-1从只是写代码到解决实际问题\">转变 1:从\"只是写代码\"到\"解决实际问题\"</h2>\n<p>写代码很酷,但解决问题更酷</p>\n<p>说实话:任何人都能写代码。但写出能解决实际问题的代码?这才是关键所在。作为初学者,很容易迷失在语法细节和函数调用中,但重点是:编码只是工具。作为 PHP 开发者,你的工作不仅仅是敲代码——而是以最佳方式解决问题。</p>\n<p><strong>技术实践:在编码前先分解问题</strong></p>\n<p>在打开代码编辑器之前,先将问题分解成可管理的小块。使用流程图或伪代码等工具来规划逻辑。这种方法不仅能理清思路,还能帮你尽早发现边界情况和潜在陷阱。</p>\n<p>示例:<br />\n构建购物车时,先为添加商品、计算总价和管理会话持久化编写伪代码。然后在 PHP 中有条不紊地实现每一步。例如:</p>\n<pre><code class=\"language-php\">// Pseudocode: Add item to cart\nif (!isset($_SESSION['cart'])) {\n    $_SESSION['cart'] = array();\n}\narray_push($_SESSION['cart'], $item);\n</code></pre>\n<p>这种结构化方法将编码转变为解决问题,而不仅仅是随意写代码。</p>\n<h2 id=\"转变-2从复制粘贴编码到理解并掌控你的代码\">转变 2:从\"复制粘贴编码\"到\"理解并掌控你的代码\"</h2>\n<p>别再偷懒复制粘贴了(我们都经历过)</p>\n<p>这很诱人,对吧?在 Stack Overflow 上找到快速解决方案,复制粘贴代码,然后收工。但现实是:这在短期内可能有效,但从长远来看是灾难。如果你不理解正在使用的代码,就会遇到无法修复的问题——更糟的是,你会错过学习如何编写真正适合你的代码的机会。</p>\n<p><strong>技术实践:阅读文档并在本地测试</strong></p>\n<p>不要直接复制粘贴,而是先阅读文档。这对理解函数和库的工作原理至关重要。一旦掌握了概念,就在隔离环境中测试它(使用 PHP FPM 或 Xdebug 等工具)来观察它的行为。</p>\n<p>示例:<br />\n在使用第三方 API 之前,彻底阅读其文档。尝试简单的 curl 请求来查看数据格式以及 PHP 如何处理它。不要只依赖教程——自己动手试试。以下是在 PHP 中向 API 发起请求的快速示例:</p>\n<pre><code class=\"language-php\">// Example: Using cURL to send a GET request\n$ch = curl_init();\ncurl_setopt($ch, CURLOPT_URL, \"https://api.example.com/data\");\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n$response = curl_exec($ch);\ncurl_close($ch);\n$data = json_decode($response, true);\nprint_r($data);\n</code></pre>\n<p>现在,你理解了请求过程以及 API 如何响应。</p>\n<h2 id=\"转变-3从独立开发到团队协作\">转变 3:从\"独立开发\"到\"团队协作\"</h2>\n<p>你不是一个人在战斗</p>\n<p>是的,独自完成小项目一开始感觉很好。但一旦进入专业领域,编码就变成了团队运动。作为 PHP 开发者,你经常会与前端开发者、数据库管理员、设计师,有时甚至是项目经理一起工作。你不再是一支单人军队——你是更大图景的一部分。</p>\n<p><strong>技术实践:认真使用版本控制(Git)</strong></p>\n<p>协作意味着共享代码和跟踪变更。这就是版本控制的用武之地。学习 Git 并使用 GitHub 或 GitLab 等平台将使你的代码协作顺畅高效。使用 Git,你可以跟踪变更、回退到以前的版本,并合并多个开发者的代码而不会混乱。</p>\n<p>示例:</p>\n<pre><code class=\"language-bash\"># Initialize a new Git repository\ngit init\n# Add files to the staging area\ngit add .\n# Commit changes with a message\ngit commit -m \"Initial commit\"\n# Push changes to a remote repository\ngit push origin main\n</code></pre>\n<p>Git 不仅适用于大型团队——它对个人项目也至关重要,因为它能帮你有效管理变更。与他人合作时,拉取请求和代码审查对于维护高质量代码至关重要。</p>\n<h2 id=\"转变-4从追逐流行框架到掌握基础\">转变 4:从\"追逐流行框架\"到\"掌握基础\"</h2>\n<p>框架很有趣,但基础才是永恒的</p>\n<p>Laravel、Symfony 和 CodeIgniter 等 PHP 框架很棒,但问题是:在深入研究任何框架之前,你需要对 PHP 本身有扎实的理解。在不理解基础的情况下直接跳入框架,就像在学会走路之前就想跑步。</p>\n<p><strong>技术实践:从零开始构建项目</strong></p>\n<p>在深入研究 Laravel 等框架之前,花时间使用纯 PHP 从零开始构建一个简单项目。例如,构建一个简单的 CRUD(创建、读取、更新、删除)应用,而不依赖任何框架。这将巩固你对以下内容的理解:</p>\n<ul>\n<li>路由</li>\n<li>数据库交互</li>\n<li>会话处理</li>\n<li>用户认证</li>\n</ul>\n<p>示例:<br />\n以下是如何使用 PHP 和 MySQL 设置基本 CRUD 应用:</p>\n<ol>\n<li>创建数据库表:</li>\n</ol>\n<pre><code class=\"language-sql\">CREATE TABLE users (\n  id INT AUTO_INCREMENT PRIMARY KEY,\n  name VARCHAR(100),\n  email VARCHAR(100)\n);\n</code></pre>\n<ol start=\"2\">\n<li>使用 PHP 插入数据:</li>\n</ol>\n<pre><code class=\"language-php\">// Establish a connection\n$conn = new mysqli(\"localhost\", \"username\", \"password\", \"database\");\n// Check for connection error\nif ($conn-&gt;connect_error) {\n    die(\"Connection failed: \" . $conn-&gt;connect_error);\n}\n// Insert data\n$sql = \"INSERT INTO users (name, email) VALUES ('John Doe', 'john@example.com')\";\nif ($conn-&gt;query($sql) === TRUE) {\n    echo \"New record created successfully\";\n} else {\n    echo \"Error: \" . $sql . \"&lt;br&gt;\" . $conn-&gt;error;\n}\n$conn-&gt;close();\n</code></pre>\n<p>在不使用框架的情况下构建项目将让你深入理解底层工作原理,这会让你在之后使用 Laravel 等框架时感觉轻松许多。</p>\n<h2 id=\"转变-5从一次性学习到持续学习\">转变 5:从\"一次性学习\"到\"持续学习\"</h2>\n<p>学习永无止境</p>\n<p>如果你认为学完 PHP 和几个框架就\"完成\"了,那就再想想。技术世界发展迅速,作为专业开发者,你需要跟上步伐。优秀的 PHP 开发者不仅仅是知道如何写代码的人;而是不断进化、适应并保持好奇心的人。</p>\n<p><strong>技术实践:关注 PHP 变更日志和博客</strong></p>\n<p>及时了解 PHP 版本和最佳实践。订阅博客,关注 PHP 相关新闻,并阅读每个新版本发布的官方 PHP 变更日志。了解 PHP 8 中的新特性(如 JIT 和属性)将使你的代码保持现代和高效。</p>\n<p>示例:<br />\n在 PHP 8 中,match 表达式可以成为 switch-case 的更简洁替代方案。如果你还没试过,现在就试试!</p>\n<pre><code class=\"language-php\">$fruit = 'apple';\necho match($fruit) {\n    'apple' =&gt; 'It's an apple!',\n    'banana' =&gt; 'It's a banana!',\n    default =&gt; 'Unknown fruit',\n};\n</code></pre>\n<p>这种新语法更紧凑,消除了多个 case 语句的需要。</p>\n<h2 id=\"转变-6从快速修复到长期解决方案\">转变 6:从\"快速修复\"到\"长期解决方案\"</h2>\n<p>写出你会引以为豪的代码(而不仅仅是能用的代码)</p>\n<p>我们都经历过。紧迫的截止日期、压力,以及随便拼凑点东西的诱惑。但问题是:编写快速而粗糙的代码现在可能完成工作,但以后会反噬你。糟糕的代码会导致 bug、性能问题和巨大的麻烦。</p>\n<p><strong>技术实践:编写可测试、可扩展的代码</strong></p>\n<p>确保代码保持整洁和可扩展的一种方法是编写测试。使用 PHPUnit 进行单元测试来验证代码的每个部分是否按预期工作。</p>\n<p>示例:<br />\n以下是一个简单的 PHPUnit 测试,用于测试计算购物车中商品总价的方法:</p>\n<pre><code class=\"language-php\">use PHPUnit\\Framework\\TestCase;\nclass ShoppingCartTest extends TestCase\n{\n    public function testTotalPrice()\n    {\n        $cart = new ShoppingCart();\n        $cart-&gt;addItem('Apple', 1.50);\n        $cart-&gt;addItem('Banana', 1.00);\n        \n        $this-&gt;assertEquals(2.50, $cart-&gt;getTotalPrice());\n    }\n}\n</code></pre>\n<p>单元测试有助于尽早发现 bug,并确保在添加新功能时,现有功能不会出问题。</p>\n<h2 id=\"结语转变思维让你的-php-职业生涯腾飞\">结语:转变思维,让你的 PHP 职业生涯腾飞</h2>\n<p>成为 PHP 专业人士远不止于写代码——这关乎像问题解决者一样思考、深入理解你的工具、与他人协作,以及致力于持续成长。如果你今天开始进行这些思维转变,你将顺利成为一名抢手的 PHP 开发者。</p>\n<p>所以,下次坐下来编码时,记住:这不仅仅是完成工作——而是以正确的方式、专业的方式去做。祝编码愉快!</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-27 08:14</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">93</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "FFmpeg开发笔记（九十六）采用Kotlin+Compose的视频编辑器OpenVideoEditor",
      "link": "https://www.cnblogs.com/aqi00/p/19319703",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aqi00/p/19319703\" id=\"cb_post_title_url\" title=\"发布于 2025-12-28 11:00\">\n    <span>FFmpeg开发笔记（九十六）采用Kotlin+Compose的视频编辑器OpenVideoEditor</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<span><span>​</span></span><span id=\"cke_bm_426S\">《FFmpeg开发实战：从零基础到短视频上线》一书的“第 12 章 &nbsp;FFmpeg的移动开发”介绍了如何使用FFmpeg在手机上播放视频，基于FFmpeg的国产播放器开源框架也有很多了，前有哔哩哔哩的ijkplayer，后有小红书的RedPlayer，参见之前的文章《使用国产的ijkplayer播放器观看网络视频》和《使用国产的RedPlayer播放器观看网络视频》。</span>\n<p><span id=\"cke_bm_426S\"> 除此以外，OpenVideoEditor也是一款优秀的Android原生视频编辑器，该框架基于Kotlin+Compose开发，并采用Media3和Jetpack Compose构建，贴近最新的Android开发技术。OpenVideoEditor支持裁剪、灰度、反转、缩放、旋转、调整分辨率等常见的视频剪辑功能，可谓功能强大。<br />\nOpenVideoEditor的源码托管地址为https://github.com/devhyper/open-video-editor（星星数0.5k），国内的镜像地址为https://gitcode.com/gh_mirrors/op/open-video-editor，最新版本是2024年9月发布的v1.1.3，可见该框架的源码更新十分及时，该版本的源码下载地址为https://github.com/devhyper/open-video-editor/archive/refs/tags/v1.1.3.tar.gz。<br />\n并且OpenVideoEditor的源码采用Kotlin+Compose编写，适合Android开发者用作进阶练习，不过由于OpenVideoEditor引入了最新的Android开发技术，因此需要使用较新的Android Studio才能成功导入运行。接下来以Android Studio Ladybug（小瓢虫版本）为例，介绍如何通过Android Studio编译运行OpenVideoEditor的demo工程。<br />\n为了加快OpenVideoEditor项目的加载速度，可打开settings.gradle.kts，在repositories节点内部补充以下配置：</span></p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected\">\n<pre class=\"cke_widget_element\"><code class=\"hljs\">// 以下四行添加阿里云的仓库地址，方便国内开发者下载相关插件\nmaven { url = uri(\"https://maven.aliyun.com/repository/jcenter\") }\nmaven { url = uri(\"https://maven.aliyun.com/repository/google\")}\nmaven { url = uri(\"https://maven.aliyun.com/repository/gradle-plugin\")}\nmaven { url = uri(\"https://maven.aliyun.com/repository/public\")}\n// 以下添加清华大学的仓库地址\nmaven { url = uri(\"https://mirrors.tuna.tsinghua.edu.cn/repository/maven-central/\") }</code></pre>\n</div>\n<p>增加以上配置的目的是引入国内的仓库地址，以便加快相关依赖包的下载速度。<br />\n等待OpenVideoEditor工程编译通过，把demo应用安装到手机上，启动之后的App界面如下图所示：</p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_image cke_image_nocaption cke_widget_selected\">\n<p class=\"img-center cke_widget_element\"><span class=\"cke_image_resizer_wrapper\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><img alt=\"ove1\" class=\"lazyload\" height=\"640\" width=\"297\" /></span></span></p>\n</div>\n<p>点击【视频】按钮，先到系统相册选择一个视频文件，返回的加工界面如下图所示：</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"ove2\" class=\"lazyload\" height=\"625\" width=\"295\" /></span></span></span></span></p>\n<p>点击加工界面右下角的方形按钮，弹出底部选择菜单如下图所示：</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"ove3\" class=\"lazyload\" height=\"624\" width=\"294\" /></span></span></span></span></p>\n<p>点击【剪辑】菜单项，表示根据起止时间裁剪视频片段。此时界面下方的进度条出现两个圆珠，第一个圆珠代表裁剪开始时间，第二个圆珠代表裁剪结束时间，如下图所示：</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"ove4\" class=\"lazyload\" height=\"629\" width=\"296\" /></span></span></span></span></p>\n<p>分别拖动两个圆珠确定裁剪的起止时间后，点击右下角的打勾按钮，此时进度条长度变为视频片段的持续时间比如10秒。点击界面右上角的三点按钮，弹出操作菜单列表如下图所示：</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"ove5\" class=\"lazyload\" height=\"624\" width=\"294\" /></span></span></span></span></p>\n<p>点击【导出】菜单项，弹出保存文件的配置界面如下图所示：</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"ove6\" class=\"lazyload\" height=\"634\" width=\"297\" /></span></span></span></span></p>\n<p>在配置界面可以选择导出方式与音视频的编码格式，点击右下角的导出按钮跳到保存目录的选择界面，选择某个公共目录比如Download，即可将视频片段保存到Download目录。<br />\n总结一下，OpenVideoEditor确实使用简单，剪辑功能也丰富，是个未来可期的下一代视频编辑器。</p>\n<p>更多详细的FFmpeg开发知识参见<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\"><a class=\"cke_widget_editable cke_widget_element\" href=\"https://item.jd.com/14020415.html\" rel=\"noopener nofollow\" title=\"《FFmpeg开发实战：从零基础到短视频上线》\">《FFmpeg开发实战：从零基础到短视频上线》</a>一书。</span></p>\n\n<span>\n<span>​</span></span>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-28 11:00</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aqi00\">aqi00</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Spring Boot Pf4j模块化开发设计方案",
      "link": "https://www.cnblogs.com/CreateMyself/p/19410226",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/CreateMyself/p/19410226\" id=\"cb_post_title_url\" title=\"发布于 2025-12-28 10:33\">\n    <span>Spring Boot Pf4j模块化开发设计方案</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2>前言</h2>\n<p><span style=\"font-size: 14px;\">上一篇文章还是2年前，一是工作太忙，二是人也变得懒散，好多新东西仅止于脑海里面的印象，未能深入，不成体系，最近主要花了些时间实现Java版本的模块化，同时也要重点兼顾小伙伴们从.NET Core移植模块的成本，所以需要全盘考虑的东西会更加实际，好在有些Java底子加上AI的出现，实现的过程相对会容易一些，最近对AGI提起兴趣，接下来应该会重点学习这方面的应用开发再来和大家分享，好了，话不多说，接下来的系列文章会讲讲Java版本的模块化，和大家一起探讨探讨，或许有更好的一些建议，我能学习到更多。</span></p>\n<h3>Spring Pf4j实现效果</h3>\n<p><span style=\"font-size: 14px;\">我们选择【<a href=\"https://github.com/pf4j/pf4j\" rel=\"noopener nofollow\" target=\"_blank\" title=\"https://github.com/pf4j/pf4j\">https://github.com/pf4j/pf4j</a>】作为Java模块化的基础设施，虽然官方作者提供了pf4j-spring的版本基础使用，但能力太弱（主要作者对spring boot好像不是非常熟悉，并没有任何贬低意思，在相关issue作者也做出了表明），尤其是我们还要考虑.NET Core模块的移植，所以不能完全开箱即用，所以我对其进行二次封装。二次封装为Spring版本，注意这里我说的是<span style=\"color: rgba(255, 102, 0, 1);\">封装为Spring，而不是SpringBoot，因为SpringBoot是Web应用，而Spring提供了SpringBoot的基础能力，所以我们只需要引入Spring基础包即可，万万不可将SpringBoot全家桶引入到模块化基础设施，这点考虑非常重要</span>。最终插件只需要继承封装的插件类即可</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/589642/202512/589642-20251227224452189-2117122159.png\" /></p>\n<p><span style=\"font-size: 14px;\">插件开发者可重写beforeApplicationContextRefresh和afterApplicationContextReady，熟悉.NET Core开发的伙伴们应该能猜到等同于ConfigureServices和Configure方法，在before方法里可自定义手动注册相关bean（当然常见的component和bean等注解会自动注册），而after则是上下文刷新完成后可做业务上的初始化工作</span></p>\n<h3>Spring Pf4j上下文</h3>\n<p><span style=\"font-size: 14px;\">每个插件有独立的上下文，所以在启动插件时需创建插件上下文，完成创建插件上下文分为4个步骤，一是初始化上下文，二是提供上述抽象开发者可重写的手动注册，三是刷新插件上下文，四是上述插件利用上下文进行相关业务初始化操作</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">private</span><span style=\"color: rgba(0, 0, 0, 1);\"> ApplicationContext createApplicationContext() {\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">long</span> startTs =<span style=\"color: rgba(0, 0, 0, 1);\"> System.currentTimeMillis();\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step 1: Pre-create application context</span>\n        log.info(\"Initializing base context for plugin '{}'\"<span style=\"color: rgba(0, 0, 0, 1);\">, pluginId);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">long</span> preCreateStart =<span style=\"color: rgba(0, 0, 0, 1);\"> System.currentTimeMillis();\n        AnnotationConfigApplicationContext annotationContext </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> preCreateApplicationContext();\n        log.info(</span>\"Initialized base context for plugin '{}' in {} ms\"<span style=\"color: rgba(0, 0, 0, 1);\">,\n                pluginId, System.currentTimeMillis() </span>-<span style=\"color: rgba(0, 0, 0, 1);\"> preCreateStart);\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step 2: Customize context before refresh</span>\n        log.info(\"Customizing context configuration for plugin '{}'\"<span style=\"color: rgba(0, 0, 0, 1);\">, pluginId);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">long</span> handleStart =<span style=\"color: rgba(0, 0, 0, 1);\"> System.currentTimeMillis();\n        AnnotationConfigApplicationContext context </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> beforeApplicationContextRefresh(annotationContext);\n        log.info(</span>\"Customized context configuration for plugin '{}' in {} ms\"<span style=\"color: rgba(0, 0, 0, 1);\">,\n                pluginId, System.currentTimeMillis() </span>-<span style=\"color: rgba(0, 0, 0, 1);\"> handleStart);\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (context == <span style=\"color: rgba(0, 0, 255, 1);\">null</span><span style=\"color: rgba(0, 0, 0, 1);\">) {\n            context </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> annotationContext;\n        }\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step 3: Refresh the context (load beans, etc.)</span>\n        log.info(\"Refreshing Spring context for plugin '{}'\"<span style=\"color: rgba(0, 0, 0, 1);\">, pluginId);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">long</span> postCreateStart =<span style=\"color: rgba(0, 0, 0, 1);\"> System.currentTimeMillis();\n        postCreateApplicationContext(context);\n        log.info(</span>\"Refreshed Spring context for plugin '{}' in {} ms\"<span style=\"color: rgba(0, 0, 0, 1);\">,\n                pluginId, System.currentTimeMillis() </span>-<span style=\"color: rgba(0, 0, 0, 1);\"> postCreateStart);\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step 4: Post-refresh custom logic</span>\n        log.info(\"Executing post-refresh logic for plugin '{}'\"<span style=\"color: rgba(0, 0, 0, 1);\">, pluginId);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">long</span> customStart =<span style=\"color: rgba(0, 0, 0, 1);\"> System.currentTimeMillis();\n        afterApplicationContextReady(context);\n        log.info(</span>\"Completed post-refresh logic for plugin '{}' in {} ms\"<span style=\"color: rgba(0, 0, 0, 1);\">,\n                pluginId, System.currentTimeMillis() </span>-<span style=\"color: rgba(0, 0, 0, 1);\"> customStart);\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Total time</span>\n        log.info(\"Plugin '{}' context fully initialized in {} ms\"<span style=\"color: rgba(0, 0, 0, 1);\">,\n                pluginId, System.currentTimeMillis() </span>-<span style=\"color: rgba(0, 0, 0, 1);\"> startTs);\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> context;\n    }</span></pre>\n</div>\n<p><span style=\"font-size: 14px;\">整个步骤最重要的属于初始化插件的上下文，这里贴一下伪代码</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/589642/202512/589642-20251227230519613-1831320936.png\" /></p>\n<h3><span style=\"font-size: 14px;\">Spring控制器动态注册&nbsp;</span></h3>\n<p><span style=\"font-size: 14px;\">控制器的动态注册必然是等插件上下文刷新完成后去通过插件上下文获取控制器bean，同时基于控制器的请求处理映射为RequestMappingHandlerMapping，所以我们需要实现自定义的请求处理映射，这里我们暂时只需考虑控制器及其方法的动态注册</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span> GJPluginRequestMappingHandlerMapping <span style=\"color: rgba(0, 0, 255, 1);\">extends</span><span style=\"color: rgba(0, 0, 0, 1);\"> RequestMappingHandlerMapping {\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">final</span> Logger log = LoggerFactory.getLogger(GJPluginRequestMappingHandlerMapping.<span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n    @Override\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> detectHandlerMethods(@NotNull Object controller) {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">super</span><span style=\"color: rgba(0, 0, 0, 1);\">.detectHandlerMethods(controller);\n    }\n}</span></pre>\n</div>\n<p><span style=\"font-size: 14px;\">我们将上述自定义请求映射处理作为bean注册到主应用，然后在插件上下文创建完成后，获取注册到主应用的自定义请求处理映射，传入插件，伪代码如下：</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">GJPluginLifecycle registerController() {\n        GJPluginRequestMappingHandlerMapping pluginRequestMappingHandlerMapping </span>= plugin.getMainApplicationContext()<br />　　　　　　　　.getBean(\"pluginRequestMappingHandlerMapping\", GJPluginRequestMappingHandlerMapping.<span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        pluginRequestMappingHandlerMapping.registerControllers(plugin);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(0, 0, 255, 1);\">this</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n    }</span></pre>\n</div>\n<p><span style=\"font-size: 14px;\">插件上下文获取控制器bean，并将插件控制器bean注册到主应用上下文以及控制器方法注册到自定义的请求处理映射中</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> Set&lt;Object&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> getControllerBeans(GJPlugin springBootPlugin) {\n        ApplicationContext applicationContext </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> springBootPlugin.getApplicationContext();\n        Set</span>&lt;Object&gt; beans = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> LinkedHashSet&lt;&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n\n        Map</span>&lt;String, Object&gt; controllerBeans = applicationContext.getBeansWithAnnotation(Controller.<span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        Map</span>&lt;String, Object&gt; restControllerBeans = applicationContext.getBeansWithAnnotation(RestController.<span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n        beans.addAll(controllerBeans.values());\n        beans.addAll(restControllerBeans.values());\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (log.isTraceEnabled()) {\n            List</span>&lt;String&gt; names =<span style=\"color: rgba(0, 0, 0, 1);\"> beans.stream()\n                    .map(b </span>-&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> b.getClass().getSimpleName())\n                    .collect(Collectors.toList());\n            log.debug(</span>\"Scanned {} controller beans: {}\"<span style=\"color: rgba(0, 0, 0, 1);\">, beans.size(), names);\n        }\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> beans;\n    }</span></pre>\n</div>\n<p><span style=\"font-size: 14px;\">我们再来遍历插件中所有控制器列表，进行动态注册即可</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/589642/202512/589642-20251227233218634-756014769.png\" /></p>\n<h3>SpringDoc-OpenApi</h3>\n<p><span style=\"font-size: 14px;\">上述为整个模块化或者插件化的设计方案，我们首先需要实现的第一个则是Swagger，将所有插件接口列表能够在主应用启动完成后在swagger页面里呈现出来，但我们插件控制器为动态注册，那么这里如何设计呢，我们一步步来。首先是在主应用引入openapi的包</span></p>\n<div class=\"cnblogs_code\">\n<pre> &lt;dependency&gt;\n        &lt;groupId&gt;org.springdoc&lt;/groupId&gt;\n        &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;\n &lt;/dependency&gt;</pre>\n</div>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/589642/202512/589642-20251227235215612-1285800634.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/589642/202512/589642-20251227235236681-1774366582.png\" /></p>\n<p><span style=\"font-size: 14px;\">上述只是主应用定义的控制器已被呈现，但要使得动态注册的插件控制器在主应用启动后也能在swagger中呈现出来，我们还需要完成3个步骤，一是在插件基础设施中引入openapi，插件化基础设施尽可能轻量，无需引入springdoc-openapi-starter-webmvc-ui，建议引入springdoc-openapi-starter-common包即可，如此插件只需对控制器等等打上标签，其他应该都用不到。二是插件注册时需要构建插件控制器的GroupedOpenApi（即每个插件对应一个GroupedOpenApi），并将其注册到主应用上下文，三是主应用需要支持动态注册多GroupedOpenApi。</span><span style=\"font-size: 14px;\">我们重点关注步骤2和步骤3，在主应用yml配置文件中对spring-doc的相关配置过于简单此处忽略不讲，为了实现多模块的动态注册，需要使用springdoc-OpenApi的多GroupedOpenApi延迟注册，如下为通用方案</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">@Configuration\n</span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> SpringDocOpenApiCfg {\n\n    @Bean\n    MultipleOpenApiWebMvcResource multipleOpenApiResource(List</span>&lt;GroupedOpenApi&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> groupedOpenApis,\n                                                          ObjectFactory</span>&lt;OpenAPIService&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> defaultOpenAPIBuilder,\n                                                          AbstractRequestService requestBuilder,\n                                                          GenericResponseService responseBuilder,\n                                                          OperationService operationParser,\n                                                          SpringDocConfigProperties springDocConfigProperties,\n                                                          SpringDocProviders springDocProviders,\n                                                          SpringDocCustomizers springDocCustomizers) {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> MultipleOpenApiWebMvcResource(groupedOpenApis,\n                defaultOpenAPIBuilder, requestBuilder,\n                responseBuilder, operationParser,\n                springDocConfigProperties,\n                springDocProviders,\n                springDocCustomizers);\n    }\n}</span></pre>\n</div>\n<p><span style=\"font-size: 14px;\">&nbsp;我们封装插件的注册GroupedOpenApi逻辑，如下：</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> GJPluginOpenApiInfo {\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">/**</span><span style=\"color: rgba(0, 128, 0, 1);\">\n     * 获取插件Swagger分组名称（插件ID即为组名）\n     </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">public</span><span style=\"color: rgba(0, 0, 0, 1);\"> String getGroupName;\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span><span style=\"color: rgba(0, 0, 0, 1);\"> String getGroupName() {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> getGroupName;\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> setGroupName(String getGroupName) {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">this</span>.getGroupName =<span style=\"color: rgba(0, 0, 0, 1);\"> getGroupName;\n    }\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">/**</span><span style=\"color: rgba(0, 128, 0, 1);\">\n     * 获取插件Controller所在包\n     </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">private</span> List&lt;String&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> getControllerPackages;\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span> setControllerPackages(List&lt;String&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> getControllerPackages) {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">this</span>.getControllerPackages =<span style=\"color: rgba(0, 0, 0, 1);\"> getControllerPackages;\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> List&lt;String&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> getControllerPackages() {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> getControllerPackages;\n    }\n}</span></pre>\n</div>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> GJPluginOpenApiConfig {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">final</span> String PLUGIN_SWAGGER_BEAN_PREFIX = \"pluginGroupedOpenApi-\"<span style=\"color: rgba(0, 0, 0, 1);\">;\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> registerPluginOpenApiBeans(GJPlugin springBootPlugin, GJPluginOpenApiInfo pluginSwaggerInfo) {\n        String groupName </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> pluginSwaggerInfo.getGroupName();\n        groupName </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> groupName.trim().toLowerCase();\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (groupName.trim().isEmpty()) {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        }\n        String beanName </span>= PLUGIN_SWAGGER_BEAN_PREFIX +<span style=\"color: rgba(0, 0, 0, 1);\"> groupName;\n        String finalGroupName </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> groupName;\n        GroupedOpenApi groupedOpenApi </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> GroupedOpenApi.builder()\n                .group(finalGroupName.trim())\n                .displayName(finalGroupName.trim())\n                .packagesToScan(pluginSwaggerInfo.getControllerPackages().toArray(</span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> String[0<span style=\"color: rgba(0, 0, 0, 1);\">]))\n                .build();\n        springBootPlugin.registerBeanToMainContext(beanName, groupedOpenApi);\n    }\n}</span></pre>\n</div>\n<p><span style=\"font-size: 14px;\">在上述我们遍历控制器列表动态注册控制器时，此时调用上述封装注册插件的GroupedOpenApi，代码如下：</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/589642/202512/589642-20251228003512160-145888737.png\" /></p>\n<p>我们搞一个Demo插件控制器，看能不能在swagger界面中呈现出来</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/589642/202512/589642-20251228003756396-319448334.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/589642/202512/589642-20251228003905829-287067209.png\" /></p>\n<p><span style=\"font-size: 14px;\">此时我们发现插件GroupedOpenApi有了，但插件接口列表没有呈现，同时主应用的接口列表悄无声息已无，于是乎开始自定义OpenApiResource调试等等系列操作，底层最后在构建计算接口列表等等时有一个方法引起重要关注</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/589642/202512/589642-20251228004518493-339438381.png\" /></p>\n<p><span style=\"font-size: 14px;\">上述严格判断插件控制器方法的bean到底是不是属于对应的控制器，于是我们回过头去看我们动态注册控制器的bean和将控制器的方法注册到请求处理映射的逻辑，如下再重点标识一下，以免小伙伴们忘记了</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/589642/202512/589642-20251228004921094-137300325.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/589642/202512/589642-20251228005758785-312112906.png\" /></p>\n<p><span style=\"font-size: 14px;\">未曾注意到这一细节，我们发现了问题，注册控制器到主应用上下文的bean用的控制器名称，而将控制器方法的注册传入的是控制器对象而不是简单的控制器名称，所以获取到的方法控制器bean则是控制器的hash值，而控制器的bean实际是字符串，所以传入方法的控制器也修改为控制器的名称</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/589642/202512/589642-20251228005624285-1271287822.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/589642/202512/589642-20251228005857034-959304914.png\" /></p>\n<h2>总结</h2>\n<p><span style=\"font-size: 14px;\">如上基于pf4j二次封装的整个设计思路，其中还涉及一些细节并未详细展开，细节主要是对pf4j底层实现的深入了解，然后在封装以及安全等等上做出了进一步的打磨，若有需要了解的小伙伴们，可在评论留言，我们可一起碰撞碰撞思路，本文暂到此为止，感谢阅读。</span></p>\n</div>\n<div id=\"MySignature\">\n    你所看到的并非事物本身，而是经过诠释后所赋予的意义\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-28 10:33</span>&nbsp;\n<a href=\"https://www.cnblogs.com/CreateMyself\">Jeffcky</a>&nbsp;\n阅读(<span id=\"post_view_count\">16</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}