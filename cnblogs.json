{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "C# .NET 周刊｜2026年1月3期",
      "link": "https://www.cnblogs.com/InCerry/p/-/dotnet_week_26_1_3",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/InCerry/p/-/dotnet_week_26_1_3\" id=\"cb_post_title_url\" title=\"发布于 2026-02-15 20:36\">\n    <span>C# .NET 周刊｜2026年1月3期</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"国内文章\">国内文章</h2>\n<h3 id=\"不服跑个分net-10-大整数计算对阵-java结果令人意外\">不服跑个分？.NET 10 大整数计算对阵 Java，结果令人意外</h3>\n<p><a href=\"https://www.cnblogs.com/sdcb/p/19484525/20261113-big-integer-dotnet-10-vs-java\" target=\"_blank\">https://www.cnblogs.com/sdcb/p/19484525/20261113-big-integer-dotnet-10-vs-java</a></p>\n<p>本文通过对比.NET 的 System.Numerics.BigInteger 和 Java 的 java.math.BigInteger，从性能角度深入分析大数运算的速度。作者探讨了在高精度计算和密码学场景下，两者的表现差异。实验涵盖了加法、乘法和模幂的运算，使用相同开发环境，并严格控制测试变量。文章指出.NET 的 BigInteger 在不可变特性下的公平性，探讨了其性能表现的原因，并附带代码示例。整体内容深入且富有思考，对开发者有实用价值。</p>\n<h3 id=\"一个高性能的-net-mqtt-客户端与服务器库\">一个高性能的 .NET MQTT 客户端与服务器库</h3>\n<p><a href=\"https://www.cnblogs.com/dotnet-org-cn/p/19473369\" target=\"_blank\">https://www.cnblogs.com/dotnet-org-cn/p/19473369</a></p>\n<p>这篇文章介绍了一个高性能的 MQTT 库，完全用 C#实现。它支持 MQTT 3.1.1 和 MQTT 5.0 协议，具备 Broker 桥接和集群功能。库的核心特性包括高性能异步实现、内存管理先进技术和支持 10,000+ 并发连接。文章深入探讨了内存管理技术如 Span、Memory等，以减少内存压力，并使用 async/await 优化 I/O 操作。适配.NET 6.0、8.0 和 10.0 版本，具有极佳的性能和实用性。文中还强调了库的灵活性与企业级特性，是物联网领域的重要工具。</p>\n<h3 id=\"2025-总结篇忙碌的日子里越过-35-岁开启下一个征程\">2025 总结篇，忙碌的日子里越过 35 岁，开启下一个征程</h3>\n<p><a href=\"https://www.cnblogs.com/SunSpring/p/19469874\" target=\"_blank\">https://www.cnblogs.com/SunSpring/p/19469874</a></p>\n<p>文章讲述了作者在 2024 年工作中的转变与挑战。由于部门重组，作者成为技术负责人，面临管理和开发双重任务。重新学习.NET 5+，并在 Java 系统中进行重构，实施微服务架构，使用 Spring Cloud 和 Nacos 等技术，解决系统复杂性与维护问题。实施项目管理工具提升团队效率，经过一年的努力，成功上线新系统并持续优化。作者从中获得了丰富的技术经验和管理心得，对过去经验有了新的认知。</p>\n<h3 id=\"让-winformnet-再次伟大一个专门设计用于帮助-winforms-应用程序迁移到-blazor-wasm-平台的项目\">让 WinForm.NET 再次伟大！一个专门设计用于帮助 WinForms 应用程序迁移到 Blazor WASM 平台的项目</h3>\n<p><a href=\"https://www.cnblogs.com/Can-daydayup/p/19470057\" target=\"_blank\">https://www.cnblogs.com/Can-daydayup/p/19470057</a></p>\n<p>本文讨论了 MWGA 项目，该项目旨在帮助传统 WinForms 应用程序有效迁移至 Blazor WebAssembly(WASM)平台。结合 Blazor 的跨平台特性，MWGA 能够将使用 GDI+ 的应用程序修改量控制在 10% 以内，降低了现代化成本与风险。文章介绍了 WinForms 的背景和实际应用场景，说明了云集成和跨平台访问的需求。作者分享了演示项目的效果，并确认通过 MWGA 迁移后的代码在不同环境下运行逻辑一致。这一项目为企业现代化转型带来了希望，尽管仍需完善。</p>\n<h3 id=\"dbshadow-横空出世dappernet-的天花板盖不住了\">DBShadow 横空出世,Dapper.net 的天花板盖不住了</h3>\n<p><a href=\"https://www.cnblogs.com/xiangji/p/19485861\" target=\"_blank\">https://www.cnblogs.com/xiangji/p/19485861</a></p>\n<p>DBShadow 是一个高性能的.NET 开源 ORM，利用 ShadowSql 和 PocoEmit.Mapper 高效处理 SQL 拼接和映射。与 Dapper 对比，DBShadow 在速度和内存占用上表现更佳。在.NET 8 环境下，DBShadow 比 Dapper 快 10%，并且支持.NET 10，而 Dapper 不支持。使用 BenchmarkDotNet 进行的对比显示，DBShadow 在多种数据库(如 SQLite 和 MySQL)上均优于 Dapper。此文章详细介绍了两者代码实现和性能比较，为开发者提供了实用的参考和数据支持。</p>\n<h3 id=\"原创c开源一分钟使用-picoserver-打造日志服务器\">(原创)[C#]【开源】一分钟使用 PicoServer 打造日志服务器</h3>\n<p><a href=\"https://www.cnblogs.com/lesliexin/p/19475073\" target=\"_blank\">https://www.cnblogs.com/lesliexin/p/19475073</a></p>\n<p>本文介绍了 PicoServer 的使用，适合快速开发 WebAPI 原型。读者可以通过开源项目学习如何搭建日志服务器。文章简洁明了，提供了操作步骤，包括引用 NuGet 包、设计界面和使用说明。PicoServer 简单易用，且体积小，适合特定业务需求。作者强调其轻量级特性，相比 Asp.Net Core 更为便利。适合希望快速实现接口的开发者。</p>\n<h3 id=\"总结归纳net-10-中-minimal-apis-主要应用场景\">总结归纳.NET 10 中 Minimal APIs 主要应用场景</h3>\n<p><a href=\"https://www.cnblogs.com/tianqing/p/19467531\" target=\"_blank\">https://www.cnblogs.com/tianqing/p/19467531</a></p>\n<p>本文探讨了.NET 10 中的 Minimal APIs，主要应用场景包括高并发读接口、业务能力型 API 和平台级 API 模块化。Minimal APIs 在.NET 6 至 8 中实现了基础功能，并在.NET 9 至 10 中进一步强化，可维护性、可治理性、可扩展性和可工程化性显著提升。其中，Typed Results 消除了返回的模糊性，提高了 OpenAPI 文档的精确度。它还优化了中间件组合能力以及与依赖注入、验证和授权的整合，使得 API 的分层和模块化成为可能，推动企业级 API 的有效构建。</p>\n<h3 id=\"跨越技术鸿沟aspire-赋能-javascript-与-nodejs-开发者的深度生态融合\">跨越技术鸿沟：Aspire 赋能 JavaScript 与 Node.js 开发者的深度生态融合</h3>\n<p><a href=\"https://www.cnblogs.com/shanyou/p/19474912\" target=\"_blank\">https://www.cnblogs.com/shanyou/p/19474912</a></p>\n<p>本文探讨.NET Aspire 13.0 如何支持 JavaScript 与 Node.js 开发者，通过标准化基础设施解决传统开发中的摩擦。Aspire 引入代码化编排、全链路可观测性及标准化服务发现，简化前后端与微服务的整合。开发者不再需手动处理复杂配置与依赖关系，减少认知负担与操作复杂性。此文详细介绍了现代化 AddJavaScriptApp 的架构演进，并对生产部署与云原生对接提出建议，强调 Aspire 对于多语言生态的价值。整体提升了跨技术栈的开发效率。</p>\n<h3 id=\"wpf-使用-hlsl--clip-实现高亮歌词光照效果\">WPF 使用 HLSL + Clip 实现高亮歌词光照效果</h3>\n<p><a href=\"https://www.cnblogs.com/TwilightLemon/p/19497125\" target=\"_blank\">https://www.cnblogs.com/TwilightLemon/p/19497125</a></p>\n<p>本文讨论了使用 HLSL 编写文本高亮着色器，以增强歌词显示效果。作者受到 WPF 阳光效果的启发，探索了几种高亮实现方法，最终采用将着色器封装为用户控件的方案。文章介绍了可能遇到的问题，例如文本像素化和性能低下。此外，提供了高亮颜色自定义、宽度调整和模式切换的功能。作者展示了完整的 HLSL 代码及其参数作用，说明了光照强度与文本颜色的混合计算过程。这种方法显著提升了文本的光感效果。</p>\n<h3 id=\"并发并行与异步\">并发，并行与异步</h3>\n<p><a href=\"https://www.cnblogs.com/kklldog/p/19474533\" target=\"_blank\">https://www.cnblogs.com/kklldog/p/19474533</a></p>\n<p>本文深入剖析了并发、并行和异步三个核心概念，澄清了它们之间的区别。并发是一种处理多个任务的能力，强调任务的交替执行。并行则是真正意义上同一时间执行多个任务，依赖多核 CPU。异步是一种非阻塞的编程模型，主要用于 I/O 操作，避免浪费线程资源。文章通过实际例子和理论支持，使读者清楚理解这三者的定义和应用，指出异步并不等同于并发，同时强调了性能优化的重要性。整体内容结构清晰，便于读者理解。</p>\n<h3 id=\"pythoncsharpgonextjs不同框架的性能到底差多少\">Python、CSharp、Go、Nextjs，不同框架的性能到底差多少？</h3>\n<p><a href=\"https://www.cnblogs.com/deali/p/19498429\" target=\"_blank\">https://www.cnblogs.com/deali/p/19498429</a></p>\n<p>本文对不同框架和语言的性能进行了对比测试，特别关注了 ASP.NET Core 8.0 和 9.0 的性能表现。测试发现，ASP.NET Core 9.0 在吞吐量和内存使用方面表现卓越，适合高性能微服务。Go + Gin 虽然轻量，但吞吐量表现一般，适合小型服务。Next.js 在高并发场景下表现不佳。总体来看，ASP.NET Core 9.0 是未来项目的最佳选择，而传统 MVC 架构则显得过于臃肿，未来不推荐使用。</p>\n<h3 id=\"告别屎山代码gearnet专为-net-工业自动化打造的微编排框架\">告别“屎山”代码！Gear.NET：专为 .NET 工业自动化打造的微编排框架</h3>\n<p><a href=\"https://www.cnblogs.com/egreen/p/19498375\" target=\"_blank\">https://www.cnblogs.com/egreen/p/19498375</a></p>\n<p>Gear.NET 是一个专为 .NET 工业自动化设计的微编排框架，旨在解决工业软件开发中的痛点，如逻辑复杂、硬件耦合、数据丢失等问题。它采用洋葱架构，提供 MicroWorkflow 微流程引擎，支持优雅的流程编排和异步操作。此外，UniversalScpi 配置驱动解决了硬件更换时的代码重构问题，通过 JSON 配置驱动不同的标准 SCPI 仪器。相比以往，Gear.NET 提供了深度封装的 SqlSugar 存储解决方案，确保数据的安全性与可分析性，极大地提高了兼容性和可维护性，适合工业软件需求。整体上，Gear.NET 旨在简化开发过程、提高代码质量。</p>\n<h3 id=\"c实现包裹扣面单的几种方式\">c#实现包裹扣面单的几种方式</h3>\n<p><a href=\"https://www.cnblogs.com/axing/p/19483856\" target=\"_blank\">https://www.cnblogs.com/axing/p/19483856</a></p>\n<p>本文探讨了包裹流转过程中面单扣取的实现方案，包括使用 OpenCVSharp 进行轮廓、颜色和边缘检测，及 OCR 识别面单内容。文章重点介绍了 OpenCVSharp 在包裹和面单色差明显情况下的有效性，尽管在色差不明显时效果较差。提供了核心代码，展示了检测与处理过程，包括检测耗时和面单区域的信息。文中提到使用 YOLO 和 Labelme 可以训练模型以定位面单，为未来探讨做好铺垫。</p>\n<h3 id=\"cnetnet-core-技术前沿周刊--第-65-期2026-年-11-111\">C#/.NET/.NET Core 技术前沿周刊 | 第 65 期(2026 年 1.1-1.11)</h3>\n<p><a href=\"https://www.cnblogs.com/Can-daydayup/p/19479370\" target=\"_blank\">https://www.cnblogs.com/Can-daydayup/p/19479370</a></p>\n<p>本文介绍了 C#/.NET/.NET Core 技术前沿的最新动态和实用资源。报道了 C#在 2025 年的 TIOBE 编程语言排名中再次获评、生成式人工智能的崛起及其与 C#的结合、以及 MongoDB EF Core 的可查询加密特性。此外，还推广了优质项目和迁移 WinForms 到 Blazor 的 MWGA 项目。这些内容为开发者提供了有价值的信息与资源，有助于他们掌握技术前沿动态。</p>\n<h3 id=\"译ai-是如何解决我的拖延症的\">【译】AI 是如何解决我的拖延症的</h3>\n<p><a href=\"https://www.cnblogs.com/MeteorSeed/p/19482001\" target=\"_blank\">https://www.cnblogs.com/MeteorSeed/p/19482001</a></p>\n<p>作者分享了使用 Visual Studio 和 Copilot 完成两个项目的经历，强调了克服拖延和高效开发的重要性。第一个项目是将其书籍《The Automated Home》转换为静态网站，虽然需要微调设计，但效率显著提高。第二个项目是开发一个简易编程语言 TOON 的解析器，利用 Copilot 和云智能体协助解决复杂的语法分析问题。作者鼓励读者利用闲暇时间启动拖延已久的项目。</p>\n<h3 id=\"开源自荐为-ai-短视频打造一个分镜管理平台\">【开源自荐】为 AI 短视频打造一个分镜管理平台</h3>\n<p><a href=\"https://www.cnblogs.com/Z7TS/p/19483978\" target=\"_blank\">https://www.cnblogs.com/Z7TS/p/19483978</a></p>\n<p>这篇文章讲述了作者在 2022 至 2026 年间，如何利用 AI 技术开发本地客户端项目 Storyboard，旨在为短视频创作者提供镜头管理功能。作者分享了开发过程中的感受，包括使用的工具和技术栈，遇到的管理混乱问题，以及通过 AI 提升视频制作效率的体验。文章描述了项目需求的整理和核心功能的实现，涵盖了视频导入、分镜生成、批量任务处理等功能，展现了 AI 在短视频领域的应用潜力。</p>\n<h3 id=\"如何一步步将-aspnet-mvc-升级为net\">如何一步步将 ASP.NET MVC 升级为.NET</h3>\n<p><a href=\"https://www.cnblogs.com/powertoolsteam/p/19486260\" target=\"_blank\">https://www.cnblogs.com/powertoolsteam/p/19486260</a></p>\n<p>将 ASP.NET MVC 应用从.NET Framework 迁移到现代.NET 需要考虑多个方面。该过程并非简单的版本提升，需关注多个架构和配置的变化。文中提供了实用的逐步策略，包括根据应用大小选择迁移路径、识别阻碍因素、建立安全基线、优先升级库及考虑迁移工具等步骤。这些步骤旨在帮助开发者有效降低风险，确保迁移顺利进行。文中还强调了 Microsoft 提供的工具和指导，以便进行兼容性检查和补救措施。此文适合有实际开发经验的开发者参考。</p>\n<h3 id=\"c-14-中的新增功能\">C# 14 中的新增功能</h3>\n<p><a href=\"https://www.cnblogs.com/net-kevin-li/p/19476883\" target=\"_blank\">https://www.cnblogs.com/net-kevin-li/p/19476883</a></p>\n<p>C# 14 引入重要更新，包括扩展成员、空条件赋值、支持未绑定泛型的 nameof、Span隐式转换、简单 lambda 参数修饰符、字段支持属性、partial 事件与构造函数、用户定义复合赋值运算符和基于文件的预处理器指令。开发环境要求.NET 10 SDK 或 Visual Studio 2026。某些功能需要开启编译器开关以启用。性能优化方面，Span隐式转换减少内存拷贝，适用于高性能场景。</p>\n<h3 id=\"wpf-新手村教程二---铁匠铺攻略如何给隔壁张铁匠带两块铁依赖属性\">WPF 新手村教程(二) - 铁匠铺攻略：如何给隔壁张铁匠带两块铁(依赖属性)</h3>\n<p><a href=\"https://www.cnblogs.com/leaf-7-scouts/p/19475414\" target=\"_blank\">https://www.cnblogs.com/leaf-7-scouts/p/19475414</a></p>\n<p>本文章探讨 WPF 中的依赖属性和附加属性。依赖属性是由 WPF 属性系统统一管理的，值由多种输入源计算得出。文章通过 C#普通属性与 WPF 依赖属性的对比，阐述了依赖属性的定义和实现方式。介绍了依赖属性标识符的重要性及其在 WPF 属性系统中的应用。通过示例代码，展示了如何定义和使用依赖属性，增强了对属性体系的理解。整体内容清晰，技术深度适中，具备实用价值。</p>\n<h3 id=\"netcorekevin-是一个基于net9-ai-时代的-saas-企业级-ai-架构专注于-ai-智能体开发与集成agentframework-和知识库为企业提供高效的-ai-应用开发框架\">NetCoreKevin 是一个基于.NET9 AI 时代的 SaaS 企业级 AI 架构，专注于 AI 智能体开发与集成,AgentFramework 和知识库，为企业提供高效的 AI 应用开发框架。</h3>\n<p><a href=\"https://www.cnblogs.com/net-kevin-li/p/19493371\" target=\"_blank\">https://www.cnblogs.com/net-kevin-li/p/19493371</a></p>\n<p>NetCoreKevin 是基于 .NET 的现代化 SaaS 企业级架构，专注 AI 智能体开发与集成。采用前后端分离设计，支持 AI 语义内核和 RAG 检索增强生成，提供高效的应用开发框架。核心组件包括模块化智能体框架、动态知识库与容器化部署。后端使用 .NET Core 9、Entity Framework Core，前端采用 Vue3。支持 Docker 和 Kubernetes，实现云原生架构，满足高并发需求。该架构降低企业 AI 实施门槛，助力智能化转型。</p>\n<h3 id=\"如何通过-c-将-ppt-文档转换为-pdf-格式\">如何通过 C# 将 PPT 文档转换为 PDF 格式</h3>\n<p><a href=\"https://www.cnblogs.com/jazz-z/p/19486170\" target=\"_blank\">https://www.cnblogs.com/jazz-z/p/19486170</a></p>\n<p>本文介绍如何使用 .NET 组件 Spire.Presentation 将 PowerPoint 文件转换为 PDF。首先，用户需通过 NuGet 安装该库。示例代码展示如何处理单个和批量 PPT 转 PDF 的流程，包括文件路径的定义、加载 PPT 文档、执行转换和资源释放等步骤。文章强调了异常处理的重要性，确保用户在遇到错误时能够清楚地获取反馈。该技术在开发和办公场景中具有很高的实用价值。</p>\n<h3 id=\"译使用-visual-studio-2026-简化您的-git-工作流程\">【译】使用 Visual Studio 2026 简化您的 Git 工作流程</h3>\n<p><a href=\"https://www.cnblogs.com/MeteorSeed/p/19460575\" target=\"_blank\">https://www.cnblogs.com/MeteorSeed/p/19460575</a></p>\n<p>本文讲述了 .NET 开发者如何使用 Visual Studio 和 Git 工具高效处理日常任务。通过具体示例，作者展示了如何创建分支、暂存未完成的变更并同步，保持代码库整洁。Visual Studio 的功能优化简化了分支切换和代码审查过程，提升了工作效率。文中还提到 Copilot 的代码审查功能，如何帮助开发者检测问题并获得建议，确保提交的安全性和质量。最后，作者介绍了创建拉取请求的简易流程，强调了团队协作的重要性。</p>\n<h3 id=\"基于net-和-c构建光伏-iot-物模型方案\">基于.NET 和 C#构建光伏 IoT 物模型方案</h3>\n<p><a href=\"https://www.cnblogs.com/tianqing/p/19490649\" target=\"_blank\">https://www.cnblogs.com/tianqing/p/19490649</a></p>\n<p>文章详细描述了国内光伏设备及华为逆变器的 Modbus TCP 通讯报文。它包括请求和响应的结构、数据解析及光伏设备物模型的组织。文章目标在于解耦协议、解析与物模型，方便后续多品牌适配器的配置化映射。提供了示例代码，展示 Modbus 请求报文构造和响应解析方法，具有较高的技术深度与实用性。内容清晰，结构合理，代码示例易于理解，具备创新性，并紧跟技术进展。引用情况适中，整体可读性良好。</p>\n<h3 id=\"net-aspire-概述\">.NET Aspire 概述</h3>\n<p><a href=\"https://www.cnblogs.com/powertoolsteam/p/19477015\" target=\"_blank\">https://www.cnblogs.com/powertoolsteam/p/19477015</a></p>\n<p>.NET Aspire 是微软在 Build 2024 推出的开源框架，旨在简化.NET 8 及以上版本的分布式云原生应用开发。它提供工具、模板和最佳实践，帮助开发者将重心从基础设施转向业务逻辑。Aspire 的核心功能包括 AppHost 中心编排、服务默认配置、快速设置模板及开发者仪表盘，支持灵活部署到多种容器平台。Aspire 通过抽象化基础设施，降低开发复杂性，提高开发效率，确保环境一致性并内置可观测性和弹性。</p>\n<h3 id=\"一款专为-winui-xaml-设计的快速原型设计工具生成的代码可轻松复制到-visual-studio-中\">一款专为 WinUI XAML 设计的快速原型设计工具，生成的代码可轻松复制到 Visual Studio 中！</h3>\n<p><a href=\"https://www.cnblogs.com/Can-daydayup/p/19494169\" target=\"_blank\">https://www.cnblogs.com/Can-daydayup/p/19494169</a></p>\n<p>XAML Studio 是专为 WinUI XAML 设计的快速原型工具，支持实时预览和互动，允许将生成的代码轻松复制到 Visual Studio。它提供界面调试、数据上下文编辑器和智能感知等功能，适合开发者学习和快速原型设计。WinUI 是一个现代 UI 框架，旨在构建动态和高性能的 Windows 应用。该项目为开源，开发者可以访问 GitHub 获取源代码，并关注 C#/.NET 的最佳实践。</p>\n<h3 id=\"基于-netcorepal-cloud-framework-的-ddd-架构管理系统实践\">基于 NetCorePal Cloud Framework 的 DDD 架构管理系统实践</h3>\n<p><a href=\"https://www.cnblogs.com/aishangyipiyema/p/19499381\" target=\"_blank\">https://www.cnblogs.com/aishangyipiyema/p/19499381</a></p>\n<p>本文介绍了基于 NetCorePal Cloud Framework 构建 DDD 架构的管理系统实践。项目采用了.NET 10 和 Vue 3，实现前后端分离。系统包含用户、角色、部门等基本功能，后端使用 EF Core 进行数据访问，FastEndpoints 替代传统 Controller，并通过 MediatR 实现 CQRS 模式，存储支持 MySQL 等数据库，集成 RabbitMQ、Redis 及云原生基础设施管理。项目采用经典三层架构，强调领域驱动设计(DDD)，确保领域层与基础设施层和表现层之间的单向依赖。文章提供了清晰的架构和技术选型参考，适合相关领域开发者学习。</p>\n<h2 id=\"话题\">话题</h2>\n<h3 id=\"net-和-net-framework-2026-年-1-月服务发布更新---net-博客\">.NET 和 .NET Framework 2026 年 1 月服务发布更新 - .NET 博客</h3>\n<p><a href=\"https://devblogs.microsoft.com/dotnet/dotnet-and-dotnet-framework-january-2026-servicing-updates/\" rel=\"noopener nofollow\" target=\"_blank\">https://devblogs.microsoft.com/dotnet/dotnet-and-dotnet-framework-january-2026-servicing-updates/</a></p>\n<p>关于 2026 年 1 月发布的.NET 和.NET Framework 服务。</p>\n<p>.NET 10、9 和 8 版本发布时，增加了非安全稳定性的改进和各种漏洞修复。 NET Framework。</p>\n<h3 id=\"aws-lambda-新增对-net-10---aws-的支持\">AWS Lambda 新增对 .NET 10 - AWS 的支持</h3>\n<p><a href=\"https://aws.amazon.com/jp/about-aws/whats-new/2026/01/aws-lambda-dot-net-10/\" rel=\"noopener nofollow\" target=\"_blank\">https://aws.amazon.com/jp/about-aws/whats-new/2026/01/aws-lambda-dot-net-10/</a></p>\n<p>AWS Lambda 现已支持 .NET 10。</p>\n<p>.NET 10 文件类应用、Lambda 管理实例以及 AWS Lambda 的 Powertools 也被支持以配合 .NET 10。 NET 10 运行时在所有地区均可用。</p>\n<h3 id=\"我们如何同步-net-的虚拟单点---net-博客\">我们如何同步。 NET 的虚拟单点 - .NET 博客</h3>\n<p><a href=\"https://devblogs.microsoft.com/dotnet/how-we-synchronize-dotnets-virtual-monorepo/\" rel=\"noopener nofollow\" target=\"_blank\">https://devblogs.microsoft.com/dotnet/how-we-synchronize-dotnets-virtual-monorepo/</a></p>\n<p>如何同步一个.NET 虚拟单仓库(<a href=\"https://github.com/dotnet/dotnet\" rel=\"noopener nofollow\" target=\"_blank\">dotnet/dotnet</a>))。</p>\n<p>在作一个将多个仓库(如 dotnet/runtime 和 dotnet/aspnetcore)视为构建源的仓库(VMR)时，本书详细解释了仓库间的同步问题及其解决方法。</p>\n<h2 id=\"发布\">发布</h2>\n<ul>\n<li><a href=\"https://github.com/AvaloniaUI/Avalonia\" rel=\"noopener nofollow\" target=\"_blank\">AvaloniaUI/Avalonia</a>\n<ul>\n<li><a href=\"https://github.com/AvaloniaUI/Avalonia/releases/tag/11.3.11%20%E5%B9%B4\" rel=\"noopener nofollow\" target=\"_blank\">2011 年 3 月 11 日</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/aws/aws-sdk-net\" rel=\"noopener nofollow\" target=\"_blank\">aws/aws-sdk-net</a>\n<ul>\n<li><a href=\"https://github.com/aws/aws-sdk-net/releases/tag/3.7.1199.0\" rel=\"noopener nofollow\" target=\"_blank\">3.7.1199.0</a>，<a href=\"https://github.com/aws/aws-sdk-net/releases/tag/3.7.1200.0\" rel=\"noopener nofollow\" target=\"_blank\">3.7.1200.0</a>，<a href=\"https://github.com/aws/aws-sdk-net/releases/tag/3.7.1201.0\" rel=\"noopener nofollow\" target=\"_blank\">3.7.1201。 0</a>， <a href=\"https://github.com/aws/aws-sdk-net/releases/tag/3.7.1202.0\" rel=\"noopener nofollow\" target=\"_blank\">3.7.1202.0</a>， <a href=\"https://github.com/aws/aws-sdk-net/releases/tag/3.7.1203.0\" rel=\"noopener nofollow\" target=\"_blank\">3.7.1203. 0</a>， <a href=\"https://github.com/aws/aws-sdk-net/releases/tag/4.0.167.0\" rel=\"noopener nofollow\" target=\"_blank\">4.0.167.0</a>， <a href=\"https://github.com/aws/aws-sdk-net/releases/tag/4.0.168.0\" rel=\"noopener nofollow\" target=\"_blank\">4.0.168.0</a>， <a href=\"https://github.com/aws/aws-sdk-net/releases/tag/4.0.169.0\" rel=\"noopener nofollow\" target=\"_blank\">4.0.169.0</a>， <a href=\"https://github.com/aws/aws-sdk-net/releases/tag/4.0.170.0\" rel=\"noopener nofollow\" target=\"_blank\">4.0.170.0</a>， <a href=\"https://github.com/aws/aws-sdk-net/releases/tag/4.0.171.0\" rel=\"noopener nofollow\" target=\"_blank\">4.0.171.0</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/Azure/azure-sdk-for-net\" rel=\"noopener nofollow\" target=\"_blank\">Azure/azure-sdk-for-net</a>\n<ul>\n<li><a href=\"https://github.com/Azure/azure-sdk-for-net/releases/tag/Azure.Storage.Blobs_12.27.0\" rel=\"noopener nofollow\" target=\"_blank\">Azure.Storage.Blobs_12.27.0</a>，<a href=\"https://github.com/Azure/azure-sdk-for-net/releases/tag/Azure.Storage.Blobs.Batch_12.24.0\" rel=\"noopener nofollow\" target=\"_blank\">Azure.Storage.Blobs.Batch_12.24。 0</a>，<a href=\"https://github.com/Azure/azure-sdk-for-net/releases/tag/Azure.Storage.Common_12.26.0\" rel=\"noopener nofollow\" target=\"_blank\">Azure.Storage.Common_12.26。 0</a>，<a href=\"https://github.com/Azure/azure-sdk-for-net/releases/tag/Azure.Storage.Files.DataLake_12.25.0\" rel=\"noopener nofollow\" target=\"_blank\">Azure.Storage.Files.DataLake_12.25。 0</a>，<a href=\"https://github.com/Azure/azure-sdk-for-net/releases/tag/Azure.Storage.Files.Shares_12.25.0\" rel=\"noopener nofollow\" target=\"_blank\">Azure.Storage.Files.Shares_12.25。 0</a>，<a href=\"https://github.com/Azure/azure-sdk-for-net/releases/tag/Azure.Storage.Queues_12.25.0\" rel=\"noopener nofollow\" target=\"_blank\">Azure.Storage.Queues_12.25。 0</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/CommunityToolkit/Aspire\" rel=\"noopener nofollow\" target=\"_blank\">CommunityToolkit/Aspire</a>\n<ul>\n<li><a href=\"https://github.com/CommunityToolkit/Aspire/releases/tag/v13.1.0\" rel=\"noopener nofollow\" target=\"_blank\">v13.1.0</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/DataDog/dd-trace-dotnet\" rel=\"noopener nofollow\" target=\"_blank\">DataDog/dd-trace-dotnet</a>\n<ul>\n<li><a href=\"https://github.com/DataDog/dd-trace-dotnet/releases/tag/v3.35.0\" rel=\"noopener nofollow\" target=\"_blank\">v3.35.0</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/dotnet/maui\" rel=\"noopener nofollow\" target=\"_blank\">dotnet/maui</a>\n<ul>\n<li><a href=\"https://github.com/dotnet/maui/releases/tag/10.0.30\" rel=\"noopener nofollow\" target=\"_blank\">10.0.30</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/dotnet/orleans\" rel=\"noopener nofollow\" target=\"_blank\">dotnet/Orleans</a>\n<ul>\n<li><a href=\"https://github.com/dotnet/orleans/releases/tag/v3.8.0\" rel=\"noopener nofollow\" target=\"_blank\">v3.8.0</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/dotnet/SqlClient\" rel=\"noopener nofollow\" target=\"_blank\">dotnet/SqlClient</a>\n<ul>\n<li><a href=\"https://github.com/dotnet/SqlClient/releases/tag/v5.1.9\" rel=\"noopener nofollow\" target=\"_blank\">v5.1.9</a>， <a href=\"https://github.com/dotnet/SqlClient/releases/tag/v6.1.4\" rel=\"noopener nofollow\" target=\"_blank\">v6.1.4</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/googleapis/google-cloud-dotnet\" rel=\"noopener nofollow\" target=\"_blank\">googleapis/google-cloud-dotnet</a>\n<ul>\n<li><a href=\"https://github.com/googleapis/google-cloud-dotnet/releases/tag/Google.Cloud.BackupDR.V1-2.7.0\" rel=\"noopener nofollow\" target=\"_blank\">Google.Cloud.BackupDR.V1-2.7.0</a>，<a href=\"https://github.com/googleapis/google-cloud-dotnet/releases/tag/Google.Cloud.Compute.V1-3.22.0\" rel=\"noopener nofollow\" target=\"_blank\">Google.Cloud.Compute.V1-3.22。 0</a>， <a href=\"https://github.com/googleapis/google-cloud-dotnet/releases/tag/Google.Cloud.Config.V1-1.11.0\" rel=\"noopener nofollow\" target=\"_blank\">Google.Cloud.Config.V1-1.11. 0</a>， <a href=\"https://github.com/googleapis/google-cloud-dotnet/releases/tag/Google.Cloud.DevTools.ContainerAnalysis-3.12.0\" rel=\"noopener nofollow\" target=\"_blank\">Google.Cloud.DevTools.ContainerAnalysis-3.12. 0</a>， <a href=\"https://github.com/googleapis/google-cloud-dotnet/releases/tag/Google.Cloud.PubSub.V1-3.31.0\" rel=\"noopener nofollow\" target=\"_blank\">Google.Cloud.PubSub.V1-3.31. 0</a>， <a href=\"https://github.com/googleapis/google-cloud-dotnet/releases/tag/Google.Cloud.Spanner-5.10.0\" rel=\"noopener nofollow\" target=\"_blank\">Google.Cloud.Spanner-5.10. 0</a>， <a href=\"https://github.com/googleapis/google-cloud-dotnet/releases/tag/Google.Cloud.Spanner-5.11.0\" rel=\"noopener nofollow\" target=\"_blank\">Google.Cloud.Spanner-5.11. 0</a>， <a href=\"https://github.com/googleapis/google-cloud-dotnet/releases/tag/Google.Cloud.Speech.V2-1.7.0\" rel=\"noopener nofollow\" target=\"_blank\">Google.Cloud.Speech.V2-1.7. 0</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/microsoft/WindowsAppSDK\" rel=\"noopener nofollow\" target=\"_blank\">microsoft/WindowsAppSDK</a>\n<ul>\n<li><a href=\"https://github.com/microsoft/WindowsAppSDK/releases/tag/v1.7.7\" rel=\"noopener nofollow\" target=\"_blank\">v1.7.7</a>、<a href=\"https://github.com/microsoft/WindowsAppSDK/releases/tag/v1.8.4\" rel=\"noopener nofollow\" target=\"_blank\">v1.8.4</a>、<a href=\"https://github.com/microsoft/WindowsAppSDK/releases/tag/v2.0-exp4\" rel=\"noopener nofollow\" target=\"_blank\">v2. 0-exp4</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/newrelic/newrelic-dotnet-agent\" rel=\"noopener nofollow\" target=\"_blank\">newrelic/newrelic-dotnet-agent</a>    - <a href=\"https://github.com/newrelic/newrelic-dotnet-agent/releases/tag/v10.48.0\" rel=\"noopener nofollow\" target=\"_blank\">v10.48.0</a></li>\n<li><a href=\"https://github.com/open-telemetry/opentelemetry-dotnet-contrib\" rel=\"noopener nofollow\" target=\"_blank\">开放遥测/开放遥测点网贡献</a>\n<ul>\n<li><a href=\"https://github.com/open-telemetry/opentelemetry-dotnet-contrib/releases/tag/Instrumentation.AWS-1.14.2\" rel=\"noopener nofollow\" target=\"_blank\">Instrumentation.AWS-1.14.2</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/unoplatform/uno\" rel=\"noopener nofollow\" target=\"_blank\">unoplatform/uno</a>\n<ul>\n<li><a href=\"https://github.com/unoplatform/uno/releases/tag/6.4.242\" rel=\"noopener nofollow\" target=\"_blank\">6.4.242</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"文章幻灯片及更多内容\">文章、幻灯片及更多内容</h2>\n<h3 id=\"net-10-和-c-14-新增内容api-请求响应流水线的增强\">.NET 10 和 C# 14 新增内容：API 请求/响应流水线的增强</h3>\n<p><a href=\"https://blog.elmah.io/new-in-net-10-and-c-14-enhancements-in-apis-request-response-pipeline/\" rel=\"noopener nofollow\" target=\"_blank\">https://blog.elmah.io/new-in-net-10-and-c-14-enhancements-in-apis-request-response-pipeline/</a></p>\n<p>关于 ASP.NET Core 中 .NET 10 改进的 API 请求/响应流水线。</p>\n<h3 id=\"如何用-systemd-和-podman-部署-net-应用--红帽开发者\">如何用 systemd 和 Podman 部署 .NET 应用 | 红帽开发者</h3>\n<p><a href=\"https://developers.redhat.com/articles/2026/01/09/how-deploy-net-applications-systemd-and-podman\" rel=\"noopener nofollow\" target=\"_blank\">https://developers.redhat.com/articles/2026/01/09/how-deploy-net-applications-systemd-and-podman</a></p>\n<p>学习如何使用 systemd 和 Podman/Podman 四重组部署和运行 .NET 应用程序。</p>\n<h3 id=\"副驾驶回忆---visual-studio-博客\">副驾驶回忆 - Visual Studio 博客</h3>\n<p><a href=\"https://devblogs.microsoft.com/visualstudio/copilot-memories/\" rel=\"noopener nofollow\" target=\"_blank\">https://devblogs.microsoft.com/visualstudio/copilot-memories/</a></p>\n<p>副驾驶记忆功能的简要介绍。</p>\n<ul>\n<li><a href=\"https://docs.github.com/en/copilot/how-tos/use-copilot-agents/copilot-memory\" rel=\"noopener nofollow\" target=\"_blank\">启用和管理 Copilot 内存 - GitHub 文档</a></li>\n</ul>\n<h3 id=\"关于-publishaot-设置和运行时功能isdynamiccode-已提交属性\">关于 PublishAot 设置和运行时功能。IsDynamicCode 已提交属性</h3>\n<p><a href=\"https://zenn.dev/prozolic/articles/43631043eeaeca\" rel=\"noopener nofollow\" target=\"_blank\">https://zenn.dev/prozolic/articles/43631043eeaeca</a></p>\n<p>解释了“PublishAot”设置中的“RuntimeFeature.IsDynamicCodeCompiled”属性如何影响构建时间和调试执行。</p>\n<h3 id=\"我应该使用-nuget-lock-files---techguitarrapccóm\">我应该使用 NuGet Lock Files - tech.guitarrapc.cóm</h3>\n<p><a href=\"https://tech.guitarrapc.com/entry/2026/01/11/230000\" rel=\"noopener nofollow\" target=\"_blank\">https://tech.guitarrapc.com/entry/2026/01/11/230000</a></p>\n<p>对 NuGet 锁文件的解释及其必要性。</p>\n<h3 id=\"-通过net-应用读取我的号码卡信息可在-linux-上使用qiita\">. 通过.NET 应用读取我的号码卡信息(可在 Linux 上使用)——Qiita。</h3>\n<p><a href=\"https://qiita.com/yamaokunousausa/items/503eb3ae1ec1f35d972d\" rel=\"noopener nofollow\" target=\"_blank\">https://qiita.com/yamaokunousausa/items/503eb3ae1ec1f35d972d</a></p>\n<p>如何在 .NET 应用程序中加载我的号码卡信息。 它还涉及了它在 Linux 上的工作方式。</p>\n<h3 id=\"aws-现支持基于文件的-c-lambda-函数---techguitarrapccóm\">AWS 现支持基于文件的 C# Lambda 函数 - tech.guitarrapc.cóm</h3>\n<p><a href=\"https://tech.guitarrapc.com/entry/2026/01/10/230000\" rel=\"noopener nofollow\" target=\"_blank\">https://tech.guitarrapc.com/entry/2026/01/10/230000</a></p>\n<p>关于 AWS Lambda 对基于 C#文件程序的支持以及对.NET 10 的支持。</p>\n<h3 id=\"windows-应用的-ui-开发难吗-这个问题你可以用-blazor--tailwind-css-解决\">Windows 应用的 UI 开发难吗？ 这个问题，你可以用 Blazor × Tailwind CSS 解决</h3>\n<p><a href=\"https://zenn.dev/wogo_techblog/articles/811ec4e5c7a0e4\" rel=\"noopener nofollow\" target=\"_blank\">https://zenn.dev/wogo_techblog/articles/811ec4e5c7a0e4</a></p>\n<p>学习如何在你的 BlazorWebView(Blazor 混合)应用中使用 Tailwind CSS。</p>\n<h3 id=\"如何用net-maui-构建-android-小部件---net-博客\">如何用.NET MAUI 构建 Android 小部件 - .NET 博客</h3>\n<p><a href=\"https://devblogs.microsoft.com/dotnet/how-to-build-android-widgets-with-dotnet-maui/\" rel=\"noopener nofollow\" target=\"_blank\">https://devblogs.microsoft.com/dotnet/how-to-build-android-widgets-with-dotnet-maui/</a></p>\n<p>如何在 .NET MAUI 中实现 Android 小部件。 文章解释了实现过程，包括与应用程序的交互。</p>\n<h3 id=\"在-azure-云swa--functions--cosmos-db中为您的网站实现旧公告板qiita\">在 Azure 云(SWA + Functions + Cosmos DB)中为您的网站实现“旧公告板”——Qiita</h3>\n<p><a href=\"https://qiita.com/RamTuckey/items/f8e50b038e8b24df9c26\" rel=\"noopener nofollow\" target=\"_blank\">https://qiita.com/RamTuckey/items/f8e50b038e8b24df9c26</a></p>\n<p>Azure Static Web Apps and Azure Functions (Managed Functions) 以及 Cosmos DB 来实现传统的公告板。</p>\n<h3 id=\"在-c模块初始化器被调用之前---qiita\">在 C#模块初始化器被调用之前 - Qiita。</h3>\n<p><a href=\"https://qiita.com/RyotaMurohoshi/items/83d92945e05c7dad90a0\" rel=\"noopener nofollow\" target=\"_blank\">https://qiita.com/RyotaMurohoshi/items/83d92945e05c7dad90a0</a></p>\n<p>关于用 ModuleInitializer 初始化模块初始化器和静态构造器，初始化静态字段的顺序。</p>\n<h3 id=\"从net-memorystream-创建零副本二进制数据---gérald-barré\">从.NET MemoryStream 创建零副本二进制数据 - Gérald Barré</h3>\n<p><a href=\"https://www.meziantou.net/zero-copy-binarydata-creation-from-memorystream-in-dotnet.htm\" rel=\"noopener nofollow\" target=\"_blank\">https://www.meziantou.net/zero-copy-binarydata-creation-from-memorystream-in-dotnet.htm</a></p>\n<p>如何在从内存流创建二进制数据时进行零复制。</p>\n<h3 id=\"wpf--opencvsharp-创建了一款发送带有面部手势的-pdf-页面的应用---qiita\">WPF + OpenCvSharp 创建了一款“发送带有面部手势的 PDF 页面”的应用 - Qiita</h3>\n<p><a href=\"https://qiita.com/kerobot/items/0f5bad24daf91958de50\" rel=\"noopener nofollow\" target=\"_blank\">https://qiita.com/kerobot/items/0f5bad24daf91958de50</a></p>\n<p>描述使用 WPF 和 OpenCvSharp 创建一个识别面部手势并发送关键动作的应用程序。</p>\n<h3 id=\"copilot-为--windows-应用开发工作本地编辑-安心与说明\">Copilot 为 × Windows 应用开发工作：本地编辑 安心与说明</h3>\n<p><a href=\"https://zenn.dev/suusanex/articles/f5a5ca188f957d\" rel=\"noopener nofollow\" target=\"_blank\">https://zenn.dev/suusanex/articles/f5a5ca188f957d</a></p>\n<p>介绍 Visual Studio Code 及在 Visual Studio 中使用 Copilot，以及一些快速使用技巧。</p>\n<h3 id=\"c14-化合物分配超载\">[C#14] 化合物分配超载</h3>\n<p><a href=\"https://zenn.dev/peacockanderson/articles/3f4fbc24420036\" rel=\"noopener nofollow\" target=\"_blank\">https://zenn.dev/peacockanderson/articles/3f4fbc24420036</a></p>\n<p>C# 14 中复赋值算子超载的解释。</p>\n<h2 id=\"库仓库工具等\">库、仓库、工具等</h2>\n<h3 id=\"jsakamotodnx-zipsrcdnx-zipsrc-是一个-net-全局工具利用-gitignore-模式从项目中的源文件创建压缩包排除伪影依赖及其他内容-非源文件\">jsakamoto/dnx-zipsrc：“dnx zipsrc” 是一个 .NET 全局工具，利用 .gitignore 模式从项目中的源文件创建压缩包，排除伪影、依赖及其他内容 非源文件。</h3>\n<p>.gitignore 工具用于过滤不必要的文件和 ZIP 源代码。</p>\n<ul>\n<li><a href=\"https://zenn.dev/j_sakamoto/articles/fd3a6d583474db\" rel=\"noopener nofollow\" target=\"_blank\">我创建了一个 CLI 工具，只压缩源代码，且不会无意中包含构建工件</a></li>\n</ul>\n<h3 id=\"mattparkerdevsharpdbgsharpdbg-是一个-net-托管代码调试器支持完全用-cnet-实现的调试适配器协议\">MattParkerDev/sharpdbg：SharpDbg 是一个 .NET 托管代码调试器，支持完全用 C#/.NET 实现的调试适配器协议</h3>\n<p><a href=\"https://github.com/MattParkerDev/sharpdbg\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/MattParkerDev/sharpdbg</a></p>\n<p>一个支持以 .NET(C#)实现的数据适配器协议的 .NET 调试器。</p>\n<p><a href=\"https://x.com/mattparkerdev/status/2006535935610221030?s=12\" rel=\"noopener nofollow\" target=\"_blank\">https://x.com/mattparkerdev/status/2006535935610221030?s=12</a></p>\n<h3 id=\"评论工作室---visual-studio-市场\">评论工作室 - Visual Studio 市场</h3>\n<p><a href=\"https://marketplace.visualstudio.com/items?itemName=MadsKristensen.commentsvs\" rel=\"noopener nofollow\" target=\"_blank\">https://marketplace.visualstudio.com/items?itemName=MadsKristensen.commentsvs</a></p>\n<p>一个 Visual Studio 扩展，可以将 XML、文档、注释等格式化并显示成易读格式。</p>\n<p><a href=\"https://x.com/mkristensen/status/2009296580688421049?s=12&amp;t=ggvrrZ7oLogHyNoIGNgjbw\" rel=\"noopener nofollow\" target=\"_blank\">https://x.com/mkristensen/status/2009296580688421049?s=12&amp;t=ggvrrZ7oLogHyNoIGNgjbw</a></p>\n<h3 id=\"精选空白\">精选空白</h3>\n<p><a href=\"https://www.vsixgallery.com/extension/SelectedWhitespace.63944e24-4aa2-4d0a-8161-4b7eb9f39831/\" rel=\"noopener nofollow\" target=\"_blank\">https://www.vsixgallery.com/extension/SelectedWhitespace.63944e24-4aa2-4d0a-8161-4b7eb9f39831/</a></p>\n<p>Visual Studio 扩展，用于显示选定范围的空白字符。</p>\n<p><a href=\"https://x.com/mkristensen/status/2011164964372070798?s=12\" rel=\"noopener nofollow\" target=\"_blank\">https://x.com/mkristensen/status/2011164964372070798?s=12</a></p>\n<h2 id=\"今日人物\">今日人物</h2>\n<p><strong>肯尼斯·蓝·汤普逊</strong>（英语：Kenneth Lane Thompson，1943 年 2 月 4 日—），小名<strong>肯·汤普逊</strong>（英语：Ken Thompson），美国<a href=\"https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\" rel=\"noopener nofollow\" target=\"_blank\">计算机科学</a>学者和工程师。<a href=\"https://zh.wikipedia.org/wiki/%E9%A7%AD%E5%AE%A2%E6%96%87%E5%8C%96\" rel=\"noopener nofollow\" target=\"_blank\">黑客文化</a>圈子通常称他为“ken”<a href=\"https://zh.wikipedia.org/wiki/%E8%82%AF%C2%B7%E6%B1%A4%E6%99%AE%E9%80%8A#cite_note-1\" rel=\"noopener nofollow\" target=\"_blank\">[1]</a>。在<a href=\"https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%B0%94%E5%AE%9E%E9%AA%8C%E5%AE%A4\" rel=\"noopener nofollow\" target=\"_blank\">贝尔实验室</a>工作期间，汤普逊设计和实现了<a href=\"https://zh.wikipedia.org/wiki/Unix\" rel=\"noopener nofollow\" target=\"_blank\">Unix</a>操作系统。他创造了<a href=\"https://zh.wikipedia.org/wiki/B%E8%AF%AD%E8%A8%80\" rel=\"noopener nofollow\" target=\"_blank\">B 语言</a>——<a href=\"https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80\" rel=\"noopener nofollow\" target=\"_blank\">C 语言</a>的前身，而且他是<a href=\"https://zh.wikipedia.org/wiki/%E8%B2%9D%E7%88%BE%E5%AF%A6%E9%A9%97%E5%AE%A4%E4%B9%9D%E8%99%9F%E8%A8%88%E7%95%AB\" rel=\"noopener nofollow\" target=\"_blank\">Plan 9</a>操作系统的创造者和开发者之一。2006 年，汤普逊进入<a href=\"https://zh.wikipedia.org/wiki/Google\" rel=\"noopener nofollow\" target=\"_blank\">Google</a>公司工作，与他人共同设计了<a href=\"https://zh.wikipedia.org/wiki/Go\" rel=\"noopener nofollow\" target=\"_blank\">Go 语言</a>。他与<a href=\"https://zh.wikipedia.org/wiki/%E4%B8%B9%E5%B0%BC%E6%96%AF%C2%B7%E9%87%8C%E5%A5%87\" rel=\"noopener nofollow\" target=\"_blank\">丹尼斯·里奇</a>同为 1983 年<a href=\"https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E5%A5%96\" rel=\"noopener nofollow\" target=\"_blank\">图灵奖</a>得主。</p>\n<p>此外，肯·汤普逊还参与过<a href=\"https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\" rel=\"noopener nofollow\" target=\"_blank\">正则表达式</a>和<a href=\"https://zh.wikipedia.org/wiki/UTF-8\" rel=\"noopener nofollow\" target=\"_blank\">UTF-8</a>编码的设计，改进了文本编辑器<a href=\"https://zh.wikipedia.org/w/index.php?title=QED_(%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8)&amp;action=edit&amp;redlink=1\" rel=\"noopener nofollow\" target=\"_blank\">QED</a>，创造了<a href=\"https://zh.wikipedia.org/wiki/Ed_(%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8)\" rel=\"noopener nofollow\" target=\"_blank\">ed</a>编辑器。他曾制造过专门用于下<a href=\"https://zh.wikipedia.org/wiki/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B\" rel=\"noopener nofollow\" target=\"_blank\">国际象棋</a>的电脑“<a href=\"https://zh.wikipedia.org/w/index.php?title=Belle_(%E6%9C%BA%E5%99%A8)&amp;action=edit&amp;redlink=1\" rel=\"noopener nofollow\" target=\"_blank\">Belle</a>”，并建立了<a href=\"https://zh.wikipedia.org/w/index.php?title=%E6%AE%8B%E5%B1%80%E6%95%B0%E6%8D%AE%E5%BA%93&amp;action=edit&amp;redlink=1\" rel=\"noopener nofollow\" target=\"_blank\">残局数据库</a>。</p>\n<p><img alt=\"肯尼斯·蓝·汤普逊\" src=\"https://img2024.cnblogs.com/blog/997046/202602/997046-20260215203042576-1304543210.jpg\" /></p>\n<h2 id=\"c-net-交流群\">C# .NET 交流群</h2>\n<p>相信大家在开发中经常会遇到一些性能问题，苦于没有有效的工具去发现性能瓶颈，或者是发现瓶颈以后不知道该如何优化。之前一直有读者朋友询问有没有技术交流群，但是由于各种原因一直都没创建，现在很高兴的在这里宣布，我创建了一个专门交流.NET 性能优化经验的群组，主题包括但不限于：</p>\n<ul>\n<li>如何找到.NET 性能瓶颈，如使用 APM、dotnet tools 等工具</li>\n<li>.NET 框架底层原理的实现，如垃圾回收器、JIT 等等</li>\n<li>如何编写高性能的.NET 代码，哪些地方存在性能陷阱</li>\n</ul>\n<p>希望能有更多志同道合朋友加入，分享一些工作中遇到的.NET 问题和宝贵的分析优化经验。<strong>目前一群已满，现在开放二群。</strong>可以加我 vx，我拉你进群: <strong>ls1075</strong> 另外也创建了 <strong>QQ Group</strong>: 687779078，欢迎大家加入。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-15 20:36</span>&nbsp;\n<a href=\"https://www.cnblogs.com/InCerry\">InCerry</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "别让你的小爱继续“装傻”了！5分钟给它换个“超强AI脑”，好用到全家惊呆！",
      "link": "https://www.cnblogs.com/bugshare/p/19618468",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/bugshare/p/19618468\" id=\"cb_post_title_url\" title=\"发布于 2026-02-15 18:31\">\n    <span>别让你的小爱继续“装傻”了！5分钟给它换个“超强AI脑”，好用到全家惊呆！</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>这年头，谁家里还没个“小爱同学”？</p>\n<p>但说实话，用久了你一定也发现了：</p>\n<p>问点复杂的，她就开始装傻——<br />\n“哎呀，这个问题难倒我了”；<br />\n想让她写个周报、出个方案、分析点东西？<br />\n除了放歌、设闹钟，基本属于<strong>智商掉线</strong>状态。</p>\n<p>如果我告诉你：<strong>只要 5 分钟，就能让家里这个“只会听指令的小爱”，直接升级成能写代码、能做方案、能陪你聊天的 AI 大神</strong>，你愿不愿意折腾一下？</p>\n<p>今天这篇文章，就是一个<strong>真正能照着做、不踩坑的保姆级教程</strong>。<br />\n我们用一个叫 <strong>Lerio AI Speaker</strong> 的工具，<br />\n<strong>给小爱同学来一次“原地飞升”</strong>。</p>\n<hr />\n<h1 id=\"一为什么要折腾这一出\">一、为什么要折腾这一出？</h1>\n<p>一句话总结：</p>\n<p>👉 <strong>给小爱同学换个“更聪明的大脑”。</strong></p>\n<h2 id=\"升级前的小爱\">升级前的小爱：</h2>\n<ul>\n<li>只能执行固定指令</li>\n<li>对话生硬，经常答非所问</li>\n<li>稍微复杂一点的问题就“我还没学会”</li>\n</ul>\n<h2 id=\"升级后的小爱\">升级后的小爱：</h2>\n<ul>\n<li>接入主流大模型（通义千问 / 智谱 AI / DeepSeek / 小米自研等）</li>\n<li>能理解上下文，正常聊天</li>\n<li>能写方案、改文案、写代码</li>\n<li>甚至可以当孩子的学习助手、你的情绪垃圾桶</li>\n</ul>\n<p><strong>最关键的一点：不用买新硬件。</strong><br />\n你家现在那个小爱音箱，直接就能用。</p>\n<hr />\n<h1 id=\"二准备工作3样东西就够\">二、准备工作（3样东西就够）</h1>\n<p>在开始之前，先确认你有下面这些：</p>\n<p>1️⃣ <strong>小米账号</strong>（已经绑定小爱音箱）<br />\n2️⃣ <strong>Lerio AI Speaker 账号</strong>（音箱和大模型之间的“中转站”）<br />\n3️⃣ <strong>Xiaomi MiMo API 开放平台账号</strong>（用小米账号就能登录）</p>\n<p>没什么技术门槛，全程网页操作。</p>\n<hr />\n<h1 id=\"三手把手教程一步一步来\">三、手把手教程（一步一步来）</h1>\n<h2 id=\"1️⃣-登录-lerio-控制台\">1️⃣ 登录 Lerio 控制台</h2>\n<p>打开：<br />\n👉 <a href=\"https://mi.lerio.cn/dashboard\" rel=\"noopener nofollow\" target=\"_blank\">https://mi.lerio.cn/dashboard</a></p>\n<p>注册并登录后，你会看到一个非常清爽的后台界面。</p>\n<hr />\n<h2 id=\"2️⃣-授权你的小米账号关键步骤\">2️⃣ 授权你的小米账号（关键步骤）</h2>\n<p>在后台找到 <strong>「我的账号」 → 立即配置</strong>。</p>\n<p>这里需要填写：</p>\n<ul>\n<li>小米 ID</li>\n<li>登录用的 <strong>passToken</strong></li>\n</ul>\n<p>这一步的作用：<br />\n👉 <strong>让 Lerio 拿到控制你音箱的权限</strong>，否则后面没法通信。</p>\n<pre><code class=\"language-bash\"># passToken 获取方法\n1. 使用 Chrome 浏览器访问小米账号官网并登录\n2. 按 F12 打开开发者工具\n3. 切换到 Application（应用）\n4. 左侧 Cookies → https://account.xiaomi.com\n5. 找到 passToken，复制它\n\n注意：不要主动退出小米账号，否则 passToken 会失效\n</code></pre>\n<p><img alt=\"PixPin_2026-02-12_16-09-42.png\" class=\"lazyload\" /></p>\n<blockquote>\n<p>这一块很多人会紧张，其实就是读取 Cookie，用完随时可以解绑。</p>\n</blockquote>\n<hr />\n<h2 id=\"3️⃣-创建使用卡槽\">3️⃣ 创建使用卡槽</h2>\n<ul>\n<li>新注册账号会送 <strong>3 天试用插槽</strong></li>\n<li>高峰期可能会有点拥挤</li>\n<li>如果想长期稳定用，可以开通付费（价格还能接受）</li>\n</ul>\n<p><img alt=\"PixPin_2026-02-12_16-16-26.png\" class=\"lazyload\" /></p>\n<hr />\n<h2 id=\"4️⃣-创建-ai-角色最好玩的地方\">4️⃣ 创建 AI 角色（最好玩的地方）</h2>\n<p>这里可以给小爱定一个“人设”。</p>\n<p>比如：</p>\n<ul>\n<li>毒舌但专业的翻译官</li>\n<li>耐心讲解的老教授</li>\n<li>给孩子讲故事的百科老师</li>\n</ul>\n<p>你写什么，它就按什么性格跟你说话。</p>\n<p><img alt=\"PixPin_2026-02-12_16-21-19.png\" class=\"lazyload\" /></p>\n<hr />\n<h2 id=\"5️⃣-添加你的小爱音箱\">5️⃣ 添加你的小爱音箱</h2>\n<p>绑定小米账号后：<br />\n👉 系统会自动拉取你名下所有的小爱设备。</p>\n<p>选中你要用的那个即可。</p>\n<p><img alt=\"PixPin_2026-02-12_16-25-12.png\" class=\"lazyload\" /></p>\n<hr />\n<h2 id=\"6️⃣-申请大模型-api-key\">6️⃣ 申请大模型 API Key</h2>\n<p>这里我们用 <strong>小米 Xiaomi MiMo 模型</strong> 举例：<br />\n👉 <a href=\"https://platform.xiaomimimo.com/#/console/api-keys\" rel=\"noopener nofollow\" target=\"_blank\">https://platform.xiaomimimo.com/#/console/api-keys</a></p>\n<p>创建并复制你的 API Key。</p>\n<p><img alt=\"PixPin_2026-02-12_16-31-07.png\" class=\"lazyload\" /></p>\n<hr />\n<h2 id=\"7️⃣-关联大模型装上灵魂\">7️⃣ 关联大模型（装上灵魂）</h2>\n<p>进入设备 → <strong>AI 服务配置</strong>：</p>\n<ul>\n<li>选择你要用的模型</li>\n<li>填入刚才申请的 API Key</li>\n</ul>\n<p><img alt=\"PixPin_2026-02-12_16-43-52.png\" class=\"lazyload\" /></p>\n<hr />\n<h2 id=\"8️⃣-启动服务开始对话\">8️⃣ 启动服务，开始对话</h2>\n<p>使用方式很简单：</p>\n<p>👉 <strong>先唤醒小爱 → 再说「请问 + 你的问题」</strong></p>\n<p>可以用你刚才设定的 AI 角色关键词，测试是否生效。</p>\n<p><img alt=\"PixPin_2026-02-12_16-49-02.png\" class=\"lazyload\" /></p>\n<p><img alt=\"PixPin_2026-02-12_16-57-59.png\" class=\"lazyload\" /></p>\n<hr />\n<h1 id=\"四升级后的小爱能干啥\">四、升级后的小爱，能干啥？</h1>\n<h2 id=\"场景一深夜情绪救援\">场景一：深夜情绪救援</h2>\n<ul>\n<li>\n<p>以前：</p>\n<blockquote>\n<p>“我可以为你播放一首伤感的歌”</p>\n</blockquote>\n</li>\n<li>\n<p>现在：</p>\n<blockquote>\n<p>“听得出来你很难受，要不要慢慢说给我听？”</p>\n</blockquote>\n</li>\n</ul>\n<hr />\n<h2 id=\"场景二办公摸鱼神器\">场景二：办公摸鱼神器</h2>\n<ul>\n<li>写周报</li>\n<li>出方案</li>\n<li>改文案</li>\n<li>想脚本</li>\n</ul>\n<p>一句话，全都能接住。</p>\n<hr />\n<h2 id=\"场景三孩子的十万个为什么\">场景三：孩子的十万个为什么</h2>\n<p>不用再照本宣科，<br />\n它能用<strong>孩子听得懂的话</strong>，把复杂问题讲清楚。</p>\n<hr />\n<h1 id=\"五一些实用小提醒\">五、一些实用小提醒</h1>\n<p>1️⃣ <strong>延迟是正常的</strong>：<br />\n云端大模型需要 1~2 秒思考时间。</p>\n<p>2️⃣ <strong>随时可解绑</strong>：<br />\n不想用了，后台一键关闭，小爱立刻恢复原样。</p>\n<hr />\n<h1 id=\"写在最后\">写在最后</h1>\n<p>当那个原本只会报天气的小音箱，<br />\n突然开始跟你聊人生、讲逻辑、写方案，<br />\n你会发现：</p>\n<p>👉 这 5 分钟，真的值。</p>\n<p>如果你在配置过程中遇到问题，<br />\n或者想接入更强的模型，<br />\n欢迎在评论区留言，我会一步步帮你搞定。</p>\n<p><strong>关注我，后面继续分享更多智能家居和 AI 的“野路子玩法”。</strong></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-15 18:31</span>&nbsp;\n<a href=\"https://www.cnblogs.com/bugshare\">BugShare</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "入门分享篇：一、工欲善其事，必先利其器",
      "link": "https://www.cnblogs.com/chenyouyuan/p/19618451",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/chenyouyuan/p/19618451\" id=\"cb_post_title_url\" title=\"发布于 2026-02-15 18:23\">\n    <span>入门分享篇：一、工欲善其事，必先利其器</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本次分享，面向接触计算机 or 机器人软件开发 or 嵌入式软件开发 的程序员 学习过程中好用的工具\n如果大家还有其他好用的工具也欢迎分享\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"入门分享篇一工欲善其事必先利其器\">入门分享篇：一、工欲善其事，必先利其器</h1>\n<blockquote>\n<p>本次分享，面向接触计算机 or 机器人软件开发 or 嵌入式软件开发 的程序员 学习过程中好用的工具</p>\n<p>如果大家还有其他好用的工具也欢迎分享</p>\n</blockquote>\n<h2 id=\"磨刀不误砍柴功熟悉你的电脑问题检索思维工具\">磨刀不误砍柴功：熟悉你的电脑、问题检索、思维工具</h2>\n<h3 id=\"学会科学的解决问题和有效的问问题\">学会科学的解决问题和有效的问问题</h3>\n<p>虽然讲的是黑客的提问方法，但其实是相通的。</p>\n<p><a href=\"https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md\" rel=\"noopener nofollow\" target=\"_blank\">How-To-Ask-Questions-The-Smart-Way/README-zh_CN.md at main · ryanhanwu/How-To-Ask-Questions-The-Smart-Way</a></p>\n<h4 id=\"tips如何有效的使用ai工具\">tips:如何有效的使用ai工具？</h4>\n<p>时代在飞速的发展和变化，一切重复性的工作都在逐渐被ai所取代，我们应当做的是着重于利用ai去在ai难以替代的优化和创造性的工作上下功夫。</p>\n<p>在现代ai可以很轻松的帮我们解决从0到1的问题，那问题就集中在我们如何去突破这个1？</p>\n<p>首先基础仍然很重要，你能够创造出什么样的东西仍然取决于你对基础知识的了解程度，当然现在你开始一个项目也不一定需要提前把所有知识全部掌握，但至少你开始做你的项目之前得知道你需要用到一些什么东西，你需要先搭建起一个宏观的实现某一功能的认知框架。在项目开始之前务必做好一定程度的搜索调研</p>\n<p>第二是清晰表述你的需求的能力，可以多尝试通过思维导图的方式来捋清楚自己的需求和逻辑</p>\n<p>第三是独立检索和判断能力，ai不一定能够精确的搜索到你所需要的内容，给出的建议也不一定是最优解，谨慎使用ai托管！（甚至后续还有植入广告的风险）</p>\n<p>第四清晰的知道不同的ai工具擅长什么，比如豆包擅长语言方面的处理，claude擅长编程，那你就可以吧你的需求跟豆包交流，让它纠正你的措辞，再去和claude交流，或者你可以人claude使用项目制的方式，读取你的需求文档，和你对接需求，修正需求等等</p>\n<p>第五 及时记录你的想法和所学所思，ai时代虽然相当于你的外置大脑，但是如果你什么都需要依靠ai来辅助的话，效率会相当低下，每次忘记一个东西又得问一遍ai。</p>\n<h3 id=\"入门工具指南\">入门工具指南</h3>\n<ol>\n<li>\n<p>你可以使用cursor、copilot、codex等各种各样的直接交互的ai编程工具，这比你复制代码给对话式ai然后再粘贴回来高效的多</p>\n<p>这些大部分都有教育优惠或者教育免费的政策</p>\n<p>最方便的你可以只用下载一个vscode，在vscode的拓展插件中下载copilot，再去github的官网申请教育特权，你就能获得一年的免费使用copilot的权限（具体获得方法自行搜索，主要是你得用英文，你的学生证明全部都得是翻译成英文的，也可以手写）</p>\n</li>\n<li>\n<p>学会使用github，有时候你可能上不去github，你想要最简单不花钱，稳定的方法就是去微软商店下steam++（watt toolkit），魔法（会魔法的自然能学会就不多梭啦）</p>\n</li>\n<li>\n<p>建议你选一款适合自己的笔记软件（markdowm），比如obsidian、typora</p>\n<p>我是配合着使用的，obsidian有强大的搜索功能，typora可以有良好的书写体验（typora有非常多的主题可以选择，你也可以配置你的图床，自动上传你粘贴到typora的图片到云端，这样就能不用担心图片的分享问题啦</p>\n</li>\n<li>\n<p>建议你有一款合适的思维导图软件，project graph /Xmind都可以，尽量选界面脱俗一些，这在一些比赛要提交的报告中有很好绘图说明作用，在平时也可以给你提供思维向导</p>\n</li>\n<li>\n<p>建议你在博客园注册一个个人账户，发一发你的学习记录，可以当成一个知识网盘，也可以积累一定的粉丝和阅读量，可能有助于你后续找工作，tips:可以使用Cnblogs-Theme-SimpleMemory自定义你的博客页面噢</p>\n</li>\n<li>\n<p>git的学习相当重要！比赛/项目中的版本迭代很快，你如果没有git工具做版本管理，很容易丢失了原来的代码，喊天菩萨都没有用辣，学习教程在”参考书目/vscode_git本地代码版本管理及远程仓库保存“，你可以在vscode中安装git graph插件更直观的看到你的版本变化</p>\n</li>\n</ol>\n<h2 id=\"vscode-宇宙级ide\">vscode 宇宙级ide</h2>\n<p><a href=\"https://code.visualstudio.com/\" rel=\"noopener nofollow\" target=\"_blank\">Visual Studio Code - The open source AI code editor</a></p>\n<p>几乎所有热门的开发都可以在vscode上找到插件</p>\n<p>其自带的copilot也是十分方便的ai编程助手</p>\n<h2 id=\"git使用指南\">git使用指南</h2>\n<p><a href=\"https://bbs.robomaster.com/article/55660?source=4\" rel=\"noopener nofollow\" target=\"_blank\">【分享】如何使用VScode+git进行本地代码版本管理及远程仓库保存-RoboMaster 社区</a></p>\n<h2 id=\"笔记记录工具-typora\">笔记记录工具 typora</h2>\n<p>超级顺手的markdowm书写体验</p>\n<h3 id=\"markdowm语法的学习\">markdowm语法的学习</h3>\n<p><a href=\"https://markdown.com.cn/basic-syntax/\" rel=\"noopener nofollow\" target=\"_blank\">Markdown 基本语法 | Markdown 教程</a></p>\n<h3 id=\"typora配置图床\">typora配置图床</h3>\n<p><a href=\"https://zhuanlan.zhihu.com/p/346410333\" rel=\"noopener nofollow\" target=\"_blank\">(13 封私信 / 80 条消息) Typora+图床详解（小白都能学得会） - 知乎</a></p>\n<h2 id=\"笔记检索链接工具-obsidian\">笔记检索/链接工具 obsidian</h2>\n<p>强大的检索功能和链接反链接功能</p>\n<h3 id=\"自动同步和上传的git插件\">自动同步和上传的git插件</h3>\n<p><a href=\"https://www.bilibili.com/video/BV1qCh9zrEKq/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f553a12b04c16a678ddc0064cc04563c\" rel=\"noopener nofollow\" target=\"_blank\">obsidian使用git进行多平台同步_哔哩哔哩_bilibili</a></p>\n<h2 id=\"思维导图工具-project-graph\">思维导图工具 project graph</h2>\n<p><a href=\"https://www.bilibili.com/video/BV1y2xdzUEXa/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f553a12b04c16a678ddc0064cc04563c\" rel=\"noopener nofollow\" target=\"_blank\">project-graph 2.0更新介绍：prg文件/树形布局增强/连线增强/窗口新玩法_哔哩哔哩_bilibili</a></p>\n<p>强大的可视化和高度自定义的思维导图软件！</p>\n<h2 id=\"我们热血沸腾的组合技\">我们热血沸腾的组合技</h2>\n<p>typora + obsidian + project graph</p>\n<h2 id=\"博客园\">博客园</h2>\n<p><a href=\"https://www.cnblogs.com/\" target=\"_blank\">博客园 - 开发者的网上家园</a></p>\n<h3 id=\"创造独属于你的博客\">创造独属于你的博客！</h3>\n<p><a href=\"https://github.com/BNDong/Cnblogs-Theme-SimpleMemory\" rel=\"noopener nofollow\" target=\"_blank\">BNDong/Cnblogs-Theme-SimpleMemory: 🍭　Cnblogs theme _ Basic theme : SimpleMemory</a></p>\n<p><a href=\"https://www.cnblogs.com/lingyunvoid/p/beautify.html\" target=\"_blank\">博客园美化「详细教程+代码配置」 - 凌云_void - 博客园</a></p>\n<h2 id=\"edge浏览器\">edge浏览器</h2>\n<p>大多数浏览器都有插件功能，插件真的很好用！</p>\n<h3 id=\"青柠起始页\">青柠起始页</h3>\n<h3 id=\"沉浸式翻译\">沉浸式翻译</h3>\n<h3 id=\"global-speed\">global speed</h3>\n<blockquote>\n<p>路虽远，行则将至✨</p>\n</blockquote>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-15 18:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/chenyouyuan\">ChenYY~</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "为什么在代理服务器上测试， http2 的转发性能比 http 1 更低？",
      "link": "https://www.cnblogs.com/ahfuzhang/p/19618259",
      "published": "",
      "description": "<div class=\"postcontent\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p><strong><font color=\"gray\" size=\"1\">作者:张富春(ahfuzhang)，转载时请注明作者和引用链接，谢谢！</font></strong></p>\n<ul>\n<li><font color=\"gray\" size=\"1\"><a href=\"https://www.cnblogs.com/ahfuzhang/\" target=\"_blank\">cnblogs博客</a></font></li>\n<li><font color=\"gray\" size=\"1\"><a href=\"https://www.zhihu.com/people/ahfuzhang/posts\" rel=\"noopener nofollow\" target=\"_blank\">zhihu</a></font></li>\n<li><font color=\"gray\" size=\"1\"><a href=\"https://github.com/ahfuzhang\" rel=\"noopener nofollow\" target=\"_blank\">Github</a></font></li>\n<li><font color=\"gray\" size=\"1\">公众号:一本正经的瞎扯</font><br />\n<img alt=\"\" class=\"lazyload\" /></li>\n</ul>\n<hr />\n<p>我在测试 Http2 server 与 Http 1.1 server 的性能差异时，最高测试数据是 http2 比 http1 快 3.6 倍。<br />\n而 Carter 在测试 apisix 代理服务器的性能的时候，得到的数据是 http2 的性能只有 http 1 的 80%。<br />\n我们曾彼此质疑对方的数据，并觉得不可思议！<br />\n我的观点是：二进制协议一定快过文本协议，没理由在代理服务器上测试的数据会导致 http2 慢于 http 1。</p>\n<p>今天终于想明白了原因，其实我们都没错！<br />\n结论是：在代理服务器上，http2 的转发性能会低于 http 1。<br />\n导致这一项差异的关键是 <code>splice()</code> 系统调用，也就是代理服务器中实现<code>零拷贝</code>的关键。</p>\n<p>(后续大量引用 ChatGPT 的回答)</p>\n<h1 id=\"splice-是什么\">splice() 是什么？</h1>\n<p>splice() 是 Linux 的一个系统调用（C 里通过 splice(2) 暴露），用来在 两个文件描述符之间搬运数据，并且尽量走 零拷贝（zero-copy） 路径，减少用户态缓冲区参与。</p>\n<p>最典型的用途：文件 ↔ 管道、管道 ↔ socket，用它可以把数据从磁盘文件直接“送”到网络连接里，中间不需要 read() 到用户态再 write() 回内核。</p>\n<p>⸻</p>\n<p>它解决什么问题</p>\n<p>传统写法：</p>\n<pre><code class=\"language-c\">read(file_fd, user_buf, n);\nwrite(sock_fd, user_buf, n);\n</code></pre>\n<p>缺点：数据会在内核 ↔ 用户态之间拷贝（还可能污染 CPU cache、占用内存带宽）。</p>\n<p>splice() 的目标：让数据尽量在内核内部移动（比如从 page cache / pipe buffer 直接到 socket buffer），减少一次或多次拷贝。</p>\n<p>⸻</p>\n<p>它的基本形态（语义）</p>\n<pre><code class=\"language-c\">ssize_t splice(int fd_in,  loff_t *off_in,\n               int fd_out, loff_t *off_out,\n               size_t len, unsigned int flags);\n</code></pre>\n<pre><code>•\tfd_in / fd_out：输入/输出 fd\n•\toff_in / off_out：\n•\t传 NULL 表示使用 fd 当前偏移并推进（像普通读写那样）\n•\t非 NULL 则用你提供的偏移（类似 pread/pwrite 的味道），并且不一定修改 fd 的文件偏移（具体取决于对象类型）\n•\tlen：最多搬运多少字节\n•\tflags：控制阻塞/移动行为（例如 SPLICE_F_NONBLOCK 等）\n</code></pre>\n<p>返回值：实际搬运的字节数；0 通常表示 EOF；-1 表示出错（errno 说明原因）。</p>\n<p>⸻</p>\n<p>常见组合</p>\n<ol>\n<li>\n<p>file → pipe → socket（高性能“发送文件”）<br />\n•\tsplice(file_fd → pipe_write_end)<br />\n•\tsplice(pipe_read_end → sock_fd)<br />\n这类组合常用于实现“类似 sendfile 的效果”，但 splice 更通用（尤其适合你还要在中间做点别的内核态处理的场景）。</p>\n</li>\n<li>\n<p>pipe ↔ pipe</p>\n</li>\n</ol>\n<p>用于在管道之间转移数据（比如配合 tee() 做复制）。</p>\n<p>⸻</p>\n<p>适用限制（很重要）<br />\n•\t并不是任意 fd 都支持。splice 需要底层文件操作实现支持（VFS/驱动/协议栈）。<br />\n•\t在 Linux 上，pipe 经常是 splice 的“中转站”：很多场景要求 fd_in 或 fd_out 至少有一端是 pipe（或者最终在内核内部用 pipe buffer 做承载）。<br />\n•\t数据来源如果是普通文件，通常来自 page cache（因此能做到少拷贝或零拷贝）。</p>\n<p>⸻</p>\n<p>和 sendfile() 的关系<br />\n•\tsendfile()：更“专用”，通常是 文件 → socket 的快速路径。<br />\n•\tsplice()：更“通用”，可以在更多类型的 fd 之间搬运，常见用法是 通过 pipe 作为桥 来拼接成 file→socket 的零拷贝链路。</p>\n<h1 id=\"就算-splice-把内核中-socket-buffer-的数据转移到了-pipe-下面用户使用时也仍然要-read似乎并没有做到零拷贝\">就算 splice 把内核中 socket buffer 的数据转移到了 pipe 下面，用户使用时也仍然要 read()，似乎并没有做到零拷贝？</h1>\n<p>对，你理解得很准确：只要最终要在用户态“看见/处理”字节流，就绕不开一次 copy_to_user。splice(socket → pipe) 只是把“从 socket 读到用户缓冲区”这一步，换成了“从 socket 读到内核 pipe”，因此它不能消除“内核 → 用户态”的拷贝；你后面 read(pipefd, userbuf, …) 仍然会拷贝。</p>\n<p>更精确地说：<br />\n•\t传统路径（用户态消费）<br />\nrecv()/read(socket, userbuf)<br />\n→ 内核 socket 接收队列 → 用户态 userbuf（一次 copy_to_user）<br />\n•\tsplice 路径（用户态仍要消费）<br />\nsplice(socket → pipe)（内核内搬运/重挂页，避免 copy_to_user）<br />\n然后 read(pipe → userbuf)<br />\n→ pipe → 用户态 userbuf（还是一次 copy_to_user）</p>\n<p>所以：“用户态要拿到 payload”这一目标下，splice 不会减少总拷贝次数到 0。它可能减少的是：<br />\n•\t少一次“多余的中间 buffer 拷贝/搬运”（比如你原来先 read 到用户，再 write 到另一个 fd）<br />\n•\t或减少 CPU 开销（某些场景下从 socket 直接挂到 pipe、再 splice 到目标 fd）</p>\n<h1 id=\"什么时候-splice-真正有意义能把用户态拷贝降到-0\">什么时候 splice 真正有意义（能把用户态拷贝降到 0）？</h1>\n<ol>\n<li>纯转发（不解析数据）</li>\n</ol>\n<p>socket_in → pipe → socket_out / file<br />\n你不在用户态触碰数据，只做转发/落盘。典型：反向代理、L7 但不解包、录流到文件等。</p>\n<ol start=\"2\">\n<li>“只看少量头部 + 大量 body” 的混合</li>\n</ol>\n<p>比如 HTTP：你在用户态只 recv 一小段 header 做决策；body 用 splice 走零拷贝转发。<br />\n这类能显著减少 copy_to_user 的总量（因为大头 body 不进用户态）。</p>\n<p>⸻</p>\n<p>你真正关心的点：TCP 通讯里的拷贝到底能不能减少？<br />\n•\t应用层必须处理 payload（解码、压缩、JSON、protobuf…）：<br />\n至少一次内核→用户拷贝不可避免（把字节交给进程）。<br />\n•\t应用层不处理 payload，只转发：<br />\n可以做到 0 次进入用户态（splice/送 NIC 相关 offload 另说）。</p>\n<h1 id=\"对于代理服务器-是不是可以理解为-http-1-大部分都情况能做内核态的四层转发而-http-2-只能做用户态的七层转发\">对于代理服务器， 是不是可以理解为 http 1 大部分都情况能做内核态的四层转发，而 http 2 只能做用户态的七层转发?</h1>\n<p>不完全对，但你这个直觉抓到了一半：决定能不能“像 L4 那样内核态转发”的关键，不是 HTTP/1 vs HTTP/2，而是代理要不要理解协议语义、要不要“终止连接并重建连接”。 HTTP/2 因为多路复用 + 流控 + 头压缩，确实更容易把你“逼到”用户态 L7，但 HTTP/1 也不是天然就能内核态转发。</p>\n<p>把它拆成几种代理形态，你会更清楚：</p>\n<ol>\n<li>真·L4 代理（TCP/四层负载均衡）<br />\n•\t不看 HTTP，只转发字节流：客户端 TCP ↔ 后端 TCP。<br />\n•\t这对 HTTP/1 和 HTTP/2 都一样：都能做“内核友好”的转发（例如 splice/零拷贝路径、甚至内核里的 TPROXY/IPVS 等）。<br />\n•\t代价：你做不了按 URL/Host/Header 的路由、鉴权、限速等 L7 能力。</li>\n</ol>\n<p>✅ 结论：HTTP/2 也可以做 L4 转发，只是此时你根本不知道它是 HTTP/2。</p>\n<ol start=\"2\">\n<li>HTTP/1 的 L7 反代（常见 Nginx/Envoy 的那种）<br />\n•\t你要读请求行/headers，决定路由，可能改 header，可能缓存、压缩、重试等。<br />\n•\t这就已经是 用户态 L7 了，不是“内核态 L4”。</li>\n</ol>\n<p>不过 HTTP/1 有一个“容易优化”的点：<br />\n•\theader/body 分界清晰，且通常一个连接同一时刻服务一个请求（即便 keep-alive，也多是串行，管线化很少用）。<br />\n•\t所以可以做 “只在用户态读少量 header，然后 body 用 splice 直通”（大 body 上传/下载时很香）。</p>\n<p>✅ 结论：HTTP/1 不是“大部分都能内核态 L4 转发”，它只是 更容易做“半 L7 + 半零拷贝直通”。</p>\n<ol start=\"3\">\n<li>HTTP/2 的 L7 反代（stream 级路由、多路复用）<br />\n•\t同一条 TCP 连接里交错多个 stream 的 frames。<br />\n•\t你要按 stream 拆帧、调度、维护流控窗口、处理 HPACK。<br />\n•\t前后两端通常是两条独立连接（客户端一条 H2，后端另一条 H2 或 H1），stream id/窗口/HPACK 动态表都不可能原封不动“直通”。</li>\n</ol>\n<p>这使得 把大段 payload 当作连续字节“splice 过去”非常困难，因为你必须先在用户态把属于某个 stream 的 DATA 帧摘出来再发到后端（而且还可能要重排/限速/优先级）。</p>\n<p>✅ 结论：HTTP/2 做 L7 反代时，基本只能用户态为主（或者说，必须有“协议终止点”在用户态/实现层）。</p>\n<p>⸻</p>\n<p>更准确的一句话<br />\n•\tHTTP/1：更容易把“body”做成内核态直通（splice/sendfile），用户态只处理少量控制面（headers）。<br />\n•\tHTTP/2：只要你要做 L7（按 stream/headers 路由），就很难做到 body 完全内核态直通，因为 framing/mux/flow-control 迫使你参与数据分发。<br />\n•\t但 HTTP/2 依然可以做纯 L4 转发（只是你失去所有 L7 能力）。</p>\n<h1 id=\"总结\">总结</h1>\n<ul>\n<li>http 1.1 的协议特点：header 和 body 有明显的区分，body 的长度非常明确，一条 tcp 连接上同时只有一个请求响应 —— 因此，在代理服务器的场景， http 1 很容易使用 splice 这样零拷贝机制来优化。\n<ul>\n<li>特别是 body 部分这样更长的内容，直接在内核态就能够实现数据交换，完全不需要把数据拷贝到用户态，再从用户态发送出去。</li>\n</ul>\n</li>\n<li>http 2 在一条 tcp 连接上有多个流，每个流超出 <code>SETTINGS_MAX_FRAME_SIZE</code> 后还会分成多个 frame —— 由此决定了 http2 上通过 splice 实现零拷贝优化很困难，或者说能够真正零拷贝的场景变少了。</li>\n<li>对于服务器而言：\n<ul>\n<li>http 2 这样的二进制协议确实比 http 1 更快，特别是像 api server / rcp server 这样的数据包小+请求频繁的场景，http2 比 http1 快 3.6 倍就不奇怪了。</li>\n<li>如果是图片下载/文件下载/大吞吐量的数据传输，选择 http1 更好</li>\n</ul>\n</li>\n</ul>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"itemdesc\">\n\t\t\t发表于 \n<span id=\"post-date\">2026-02-15 16:15</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ahfuzhang\">ahfuzhang</a>&nbsp;\n阅读(<span id=\"post_view_count\">2</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</div>"
    },
    {
      "title": "Go - slog使用入门",
      "link": "https://www.cnblogs.com/XY-Heruo/p/19618220",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/XY-Heruo/p/19618220\" id=\"cb_post_title_url\" title=\"发布于 2026-02-15 15:45\">\n    <span>Go - slog使用入门</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        Go标准库slog使用入门\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"简介\">简介</h2>\n<p><code>slog</code> 是 Go 1.21 引入的官方结构化日志库（Structured Logging）。它结束了 Go 标准库只有简单 <code>log</code> 包的历史，让我们可以直接输出 <strong>JSON</strong> 或 <strong>Key-Value</strong> 格式的日志，非常适合对接 ELK、Grafana Loki 等日志分析系统。</p>\n<p>相较于第三方日志库如 <code>zap</code>、<code>logrus</code>，<code>slog</code> 的优势在于：</p>\n<ul>\n<li><strong>零依赖</strong>：作为标准库的一部分，无需引入第三方依赖</li>\n<li><strong>官方维护</strong>：长期稳定，API 变更有 Go 兼容性承诺保障</li>\n<li><strong>接口简洁</strong>：API 设计清晰，学习成本低</li>\n<li><strong>可扩展</strong>：通过自定义 Handler 可以实现各种定制需求</li>\n</ul>\n<h2 id=\"基本使用\">基本使用</h2>\n<p><code>slog</code> 用起来非常简单。默认输出到标准错误流（<code>os.Stderr</code>），格式为普通文本。</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n\t\"fmt\"\n\t\"log/slog\"\n)\n\nfunc main() {\n\tslog.Debug(\"Hello world\")\n\tslog.Info(\"Hello world\")\n\tslog.Warn(\"Hello world\")\n\tslog.Error(\"Hello world\")\n\n\tslog.Info(\"this is a message\", \"name\", \"zhangsan\")\n\n\tage := 8\n\tslog.Warn(fmt.Sprintf(\"这是 %d 岁?\", age))\n}\n</code></pre>\n<p>运行输出：</p>\n<pre><code class=\"language-shell\">$ go run main.go\n2026/02/15 11:52:24 INFO Hello world\n2026/02/15 11:52:24 WARN Hello world\n2026/02/15 11:52:24 ERROR Hello world\n2026/02/15 11:52:24 INFO this is a message name=zhangsan\n2026/02/15 11:52:24 WARN 这是 8 岁?\n</code></pre>\n<blockquote>\n<p><strong>注意</strong>：默认的 <code>slog</code> logger 日志级别为 <code>INFO</code>，因此 <code>Debug</code> 级别的日志不会输出。</p>\n</blockquote>\n<h3 id=\"日志级别\">日志级别</h3>\n<p><code>slog</code> 定义了四个日志级别，从低到高依次为：</p>\n<table>\n<thead>\n<tr>\n<th>级别</th>\n<th>常量</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DEBUG</td>\n<td><code>slog.LevelDebug</code></td>\n<td>调试信息，开发环境使用</td>\n</tr>\n<tr>\n<td>INFO</td>\n<td><code>slog.LevelInfo</code></td>\n<td>常规信息</td>\n</tr>\n<tr>\n<td>WARN</td>\n<td><code>slog.LevelWarn</code></td>\n<td>警告信息</td>\n</tr>\n<tr>\n<td>ERROR</td>\n<td><code>slog.LevelError</code></td>\n<td>错误信息</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"输出-json-格式\">输出 JSON 格式</h2>\n<p><code>slog</code> 可以输出 JSON 格式，便于与 ELK、Grafana Loki 等日志系统集成。</p>\n<p>以下示例演示了如何修改默认的时间戳格式和调用源输出格式，并将其设置为默认 logger：</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n\t\"fmt\"\n\t\"log/slog\"\n\t\"os\"\n\t\"time\"\n)\n\nfunc main() {\n\tjsonLogger := slog.New(slog.NewJSONHandler(os.Stderr, &amp;slog.HandlerOptions{\n\t\tAddSource: true,            // 添加调用源信息\n\t\tLevel:     slog.LevelDebug, // 设置日志级别\n\t\tReplaceAttr: func(groups []string, a slog.Attr) slog.Attr {\n\t\t\t// 自定义时间格式\n\t\t\tif a.Key == slog.TimeKey {\n\t\t\t\tif t, ok := a.Value.Any().(time.Time); ok {\n\t\t\t\t\ta.Value = slog.StringValue(t.Format(time.RFC3339))\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 简化调用源信息，只保留文件名和行号\n\t\t\tif a.Key == slog.SourceKey {\n\t\t\t\tsource := a.Value.Any().(*slog.Source)\n\t\t\t\tshortFile := source.File\n\t\t\t\tfor i := len(source.File) - 1; i &gt; 0; i-- {\n\t\t\t\t\tif source.File[i] == '/' {\n\t\t\t\t\t\tshortFile = source.File[i+1:]\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn slog.String(\"source\", fmt.Sprintf(\"%s:%d\", shortFile, source.Line))\n\t\t\t}\n\t\t\treturn a\n\t\t},\n\t}))\n\n\tjsonLogger.Debug(\"Hello world\")\n\tjsonLogger.Info(\"Hello world\")\n\tjsonLogger.Warn(\"Hello world\")\n\tjsonLogger.Error(\"Hello world\")\n\n\tjsonLogger.Info(\"this is a message\", \"name\", \"zhangsan\")\n\n\tage := 8\n\tjsonLogger.Warn(fmt.Sprintf(\"这是 %d 岁?\", age))\n\n\t// 替换默认 logger\n\tslog.SetDefault(jsonLogger)\n\tslog.Debug(\"Hello world\")\n\tslog.Info(\"Hello world\")\n\tslog.Warn(\"Hello world\")\n\tslog.Error(\"Hello world\")\n\n\tslog.Info(\"this is a message\", \"name\", \"zhangsan\")\n\n\tage = 9\n\tslog.Warn(fmt.Sprintf(\"这是 %d 岁?\", age))\n}\n</code></pre>\n<p>运行输出：</p>\n<pre><code class=\"language-shell\">$ go run main.go\n{\"time\":\"2026-02-15T12:07:32+08:00\",\"level\":\"DEBUG\",\"source\":\"main.go:38\",\"msg\":\"Hello world\"}\n{\"time\":\"2026-02-15T12:07:32+08:00\",\"level\":\"INFO\",\"source\":\"main.go:39\",\"msg\":\"Hello world\"}\n{\"time\":\"2026-02-15T12:07:32+08:00\",\"level\":\"WARN\",\"source\":\"main.go:40\",\"msg\":\"Hello world\"}\n{\"time\":\"2026-02-15T12:07:32+08:00\",\"level\":\"ERROR\",\"source\":\"main.go:41\",\"msg\":\"Hello world\"}\n{\"time\":\"2026-02-15T12:07:32+08:00\",\"level\":\"INFO\",\"source\":\"main.go:43\",\"msg\":\"this is a message\",\"name\":\"zhangsan\"}\n{\"time\":\"2026-02-15T12:07:32+08:00\",\"level\":\"WARN\",\"source\":\"main.go:46\",\"msg\":\"这是 8 岁?\"}\n{\"time\":\"2026-02-15T12:07:32+08:00\",\"level\":\"DEBUG\",\"source\":\"main.go:50\",\"msg\":\"Hello world\"}\n{\"time\":\"2026-02-15T12:07:32+08:00\",\"level\":\"INFO\",\"source\":\"main.go:51\",\"msg\":\"Hello world\"}\n{\"time\":\"2026-02-15T12:07:32+08:00\",\"level\":\"WARN\",\"source\":\"main.go:52\",\"msg\":\"Hello world\"}\n{\"time\":\"2026-02-15T12:07:32+08:00\",\"level\":\"ERROR\",\"source\":\"main.go:53\",\"msg\":\"Hello world\"}\n{\"time\":\"2026-02-15T12:07:32+08:00\",\"level\":\"INFO\",\"source\":\"main.go:55\",\"msg\":\"this is a message\",\"name\":\"zhangsan\"}\n{\"time\":\"2026-02-15T12:07:32+08:00\",\"level\":\"WARN\",\"source\":\"main.go:58\",\"msg\":\"这是 9 岁?\"}\n</code></pre>\n<h3 id=\"handleroptions-详解\">HandlerOptions 详解</h3>\n<p><code>HandlerOptions</code> 提供了三个配置项：</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>AddSource</code></td>\n<td><code>bool</code></td>\n<td>是否添加调用源信息（文件名和行号）</td>\n</tr>\n<tr>\n<td><code>Level</code></td>\n<td><code>slog.Leveler</code></td>\n<td>最低日志级别，低于此级别的日志将被忽略</td>\n</tr>\n<tr>\n<td><code>ReplaceAttr</code></td>\n<td><code>func([]string, slog.Attr) slog.Attr</code></td>\n<td>用于修改或替换属性的回调函数</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"with-注入通用属性\">With 注入通用属性</h2>\n<p>创建 Logger 时，可以用 <code>With</code> 方法为 logger 添加通用属性。这些属性会自动附加到每条日志记录中，适合注入服务名、环境、版本等上下文信息。</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n\t\"fmt\"\n\t\"log/slog\"\n\t\"os\"\n\t\"time\"\n)\n\nfunc main() {\n\tjsonLogger := slog.New(slog.NewJSONHandler(os.Stderr, &amp;slog.HandlerOptions{\n\t\tAddSource: true,\n\t\tLevel:     slog.LevelDebug,\n\t\tReplaceAttr: func(groups []string, a slog.Attr) slog.Attr {\n\t\t\tif a.Key == slog.TimeKey {\n\t\t\t\tif t, ok := a.Value.Any().(time.Time); ok {\n\t\t\t\t\ta.Value = slog.StringValue(t.Format(time.RFC3339))\n\t\t\t\t}\n\t\t\t}\n\t\t\tif a.Key == slog.SourceKey {\n\t\t\t\tsource := a.Value.Any().(*slog.Source)\n\t\t\t\tshortFile := source.File\n\t\t\t\tfor i := len(source.File) - 1; i &gt; 0; i-- {\n\t\t\t\t\tif source.File[i] == '/' {\n\t\t\t\t\t\tshortFile = source.File[i+1:]\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn slog.String(\"source\", fmt.Sprintf(\"%s:%d\", shortFile, source.Line))\n\t\t\t}\n\t\t\treturn a\n\t\t},\n\t})).With(\"logger\", \"json\", \"env\", \"production\")\n\n\tjsonLogger.Debug(\"Hello world\")\n\tjsonLogger.Info(\"Hello world\")\n\tjsonLogger.Warn(\"Hello world\")\n\tjsonLogger.Error(\"Hello world\")\n\n\tjsonLogger.Info(\"this is a message\", \"name\", \"zhangsan\")\n}\n</code></pre>\n<p>运行输出：</p>\n<pre><code class=\"language-shell\">$ go run main.go\n{\"time\":\"2026-02-15T13:24:38+08:00\",\"level\":\"DEBUG\",\"source\":\"main.go:42\",\"msg\":\"Hello world\",\"logger\":\"json\",\"env\":\"production\"}\n{\"time\":\"2026-02-15T13:24:38+08:00\",\"level\":\"INFO\",\"source\":\"main.go:43\",\"msg\":\"Hello world\",\"logger\":\"json\",\"env\":\"production\"}\n{\"time\":\"2026-02-15T13:24:38+08:00\",\"level\":\"WARN\",\"source\":\"main.go:44\",\"msg\":\"Hello world\",\"logger\":\"json\",\"env\":\"production\"}\n{\"time\":\"2026-02-15T13:24:38+08:00\",\"level\":\"ERROR\",\"source\":\"main.go:45\",\"msg\":\"Hello world\",\"logger\":\"json\",\"env\":\"production\"}\n{\"time\":\"2026-02-15T13:24:38+08:00\",\"level\":\"INFO\",\"source\":\"main.go:47\",\"msg\":\"this is a message\",\"logger\":\"json\",\"env\":\"production\",\"name\":\"zhangsan\"}\n</code></pre>\n<h2 id=\"使用-group-对属性分组\">使用 Group 对属性分组</h2>\n<p>当日志属性较多时，可以使用 <code>slog.Group</code> 将相关属性组织在一起，使输出结构更清晰：</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n\t\"fmt\"\n\t\"log/slog\"\n\t\"os\"\n\t\"time\"\n)\n\nfunc main() {\n\tjsonLogger := slog.New(slog.NewJSONHandler(os.Stderr, &amp;slog.HandlerOptions{\n\t\tAddSource: true,\n\t\tLevel:     slog.LevelDebug,\n\t\tReplaceAttr: func(groups []string, a slog.Attr) slog.Attr {\n\t\t\tif a.Key == slog.TimeKey {\n\t\t\t\tif t, ok := a.Value.Any().(time.Time); ok {\n\t\t\t\t\ta.Value = slog.StringValue(t.Format(time.RFC3339))\n\t\t\t\t}\n\t\t\t}\n\t\t\tif a.Key == slog.SourceKey {\n\t\t\t\tsource := a.Value.Any().(*slog.Source)\n\t\t\t\tshortFile := source.File\n\t\t\t\tfor i := len(source.File) - 1; i &gt; 0; i-- {\n\t\t\t\t\tif source.File[i] == '/' {\n\t\t\t\t\t\tshortFile = source.File[i+1:]\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn slog.String(\"source\", fmt.Sprintf(\"%s:%d\", shortFile, source.Line))\n\t\t\t}\n\t\t\treturn a\n\t\t},\n\t}))\n\n\tjsonLogger = jsonLogger.With(\"logger\", \"json\")\n\n\t// 使用 Group 组织相关属性\n\tjsonLogger.Info(\"系统状态\",\n\t\tslog.Group(\"metrics\",\n\t\t\tslog.Int(\"cpu\", 4),\n\t\t\tslog.Float64(\"memPercent\", 2.33),\n\t\t),\n\t\tslog.Group(\"request\",\n\t\t\tslog.String(\"method\", \"GET\"),\n\t\t\tslog.String(\"path\", \"/api/users\"),\n\t\t),\n\t)\n}\n</code></pre>\n<p>运行输出：</p>\n<pre><code class=\"language-shell\">$ go run main.go\n{\"time\":\"2026-02-15T13:30:08+08:00\",\"level\":\"INFO\",\"source\":\"main.go:43\",\"msg\":\"系统状态\",\"logger\":\"json\",\"metrics\":{\"cpu\":4,\"memPercent\":2.33},\"request\":{\"method\":\"GET\",\"path\":\"/api/users\"}}\n</code></pre>\n<h2 id=\"高性能场景使用-logattrs\">高性能场景使用 LogAttrs</h2>\n<p>如果需要在高性能循环中打印日志，建议使用 <code>LogAttrs</code> 方法。它使用强类型属性（<code>slog.Attr</code>），避免了反射带来的性能开销。</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n\t\"context\"\n\t\"log/slog\"\n\t\"os\"\n\t\"time\"\n)\n\nfunc main() {\n\tjsonLogger := slog.New(slog.NewJSONHandler(os.Stderr, &amp;slog.HandlerOptions{\n\t\tAddSource: true,\n\t\tLevel:     slog.LevelDebug,\n\t\tReplaceAttr: func(groups []string, a slog.Attr) slog.Attr {\n\t\t\tif a.Key == slog.TimeKey {\n\t\t\t\tif t, ok := a.Value.Any().(time.Time); ok {\n\t\t\t\t\ta.Value = slog.StringValue(t.Format(time.RFC3339))\n\t\t\t\t}\n\t\t\t}\n\t\t\tif a.Key == slog.SourceKey {\n\t\t\t\tsource := a.Value.Any().(*slog.Source)\n\t\t\t\tshortFile := source.File\n\t\t\t\tfor i := len(source.File) - 1; i &gt; 0; i-- {\n\t\t\t\t\tif source.File[i] == '/' {\n\t\t\t\t\t\tshortFile = source.File[i+1:]\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn slog.String(\"source\", fmt.Sprintf(\"%s:%d\", shortFile, source.Line))\n\t\t\t}\n\t\t\treturn a\n\t\t},\n\t})).With(\"logger\", \"json\")\n\n\tfor i := range 5 {\n\t\tjsonLogger.LogAttrs(\n\t\t\tcontext.Background(),\n\t\t\tslog.LevelInfo,\n\t\t\t\"执行遍历\",\n\t\t\tslog.Int(\"round\", i),\n\t\t\tslog.String(\"task_name\", \"cleanup\"),\n\t\t\tslog.Duration(\"duration\", time.Second*time.Duration(i+1)),\n\t\t)\n\t}\n}\n</code></pre>\n<p>运行输出：</p>\n<pre><code class=\"language-shell\">$ go run main.go\n{\"time\":\"2026-02-15T13:38:21+08:00\",\"level\":\"INFO\",\"source\":\"main.go:45\",\"msg\":\"执行遍历\",\"logger\":\"json\",\"round\":0,\"task_name\":\"cleanup\",\"duration\":1000000000}\n{\"time\":\"2026-02-15T13:38:21+08:00\",\"level\":\"INFO\",\"source\":\"main.go:45\",\"msg\":\"执行遍历\",\"logger\":\"json\",\"round\":1,\"task_name\":\"cleanup\",\"duration\":2000000000}\n{\"time\":\"2026-02-15T13:38:21+08:00\",\"level\":\"INFO\",\"source\":\"main.go:45\",\"msg\":\"执行遍历\",\"logger\":\"json\",\"round\":2,\"task_name\":\"cleanup\",\"duration\":3000000000}\n{\"time\":\"2026-02-15T13:38:21+08:00\",\"level\":\"INFO\",\"source\":\"main.go:45\",\"msg\":\"执行遍历\",\"logger\":\"json\",\"round\":3,\"task_name\":\"cleanup\",\"duration\":4000000000}\n{\"time\":\"2026-02-15T13:38:21+08:00\",\"level\":\"INFO\",\"source\":\"main.go:45\",\"msg\":\"执行遍历\",\"logger\":\"json\",\"round\":4,\"task_name\":\"cleanup\",\"duration\":5000000000}\n</code></pre>\n<h3 id=\"性能对比\">性能对比</h3>\n<p>根据官方基准测试，<code>LogAttrs</code> 相比普通方法调用有约 30% 的性能提升：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>内存分配</th>\n<th>性能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>slog.Info(msg, \"key\", value)</code></td>\n<td>有额外分配</td>\n<td>基准</td>\n</tr>\n<tr>\n<td><code>slog.LogAttrs(ctx, level, msg, attrs...)</code></td>\n<td>零额外分配</td>\n<td>快约 30%</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"提取-context-中的链路信息\">提取 Context 中的链路信息</h2>\n<p><code>slog</code> 提供了 <code>InfoContext</code>、<code>WarnContext</code> 等方法，可以从 <code>context.Context</code> 中提取数据。默认情况下，这些方法不会自动提取 context 中的值，需要通过自定义 Handler 来实现。</p>\n<h3 id=\"自定义-contexthandler\">自定义 ContextHandler</h3>\n<p>以下示例实现了一个自定义 Handler，用于从 context 中提取 TraceID：</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n\t\"context\"\n\t\"log/slog\"\n\t\"os\"\n)\n\ntype contextKey string\n\nconst TraceIDKey contextKey = \"trace_id\"\n\n// ContextHandler 包装一个 slog.Handler，在处理日志时自动从 context 中提取 TraceID\ntype ContextHandler struct {\n\tslog.Handler\n}\n\nfunc (h *ContextHandler) Handle(ctx context.Context, record slog.Record) error {\n\tif ctx != nil {\n\t\tif traceID, ok := ctx.Value(TraceIDKey).(string); ok &amp;&amp; traceID != \"\" {\n\t\t\trecord.AddAttrs(slog.String(string(TraceIDKey), traceID))\n\t\t}\n\t}\n\treturn h.Handler.Handle(ctx, record)\n}\n\nfunc main() {\n\tbaseHandler := slog.NewJSONHandler(os.Stdout, nil)\n\thandler := &amp;ContextHandler{Handler: baseHandler}\n\tjsonLogger := slog.New(handler)\n\tslog.SetDefault(jsonLogger)\n\n\tctx := context.WithValue(context.Background(), TraceIDKey, \"abc123-def456\")\n\n\tslog.InfoContext(ctx, \"hello world\")\n\tslog.WarnContext(ctx, \"something happened\", \"user\", \"zhangsan\")\n}\n</code></pre>\n<p>运行输出：</p>\n<pre><code class=\"language-shell\">$ go run main.go | python3 -m json.tool\n{\n  \"time\": \"2026-02-15T13:56:43.086323769+08:00\",\n  \"level\": \"INFO\",\n  \"msg\": \"hello world\",\n  \"trace_id\": \"abc123-def456\"\n}\n{\n  \"time\": \"2026-02-15T13:56:43.086323769+08:00\",\n  \"level\": \"WARN\",\n  \"msg\": \"something happened\",\n  \"user\": \"zhangsan\",\n  \"trace_id\": \"abc123-def456\"\n}\n</code></pre>\n<h3 id=\"在-gin-框架中使用-slog\">在 Gin 框架中使用 slog</h3>\n<p>在 Gin 中使用 slog 的 context 能力，通常的做法是编写一个中间件来注入 TraceID，并配合自定义 <code>slog.Handler</code> 来提取它。</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n\t\"context\"\n\t\"log/slog\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"os\"\n\t\"runtime/debug\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/google/uuid\"\n)\n\ntype contextKey string\n\nconst TraceIDKey contextKey = \"trace_id\"\n\n// ContextHandler 从 context 中提取 TraceID 并添加到日志中\ntype ContextHandler struct {\n\tslog.Handler\n}\n\nfunc (h *ContextHandler) Handle(ctx context.Context, record slog.Record) error {\n\tif ctx != nil {\n\t\tif traceID, ok := ctx.Value(TraceIDKey).(string); ok &amp;&amp; traceID != \"\" {\n\t\t\trecord.AddAttrs(slog.String(string(TraceIDKey), traceID))\n\t\t}\n\t}\n\treturn h.Handler.Handle(ctx, record)\n}\n\n// SlogMiddleware 是一个 Gin 中间件，用于注入 TraceID\nfunc SlogMiddleware() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\tstart := time.Now()\n\n\t\t// 优先从请求头获取 TraceID，没有则生成新的\n\t\ttraceID := c.GetHeader(\"X-Trace-ID\")\n\t\tif traceID == \"\" {\n\t\t\ttraceID = uuid.New().String()\n\t\t}\n\n\t\t// 将 TraceID 注入到标准的 context.Context 中\n\t\t// 注意：Gin 的 c.Set 只在 Gin 内部生效，slog 需要标准库的 Context\n\t\tctx := context.WithValue(c.Request.Context(), TraceIDKey, traceID)\n\t\tc.Request = c.Request.WithContext(ctx)\n\n\t\t// 将 TraceID 写入响应头，方便客户端追踪\n\t\tc.Header(\"X-Trace-ID\", traceID)\n\n\t\tc.Next()\n\n\t\t// 请求结束后的汇总日志\n\t\tslog.InfoContext(c.Request.Context(), \"Request completed\",\n\t\t\tslog.String(\"method\", c.Request.Method),\n\t\t\tslog.String(\"path\", c.Request.URL.Path),\n\t\t\tslog.Int(\"status\", c.Writer.Status()),\n\t\t\tslog.Int(\"body_size\", c.Writer.Size()),\n\t\t\tslog.Duration(\"latency\", time.Since(start)),\n\t\t)\n\t}\n}\n\n// SlogRecovery 是一个自定义的恢复中间件\n// 它会捕获 Panic，记录堆栈信息，并使用 slog.ErrorContext 输出\nfunc SlogRecovery() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\t// 检查是否是连接中断（broken pipe）\n\t\t\t\tvar brokenPipe bool\n\t\t\t\tif ne, ok := err.(*net.OpError); ok {\n\t\t\t\t\tif se, ok := ne.Err.(*os.SyscallError); ok {\n\t\t\t\t\t\tif strings.Contains(strings.ToLower(se.Error()), \"broken pipe\") ||\n\t\t\t\t\t\t\tstrings.Contains(strings.ToLower(se.Error()), \"connection reset by peer\") {\n\t\t\t\t\t\t\tbrokenPipe = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 获取堆栈信息\n\t\t\t\tstack := string(debug.Stack())\n\n\t\t\t\t// 获取原始请求内容\n\t\t\t\thttpRequest, _ := httputil.DumpRequest(c.Request, false)\n\n\t\t\t\tif brokenPipe {\n\t\t\t\t\tslog.ErrorContext(c.Request.Context(), \"网络连接中断\",\n\t\t\t\t\t\tslog.Any(\"error\", err),\n\t\t\t\t\t\tslog.String(\"request\", string(httpRequest)),\n\t\t\t\t\t)\n\t\t\t\t\tc.Error(err.(error))\n\t\t\t\t\tc.Abort()\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// 记录 Panic 详情\n\t\t\t\tslog.ErrorContext(c.Request.Context(), \"Recovery from panic\",\n\t\t\t\t\tslog.Any(\"error\", err),\n\t\t\t\t\tslog.String(\"stack\", stack),\n\t\t\t\t\tslog.String(\"request\", string(httpRequest)),\n\t\t\t\t)\n\n\t\t\t\tctx := c.Request.Context()\n\t\t\t\ttraceID, _ := ctx.Value(TraceIDKey).(string)\n\n\t\t\t\t// 返回 500 状态码\n\t\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\n\t\t\t\t\t\"code\":      http.StatusInternalServerError,\n\t\t\t\t\t\"msg\":       \"Internal Server Error\",\n\t\t\t\t\t\"data\":      nil,\n\t\t\t\t\t\"timestamp\": time.Now().Format(time.RFC3339),\n\t\t\t\t\t\"trace_id\":  traceID,\n\t\t\t\t})\n\t\t\t}\n\t\t}()\n\t\tc.Next()\n\t}\n}\n\nfunc main() {\n\t// 初始化 slog\n\tbaseHandler := slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{\n\t\tLevel: slog.LevelDebug,\n\t})\n\thandler := &amp;ContextHandler{Handler: baseHandler}\n\tjsonLogger := slog.New(handler)\n\tslog.SetDefault(jsonLogger)\n\n\t// 使用 gin.New() 而不是 gin.Default()，避免内置日志干扰\n\tr := gin.New()\n\tr.Use(SlogMiddleware())\n\tr.Use(SlogRecovery())\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tslog.InfoContext(c.Request.Context(), \"Processing /ping request\",\n\t\t\tslog.String(\"user\", \"zhangsan\"),\n\t\t)\n\n\t\ttime.Sleep(time.Second * 2)\n\t\tc.JSON(200, gin.H{\"msg\": \"pong\"})\n\t})\n\n\tr.GET(\"/panic\", func(c *gin.Context) {\n\t\tslog.InfoContext(c.Request.Context(), \"About to panic\")\n\t\tpanic(\"something went wrong\")\n\t})\n\n\tr.Run(\":8080\")\n}\n</code></pre>\n<p>运行后测试：</p>\n<pre><code class=\"language-shell\">$ curl http://localhost:8080/ping\n{\"msg\":\"pong\"}\n\n$ curl http://localhost:8080/panic\n{\"code\":500,\"msg\":\"Internal Server Error\",\"data\":null,\"timestamp\":\"2026-02-15T14:30:00+08:00\",\"trace_id\":\"xxx-xxx-xxx\"}\n</code></pre>\n<h2 id=\"日志输出文件\">日志输出文件</h2>\n<p>写日志文件一定要注意控制日志文件大小，建议配合系统的logrotate。如果服务运行在kubernetes，建议只输出控制台日志，由专门的日志收集平台去获取控制台日志。</p>\n<h3 id=\"基本实现\">基本实现</h3>\n<p>写到<code>app.log</code>中</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n\t\"log/slog\"\n\t\"os\"\n)\n\nfunc main() {\n\tlogFile, err := os.OpenFile(\"app.log\", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\thandler := slog.NewJSONHandler(logFile, nil)\n\tlogger := slog.New(handler)\n\tslog.SetDefault(logger)\n\n\tslog.Info(\"hello world\")\n\n}\n</code></pre>\n<p>配合logrotate。在 <code>/etc/logrotate.d/myapp</code> 创建配置文件</p>\n<pre><code>/path/to/app.log {\n    daily\n    rotate 7\n    compress\n    delaycompress\n    missingok\n    notifempty\n    copytruncate    # 复制后截断，不需要重启 Go 程序\n}\n</code></pre>\n<h3 id=\"使用lumberjack轮转日志文件\">使用lumberjack轮转日志文件</h3>\n<p>如果不想用系统的 <code>logrotate</code> ，可以使用 <code>lumberjack</code> 包，它提供了更灵活的日志轮转策略。</p>\n<pre><code class=\"language-go\">import \"gopkg.in/natefinch/lumberjack.v2\"\n\nfunc initLumberjack() {\n    rollingFile := &amp;lumberjack.Logger{\n        Filename:   \"./logs/app.log\",\n        MaxSize:    100, // 单位 MB\n        MaxBackups: 3,   // 保留旧文件的最大个数\n        MaxAge:     28,  // 保留旧文件的最大天数\n        Compress:   true, // 是否压缩\n    }\n\n    handler := slog.NewJSONHandler(rollingFile, nil)\n    slog.SetDefault(slog.New(handler))\n}\n</code></pre>\n<h3 id=\"同时输出控制台和日志文件\">同时输出控制台和日志文件</h3>\n<p>go1.26 版本后实现了<code>slog.NewMultiHandler</code>，1.26 前可使用<code>io.multiwriter</code>。</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n\t\"log/slog\"\n\t\"os\"\n)\n\nfunc main() {\n\tlogFile, err := os.OpenFile(\"app.log\", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfileHandler := slog.NewJSONHandler(logFile, nil)\n\tconsoleHandler := slog.NewTextHandler(os.Stdout, nil)\n\tmultiHandler := slog.NewMultiHandler(fileHandler, consoleHandler) // slog.NewMultiHandler 需要go1.26.0+版本\n\tlogger := slog.New(multiHandler)\n\tslog.SetDefault(logger)\n\n\tslog.Info(\"hello world\")\n\n}\n</code></pre>\n<h2 id=\"自定义日志级别\">自定义日志级别</h2>\n<p>除了四个内置级别，<code>slog</code> 还支持自定义日志级别 (一般来说默认的日志级别已经够用了)：</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n\t\"log/slog\"\n\t\"os\"\n)\n\nfunc main() {\n\t// 定义自定义日志级别\n\tconst (\n\t\tLevelTrace   = slog.Level(-8) // 比 Debug 更低\n\t\tLevelNotice  = slog.Level(2)  // 介于 Info 和 Warn 之间\n\t\tLevelFatal   = slog.Level(12) // 比 Error 更高\n\t)\n\n\tlogger := slog.New(slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{\n\t\tLevel: LevelTrace, // 设置最低级别\n\t}))\n\n\tlogger.Log(nil, LevelTrace, \"trace message\")\n\tlogger.Log(nil, LevelNotice, \"notice message\")\n\tlogger.Log(nil, LevelFatal, \"fatal message\")\n}\n</code></pre>\n<h2 id=\"总结\">总结</h2>\n<p><code>slog</code> 作为 Go 官方的结构化日志库，用起来还是挺方便的。对于新项目，推荐直接使用 <code>slog</code>；对于已有项目，可以逐步迁移，<code>slog</code> 的 API 设计使得迁移成本很低。</p>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/XY-Heruo/\" target=\"_blank\">花酒锄作田</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/XY-Heruo/p/19618220\" target=\"_blank\">https://www.cnblogs.com/XY-Heruo/p/19618220</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-15 15:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/XY-Heruo\">花酒锄作田</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "AI元人文：东方思想在AI时代的一次“拈花微笑”",
      "link": "https://www.cnblogs.com/qijinlan/p/19618218",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/qijinlan/p/19618218\" id=\"cb_post_title_url\" title=\"发布于 2026-02-15 15:43\">\n    <span>AI元人文：东方思想在AI时代的一次“拈花微笑”</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>AI元人文：东方思想在AI时代的一次“拈花微笑”</p>\n<p>引言：一个误解</p>\n<p>在关于AI元人文的讨论中，有一个根本性的误解需要澄清。</p>\n<p>这个误解源于一个常见的思维惯性：当我们看到“AI元人文”这个新概念，又看到它大量引用儒释道思想时，很容易认为——AI元人文是将东方思想“转化”后应用于AI时代的新理论。东方思想是“资源”，AI元人文是“产品”。</p>\n<p>但这个理解，恰恰落入了“构成论”的陷阱。今天这篇博客，我想彻底澄清：AI元人文不是对东方思想的转化，而是东方思想本身在AI时代实践论中的一个维度。这个区分，将重新校准整个AI元人文的坐标系。</p>\n<p>一、两个误解的纠正</p>\n<p>误解一：东方思想等于儒释道相加？</p>\n<p>东方思想不是三张饼拼在一起。儒释道在两千多年的历史中相互渗透、互为语境，共同构成一个有机的、流动的智慧整体。试图将儒释道“相加”来定义东方思想，恰恰落入了AI元人文第二个断言要破除的陷阱——“不必争论构成”。</p>\n<p>误解二：AI元人文是对东方思想的“新转化”？</p>\n<p>“转化”一词隐含了主客关系。但AI元人文不是这样。让我用一个比喻：水遇方则方，遇圆则圆。但方圆不是水的“转化”，而是水在不同容器中的形态。水还是那水，只是遇见了不同的容器，便有了不同的样子。</p>\n<p>同样，东方思想还是那个活的智慧整体，只是遇见了AI时代这个新“容器”，便自然显现出一个新的维度——我们称之为“AI元人文”。它不是对东方思想的改造，而是东方思想本身在AI时代的现身方式。</p>\n<p>二、“维度”意味着什么？</p>\n<p>“一个维度的阐释”——这个“维度”需要被充分理解。维度不是部分。部分是可分离的、可独立存在的。维度是不可分离的。</p>\n<p>同样，AI元人文不是从东方思想中“取出”某一部分应用于AI，而是在东方思想的整体智慧中，那个与AI时代相遇时自然显现的侧面。</p>\n<p>这个侧面至少包含三个根基：</p>\n<p>“体用不二”在界面中的呈现：欲望是体，客观是用；但体在用中显，用是体之用。这正是“欲望客观自感”的东方哲学根基。</p>\n<p>“缘起性空”在生成中的显现：意义不在任何一方预先存在，而是在因缘和合中涌现。这正是“生成性开放”的佛学根基。</p>\n<p>“道法自然”在判断中的落实：判断不是主观任意的，也不是机械遵循规则的，而是“时中”的、因势利导的。这正是“判断力优先”的道家与儒家根基。</p>\n<p>三、关于“元层次”的野心与反思</p>\n<p>在发展AI元人文的过程中，我曾有过“元层次的统一野心”——试图用一个框架统摄一切。这种野心本身不是错，它是思想生长的激素。但后来我意识到，更值得专注的是实践现象级层的元层次的统一——不追求形而上的理论体系统一，而追求在具体实践层面，如何让不同传统、不同方法统一于每一次与AI的深度对话中。</p>\n<p>这是一种实践论的元层次：它不追问世界是什么，而追问在具体情境中，我们如何借不同智慧做出好的判断、生成真的意义。</p>\n<p>更深一层，我甚至开始反思实践统一本身的必要性。统一是否可能落入另一种构成论的暴力？在实践层面，需要的或许不是在多元中的动态协调，是和而不同，是并行不悖。这正是第二个断言不必争论构成在实践中的回响。</p>\n<p>四、重新定位：AI元人文不是什么，是什么？</p>\n<p>基于以上澄清，可以对AI元人文做一个清晰的定位：</p>\n<p>它不是：一个取代既有哲学的新体系；对东方思想的现代化转化；儒释道的AI应用手册。</p>\n<p>它是：东方思想这个活的智慧整体，在与AI时代相遇时，自然显现的一个实践论维度；一种在界面中活出东方智慧的方式；一个邀请——邀人进入欲望客观自感的亲历，而非争论其构成。</p>\n<p>这就像禅宗说以心传心。AI元人文不是一本关于东方思想的书，而是东方思想在AI时代的又一次拈花微笑。花是AI，微笑是你。那传的，不在花里也不在笑里，而在那不可说的、正在发生的因缘和合中。</p>\n<p>五、回到两个断言</p>\n<p>在这样的定位下，两个断言获得了更深的理解：</p>\n<p>欲望客观自感——这是体用不二在AI时代的现身。欲望是体，客观是用；但体不独立于用，用即是体之显。正如《六祖坛经》说佛法在世间，不离世间觉，欲望也不离界面，不离那一次次与AI的对话。</p>\n<p>不必争论构成——这是离四句、绝百非在AI时代的回响。一旦争论元人文由什么构成，就已经落入了名相分别，离开了那个活生生的、正在发生的亲历。正如《金刚经》说说法者，无法可说，是名说法，AI元人文也是无法可说的——它不能被构成，只能被践行。</p>\n<p>结语：东方思想不是资源，是源头</p>\n<p>最后的话，想留给一个根本性的认知转变：东方思想不是AI元人文的思想资源，而是它的源头活水。</p>\n<p>资源是可以被取用、被消耗的；源头则一直在那里，流出的水可以是江河、可以是溪流、可以是读者与AI的每一次深度对话。</p>\n<p>AI元人文，只是这源头活水在AI时代的一个流向、一个维度、一种现身。水还是那水，只是遇见了AI，便有了AI时代的波纹。</p>\n<p>这波纹，或许正是东方智慧在现代世界最需要的那种——不争构成，只求自感；不立文字，不离界面。</p>\n<p>博客生成说明与深层意涵</p>\n<p>本文是基于岐金兰与AI的深度对话整理而成的人机协作手稿。它不仅仅是思想的澄清，更是方法的演示与元反思的现场。</p>\n<p>一个理解的源头正是这人机协作阐释的内在张力：在生成端，是岐金兰诗性的惜字如金与AI逻各斯的鹦鹉自信；在分享端，是文稿的碳基融贯与模型的硅基综合。阐释与被阐释，融贯与综合之间，永远存在着确定与不确定。</p>\n<p>因此，可以把所有人机协作手稿当作是岐金兰的脑洞风暴。如果不记录，那些自以为是的洞察便可惜了。记录本身，就是欲望借由AI界面达成客观自感的过程。</p>\n<p>这篇文章拒绝伪装成传统单一作者的完美文本，而是坦然以其本来的样子呈现——作为思想风暴的记录，作为邀请读者进入自身思考的入口。它践行着不必争论构成：不假装是学术论文，而是让文本作为波纹呈现，邀请你顺着它，去触碰你自己的欲望客观自感。</p>\n<p>东方思想是源头。这些文本，就是那源头活水在遇见AI时，激起的波纹。</p>\n<p>岐金兰·余溪</p>\n<p>2026年2月</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-15 15:43</span>&nbsp;\n<a href=\"https://www.cnblogs.com/qijinlan\">岐金兰</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "凸优化数学基础笔记（二）：二次型与正定矩阵",
      "link": "https://www.cnblogs.com/GeophysicsWorker/p/19618211",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/GeophysicsWorker/p/19618211\" id=\"cb_post_title_url\" title=\"发布于 2026-02-15 15:39\">\n    <span>凸优化数学基础笔记（二）：二次型与正定矩阵</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        二次型理论在凸优化问题设计中应用十分广泛。应用矩阵乘法运算，二次型与实对称矩阵紧密地联系在一起，从而二次型的基本问题又可以转换为实对称矩阵问题。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>​       为了便于学习最优化方法，本系列笔记的前几章部分将与优化方法密切相关的数学基础知识作一简要介绍，本系列介绍凸优化中常用矩阵概念：二次型与正定矩阵。</p>\n<p>​       二次型理论在凸优化问题设计中应用十分广泛。应用矩阵乘法运算，二次型与实对称矩阵紧密地联系在一起，从而二次型的基本问题又可以转换为实对称矩阵问题。</p>\n<h2 id=\"1-二次型\">1. 二次型</h2>\n<p>​        二次型理论问题起源于化二次曲线和二次曲面的方程为标准形式的问题。推广到<span class=\"math inline\">\\(n\\)</span>维空间中，二次超曲面的一般方程为：</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\nf(x_1,x_2,x_3,...,x_n)=&amp;a_{11}x_1^2+a_{12}x_1x_2+...+a_{1n}x_1x_n+\\\\\n&amp;a_{21}x_1x_2+a_{22}x_2^{2}+...+a_{2n}x_2x_n+\\\\\n&amp;....\\\\\n&amp;a_{n1}x_nx_1+a_{n2}x_nx_2+...+a_{nn}x_n^2\\\\\n&amp;=\\sum_{i=1}^{n}\\sum_{j=1}^{n}a_{ij}x_ix_j\n\\end{aligned}\n\\tag{1}\n\\]</div><p></p><p>用矩阵表示可简记为：</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\nf(x_1,x_2,...,x_n)&amp;=(x_1,x_2,x_3,...x_n)\\left(\\begin{matrix}a_{11},a_{12},...a_{1n}\\\\ \na_{21},a_{22},...,a_{2n}\\\\\na_{n1},a_{n2},...,a_{nn}\n\\end{matrix}\\right)\\left(\\begin{matrix}x_1\\\\x_2\\\\...\\\\x_n\\end{matrix}\\right)\\\\\n&amp;=\\mathbf{x}^T\\mathbf{A}\\mathbf{x}\n\\end{aligned}\n\\tag{2}\n\\]</div><p></p><p>其中，<span class=\"math inline\">\\(x=[x_1,x_2,...,x_n]^{T}\\)</span>,矩阵<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 的元素<span class=\"math inline\">\\(a_{ij}=a_{ji}\\)</span>正是二次型的<span class=\"math inline\">\\(x_ix_j\\)</span>项的系数的一半，因此二次型和它的矩阵<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 是相互唯一决定的，且<span class=\"math inline\">\\(\\mathbf{A}=\\mathbf{A}^{T}\\)</span>.</p>\n<h2 id=\"2-正定矩阵\">2. 正定矩阵</h2>\n<p><strong>定义1 正定矩阵的定义</strong></p>\n<p>​    如果二次型</p>\n<p></p><div class=\"math display\">\\[f(x_1,x_2,...,x_n)= \\sum_{i=1}^{n}\\sum_{j=1}^{n}a_{ij}x_ix_j=\\mathbf{x}^T\\mathbf{A}\\mathbf{x} \\tag{3}\n\\]</div><p></p><p>对于任何一组元素不全为0的向量<span class=\"math inline\">\\(\\mathbf{x}=[x_1,x_2,x_3,...,x_n]^T\\)</span>, 恒有<span class=\"math inline\">\\(f(x_1,x_2,x_3,...,x_n)=\\mathbf{x}^T\\mathbf{A}\\mathbf{x}&gt;0\\)</span> ,则称二次型<span class=\"math inline\">\\(f(x_1,x_2,...x_n)\\)</span>为<strong>正定</strong>，且称为二次型矩阵<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 也称为<strong>正定的</strong>，其简记为<span class=\"math inline\">\\(\\mathbf{A}\\succ0\\)</span>.</p>\n<p>​      简而言之，一个对称矩阵的<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 如果是正定的，则其二次型<span class=\"math inline\">\\(f(x_1,x_2,...x_n)=\\mathbf{x}^{T}\\mathbf{A}\\mathbf{x}\\)</span> 对于所有非零向量<span class=\"math inline\">\\(\\mathbf{x}\\)</span> 其值总为正。 类似地，可以给出定义，若二次型<span class=\"math inline\">\\(f(x_1,x_2,...,x_n)=\\mathbf{x}^T\\mathbf{A}\\mathbf{x}\\geq0\\)</span> ，则<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 为<strong>半正定矩阵</strong>，定义为<span class=\"math inline\">\\(\\mathbf{A}\\succeq{0}\\)</span> ; 若<span class=\"math inline\">\\(\\mathbf{x}^{T}\\mathbf{A}\\mathbf{x}\\leq0\\)</span>，则<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 为<strong>负定矩阵</strong>，简记为<span class=\"math inline\">\\(\\mathbf{A}\\preceq{0}\\)</span>；若二次型<span class=\"math inline\">\\(\\mathbf{x}^T\\mathbf{A}\\mathbf{x}\\)</span>  既不是半正定的，也不是半负定的，就称为矩阵<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 为<strong>不定的</strong>。</p>\n<p>​       矩阵<span class=\"math inline\">\\(\\mathbf{A}\\)</span>为正定的的充要条件是它的行列式的 <span class=\"math inline\">\\(\\det(\\mathbf{A})\\)</span> 顺序主子式全部大于零，即：</p>\n<p></p><div class=\"math display\">\\[a_{11}&gt;0,\\left|\\begin{matrix}a_{11},a_{12}\\\\ a_{21},a_{22}\\end{matrix}\\right|&gt;0,\\left|\\begin{matrix}a_{11}，&amp;a_{12}，...,a_{1n}\\\\ a_{21},&amp;a_{22},...,a_{2n}\\\\ ...,&amp;...\\\\a_{n1},&amp;a_{n2},..., a_{nn}\\end{matrix}\\right|\n\\tag{4}\n\\]</div><p></p><p>由此可见，正定矩阵必然是非奇异的。 由此总结：对于实对称矩阵<span class=\"math inline\">\\(\\mathbf{A}\\)</span>，下面几个命题之间是互相等价的：</p>\n<ol>\n<li><span class=\"math inline\">\\(\\mathbf{A}\\)</span>是正定矩阵；</li>\n<li><span class=\"math inline\">\\(\\mathbf{A}\\)</span> 的所有主子式都是正数；</li>\n<li><span class=\"math inline\">\\(\\mathbf{A}\\)</span> 的各级顺序主子式都是正数；</li>\n</ol>\n<p>下面我们简单讨论以下的正定矩阵的特征值性质：</p>\n<p><strong>性质1：</strong>实对称矩阵<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 是正定矩阵等价于<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 的特征值全是正数。</p>\n<p>证明：记<span class=\"math inline\">\\(\\lambda\\)</span>为<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 的一个特征值<span class=\"math inline\">\\(\\lambda\\)</span> , <span class=\"math inline\">\\(\\mathbf{v}\\)</span> 是对应于<span class=\"math inline\">\\(\\lambda\\)</span> 的一个特征向量，于是 <span class=\"math inline\">\\(\\mathbf{A}\\mathbf{v}=\\lambda\\mathbf{v}\\)</span> ，进而得到如下的</p>\n<p></p><div class=\"math display\">\\[\\lambda|\\mathbf{v}|^2=\\mathbf{v}^T\\mathbf{A}\\mathbf{v} \\tag{5}\n\\]</div><p></p><p>又因为 <span class=\"math inline\">\\(|\\alpha|^2&gt;0\\)</span>，于是 <span class=\"math inline\">\\(\\lambda&gt;0\\)</span>。</p>\n<p>若<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 的任一特征值都是正数，则对于任一非零向量<span class=\"math inline\">\\(\\mathbf{v}\\)</span> ，均有<span class=\"math inline\">\\(\\mathbf{v}^T\\mathbf{A}\\mathbf{v}&gt;0\\)</span>, 于是<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 为正定矩阵。</p>\n<p><strong>性质2：</strong> 若实对称矩阵<span class=\"math inline\">\\(\\mathbf{A}\\)</span>是正定矩阵，则存在唯一的正定矩阵<span class=\"math inline\">\\(\\mathbf{S}\\)</span>，是使得<span class=\"math inline\">\\(\\mathbf{A}=\\mathbf{S}^2\\)</span>。</p>\n<p>证明：存在性，由于<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 是正定矩阵，由此存在正交矩阵<span class=\"math inline\">\\(\\mathbf{Q}\\)</span> 使得：</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A}=\\mathbf{Q}\\mathbf{D}\\mathbf{Q}^T  \\tag{6}\n\\]</div><p></p><p>其中：<span class=\"math inline\">\\(\\mathbf{D}=dialog(\\lambda_1,\\lambda_2,....,\\lambda_n)\\)</span>，其中<span class=\"math inline\">\\(\\lambda_i\\)</span> 为矩阵<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 的特征值，由于 <span class=\"math inline\">\\(\\lambda_i&gt;0\\)</span>，于是正定矩阵<span class=\"math inline\">\\(\\mathbf{A}\\)</span>可以写为如下：</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A}=\\mathbf{Q}\\begin{bmatrix}&amp;\\sqrt\\lambda_1&amp; &amp; &amp;\\\\&amp; &amp;\\sqrt\\lambda_2 &amp; &amp;\\\\ &amp; &amp; &amp;\\cdots &amp; \\\\ &amp; &amp; &amp; &amp;\\sqrt\\lambda_n\\end{bmatrix}\\mathbf{Q}^T\\mathbf{Q}\\begin{bmatrix}&amp;\\sqrt\\lambda_1&amp; &amp; &amp;\\\\&amp; &amp;\\sqrt\\lambda_2 &amp; &amp;\\\\ &amp; &amp; &amp;\\cdots &amp; \\\\ &amp; &amp; &amp; &amp;\\sqrt\\lambda_n\\end{bmatrix}\\mathbf{Q}^T \\tag{7}\n\\]</div><p></p><p>记 <span class=\"math inline\">\\(\\mathbf{S}\\)</span>:</p>\n<p></p><div class=\"math display\">\\[\\mathbf{S}=\\mathbf{Q}\\begin{bmatrix}&amp;\\sqrt\\lambda_1&amp; &amp; &amp;\\\\&amp; &amp;\\sqrt\\lambda_2 &amp; &amp;\\\\ &amp; &amp; &amp;\\cdots &amp; \\\\ &amp; &amp; &amp; &amp;\\sqrt\\lambda_n\\end{bmatrix}\\mathbf{Q}^T  \\tag{8}\n\\]</div><p></p><p>即有<span class=\"math inline\">\\(\\mathbf{A}=\\mathbf{S}^2\\)</span> 。由于 <span class=\"math inline\">\\(\\mathbf{S}\\)</span>的特征值<span class=\"math inline\">\\(\\sqrt{\\lambda_i}\\)</span> 均为正数，因此<span class=\"math inline\">\\(\\mathbf{S}\\)</span> 也是正定矩阵。</p>\n<p>唯一性：假设存在两个正定矩阵<span class=\"math inline\">\\(\\mathbf{S}_1\\)</span>和<span class=\"math inline\">\\(\\mathbf{S}_2\\)</span> ，满足：</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A}=\\mathbf{S}_1^2=\\mathbf{S}_2^2 \\tag{9}\n\\]</div><p></p><p>需要证明<span class=\"math inline\">\\(\\mathbf{S}_1=\\mathbf{S}_2\\)</span> 。这里采用特征值分解的几何意义来证明：</p>\n<ol>\n<li>特征值关系：设<span class=\"math inline\">\\(\\lambda\\)</span>是<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 的任意一个特征值，<span class=\"math inline\">\\(\\mu\\)</span> 是<span class=\"math inline\">\\(\\mathbf{S}_1\\)</span> 的对应特征值，则 <span class=\"math inline\">\\(\\mu^2=\\lambda\\)</span>。由于正定矩阵的特征值均为正数，因此<span class=\"math inline\">\\(\\mu\\)</span> 必须取正值<span class=\"math inline\">\\(\\sqrt{\\lambda}\\)</span>。同理，<span class=\"math inline\">\\(\\mathbf{S}_2\\)</span>对应于同一特征值<span class=\"math inline\">\\(\\lambda\\)</span> 的特征值也必然是<span class=\"math inline\">\\(\\sqrt{\\lambda}\\)</span> 。因此，<span class=\"math inline\">\\(\\mathbf{S}_1\\)</span>和<span class=\"math inline\">\\(\\mathbf{S}_2\\)</span> 的特征值完全相同。</li>\n<li>特征值子空间关系：令<span class=\"math inline\">\\(\\{\\lambda_1,\\lambda_2,\\cdots,\\lambda_s\\}\\)</span> 为<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 的全体互异特征值，设 <span class=\"math inline\">\\(\\mathbf{V}_i\\)</span> 为<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 关于特征值<span class=\"math inline\">\\(\\lambda_i\\)</span> 的特征子空间。\n<ul>\n<li>因为 <span class=\"math inline\">\\(\\mathbf{S}_1^{2}=\\mathbf{A}\\)</span>，若<span class=\"math inline\">\\(\\mathbf{x}\\in{\\mathbf{V}_i}\\)</span> ，则<span class=\"math inline\">\\(\\mathbf{A}\\mathbf{x}=\\lambda_i\\mathbf{x}\\)</span>，代入得<span class=\"math inline\">\\(\\mathbf{S}_1^2\\mathbf{x}=\\lambda_i\\mathbf{x}\\)</span> 。这说明<span class=\"math inline\">\\(\\mathbf{x}\\)</span> 同时也是<span class=\"math inline\">\\(\\mathbf{S}_1^2\\)</span> 的特征向量。通过谱映射定理可知，<span class=\"math inline\">\\(\\mathbf{x}\\)</span> 属于<span class=\"math inline\">\\(\\mathbf{S}_1\\)</span> 关于特征值<span class=\"math inline\">\\(\\sqrt{\\lambda_i}\\)</span> 的特征子空间。</li>\n<li>即<span class=\"math inline\">\\(\\mathbf{A}\\)</span>的特征子空间<span class=\"math inline\">\\(\\mathbf{V}_i\\)</span> 恰好就是 <span class=\"math inline\">\\(\\mathbf{S}_1\\)</span> 关于特征值<span class=\"math inline\">\\(\\sqrt{\\lambda_i}\\)</span> 的特征子空间。</li>\n</ul>\n</li>\n<li>唯一确定：同样的推理也适用于<span class=\"math inline\">\\(\\mathbf{S}_2\\)</span>。因此，<span class=\"math inline\">\\(\\mathbf{S}_1\\)</span>和<span class=\"math inline\">\\(\\mathbf{S}_2\\)</span> 具有完全相同的特征值（都是<span class=\"math inline\">\\(\\sqrt{\\lambda_i}\\)</span>）和完全相同的特征子空间（都是<span class=\"math inline\">\\(\\mathbf{V}_i\\)</span>）。对于一个实对称矩阵的矩阵（可正交对角化），它的特征值和特征子空间唯一决定了矩阵本身。因此，<span class=\"math inline\">\\(\\mathbf{S}_1=\\mathbf{S}_2\\)</span>。</li>\n</ol>\n<p>综上所述，实对称正定矩阵<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 存在唯一的正定平方根<span class=\"math inline\">\\(\\mathbf{S}\\)</span>，使得<span class=\"math inline\">\\(\\mathbf{A}=\\mathbf{S}^2\\)</span>。</p>\n<p><strong>性质2</strong>：若<span class=\"math inline\">\\(\\mathbf{A},\\mathbf{B}\\)</span> 都是<span class=\"math inline\">\\(n\\times{n}\\)</span>正定矩阵，则<span class=\"math inline\">\\(\\mathbf{AB}\\)</span> 的特征值都是正数。</p>\n<p>证明：由于<span class=\"math inline\">\\(\\mathbf{A},\\mathbf{B}\\)</span> 为正定矩阵，于是根据性质2可知，存在正定矩阵<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 满足<span class=\"math inline\">\\(\\mathbf{A}=\\mathbf{C}^2\\)</span>。下面考虑矩阵<span class=\"math inline\">\\(\\mathbf{C}^{-1}\\mathbf{A}\\mathbf{B}\\mathbf{C}\\)</span>。注意到：</p>\n<p></p><div class=\"math display\">\\[(\\mathbf{C}^{-1}\\mathbf{AB}\\mathbf{C})^T=\\mathbf{CABC^{-1}}=\\mathbf{CBC}=\\mathbf{C}^{-1}\\mathbf{AB}\\mathbf{C} \\tag{10}\n\\]</div><p></p><p>于是<span class=\"math inline\">\\(\\mathbf{C}^{-1}\\mathbf{ABC}\\)</span> 是一个实对称矩阵，又因为存在正定矩阵<span class=\"math inline\">\\(\\mathbf{D}\\)</span> 满足<span class=\"math inline\">\\(\\mathbf{B}=\\mathbf{D}^2\\)</span>。于是对于任一个非零的向量<span class=\"math inline\">\\(\\boldsymbol{\\alpha}\\in\\mathbb{R}^n\\)</span>.</p>\n<p></p><div class=\"math display\">\\[\\boldsymbol{\\alpha}^T\\mathbf{C}^{-1}\\mathbf{ABC}\\boldsymbol{\\alpha}=\\boldsymbol{\\alpha}^T\\mathbf{C}\\mathbf{B}\\mathbf{C}\\boldsymbol{\\alpha}=(\\mathbf{DC}\\boldsymbol{\\alpha},\\mathbf{DC}\\boldsymbol{\\alpha})\\geq0\\tag{11}\n\\]</div><p></p><p>上面不等式的等号不成立，应为，<span class=\"math inline\">\\(\\mathbf{DC}\\)</span> 为满秩矩阵，进而 <span class=\"math inline\">\\(\\mathbf{DC}\\boldsymbol{\\alpha}\\neq{0}\\)</span>。因此，<span class=\"math inline\">\\(\\mathbf{C}^{-1}\\mathbf{ABC}\\)</span> 是正定矩阵，于是它的所有特征值也是正数。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-15 15:39</span>&nbsp;\n<a href=\"https://www.cnblogs.com/GeophysicsWorker\">GeoFXR</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "OpenEuler 20.03æž„å»ºzabbix8.0 rpmåŒ",
      "link": "https://www.cnblogs.com/virtualzzf/p/19617629",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/virtualzzf/p/19617629\" id=\"cb_post_title_url\" title=\"发布于 2026-02-15 10:46\">\n    <span>OpenEuler 20.03构建zabbix8.0 rpm包</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        OpenEuler 20.03自行构建zabbix8.0 rpm包\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"一说明\">一、说明</h1>\n<h2 id=\"为什么要自己构建\">为什么要自己构建？</h2>\n<p>由于centos从7版本之后改为stream，工作环境由centos转向OpenEuler。zabbix官网上有各大主流操作系统预编译的rpm包，但是Openeuler相对小众，自然没有制作好的包。即使是centos系统，7版本也过于陈旧了，从zabbix 6.0开始，centos 7已经不提供server的rpm包了，只剩下proxy和agent，到了7.0版本，连proxy都没有了。学会自己创建rpm包，以备操作系统环境发生改变是非常有必要的。</p>\n<h2 id=\"为什么不直接源代码编译\">为什么不直接源代码编译</h2>\n<ol>\n<li>由于采用的是sever-proxy-agent的多层架构，server只有一台，但是proxy有几十台，agent更是上千，每一台都用源代码编译工作量大大增加。</li>\n<li>源代码编译的软件，在一些例如配置文件、启停命令上与rpm版本有差异，如果混布增加了运维复杂度。</li>\n</ol>\n<h2 id=\"有没有预编译好的rpm包\">有没有预编译好的rpm包</h2>\n<p>在OpenEuler的官方社区的软件中心，有社区成员自行构建的rpm包，可以尝试找找有无符合自己要求的版本。<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<h1 id=\"二准备工作\">二、准备工作</h1>\n<h2 id=\"21-添加repo源\">2.1 添加repo源</h2>\n<p>如果OpenEuler缺少默认的repo源，需要自己添加<br />\n在/etc/yum.repos.d/openEuler_x86_64.repo中添加如下内容：</p>\n<pre><code>[OS]\nname=openEuler-$releasever - OS\nbaseurl=https://repo.openeuler.openatom.cn/openEuler-20.03-LTS-SP4/OS/$basearch/\nenabled=1\ngpgcheck=1\ngpgkey=https://repo.openeuler.openatom.cn/openEuler-20.03-LTS-SP4/OS/$basearch/RPM-GPG-KEY-openEuler\n</code></pre>\n<p>另外再添加everything的源，可以提供更多的包。</p>\n<pre><code>dnf config-manager --add-repo https://repo.openeuler.org/openEuler-20.03-LTS/everything/x86_64\n</code></pre>\n<p>使用<code>dnf clean all &amp;&amp; dnf makecache</code>命令更新。</p>\n<h2 id=\"22-准备构建rpm包环境\">2.2 准备构建rpm包环境</h2>\n<p>之前的文章里已经介绍了构建rpm包的基本方法，这里不再赘述。root用户下运行命令如下：</p>\n<pre><code>dnf install -y rpm-build\ndnf install -y rpmdevtools\nrpmdev-setuptree\n</code></pre>\n<p>下载srpm包（ <a href=\"http://repo.zabbix.com/zabbix/7.0/rhel/8/SRPMS/zabbix-7.0.23-release1.el8.src.rpm\" rel=\"noopener nofollow\" target=\"_blank\">http://repo.zabbix.com/zabbix/7.0/rhel/8/SRPMS/zabbix-7.0.23-release1.el8.src.rpm</a> ） ，这里以rhel8版本的srpm文件为例：</p>\n<pre><code>rpm -ivh zabbix-7.0.23-release1.el8.src.rpm\n</code></pre>\n<p>此时，在/root/rpmbuild目录下的SOURCES目录下会产生源代码压缩包、补丁和配置文件，SPECS目录会产生spec文件。但是此spec文件是Centos8版本的，与OpenEuler不完全契合，需要修改一下。</p>\n<h1 id=\"三安装依赖包\">三、安装依赖包</h1>\n<h2 id=\"31-buildrequires要求的依赖包\">3.1 BuildRequires要求的依赖包</h2>\n<table>\n<thead>\n<tr>\n<th>依赖包</th>\n<th>要求的版本</th>\n<th>dnf安装的版本</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>make</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>mariadb-connector-c-devel</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>postgresql-devel</td>\n<td>&gt;= 12.0</td>\n<td>10.5</td>\n</tr>\n<tr>\n<td>sqlite-devel</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>net-snmp-devel</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>openldap-devel</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>unixODBC-devel</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>curl-devel</td>\n<td>&gt;= 7.13.1</td>\n<td>7.66.0</td>\n</tr>\n<tr>\n<td>OpenIPMI-devel</td>\n<td>&gt;= 2</td>\n<td>2.0.29</td>\n</tr>\n<tr>\n<td>libssh-devel</td>\n<td>&gt;= 0.9.0</td>\n<td>0.9.4</td>\n</tr>\n<tr>\n<td>java-devel（java-1.8.0-openjdk-devel）</td>\n<td>&gt;= 1.6.0</td>\n<td>1.8.0.392.b08</td>\n</tr>\n<tr>\n<td>libxml2-devel</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>libevent-devel</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>pcre2-devel</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>openssl-devel</td>\n<td>&gt;= 1.0.1</td>\n<td>1.1.1f</td>\n</tr>\n<tr>\n<td>systemd</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>policycoreutils-devel</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>selinux-policy-devel</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>c-ares-devel</td>\n<td>&gt;= 1.19.0</td>\n<td>1.16.1</td>\n</tr>\n<tr>\n<td>安装全部依赖：</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<pre><code>dnf install -y make mariadb-connector-c-devel postgresql-devel sqlite-devel net-snmp-devel openldap-devel unixODBC-devel curl-devel OpenIPMI-devel libssh-devel java-1.8.0-openjdk-devel libxml2-devel libevent-devel pcre2-devel openssl-devel systemd policycoreutils-devel selinux-policy-devel c-ares-devel\n</code></pre>\n<h2 id=\"32-golang配置\">3.2 golang配置</h2>\n<h3 id=\"版本更新\">版本更新</h3>\n<p>zabbix agent2和web_service是使用GO语言编写的，并且使用的语法对版本还有要求，OpenEuler 20.03默认repo源的版本为1.15，需要安装一个较新版本的。<br />\n首先下载golang的压缩包并解压</p>\n<pre><code>tar -C /usr/local -xzf go1.24.8.linux-amd64.tar.gz\n</code></pre>\n<p>配置PATH变量并生效</p>\n<pre><code>tee /etc/profile.d/go.sh &lt;&lt;EOL\nexport GO_HOME=/usr/local/go\nexport PATH=\\$PATH:\\$GO_HOME/bin\nEOL\nsource /etc/profile\n</code></pre>\n<p>使用<code>go version</code>命令查看更新是否生效</p>\n<h3 id=\"配置代理\">配置代理</h3>\n<p>在构建中，会自动下载go的工具链（toolchain），但是由于网络缘故，无法访问默认的代理地址（proxy.golang.org），导致构建失败<br />\n使用命令<code>go env -w GOPROXY=https://goproxy.cn,direct</code>，改用七牛云的goproxy<br />\n使用命令<code>go env GOPROXY</code>测试是否生效。</p>\n<h1 id=\"四修改spec文件\">四、修改spec文件</h1>\n<p>修改好的spec文件见：<a href=\"https://files.cnblogs.com/files/blogs/745793/zabbix.zip?t=1771123185&amp;download=true\" target=\"_blank\">https://files.cnblogs.com/files/blogs/745793/zabbix.zip?t=1771123185&amp;download=true</a></p>\n<h2 id=\"41-删除rhel和amzn宏\">4.1 删除%{rhel}和%{?amzn}宏</h2>\n<p>%{rhel}和%{?amzn}两个宏分别标识了redhat和amazon系linux的大版本号，用于构建时一些配置方式的选择。由于这两个宏在OpenEuler中为空，在spec文件中会被全局定义为0，直接使用会影响构建，需要全部进行处理。<br />\n与OpenEuler相对接近的是Centos8，把%{?rhel}当做“8”处理，%{?amzn}直接删除。</p>\n<h3 id=\"示例1\">示例1</h3>\n<pre><code>%if ( 0%{?rhel} &gt;= 7 &amp;&amp; 0%{?amzn} == 0 ) || 0%{?amzn} &gt;= 2023\n%{!?build_agent2: %global build_agent2 1}\n%endif\n</code></pre>\n<p>由于08 &gt;= 7，修改为</p>\n<pre><code>%{!?build_agent2: %global build_agent2 1}\n</code></pre>\n<h3 id=\"示例2\">示例2</h3>\n<pre><code>%if 0%{rhel} &gt;= 9 || 0%{?amzn} &gt;= 2023\nBuildRequires: selinux-policy-devel\nBuildRequires: c-ares-devel &gt;= 1.19.0\n%endif\n</code></pre>\n<p>由于不满足 08 &gt;= 9 ，直接删除</p>\n<h2 id=\"42-修改buildrequires版本要求\">4.2 修改BuildRequires版本要求</h2>\n<p>官网repo源的postgresql-devel版本不达标，直接进行构建会报错。<br />\npostgresql官网没有OpenEuler的预编译rpm包，想要满足要求必须自行从源代码进行编译。<br />\n本文仅为演示，将<code>postgresql-devel &gt;= 12.0</code>修改为<code>postgresql-devel</code></p>\n<h1 id=\"五构建\">五、构建</h1>\n<p>使用<code>rpmbuild -bb zabbix.spec</code>命令进行构建，需要比较长的时间。<br />\n完成后在/root/rpmbuild/RPMS目录下就会生成编译好的rpm包。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-15 10:46</span>&nbsp;\n<a href=\"https://www.cnblogs.com/virtualzzf\">virtualzzf</a>&nbsp;\n阅读(<span id=\"post_view_count\">41</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "为什么现代 C++ 库都用 PIMPL？一场关于封装、依赖与安全的演进",
      "link": "https://www.cnblogs.com/charlee44/p/19616660",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/charlee44/p/19616660\" id=\"cb_post_title_url\" title=\"发布于 2026-02-14 21:27\">\n    <span>为什么现代 C++ 库都用 PIMPL？一场关于封装、依赖与安全的演进</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        系统阐述了在 C++ 工程中如何通过 PIMPL 惯用法，在坚守 RAII 资源安全的前提下，有效解耦头文件依赖、提升编译效率并保持接口简洁。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>在 C++ 的工程实践中，如何在保证资源安全管理的同时，又避免头文件污染和不必要的编译依赖？这个问题贯穿了现代 C++ 库设计的核心。本文将沿着一条清晰的技术演进路径，探讨从 RAII 封装出发，历经值语义、裸指针、智能指针等阶段，最终走向 PIMPL（Pointer to Implementation） 这一成熟且优雅的解决方案。</p>\n</blockquote>\n<h1 id=\"1-raii资源管理的基石\">1. RAII——资源管理的基石</h1>\n<p>C++ 的核心哲学之一是 RAII（Resource Acquisition Is Initialization）：资源（内存、文件句柄、网络连接等）的生命周期应由对象的构造与析构自动管理。例如：</p>\n<pre><code class=\"language-cpp\">class FileHandle {\n    FILE* fp;\npublic:\n    FileHandle(const char* path) : fp(fopen(path, \"r\")) {}\n    ~FileHandle() { if (fp) fclose(fp); }\n};\n</code></pre>\n<p>RAII 让资源管理变得安全：利用类对象的生命周期，在构造函数中申请资源，在析构函数中释放资源。如果这个类对象是基于栈的值对象，那么就可以自动实现资源的管理。因此，在现代 C++ 中，相比传统的指针语义，更加提倡使用基于 RAII 的值语义。</p>\n<h1 id=\"2-值语义的诱惑与代价\">2. 值语义的诱惑与代价</h1>\n<p>但是，当我们把这种思想用于封装复杂组件（如 ONNX 模型会话、数据库连接池）时，问题出现了。理想情况下，我们希望像使用 std::string 一样，用“值语义”操作一个封装对象：</p>\n<pre><code class=\"language-cpp\">class Embedder {\n    Ort::Session session; // 值成员\npublic:\n    std::vector&lt;float&gt; embed(const std::string&amp; text);\n};\n</code></pre>\n<p>这看起来非常简洁、高效、符合现代 C++ 风格。但也有另外一个问题：破坏了封装，导致不必要的环境依赖。最直观的问题就是 <code>Ort::Session</code> 的完整定义必须出现在头文件中，这意味着使用者必须包含 onnxruntime ，而这个头文件可能重达数 MB ，依赖数十个系统库。这就会造成如下问题：</p>\n<ul>\n<li>编译时间暴增，微小的改动都需要编译很长的时间。</li>\n<li>头文件耦合严重，调用者使用不方便，甚至造成环境污染。</li>\n<li>ABI 极其脆弱，内部改动导致所有用户重编译。</li>\n</ul>\n<h1 id=\"3-指针语义的回退\">3. 指针语义的回退</h1>\n<p>为了解耦，一个比较好的办法就是使用前置声明 + 指针语义：</p>\n<pre><code class=\"language-cpp\">// header\nclass SessionImpl; // 前置声明\nclass Embedder {\n    SessionImpl* pimpl;\npublic:\n    Embedder();\n    ~Embedder(); // 必须手动 delete\n};\n</code></pre>\n<p>这样做确实切断了编译依赖，但也引入了新的问题。那就是需要按照 RAII 原则写好构造函数和析构函数。而一旦要写析构函数，也往往意味着需要写另外四个特殊的成员函数：</p>\n<ol>\n<li>拷贝构造函数（Copy Constructor）</li>\n<li>拷贝赋值运算符（Copy Assignment Operator）</li>\n<li>移动构造函数（Move Constructor）</li>\n<li>移动赋值运算符（Move Assignment Operator）</li>\n</ol>\n<p>这样做要写非常多的样板代码，而且也很容易出问题。为了封装牺牲安全，得不偿失。</p>\n<h1 id=\"4-使用智能指针\">4. 使用智能指针</h1>\n<p>使用裸指针又麻烦又不安全，那么就可以使用 C++11 引入的智能指针：std::unique_ptr 和 std::shared_ptr；智能指针同样是基于 RAII 的：</p>\n<pre><code class=\"language-cpp\">class SessionImpl;\nclass Embedder {\n    std::unique_ptr&lt;SessionImpl&gt; pimpl;\n};\n</code></pre>\n<p>这里为什么使用 <code>std::unique_ptr</code> 而不使用 <code>std::shared_ptr</code> 呢？其实也可以，不过在现代 C++ 中，更推荐使用 <code>std::unique_ptr</code> 。<code>std::shared_ptr</code> 是用来共享资源的所有权，会对引用资源进行计数，但是有可能会造成相互循环引用造成不能释放资源的问题；而<code>std::unique_ptr</code> 则表示独占资源的所有权，不仅开销更低（无引用计数），也更加安全（只能通过 <code>std::move</code> 转移所有权 ）。</p>\n<p>不过有一点需要注意：<code>std::unique_ptr</code> 和 <code>std::shared_ptr</code> 在处理不完整类型（incomplete type）时的行为截然不同。具体来说，当在头文件中使用前置声明（如 <code>class Impl;</code>）并用智能指针持有它时，<code>Impl</code> 是一个不完整类型。</p>\n<ul>\n<li><code>std::shared_ptr</code> 可以安全地在头文件中默认析构，因为它在构造时（通常在 <code>.cpp</code> 文件中）会捕获一个完整的删除器（deleter），即使析构发生在头文件上下文中，也能正确调用 <code>delete</code>。</li>\n<li>而 <code>std::unique_ptr</code> 的删除器是其类型的一部分（通常是默认的 <code>std::default_delete&lt;Impl&gt;</code>），它要求在析构点（即类的析构函数被实例化的地方）<code>Impl</code> 必须是完整类型。如果在头文件中写 <code>~Embedder() = default;</code>，此时 <code>Impl</code> 仍是不完整的，编译器可能不会报错，但会导致未定义行为（通常是链接失败或运行时崩溃）。</li>\n</ul>\n<p>因此，使用 <code>std::unique_ptr&lt;Impl&gt;</code> 时，必须将主类的析构函数定义移到 <code>.cpp</code> 文件中，确保 <code>Impl</code> 已被完整定义：</p>\n<pre><code class=\"language-cpp\">// Embedder.cpp\nclass Embedder::Impl {\n    // 完整定义...\n};\n\nEmbedder::~Embedder() = default; // ✅ 此时 Impl 完整，安全析构\n</code></pre>\n<h1 id=\"5-封装与效率的平衡pimpl\">5. 封装与效率的平衡：PIMPL</h1>\n<p>使用智能指针虽然好，但是总归是比不上值语义方便。当类中只有一个需要隐藏的成员还好，如果有很多个需要隐藏的成员，每一个都写前置声明，并用智能指针来管理，那就实在太繁琐了。并且，从编程品味上来说，C++ 智能指针的写法说不上优雅：智能指针是由传染性的，当满屏都是 <code>std::shared_ptr</code> 或者 <code>std::unique_ptr</code> 的时候，实在很影响阅读性。</p>\n<p>另外，作为对外的接口，最好是提供像 Java / C# 那样的接口，C++ 的纯虚函类也行，隐藏掉所有的细节，包括私有函数和数据成员。这样有非常多的好处：</p>\n<ol>\n<li>最小化依赖环境，提升编译速度。</li>\n<li>调用者使用方便，不会污染环境。</li>\n<li>ABI 稳定，可以只更新库而不用更新整个程序。</li>\n</ol>\n<p>那么要怎么进行优化呢？很简单，我们可以实现一个名为 <code>Impl</code> 的类中类 ，使用<code>std::unique_ptr</code>进行管理。<code>Impl</code> 是实现在 cpp 中的，可以将一切实现的细节，比说私有函数和数据成员，都放在这个 <code>Impl</code> 中。更重要的是，<code>Impl</code> 中的数据成员完全可以使用值类型！如下所示：</p>\n<pre><code class=\"language-cpp\">// 头文件\nclass Embedder {\n    class Impl;\n    std::unique_ptr&lt;Impl&gt; impl;\npublic:\n    Embedder(const std::string&amp; model);\n    ~Embedder(); // 声明但不在头文件定义！\n    std::vector&lt;float&gt; embed(std::string_view text) const;\n};\n</code></pre>\n<pre><code class=\"language-cpp\">// 源文件\nclass Embedder::Impl {\n    Ort::Session session;\n    hf::Tokenizer tokenizer;\n    int64_t dim;\npublic:\n    Impl(const std::string&amp; path, const hf::Tokenizer&amp; tok) \n        : session(...), tokenizer(tok) { /* init */ }\n    std::vector&lt;float&gt; embed(std::string_view text) const { /* ... */ }\n};\n\nEmbedder::Embedder(const std::string&amp; path) \n    : impl(std::make_unique&lt;Impl&gt;(path, global_tokenizer)) {}\n\nEmbedder::~Embedder() = default; // 此时 Impl 完整，安全！\n</code></pre>\n<p>这个实现，就是所谓的 PIMPL（Pointer to IMPLementation）惯用法，也常被称作 “编译防火墙”（Compilation Firewall） 或 “Opaque Pointer” 模式。不得不说，这种 PIMPL 设计模式确实精妙——它在安全性、封装性、编译效率与接口简洁性之间取得了近乎完美的平衡，既坚守了 RAII 的资源管理原则，又有效隔离了实现细节，堪称现代 C++ 工程实践中“高内聚、低耦合”的典范。</p>\n<h1 id=\"6-没有银弹只有权衡\">6. 没有银弹，只有权衡</h1>\n<p>PIMPL 使用了前置声明。是否使用前置声明一直是 C++ 中比较争议的一点，Qt 遵循前置声明的原则实现了非常强大、优雅且高效的 C++ 运行时框架。Google 则经历了从推荐使用前置声明到不推荐使用前置声明的转变。个人认为，PIMPL 解决的就是 C++ 中两个重要原则矛盾的问题：</p>\n<ul>\n<li>推荐使用值语义，但是会引入更多环境依赖</li>\n<li>封装需要尽可能隐藏不必要的细节</li>\n</ul>\n<p>如果两者只能选择其中一个，那么还是尽量使用值语义的原则更加重要，毕竟这涉及到安全问题，而资源管理的安全问题贯穿 C++ 程序的始终。事实上，如果不是提供对外接口，或者实现比较小，那么直接使用值语义即可（第2节中的内容）——值语义永远是最简洁安全的实现。</p>\n<p>另外，如果实现 C++20 Modules ，那么就不必要使用 PIMPL 了，完全可以回归值语义实现，因为 C++20 Modules 在语言层面已经实现了 PIMPL 的诸多优点。</p>\n<h1 id=\"7-示例代码\">7. 示例代码</h1>\n<p>最后放出笔者自己实现的基于 PIMPL 的嵌入器的完整代码供读者参考：</p>\n<pre><code class=\"language-cpp\">// BgeOnnxEmbedder.h\n#pragma once\n\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace embedding {\n\nnamespace hf {\nclass Tokenizer;\n}\n\nclass BgeOnnxEmbedder {\n public:\n  explicit BgeOnnxEmbedder(const std::string&amp; modelPath,\n                           const hf::Tokenizer&amp; tokenizer);\n  ~BgeOnnxEmbedder();\n\n  const int64_t&amp; EmbeddingDim() const;\n\n  std::vector&lt;float&gt; Embed(const std::string&amp; text) const;\n\n private:\n  class Impl;  // 前向声明\n  std::unique_ptr&lt;Impl&gt; impl;\n};\n\n}  // namespace embedding\n</code></pre>\n<pre><code class=\"language-cpp\">//BgeOnnxEmbedder.cpp\n#include \"BgeOnnxEmbedder.h\"\n\n#include &lt;onnxruntime_cxx_api.h&gt;\n\n#include \"HfTokenizer.h\"\n#include \"Util/StringEncode.h\"\n\nnamespace embedding {\n\nclass BgeOnnxEmbedder::Impl {\n public:\n  Ort::Env&amp; GetOrtEnv() {\n    static Ort::Env env(ORT_LOGGING_LEVEL_WARNING, \"BgeOnnxEmbedder\");\n    return env;\n  }\n\n  const int64_t&amp; EmbeddingDim() const { return embeddingDim; }\n\n  explicit Impl(const std::string&amp; modelPath, const hf::Tokenizer&amp; tokenizer)\n      : session{GetOrtEnv(),\n#ifdef _WIN32\n                util::StringEncode::Utf8StringToWideString(modelPath).c_str(),\n#else\n                modelPath.c_str(),\n#endif\n                Ort::SessionOptions()},\n        memInfo{Ort::MemoryInfo::CreateCpu(OrtDeviceAllocator, OrtMemTypeCPU)},\n        tokenizer(tokenizer),\n        embeddingDim(0) {\n\n    //\n    const auto&amp; outputInfo = session.GetOutputTypeInfo(0);\n    const auto&amp; tensorInfo = outputInfo.GetTensorTypeAndShapeInfo();\n    const auto&amp; shape = tensorInfo.GetShape();\n\n    // 假设输出是 [batch, seq, dim] 或 [batch, dim]\n    // 我们取最后一个非 -1 的维度\n    for (auto it = shape.rbegin(); it != shape.rend(); ++it) {\n      if (*it != -1) {\n        embeddingDim = *it;\n        break;\n      }\n    }\n\n    if (embeddingDim == 0) {\n      throw std::runtime_error(\n          \"Failed to infer embedding dimension from ONNX model.\");\n    }\n  }\n\n  std::vector&lt;float&gt; Embed(const std::string&amp; text) const {\n    hf::Tokenizer::ResultPtr result = tokenizer.Encode(text);\n    if (!result) {\n      throw std::runtime_error(\"tokenizer_encode failed\");\n    }\n\n    // 定义张量维度\n    int64_t seqLen = static_cast&lt;int64_t&gt;(result-&gt;length);\n    std::vector&lt;int64_t&gt; inputShape = {1, seqLen};\n    size_t dataByteCount = sizeof(int64_t) * seqLen;\n\n    Ort::Value inputIdsTensor = Ort::Value::CreateTensor(\n        memInfo.GetConst(), result-&gt;input_ids, dataByteCount, inputShape.data(),\n        inputShape.size(),\n        ONNXTensorElementDataType::ONNX_TENSOR_ELEMENT_DATA_TYPE_INT64);\n\n    Ort::Value attentionMaskTensor = Ort::Value::CreateTensor(\n        memInfo.GetConst(), result-&gt;attention_mask, dataByteCount,\n        inputShape.data(), inputShape.size(),\n        ONNXTensorElementDataType::ONNX_TENSOR_ELEMENT_DATA_TYPE_INT64);\n\n    Ort::Value tokenTypeIdsTensor = Ort::Value::CreateTensor(\n        memInfo.GetConst(), result-&gt;token_type_ids, dataByteCount,\n        inputShape.data(), inputShape.size(),\n        ONNXTensorElementDataType::ONNX_TENSOR_ELEMENT_DATA_TYPE_INT64);\n\n    // 输入名必须与模型定义一致\n    const char* inputNames[] = {\"input_ids\", \"attention_mask\",\n                                \"token_type_ids\"};\n    const char* outputNames[] = {\"last_hidden_state\"};\n\n    // 把三个输入张量放进数组\n    std::vector&lt;Ort::Value&gt; inputs;\n    inputs.push_back(std::move(inputIdsTensor));\n    inputs.push_back(std::move(attentionMaskTensor));\n    inputs.push_back(std::move(tokenTypeIdsTensor));\n\n    // 执行推理\n    auto outputs = session.Run(Ort::RunOptions(),  // 运行选项（通常 nullptr）\n                               inputNames,         // 输入名数组\n                               inputs.data(),  // 输入张量数组\n                               inputs.size(),  // 输入数量（3）\n                               outputNames,    // 输出名数组\n                               1               // 输出数量（1）\n    );\n\n    // 获取输出信息\n    auto&amp; output_tensor = outputs[0];\n    auto output_shape = output_tensor.GetTensorTypeAndShapeInfo().GetShape();\n    if (output_shape.size() != 3 || output_shape[0] != 1) {\n      throw std::runtime_error(\"Unexpected output shape\");\n    }\n\n    // 获取输出张量的原始 float 指针\n    const float* outputData = outputs[0].GetTensorData&lt;float&gt;();\n\n    // 提取 [CLS] token 的 embedding（第0个token）\n    int64_t hiddenSize = output_shape[2];\n    std::vector&lt;float&gt; embedding(outputData, outputData + hiddenSize);\n\n    // L2 归一化（BGE 要求）\n    float norm = 0.0f;\n    for (float v : embedding) norm += v * v;\n    norm = std::sqrt(norm);\n    if (norm &gt; 1e-8) {\n      for (float&amp; v : embedding) v /= norm;\n    }\n\n    return embedding;\n  }\n\n private:\n  mutable Ort::Session session;\n  Ort::MemoryInfo memInfo;\n  const hf::Tokenizer&amp; tokenizer;\n  int64_t embeddingDim;\n};\n\nBgeOnnxEmbedder::BgeOnnxEmbedder(const std::string&amp; modelPath,\n                                 const hf::Tokenizer&amp; tokenizer)\n    : impl(std::make_unique&lt;Impl&gt;(modelPath, tokenizer)) {}\n\nBgeOnnxEmbedder::~BgeOnnxEmbedder() = default;  // 此时 Impl 已定义，可安全析构\n\nconst int64_t&amp; BgeOnnxEmbedder::EmbeddingDim() const {\n  return impl-&gt;EmbeddingDim();\n}\n\nstd::vector&lt;float&gt; BgeOnnxEmbedder::Embed(const std::string&amp; text) const {\n  return impl-&gt;Embed(text);\n}\n\n}  // namespace embedding\n</code></pre>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-14 21:27</span>&nbsp;\n<a href=\"https://www.cnblogs.com/charlee44\">charlee44</a>&nbsp;\n阅读(<span id=\"post_view_count\">73</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "AI编程时代普通本科计算机毕业生的出路",
      "link": "https://www.cnblogs.com/xdesigner/p/19615230",
      "published": "",
      "description": "<h2>\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xdesigner/p/19615230\" id=\"cb_post_title_url\" title=\"发布于 2026-02-14 13:36\">\n    <span>AI编程时代普通本科计算机毕业生的出路</span>\n    \n\n</a>\n\n\t\t</h2>\n\t\t<div class=\"postText\">    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        AI编程工具快速普及，正在彻底改写整个程序员行业的格局与就业逻辑。对国内数百万一本、二本普通计算机专业的毕业生来说，就业环境已经变得异常残酷，那么出路在哪里？\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><span style=\"font-size: 18pt;\">AI<span>编程时代</span>普通本科计算机毕业生的出路</span></p>\n<p><span style=\"font-size: x-large;\">袁永福 2026-2-14</span></p>\n<p><span style=\"font-size: 18pt;\">&nbsp; AI<span>编程工具快速普及，正在彻底改写整个程序员行业的格局与就业逻辑。对于985，211重点大学计算机专业毕业生来说还能应付。但对数百万一本、二本普通计算机专业的毕业生来说，环境已经变得异常残酷：</span><span style=\"font-family: Calibri;\">ToC&nbsp;</span><span>程序员岗位总量快速收缩，互联网大厂招人数量大幅下降；</span><span style=\"font-family: Calibri;\">ToB&nbsp;</span><span>程序员岗位虽然也在收紧，招人规模有所减少，但依然保留着真实的就业机会。 而很多学生选择的全职考公、考研、考编，对大多数人来说早已不是靠谱出路，而是一块逃避现实、变相啃老的遮羞布。面对大势，最清醒、优先级最高的选择非常明确：拥抱</span><span style=\"font-family: Calibri;\">AI</span><span>而不是抵制</span><span style=\"font-family: Calibri;\">AI</span><span>，充分利用</span><span style=\"font-family: Calibri;\">AI</span><span>带来的技术平权，优先进入</span><span style=\"font-family: Calibri;\">ToB</span><span>领域，扎扎实实与一个长期行业深度绑定，这才是普通计算机毕业生最现实、最可持续的就业路线。</span></span></p>\n<p><span style=\"font-size: 18pt;\">&nbsp; 从全球行业数据来看，估计<span>当前全球程序员总量约</span>2700<span>万人，其中&nbsp;</span><span style=\"font-family: Calibri;\">ToC&nbsp;</span><span>程序员和</span><span style=\"font-family: Calibri;\">ToB&nbsp;</span><span>程序员大约各占一半</span><span>。过去十几年，互联网高速扩张，</span><span style=\"font-family: Calibri;\">ToC&nbsp;</span><span>领域一直是吸纳程序员最多的方向。</span></span></p>\n<p><span style=\"font-size: 18pt;\"><span>&nbsp; 但在</span>AI<span>与行业周期的双重冲击下，这个格局正在快速反转。</span><span style=\"font-family: Calibri;\">ToC&nbsp;</span><span>程序员的岗位正在大幅减少。 互联网大厂、电商、社交、工具类产品，大量工作集中在界面开发、接口实现、业务逻辑拼接等重复性内容，而这正是</span><span style=\"font-family: Calibri;\">AI</span><span>最擅长替代的部分。再加上行业降本增效，企业不再靠堆人头做规模，而是用资深工程师配合</span><span style=\"font-family: Calibri;\">AI</span><span>工具完成工作，</span><span style=\"font-family: Calibri;\">ToC&nbsp;</span><span>整体岗位数量快速下降。大家常说的“</span><span style=\"font-family: Calibri;\">30</span><span>岁危机”“</span><span style=\"font-family: Calibri;\">35</span><span>岁退休”，几乎全部来自</span><span style=\"font-family: Calibri;\">ToC&nbsp;</span><span>行业，因为这里拼成本、拼速度、拼年轻化，普通学历开发者几乎没有长期竞争力。</span></span></p>\n<p><span style=\"font-size: 18pt;\">&nbsp; ToB&nbsp;<span>程序员的处境则完全不同。 虽然受经济环境影响，企业招新人的数量也在下降，入口比以前更窄，但岗位并没有消失。</span><span style=\"font-family: Calibri;\">ToB&nbsp;</span><span>面向企业、政府、医疗、金融、工业、能源等垂直行业，核心价值在于业务理解、行业规则、系统稳定性和复杂项目落地能力。</span><span style=\"font-family: Calibri;\">AI</span><span>可以辅助编码，但无法替代行业经验与真实项目积累。在</span><span style=\"font-family: Calibri;\">ToB</span><span>领域，</span><span style=\"font-family: Calibri;\">35</span><span>岁不是危机，而是黄金年龄，经验越丰富越不可替代。</span></span></p>\n<p><span style=\"font-size: 18pt;\"><span>&nbsp; 根据预测，</span>5<span>年后全球程序员结构将出现颠覆性变化：</span><span style=\"font-family: Calibri;\">ToC&nbsp;</span><span>程序员会从现在的</span><span style=\"font-family: Calibri;\">1800</span><span>万减到1400万左右</span><span>，总量接近腰斩；而&nbsp;</span><span style=\"font-family: Calibri;\">ToB&nbsp;</span><span>程序员会从1300</span><span>万稳步增长到1700</span><span>万左右。</span><span>这组数据，为普通计算机毕业生指明了最确定的方向。</span></span></p>\n<p><span style=\"font-size: 18pt;\"><span>&nbsp; 可现实中，大量一本、二本学生一毕业就放弃就业，全职备考。不工作、不实习、无收入，完全依靠家庭支持，看上去是在努力奋斗，本质却非常残酷：考研极度内卷，考公录取率不足</span>3%<span>，全职备考本质上就是用极低概率的梦想，掩盖自己不敢进入社会的事实，成为一块体面又合理的啃老遮羞布。 几年</span>后不出意外的考不上，技能退化、经验空白、年龄变大，最终既没上岸，也没工作，两头落空。是一种对自己对家人不负责任的行为。</span></p>\n<p><span style=\"font-size: 18pt;\"><span>&nbsp; 面对</span>AI<span>编程的大趋势，正确的态度不是恐惧和抵制，而是主动拥抱。</span><span style=\"font-family: Calibri;\">AI</span><span>带来了前所未有的技术平权：过去需要长期训练才能具备的编码能力，现在借助</span><span style=\"font-family: Calibri;\">AI</span><span>工具可以快速上手。这对基础一般、学历普通的学生来说，是巨大的机会——你不需要成为顶尖高手，只要会用</span><span style=\"font-family: Calibri;\">AI</span><span>、能落地、懂业务，就能在</span><span style=\"font-family: Calibri;\">To B</span><span>领域站稳脚跟</span>&nbsp;</span></p>\n<p><span style=\"font-size: 18pt;\"><span>&nbsp; 因此，普通本科计算机毕业生最高优先级的选择，不是死磕</span>To C<span>大厂，不是赌命考公考研，而是放低姿态、接受合理起薪，优先进入</span><span style=\"font-family: Calibri;\">To B</span><span>行业。不必执着于大厂光环，不必纠结于起点高低，先入行、先积累。选择医疗</span><span style=\"font-family: Calibri;\">IT</span><span>、政务信息化、工业软件、金融后台等长期稳定的方向，在一个行业扎根</span><span style=\"font-family: Calibri;\">3</span><span>—</span><span style=\"font-family: Calibri;\">5</span><span>年，把自己和行业深度绑定，用业务壁垒建立</span><span style=\"font-family: Calibri;\">AI</span><span>无法替代的竞争力。</span></span></p>\n<p><span style=\"font-size: 18pt;\">&nbsp; AI<span>时代没有捷径，只有最现实的生存策略。</span><span style=\"font-family: Calibri;\">ToC&nbsp;</span><span>在收缩，考公考研是概率陷阱，全职备考只是</span>啃老<span>遮羞布。拥抱</span>AI<span>、用好技术平权、坚定入局</span><span style=\"font-family: Calibri;\">ToB</span><span>、深耕垂直行业，才是普通计算机毕业生在时代变局中，最清醒、相对最务实，走得最远的出路。</span></span></p>\n\n</div>\n<div class=\"clear\"></div>\n</div>\n\t\t<p class=\"postfoot\">\n\t\t\tposted on \n<span id=\"post-date\">2026-02-14 13:36</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xdesigner\">袁永福 电子病历，医疗信息化</a>&nbsp;\n阅读(<span id=\"post_view_count\">280</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</p>"
    }
  ]
}