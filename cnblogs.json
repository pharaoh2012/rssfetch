{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "决策树极简入门",
      "link": "https://www.cnblogs.com/wang_yb/p/19587107",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wang_yb/p/19587107\" id=\"cb_post_title_url\" title=\"发布于 2026-02-07 08:06\">\n    <span>决策树极简入门</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>我们在学习机器学习算法时，往往会被各种枯燥的数学公式所劝退。</p>\n<p>今天，我将尝试用结合实际生活的方式，来介绍一个非常经典，而且可能是最“懂你心意”的算法——决策树 (Decision Tree)。。</p>\n<p>别被这个术语吓到了，其实你每天点外卖的时候都在用它。</p>\n<p>想象一下，下午三点，你站在奶茶店门口（或者打开了外卖App），面对眼花缭乱的菜单，你的大脑为了保护你的体重，立刻启动了一个“决策树”程序：</p>\n<ol>\n<li>这杯奶茶含糖吗？ -&gt; 如果是全糖 -&gt; 不喝，会胖死 ❌。</li>\n<li>-&gt; 如果是无糖 -&gt; 再看看。</li>\n<li>加没加小料？ -&gt; 没加？ -&gt; 没灵魂，不喝 ❌。</li>\n<li>-&gt; 加了波霸/珍珠？ -&gt; 完美！买它！ ✅</li>\n</ol>\n<p><img alt=\"画板\" src=\"https://img2024.cnblogs.com/blog/83005/202602/83005-20260207080350892-40837281.jpg\" /></p>\n<p>看，这就是一棵决策树！把你脑海里纠结的过程画下来，它就是一个倒立的树状流程图。</p>\n<p>但在机器学习里，我们不是自己画图，而是让计算机通过学习历史订单数据，自己总结出这套“点单秘籍”。</p>\n<p>它是怎么做到的？别急，我们要用几杯奶茶来教会你。🧋</p>\n<h1 id=\"-第一部分解剖决策树\">🌲 第一部分：解剖决策树</h1>\n<p>在深入之前，咱们先对齐一下 <strong>“行话”</strong>。虽然它叫树，但在计算机科学里，这棵树通常是倒着长的（根在上面，叶子在下面）。</p>\n<ul>\n<li><strong>根节点</strong> (<code>Root Node</code>): 树的最顶端。也就是最关键的那个问题（比如：甜度是多少？）。</li>\n<li><strong>决策节点</strong> (<code>Decision Node</code>): 中间的那些站点，负责根据某个特征（比如小料、冷热）把数据分流。</li>\n<li><strong>叶节点</strong> (<code>Leaf Node</code>): 树的末端。到了这里，不再问问题了，直接给出最终判决（比如：喝！ 或者 快逃！）。</li>\n</ul>\n<h1 id=\"-第二部分树是怎么长出来的\">🧠 第二部分：树是怎么“长”出来的？</h1>\n<p>这才是最迷人的地方。如果你给模型一堆奶茶数据，它怎么知道先看“甜度”还是先看“价格”？</p>\n<p>这就涉及到两个超级重要的概念：<strong>熵</strong> (<code>Entropy</code>) 和 <strong>信息增益</strong> (<code>Information Gain</code>)。</p>\n<h2 id=\"1-什么是熵-entropy\">1. 什么是熵 (Entropy)？</h2>\n<p>物理学里说<strong>熵</strong>代表<strong>混乱程度</strong>。在决策树里，<strong>熵</strong>代表数据的 <strong>“不纯度”</strong>（你也可以理解为** “纠结程度” **）。</p>\n<ul>\n<li><strong>场景 A</strong>: 你面前有10杯奶茶，全是无糖波霸奶茶。这数据太纯了，熵 = 0。你闭着眼拿一杯都是你想喝的，完全不用纠结。</li>\n<li><strong>场景 B:</strong> 你面前有10杯奶茶，5杯是你最爱的无糖，5杯是甜到齁的全糖，混在一起。这太混乱了，熵 = 1（最高）。你完全猜不到下一杯是不是“雷”。</li>\n</ul>\n<p>机器学习的目标就是：通过问问题（分裂），让数据的熵越来越小，直到变成 0（完全纯净）。</p>\n<h2 id=\"2-信息增益-information-gain\">2. 信息增益 (Information Gain)</h2>\n<p>这就是我们的 <strong>“筛选标准”</strong>。</p>\n<ul>\n<li><strong>信息增益</strong> = <strong>分裂前的熵</strong> - <strong>分裂后的熵</strong></li>\n</ul>\n<p>简单说：如果我按“甜度”分，能让这堆数据变得多“干净”？ 哪个问题能帮我排除掉最多的干扰项，我们就选哪个问题当老大（根节点）！</p>\n<h1 id=\"-第三部分手动算一算-奶茶案例\">📊 第三部分：手动算一算 (奶茶案例)</h1>\n<p>假设我们收集了你过去买的50次奶茶记录，你的口味偏好非常明显：只喝无糖。<br />\n数据分布如下：</p>\n<ul>\n<li><strong>全糖</strong>: <code>25</code>杯 -&gt; 结果全是 不喝 (❌)</li>\n<li><strong>无糖</strong>: <code>25</code>杯 -&gt; 结果是 喝 (✅)</li>\n</ul>\n<p>我们要决定：先按“甜度”分，还是先按“加没加冰”分？</p>\n<h2 id=\"方案一按甜度切一刀-\">方案一：按“甜度”切一刀 🔪</h2>\n<ul>\n<li>左边（<strong>全糖堆</strong>）: 25杯全是❌。完美！这堆数据的熵直接变成0了！（不用再问别的了，直接扔掉）。</li>\n<li>右边（<strong>无糖堆</strong>）: 25杯全是✅。完美！熵也是0！</li>\n</ul>\n<h2 id=\"方案二按加冰切一刀-\">方案二：按“加冰”切一刀 🧊</h2>\n<p>假设全糖和无糖里都有加冰和去冰的情况。</p>\n<ul>\n<li>左边（<strong>加冰堆</strong>）: 混杂着全糖(❌)和无糖(✅)。还是很乱，熵很高。</li>\n<li>右边（<strong>去冰堆</strong>）: 同样混杂。</li>\n</ul>\n<p>很明显，按<strong>甜度分</strong>的信息增益最大，因为它能帮我们瞬间把“绝对不喝”的那部分挑出来。</p>\n<p>所以，机器会选择 <strong>甜度</strong> 作为根节点！</p>\n<h1 id=\"-第四部分python-代码实战\">💻 第四部分：Python 代码实战</h1>\n<p>光说不练假把式。作为工程师，我们要用代码说话。我们会使用 Python 的 <code>scikit-learn</code> 库。</p>\n<p>假设我们整理好了数据 <code>milktea.csv</code>：</p>\n<table>\n<thead>\n<tr>\n<th>Sugar (甜度)</th>\n<th>Topping (小料)</th>\n<th>Decision (喝吗?)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Full (全糖)</td>\n<td>Pearls (珍珠)</td>\n<td>0 (No)</td>\n</tr>\n<tr>\n<td>Zero (无糖)</td>\n<td>None (无)</td>\n<td>0 (No - 太寡淡)</td>\n</tr>\n<tr>\n<td>Zero (无糖)</td>\n<td>Pearls (珍珠)</td>\n<td>1 (Yes)</td>\n</tr>\n<tr>\n<td>...</td>\n<td>...</td>\n<td>...</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"1-预处理与训练\">1. 预处理与训练</h2>\n<p>机器看不懂中文或单词，我们要把它翻译成数字。</p>\n<pre><code class=\"language-python\">import pandas as pd\nfrom sklearn import tree\nimport matplotlib.pyplot as plt\n\n# 1. 模拟一点奶茶数据\n# 假设我们的逻辑是：只有\"无糖(Zero)\"且\"加珍珠(Pearls)\"才喝\ndata = pd.DataFrame({\n    'Sugar':   ['Full', 'Zero', 'Full', 'Zero', 'Half', 'Zero'],\n    'Topping': ['Pearls', 'None', 'None', 'Pearls', 'Pearls', 'Pudding'],\n    'Drink':   [0, 0, 0, 1, 0, 1]  # 1=喝, 0=不喝 (假设只要是无糖且有小料就喝)\n})\n\n# 2. 数据预处理：把文字变成数字 (Mapping)\n# 甜度: Full=0, Zero=1, Half=2\n# 小料: Pearls=0, None=1, Pudding=2\ndata['Sugar_Code'] = data['Sugar'].map({'Full': 0, 'Zero': 1, 'Half': 2})\ndata['Topping_Code'] = data['Topping'].map({'Pearls': 0, 'None': 1, 'Pudding': 2})\n\nfeatures = ['Sugar_Code', 'Topping_Code']\nX = data[features]\nY = data['Drink']\n\n# 3. 训练模型\n# criterion='entropy' 表示我们使用“熵”来作为分裂标准\nclf = tree.DecisionTreeClassifier(criterion='entropy')\nclf = clf.fit(X, Y)\n\nprint(\"🤖 奶茶鉴定模型训练完毕！\")\n</code></pre>\n<h2 id=\"2-可视化这棵树\">2. 可视化这棵树</h2>\n<p>让我们看看机器脑子里想的图长什么样。</p>\n<pre><code class=\"language-python\"># 4. 画出决策树\nplt.figure(figsize=(10,6))\ntree.plot_tree(clf, \n               feature_names=['Sugar', 'Topping'],  \n               class_names=['Pass', 'Drink'], # Pass=不喝, Drink=喝\n               filled=True, # 颜色越深代表机器越确信\n               rounded=True)\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202602/83005-20260207080350764-430638444.png\" /></p>\n<h2 id=\"3-预测新数据\">3. 预测新数据</h2>\n<p>这时候，老板推出了一款新品：无糖 + 珍珠。你要不要尝尝？</p>\n<ul>\n<li>无糖 = 1</li>\n<li>珍珠 = 0</li>\n</ul>\n<pre><code class=\"language-python\"># 预测 [Sugar=1, Topping=0]\nnew_tea = [[1, 0]]\nprediction = clf.predict(new_tea)\n\nif prediction[0] == 1:\n    print(\"决策结果：买它！🧋😋\")\nelse:\n    print(\"决策结果：哒咩！❌\")\n\n## 运行结果：\n'''\n决策结果：买它！🧋😋\n'''\n</code></pre>\n<h1 id=\"-总结\">🚀 总结</h1>\n<p>今天我们通过一杯奶茶学习了：</p>\n<ol>\n<li><strong>决策树</strong>就是一套帮你做选择的“流程图”。</li>\n<li>机器利用<strong>熵</strong>（乱不乱）和<strong>信息增益</strong>（变干净了吗）来寻找最佳的筛选条件。</li>\n<li>用 <code>scikit-learn</code> 几行代码就能搞定。</li>\n</ol>\n<p>机器学习其实离生活很近。希望这棵“树”能帮你不仅选对模型，还能选对最适合你的那杯下午茶！</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-07 08:06</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wang_yb\">wang_yb</a>&nbsp;\n阅读(<span id=\"post_view_count\">17</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "ArcGIS授权管理器断网后自动停止",
      "link": "https://www.cnblogs.com/leaguecn/p/19585000",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/leaguecn/p/19585000\" id=\"cb_post_title_url\" title=\"发布于 2026-02-06 16:07\">\n    <span>ArcGIS授权管理器断网后自动停止</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"问题的由来\">问题的由来</h2>\n<p>系统重装win10 22h2，重新安装ArcGIS10.2.2版本，断网启动<strong>许可服务器管理员（LicenseManager）</strong> 的时候无法启动，联网时该软件自动启动了，断网时又自动停止了。</p>\n<h3 id=\"排查\">排查</h3>\n<p>查看lmgrd9.log没啥问题，-&gt;<strong>授权</strong>-&gt;<strong>机器ID</strong>，得到以下的异常标识。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1410060/202602/1410060-20260206160653610-505996147.png\" /></p>\n<ul>\n<li>异常的机器ID</li>\n</ul>\n<pre><code>下面列出了此计算机的主机标识符:\n\nMAC 地址: xxxxxxxxx\n主机名: DESKTOP-7E9QMGD\nIP 地址: ::1\n域: DESKTOP-7E9QMGD\nUMN 2: xxxxxxxxxxxxxxxxxxxxxxx\n</code></pre>\n<p>重新连接WIFI后，查看到正常的表示：</p>\n<ul>\n<li>正常的机器ID</li>\n</ul>\n<pre><code>下面列出了此计算机的主机标识符:\n\nMAC 地址: xxxxxxxxx\n主机名: DESKTOP-7E9QMGD\nIP 地址: 192.168.9.56\n域: DESKTOP-7E9QMGD\nUMN 2: xxxxxxxxxxxxxxxxxxxxxxx\n</code></pre>\n<h2 id=\"甄别与修复\">甄别与修复</h2>\n<h3 id=\"可能出现的异常及尝试\">可能出现的异常及尝试</h3>\n<ul>\n<li>首先排查了Hosts文件，不存在localhost被解析到::1这个ipv6中内容</li>\n<li>调整ipv4和ipv6顺序，使断网情况下有限回环到127.0.0.1，使得ip有可用值。调整后，许可服务器管理员断网状态获取的IP依旧是::1回环地址</li>\n<li>自行组建局域网，使得有IP地址。</li>\n</ul>\n<p>使用大模型进行检索：</p>\n<pre><code>断网后ArcGIS License Manager获取IP时出现以下的log：下面列出了此计算机的主机标识符:\n\nMAC 地址: xxxxxxxxx\n主机名: DESKTOP-7E9QMGD\nIP 地址: ::1\n域: DESKTOP-7E9QMGD\nUMN 2: xxxxxxxxxxxxxxxxxxxxxxx\n\n</code></pre>\n<ul>\n<li>简单说：断网后，你的电脑没有真实的物理网络 IP，License Manager 只能检测到系统默认的本地回环地址 ::1，这会导致许可验证失败（因为许可文件绑定的是物理网卡的真实 IP/MAC）。</li>\n</ul>\n<p><strong>断网时出现该问题的核心原因</strong></p>\n<ul>\n<li>ArcGIS License Manager 验证许可时，会优先读取物理网卡的真实 IP 地址（如 192.168.1.100），但断网后：</li>\n</ul>\n<ol>\n<li>物理网卡（以太网、WiFi）处于「未连接」状态，系统不会分配真实 IP；</li>\n<li>系统会默认使用「回环适配器」的 IP（::1 或 127.0.0.1）作为本机唯一可用 IP；</li>\n<li>许可文件中绑定的是你联网时的物理网卡 IP/MAC，与断网时的回环地址不匹配，导致验证失败。</li>\n</ol>\n<p><strong>解决方案：断网时让 License Manager 读取到「虚拟 IP」</strong>*<br />\n要解决这个问题，核心是给电脑添加一个始终存在的「虚拟网卡」，让 License Manager 无论是否断网，都能读取到固定的真实 IP（而非回环地址）。</p>\n<h3 id=\"有效的解决办法\">有效的解决办法</h3>\n<ul>\n<li>方法一：安装「Microsoft 环回适配器」</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1410060/202602/1410060-20260206160628370-802218261.png\" /></p>\n<ol>\n<li>这是 Windows 自带的虚拟网卡工具，安装后会生成一个虚拟物理网卡，断网时也能分配固定 IP，完美适配 ArcGIS License Manager。</li>\n<li>操作步骤（Windows 10/11 通用）：</li>\n<li>打开「设备管理器」：按下 Win+X，选择「设备管理器」；</li>\n<li>添加过时硬件：点击设备管理器顶部的「操作」→「添加过时硬件」；</li>\n<li>启动硬件安装向导：</li>\n<li>选择「下一步」→ 选择「安装我手动从列表选择的硬件（高级）」→「下一步」；</li>\n<li>下拉列表找到「网络适配器」→「下一步」；</li>\n<li>选择环回适配器：</li>\n<li>左侧厂商选择「Microsoft」，右侧型号选择「Microsoft KM-TEST 环回适配器」→「下一步」；</li>\n<li>继续点击「下一步」，完成安装（等待几秒，系统会自动配置）；</li>\n<li>给虚拟网卡分配固定 IP：</li>\n<li>打开「控制面板→网络和共享中心→更改适配器设置」；</li>\n<li>找到刚安装的「以太网 2」（名称可能不同，带「环回」标识），右键「属性」；</li>\n<li>双击「Internet 协议版本 4 (TCP/IPv4)」；</li>\n<li>选择「使用下面的 IP 地址」，输入固定 IP（如 192.168.100.100），子网掩码填 255.255.255.0，网关留空；</li>\n<li>点击「确定」保存；</li>\n<li>重启 ArcGIS License Manager 服务：</li>\n<li>按下 Win+R，输入 services.msc 打开服务列表；</li>\n<li>找到「ArcGIS License Manager」，右键「重启」；</li>\n<li>验证效果：重新打开 License Server Administrator，查看主机标识符，IP 地址会显示为你设置的 192.168.100.100（而非 ::1），许可验证即可恢复正常。</li>\n</ol>\n<ul>\n<li>方法二：临时启用「虚拟 WiFi / 热点」<br />\n断网状态下，无法通过[热点]图标、按钮开启热点，需要使用powershell命令，以管理员身份开启powershell命令行，键入：</li>\n</ul>\n<pre><code class=\"language-PS\"># 注册热点配置\n$connectionProfile = [Windows.Networking.Connectivity.NetworkInformation,Windows.Networking.Connectivity,ContentType=WindowsRuntime]::GetInternetConnectionProfile()\n$tetheringManager = [Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager,Windows.Networking.NetworkOperators,ContentType=WindowsRuntime]::CreateFromConnectionProfile($connectionProfile)\n\n# 启动热点\n$tetheringManager.StartTetheringAsync()\n\n# 停止热点\n$tetheringManager.StopTetheringAsync()\n</code></pre>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-06 16:07</span>&nbsp;\n<a href=\"https://www.cnblogs.com/leaguecn\">leaguecn</a>&nbsp;\n阅读(<span id=\"post_view_count\">69</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Windows + AMD 显卡，终于能用 PyTorch 炼丹了",
      "link": "https://www.cnblogs.com/deali/p/19584890",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/deali/p/19584890\" id=\"cb_post_title_url\" title=\"发布于 2026-02-06 15:53\">\n    <span>Windows + AMD 显卡，终于能用 PyTorch 炼丹了</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>上一篇文章里，我开始折腾在 Windows11 上编译 ROCm 版的 PyTorch，虽然折腾失败了，但积累了一些经验。</p>\n<p>这不第二天就编译成功了。</p>\n<p><img alt=\"\" src=\"https://blog.deali.cn/media/blog/c4c248b3bf4132cd/77f0fcbc86478c7e.jpg\" /></p>\n<h2 id=\"编译产物\">编译产物</h2>\n<p>爽啊！</p>\n<pre><code class=\"language-bash\">-a---            2026/1/5    15:58      151148776 torch-2.9.1+rocm7.11.0a20260104-cp312-cp312-win_amd64.whl\n-a---            2026/1/5    15:59         514989 torchaudio-2.9.0+rocm7.11.0a20260104-cp312-cp312-win_amd64.whl\n-a---            2026/1/5    16:01        1247290 torchvision-0.24.0+rocm7.11.0a20260104-cp312-cp312-win_amd64.whl\n</code></pre>\n<p>Windows + AMD + ROCm + PyTorch，</p>\n<p>懂不懂这些词凑在一起的含金量啊！！😄</p>\n<h2 id=\"要点\">要点</h2>\n<p>总结下来这次编译功能的要点就俩。</p>\n<h3 id=\"使用官方版的-rocm\">使用官方版的 ROCm</h3>\n<p>之前因为网上查到的资料都说官方还没推出 gfx103x 的 ROCm，所以我安装了一个第三方预构建好的版本，可能是太老了还是咋的，编译 PyTorch 时老是失败。</p>\n<p>这次我使用了这个命令安装：</p>\n<pre><code class=\"language-bash\">pip install --index-url https://rocm.nightlies.amd.com/v2-staging/gfx103X-dgpu/ --pre rocm[libraries,devel]\n</code></pre>\n<p>你可以在这些位置尝试找到对应的 ROCm 软件包：</p>\n<ul>\n<li><a href=\"https://rocm.nightlies.amd.com/v2-staging/\" rel=\"noopener nofollow\" target=\"_blank\">https://rocm.nightlies.amd.com/v2-staging/</a></li>\n<li><a href=\"https://rocm.nightlies.amd.com/v2/\" rel=\"noopener nofollow\" target=\"_blank\">https://rocm.nightlies.amd.com/v2/</a></li>\n<li><a href=\"https://rocm.devreleases.amd.com/v2\" rel=\"noopener nofollow\" target=\"_blank\">https://rocm.devreleases.amd.com/v2</a></li>\n<li><a href=\"https://rocm.devreleases.amd.com/v2-staging\" rel=\"noopener nofollow\" target=\"_blank\">https://rocm.devreleases.amd.com/v2-staging</a></li>\n</ul>\n<p>别迷信第三方包，能用官方的就用官方的，没有就自己编译 ROCm，很幸运我这个卡有官方的 ROCm 包。</p>\n<h3 id=\"使用旧版本-pytorch\">使用旧版本 PyTorch</h3>\n<p>这一点上篇文章也说了，最新版可能不行，我在网上看有人编译 2.10 版本成功了。</p>\n<p>其实之前折腾的时候已经隐约感觉到了，PyTorch 版本太新，在 Windows + ROCm 这条路径上，更容易踩坑。</p>\n<p>网上已经有人确认：</p>\n<ul>\n<li>2.10：有人成功</li>\n<li>2.11：存在各种不确定性</li>\n</ul>\n<p>这次我直接选了更保守的方案：<strong>PyTorch 2.9.1</strong></p>\n<p>事实证明，这个选择是对的。</p>\n<p>至于 2.11 行不行？</p>\n<p>以后有精力再继续折腾，现在先享受成果。</p>\n<h2 id=\"安装-wheel\">安装 wheel</h2>\n<p>既然编译好了，那就可以安装试用一下。</p>\n<p>按顺序安装这三个文件（注意：torch 必须最先安装）</p>\n<pre><code class=\"language-bash\">pip install .\\torch-2.9.1+rocm7.11.0a20260104-cp312-cp312-win_amd64.whl\npip install .\\torchvision-0.24.0+rocm7.11.0a20260104-cp312-cp312-win_amd64.whl\npip install .\\torchaudio-2.9.0+rocm7.11.0a20260104-cp312-cp312-win_amd64.whl\n</code></pre>\n<p><strong>Windows + AMD 显卡，炼丹通道已打通。</strong></p>\n<h2 id=\"下一步做啥\">下一步做啥？</h2>\n<p>显卡加速能用了，那能做的事情就很多了。</p>\n<p>深度学习跑起来，AI画图玩起来~</p>\n<p>下一步我想先试试：</p>\n<ul>\n<li>一些简单的深度学习模型训练任务</li>\n<li>把 AI 画图重新玩起来</li>\n<li>重点试试 Z-Image : <a href=\"https://huggingface.co/Comfy-Org/z_image_turbo\" rel=\"noopener nofollow\" target=\"_blank\">https://huggingface.co/Comfy-Org/z_image_turbo</a></li>\n</ul>\n<p>这个系列后续还有很多值得记录分享的，欢迎继续关注。</p>\n\n\n</div>\n<div id=\"MySignature\">\n    微信公众号：「程序设计实验室」\n专注于互联网热门新技术探索与团队敏捷开发实践，包括架构设计、机器学习与数据分析算法、移动端开发、Linux、Web前后端开发等，欢迎一起探讨技术，分享学习实践经验。\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-06 15:53</span>&nbsp;\n<a href=\"https://www.cnblogs.com/deali\">程序设计实验室</a>&nbsp;\n阅读(<span id=\"post_view_count\">222</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "从零开始学Flink：Flink SQL 极简入门",
      "link": "https://www.cnblogs.com/daimajiangxin/p/19584653",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/daimajiangxin/p/19584653\" id=\"cb_post_title_url\" title=\"发布于 2026-02-06 15:16\">\n    <span>从零开始学Flink：Flink SQL 极简入门</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"从零开始学Flink：Flink SQL 极简入门\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3365149/202602/3365149-20260206151553657-54750339.png\" />\n        无需Java/Scala代码！本文基于Flink 1.20.1版本，手把手教你在WSL2 Ubuntu环境下搭建开发环境，使用SQL Client体验实时流计算的魅力，轻松跑通第一个数据流任务。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>Flink SQL 是 Apache Flink 的核心模块之一，它让开发者可以使用标准的 SQL 语法来编写流处理和批处理作业。对于不想深究 Java/Scala 复杂 API 的“小白”来说，Flink SQL 是进入实时计算领域的最佳敲门砖。</p>\n<p>本文将基于 <strong>Flink 1.20.1</strong> 版本，手把手教你在 WSL2 (Ubuntu) 环境下搭建环境，并运行你的第一个 Flink SQL 任务。</p>\n<h2 id=\"一为什么选择-flink-sql\">一、为什么选择 Flink SQL？</h2>\n<ol>\n<li><strong>低门槛</strong>：会写 SQL 就能开发实时任务。</li>\n<li><strong>统一性</strong>：批流一体，同一套 SQL 既可以跑历史数据（批），也可以跑实时数据（流）。</li>\n<li><strong>生态丰富</strong>：内置了大量的 Connector（连接器），轻松连接 Kafka、MySQL、Hive 等主流组件。</li>\n</ol>\n<p><img alt=\"Flink SQL 架构图\" class=\"lazyload\" /><br />\n<em>(图：Flink SQL 架构示意图，展示 SQL 解析、优化到执行的过程)</em></p>\n<h2 id=\"二环境准备-wsl2-ubuntu\">二、环境准备 (WSL2 Ubuntu)</h2>\n<p>本教程演示环境为 Windows 下的 WSL2 (Ubuntu 20.04/22.04)，这是目前 Windows 用户体验 Linux 开发环境的最佳姿势。<br />\n参考以前些的文章<a href=\"https://mp.weixin.qq.com/s/2_d434kpSeKrSh-krRgvsQ\" rel=\"noopener nofollow\" target=\"_blank\">从零开始学Flink：揭开实时计算的神秘面纱</a>，搭建好 Flink 环境。</p>\n<h2 id=\"三体验-flink-sql-client\">三、体验 Flink SQL Client</h2>\n<p>Flink 提供了一个交互式的命令行工具：<strong>SQL Client</strong>。它允许你直接在终端编写和提交 SQL 任务。</p>\n<h3 id=\"1-启动-sql-client\">1. 启动 SQL Client</h3>\n<p>如果没有启动Flink集群,则先启动flink集群:</p>\n<pre><code class=\"language-bash\">./bin/start-cluster.sh\n</code></pre>\n<p>,然后在 Flink 目录下执行：</p>\n<pre><code class=\"language-bash\">./bin/sql-client.sh\n</code></pre>\n<p>你将看到那只著名的松鼠 LOGO：</p>\n<p><img alt=\"SQLClient启动界面\" class=\"lazyload\" /><br />\n<em>(图：SQL Client 启动欢迎界面)</em></p>\n<h3 id=\"2-hello-world数据生成与打印\">2. Hello World：数据生成与打印</h3>\n<p>我们不依赖任何外部组件（如 Kafka），直接使用 Flink 内置的 <code>datagen</code> 连接器生成模拟数据，并用 <code>print</code> 连接器打印结果。</p>\n<p><strong>第一步：创建源表 (Source Table)</strong></p>\n<p>复制以下 SQL 到 SQL Client 中执行：</p>\n<pre><code class=\"language-sql\">CREATE TABLE source_table (\n    id INT,\n    name STRING,\n    ts TIMESTAMP(3),\n    WATERMARK FOR ts AS ts - INTERVAL '5' SECOND\n) WITH (\n    'connector' = 'datagen',       -- 使用数据生成器\n    'rows-per-second' = '1',       -- 每秒生成1条数据\n    'fields.id.kind' = 'sequence', -- id 字段为序列\n    'fields.id.start' = '1',       -- id 从1开始\n    'fields.id.end' = '100'        -- id 到100结束\n);\n</code></pre>\n<p>执行后显示 <code>[INFO] Execute statement succeed.</code>。</p>\n<p><strong>第二步：创建结果表 (Sink Table)</strong></p>\n<pre><code class=\"language-sql\">CREATE TABLE print_table (\n    id INT,\n    name STRING,\n    ts TIMESTAMP(3)\n) WITH (\n    'connector' = 'print'          -- 使用控制台打印连接器\n);\n</code></pre>\n<p><strong>第三步：提交任务</strong></p>\n<p>将源表的数据插入到结果表：</p>\n<pre><code class=\"language-sql\">INSERT INTO print_table SELECT * FROM source_table;\n</code></pre>\n<p>此时，SQL Client 会提交一个异步任务到集群。你会看到类似 Job ID 的输出。</p>\n<h3 id=\"3-查看运行结果\">3. 查看运行结果</h3>\n<p>由于我们使用的是 <code>print</code> 连接器，在 Standalone 模式下，输出会打印到 TaskManager 的日志文件中。</p>\n<p>打开一个新的 WSL2 终端窗口，进入 Flink 目录查看日志：</p>\n<pre><code class=\"language-bash\"># 进入 log 目录\ncd log\n\n# 查看最新的 .out 文件 (文件名包含 taskexecutor)\ntail -f flink-*-taskexecutor-*.out\n</code></pre>\n<p>你应该能看到屏幕上不断跳动的数据流：</p>\n<p><img alt=\"运行结果日志截图位置\" class=\"lazyload\" /><br />\n<em>(图：终端 tail -f 命令看到的实时数据输出)</em></p>\n<h2 id=\"四常用命令速查\">四、常用命令速查</h2>\n<p>在 SQL Client 中，你可以使用以下命令：</p>\n<ul>\n<li><code>HELP</code>: 查看帮助。</li>\n<li><code>SHOW TABLES</code>: 查看当前创建的表。</li>\n<li><code>SHOW JOBS</code>: 查看运行中的作业。</li>\n<li><code>DESCRIBE table_name</code>: 查看表结构。</li>\n<li><code>QUIT</code>: 退出 SQL Client。</li>\n</ul>\n<h2 id=\"五总结\">五、总结</h2>\n<p>恭喜你！你已经成功运行了人生中第一个 Flink SQL 任务。</p>\n<p>通过本文，我们完成了：</p>\n<ol>\n<li>WSL2 下 Java 和 Flink 1.20.1 的安装。</li>\n<li>启动了 Flink 本地集群。</li>\n<li>使用 SQL Client 创建了 Source 和 Sink 表，并跑通了数据流。</li>\n</ol>\n<p>下一篇，我们将深入讲解 Flink SQL 中的<strong>窗口（Window）</strong>操作，看看如何处理“过去5分钟的订单总额”这类经典需求。</p>\n<hr />\n<p><strong>参考资料</strong>：</p>\n<ul>\n<li><a href=\"https://nightlies.apache.org/flink/flink-docs-release-1.20/\" rel=\"noopener nofollow\" target=\"_blank\">Flink 官方文档</a></li>\n<li><a href=\"http://blog.daimajiangxin.com.cn/article/bigdata/flink-10.html\" rel=\"noopener nofollow\" target=\"_blank\">原文来自</a></li>\n</ul>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-06 15:16</span>&nbsp;\n<a href=\"https://www.cnblogs.com/daimajiangxin\">代码匠心</a>&nbsp;\n阅读(<span id=\"post_view_count\">113</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "从回调函数到Promise",
      "link": "https://www.cnblogs.com/LFeather/p/19583059",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/LFeather/p/19583059\" id=\"cb_post_title_url\" title=\"发布于 2026-02-06 10:47\">\n    <span>从回调函数到Promise</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>最近在面试中遇到了很多关于 <code>Promise</code> 的问题，因为以前的业务在请求方面并不复杂，多数时候都是在用 <code>async/await</code>，对 <code>Promise</code> 的理解还是有所欠缺，最近重新学习了一下 <code>Promise</code>，尽量避免写成API式的文章，主要还是结合自己的一些理解和思考来整理一下。</p>\n<h2 id=\"为什么要使用-promise\">为什么要使用 Promise</h2>\n<p>众所周知，JavaScript 的主线程是单线程执行的，所有的同步代码都是在一个线程中执行的，当遇到一些耗时操作时（比如网络请求、文件读取等），如果采用同步的方式去处理这些操作，就会阻塞主线程，导致页面卡顿，用户体验变差。为了解决这个问题，我们发明了异步编程，最早的异步编程方式是回调函数（Callback），我们先看一个简单的例子：</p>\n<pre><code class=\"language-javascript\">function add(getX, getY, finalCallback) {\n  var x, y;\n  getX(function (xVal) {\n    x = xVal;\n    if (y !== undefined) {\n      finalCallback(x + y);\n    }\n  });\n\n  getY(function (yVal) {\n    y = yVal;\n    if (x !== undefined) {\n      finalCallback(x + y);\n    }\n  });\n}\n\nfunction fetchX(xCallback) {\n  setTimeout(function () {\n    xCallback(2);\n  }, 1000);\n}\n\nfunction fetchY(yCallback) {\n  setTimeout(function () {\n    yCallback(3);\n  }, 1000);\n}\n\nadd(fetchX, fetchY, function (sum) {\n  console.log(\"Sum is: \" + sum);\n});\n</code></pre>\n<p><code>fetchX</code> 和 <code>fetchY</code> 是两个异步函数，分别模拟从服务器获取数据的过程，我们要进行 <code>x+y</code> 的计算，如果它们中的任何一个还没有准备好，就等待两者都准备好。我们逐步拆解这个过程：</p>\n<ol>\n<li>\n<p>调用 <code>add</code> 函数，传入 <code>fetchX</code>、<code>fetchY</code> 和回调函数。</p>\n</li>\n<li>\n<p>在 <code>add</code> 函数内部，调用 <code>getX</code>（即 <code>fetchX</code>），传入一个回调函数。</p>\n</li>\n</ol>\n<pre><code class=\"language-JavaScript\">function (xVal) {\n  x = xVal;\n  if (y !== undefined) {\n    finalCallback(x + y);\n  }\n}\n</code></pre>\n<ol start=\"3\">\n<li>\n<p><code>fetchX</code> 开始执行，经过1秒钟后，调用传入的回调函数（<code>xCallback</code>），将 <code>2</code> 作为参数传递进去。</p>\n</li>\n<li>\n<p>回调函数执行，<code>x</code> 被赋值为 <code>2</code>，然后检查 <code>y</code> 是否已经准备好（即 <code>y</code> 是否不为 <code>undefined</code>）。此时 <code>y</code> 还没有准备好，所以不会调用最终的 <code>finalCallback</code>。</p>\n</li>\n<li>\n<p>同样的过程发生在 <code>getY</code>（即 <code>fetchY</code>）上，经过1秒钟后，<code>y</code> 被赋值为 <code>3</code>，然后检查 <code>x</code> 是否已经准备好。此时 <code>x</code> 已经准备好了（<code>x=2</code>），所以调用 <code>finalCallback</code>，计算出最终的结果 <code>5</code>，并打印出来。</p>\n</li>\n</ol>\n<p>从这个例子中，我们是否能看出使用回调函数来处理异步操作存在一些问题？首先，也许这个思路很巧妙，但是代码很复杂，我在逐步拆解前很难直接理解这个过程。其次，如果有更多的异步操作需要处理，代码会变得更加复杂，难以维护，这就是著名的“回调地狱”问题。</p>\n<p>回想我刚上班时，使用的还是 jQuery，jQuery 的 Ajax 请求就是基于回调函数的，代码如下：</p>\n<pre><code class=\"language-javascript\">$.ajax({\n  url: \"https://api.example.com/data\",\n  method: \"GET\",\n  success: function (data) {\n    console.log(\"Data received:\", data);\n    $.ajax({\n      url: \"https://api.example.com/more-data\",\n      method: \"GET\",\n      success: function (moreData) {\n        console.log(\"More data received:\", moreData);\n        // 继续嵌套更多的回调...\n      },\n      error: function (err) {\n        console.error(\"Error fetching more data:\", err);\n      },\n    });\n  },\n  error: function (err) {\n    console.error(\"Error fetching data:\", err);\n  },\n});\n</code></pre>\n<p>显然，随着嵌套层级的增加，代码变得越来越难以阅读和维护，而且错误处理也变得复杂。所以回收这一节的标题，因为用回调函数来处理异步操作确实存在一些问题：</p>\n<ol>\n<li>可读性差：嵌套的回调函数使代码难以理解。</li>\n<li>错误处理复杂：每个回调函数都需要单独处理错误，导致代码冗长。</li>\n<li>控制流困难：管理多个异步操作的顺序和依赖关系变得复杂。</li>\n</ol>\n<p>等讲完 <code>Promise</code> 之后我们看下 <code>Promise</code> 是否能解决这些问题。</p>\n<h2 id=\"promise\">Promise</h2>\n<h3 id=\"是什么\">是什么</h3>\n<p>通俗的说，我们可以把 <code>Promise</code> 理解成一个异步操作的代理，它是异步操作的返回值，原本只有同步操作才能有返回值，异步操作只能使用我们上面所说的回调函数嵌套来获得结果。</p>\n<blockquote>\n<p>异步方法不会立即返回最终值，而是返回一个 <code>Promise</code>，以便在将来的某个时间点提供该值。</p>\n</blockquote>\n<p><code>Promise</code> 的基本用法应该都很熟悉了，我们创建一个 <code>Promise</code> 的例子：</p>\n<pre><code class=\"language-javascript\">// ES6 原生 Promise\nconst asyncTask = new Promise((resolve, reject) =&gt; {\n  // 模拟异步操作（比如接口请求、文件读取）\n  setTimeout(() =&gt; {\n    const success = true;\n    if (success) {\n      resolve(\"操作成功\"); // 成功回调\n    } else {\n      reject(\"操作失败\"); // 失败回调\n    }\n  }, 1000);\n});\n\n// 调用 Promise\nasyncTask\n  .then((result) =&gt; console.log(result)) // 输出：操作成功\n  .catch((error) =&gt; console.log(error))\n  .finally(() =&gt; console.log(\"操作完成\"));\n</code></pre>\n<p>可以看到，我们把异步操作 <code>setTimeout</code> 包装在 <code>Promise</code> 中，然后通过 <code>then</code>、<code>catch</code> 和 <code>finally</code> 来处理结果和错误，<code>setTimeout</code> 可以是任意异步操作，比如网络请求、文件读取等。</p>\n<p>隐藏在这些 API 之下的还有一个参数，一个 <code>Promise</code> 必然处于以下三种状态之一：</p>\n<ul>\n<li><strong><code>Pending</code>（进行中）</strong>：初始状态，既不是成功，也不是失败。</li>\n<li><strong><code>Fulfilled</code>（已成功）</strong>：操作成功完成。</li>\n<li><strong><code>Rejected</code>（已失败）</strong>：操作失败。</li>\n</ul>\n<p>这一部分内容可以参考 MDN 的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\" rel=\"noopener nofollow\" target=\"_blank\">Promise - JavaScript | MDN</a>，讲得很清楚。</p>\n<p><img alt=\"\" src=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/promises.png\" /></p>\n<p>参考这张图，<code>Pending</code> 状态通向两个结果：<code>Fulfilled</code> 和 <code>Rejected</code>，这个过程是单向不可逆的，一旦状态改变，就会永久保持该状态。当任意一种情况发生时，<code>then</code> 方法注册的回调函数就会被调用，即不再处于\"待定\"（<code>Pending</code>）状态，称之为\"已敲定\"（<code>Settled</code>）。</p>\n<h4 id=\"rejected\">Rejected</h4>\n<p>我们先看 <code>Rejected</code> 的情况：</p>\n<pre><code class=\"language-JavaScript\">// catch\nconst failedTask = new Promise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; {\n    reject(\"操作失败\"); // 失败回调\n  }, 1000);\n});\n\nfailedTask\n  .then((result) =&gt; console.log(result))\n  .catch((error) =&gt; console.log(error)) // 输出：操作失败\n  .finally(() =&gt; console.log(\"操作完成\"));\n\n// then 第二个参数\nconst anotherFailedTask = new Promise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; {\n    reject(\"操作失败\"); // 失败回调\n  }, 1000);\n});\n\nanotherFailedTask\n  .then(\n    (result) =&gt; console.log(\"成功：\" + result),\n    (error) =&gt; console.log(\"失败：\" + error),\n  ) // 输出：操作失败\n  .finally(() =&gt; console.log(\"操作完成\"));\n</code></pre>\n<p>有两种方式可以捕获 <code>Promise</code> 的拒绝状态：一种是使用 <code>catch</code> 方法，另一种是将错误处理函数作为 <code>then</code> 方法的第二个参数传入。两种方式都能有效地处理 <code>Promise</code> 的拒绝状态，如果不进行错误处理，未捕获的拒绝会导致未处理的 <code>Promise</code> 拒绝警告。更详细的说明我们后面再聊，这里只看用法。</p>\n<h4 id=\"fulfilled\">Fulfilled</h4>\n<p>在构造器 <code>Promise(..)</code> 中，我们通常用两个回调函数来表示成功和失败的情况，这两个函数的命名并不固定，通常我们使用 <code>resolve</code> 和 <code>reject</code>，<code>reject</code> 很清楚地表示失败，并且代表 <code>Promise</code> 进入 <code>Rejected</code> 状态，而成功的回调函数 <code>resolve</code>（决议），它表示 <code>Promise</code> 进入 <code>Fulfilled</code> 状态，这里用 ES6 规范中的回调命名来说明：</p>\n<pre><code class=\"language-JavaScript\">myPromise.then((result) =&gt; onFulfilled, onRejected)\n</code></pre>\n<h4 id=\"链式调用\">链式调用</h4>\n<p>在提到 <code>Promise</code> 时，链式调用是一个非常重要的概念，上面的例子中，我们看到 <code>Promise</code> 对象可以调用 <code>then</code> 方法，而 <code>then</code> 方法又可以调用 <code>catch</code> 和 <code>finally</code> 方法，因为 <code>then</code> 方法返回的仍然是一个 <code>Promise</code> 对象，而 <code>catch</code> 和 <code>finally</code> 方法内在内部调用的也是 <code>then</code> 方法，这样它们就可以链式调用。</p>\n<pre><code class=\"language-JavaScript\">// Promise.resolve这种写法我们之后讨论\nPromise.resolve('第一步结果')\n  .then(res =&gt; {\n    console.log(res); // 打印：第一步结果\n    // return 普通值 → 新 Promise 状态为 fulfilled\n    return '第二步结果';\n  })\n  .then(res =&gt; {\n    console.log(res); // 打印：第二步结果\n    // return 新 Promise → 新 Promise 跟随该 Promise 的状态\n    return Promise.resolve('第三步结果');\n  })\n  .then(res =&gt; {\n    console.log(res); // 打印：第三步结果\n  });\n</code></pre>\n<p>通过例子可以看到，链式调用可以将多个异步操作串联起来，每个 <code>then</code> 方法处理上一个 <code>Promise</code> 的结果，这就解决了我们最开始提到的回调地狱问题，使代码更加清晰和易于维护。</p>\n<p>这个例子中还有一个细节，在 <code>then</code> 方法中通过 <code>return</code> 来传递值，当使用 <code>return</code> 返回一个普通值时，新的 <code>Promise</code> 会进入 <code>Fulfilled</code> 状态，也可以返回一个新的 <code>Promise</code> 对象，这样新的 <code>Promise</code> 会跟随该 <code>Promise</code> 的状态。值得注意的是，如果返回的是一个 <code>thenable</code> 对象（具有 <code>then</code> 方法的对象），<code>Promise</code> 也会等待该对象解决，这使得 <code>Promise</code> 可以与其他实现了类 <code>Promise</code> 接口的库进行互操作。</p>\n<p>大体上我们了解了 <code>Promise</code> 的用法，我们用 <code>Promise</code> 来实现嵌套异步操作：</p>\n<pre><code class=\"language-JavaScript\">function getFirstData() {\n  // 返回一个 Promise，用 setTimeout 模拟异步\n  return new Promise((resolve) =&gt; {\n    setTimeout(() =&gt; {\n      const data = \"第一个异步操作的结果\";\n      console.log(\"Data received:\", data);\n      // 异步成功，传递结果给下一个 .then()\n      resolve(data);\n    }, 1000);\n  });\n}\n\nfunction getSecondData(prevData) {\n  return new Promise((resolve) =&gt; {\n    setTimeout(() =&gt; {\n      const moreData = `第二个异步操作的结果（基于上一步：${prevData}）`;\n      console.log(\"More data received:\", moreData);\n      resolve(moreData); // 可选：继续传递结果给后续链式调用\n    }, 1000);\n  });\n}\n\n// 链式调用\ngetFirstData()\n  .then((data) =&gt; {\n    // 第一个异步成功后，执行第二个异步\n    return getSecondData(data);\n  })\n  .catch((err) =&gt; {\n    // 统一捕获所有异步操作的错误\n    console.error(\"异步操作出错：\", err);\n  });\n</code></pre>\n<h3 id=\"promise-解决了什么问题\">Promise 解决了什么问题</h3>\n<p>通过这个例子可以看到，我们一开始提出的回调函数的三个问题得到了不同程度的解决：</p>\n<ol>\n<li><strong>可读性提升</strong>：通过链式调用，代码结构更加清晰，每个异步操作都在自己的 <code>then</code> 块中处理，避免了嵌套回调的复杂性。</li>\n<li><strong>统一错误处理</strong>：使用 <code>catch</code> 方法可以统一捕获所有异步操作的错误，简化了错误处理逻辑。</li>\n<li><strong>控制流简化</strong>：通过链式调用，可以更容易地管理多个异步操作的顺序和依赖关系，使代码更易于理解。</li>\n</ol>\n<p>这里有点像一种 <code>if</code> 语句的替代写法：</p>\n<pre><code class=\"language-JavaScript\">if (condition1) {\n  // do something\n  if (condition2) {\n    // do something\n    if (condition3) {\n      // do something\n    }\n  }\n}\n\n// 可以改写为：\n\nif(!condition1) return;\n// do something\nif(!condition2) return;\n// do something\nif(!condition3) return;\n// do something\n\n</code></pre>\n<p>换个思路，作用相同，但代码的可读性会变高，不过 <code>Promise</code> 要复杂得多，我没有直接使用一开始的回调函数版本来对比，并非做不到，而是涉及了新的知识点，需要用到 <code>Promise</code> 的一些 API，我打算换一种角度来理解，然后我们再回头看这个对比。</p>\n<h3 id=\"promise-的-api-与原型\">Promise 的 API 与原型</h3>\n<p><code>Promise</code> 是 ES6（ES2015）引入的一种用于处理异步操作的<strong>对象</strong>，最近刚写了一篇关于原型的文章：<a href=\"https://www.cnblogs.com/LFeather/p/19312203\" target=\"_blank\">对于原型、原型链和继承的理解</a>，这里就是想从原型和面向对象的角度来加深一下理解，我们还是用前面的例子，分步拆解：</p>\n<pre><code class=\"language-javascript\">// ES6 原生 Promise\nconst asyncTask = new Promise((resolve, reject) =&gt; {\n  // 模拟异步操作（比如接口请求、文件读取）\n  setTimeout(() =&gt; {\n    const success = true;\n    if (success) {\n      resolve(\"操作成功\"); // 成功回调\n    } else {\n      reject(\"操作失败\"); // 失败回调\n    }\n  }, 1000);\n});\n\n// 调用 Promise\nasyncTask\n  .then((result) =&gt; console.log(result)) // 输出：操作成功\n  .catch((error) =&gt; console.log(error))\n  .finally(() =&gt; console.log(\"操作完成\"));\n</code></pre>\n<h4 id=\"构造函数-promise\">构造函数 Promise()</h4>\n<p>先从核心语句说起， <code>new Promise((resolve, reject) =&gt; { ... })</code> 这里事关两个概念：构造函数和 <code>new</code>。</p>\n<p><code>Promise()</code> 是一个构造器（Constructor）或者说构造函数，用于创建 <code>Promise</code> 对象。</p>\n<p>使用构造函数的形式来创建对象有几个好处：</p>\n<ol>\n<li>\n<p><strong>封装初始化逻辑</strong>：<code>Promise</code> 构造函数内部封装了初始化 <code>Promise</code> 对象所需的逻辑，比如设置初始状态（<code>pending</code>）、设置回调函数（<code>resolve</code> 和 <code>reject</code>）。</p>\n</li>\n<li>\n<p><strong>共享方法</strong>：通过构造函数创建的对象实例可以共享原型上的方法（如 <code>then</code>、<code>catch</code>、<code>finally</code>），避免每个实例都创建一份相同的方法，节省内存。</p>\n</li>\n<li>\n<p><strong>立即执行</strong>：当我们创建一个新的 <code>Promise</code> 实例时，传入的执行器函数（executor function）会立即执行，这使得我们可以在创建 <code>Promise</code> 的同时开始异步操作。</p>\n</li>\n</ol>\n<p>而 <code>new</code> 关键字用于创建一个新的对象实例，并将其原型链接到构造函数的原型对象上，也就是让新创建的对象继承构造函数原型上的方法和属性，结合上面的例子就是说我们创建的 <code>asyncTask</code> 对象会继承 <code>Promise.prototype</code> 上的方法，比如 <code>then</code>、<code>catch</code> 和 <code>finally</code>，这也就是为什么我们可以在 <code>asyncTask</code> 上调用这些方法，以及进行前面所说的链式调用。</p>\n<p>要注意的一点是，执行器函数的返回值对 <code>Promise</code> 的影响有限，在 <code>then</code> 方法中我们通过 <code>return</code> 来传递值，但在执行器函数中 <code>return</code> 语句仅影响控制流程，并不会直接改变 <code>Promise</code> 的状态，<code>Promise</code> 的状态只能通过调用 <code>resolve</code> 或 <code>reject</code> 来改变。</p>\n<pre><code class=\"language-JavaScript\">const myPromise = new Promise((resolve, reject) =&gt; {\n  // 一些异步操作\n  if (/* 操作成功 */) {\n    resolve(\"成功结果\");\n  } else {\n    reject(\"失败原因\");\n  }\n  return \"这个返回值不会影响 Promise 的状态\";\n});\n</code></pre>\n<h4 id=\"入参-resolve-reject-\">入参 (resolve, reject) =&gt;</h4>\n<p>接下来我们看构造函数的入参 <code>(resolve, reject) =&gt; { ... }</code> ，也就是执行器函数（executor function），它会在 <code>Promise</code> 实例创建时立即执行，这个上面说过了。使用 <code>Promise</code> 时，我们不会关注执行器函数，主要是使用这个函数的入参 <code>resolve</code> 和 <code>reject</code> 用来改变 <code>Promise</code> 的状态。</p>\n<pre><code class=\"language-JavaScript\">function executor(resolveFunc, rejectFunc) {\n  // 通常，`executor` 函数用于封装某些接受回调函数作为参数的异步操作，比如上面的 `setTimeout` 函数\n}\n</code></pre>\n<p>当调用 <code>resolve</code> 或 <code>reject</code> 时，<code>Promise</code> 的状态会立即改变，从 <code>pending</code> 变为 <code>fulfilled</code> 或 <code>rejected</code>，然后执行回调函数，这个回调函数就是我们通过 <code>then</code> 方法注册的函数。</p>\n<pre><code class=\"language-JavaScript\">const p = new Promise((resolve) =&gt; {\n  console.log('1. 执行器函数立即执行');\n  resolve('成功');\n  console.log('2. resolve 调用完成（同步）');\n});\n\nconsole.log('3. Promise 创建完成');\n\np.then((value) =&gt; {\n  console.log('5. then 回调执行:', value);\n});\n\nconsole.log('4. then 方法调用完成');\n\n// 输出顺序：\n// 1. 执行器函数立即执行\n// 2. resolve 调用完成（同步）\n// 3. Promise 创建完成\n// 4. then 方法调用完成\n// 5. then 回调执行: 成功\n</code></pre>\n<p>但我们用到 <code>Promise</code> 时主要还是用于异步任务，<code>then</code> 方法是典型的微任务（microtask），如果 <code>then</code> 方法先执行，里面的回调函数会被放入微任务队列，等待当前宏任务执行完毕后再执行。</p>\n<p>对于更细致的执行顺序，之前有写过一篇关于事件循环的文章，刚好是用 <code>Promise</code> 举例，可以参考：<a href=\"https://www.cnblogs.com/LFeather/p/16139014.html\" target=\"_blank\">有关 JavaScript 事件循环的若干疑问探究</a>。</p>\n<p><code>Promise</code> 内部的大致逻辑是这样的：</p>\n<pre><code class=\"language-JavaScript\">// Promise 内部简化实现\nclass MyPromise {\n  constructor(executor) {\n    this.state = 'pending';           // 状态\n    this.value = undefined;           // 结果值\n    this.onFulfilledCallbacks = [];   // ← 存储 then 的成功回调\n    this.onRejectedCallbacks = [];    // ← 存储 then 的失败回调\n\n    const resolve = (value) =&gt; {\n      if (this.state === 'pending') {\n        this.state = 'fulfilled';\n        this.value = value;\n        // ← 关键：遍历回调队列，将所有回调加入微任务\n        this.onFulfilledCallbacks.forEach(callback =&gt; {\n          queueMicrotask(() =&gt; callback(value));\n        });\n      }\n    };\n\n    const reject = (reason) =&gt; {\n      if (this.state === 'pending') {\n        this.state = 'rejected';\n        this.value = reason;\n        this.onRejectedCallbacks.forEach(callback =&gt; {\n          queueMicrotask(() =&gt; callback(reason));\n        });\n      }\n    };\n\n    executor(resolve, reject);\n  }\n\n  then(onFulfilled, onRejected) {\n    // 如果 Promise 还是 pending，就把回调存起来\n    if (this.state === 'pending') {\n      this.onFulfilledCallbacks.push(onFulfilled);  // ← 存储回调\n      this.onRejectedCallbacks.push(onRejected);\n    }\n    // 如果 Promise 已经 fulfilled，立即将回调加入微任务\n    else if (this.state === 'fulfilled') {\n      queueMicrotask(() =&gt; onFulfilled(this.value));\n    }\n    // 如果 Promise 已经 rejected\n    else if (this.state === 'rejected') {\n      queueMicrotask(() =&gt; onRejected(this.value));\n    }\n\n    return new MyPromise(() =&gt; {}); // 简化，实际更复杂\n  }\n}\n</code></pre>\n<p>所以 <code>then</code> 中的回调函数被执行的前提是 <code>resolve</code> 或 <code>reject</code> 被调用并且 <code>then</code> 方法也被调用，这也是 <code>Promise</code> 能处理异步操作的关键。</p>\n<h4 id=\"静态方法\">静态方法</h4>\n<p>简单提一下，静态方法是直接挂载在构造函数上的方法，而不是实例对象上，以前面的例子来说，<code>asyncTask</code> 是 <code>Promise</code> 的一个实例对象，而 <code>Promise.all(..)</code> 和 <code>Promise.resolve(..)</code> 这种则是 <code>Promise</code> 构造函数的一个静态方法。</p>\n<p>基于上面的简单例子，<code>Promise</code> 大体上的用法我们已经了解了，但还有很多 API 没有涉及到，我们可以通过打印 <code>Promise</code> 的原型来查看：</p>\n<pre><code class=\"language-JavaScript\">console.log(Promise.prototype);\n</code></pre>\n<p><img alt=\"\" src=\"https://blog-1252364274.cos.ap-guangzhou.myqcloud.com/20260205173555584.png\" /></p>\n<p>我们可以看到 <code>then</code>、<code>catch</code> 和 <code>finally</code> 方法都在 <code>Promise.prototype</code> 上，这些方法是实例方法，意味着它们可以被任何 <code>Promise</code> 实例调用。</p>\n<p>由于安全机制，直接打印 <code>Promise</code> 本身是看不到原生代码的，我们换一种方式，只需要得到静态方法名就行：</p>\n<pre><code class=\"language-JavaScript\">console.log(Object.getOwnPropertyNames(Promise));\n\n// 输出：['length', 'name', 'prototype', 'all', 'allSettled', 'any', 'race', 'resolve', 'reject', 'withResolvers', 'try']\n</code></pre>\n<p>输出结果中有的熟悉有的不熟悉，因为我之前对 <code>Promise</code> 仅停留在会用的层面，所以有些我甚至是第一次知道，但没关系，通过原型再对照 MDN 文档，逐个学习一下。 <code>length</code>、<code>name</code> 和 <code>prototype</code> 是函数对象的默认属性，我们主要关注其他的静态方法：</p>\n<ol>\n<li><code>Promise.resolve(..)</code> 和 <code>Promise.reject(..)</code></li>\n</ol>\n<p>这两个方法应该是最常见的了，上面的例子中也用到过，<code>reject</code> 比较简单，返回一个拒绝状态的 <code>Promise</code> 对象，入参就是拒绝的原因：</p>\n<pre><code class=\"language-JavaScript\">const promiseReject = Promise.reject(new Error(\"失败原因\"));\npromiseReject.catch((reason) =&gt; {\n  console.log(reason.message);\n  // Expected output: 失败原因\n});\n\n// 或者\nfunction resolved(result) {\n  console.log(\"Resolved\");\n}\n\nfunction rejected(result) {\n  console.log(\"Rejected:\", result);\n}\n\nconst promiseReject2 = Promise.reject(\"失败原因\");\npromiseReject2.then(resolved, rejected);\n</code></pre>\n<p><code>resolve</code> 方法则比较复杂一些，它有两种返回形式：1. 如果入参是一个普通值（非 <code>Promise</code> 对象），则返回一个以该值为结果的已解决（<code>fulfilled</code>）状态的 <code>Promise</code> 对象，这一点与 <code>reject</code> 对应；2. 如果入参是一个 <code>Promise</code> 对象，则返回该 <code>Promise</code> 对象本身。</p>\n<pre><code class=\"language-JavaScript\">// 入参是普通值\nconst promise1 = Promise.resolve(123);\n\npromise1.then((value) =&gt; {\n  console.log(value);\n  // Expected output: 123\n});\n\n// 入参是 Promise 对象\nconst originalPromise = new Promise((resolve) =&gt; {\n  setTimeout(() =&gt; {\n    resolve(\"原始 Promise 结果\");\n  }, 1000);\n});\n\nconst promise2 = Promise.resolve(originalPromise);\npromise2.then((value) =&gt; {\n  console.log(value);\n  // Expected output: 原始 Promise 结果\n});\n</code></pre>\n<ol start=\"2\">\n<li><code>Promise.all(..)</code>、<code>Promise.race(..)</code>、<code>Promise.allSettled(..)</code> 和 <code>Promise.any(..)</code></li>\n</ol>\n<p>这四个我觉得可以放一起介绍，它们都是用于处理多个 <code>Promise</code> 对象的静态方法，入参都是一个可迭代对象（通常是数组），包含多个 <code>Promise</code> 对象，返回一个新的 <code>Promise</code> 对象，其他的区别用一张表格来说明：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Promise.all(..)</code></td>\n<td>全成功才成功，一失败就失败。</td>\n<td>成功时返回一个包含所有结果的数组，失败时返回第一个失败的原因。</td>\n</tr>\n<tr>\n<td><code>Promise.allSettled(..)</code></td>\n<td>等所有完成，无论成败。</td>\n<td>结果是一个包含每个 <code>Promise</code> 结果状态的数组。</td>\n</tr>\n<tr>\n<td><code>Promise.any(..)</code></td>\n<td>一成功就成功，全失败才失败。</td>\n<td>成功时返回第一个成功的结果，失败时返回一个 <code>AggregateError</code>，包含所有失败的原因。</td>\n</tr>\n<tr>\n<td><code>Promise.race(..)</code></td>\n<td>谁先完成（成败均可），就用谁的结果。</td>\n<td>结果是第一个解决或拒绝的 <code>Promise</code> 的结果或原因。</td>\n</tr>\n</tbody>\n</table>\n<p>关于 <code>Promise.all(..)</code> 的应用，我们最开始的回调函数就是一个很好的例子，我们可以用它来重写：</p>\n<pre><code class=\"language-JavaScript\">function fetchX() {\n  return new Promise((resolve) =&gt; {\n    setTimeout(() =&gt; {\n      resolve(2);\n    }, 1000);\n  });\n}\nfunction fetchY() {\n  return new Promise((resolve) =&gt; {\n    setTimeout(() =&gt; {\n      resolve(3);\n    }, 1000);\n  });\n}\n\nfunction add() {\n  return Promise.all([fetchX(), fetchY()]).then(([x, y]) =&gt; x + y);\n}\n\nadd().then((sum) =&gt; {\n  console.log(\"Sum is: \" + sum); // 输出：Sum is: 5\n});\n</code></pre>\n<p>如果有三个异步操作：</p>\n<pre><code class=\"language-JavaScript\">function fetchZ() {\n  return new Promise((resolve) =&gt; {\n    setTimeout(() =&gt; {\n      resolve(4);\n    }, 1000);\n  });\n}\n\nfunction addThree() {\n  return Promise.all([fetchX(), fetchY(), fetchZ()]).then(([x, y, z]) =&gt; x + y + z);\n}\n</code></pre>\n<p>MDN上的 <code>Promise.allSettled(..)</code> 例子：</p>\n<pre><code class=\"language-JavaScript\">Promise.allSettled([\n  Promise.resolve(33),\n  new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(66), 0)),\n  99,\n  Promise.reject(new Error(\"一个错误\")),\n]).then((values) =&gt; console.log(values));\n\n// [\n//   { status: 'fulfilled', value: 33 },\n//   { status: 'fulfilled', value: 66 },\n//   { status: 'fulfilled', value: 99 },\n//   { status: 'rejected', reason: Error: 一个错误 }\n// ]\n</code></pre>\n<p>这里的返回值有些不同，是一个对象数组，每个对象表示对应 <code>Promise</code> 的状态和结果。</p>\n<p><code>Promise.any(..)</code> 的返回值是第一个成功的结果，如果所有 <code>Promise</code> 都失败了，则返回一个 <code>AggregateError</code>，它包含所有失败的原因：</p>\n<pre><code class=\"language-JavaScript\">const promiseA = Promise.reject(\"失败原因 A\");\nconst promiseB = Promise.reject(\"失败原因 B\");\n\nPromise.any([promiseA, promiseB])\n  .then((value) =&gt; {\n    console.log(value);\n  })\n  .catch((error) =&gt; {\n    console.log(error);\n  });\n\n// 输出：AggregateError: All promises were rejected\n</code></pre>\n<p>与其他三个方法不同，<code>Promise.race(..)</code> 返回的 <code>Promise</code> 状态的敲定总是异步的，前面的三种方法入参的 <code>Promise</code> 数组中有一个甚至多个是已经解决（<code>fulfilled</code>）或拒绝（<code>rejected</code>）的 <code>Promise</code> 对象（简单来说，和上面的大部分例子一样，我们传入一个确定的值而不是异步方法），那么 <code>Promise.all(..)</code>、<code>Promise.allSettled(..)</code> 和 <code>Promise.any(..)</code> 会立即返回结果，而 <code>Promise.race(..)</code> 的返回值则是异步的。</p>\n<p>MDN 针对每个方法的返回值都有详细的说明，比如说 <code>Promise.all(..)</code> ，如果传入的参数为空，则它的状态会立即变为 <strong>已解决（<code>fulfilled</code>）</strong> 另外两种返回状态则为 <strong>异步兑现（asynchronously fulfilled）</strong> 和 <strong>异步拒绝（asynchronously rejected）</strong> ，而 <code>Promise.any(..)</code> 则是相反的，如果传入的参数为空，则它的状态会立即变为 <strong>已拒绝（<code>rejected</code>）</strong>，其他情况都是异步的。</p>\n<p>向 <code>Promise.race(..)</code> 传入一个空的可迭代对象会导致返回的 <code>Promise</code> 永远处于挂起状态（<code>pending</code>），因为没有任何 <code>Promise</code> 可以兑现或拒绝。</p>\n<pre><code class=\"language-JavaScript\">const foreverPendingPromise = Promise.race([]);\nconsole.log(foreverPendingPromise);\nsetTimeout(() =&gt; {\n  console.log(\"堆栈现在为空\");\n  console.log(foreverPendingPromise);\n});\n\n// 按顺序打印：\n// Promise { &lt;state&gt;: \"pending\" }\n// 堆栈现在为空\n// Promise { &lt;state&gt;: \"pending\" }\n</code></pre>\n<p><code>Promise.race(..)</code> 的异步性有什么意义呢？假设我们有一个网络请求操作，我们希望在一定时间内获得响应，否则就放弃请求，这时我们可以使用 <code>Promise.race(..)</code> 来实现超时控制：</p>\n<pre><code class=\"language-JavaScript\">const data = Promise.race([\n  fetch(\"/api\"),\n  new Promise((resolve, reject) =&gt; {\n    // 5 秒后拒绝\n    setTimeout(() =&gt; reject(new Error(\"请求超时\")), 5000);\n  }),\n])\n  .then((res) =&gt; res.json())\n  .catch((err) =&gt; displayError(err));\n</code></pre>\n<ol start=\"3\">\n<li><code>Promise.try()</code></li>\n</ol>\n<blockquote>\n<p><code>Promise.try()</code> 静态方法接受一个任意类型的回调函数（无论其是同步或异步，返回结果或抛出异常），并将其结果封装成一个 <code>Promise</code>。</p>\n</blockquote>\n<p>这是一个截止到目前（2026年2月）仍在提案阶段的 API，在一些现代浏览器和 Node.js 最新版本中已经可以使用，作用类似于 <code>async</code> 函数，可以将同步代码和异步代码统一处理为 <code>Promise</code> 对象：</p>\n<pre><code class=\"language-JavaScript\">Promise.try(() =&gt; {\n  // 这里可以是同步代码\n  const result = synchronousFunction();\n  return result;\n})\n  .then((value) =&gt; {\n    console.log(\"同步结果:\", value);\n  })\n  .catch((error) =&gt; {\n    console.error(\"错误:\", error);\n  });\n// 也可以是异步代码\nPromise.try(async () =&gt; {\n  const result = await asynchronousFunction();\n  return result;\n})\n  .then((value) =&gt; {\n    console.log(\"异步结果:\", value);\n  })\n  .catch((error) =&gt; {\n    console.error(\"错误:\", error);\n  });\n</code></pre>\n<ol start=\"4\">\n<li><code>Promise.withResolvers()</code></li>\n</ol>\n<blockquote>\n<p><code>Promise.withResolvers()</code> 静态方法返回一个对象，其包含一个新的 <code>Promise</code> 对象和两个函数，用于解决或拒绝它，对应于传入给 <code>Promise()</code> 构造函数执行器的两个参数。</p>\n</blockquote>\n<p>它完全等价于下面的代码：</p>\n<pre><code class=\"language-JavaScript\">let resolve, reject;\nconst promise = new Promise((res, rej) =&gt; {\n  resolve = res;\n  reject = rej;\n});\n</code></pre>\n<p>它的作用是简化创建一个可控的 <code>Promise</code> 对象，我们可以在外部调用 <code>resolve</code> 和 <code>reject</code> 来改变 <code>Promise</code> 的状态：</p>\n<pre><code class=\"language-JavaScript\">const { promise, resolve, reject } = Promise.withResolvers();\n// 模拟异步操作\nsetTimeout(() =&gt; {\n  const success = true;\n  if (success) {\n    resolve(\"操作成功\");\n  } else {\n    reject(\"操作失败\");\n  }\n}, 1000);\npromise\n  .then((result) =&gt; console.log(result))\n  .catch((error) =&gt; console.log(error))\n  .finally(() =&gt; console.log(\"操作完成\"));\n</code></pre>\n<p>这个 API 的使用场景比较少见，目前我还不能完全理解它的作用，感兴趣可以到 MDN 上查看。</p>\n<h2 id=\"asyncawait-与-promise\">async/await 与 Promise</h2>\n<p>最开始就说到 <code>async/await</code> 了，我是先接触到 <code>async/await</code> 这种写法的，然后才了解到它是基于 <code>Promise</code> 的语法糖，个人理解来说，<code>async/await</code> 让异步代码看起来更像同步代码，主要是提高代码的可读性和可维护性，就像 <code>Promise</code> 之于回调函数一样。</p>\n<p>在使用上，<code>async/await</code> 的争议集中在是否要使用 <code>try/catch</code> 来处理错误，我之前的处理方式是在请求的封装里使用 <code>try/catch</code> 来捕获错误，调用时正常使用 <code>async/await</code> ，其他地方处理异步操作还是直接使用 <code>Promise</code>。以前其实没有太深入考虑过合理性的问题，在新公司看代码规范时发现他们有针对这个问题讨论过，才意识到这个问题的重要性。关于这个问题争议比较大，而且关于 <code>async/await</code> 完全可以单独写一篇，这篇主要还是针对 <code>Promise</code> 的学习记录，再写下去也有些超篇幅了，之后学习时应该还会再聊到。</p>\n<h2 id=\"缺陷\">缺陷</h2>\n<p>这个部分对于我来说还是有些超纲了，但也有参考资料，列一下《你不知道的JavaScript》中卷提到的几个缺陷，不过这些纸质书有一定的时代性，内容仅供参考：</p>\n<ol>\n<li><strong>顺序错误处理</strong>： 如果构建了一个没有错误处理函数的Promise链，链中后续的 <code>then</code> 仍然会被执行，可能导致错误被忽略或处理不当。</li>\n<li><strong>单一值</strong>： <code>Promise</code> 只能处理单一值的传递，无法直接处理多个值或复杂的数据结构（可以传递封装的对象，但如果在链中的每一步都进行封装和解封，就有些笨重了）。</li>\n<li><strong>单决议</strong>： <code>Promise</code> 一旦被解决（<code>fulfilled</code>）或拒绝（<code>rejected</code>），其状态就不能再改变，无法重新解决或拒绝。</li>\n<li><strong>惯性</strong>： 时代性的体现，考虑当时的环境 <code>Promise</code> 还未普及，现在应该可以忽略这一点了。</li>\n<li><strong>不可取消</strong>： 一旦创建，<code>Promise</code> 就会一直执行，无法取消正在进行的异步操作。这个也有些时代性了，现在有 <code>AbortController</code> 可以配合 <code>fetch</code> 来实现取消请求的功能。</li>\n<li><strong>性能</strong>： 相较于回调函数，<code>Promise</code> 在创建和管理状态方面有一定的性能开销，但个人认为这在通常的应用场景中影响不大。</li>\n</ol>\n<h2 id=\"总结\">总结</h2>\n<p>说实话动笔之前就是觉得应该写一篇关于 <code>Promise</code> 的，但开始写之后发现没什么方向，相关资料也是浩如烟海，写这篇耗费了非常多的时间，开始不断地深挖细节后感觉有无穷无尽的问题，好在现在通过 AI 至少可以把这些问题大致理清楚，\"大致\"理解说明还有很多内容没有涉及，之后在项目中应该会更加注意 <code>Promise</code> 的应用，然后把《你不知道的JavaScript》的相关内容看完结合一下应该还可以再水一篇。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-06 10:47</span>&nbsp;\n<a href=\"https://www.cnblogs.com/LFeather\">夜尽丶</a>&nbsp;\n阅读(<span id=\"post_view_count\">208</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "刚刚，Claude Opus 4.6 和 GPT-5.3-Codex 同时炸场！AI 编程要变天了",
      "link": "https://www.cnblogs.com/yupi/p/19583031",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yupi/p/19583031\" id=\"cb_post_title_url\" title=\"发布于 2026-02-06 10:40\">\n    <span>刚刚，Claude Opus 4.6 和 GPT-5.3-Codex 同时炸场！AI 编程要变天了</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"刚刚，Claude Opus 4.6 和 GPT-5.3-Codex 同时炸场！AI 编程要变天了\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/2225420/202602/2225420-20260206102350805-967131892.png\" />\n        这次两家巨头同时发布新模型，互相贴脸开大，对我们用户来说是好事。可以看到，这两个模型都在往 实用方向 猛卷，是真的想让你日常工作中用得上。\n这两个大模型你会如何选择呢？\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p class=\"md-end-block md-heading\"><span class=\"md-plain\">大家好，我是程序员鱼皮。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">今天凌晨，AI 圈又双叒炸了。Anthropic 和 OpenAI 几乎同时发布了自家的最新大模型 —— Claude Opus 4.6 和 GPT-5.3-Codex，中门对狙，火药味十足。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这次两家是真往编程和实际工作能力上卷了，不是那种 “跑分升了 2 个点” 就发篇博客的敷衍更新。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">下面我带大家快速了解一下，这两个模型到底更新了什么？对我们程序员和 AI 玩家来说有什么用？</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">Claude Opus 4.6：更聪明、更能干、更持久</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">先说 Anthropic 这边。Claude Opus 4.6 是目前 Claude 家族最强的模型，之前用 Claude Opus 4.5 编程就已经让我感觉 “AI 写代码无所不能” 了，而这次的 Opus 4.6 在多项评估中均处于最先进水平，包括智能编码、多学科推理、知识工作和智能搜索等。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">光看这个跑分我就贼激动了！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">实际上手后，我最直观的感受就是：<span class=\"md-pair-s \"><strong>干活更靠谱了</strong><span class=\"md-plain\">。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">具体更新了这些：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">1）编程能力大幅提升：Opus 4.6 能更好地在大型代码库中工作，调试和代码审查能力增强，写完代码还能自己检查错误。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我实测了一波，让之前的 Opus 4.5 和新出的 Opus 4.6 同时开发一个「聚合搜索引擎」项目：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>请你帮我开发一个聚合搜索网站，包含完整的前端和后端，能够同时从多个不同的搜索引擎搜索和聚合结果。<br /><span>应该先做 MVP 最小可行产品，整个过程不需要向我确认、不需要我提供 API Key，你必须确保功能正常可用。</span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">几分钟后，二者都完成了任务：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">但是对比一下实际搜索效果，Opus 4.5 完败，看到这我就放心了，以后我用 AI 编程估计 Bug 更少了~</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">2）100 万 token 上下文窗口。Opus 系列第一次支持这么长的上下文，简单来说就是你可以一次性给它丢一大堆文件和代码，它都能记住并理解，不会像以前那样聊着聊着就失忆了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这也是我最最最期待的特性，复杂的前后端项目也可以在同一对话框中一把梭了！不用来来回回总结上下文和新开对话框。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">赣，准备嘎嘎烧 Tokens 了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">3）128k 输出 token。输出长度翻倍，意味着 Claude 可以一次性生成更长的代码和文档，不用再拆成好几次请求了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">4）自适应思考。以前开发者只能手选开启或关闭深度推理，现在 Claude 会自动判断这个问题需不需要深度思考。简单问题秒回，复杂问题慢慢想，智能调节，省时省钱。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">5）上下文压缩。以前跑长任务的时候，AI 经常会撞到上下文长度的天花板。现在 Claude 能自动压缩和总结之前的对话内容，让长时间运行的任务不会中途翻车。搭配 100 万 token 上下文，不敢想象有多持久！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">6）Claude Code 支持多智能体协作。你可以同时启动多个 AI Agent 并行工作，比如让几个 Agent 同时审查代码库的不同部分，效率直接翻倍。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">7）Claude in Excel 大升级。现在能处理更复杂的长时间任务，支持数据透视表、图表修改、条件格式、数据验证等，还能一次性处理多步骤操作。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">8）Claude in PowerPoint 上线。能读取你已有的模板、字体和母版，保持品牌风格一致，然后直接帮你生成完整的 PPT。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">大家对 Opus 4.6 也是一致好评，不少早期测试的公司都表示 “用了回不去”，Cursor 官方说 Opus 4.6 是他们内部长任务测试中的最强模型，Replit 说它的任务拆解和并行规划能力有了巨大飞跃。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">GPT-5.3-Codex：OpenAI 的编程杀手锏</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">再看 OpenAI 这边。这次发布的 GPT-5.3-Codex，剑指 <span class=\"md-pair-s \"><strong>最强编程 Agent</strong><span class=\"md-plain\">，而且不只是写代码，还能像你的同事一样边干活边和你沟通。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">相比 Claude 官方连发好几个帖子介绍自家新模型，OpenAI 官方这边则低调不少。Sam Altman 亲自在 X 上喊话：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">来看看具体有什么：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">1）编程跑分全面领先。SWE-Bench Pro 57% 和 TerminalBench 2.0 77%，编程相关基准都创了新高。尤其是 OSWorld（测试 AI 在真实桌面环境中完成任务的能力）直接从上一代的 38.2% 飙到 64.7%，这个提升幅度相当炸裂。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">2）速度更快、更省钱。完成同样的任务，token 消耗量不到上一代（5.2-Codex）的一半，而且每个 token 处理速度还快了 25%。又快又省，这才是实实在在的体验提升。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">3）边干活边汇报。以前你丢一个任务给 AI，只能干等结果。现在 GPT-5.3-Codex 会在工作过程中实时告诉你它在做什么、做到哪了，你随时可以插嘴调整方向，就像真的在和一个同事协作一样。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">4）超强的前端开发能力。官方直接展示了让它做赛车游戏和潜水游戏的效果，完整度高得离谱，有多个地图、道具系统和完整的游戏逻辑。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">生成普通网页时 AI 也更懂你的意图了，默认就能给你做出功能更丰富、设计更合理的页面。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">5）电脑操作能力增强。不只是写代码，它还能像人一样操作电脑完成各种任务，比如做 PPT、分析数据、处理表格，把编程 Agent 的边界扩展到了全能打工 Agent。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">6）自己训练自己。OpenAI 团队说 GPT-5.3-Codex 是第一个 <span class=\"md-pair-s \"><strong>参与了自身创造</strong><span class=\"md-plain\"> 的模型。团队用它的早期版本来调试训练过程、管理部署、分析测试结果。也就是说，AI 在加速 AI 自身的进化，以后的进化速度肯定会越来越快。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">7）网络安全能力大幅增强。这是第一个被 OpenAI 归类为高能力网络安全模型的版本，能主动发现代码漏洞。OpenAI 同时承诺投入 1000 万美元 API 额度支持网络防御研究。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">我的看法</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这次两家巨头同时发布新模型，互相贴脸开大，对我们用户来说是好事。可以看到，这两个模型都在往 <span class=\"md-pair-s \"><strong>实用方向</strong><span class=\"md-plain\"> 猛卷，是真的想让你日常工作中用得上。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这两个大模型应该如何选择呢？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">简单对比一下：</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Claude Opus 4.6 是六边形战士，编程、办公、研究样样行，特别是在 Excel、PowerPoint 这些办公场景里做了很深的整合。</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">GPT-5.3-Codex 把编程能力拉满，在代码生成、任务执行和人机协作上打出了差异化优势。</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不过我估计网络和价格就已经劝退一大波国内用户了，如果你只是日常学习、或者做做工具类小项目，也不必盲目追求国外的大模型。很快 DeepSeek V4 等一系列国产大模型应该就要出来了，期待一波~</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">更多编程学习资源</span></h2>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course\" rel=\"noopener nofollow\"><span class=\"md-plain\">Java前端程序员必做项目实战教程+毕设网站</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费编程学习交流社区（自学必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course/cv\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员保姆级求职写简历指南（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.mianshiya.com/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费面试刷题网站工具（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640584449888772098\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Java零基础入门学习路线 + Java教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586673306091521\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Python零基础入门学习路线 + Python教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586014108303362\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新前端零基础入门学习路线 + 前端教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586867363954689\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据结构和算法零基础入门学习路线 + 算法教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1644279832026075138\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新C++零基础入门学习路线、C++教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641797333479903234\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据库零基础入门学习路线 + 数据库教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640589994284695553\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Redis零基础入门学习路线 + Redis教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641035880439271426\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机基础入门学习路线 + 计算机基础教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641366118197153793\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新小程序入门学习路线 + 小程序开发教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"http://sqlmother.yupi.icu/\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新SQL零基础入门学习路线 + SQL教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586295529324545\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Linux零基础入门学习路线 + Linux教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588753362108417\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Git/GitHub零基础入门学习路线 + Git教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640587909942099969\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新操作系统零基础入门学习路线 + 操作系统教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588119619551233\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机网络零基础入门学习路线 + 计算机网络教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588392073150465\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新设计模式零基础入门学习路线 + 设计模式教程</span></a></span></p>\n</li>\n<li class=\"md-list-item md-focus-container\">\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-meta-i-c md-link md-expand\"><a href=\"https://www.code-nav.cn/post/1640648711119892481\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新软件工程零基础入门学习路线 + 软件工程教程</span></a></span></p>\n</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-06 10:40</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yupi\">程序员鱼皮</a>&nbsp;\n阅读(<span id=\"post_view_count\">637</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Linux内核中模块定义宏机制解析",
      "link": "https://www.cnblogs.com/ttkwzyttk/p/19582878",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ttkwzyttk/p/19582878\" id=\"cb_post_title_url\" title=\"发布于 2026-02-06 10:10\">\n    <span>Linux内核中模块定义宏机制解析</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文解析了 Linux 内核中的 module driver helper macro，讲解了 module_platform_driver 的实现原理与设计思想，展示了宏如何通过 宏拼接、可变参数、__init/__exit 和 module_init/module_exit 自动生成驱动注册与注销模板，是内核驱动开发者掌握标准写法的实用指南。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在编写 Linux 设备驱动时，尤其是 platform、I2C、SPI 等总线驱动，我们经常会看到类似下面的写法：</p>\n<pre><code class=\"language-c\">module_platform_driver(my_driver);\n</code></pre>\n<p>这类宏看起来很“魔法”，但实际上它们只是 Linux 内核为了减少样板代码而提供的一种 <strong>driver helper macro</strong>，本文主要讲解这类宏的用法与机制</p>\n<h1 id=\"一传统模块初始化方式\">一、传统模块初始化方式</h1>\n<p>这里以platform驱动为例，传统的驱动写法通常是这样的：</p>\n<pre><code class=\"language-c\">static struct platform_driver my_platform_driver = {\n    .probe  = my_probe,\n    .remove = my_remove,\n    .driver = {\n        .name = \"my_driver\",\n    },\n};\n\nstatic int __init my_init(void)\n{\n    return platform_driver_register(&amp;my_platform_driver);\n}\n\nstatic void __exit my_exit(void)\n{\n    platform_driver_unregister(&amp;my_platform_driver);\n}\n\nmodule_init(my_init);\nmodule_exit(my_exit);\nMODULE_LICENSE(\"GPL\");\n</code></pre>\n<p>这是一个标准的驱动模板，有驱动的入口init函数与出口exit函数，并通过<code>module_init</code>和<code>module_exit</code>接口函数进行注册，这种写法的样板代码高度重复，几乎每一个platform驱动都是一模一样的，内核中存在大量这种固定模式的代码，非常适合使用宏来简化</p>\n<h1 id=\"二模块定义宏的引入\">二、模块定义宏的引入</h1>\n<p>为了解决上述问题，Linux 内核引入了一组 <strong>module driver helper macro</strong>，用于简化驱动的注册与注销过程。</p>\n<p>以platform驱动为例，内核提供了</p>\n<pre><code class=\"language-c\">module_platform_driver(...)\n</code></pre>\n<p>虽然接口看着像是函数，但是他是由宏来实现的，使用该宏之后，上面的代码就可以简化为：</p>\n<pre><code class=\"language-c\">static struct platform_driver my_platform_driver = {\n    .probe  = my_probe,\n    .remove = my_remove,\n    .driver = {\n        .name = \"my_driver\",\n    },\n};\n\nmodule_platform_driver(my_platform_driver);\nMODULE_LICENSE(\"GPL\");\n</code></pre>\n<p>可以看见，使用该宏之后，就不需要再手写<code>__init</code>和<code>__exit</code>注册与注销接口函数了，也不需要再显式调用<code>platform_driver_register</code>和<code>platform_driver_unregister</code>接口函数了，与传统写法完全相同</p>\n<p>当然这种写法不仅仅只有platform驱动有，内核为不同的总线都提供了对应的宏定义</p>\n<pre><code class=\"language-c\">module_i2c_driver(my_i2c_driver);\nmodule_spi_driver(my_spi_driver);\nmodule_usb_driver(my_usb_driver);\nmodule_pci_driver(my_pci_driver);\n.......\n</code></pre>\n<p>他们遵循完全相同的设计思想：一个模块，只注册一个驱动，用一行宏搞定</p>\n<h1 id=\"三本质解析\">三、本质解析</h1>\n<p>这里还是以platform驱动为例，<code>module_platform_driver</code> 是一个宏封装。我们可以打开内核源码<code>kernel/include/linux/platform_device.h</code>找到对应的宏，如果为其他总线驱动，需要到对应的头文件中查找，如下所示</p>\n<pre><code class=\"language-c\">/* module_platform_driver() - Helper macro for drivers that don't do\n* anything special in module init/exit. This eliminates a lot of\n* boilerplate. Each module may only use this macro once, and\n* calling it replaces module_init() and module_exit()\n*/\n\n#define module_platform_driver(__platform_driver) \\\nmodule_driver(__platform_driver, platform_driver_register, \\\nplatform_driver_unregister)\n</code></pre>\n<p>可以看见<code>module_platform_driver</code>宏中又使用了<code>module_driver</code>这个宏定义，这个宏定在<code>kernel/include/linux/device/driver.h</code>头文件中，定义代码如下</p>\n<pre><code class=\"language-c\">/**\n\n* module_driver() - Helper macro for drivers that don't do anything\n* special in module init/exit. This eliminates a lot of boilerplate.\n* Each module may only use this macro once, and calling it replaces\n* module_init() and module_exit().\n*\n* @__driver: driver name\n* @__register: register function for this driver type\n* @__unregister: unregister function for this driver type\n* @...: Additional arguments to be passed to __register and __unregister.\n*\n* Use this macro to construct bus specific macros for registering\n* drivers, and do not use it on its own.\n*/\n#define module_driver(__driver, __register, __unregister, ...) \\\nstatic int __init __driver##_init(void) \\\n{ \\\nreturn __register(&amp;(__driver) , ##__VA_ARGS__); \\\n} \\\nmodule_init(__driver##_init); \\\nstatic void __exit __driver##_exit(void) \\\n{ \\\n__unregister(&amp;(__driver) , ##__VA_ARGS__); \\\n} \\\n\nmodule_exit(__driver##_exit);\n</code></pre>\n<p>在<code>module_driver</code>宏中就可以看见对应的驱动注册与注销的模板了，这里主要就是通过宏拼接以及可变参数宏来实现，读者可以自行宏展开进行分析，所有的模块宏<code>platform</code>驱动、<code>pci</code>驱动、<code>usb</code>驱动等等，底层都是调用了<code>module_driver</code>进行宏替换与拼接组成最后的模块注册模板，这里就不再赘述了</p>\n<h1 id=\"四使用场景\">四、使用场景</h1>\n<p>在主线内核中，这种写法已经成为<strong>事实标准</strong>，原因主要有：</p>\n<ul>\n<li>*<strong>减少样板代码</strong></li>\n<li><strong>统一驱动风格</strong></li>\n<li><strong>降低出错概率</strong></li>\n<li><strong>代码审查更友好</strong></li>\n</ul>\n<p>对于维护者来说，一眼看到<code>module_platform_driver(xxx_driver);</code> 就能立刻知道这是一个“标准的 platform 模块驱动。</p>\n<p>虽然 helper macro 很方便，但并非所有场景都适合。不建议使用的情况包括：</p>\n<ul>\n<li>一个模块中注册 <strong>多个 driver</strong></li>\n<li>模块 init 阶段还需要做额外初始化工作，使用模块宏的话，它的底层只能调用对应的<code>register</code>和<code>unregister</code>函数无法做其他操作</li>\n<li>对初始化/退出顺序有精细控制需求</li>\n</ul>\n<p>在这些场景下，手写 <code>module_init</code> / <code>module_exit</code> 反而更清晰。所以需要具体情况具体分析</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-06 10:10</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ttkwzyttk\">ttkwzyttk</a>&nbsp;\n阅读(<span id=\"post_view_count\">102</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Codex 5.3 与 Opus 4.6 同日升级，AI Agent今年要爆发了",
      "link": "https://www.cnblogs.com/haibindev/p/19586598",
      "published": "",
      "description": "<div class=\"postTitle\">\n\t\t<h1><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/haibindev/p/19586598\" id=\"cb_post_title_url\" title=\"发布于 2026-02-07 00:21\">\n    <span>Codex 5.3 与 Opus 4.6 同日升级，AI Agent今年要爆发了</span>\n    \n\n</a>\n</h1>\n\t</div>\n\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"Codex 5.3 与 Opus 4.6 同日升级，AI Agent今年要爆发了\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/254714/202602/254714-20260207002057936-565238423.png\" />\n        2026真的是 AI Agent 爆发的一年。OpenAI 与 Anthropic 几乎前后脚发布新版本：`GPT-5.3-Codex` 与 `Claude Opus 4.6`。再叠加国内大模型在 1月到2月的密集动作，现在看来，智能体的发展速度，已经超出大多数人的预料了，我们都需要紧跟脚步。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"codex-53-与-opus-46-同日升级ai-编码竞争从会写转向能闭环\">Codex 5.3 与 Opus 4.6 同日升级，AI 编码竞争从“会写”转向“能闭环”</h1>\n<p>2026真的是 AI Agent 爆发的一年。OpenAI 与 Anthropic 几乎前后脚发布新版本：<code>GPT-5.3-Codex</code> 与 <code>Claude Opus 4.6</code>。再叠加国内大模型在 1月到2月的密集动作，现在看来，智能体的发展速度，已经超出大多数人的预料了，我们都需要紧跟脚步。</p>\n<h2 id=\"发生了什么\">发生了什么</h2>\n<p>2月5日，OpenAI 发布 GPT-5.3-Codex，定位是更强的 agentic coding 模型，覆盖 Codex App、CLI、IDE 扩展与 Web。<br />\n同一天，Anthropic 发布 Claude Opus 4.6，重点强调长任务、长上下文与工程稳定性。</p>\n<p><img alt=\"Sam Altman 在 X 发布 Codex 5.3 截图\" src=\"https://img2024.cnblogs.com/blog/254714/202602/254714-20260207001843633-555515766.png\" /></p>\n<p><img alt=\"Anthropic 在 X 发布 Opus 4.6 截图\" src=\"https://img2024.cnblogs.com/blog/254714/202602/254714-20260207001843660-1930590112.png\" /></p>\n<p>同日升级这件事本身就是信号：头部厂商已经把“开发者工作流”当成最核心战场。</p>\n<h2 id=\"有什么提升和改变\">有什么提升和改变</h2>\n<p>这一部分按官方披露口径展开。</p>\n<p>先看 OpenAI。官方给了比较明确的性能描述和对比数据：</p>\n<ul>\n<li>在 Codex 使用场景中，<code>GPT-5.3-Codex</code> 相比 <code>GPT-5-Codex</code>，官方称整体速度约提升 25%。</li>\n<li>在 <code>SWE-Bench Pro</code> 上，<code>GPT-5.3-Codex</code> 为 56.8，<code>GPT-5-Codex</code> 为 56.4，属于小幅提升。</li>\n<li>在 <code>Terminal-Bench 2.0</code> 上，<code>GPT-5.3-Codex</code> 为 77.3，<code>GPT-5-Codex</code> 为 64.0，提升更明显。</li>\n<li>在 <code>OSWorld Verified</code> 上，<code>GPT-5.3-Codex</code> 为 64.7，<code>GPT-5-Codex</code> 为 38.2，跨任务执行能力的提升幅度非常大。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>指标</th>\n<th style=\"text-align: right;\">GPT-5.3-Codex</th>\n<th style=\"text-align: right;\">GPT-5-Codex</th>\n<th>变化解读</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Codex 场景整体速度</td>\n<td style=\"text-align: right;\">+25%（官方口径）</td>\n<td style=\"text-align: right;\">基线</td>\n<td>交互和长任务执行节奏更快</td>\n</tr>\n<tr>\n<td>SWE-Bench Pro</td>\n<td style=\"text-align: right;\">56.8</td>\n<td style=\"text-align: right;\">56.4</td>\n<td>小幅提升，说明基础修复能力继续优化</td>\n</tr>\n<tr>\n<td>Terminal-Bench 2.0</td>\n<td style=\"text-align: right;\">77.3</td>\n<td style=\"text-align: right;\">64.0</td>\n<td>大幅提升，终端多步任务更稳</td>\n</tr>\n<tr>\n<td>OSWorld Verified</td>\n<td style=\"text-align: right;\">64.7</td>\n<td style=\"text-align: right;\">38.2</td>\n<td>显著提升，跨工具/跨环境任务能力加强</td>\n</tr>\n</tbody>\n</table>\n<p>换句话说，OpenAI 这次最关键的升级点，不是“写一段代码更优雅”，而是“在多步骤、多工具、多文件任务里更稳”。</p>\n<p>再看 Anthropic。Opus 4.6 的官方叙事重点有三点：</p>\n<ul>\n<li>首次把 Opus 系列推进到 <code>1M</code> 上下文窗口（测试能力），直接服务长文档和长链路任务。</li>\n<li>在官方展示中，<code>Terminal-Bench 2.0</code> 达到 65.4，<code>OSWorld</code> 达到 72.7，继续强化端到端任务执行能力。</li>\n<li>价格口径保持不变，意图很明确：在不提高使用门槛的前提下，拉高复杂任务成功率。</li>\n</ul>\n<p>所以这轮变化可以总结成一句话：模型厂商正在把“代码生成工具”升级为“软件工程执行代理”。</p>\n<h2 id=\"国内模型的最近动作\">国内模型的最近动作</h2>\n<p>国内阵营这段时间也很密集，而且都在往“工程化可用”方向卷。</p>\n<p>百度这边，2026年1月22日发布文心大模型 5.0。官方披露的关键词是“原生多模态、超大参数规模、综合能力升级”，并强调在多项公开基准上的竞争力。对企业用户来说，这意味着百度正在把文心从通用对话进一步推向多场景生产。</p>\n<p>阿里云通义这边，2026年1月23日版本号 <code>qwen3-max-2026-01-23</code> 已在模型服务侧上线，思考模式标识为 <code>Qwen3-Max-Thinking</code>。官方描述重点放在更强推理、更强 Agent 任务处理和工具调用能力，定位是可直接进入业务工作流的旗舰模型。</p>\n<p>DeepSeek 据说马上要发布 <code>DeepSeek V4</code>，主打编码能力。截至2026年2月6日，官方仍未给出 V4 正式发布公告。</p>\n<p>智谱这边，<code>GLM-5</code> 在2026年1月初有“将很快推出”的对外信息，但截至2026年2月6日，尚未看到完整官方发布页落地。</p>\n<p>如果做一个阶段性预估：国内大模型在2026年上半年很可能出现“旗舰扎堆发布 + 价格快速调整 + Agent 场景落地提速”的三连动。</p>\n<p>另外，阿里在千问上已经开始打通生活圈，包括电商、导航、旅游、支付，甚至是政务民生，要成为一个大帝国。这个能力恐怕全球独一份了</p>\n<p><img alt=\"千问生活圈生态示意图\" src=\"https://img2024.cnblogs.com/blog/254714/202602/254714-20260207001843706-160854750.png\" /></p>\n<h2 id=\"ai-agent-智能体正在加速进化\">AI Agent 智能体正在加速进化</h2>\n<p>AI Agent 对所有人的影响，已经从“可选工具”变成“基础能力差距”。</p>\n<p>对程序员来说，变化是工作重心迁移。你写的纯代码会减少，但你定义任务、拆解需求、设计验证、管理上下文的能力会成为新核心。</p>\n<p>对产品和运营来说，变化是执行方式重构。过去要多人协作一周的内容整理、数据分析、方案迭代，未来可能由“人定方向 + Agent 连续执行”在一天内完成。</p>\n<p>对企业管理者来说，变化是组织效率和组织结构。很多岗位不会消失，但“人机协作比”会快速变化，团队将从按岗位分工转向按任务闭环分工。</p>\n<p>对普通用户来说，变化是信息处理门槛被拉平。未来的差距不再是“会不会用某个软件”，而是“会不会把目标描述清楚，并持续驱动 Agent 直到拿到可用结果”。</p>\n<p><img alt=\"AI Agent 进化路线图\" src=\"https://img2024.cnblogs.com/blog/254714/202602/254714-20260207001843691-1353541318.png\" /></p>\n<p>未来 6 到 12 个月，最现实的预估是：</p>\n<ul>\n<li>Agent 会先在高重复、可验证、可审计的场景里规模化。</li>\n<li>跨系统自动执行会增加，但权限治理和审计会成为刚需。</li>\n<li>个人生产力差距会被进一步放大，会“定义任务和验收结果”的人会显著领先。</li>\n</ul>\n<h2 id=\"小结\">小结</h2>\n<p>从2026年2月这轮更新看，AI 编码竞争的核心已经非常清晰：谁能更稳定地完成复杂任务，谁就能拿到下一阶段的话语权。<br />\nCodex 5.3 与 Opus 4.6 的同日升级，加上文心 5、Qwen3-Max-Thinking、DeepSeek V4、GLM-5 的连续动作，说明2026年的主线不是“模型会不会写代码”，而是“模型能不能作为可控的工程执行者进入真实生产”。</p>\n<hr />\n<p><strong>作者简介：</strong> 10年+视频技术、后端架构、AI应用开发经验，曾任某互联网大厂技术专家。对AI编程工具、云原生架构、视频处理技术有深入研究。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/254714/202307/254714-20230701143418754-1351786962.jpg\" /></p>\n<p><strong>合作请加WX：hbstream</strong><br />\n<strong>（<a href=\"http://haibindev.cnblogs.com\" target=\"_blank\">http://haibindev.cnblogs.com</a>），转载请注明作者和出处</strong></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-02-07 00:21</span>&nbsp;\n<a href=\"https://www.cnblogs.com/haibindev\">haibindev</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "从聊天框到动态助手：MCP Apps 如何重塑 AI 交互的未来",
      "link": "https://www.cnblogs.com/shanyou/p/19586390",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/shanyou/p/19586390\" id=\"cb_post_title_url\" title=\"发布于 2026-02-06 22:02\">\n    <span>从聊天框到动态助手：MCP Apps 如何重塑 AI 交互的未来</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><span>在人工智能向“自主智能体”演进的道路上，我们正见证一个关键的范式转移：大型语言模型（LLM）不再仅仅是文本生成器，而是逐渐成为能感知环境、调用工具并执行复杂任务的智能核心。然而，传统的“文本输入-文本输出”模式，在面对需要精密逻辑、实时数据可视化与复杂业务流操控的生产力场景时，其交互深度的局限性暴露无遗。为了连接模型与广阔的外部世界，<strong>模型上下文协议（Model Context Protocol, MCP）</strong> 应运而生，旨在标准化模型与工具之间的通信，降低生态适配成本。</span></p>\n<h5><span>一、MCP 的基石与交互瓶颈</span></h5>\n<p><span>MCP 通过宿主（Host）、客户端（Client）与服务器（Server）的三层架构，实现了关注点的分离与协议的标准化。在其基础模型中，工具（Tools）通常返回结构化数据或静态 Markdown 文本。虽然这解决了功能调用的问题，但在处理如多维财务报表、交互式工程图纸或实时监控仪表盘等任务时，用户体验出现了断层——智能体只能“描述”数据，用户无法直接“操作”数据。这种交互深度的缺失，成为提升 AI 生产力的主要障碍。</span></p>\n<h5><span>二、MCP Apps：交互式 UI 的引入</span></h5>\n<p><span>2025年底，由 Anthropic、OpenAI 及社区推动的 <strong>MCP Apps 扩展（代号 SEP-1865）</strong> 正式发布，旨在彻底突破这一瓶颈。其核心创新在于，允许 AI 对话线程内直接交付并运行完整的、交互式的 Web 应用程序。</span></p>\n<p><span><span style=\"font-size: medium;\"><strong>MCP Apps 的本质</strong>，是存在于 AI 对话中的沙箱化 HTML5 应用。它并非定义新的 UI 语言，而是拥抱成熟的 Web 技术栈（HTML/JS/CSS）。在 SEP-1865 框架下，工具定义可通过 _meta.ui 字段声明一个指向 UI 资源（使用 ui:// 协议）的引用。当 LLM 调用此类工具时，宿主便能识别该声明，并从服务器拉取对应的 UI 捆绑包进行渲染。</span></span></p>\n<p><span>与传统 MCP 工具相比，MCP Apps 带来了根本性的提升：</span></p>\n<ul>\n<li><span><span style=\"font-size: medium;\"><strong>输出介质</strong>：从静态文本/JSON 变为动态、可交互的应用程序。</span></span></li>\n</ul>\n<ul>\n<li><span><span style=\"font-size: medium;\"><strong>交互深度</strong>：从触发新一轮对话，扩展到支持点击、拖拽、表单校验等丰富的前端操作。</span></span></li>\n</ul>\n<ul>\n<li><span><span style=\"font-size: medium;\"><strong>通信模式</strong>：从单向的请求-响应，升级为基于 postMessage 的全双工 JSON-RPC 通道，实现实时双向通信。</span></span></li>\n</ul>\n<ul>\n<li><span><span style=\"font-size: medium;\"><strong>生命周期</strong>：从随工具执行结束而终止，变为可在整个对话上下文中持续存在并保持内部状态。</span></span></li>\n</ul>\n<h5><span>三、安全架构与核心技术流程</span></h5>\n<p><span>将不受信任的外部代码引入宿主环境，安全是首要考量。SEP-1865 为此构建了严密的多层防护：</span></p>\n<ol>\n<li><span><span style=\"font-size: medium;\"><strong>强制沙箱隔离</strong>：所有 App 必须运行在高度受限的 iframe 沙箱中，禁止直接访问父页面 DOM 或执行特权操作。</span></span></li>\n</ol><ol start=\"2\">\n<li><span><span style=\"font-size: medium;\"><strong>严格的内容安全策略（CSP）</strong>：服务器可通过元数据定义 App 允许加载的资源域名和发起的网络连接，有效防御 XSS 攻击和数据泄露。</span></span></li>\n</ol><ol start=\"3\">\n<li><span><span style=\"font-size: medium;\"><strong>显式权限授权</strong>：对于需要摄像头、麦克风等本地敏感权限的 App，宿主必须验证其声明，并征得用户二次确认，满足企业级隐私要求。</span></span></li>\n</ol>\n<p><span>一次完整的 MCP Apps 交互，遵循一个精密协同的四步工作流：</span></p>\n<ol>\n<li><span><span style=\"font-size: medium;\"><strong>发现与声明</strong>：LLM 调用的工具定义中，包含了指向 UI 资源的元数据。</span></span></li>\n</ol><ol start=\"2\">\n<li><span><span style=\"font-size: medium;\"><strong>资源获取</strong>：宿主主动从 MCP 服务器拉取 HTML、JS、CSS 等资源包。宿主具备预加载能力，可在 LLM 生成最终答案前启动加载，极大优化感知延迟。</span></span></li>\n</ol><ol start=\"3\">\n<li><span><span style=\"font-size: medium;\"><strong>沙箱化渲染</strong>：宿主创建配置了严格 CSP 和权限的 iframe ，并初始化渲染 UI。</span></span></li>\n</ol><ol start=\"4\">\n<li><span><span style=\"font-size: medium;\"><strong>实时通信</strong>：通过 postMessage 建立宿主与 App 间的 JSON-RPC 通道。App 可调用服务器工具（通过宿主转发），宿主也可将模型生成的新数据推送给 App，形成闭环交互。</span></span></li>\n</ol>\n<h5><span>四、设计哲学与未来意义</span></h5>\n<p><span>MCP Apps 的设计蕴含四大关键目标：<strong>上下文保留</strong>（任务在对话线程内无缝完成）、<strong>双向数据流</strong>（界面与模型逻辑实时同步）、<strong>宿主集成</strong>（可委托宿主执行如 OAuth 登录等重度操作）以及前述的<strong>安全性</strong>。</span></p>\n<p><span>这种架构巧妙地解耦了“表示层”（UI）与“逻辑层”（服务器工具）。它向我们展示了一个诱人的未来：AI 智能体将从一个被动的“聊天框”，蜕变为深度嵌入我们所有数字工具中的<strong>动态、交互式助手</strong>。通过 SEP-1865，MCP 补全了构建复杂生产级 AI 应用的最后一块拼图。</span></p>\n<h5><span>结语</span></h5>\n<p><span>对于开发者和技术决策者而言，拥抱 MCP 及其 Apps 生态已是一种必然趋势。基于 MCP 构建服务，意味着获得了跨平台的能力和进入“智能体原生”时代的标准入场券。尽管在延迟优化、复杂授权和语义理解一致性方面仍有挑战，但通过行业巨头与开源社区的协同推进，MCP 正稳步成为构建下一代<strong>自主、安全、高效</strong>的 AI 应用的坚实基石。未来，与 AI 的协作将不再是简单的问答，而是在一个共享的、可视化的交互空间中共同解决问题。</span></p>\n<p><span>相关链接：</span></p>\n<ul>\n<li>\n<p class=\"text-2xl sm:text-3xl font-bold text-gray-900 tracking-tight dark:text-gray-200 [overflow-wrap:anywhere]\" id=\"page-title\">MCP Apps：<span>https://modelcontextprotocol.io/docs/extensions/apps&nbsp;</span></p>\n</li>\n</ul>\n\n</div>\n<div id=\"MySignature\">\n    <p>欢迎大家扫描下面二维码成为我的客户，扶你上云</p>\n<img src=\"https://images.cnblogs.com/cnblogs_com/shanyou/57459/o_220125090408_%E9%82%80%E8%AF%B7%E4%BA%8C%E7%BB%B4%E7%A0%81-258px.jpeg\" width=\"170\" />\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-06 22:02</span>&nbsp;\n<a href=\"https://www.cnblogs.com/shanyou\">张善友</a>&nbsp;\n阅读(<span id=\"post_view_count\">10</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "基于 Clean Architecture + DDD 的轻量级工作流系统实践",
      "link": "https://www.cnblogs.com/aishangyipiyema/p/19585669",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aishangyipiyema/p/19585669\" id=\"cb_post_title_url\" title=\"发布于 2026-02-06 17:48\">\n    <span>基于 Clean Architecture + DDD 的轻量级工作流系统实践</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"基于-clean-architecture--ddd-的轻量级工作流系统实践\">基于 Clean Architecture + DDD 的轻量级工作流系统实践</h1>\n<blockquote>\n<p>本文介绍在一个 .NET 10 + Vue 3 的后台管理系统（Ncp.Admin）中，如何基于现有的 Clean Architecture + DDD 架构，从零构建一套轻量级审批工作流系统，涵盖后端领域建模、CQRS 命令查询、领域事件驱动的业务自动化，以及前端可视化流程节点设计器的完整实现。</p>\n</blockquote>\n<h2 id=\"一项目背景与技术栈\">一、项目背景与技术栈</h2>\n<p><strong>Ncp.Admin</strong> 是一套采用 Clean Architecture 分层架构的后台管理系统，技术栈如下：</p>\n<table>\n<thead>\n<tr>\n<th>层级</th>\n<th>技术选型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>前端</td>\n<td>Vue 3 + Vite + Ant Design Vue (Vben Admin)</td>\n</tr>\n<tr>\n<td>API 层</td>\n<td>ASP.NET Core + FastEndpoints</td>\n</tr>\n<tr>\n<td>应用层</td>\n<td>MediatR (CQRS)、FluentValidation</td>\n</tr>\n<tr>\n<td>领域层</td>\n<td>DDD 聚合根、领域事件、强类型 ID</td>\n</tr>\n<tr>\n<td>基础设施</td>\n<td>EF Core + Pomelo MySQL、Redis、CAP、Hangfire</td>\n</tr>\n</tbody>\n</table>\n<p>项目已经有完善的用户、角色、部门、权限管理模块。本次需求是在现有架构基础上，增加一套 <strong>审批工作流系统</strong>，支持流程定义、流程发起、多级审批、驳回、转办等能力，并实现 <strong>\"新增用户需走审批流程\"</strong> 的业务闭环。</p>\n<h2 id=\"二为什么不用-elsa-workflows\">二、为什么不用 Elsa Workflows？</h2>\n<p>在技术选型阶段，我们对比了 Elsa Workflows 和自建方案：</p>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>Elsa Workflows</th>\n<th>自建方案</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>功能丰富度</td>\n<td>自带可视化设计器、条件分支、定时触发等</td>\n<td>按需实现，功能精简</td>\n</tr>\n<tr>\n<td>学习成本</td>\n<td>需理解 Elsa 活动模型、序列化机制</td>\n<td>复用现有 DDD 模式，团队零成本</td>\n</tr>\n<tr>\n<td>架构耦合</td>\n<td>引入独立的持久化层和运行时</td>\n<td>完全融入现有分层架构</td>\n</tr>\n<tr>\n<td>前端集成</td>\n<td>自带 Blazor/React 设计器，与 Vue 生态不匹配</td>\n<td>原生 Vue 3 + Ant Design Vue</td>\n</tr>\n<tr>\n<td>数据库</td>\n<td>默认 SQLite，MySQL 支持需额外配置</td>\n<td>复用现有 EF Core + MySQL</td>\n</tr>\n<tr>\n<td>.NET 版本</td>\n<td>Elsa 3.x 对 .NET 10 的兼容性需验证</td>\n<td>无兼容性风险</td>\n</tr>\n</tbody>\n</table>\n<p>最终选择了 <strong>自建方案</strong> —— 对于审批类工作流，核心逻辑并不复杂，而自建方案可以完美融入现有 DDD 架构，代码风格统一，维护成本更低。</p>\n<h2 id=\"三领域模型设计\">三、领域模型设计</h2>\n<h3 id=\"31-聚合根划分\">3.1 聚合根划分</h3>\n<p>工作流系统划分为两个聚合：</p>\n<pre><code>WorkflowDefinition (流程定义聚合)\n├── WorkflowDefinitionId    // 强类型 ID\n├── Name / Description / Category\n├── Status (Draft → Published → Archived)\n├── Version\n├── Nodes: ICollection&lt;WorkflowNode&gt;  // 流程节点（值对象集合）\n└── 领域方法: Publish(), Archive(), GetFirstApprovalNode(), GetNextApprovalNode()\n\nWorkflowInstance (流程实例聚合)\n├── WorkflowInstanceId      // 强类型 ID\n├── WorkflowDefinitionId    // 关联定义\n├── BusinessKey / BusinessType\n├── Status (Running → Completed/Rejected/Cancelled)\n├── Variables               // 业务数据 JSON\n├── Tasks: ICollection&lt;WorkflowTask&gt;   // 审批任务集合\n└── 领域方法: CreateTask(), ApproveTask(), RejectTask(), TransferTask(), Complete()\n</code></pre>\n<h3 id=\"32-强类型-id\">3.2 强类型 ID</h3>\n<p>与项目现有模式一致，所有聚合根使用强类型 ID：</p>\n<pre><code class=\"language-csharp\">public partial record WorkflowDefinitionId : IGuidStronglyTypedId;\npublic partial record WorkflowInstanceId : IGuidStronglyTypedId;\n</code></pre>\n<h3 id=\"33-流程定义聚合根\">3.3 流程定义聚合根</h3>\n<p><code>WorkflowDefinition</code> 是流程模板的聚合根，封装了状态管理和 <strong>流程流转的领域逻辑</strong>：</p>\n<pre><code class=\"language-csharp\">public class WorkflowDefinition : Entity&lt;WorkflowDefinitionId&gt;, IAggregateRoot\n{\n    public WorkflowDefinitionStatus Status { get; private set; }\n    public virtual ICollection&lt;WorkflowNode&gt; Nodes { get; init; } = [];\n\n    // 状态变更 + 领域事件\n    public void Publish()\n    {\n        if (Status == WorkflowDefinitionStatus.Published)\n            throw new KnownException(\"流程定义已经发布\", ErrorCodes.WorkflowDefinitionAlreadyPublished);\n\n        Status = WorkflowDefinitionStatus.Published;\n        AddDomainEvent(new WorkflowDefinitionPublishedDomainEvent(this));\n    }\n\n    // 流程流转逻辑下沉到聚合根（而非 Handler）\n    public WorkflowNode? GetFirstApprovalNode()\n        =&gt; GetOrderedApprovalNodes().FirstOrDefault();\n\n    public WorkflowNode? GetNextApprovalNode(string currentNodeName)\n    {\n        var orderedNodes = GetOrderedApprovalNodes();\n        var currentIndex = orderedNodes.ToList().FindIndex(n =&gt; n.NodeName == currentNodeName);\n        return (currentIndex &gt;= 0 &amp;&amp; currentIndex &lt; orderedNodes.Count - 1)\n            ? orderedNodes[currentIndex + 1]\n            : null;\n    }\n}\n</code></pre>\n<blockquote>\n<p><strong>DDD 要点</strong>：流转逻辑（获取首节点、下一节点）放在 <code>WorkflowDefinition</code> 聚合根而非 Command Handler 中。Handler 只负责编排调度，领域逻辑由聚合根保护。</p>\n</blockquote>\n<h3 id=\"34-流程实例聚合根\">3.4 流程实例聚合根</h3>\n<p><code>WorkflowInstance</code> 管理一次具体的审批流程执行：</p>\n<pre><code class=\"language-csharp\">public class WorkflowInstance : Entity&lt;WorkflowInstanceId&gt;, IAggregateRoot\n{\n    public string Variables { get; private set; } = \"{}\"; // 业务数据 JSON\n\n    public WorkflowTask CreateTask(string nodeName, WorkflowTaskType taskType,\n        UserId assigneeId, string assigneeName)\n    {\n        var task = new WorkflowTask(nodeName, taskType, assigneeId, assigneeName);\n        Tasks.Add(task);\n        CurrentNodeName = nodeName;\n        AddDomainEvent(new WorkflowTaskCreatedDomainEvent(this, task));\n        return task;\n    }\n\n    public void ApproveTask(WorkflowTaskId taskId, UserId operatorId, string comment)\n    {\n        var task = Tasks.FirstOrDefault(t =&gt; t.Id == taskId)\n            ?? throw new KnownException(\"未找到该任务\", ErrorCodes.WorkflowTaskNotFound);\n        task.Approve(comment);\n        AddDomainEvent(new WorkflowTaskCompletedDomainEvent(this, task));\n    }\n\n    public void Complete()\n    {\n        Status = WorkflowInstanceStatus.Completed;\n        CompletedAt = DateTimeOffset.UtcNow;\n        AddDomainEvent(new WorkflowInstanceCompletedDomainEvent(this));\n    }\n}\n</code></pre>\n<h2 id=\"四cqrs-命令与查询\">四、CQRS 命令与查询</h2>\n<h3 id=\"41-发起流程命令\">4.1 发起流程命令</h3>\n<p><code>StartWorkflowCommand</code> 演示了 Handler 如何 <strong>编排</strong> 聚合根交互：</p>\n<pre><code class=\"language-csharp\">public class StartWorkflowCommandHandler(\n    IWorkflowDefinitionRepository definitionRepository,\n    IWorkflowInstanceRepository instanceRepository)\n    : ICommandHandler&lt;StartWorkflowCommand, WorkflowInstanceId&gt;\n{\n    public async Task&lt;WorkflowInstanceId&gt; Handle(StartWorkflowCommand request, CancellationToken ct)\n    {\n        var definition = await definitionRepository.GetAsync(request.WorkflowDefinitionId, ct)\n            ?? throw new KnownException(\"未找到流程定义\");\n\n        // 创建实例\n        var instance = new WorkflowInstance(\n            request.WorkflowDefinitionId, definition.Name,\n            request.BusinessKey, request.BusinessType,\n            request.Title, request.InitiatorId, request.InitiatorName,\n            request.Variables, request.Remark);\n\n        await instanceRepository.AddAsync(instance, ct);\n\n        // 通过聚合根领域方法获取第一个审批节点（逻辑在 Definition 中）\n        var firstNode = definition.GetFirstApprovalNode();\n        if (firstNode != null &amp;&amp; long.TryParse(firstNode.AssigneeValue, out var id))\n        {\n            instance.CreateTask(firstNode.NodeName, WorkflowTaskType.Approval,\n                new UserId(id), string.Empty);\n        }\n\n        return instance.Id;\n    }\n}\n</code></pre>\n<h3 id=\"42-审批命令--自动流转\">4.2 审批命令 — 自动流转</h3>\n<pre><code class=\"language-csharp\">public class ApproveTaskCommandHandler(\n    IWorkflowInstanceRepository instanceRepository,\n    IWorkflowDefinitionRepository definitionRepository) : ICommandHandler&lt;ApproveTaskCommand&gt;\n{\n    public async Task Handle(ApproveTaskCommand request, CancellationToken ct)\n    {\n        var instance = await instanceRepository.GetAsync(request.WorkflowInstanceId, ct);\n        instance.ApproveTask(request.TaskId, request.OperatorId, request.Comment);\n\n        var definition = await definitionRepository.GetAsync(instance.WorkflowDefinitionId, ct);\n        var approvedTask = instance.Tasks.First(t =&gt; t.Id == request.TaskId);\n\n        // 领域方法：获取下一节点\n        var nextNode = definition.GetNextApprovalNode(approvedTask.NodeName);\n\n        if (nextNode != null)\n        {\n            // 创建下一个审批任务\n            instance.CreateTask(nextNode.NodeName, WorkflowTaskType.Approval, ...);\n        }\n        else\n        {\n            // 所有节点审批完毕，流程完成\n            instance.Complete();\n        }\n    }\n}\n</code></pre>\n<h2 id=\"五领域事件驱动的业务自动化\">五、领域事件驱动的业务自动化</h2>\n<h3 id=\"51-领域事件定义\">5.1 领域事件定义</h3>\n<pre><code class=\"language-csharp\">public record WorkflowDefinitionPublishedDomainEvent(WorkflowDefinition WorkflowDefinition) : IDomainEvent;\npublic record WorkflowInstanceStartedDomainEvent(WorkflowInstance WorkflowInstance) : IDomainEvent;\npublic record WorkflowInstanceCompletedDomainEvent(WorkflowInstance WorkflowInstance) : IDomainEvent;\npublic record WorkflowTaskCreatedDomainEvent(WorkflowInstance WorkflowInstance, WorkflowTask WorkflowTask) : IDomainEvent;\npublic record WorkflowTaskCompletedDomainEvent(WorkflowInstance WorkflowInstance, WorkflowTask WorkflowTask) : IDomainEvent;\n</code></pre>\n<h3 id=\"52-审批通过后自动执行业务操作\">5.2 审批通过后自动执行业务操作</h3>\n<p>这是整个系统的亮点设计 —— 通过领域事件实现 <strong>流程与业务的解耦</strong>：</p>\n<pre><code class=\"language-csharp\">public class WorkflowInstanceCompletedDomainEventHandler(IMediator mediator, RoleQuery roleQuery)\n    : IDomainEventHandler&lt;WorkflowInstanceCompletedDomainEvent&gt;\n{\n    public async Task Handle(WorkflowInstanceCompletedDomainEvent domainEvent, CancellationToken ct)\n    {\n        var instance = domainEvent.WorkflowInstance;\n        if (instance.Status != WorkflowInstanceStatus.Completed) return;\n\n        switch (instance.BusinessType)\n        {\n            case \"CreateUser\":\n                await HandleCreateUser(instance, ct);\n                break;\n            // 后续可扩展：case \"PurchaseOrder\": ...\n        }\n    }\n\n    private async Task HandleCreateUser(WorkflowInstance instance, CancellationToken ct)\n    {\n        // 从 Variables JSON 中反序列化用户数据\n        var userData = JsonSerializer.Deserialize&lt;CreateUserVariables&gt;(instance.Variables);\n\n        // 复用现有的 CreateUserCommand\n        var cmd = new CreateUserCommand(\n            userData.Name, userData.Email, userData.Password, ...);\n        await mediator.Send(cmd, ct);\n    }\n}\n</code></pre>\n<blockquote>\n<p><strong>设计思想</strong>：前端提交审批时，将完整的业务数据（如用户信息）序列化为 JSON 存入 <code>Variables</code> 字段。审批通过后，领域事件处理器从 <code>Variables</code> 中反序列化数据，调用对应的业务 Command 完成操作。这样 <strong>工作流引擎本身不需要了解任何业务细节</strong>，新增业务类型只需在 <code>switch</code> 中扩展即可。</p>\n</blockquote>\n<h2 id=\"六前端可视化节点设计器\">六、前端可视化节点设计器</h2>\n<h3 id=\"61-设计思路\">6.1 设计思路</h3>\n<p>传统的做法是让用户编辑 JSON 来配置流程节点，这显然不够友好。我们实现了一个 <strong>基于竖向流程图的可视化节点设计器</strong>：</p>\n<pre><code>    [▶ 开始]\n       │\n       ↓\n  ┌──────────────┐\n  │ ✓ 主管审批     │  ← 可编辑卡片\n  │ 类型: 审批     │\n  │ 处理人: 张三   │\n  └──────────────┘\n       │\n      (+)           ← 点击插入新节点\n       │\n  ┌──────────────┐\n  │ ✓ 总监审批     │\n  │ 类型: 审批     │\n  │ 处理人: 李四   │\n  └──────────────┘\n       │\n       ↓\n    [■ 结束]\n</code></pre>\n<h3 id=\"62-组件实现\">6.2 组件实现</h3>\n<p><code>node-designer.vue</code> 是一个完整的 Vue 3 组件，核心设计如下：</p>\n<p><strong>交互能力</strong>：</p>\n<ul>\n<li>添加节点（顶部、中间、底部均可插入）</li>\n<li>删除节点（带 Popconfirm 二次确认）</li>\n<li>上下移动节点（调整审批顺序）</li>\n<li>配置节点属性（名称、类型、处理人类型、处理人）</li>\n<li>已发布流程只读，不可编辑</li>\n</ul>\n<p><strong>视觉设计</strong>：</p>\n<ul>\n<li>开始/结束节点使用渐变色圆形标识</li>\n<li>节点卡片顶部彩色色条标识类型（蓝色=审批、绿色=抄送、橙色=通知）</li>\n<li>连接线带有方向箭头</li>\n<li>悬浮动效（卡片微浮、操作按钮渐显、添加按钮缩放高亮）</li>\n<li>表单双列布局节省空间</li>\n</ul>\n<p><strong>核心代码片段</strong>：</p>\n<pre><code class=\"language-typescript\">// 节点类型视觉配置\nconst nodeTypeConfig: Record&lt;number, { color: string; bg: string; icon: string }&gt; = {\n  1: { color: '#1677ff', bg: '#e6f4ff', icon: '✓' },  // 审批\n  2: { color: '#52c41a', bg: '#f6ffed', icon: '📋' },  // 抄送\n  3: { color: '#faad14', bg: '#fffbe6', icon: '🔔' },  // 通知\n};\n</code></pre>\n<h3 id=\"63-分类下拉选择\">6.3 分类下拉选择</h3>\n<p>流程定义的「分类」字段从自由文本输入改为下拉选择，统一维护枚举值：</p>\n<pre><code class=\"language-typescript\">export function useCategoryOptions() {\n  return [\n    { label: '用户管理', value: 'UserManagement' },\n    { label: '角色管理', value: 'RoleManagement' },\n    { label: '请假审批', value: 'LeaveRequest' },\n    { label: '采购审批', value: 'PurchaseOrder' },\n    { label: '报销审批', value: 'Reimbursement' },\n    { label: '通用流程', value: 'General' },\n  ];\n}\n</code></pre>\n<p>前端查找对应流程定义时使用枚举值精确匹配，不再依赖中文字符串：</p>\n<pre><code class=\"language-typescript\">const userCreateDef = definitions.find(\n  (d) =&gt; d.category === 'UserManagement',\n);\n</code></pre>\n<h2 id=\"七操作指南如何创建流程与审批\">七、操作指南：如何创建流程与审批</h2>\n<p>下面从使用角度说明：<strong>如何创建一条自定义工作流程</strong>，以及 <strong>审批人在哪里处理待办</strong>。</p>\n<h3 id=\"71-如何创建一个自定义工作流程\">7.1 如何创建一个自定义工作流程</h3>\n<ol>\n<li>进入 <strong>工作流管理 → 流程定义</strong>。</li>\n<li>点击 <strong>新增</strong>，打开流程定义表单。</li>\n<li>填写 <strong>流程名称</strong>、<strong>分类</strong>（从下拉选择，如「用户管理」「请假审批」等）、<strong>描述</strong>。</li>\n<li>在 <strong>流程节点设计</strong> 区域配置审批节点：\n<ul>\n<li>点击「+ 添加节点」或节点之间的「+」插入节点；</li>\n<li>为每个节点填写 <strong>节点名称</strong>，选择 <strong>节点类型</strong>（审批 / 抄送 / 通知）；</li>\n<li>选择 <strong>处理人类型</strong>（指定用户、指定角色、部门主管、发起人自选），若为指定用户或指定角色，再选择具体 <strong>处理人</strong>；</li>\n<li>通过 <strong>上移 / 下移</strong> 调整节点顺序，通过 <strong>删除</strong> 移除节点。</li>\n</ul>\n</li>\n<li>保存后，在列表中找到该流程，点击 <strong>发布</strong>。只有已发布的流程才能被发起。</li>\n</ol>\n<p><img alt=\"流程定义列表与编辑\" src=\"https://img2024.cnblogs.com/blog/553504/202602/553504-20260206174444280-259695173.png\" /></p>\n<p><em>流程定义列表：可新增、编辑、发布、归档；编辑时在下方进行流程节点设计。</em></p>\n<h3 id=\"72-在哪里审批\">7.2 在哪里审批</h3>\n<p>审批人的待办任务在 <strong>工作流管理 → 我的待办</strong> 中处理：</p>\n<ol>\n<li>登录后进入 <strong>工作流管理</strong> 菜单，点击 <strong>我的待办</strong>。</li>\n<li>列表中展示当前用户作为处理人的所有待审批任务（流程标题、流程名称、发起人、节点名称等）。</li>\n<li>点击 <strong>办理</strong> 进入详情，可查看流程信息与业务数据（如用户申请内容），进行 <strong>通过</strong>、<strong>驳回</strong> 或 <strong>转办</strong> 操作。</li>\n<li>已处理的任务可在 <strong>我的已办</strong> 中查看历史记录。</li>\n</ol>\n<p><img alt=\"我的待办\" src=\"https://img2024.cnblogs.com/blog/553504/202602/553504-20260206174503542-837619307.png\" /></p>\n<p><em>我的待办：审批人在此处理待审批任务。</em></p>\n<h2 id=\"八新增用户走审批流程--完整链路\">八、新增用户走审批流程 — 完整链路</h2>\n<p>这是一个典型的端到端示例，展示工作流如何与具体业务打通：</p>\n<h3 id=\"81-前端--提交审批\">8.1 前端 — 提交审批</h3>\n<p>在 <strong>系统管理 → 用户管理</strong> 的新增用户表单中，提供「提交审批」按钮。用户填写完账号、姓名、角色等信息后，可选择直接保存（若有权限）或 <strong>提交审批</strong>。点击「提交审批」后：</p>\n<ol>\n<li>验证表单数据</li>\n<li>查询已发布的流程定义，匹配分类为「用户管理」的定义</li>\n<li>将用户表单数据 JSON 序列化为 <code>variables</code></li>\n<li>调用 <code>startWorkflow</code> API 发起审批</li>\n</ol>\n<p><img alt=\"用户管理-提交审批\" src=\"https://img2024.cnblogs.com/blog/553504/202602/553504-20260206174554266-1617952302.png\" /></p>\n<p><em>新增用户时可选择「提交审批」，进入已配置的用户管理审批流程。</em></p>\n<pre><code class=\"language-typescript\">async function onSubmitForApproval() {\n  const { valid } = await formApi.validate();\n  if (!valid) return;\n\n  const definitions = await getPublishedDefinitions();\n  const userCreateDef = definitions.find(d =&gt; d.category === 'UserManagement');\n\n  const formValues = await formApi.getValues();\n  const variables = JSON.stringify({\n    name: formValues.name,\n    email: formValues.email,\n    password: formValues.password,\n    realName: formValues.realName,\n    roleIds: formValues.roleIds || [],\n    // ... 其他字段\n  });\n\n  await startWorkflow({\n    workflowDefinitionId: userCreateDef.id,\n    businessKey: `user-create-${Date.now()}`,\n    businessType: 'CreateUser',\n    title: `新增用户申请 - ${formValues.realName}`,\n    variables,\n  });\n}\n</code></pre>\n<h3 id=\"82-后端--审批流转\">8.2 后端 — 审批流转</h3>\n<pre><code>提交审批 → StartWorkflowCommand\n         → 创建 WorkflowInstance\n         → Definition.GetFirstApprovalNode() → 创建第一个 Task\n\n审批通过 → ApproveTaskCommand\n         → Instance.ApproveTask()\n         → Definition.GetNextApprovalNode()\n         → 有下一节点 → 创建新 Task\n         → 无下一节点 → Instance.Complete()\n                       → 触发 WorkflowInstanceCompletedDomainEvent\n\n领域事件 → WorkflowInstanceCompletedDomainEventHandler\n         → BusinessType == \"CreateUser\"\n         → 反序列化 Variables → CreateUserCommand → 用户创建成功\n</code></pre>\n<h3 id=\"83-流程图\">8.3 流程图</h3>\n<pre><code>[用户填写表单] → [提交审批] → [主管审批] → [总监审批] → [审批通过]\n                                                         ↓\n                                                   [领域事件触发]\n                                                         ↓\n                                                  [自动创建用户]\n</code></pre>\n<h2 id=\"九架构亮点总结\">九、架构亮点总结</h2>\n<h3 id=\"91-ddd-原则贯穿始终\">9.1 DDD 原则贯穿始终</h3>\n<table>\n<thead>\n<tr>\n<th>原则</th>\n<th>实践</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>聚合根封装</td>\n<td>状态变更、流转逻辑、业务规则校验均在聚合根内</td>\n</tr>\n<tr>\n<td>领域事件</td>\n<td>每个关键状态变更都发布对应领域事件</td>\n</tr>\n<tr>\n<td>强类型 ID</td>\n<td><code>WorkflowDefinitionId</code>、<code>WorkflowInstanceId</code> 避免 ID 误用</td>\n</tr>\n<tr>\n<td>值对象</td>\n<td><code>WorkflowNode</code> 作为 <code>WorkflowDefinition</code> 的子实体集合</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"92-cqrs-分离清晰\">9.2 CQRS 分离清晰</h3>\n<ul>\n<li><strong>Command 侧</strong>：<code>StartWorkflowCommand</code>、<code>ApproveTaskCommand</code>、<code>RejectTaskCommand</code> 等，Handler 只做编排</li>\n<li><strong>Query 侧</strong>：<code>WorkflowDefinitionQuery</code>、<code>WorkflowInstanceQuery</code>，使用 <code>AsNoTracking()</code> 优化性能，配合 <code>IMemoryCache</code> 缓存高频数据</li>\n</ul>\n<h3 id=\"93-业务与流程解耦\">9.3 业务与流程解耦</h3>\n<pre><code>工作流引擎（通用）          业务处理（特定）\n─────────────────         ─────────────────\nWorkflowInstance           ↗ CreateUserCommand\n  .Complete()              │\n  → DomainEvent  ──────→  EventHandler (switch BusinessType)\n                           │\n                           ↘ 其他业务 Command\n</code></pre>\n<p>新增业务类型时：</p>\n<ol>\n<li>前端新增提交入口，传入 <code>businessType</code> 和 <code>variables</code></li>\n<li>后端在 <code>WorkflowInstanceCompletedDomainEventHandler</code> 的 <code>switch</code> 中增加分支</li>\n<li>流程引擎本身无需任何修改</li>\n</ol>\n<h3 id=\"94-前端体验优化\">9.4 前端体验优化</h3>\n<ul>\n<li>可视化节点设计器替代 JSON 编辑，降低使用门槛</li>\n<li>分类枚举化，避免自由文本带来的匹配错误</li>\n<li>i18n 国际化支持中英文</li>\n<li>已发布流程自动锁定为只读模式</li>\n</ul>\n<h2 id=\"十后续规划\">十、后续规划</h2>\n<ol>\n<li><strong>条件分支节点</strong>：根据表单字段值走不同审批路径</li>\n<li><strong>会签/或签</strong>：一个节点可配置多个审批人</li>\n<li><strong>审批催办</strong>：基于 Hangfire 定时检查超时任务</li>\n<li><strong>流程统计看板</strong>：审批效率、瓶颈节点分析</li>\n<li><strong>移动端适配</strong>：审批任务推送 + 移动端快速审批</li>\n</ol>\n<h2 id=\"十一结语\">十一、结语</h2>\n<p>一套好的工作流系统，核心不在于功能有多丰富，而在于 <strong>与现有架构的融合度</strong> 和 <strong>业务扩展的便捷性</strong>。</p>\n<p>本次实践证明，在 Clean Architecture + DDD 的项目中，自建轻量级工作流是完全可行的。通过聚合根封装流转逻辑、领域事件驱动业务自动化、CQRS 分离读写关注点，我们用不到 2000 行后端代码就实现了一套 <strong>可用、可扩展、架构一致</strong> 的审批系统。</p>\n<p>前端方面，一个 600 行的 Vue 组件就搭建起了直观的可视化节点设计器，配合 Ant Design Vue 的组件库，用户体验也做到了开箱即用。</p>\n<p><strong>不是所有场景都需要引入重量级的工作流引擎，适合的才是最好的。</strong></p>\n<hr />\n<p>项目源码地址：<a href=\"https://github.com/zhouda1fu/Ncp.Admin\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/zhouda1fu/Ncp.Admin</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-06 17:48</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aishangyipiyema\">红泥巴煮雪</a>&nbsp;\n阅读(<span id=\"post_view_count\">107</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}