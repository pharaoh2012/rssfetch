{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "GIS中的“高度”到底指什么？一文厘清正高、正常高与大地高的区别",
      "link": "https://www.cnblogs.com/charlee44/p/19458808",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/charlee44/p/19458808\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 21:56\">\n    <span>GIS中的“高度”到底指什么？一文厘清正高、正常高与大地高的区别</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        深入解析 GIS 中高程参考系统的核心概念——大地水准面、似大地水准面与参考椭球面的关系，厘清正高、正常高与大地高的区别及转换方法，并介绍我国高程基准与全球重力模型。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p><strong>节选自《GIS基础原理与技术实践》第2章 地理空间参考系统</strong><br />\n作者原创内容，转载请注明出处。</p>\n</blockquote>\n<p><img alt=\"GIS基础原理与技术实践\" class=\"lazyload\" /></p>\n<h2 id=\"23-高程参考系统\">2.3 高程参考系统</h2>\n<p>使用经度和纬度表示的地理坐标系是一种水平坐标系统（这里的水平坐标系统并不表示其就是平面坐标系的意思，更准确的含义是其表达了三维空间坐标系的两个维度），缺少对于第三维度也就是高程的参考，也就是本节我们要介绍的：高程参考系统。高程参考系统是一种垂直坐标系。</p>\n<h3 id=\"231-大地水准面\">2.3.1 大地水准面</h3>\n<p>我们知道，参考椭球体是对地球表面的一种逼近。那么问题来了，参考椭球体是用喜马拉雅山所在的高度进行逼近，还是以马里亚纳海沟的高度进行逼近？答案肯定都不是。其实，这其中还隐藏了另一个逼地球自然表面的参考面，那就是本节我们要讲的——大地水准面（Geoid）。</p>\n<p>地理坐标系的第三维度通常使用海拔高度（Elevation），而不是到球心的距离。然而问题在于，高度的值是一个相对量，需要一个起算点。并且，这个高度必须沿着重力方向（铅锤方向）才有物理意义（想一想为什么建筑物总是要修的与地面垂直）。我们说到“海拔”这个名词，就会联想到高度的值应该是一个目标地物距离海平面的高差。事实也确实如此，我们可以定一个平均海平面作为高程的起算点，并且假设这个海平面完全静止，并且延伸到所有大陆下部，生成了一个密闭的曲面——这个曲面就是大地水准面。</p>\n<p>与参考椭球面不同的是，参考椭球面是数学模型得到的，处处平滑且平整；而大地水准面虽然平滑但不平整，是一个不规则但连续的闭合曲面。这其中的原因在于，地球质量分布不均匀，造成地球的引力场也是分布不均的。假设地球球体完全被水覆盖，水的高度也不会是完全一样：在地球局部密度更大的地方，地球施加的引力就会越大，造成水位越高。换句话说，大地水准面是一个重力等势面，重力方向（铅垂方向）在其任何地方都与其表面垂直；由于质量（引力）不均，每个位置的铅垂方向不一样，结果就是大地水准面并不平整。如下图2.8所示。</p>\n<p><img alt=\"图2.8 大地水准面与旋转椭球体\" class=\"lazyload\" /></p>\n<h3 id=\"232-三级逼近\">2.3.2 三级逼近</h3>\n<p>现在我们已经有了大地水准面、参考椭球面和大地基准面。那么它们的关系是如何呢？简单来说，它们共同组成了对地球自然表面的三级逼近。</p>\n<ul>\n<li>大地水准面是对地球自然表面的第一级逼近。大地水准面通过重力等势，确定了一个高程起算面，它远比地球自然表面平整得多，但是不是完全平整。地球自然表面具有从珠穆朗玛峰（+8800米）到马里亚纳海沟（-11,000米）的高差，但大地水准面与参考椭球面的偏差范围不超过200m（从+85米的冰岛到-106米的印度南部）。</li>\n<li>参考椭球面是对地球自然表面的第二级逼近。地球自然表面和大地水准面都是不规则的曲面，无法通过数学模型对其进行表达，这也意味着难以对其进行测算和分析。通过将大地水准面拟合成一个旋转椭球体，使我们可以对地球自然表面进行空间几何计算。参考椭球面是测量计算的基准面。</li>\n<li>大地基准面是对地球自然表面的第三极逼近。参考椭球体是对地球球体的抽象，但大地基准面解决的是这个参考椭球体如何摆放的问题：大地基准面要么与地球自然表面的局部区域具有较好的重合度，以便解决局部区域精度的问题；要么让椭球体中心位于地球质心，以便具有全球范围可使用的便捷性。</li>\n</ul>\n<h3 id=\"233-高程系统\">2.3.3 高程系统</h3>\n<h4 id=\"1-似大地水准面\">1 似大地水准面</h4>\n<p>如前所述，大地水准面确定了高程的起算面。那么，地球表面上一点到大地水准面必然有一个高度，这个高度就是正高（Orthometric Height）。正高就是我们通常意义上所说的海拔或者海拔高度，也叫做高程（Elevation）。这个高程系统就是正高系统。</p>\n<p>然而，大地水准面的问题是其仅仅只是一个理想化的模型，是不能准确测量的。客观地说，大地水准面所假想的大陆下部的海平面无法被量测，没有现实意义。为了解决这个问题，就引入了一个数学辅助面：似大地水准面（Quasi-geoid）。似大地水准面采用平均正常重力值来拟合水准面曲线（大地某一点的重力值无法精确求取），导致两者在海洋上完全重合，在大陆上有2 ~ 4米的微小差异。如果不能理解不要紧，我们可以定性的理解：似大地水准面是对大地水准面的数学近似，似大地水准面可以精确求得，大地水准面不可以精确求得。</p>\n<p>同样的，地球表面上一点到似大地水准面也有一个高度，我们把这个高度叫做正常高（Normal height），其高程就是正常高系统。正因为似大地水准面是大地水准面得近似且可求取，所以一般使用正常高来替代正高，正常高系统结果也可以称为海拔高度。我国目前采用的法定高程系统就是正常高系统。</p>\n<p>正高和正常高，大地水准面和似大地水准面的示意图如下图2.9所示：</p>\n<p><img alt=\"图2.9 正高、正常高与大地高\" class=\"lazyload\" /></p>\n<h4 id=\"2-高程系统\">2 高程系统</h4>\n<p>如图2.9中所示，除了正高系统和正常高系统，还有一类常用的高程系统就是大地高系统。所谓大地高，指的是以参考椭球面为基准面的高程系统，其值是地面上一点沿该点的椭球面法线到参考椭球面的距离。大地高也称为椭球高。</p>\n<p>虽然我们一般采用的高程系统是正常高系统，但在实际的使用过程中，有的时候知道正常高需要计算大地高，有的时候又需要通过大地高来计算正常高。一个很典型的例子就是，GPS（Global Positioning System，全球定位系统）获取的高程一般是大地高，那么如何得到我们想要的正常高呢？</p>\n<p>如下表2.4所述，对于高程系统中变量，我们有如下定义：</p>\n\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\">符号</th>\n<th style=\"text-align: center;\">名称</th>\n<th style=\"text-align: center;\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(H_n\\)</span></td>\n<td style=\"text-align: center;\">正常高（Normal Height）</td>\n<td style=\"text-align: center;\">地面上一点沿重力方向到似大地水准面的距离</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(H_o\\)</span></td>\n<td style=\"text-align: center;\">正高 （Orthometric Height）</td>\n<td style=\"text-align: center;\">地面上一点沿重力方向到大地水准面的距离</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(H_g\\)</span></td>\n<td style=\"text-align: center;\">大地高（Geodetic Height）</td>\n<td style=\"text-align: center;\">地面上一点沿椭球面法线方向到参考椭球面的距离</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(\\zeta\\)</span></td>\n<td style=\"text-align: center;\">高程异常（Height Anomaly）</td>\n<td style=\"text-align: center;\">似大地水准面到参考椭球面的距离</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(N\\)</span></td>\n<td style=\"text-align: center;\">大地水准面差距（Geoid Undulation）</td>\n<td style=\"text-align: center;\">大地水准面到参考椭球面的距离</td>\n</tr>\n</tbody>\n</table>\n<p>将它们在示意图中标识，如下图2.10所示：<br />\n<img alt=\"图2.10 正高、正常高与大地高\" class=\"lazyload\" /></p>\n<p>根据图示很显然可以得到如下公式：</p>\n<p></p><div class=\"math display\">\\[H_g = H_n + \\zeta \\tag{2.6}\n\\]</div><p></p><p></p><div class=\"math display\">\\[H_g = H_o + N \\tag{2.7}\n\\]</div><p></p><p>回到之前提到的问题，GPS获取的高程为大地高<span class=\"math inline\">\\(H_g\\)</span>，那么再通过大地测量的方法，可以精确确定高程异常<span class=\"math inline\">\\(\\zeta\\)</span>，根据公式2.6，大地高减去高程异常就可以得到正常高<span class=\"math inline\">\\(H_n\\)</span>，正常高可以用来代替正高，正高即最常用的海拔高度。在实际的应用中，有时需要大地高，有时需要正常高，可根据上述公式灵活转换。</p>\n<h4 id=\"3-高程基准\">3 高程基准</h4>\n<p>如2.3.1节所述，大地水准面使用一个假想的平均海平面作为高程起点（基准），这个平均海面可以通过在各地的验潮站观测、计算、综合得到。我国根据实际的观测结果之上，建立多个高程基准面，其中最常用的两个国家高程基准是：</p>\n<ul>\n<li>1956黄海高程基准，水准原点高程72.289米。</li>\n<li>1985国家高程基准，水准原点高程72.260米。</li>\n</ul>\n<p>目前，1985国家高程基准已经全部替代1956黄海高程基准，之前所有使用1956黄海高程基准的高程结果都需要通过下式2.8进行转换：</p>\n<p></p><div class=\"math display\">\\[H_{85} = H_{56} - 0.029\n\\]</div><p></p><p>此外，国际上通用的还有美国国家地理空间情报局（National Geospatial-Intelligence Agency，NGA）发布的EGM（Earth Gravitational Models，地球重力模型）大地水准面。这个大地水准面模型是综合利用现有全球大量重力数据计算出来的，适用于全球范围。目前已经发布了EGM84、EGM96、EGM2008和EGM2020四个版本。</p>\n<hr />\n<p>本文节选自作者新书《GIS基础原理与技术实践》第2章。书中系统讲解 GIS 核心理论与多语言实战，适合开发者与高校师生。</p>\n<p>📚 <strong>配套资源开源</strong>：<a href=\"https://github.com/fafa1899/GISBasic\" rel=\"noopener nofollow\" target=\"_blank\">GitHub</a> | <a href=\"https://gitcode.com/charlee44/GISBasic\" rel=\"noopener nofollow\" target=\"_blank\">GitCode</a></p>\n<p>🛒 <strong>支持正版</strong>：<a href=\"https://item.jd.com/14603137.html\" rel=\"noopener nofollow\" target=\"_blank\">京东</a>｜<a href=\"https://product.dangdang.com/29988568.html\" rel=\"noopener nofollow\" target=\"_blank\">当当</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 21:56</span>&nbsp;\n<a href=\"https://www.cnblogs.com/charlee44\">charlee44</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "吴恩达深度学习课程五：自然语言处理  第一周：循环神经网络 （四）RNN 中的梯度现象",
      "link": "https://www.cnblogs.com/Goblinscholar/p/19458774",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Goblinscholar/p/19458774\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 21:37\">\n    <span>吴恩达深度学习课程五：自然语言处理  第一周：循环神经网络 （四）RNN 中的梯度现象</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>此分类用于记录吴恩达深度学习课程的学习笔记。<br />\n课程相关信息链接如下：</p>\n<ol>\n<li>原课程视频链接：<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?buvid=XU762317353676D786954061C192FE625463B&amp;from_spmid=playlist.playlist-detail.0.0&amp;is_story_h5=false&amp;mid=zqernykrmpf7XfIorMR%2FnA%3D%3D&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=ce0bc526-db69-428a-962e-c65ed8c267bc&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1713085655&amp;unique_k=DfBgvFW&amp;up_id=8654113&amp;vd_source=e035e9878d32f414b4354b839a4c31a4\" rel=\"noopener nofollow\" target=\"_blank\">[双语字幕]吴恩达深度学习deeplearning.ai</a></li>\n<li>github课程资料，含课件与笔记:<a href=\"https://github.com/robbertliu/deeplearning.ai-andrewNG\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习教学资料</a></li>\n<li>课程配套练习（中英）与答案：<a href=\"https://blog.csdn.net/u013733326/article/details/79827273\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习课后习题与答案</a></li>\n</ol>\n<p>本篇为第五课的第一周内容，<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=158\" rel=\"noopener nofollow\" target=\"_blank\">1.8</a>的内容以及一些相关基础的补充。</p>\n<hr />\n<p>本周为第五课的第一周内容，与 CV 相对应的，这一课所有内容的中心只有一个：<strong>自然语言处理（Natural Language Processing，NLP）</strong>。<br />\n应用在深度学习里，它是专门用来进行<strong>文本与序列信息建模</strong>的模型和技术，本质上是在全连接网络与统计语言模型基础上的一次“结构化特化”，也是人工智能中<strong>最贴近人类思维表达方式</strong>的重要研究方向之一。<br />\n<strong>这一整节课同样涉及大量需要反复消化的内容，横跨机器学习、概率统计、线性代数以及语言学直觉。</strong><br />\n语言不像图像那样“直观可见”，更多是抽象符号与上下文关系的组合，因此<strong>理解门槛反而更高</strong>。<br />\n因此，我同样会尽量补足必要的背景知识，尽可能用比喻和实例降低理解难度。<br />\n本篇的内容关于<strong>RNN 中的梯度现象</strong>，是对 RNN 中存在的问题的阐述，也是对之后的门控机制的引入内容。</p>\n<h1 id=\"1-rnn-中的梯度现象\">1. RNN 中的梯度现象</h1>\n<p>在很久之前，我们就介绍过深度学习训练中的<a href=\"https://www.cnblogs.com/Goblinscholar/p/19190303\" target=\"_blank\">梯度现象</a>，这种情况主要出现在深层神经网络中，在反向传播中随着层层的梯度计算导致梯度过大或过小，从而出现梯度爆炸或者梯度消失，导致网络无法训练。<br />\n而在 RNN 中，即使是我们演示过的单层 RNN ，也可能产生梯度现象，而且这一问题会显得<strong>更加隐蔽，却也更加严重</strong>，其原因就在于 RNN 的<strong>时间反向传播</strong>特性。</p>\n<h2 id=\"11-rnn-的深度\">1.1 RNN 的深度</h2>\n<p>首先，我们知道：<strong>RNN 的“深度”并不体现在空间结构上，而是体现在时间维度上。</strong><br />\n因此，虽然我们画出来的 RNN 看起来只有一层，但在训练时，RNN 会在时间维度上被“展开”为一个<strong>共享参数的深层网络</strong>，就像这样：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260108213552905-491823195.png\" /></p>\n<p>也就是说，如果序列长度为 <span class=\"math inline\">\\(T\\)</span>，那么在反向传播时，梯度就需要沿着时间轴，从第 <span class=\"math inline\">\\(T\\)</span> 个时刻一路反传回第 <span class=\"math inline\">\\(1\\)</span> 个时刻。<br />\n需要说明的是，这里时间展开的长度 <span class=\"math inline\">\\(T\\)</span> 指的是 <strong>RNN 在时间维度上的递推步数</strong>，在我们介绍的基础 RNN 场景下，通常等同于输入序列的长度 <span class=\"math inline\">\\(T_x\\)</span>，而非生成序列的长度 <span class=\"math inline\">\\(T_y\\)</span>。<br />\n最终，从效果上看，这相当于：  <strong>同一组权重矩阵被反复相乘了 <span class=\"math inline\">\\(T\\)</span> 次。</strong></p>\n<p>因此，在 RNN 中，我们同样有必要了解训练中出现梯度现象的处理方法。</p>\n<h2 id=\"12-梯度爆炸的处理梯度裁剪gradient-clipping\">1.2 梯度爆炸的处理：梯度裁剪（Gradient Clipping）</h2>\n<p>在 RNN 的梯度问题中，<strong>梯度爆炸通常是最先、也是最容易被观察到的现象</strong>。<br />\n其表现非常直观：损失函数在训练过程中剧烈震荡，甚至直接变为 NaN，参数更新完全失控，模型无法继续训练。<br />\n与梯度消失不同，梯度爆炸并不是“学不到”，而是 <strong>“学得太猛”</strong>。<br />\n因此，相比梯度消失，梯度爆炸问题更容易被控制和缓解。这很好理解：东西多了我们可以扔，但少了我们不能凭空创造出来。<br />\n而其中一种最常见、也最直接的方法，就是<strong>梯度裁剪（Gradient Clipping）</strong>。</p>\n<p>梯度裁剪的思想非常简单，可以概括为一句话：</p>\n<blockquote>\n<p><strong>当梯度过大时，不让它继续放大更新幅度。</strong></p>\n</blockquote>\n<p>也就是说，我们并不试图改变梯度的“方向”，而只是<strong>限制梯度的“大小”</strong>，从而避免一次参数更新步长过大，破坏训练稳定性。</p>\n<p>再打个比方：在下坡骑车时，我们的方向是对的，但速度太快容易摔，所以我们通过“刹车”来控制风险。<br />\n梯度裁剪，本质上就是反向传播阶段的“数值刹车”。</p>\n<p>在实际使用中，最常见的是<strong>基于梯度范数（norm）的裁剪方式</strong>。<br />\n设所有参数的梯度拼接成一个向量 <span class=\"math inline\">\\(g\\)</span>，其 <strong><span class=\"math inline\">\\(L_2\\)</span> 范数</strong>为：</p>\n<p></p><div class=\"math display\">\\[\\lVert g \\rVert_=\\sqrt{g_1^2 + g_2^2 + \\cdots + g_n^2}  \n\\]</div><p></p><p>我们用 <strong><span class=\"math inline\">\\(L_2\\)</span> 范数</strong>衡量梯度的<strong>整体大小</strong>，它反映的是<strong>这一次反向传播中，参数更新“总体有多激进”</strong>。</p>\n<p>下一步，给定一个<strong>阈值 <span class=\"math inline\">\\(c\\)</span></strong>，梯度裁剪的规则是：</p>\n<p></p><div class=\"math display\">\\[g =\n\\begin{cases}\ng, &amp; \\lVert g \\rVert \\le c \\\\\n\\dfrac{c}{\\lVert g \\rVert} \\, g, &amp; \\lVert g \\rVert &gt; c\n\\end{cases}\n\\]</div><p></p><p>也就是说：</p>\n<ul>\n<li>如果梯度范数在可接受范围内：<strong>不做任何处理。</strong></li>\n<li>如果梯度范数超过阈值：<strong>整体缩放，使其范数恰好等于 <span class=\"math inline\">\\(c\\)</span>。</strong></li>\n</ul>\n<p>这样操作下来，你会发现：<strong>梯度裁剪并不会改变梯度各分量之间的相对比例，只是统一缩放其大小到合适程度。</strong></p>\n<p>这样，在反向传播中，梯度裁剪就会<strong>阻断“指数级放大”的最坏情况</strong>， 保证参数更新始终处在一个稳定区间，从而让训练过程“至少可以继续进行下去”。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260108213603856-931372748.png\" /><br />\n要强调的是：在实际训练中时，<strong>梯度裁剪几乎是默认配置</strong>，而不是可选技巧。</p>\n<p>但是，梯度裁剪也有其局限性：<strong>梯度裁剪只能缓解梯度爆炸，无法解决梯度消失。</strong><br />\n原因很简单：</p>\n<ul>\n<li>梯度爆炸是“数值过大”的问题 → 可以强行压缩</li>\n<li>梯度消失是“信号本身接近于 0” → 裁剪无能为力</li>\n</ul>\n<p>因此，对于梯度消失这一更常见也更难缓解的梯度现象，我们需要别的解决方案，这也是我们下面要讨论的主要内容。</p>\n<h1 id=\"2-rnn-中的梯度消失长距离依赖问题\">2. RNN 中的梯度消失：长距离依赖问题</h1>\n<p>我们知道，<a href=\"https://www.cnblogs.com/Goblinscholar/p/19449622\" target=\"_blank\">RNN</a> 擅长处理序列数据，并能够逐步积累历史信息。然而，在长序列训练中，梯度消失会让早期时间步的影响被逐渐“抹掉”，这就导致了著名的 <strong>长距离依赖问题</strong>：模型难以捕捉序列中相隔较远的信息。<br />\n我们用之前的反向传播例子来演示一下这个问题：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260108213553401-1851089098.png\" /><br />\n注意我们标红的字体：<strong>当序列过长时，与结尾距离很远的最初几步信息很难实现有效更新。因此梯度已经在层层连乘中所剩无几了。</strong><br />\n这样带来的后果是什么？来看看：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260108213555854-2054969424.png\" /></p>\n<p>这就是 RNN 中的梯度消失现象，<strong>它直接导致 RNN 难以捕捉序列中相隔较远的依赖关系</strong>，显然，这对模型性能的影响是巨大的。</p>\n<p>那么如何缓解 RNN 中的梯度消失现象？<br />\n你可能想到了我们之前介绍过的<a href=\"https://www.cnblogs.com/Goblinscholar/p/19359236\" target=\"_blank\">残差网络</a>，即通过在 RNN 中引入<strong>残差连接</strong>，为梯度提供了一条直接传递的通路，可以在一定程度上缓解梯度消失问题，使深层或长序列的训练更加稳定。这的确是一种可行的改进方案。但残差路径虽然提供了梯度直通通道，但<strong>无法进行信息选择性控制</strong>，对于非常长序列仍然存在梯度衰减。<br />\n因此，在 RNN 中，我们有一种更好的技术：<strong>门控机制</strong>，这是在实际实验和部署中我们更常使用的方法，它不仅能保持梯度稳定传递，还能智能控制信息流。<br />\n其原理较为复杂，我们经过本篇的引用，在下一篇来详细展开它。</p>\n<h1 id=\"3-总结\">3. 总结</h1>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>原理</th>\n<th>比喻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>梯度现象（Gradient Phenomena）</strong></td>\n<td>在深层网络或 RNN 的反向传播中，梯度可能过大或过小，导致训练不稳定，即梯度爆炸或梯度消失</td>\n<td>就像水流管道，如果水压过大管道爆裂，水压过小又无法输送水</td>\n</tr>\n<tr>\n<td><strong>RNN 的“深度”</strong></td>\n<td>RNN 在时间维度上展开为共享参数的深层网络，梯度需要沿时间轴反向传播，连续乘以权重矩阵 <span class=\"math inline\">\\(T\\)</span> 次</td>\n<td>好比一个接力赛，每一棒都必须传递能量，接力棒越多，总能量损耗越大</td>\n</tr>\n<tr>\n<td><strong>梯度裁剪（Gradient Clipping）</strong></td>\n<td>当梯度范数超过阈值 <span class=\"math inline\">\\(c\\)</span> 时，对梯度整体缩放，使其范数等于 <span class=\"math inline\">\\(c\\)</span>；不改变梯度方向，只调整大小</td>\n<td>就像给过快下坡的车装刹车，保持安全速度</td>\n</tr>\n<tr>\n<td><strong>RNN 的长距离依赖问题</strong></td>\n<td>梯度在层层连乘或长序列反向传播中逐渐趋近 0，早期时间步的影响被“抹掉”，导致长距离依赖难以学习</td>\n<td>像传话游戏，信息经过太多人，最开始的话慢慢被模糊甚至忘掉</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 21:37</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Goblinscholar\">哥布林学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">12</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "20250702 - FPC Token 攻击事件：严格的限制，灵活的黑客",
      "link": "https://www.cnblogs.com/ACaiGarden/p/19458550",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ACaiGarden/p/19458550\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 19:56\">\n    <span>20250702 - FPC Token 攻击事件：严格的限制，灵活的黑客</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"背景\">背景</h1>\n<p>FPC 是 BPE-20 项目，实现了复杂的交易机制，包括<strong>买卖手续费、流动性池燃烧机制、限制交易频率、限制交易数量</strong>等功能。漏洞产生的原因是当用户卖出代币时，<strong>合约会从流动性池中燃烧代币（而非从卖出者余额中燃烧）</strong>，导致池子中 FPC 代币数量减少，价格抬高。</p>\n<blockquote>\n<p>项目方应该是为了加上流动性池燃烧机制，发现直接加上这不行呀，这个会被利用去套利的。然后打了限制交易频率和限制交易数量两个补丁。希望以此来限制代币持有者通过机制进行获利。</p>\n</blockquote>\n<p>攻击交易</p>\n<ul>\n<li><strong>攻击交易哈希</strong>: <code>0x3a9dd216fb6314c013fa8c4f85bfbbe0ed0a73209f54c57c1aab02ba989f5937</code></li>\n<li><strong>攻击者地址</strong>: <code>0xbf6e706d505e81ad1f73bbc0babfe2b414ba3eb3</code></li>\n</ul>\n<p>漏洞合约</p>\n<ul>\n<li><strong>FPC代币合约</strong>: <code>0xb192d4a737430aa61cea4ce9bfb6432f7d42592f</code></li>\n<li><strong>主要流动性池</strong>: <code>0xa1e08e10eb09857a8c6f2ef6cca297c1a081ed6b</code></li>\n</ul>\n<h1 id=\"trace-分析\">Trace 分析</h1>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260108195418546-1108887978.png\" /></p>\n<ol>\n<li>\n<p>攻击者通过闪电贷获得大量的 USDT</p>\n</li>\n<li>\n<p>在 [FPC, USDT] 池子中购买大量的 FPC</p>\n</li>\n<li>\n<p>把 FPC 转移到新的地址中</p>\n</li>\n<li>\n<p>出售所有的 FPC：先触发<strong>流动性池燃烧机制</strong>，推高了 FPC 的价格，然后再计算出售获得的 USDT，从而获得超额的利润。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260108195438039-1592352059.png\" /></p>\n</li>\n</ol>\n<h1 id=\"代码分析\">代码分析</h1>\n<p>在背景介绍了 FPC 代币实现了<strong>流动性池燃烧机制、限制交易频率、限制交易数量</strong>等功能，接下来将会通过代码实现以及攻击者的手法向读者展示。</p>\n<h2 id=\"在-fpc-usdt-池子中购买大量的-fpc\">在 [FPC, USDT] 池子中购买大量的 FPC</h2>\n<p>在黑客购买 FPC 的操作中，黑客没有通过 router 进行兑换，而是直接调用 pool 进行兑换。</p>\n<pre><code class=\"language-markdown\">CALLCake-LP.swap(**amount0Out=1,000,000,000,000,000,000**, amount1Out=790,178,970,489,172,772,916,652)\n</code></pre>\n<p>并且在购买大量 FPC 代币的同时，还换出了 1 USDT。很反常的操作，如果只是为了购买 FPC，这个amount0Out 的值应为为 0。</p>\n<blockquote>\n<p>黑客这样做的目的是为了绕开最大购买数量的限制</p>\n</blockquote>\n<p>在直接通过 pool 大量购买 FPC 时同时换出 1 个 USDT，目的就为了欺骗 _isLiquidity 函数的检查，伪装成移除流动性的操作，使得 isDel 的值为 true。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260108195457477-1676036854.png\" /></p>\n<p>如果  isDel 的值为 true，就会绕过 <code>value &lt;= _maxBuyAmount()</code> 的限额检查了。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260108195511387-780783212.png\" /></p>\n<h2 id=\"把-fpc-转移到新的地址中\">把 FPC 转移到新的地址中</h2>\n<p>在 FPC 代币中，如果用户进行 swap 操作，会被记录下操作的区块号，并且限制 3 个区块内不允许再次交易。但是它没有对转账操作进行限制，所以攻击者可以通过把 FPC 转移到没有进行过 swap 的地址进行出售，从而绕过这个限制。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260108195529422-1735776335.png\" /></p>\n<h2 id=\"出售所有的-fpc触发流动性池燃烧机制\">出售所有的 FPC：触发<strong>流动性池燃烧机制</strong></h2>\n<p>这一步是关键的步骤，卖出 FPC 代币，触发合约的燃烧机制</p>\n<pre><code class=\"language-markdown\">CALLPancakeSwap: Router v2.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n  amountIn=247,441,170,766,403,071,054,109)\n</code></pre>\n<p>在 sell 的逻辑分支中，会调用 burnLpToken 函数按照出售的数量 value 来销毁 FPC 代币。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260108195542694-2016383265.png\" /></p>\n<p>而在 burnLpToken 函数函数中，燃烧的是 pool 中的代币（不是燃烧 seller 提供的代币，而是直接燃烧 pool 中的代币）。这样会使得 pool 中 FPC 的价格被推高。使得黑客在卖出 FPC 代币时能够获取到更多的利润。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260108195628531-1501728881.png\" /></p>\n<h1 id=\"后记\">后记</h1>\n<p>这个代币在添加流动性池燃烧机制的初衷应该是希望在用户出售代币的时候，啊把池子里面的代币取出来一点，一个是收归项目方所有，第二个是抬高一点币价不要跌的这么快。</p>\n<p>但是，但是在 Pancake 和 Uniswap 的 V2/V3 版本中，都是遵循着“先转账，后结算”的模式去进行 swap 的。而代币设置的各种机制只能在转账的过程中触发，这就使得了这个燃烧机制始终都是发生在结算前的，这就给了黑客套利的空间。如果想要实现这种特殊机制，可以考虑一下通过 Uniswap V4 的 Hook 去实现，但是会对开发的技术与质量要求更高（不得不说后续更新的版本都不如 V2 的 x * y = k 来得简单直接，叽里咕噜又集中流动性又 Hook 说啥呢，我 V2 一把加完流动性就能用。也是为什么直至现在很多代币的发行方都钟爱在 V2 上部署池子）。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 19:56</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ACaiGarden\">ACai_sec</a>&nbsp;\n阅读(<span id=\"post_view_count\">5</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "云原生AI算力平台的架构解读",
      "link": "https://www.cnblogs.com/JulianHuang/p/19458390",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/JulianHuang/p/19458390\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 18:41\">\n    <span>云原生AI算力平台的架构解读</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>给近半年做的云原生AI算力平台做一个回顾， 思考和实践参考了云溪大会上的分享：<a href=\"https://developer.aliyun.com/article/1414573\" rel=\"noopener nofollow\" target=\"_blank\" title=\"为大模型工程提效，基于阿里云 ACK 的云原生 AI 工程化实践\">为大模型工程提效，基于阿里云 ACK 的云原生 AI 工程化实践</a>，全文很长，我这边做一个牵引和解读。</p>\n</blockquote>\n<h2 id=\"1-云计算迎来智算时代\">1. 云计算迎来“智算”时代</h2>\n<p>云计算是一种<strong>通过互联网的方式按需提供计算资源（如服务器、存储、数据库、网络、软件等）</strong>的服务模式， 用户可以像使用水电气一样,按需购买、灵活付费，无需购买和维护物理设备。</p>\n<p>特征是① 按需自助服务 ② 广泛的网络访问 ③ 资源池化  ④ 快速弹性伸缩  ⑤ 使用量计费</p>\n<blockquote>\n<p>为什么叫“云计算”？<br />\n在冯诺依曼体系中，计算资源是CPU，但我们还是以“计算机”来指代包含计算、存储、网络、软件形成的完整服务器；<br />\n在云计算领域，“计算”一次被沿用，将传统计算机核心组件拆开虚拟化、池化，并提供了“用于信息处理所有软硬件要素的总和抽象”。</p>\n</blockquote>\n<p>今天的云计算已经承载了web应用、数据库、大数据、机器学习和高性能计算等计算负载。</p>\n<p>面对LLM和GAI这类对算力和数据都有极高需求的新负载，云计算也迎来了“智算”时代，<br />\n一方面以服务化资源池的概念提供万卡算力、PB级存储、和单机TB级高速网络互联，另一方面以云原生标准化交付算力给大模型的生产者和使用者。</p>\n<h2 id=\"2-大模型带来的挑战\">2. 大模型带来的挑战</h2>\n<p>AI有工程化的要求，同时也对基础设施提出挑战。<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108183944896-1604958658.png\" /><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108183950488-1199602426.png\" /></p>\n<h2 id=\"3-云原生ai的能力\">3. 云原生AI的能力</h2>\n<p>最近在做的“AI大模型基础设施”， 宏观目标也是帮助AI工程从小作坊向端到端云原生解决方案演进。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108183959371-1234056611.png\" /></p>\n<h3 id=\"统一管理异构资源提供资源利用率\">统一管理异构资源，提供资源利用率</h3>\n<p>对idc内各种异构计算（GPU、CPU、NPU等）、存储（OSS、NAS、CPFS、HDFS）、网络（TCP、RDMA）资源进行抽象，统一管理和运维和分配，通过软硬协同优化，提供资源利用率。</p>\n<h3 id=\"通过统一工作流--统一调度-实现ai大数据等复杂任务的高效管理\">通过①统一工作流 ② 统一调度， 实现AI/大数据等复杂任务的高效管理</h3>\n<ul>\n<li>\n<p>从异构资源管理的角度，可一键部署、操作各种异构资源，在运维过程中，需要多维度的异构资源可观测性： 监控、健康检查、告警、自愈等自动化运维能力</p>\n</li>\n<li>\n<p>对于宝贵的GPU/NPU算力资源，使用各种调度、隔离、共享的方式提供资源利用率</p>\n</li>\n<li>\n<p>分钟级准备好开发和测试环境，帮助算法工程师把 ①执行深度学习任务②产出/评测模型③模型部署 以端到端的工作流串起来， 天然支持主流框架 tensorflow/pytorchjob/mpi<br />\n--  对于分布式任务，提供丰富的任务调度策略，如Gang scheduling、Capacity scheduling、Topology aware scheduling、优先级队列等。</p>\n</li>\n<li>\n<p>提供弹性训练和弹性推理服务， 建立统一的数据集管理，模型生命周期管理， 优化模型访问性能，通过标准API使推理能力易于被业务应用集成。</p>\n</li>\n</ul>\n<h2 id=\"4-云原生ai的架构实践\">4. 云原生AI的架构实践</h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108184015761-1427603173.png\" /></p>\n<p>我们的云原生AI算力平台， 有参考上面的实践，针对企业业务的现状和侧重， 技术调研上做了调整和裁剪。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108184025350-220307939.png\" /></p>\n<p>没有从0到1的使用kubeflow全家桶，使用了arena、 kubeflow  trainer。</p>\n<blockquote>\n<p><a href=\"https://www.kubeflow.org/docs/started/architecture/\" rel=\"noopener nofollow\" target=\"_blank\" title=\"kubeflow\">kubeflow</a>是一个包含多个开源项目的AI生态组合， kubeflow以Kubernetes为底座，目标是成为部署、扩展和管理AI平台的系统。</p>\n</blockquote>\n<p>在平台侧，我们统一纳管了集群资源，实现了统一调度能力和模型生命周期管理，关联了公司自有的数据存储（涉及数据集预热、模型存储），<br />\n这里有一个技术点：Go动态感知资源变更的技术实践，你指定用过！</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108184044867-660442933.png\" /></p>\n<p>用户行为的触发点是arena， 我们使用arena提交了训练任务。 ref:  Golang 文本模板，你指定没用过!</p>\n<p>在调度侧，使用tranning operator和kerve组件，tranning operator 提供统一的训练工作流， kserve提供了将模型以云原生方式部署、扩缩容的能力。</p>\n<p>arena产生训练任务/部署动作---&gt; 内部helm形成对应的CRD（pytorchjob、InferenceService)---&gt;控制器监听CRD的变更---&gt; 生成底层资源（deploy/service/network)</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108184107591-1084626310.png\" /></p>\n<p>各算法团队天然对应租户概念，也就是k8s命名空间， 我们给租户下面每一个用户颁发了一个<a href=\"https://blog.miniasp.com/post/2022/08/24/Understanding-Service-Account-in-Kubernetes-through-MicroK8s\" rel=\"noopener nofollow\" target=\"_blank\" title=\"serviceAccount\">serviceAccount</a>作为登录和操作凭据。</p>\n<p>为实现自动任务调度，我们引入了kueue这样的任务队列组件，在任务被k8s调度器调度之前做准入，kueue成为了异构资源池化多租户配额、任务排队的技术支撑。</p>\n<p>有关kueue的使用，请参考：🎉在k8s调度的花园里面挖呀挖 。<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108184122928-1792259600.png\" /></p>\n<p>为适配AI工程化的调度要求，我们使用Koordinator调度器支持了binpack装箱调度。</p>\n<p>什么叫binpack， 为什么AI训练需要binpack， 请参考:🎉卷不过AI算法， AI工程化或许是一个出路？<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108184133179-1065900826.png\" /></p>\n<p>最后平台需要管控多渠道的任务，我们使用 informer机制监听了多渠道任务并回显到页面， 这里有个技术点，值得参考。</p>\n<p>🚀糟糕，我实现的k8s informer好像是依托答辩<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108184141433-1556621842.png\" /></p>\n<p><img alt=\"\" src=\"https://files.mdnice.com/user/4236/528d857f-9d29-4937-8275-20accf704f4e.png\" /></p>\n\n</div>\n<div id=\"MySignature\">\n    <hr color=\"#987cb9\" size=\"3\" width=\"80%\" />\n<div style=\"text-align: center;\">\n<p>本文来自博客园，作者：{有态度的马甲}，转载请注明原文链接：<a href=\"https://www.cnblogs.com/JulianHuang/p/19458390\" target=\"_blank\">https://www.cnblogs.com/JulianHuang/p/19458390</a></p>\n<strong style=\"color: red;\">欢迎关注我的原创技术、职场公众号， 加好友谈天说地，一起进化</strong>\n<div><img src=\"https://blog-static.cnblogs.com/files/JulianHuang/QR.gif\" style=\"width: 250px; height: 250px;\" /> </div>\n\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 18:41</span>&nbsp;\n<a href=\"https://www.cnblogs.com/JulianHuang\">码甲哥不卷</a>&nbsp;\n阅读(<span id=\"post_view_count\">2</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "JVM 堆内存分代",
      "link": "https://www.cnblogs.com/yanshajiuzhou/p/19458321",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yanshajiuzhou/p/19458321\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 18:25\">\n    <span>JVM 堆内存分代</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        不同存活周期的对象放在不同区域，用不同算法回收，保证 GC 效率，这就是&nbsp;\"分代回收\" 的核心思想。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><span>​</span>今天我们一起来聊一聊 <strong>JVM 堆内存</strong>。</p>\n<p><img alt=\"Java Heap1\" src=\"https://img2024.cnblogs.com/blog/1171560/202601/1171560-20260108182258403-1042762825.png\" /></p>\n<p><strong>Java Heap</strong>（堆内存）由 <strong>Young Generation</strong>（新生代，约占 <strong>1/3&nbsp;</strong>）和&nbsp;<strong>Old Generation</strong>（老年代，约占 <strong>2/3</strong> ）组成。</p>\n<p><strong>Young Generation </strong>又由&nbsp;<strong>Eden Space</strong>（伊甸园区，占新生代 <strong>80%&nbsp;</strong>）、<strong>Survivor Space 0</strong>（幸存者区0，占新生代 <strong>10%&nbsp;</strong>）和 <strong>Survivor Space 1</strong>（幸存者区1，占新生代 <strong>10%&nbsp;</strong>）组成。</p>\n<p><strong>对象的生命周期</strong>：</p>\n<p><img alt=\"对象生命周期\" src=\"https://img2024.cnblogs.com/blog/1171560/202601/1171560-20260108182353974-1428015339.png\" /></p>\n<p><strong>Young Generation</strong>（新生代）：</p>\n<ul>\n<li>存储 <strong>新创建</strong>、<strong>存活周期极短</strong> 的对象，比如方法内的局部变量、临时对象。默认占堆总容量 <strong>1/3 </strong>。</li>\n<li>触发 <strong>Minor GC</strong>（新生代 GC），频率极高（毫秒 / 秒级），但耗时极短（几十毫秒）。</li>\n<li>Eden 区是 Minor GC 的 \"触发源头\"，调大 Eden 区可减少 Minor GC 次数。</li>\n</ul>\n<p><strong>Eden Space</strong>（伊甸园区）：新对象的 \"默认出生地\"，<strong>99% 的新对象&nbsp;</strong>都会优先分配到 Eden 区（除非是超大对象直接进入老年代）。占新生代 <strong>80%&nbsp;</strong>。</p>\n<p><strong>Survivor Space 0/1</strong>（幸存者区 0/1，简称 S0/S1，也叫 From 区 / To 区）：</p>\n<ul>\n<li>新生代 GC 后存活对象的 <strong>\"临时中转站\"</strong>，避免存活对象直接进入老年代。<strong>两个区会动态互换角色</strong>。各占新生代 <strong>10%</strong>，合计 20%。</li>\n<li>S0 和 S1&nbsp;<strong>永远有一个是空的</strong>（这是 JVM 的设计巧思）。</li>\n<li>每经历一次 Minor GC，存活对象的 <strong>\"年龄 + 1\"</strong>。</li>\n</ul>\n<p><strong>S0/S1 的交互</strong> 示例：</p>\n<ul>\n<li>① 初始状态：Eden 有对象，S0 有对象，S1 为空；</li>\n<li>② Eden 触发 Minor GC → 回收 Eden+S0 的垃圾对象，存活对象复制到 S1，清空 Eden+S0；</li>\n<li>③ 此时 S1 非空、S0 为空，两者角色互换（S0=To 区，S1=From 区）；</li>\n<li>④ 下次 Minor GC 重复上述过程，存活对象在 S0/S1 之间 <strong>\"来回复制\"</strong>。</li>\n</ul>\n<p><strong>Old Generation</strong>（老年代）：</p>\n<ul>\n<li>存储&nbsp;<strong>长期存活、体积较大&nbsp;</strong>的对象，比如单例对象、缓存对象、经历多次 Minor GC 仍存活的对象。默认占堆总容量 <strong>2/3</strong>。</li>\n<li>触发&nbsp;<strong>Major GC / Full GC</strong>，频率极低，但耗时极长。</li>\n<li>老年代大小决定 Full GC 频率 —— 老年代越大，Full GC 频率越低，但单次 Full GC 耗时越长。</li>\n</ul>\n<p><strong>对象进入老年代的条件</strong>：</p>\n<ul>\n<li><strong>年龄达标</strong>：对象在 S0/S1 之间复制次数达到阈值（默认 15 次，<code>-XX:MaxTenuringThreshold</code>调整）；</li>\n<li><strong>大对象</strong>：超过阈值的对象（<code>-XX:PretenureSizeThreshold</code>）直接进入老年代；</li>\n<li><strong>空间担保失败</strong>：Minor GC 后 Survivor 区放不下存活对象，多余对象直接晋升老年代；</li>\n<li><strong>动态年龄判断</strong>：Survivor 区中相同年龄对象总和超过 50%，该年龄及以上对象直接进入老年代。</li>\n</ul>\n<p>不同存活周期的对象放在不同区域，用不同算法回收，保证 <strong>GC</strong> 效率，这就是&nbsp;<strong>\"分代回收\" </strong>的核心思想。</p>\n<p style=\"text-align: right;\"><span style=\"color: rgba(53, 152, 219, 1);\">努力的意义，不在于追逐别人的高度，而是拼尽全力，为自己创造一个绝地反击的故事。-- 烟沙九洲</span></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 18:25</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yanshajiuzhou\">烟沙九洲</a>&nbsp;\n阅读(<span id=\"post_view_count\">3</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "你们如何运行Agent生成的代码？或许你也需要一个Agent-Sandbox，Agent-Sandbox开源首发",
      "link": "https://www.cnblogs.com/xguo/p/19457007",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xguo/p/19457007\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 15:41\">\n    <span>你们如何运行Agent生成的代码？或许你也需要一个Agent-Sandbox，Agent-Sandbox开源首发</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"你们如何运行Agent生成的代码？或许你也需要一个Agent-Sandbox，Agent-Sandbox开源首发\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/57355/202601/57355-20260108145436183-1755523701.png\" />\n        Manus的高价出售，让Sandbox再次进入人们的视野，它之前用的Sandbox是E2B，这是一个非常强大的Sandbox工具，它可以帮助Agent执行代码或命令，但它不方便我们使用，之前我们的办法是部署一个Python的执行代码的服务，或着部署一个Playwright的服务，各自提供MCP或普通API，来满足需求，但是遇到的问题也是显而易见的，那就是无法实现多次访问的隔离，例如一个Agent访问了A网站，另一个Agent访问了B网站，就会相互干扰，性能也是问题，除非你部署很多实例，那也浪费。那我们的选择是什么？\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<div style=\"text-align: center;\">\n\n<img height=\"381px\" src=\"https://img2024.cnblogs.com/blog/57355/202601/57355-20260108144423805-386973583.png\" width=\"255px\" />\n\n</div>\n<h2 id=\"开源地址\">开源地址：</h2>\n<p><strong>Agent-Sandbox</strong> <a href=\"https://github.com/agent-sandbox/agent-sandbox\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/agent-sandbox/agent-sandbox</a></p>\n<h2 id=\"效果预演\">效果预演：</h2>\n<p><img alt=\"gitdemo\" src=\"https://img2024.cnblogs.com/blog/57355/202601/57355-20260108144402352-314698307.gif\" /></p>\n<h2 id=\"1为什么需要agent-sandbox\">1，为什么需要Agent-Sandbox？</h2>\n<p>在我们的业务中，经常需要让Agent执行一些代码或者访问网站等，例如用户提供了一个excel文件，处理里面的一些数据，最终生成报告，或者用户提供了一个网站，让Agent访问网站，然后获取一些数据，最终生成报告。</p>\n<p>这些都是很常见的场景，例如最近非常受关注的Manus，卖了很多钱的那个（羡慕啊～）,它就是利用了各种工具来完成用户的复杂任务，你们知道的。</p>\n<p>但问题来了，我们如何让Agent执行这些代码或者访问网站呢？</p>\n<p>因此Manus把E2B带火了，E2B是一个非常强大的Sandbox工具，它可以帮助Agent执行代码或命令，但是E2B基本上是个商业的，不方便我们使用，之前我们的办法是部署一个Python的执行代码的服务，或着部署一个Playwright的服务，各自提供MCP或普通API，来满足需求，但是遇到的问题也是显而易见的，那就是无法实现多次访问的隔离，例如一个Agent访问了A网站，另一个Agent访问了B网站，就会相互干扰，性能也是问题，除非你部署很多实例，那也浪费。</p>\n<p>这个问题你们是怎么解决的？</p>\n<h2 id=\"2agent-sandbox\">2，Agent-Sandbox</h2>\n<p><img alt=\"sbarch\" height=\"649\" src=\"https://img2024.cnblogs.com/blog/57355/202601/57355-20260108203145347-977491529.jpg\" width=\"1071\" /></p>\n<p>没有选择，只能自己搞了，上半年我们拉了几个兄弟，按照以上的痛点，开发了一个Agent-Sandbox，是的，名字就叫<strong>Agent-Sandbox</strong>，是不是很技术流，</p>\n<p>目前已经在生产环境使用了，效果还不错，支持MCP和REST API，Agent可以在任何需要的时候创建一个Sandbox，然后执行代码，访问网站等，完事儿后自己删除Sandbox，非常方便。</p>\n<p>不过最近也发现市面上出现很多关于Agent Sandbox的工具和讨论，开源的包括<a href=\"https://github.com/kubernetes-sigs/agent-sandbox\" rel=\"noopener nofollow\" target=\"_blank\">kubernetes-sigs/agent-sandbox</a> 、 <a href=\"https://github.com/agent-infra/sandbox\" rel=\"noopener nofollow\" target=\"_blank\">AIO Sandbox</a> 等，说明大家也在解决这个问题，AIO Sandbox这个是火山的，只提供一个集成化的Sandbox环境，也就是一个Docker的Image，里面有各种工具，包括执行代码、浏览器、文件系统等，而kubernetes-sigs/agent-sandbox是个部署工具，可以部署各种Sandbox环境，例如他就支持部署AIO Sandbox，可以通过它拉起很多AIO Sandbox的实例，但功能还是太基础了，无法直接给Agent使用，安装也麻烦，要求的Kubernetes版本比较高，目前大家生产用的K8S的版本都比较滞后。</p>\n<p>像我们这样开源的Sandbox还是没有看到，我们就决定把我们这个开源给大家，也许大家跟我们希望的一样，那就可以用得上了。</p>\n<h2 id=\"3agent-sandbox有哪些特点\">3，Agent-Sandbox有哪些特点？</h2>\n<p>目前实现了主要的功能，包括通过MCP或REST API来CRUD Sandbox，指定Sandbox的Image等，后续会支持更多场景的Sandbox运行环境，支持各种SDK，来满足编程场景的Sandbox控制，更多Sandbox的管理功能，包括TTL回收、无调用回收等，以及管理UI，可以看到在创建的全部Sandbox和相关操作，也可以通过这个UI来创建Sandbox等，方便与治理。</p>\n<p><img alt=\"full-lifecycle-demo\" height=\"601\" src=\"https://img2024.cnblogs.com/blog/57355/202601/57355-20260108144446225-906065250.png\" width=\"1129\" /></p>\n<h3 id=\"特性\">特性：</h3>\n<ol>\n<li>Ai使用友好，可以直接让Agent控制Sandbox的全生命周期，而不一定得提前创建好，在给Agent去使用，Agent按需创建和回收；</li>\n<li>生态开放，部署的Sandbox运行环境可以与社区的兼容，列如可以直接拉起前面提到的AIO Sandbox、Code Server或Playwright等，方便大家利用现有的资源，当然，可以自定义运行环境；</li>\n<li>企业生产可用，当然，考虑前面提到的痛点，基于K8S开发，支持规模化使用，根据需要，可以大量创建Sandbox，相互之间隔离使用；</li>\n<li>轻量化，就一个组件，没有采用K8S的CRD来开发，这个后续用户按照和升级都比较麻烦，用户得接受一种新的资源类型，我们采用RS+Label的方式，尽量依赖K8S现有的特性来快速实现。</li>\n</ol>\n<h2 id=\"4如何使用agent-sandbox\">4，如何使用Agent-Sandbox？</h2>\n<p>所以怎么使用呢，过程非常简单，主要分两步：</p>\n<h3 id=\"1部署agent-sandbox\">1，部署Agent-Sandbox</h3>\n<p>要求 <strong>Kubernetes version 1.26</strong> 或以上， 在 <code>https://github.com/agent-sandbox/agent-sandbox</code> 下载 <code>install.yaml</code> 后，</p>\n<pre><code class=\"language-bash\">kubectl create namespace agent-sandbox\nkubectl apply -nagent-sandbox -f install.yaml\n</code></pre>\n<p>里面会安装deployment、service等，之后你应该是需要配置一个ingress，如：</p>\n<pre><code class=\"language-yaml\">apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: agent-sandbox\n  namespace: agent-sandbox\nspec:\n  ingressClassName: ingress-nginx\n  rules:\n    - host: agent-sandbox.your-host.com\n      http:\n        paths:\n          - backend:\n              service:\n                name: agent-sandbox\n                port:\n                  number: 80\n            path: /(.*)\n</code></pre>\n<p>主要是 <code>host</code> 需要你给出，其他可以直接使用。</p>\n<h3 id=\"2使用agent-sandbox\">2，使用Agent-Sandbox</h3>\n<h4 id=\"21通过agent-sandbox-mcp-server\">2.1，通过Agent-Sandbox MCP Server</h4>\n<p>Agent-Sandbox MCP Server 地址： <code>http://agent-sandbox.your-host.com/mcp</code> ，提供了Sandbox的CURD等Tools。</p>\n<p><strong>效果测试：</strong></p>\n<p>一个简单的Demo，Agent 写个斐波那契额函数，然后通过MCP Server创建一个Sandbox，来计算，最后删除Sandbox。<br />\n<em>是个Gif动画，如果不播放，可以新窗口打开。</em></p>\n<p><img alt=\"gitdemo\" src=\"https://img2024.cnblogs.com/blog/57355/202601/57355-20260108144402352-314698307.gif\" /></p>\n<h4 id=\"22通过agent-sandbox-restful-api\">2.2，通过Agent-Sandbox RESTful API</h4>\n<p>Agent-Sandbox提供RESTful API来管理Sandbox，典型的工作流程包括创建Sandbox、访问Sandbox、删除Sandbox。</p>\n<p><strong>a，创建一个Sandbox</strong></p>\n<pre><code class=\"language-shell\">curl --location '/api/v1/sandbox' \\\n--header 'Content-Type: application/json' \\\n--data '{\"name\":\"sandbox-01\"}'\n</code></pre>\n<p>默认会拉起AIO Sandbox，可以通过以下方式，指定国内镜像，</p>\n<pre><code class=\"language-shell\">curl --location '/api/v1/sandbox' \\\n--header 'Content-Type: application/json' \\\n--data '{\"name\":\"sandbox-01\",\"image\":\"enterprise-public-cn-beijing.cr.volces.com/vefaas-public/all-in-one-sandbox:latest\"}'\n</code></pre>\n<p><strong>b，访问Sandbox</strong><br />\n<code>/sandbox/{sandbox_name}</code> 通过这个地址可以访问Sandbox,</p>\n<p>例如刚才创建的 <strong>sandbox-01</strong> 访问地址是： <code>/sandbox/sandbox-01</code>.</p>\n<p>访问后你应该会看到：</p>\n<p><img alt=\"aio-demo\" height=\"956\" src=\"https://img2024.cnblogs.com/blog/57355/202601/57355-20260108144513435-1606524670.jpg\" width=\"1464\" /></p>\n<p>访问这个Sandbox的MCP地址是： <code>http://agent-sandbox.your-host.com/sandbox/sandbox-01/mcp</code> ，这种场景是先创建好Sandbox，然后让Agent去访问这个Sandbox。</p>\n<p><strong>c，删除Sandbox</strong></p>\n<p>删除API： <code>/api/v1/sandbox/{sandbox_name}</code> . 例如删除Sandbox <code>sandbox-01</code> :<br />\n<strong>Shell</strong></p>\n<pre><code class=\"language-shell\">curl --location --request DELETE '/api/v1/sandbox/sandbox-01'\n</code></pre>\n<p><strong>结果:</strong></p>\n<pre><code class=\"language-json\">{\n  \"code\": \"0\",\n  \"data\": \"Sandbox sandbox-01 deleted successfully\"\n}\n</code></pre>\n<h2 id=\"结尾\">结尾</h2>\n<p>以上就是Agent-Sandbox的简单介绍和使用方法，更多内容请关注<a href=\"https://github.com/agent-sandbox/agent-sandbox\" rel=\"noopener nofollow\" target=\"_blank\">Agent-Sandbox</a>项目，后续我们会持续更新更多功能和特性，包括提到的支持更多场景的Sandbox运行环境，支持各种SDK来满足编程场景的Sandbox控制，更多Sandbox的管理功能，包括TTL回收、无调用回收，并发弹性伸缩等，以及管理UI，可以看到和管理创建的全部Sandbox，也可以通过这个UI来创建和操作Sandbox，例如上传下载文件、查看日志、执行命令、查看状态等。</p>\n<p>最后欢迎大家Star、Issue和PR~</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 15:41</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xguo\">i'm老土豆</a>&nbsp;\n阅读(<span id=\"post_view_count\">107</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "为什么很多伟大的作品都是诞生在一些不起眼的地方",
      "link": "https://www.cnblogs.com/lixingqiu/p/19457141",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lixingqiu/p/19457141\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 15:23\">\n    <span>为什么很多伟大的作品都是诞生在一些不起眼的地方</span>\n    \n\n</a>\n</h1>\n\t<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>在历史的长河中，我们不难发现，许多震撼人心、改变世界的伟大作品，往往并非出自繁华喧嚣的大都市，而是诞生于一些看似平凡甚至有些偏僻的角落。</p>\n<p>比如，梵高的许多传世画作，是在法国南部那个宁静的小村庄阿尔勒创作出来的。那里没有巴黎的灯红酒绿与艺术圈的纷繁复杂，有的只是质朴的田园风光和淳朴的村民。正是在这样相对安静的环境中，梵高得以全身心地投入到绘画创作中，用他那独特的笔触和色彩，描绘出一幅幅充满生命力的作品，给后世留下了无尽的艺术瑰宝。</p>\n<p>再比如，美国作家马克·吐温，他的许多经典文学作品，灵感来源于他童年生活的密西西比河畔小镇。那个远离城市喧嚣的地方，有着独特的风土人情和社会风貌，为他的写作提供了丰富的素材。他在那片土地上，观察着形形色色的人物，体验着生活的酸甜苦辣，从而创作出了《汤姆·索亚历险记》《哈克贝利·费恩历险记》等不朽之作。</p>\n<p>还有，著名的数学家陈景润，在一个并不起眼小县城里，默默钻研哥德巴赫猜想。在那个条件相对艰苦的环境中，他凭借着对数学的热爱和执着，克服了重重困难，最终取得了举世瞩目的成就，为数学领域的发展做出了巨大贡献。</p>\n<p>而如今，我们要说的<strong>C++精灵库</strong>，它的诞生地同样是一个毫不起眼的地方——江西省萍乡市。这里曾经是江南煤都，然而随着煤炭资源的枯竭，这座城市逐渐失去了往日的辉煌。人口不断流出，街头巷尾充斥着麻将声和抖音里各种喧闹的声音。想象一下，在这样的五线小城市里，年轻人大多选择逃离，前往长沙、南昌、杭州等大城市，甚至是一线城市去追寻自己的梦想，留下的大多是一些安于现状或者因各种原因无法离开的人。</p>\n<p>但是，就是在这样的环境中，却诞生了如此优秀的<strong>C++精灵库</strong>。它的背后，有一位了不起的人物——李兴球老师。李老师可是上世纪的学霸，年轻时曾在充满机遇与挑战的一线城市深圳闯荡了7年。自2010年发现Scratch图形化计算机语言以来，他便扎根在萍乡，从事青少儿编程教育长达10多年。</p>\n<p>时间来到2019年末，这是一个具有特殊意义的节点。李老师开始着手Python精灵模块的开发。为什么要开发这个模块呢？这源于李老师那颗始终充满好奇的心。在教学过程中，他敏锐地发现了Python turtle功能上的不足。比如说，想要让角色的造型图片进行缩放，或者是进行像素级别的碰撞检测，这些功能在Python turtle中都没有。于是，李老师便深入研究python turtle库的源文件turtle.py，经过不懈的努力，最终成功编写出了Python精灵模块。这一段经历，其实为后来C++精灵库的诞生埋下了深厚的根基，因为任何伟大的创新都不是凭空而来的，都需要有前期的积累和探索。</p>\n<p>岁月流转，到了2025年8月，暑假课程结束了。李老师那颗探索的心再次萌动起来。在人们的传统观念中，C++是一门非常难学的编程语言，似乎只有那些所谓的“小天才”才能掌握。这种观念流传至今，几乎已经固化。但李老师却不这么想，他一直思考着如何降低C++的教学门槛。一个大胆的想法在他脑海中浮现：能不能把Python turtle的命令移植到C++中呢？这样一来，学生们在学习了Python turtle之后再学习C++，岂不是会容易很多？</p>\n<p>为了实现这个想法，李老师进行了多方面的调研。他深入研究底层技术，了解现有的库是否能够满足需求。经过深思熟虑，李老师最终决定采用SDL2库进行全新编写。这样做的好处是显而易见的，基于工业级别的SDL2库，不仅底层代码可以全程掌握，而且拓展性极强，为后续的开发和完善提供了广阔的空间。</p>\n<p>在这个小城市里，李老师已经实现了生活无忧，并且能够完全掌控自己的时间，没有绩效考核等繁琐的压力。所以，暑假过后，从周一到周五，他每天都全身心地投入到C++精灵库的开发与调试工作中。有时候，一个小小的问题可能需要花费好几天的时间来解决。如果是在一线城市，这样的时间和人力成本无疑是巨大的，但在五线小城市，相对来说就显得微不足道了。也许，只有在这种相对“休闲”的状态中，人才能静下心来，专注于一件事情，从而做出伟大的、革命性的产品。</p>\n<p>如今，C++精灵库已经实现了超越。就拿它的链式调用来说，这种设计让代码更加优雅，更接近自然语言，大大降低了学习和使用的难度。李老师还精心设计了许多画笔颜色的调节命令，如penshade、pentone、pensat以及penhsv等，这些在Python turtle中都是没有的。这些独特的命令，为美术生的艺术创造打开了方便之门，让他们能够在编程的世界里更加自由地发挥想象力和创造力。</p>\n<p>让我们来看下面的C++代码：</p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:cpp;gutter:true;\">#include \"sprites.h\"  //包含C++精灵库 \nSprite turtle;       //建立角色叫turtle \n\nint main(){        //主功能块 \n   turtle.bgcolor(\"black\");\n   turtle.pensize(4).speed(0);\n   for(int i=0;i&lt;36;i++)\n       turtle.fd(10).left(10);\n   for(int i=0;i&lt;36;i++)\n       turtle.fd(10).right(10); \n    \n   turtle.ht(); \n   turtle.done();  \n   return 0;\n}\n</pre>\n</div>\n<p>　　再看下对应的Python turtle代码：</p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:php;gutter:true;\">import turtle\nturtle.bgcolor(\"black\")\nturtle.pensize(4)\nturtle.speed(0)\nfor i in range(36):\n    turtle.fd(10)\n    turtle.left(10)\nfor i in range(36):\n    turtle.fd(10)\n    turtle.right(10)\n</pre>\n</div>\n<p>　　</p>\n<p>它们的本质是一样的！C++版本的核心逻辑代码，只需稍加修改，将C++的链式调用改成Python的单个命令调用，复制到Python IDLE中就能运行。不过，这一改，倒是把原本优雅的C++代码换成了传统的Python书写方式。</p>\n<p>所以说，为什么很多伟大的作品都是诞生在一些不起眼的地方呢？因为在这里，人们可以摆脱外界的干扰和压力，以最低的成本去追求自己的理想，同时又能将自己的价值最大化。就像C++精灵库一样，它在萍乡这个小城市里诞生，却有可能为整个编程教育领域带来深远的影响。</p>\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-01-08 15:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lixingqiu\">李兴球</a>&nbsp;\n阅读(<span id=\"post_view_count\">192</span>)&nbsp;\n评论(<span id=\"post_comment_count\">4</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "自适应可变速率ID生成器的设计与实践(视频)",
      "link": "https://www.cnblogs.com/Zongsoft/p/19457036/sequence",
      "published": "",
      "description": "<a name=\"top\"></a>\n    <h2><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Zongsoft/p/19457036/sequence\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 15:03\">\n    <span>自适应可变速率ID生成器的设计与实践(视频)</span>\n    \n\n</a>\n</h2>\n    <small>\n<span id=\"post-date\">2026-01-08 15:03</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Zongsoft\">Zongsoft</a>&nbsp;\n阅读(<span id=\"post_view_count\">93</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</small>\n    <div class=\"entry\">\n            <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        在分布式系统架构中，全局唯一ID生成器是支撑高并发、高可用系统的基石。市面上的常见方案（如Snowflake-ID、UUID、Redis自增）各有优劣，但往往难以兼顾高性能、无中心化与灵活的业务需求。\n本系列视频将带你深入剖析一个开源项目中的核心组件，重点解析如何设计一款能智能适应流量波动、兼顾全局唯一与趋势递增特性的高性能ID生成器。我们将从理论设计、性能压测到源码实现，全方位解读这套算法如何在保证极高吞吐量的同时，实现毫秒级的自适应与可变速率调节。\n无论你是架构师、后端开发工程师，还是对高性能算法感兴趣的爱好者，这个系列都将为你提供宝贵的实战经验和深度的技术洞察。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在分布式系统设计中，ID生成器 <em>(<strong>S</strong>equence)</em> 是看似基础却至关重要的组件。然而，一些常用解决方案 <em>(如 Snowflake-ID 算法)</em> 在高并发、弹性伸缩场景下，常面临机器节点分配、时钟回拨、序列号耗尽、跨机房容错等挑战。你是否也曾为这些问题困扰？</p>\n<p><a href=\"http://zongsoft.com\" rel=\"noopener nofollow\" target=\"_blank\"><em><strong>Z</strong>ongsoft</em></a> 开源项目中的 <a href=\"https://github.com/Zongsoft/framework/blob/master/Zongsoft.Core/src/Common/Sequence.cs\" rel=\"noopener nofollow\" target=\"_blank\"><em>自适应可变速率ID生成器</em></a>，或许能为你提供一种新的思路。</p>\n<p>我强烈推荐大家关注近期上线的 <strong>视频系列</strong>：《<a href=\"https://space.bilibili.com/20995572\" rel=\"noopener nofollow\" target=\"_blank\">自适应可变速率ID生成器的设计与实践</a>》。</p>\n<p>系列视频采取 “<strong>理论</strong>-<strong>实验</strong>-<strong>源码</strong>” 三层递进结构，涵盖从设计理念到性能验证再到实现细节的完整知识链，展示了如何设计并实现一个智能适应流量波动、兼顾全局唯一与高信息密度、高性能的解决方案。无论是分布式系统初学者还是资深工程师都能从中获益。其亮点在于：</p>\n<ol>\n<li>\n<p><strong>直面痛点，突破传统局限​</strong></p>\n<p>视频中对比了 Snowflake-ID、UUID、数据库自增等方案的优劣，并重点解析了如何通过动态速率调整和时钟回拨容错机制，避免序列号争用与时间同步问题。这种设计尤其适合流量突增场景 <em>（如秒杀、日志高频写入）</em>，显著提升系统的稳定性。</p>\n</li>\n<li>\n<p><strong>实验驱动，数据说话​</strong></p>\n<p>系列中通过 <strong>6</strong> 组严谨实验，验证了算法在性能、正确性、稳定性方面的表现，并与原生 Redis 生成器进行对比。结果清晰展示了其在高压下的吞吐量优势，为技术选型提供了可靠依据。</p>\n</li>\n<li>\n<p><strong>开源实战，源码级解读​</strong></p>\n<p>视频直接基于 <a href=\"https://github.com/Zongsoft/framework\" rel=\"noopener nofollow\" target=\"_blank\"><em><strong>Z</strong>ongsoft</em></a> 开源项目代码解析，从位运算设计到异常处理逻辑，逐行拆解实现细节。无论是学习分布式系统设计，还是需要二次开发，都具有极高参考价值。</p>\n</li>\n</ol>\n<blockquote>\n<p>无论你是架构师、后端开发工程师，还是对高性能算法感兴趣的爱好者，这个系列都将为你提供宝贵的实战经验和深度的技术洞察。又或者你正在构建高并发系统，或对分布式基础组件有深入探索的兴趣，这一系列视频将是不可多得的学习资源。<br />\n它不仅能帮助你理解ID生成器的本质，更能拓宽解决复杂问题的思路。</p>\n</blockquote>\n<hr />\n<h3 id=\"-视频-1自适应可变速率id生成器设计与实践上\">🎥 视频 1：自适应可变速率ID生成器设计与实践(上)</h3>\n<blockquote>\n<p>副标题： 从理论到架构：为什么我们需要新的ID生成方案？<br /><br />\n视频地址：<a href=\"https://www.bilibili.com/video/BV15fiSBXEW5\" rel=\"noopener nofollow\" target=\"_blank\">https://www.bilibili.com/video/BV15fiSBXEW5</a></p>\n</blockquote>\n<p>在本系列的第一部分，我们将首先对现有的常见分布式ID生成方案进行深度的横向对比与剖析。</p>\n<p>深入探讨 Snowflake ID 的机器节点分配和时钟回拨、时钟漂移问题、UUID 的无序性、时钟问题与存储浪费、数据库自增ID的性能瓶颈与各种限制，以及 Redis 递增方案的优缺点。</p>\n<p>详细阐述本算法的设计初衷与核心理念；在此基础上，视频深入阐述自适应可变速率ID生成器的设计目标与核心理念，重点讲解如何通过动态速率调整、时钟回拨容错等机制，解决传统方案在高并发场景下的序列号耗尽、时钟同步等痛点问题。该视频为理解后续实验与源码实现奠定理论基础。</p>\n<h3 id=\"-视频-2自适应可变速率id生成器设计与实践中\">🎥 视频 2：自适应可变速率ID生成器设计与实践(中)</h3>\n<blockquote>\n<p>副标题： 数据说话：性能、稳定性与正确性的硬核实测<br /><br />\n视频地址：<a href=\"https://www.bilibili.com/video/BV1EQiSBtE38\" rel=\"noopener nofollow\" target=\"_blank\">https://www.bilibili.com/video/BV1EQiSBtE38</a></p>\n</blockquote>\n<p>光有理论不够，数据才是硬道理。在本集中，我们将通过 <strong>6</strong> 个精心设计的实验，对算法进行全方位的压力测试与验证：</p>\n<ul>\n<li>核心指标：验证生成器在高并发场景下的吞吐量（TPS）与响应延迟。</li>\n<li>稳定性测试：模拟延迟环境中，算法在长时间高并发运行下的稳定性与正确性。</li>\n<li>横向对比：我们将本算法与原生 Redis 生成器进行同场景下的性能对比，直观展示其在资源消耗与生成效率上的优势。</li>\n</ul>\n<blockquote>\n<p>通过这些实验，你将看到这套算法在实际应用中表现出的卓越性能。</p>\n</blockquote>\n<p>视频特别设置了与原生 Redis 生成器的对比测试，通过量化数据展现自适应算法在可变负载场景下的性能优势。例如，在流量突增时，传统生成器可能因序列号快速耗尽而导致ID生成延迟或阻塞，而自适应算法能动态调整生成策略，保持高性能与稳定性。这些实验为开发者提供了客观的评估依据，帮助他们在技术选型时做出明智决策。</p>\n<h3 id=\"-视频-3自适应可变速率id生成器设计与实践下\">🎥 视频 3：自适应可变速率ID生成器设计与实践(下)</h3>\n<blockquote>\n<p>副标题： 源码深潜：揭秘核心逻辑与环境配置<br /><br />\n视频地址：即将发布，请关注微信公众号(<code>Zongsoft</code>)以获得及时发布通知。</p>\n</blockquote>\n<p>最后一集，我们将带你潜入代码深处，直面该算法的核心实现以及如何快速搭建开发与测试环境。</p>\n<p>逐行剖析 <a href=\"https://github.com/Zongsoft/framework/blob/master/Zongsoft.Core/src/Common/Sequence.cs\" rel=\"noopener nofollow\" target=\"_blank\">Sequence</a> 类的关键逻辑，解读代理模式封装、动态步长调整、本地无锁递增、边界保障机制、时序感知优化等核心代码块。<br />\n详细介绍算法运行所需的环境依赖与配置参数，帮助你快速将这套高性能组件集成到自己的项目中。</p>\n<p>通过本集，你将掌握从源码到部署的全链路能力——不仅 <em>“用得上”</em>，更能 <em>“懂透原理”</em>，在实际项目中快速构建出自适应、高可靠、零运维的ID生成服务，为高并发系统筑牢基石。</p>\n<hr />\n<ul>\n<li>Bilibili\n<blockquote>\n<p><a href=\"https://space.bilibili.com/20995572\" rel=\"noopener nofollow\" target=\"_blank\">https://space.bilibili.com/20995572</a></p>\n</blockquote>\n</li>\n<li>抖音\n<blockquote>\n<p><a href=\"https://www.douyin.com/user/MS4wLjABAAAA9NmpuYVoLopaB6XdHoQ1CcmDF5DIb5YgwKzBLjZZdyU\" rel=\"noopener nofollow\" target=\"_blank\">https://www.douyin.com/user/MS4wLjABAAAA9NmpuYVoLopaB6XdHoQ1CcmDF5DIb5YgwKzBLjZZdyU</a></p>\n</blockquote>\n</li>\n<li>微信公众号\n<blockquote>\n<p><img alt=\"Zongsoft 微信公众号\" class=\"lazyload\" /></p>\n</blockquote>\n</li>\n</ul>\n\n</div>\n<div id=\"MySignature\">\n    <div style=\"text-align: center;\">\n\t<img src=\"https://raw.githubusercontent.com/Zongsoft/Guidelines/master/zongsoft-qrcode%28wechat%29.png\" />\n</div>\n\n<hr style=\"margin-top: 2em; margin-bottom: 2em; margin-left: 0; margin-right: 0; padding: 0; height: 2px; border: 0; background-color: #e8e8e8;\" />\n\n<div id=\"license\">\n\t<img src=\"https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png\" width=\"\" />\n\t<p style=\"margin-top: 4px;\">\n本作品采用 <a class=\"bi-link\" href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" target=\"_blank\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a> 进行许可。欢迎转载、使用、重新发布，但必须保留本文的署名 <a class=\"bi-link\" href=\"https://github.com/zongsoft\" target=\"_blank\">钟峰</a>（包含链接：<a class=\"bi-link\" href=\"http://zongsoft.github.io/\" target=\"_blank\">http://zongsoft.github.io</a>），不得用于商业目的，基于本文修改后的作品务必以相同的许可发布。如有任何疑问或授权方面的协商，请致信给我 (zongsoft@qq.com)。\n\t</p>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n        <div class=\"clear\"></div>\n        \n</div>\n    <ul class=\"postmetadata\">\n        \n    </ul>"
    },
    {
      "title": "强烈推荐 | 阿里开源的这10个神级项目",
      "link": "https://www.cnblogs.com/12lisu/p/19456855",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/12lisu/p/19456855\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 14:35\">\n    <span>强烈推荐 | 阿里开源的这10个神级项目</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>最近趁着放假休息，特地整理了一下，阿里巴巴开源的10款神级项目。</p>\n<p>这些开源项目中的绝大多数，我都在实际工作中用过，或者有同事用过。确实挺不错，挺有价值的，现在推荐给大家。</p>\n<h2 id=\"1-druid\">1. Druid</h2>\n<p>Druid自称是Java语言中最好的数据库连接池，它能够提供强大的监控和扩展功能。监控后台如下图所示：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>Druid的主要优点如下：</p>\n<ul>\n<li>它能监控数据库访问性能。</li>\n<li>它提供了WallFilter，它是基于SQL语义分析来实现防御SQL注入攻击的。</li>\n<li>它提供了多种监测连接泄漏的手段。</li>\n<li>它提供了数据库密码加密的功能。</li>\n<li>它能打印SQL执行日志。</li>\n</ul>\n<blockquote>\n<p>github地址: <a href=\"https://github.com/alibaba/druid\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/druid</a></p>\n</blockquote>\n<blockquote>\n<p>maven中央仓库: <a href=\"https://mvnrepository.com/artifact/com.alibaba/druid\" rel=\"noopener nofollow\" target=\"_blank\">https://mvnrepository.com/artifact/com.alibaba/druid</a></p>\n</blockquote>\n<p>配置maven依赖：</p>\n<pre><code class=\"language-java\">&lt;dependency&gt;\n\t\t&lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n\t\t&lt;artifactId&gt;druid&lt;/artifactId&gt;\n\t\t&lt;version&gt;${druid-version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h2 id=\"2-fastjson\">2. fastjson</h2>\n<p><code>fastjson</code>是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。</p>\n<p>fastjson的主要优点如下：</p>\n<ul>\n<li>速度快，fastjson相对其他JSON库的特点是快，从2011年fastjson发布1.1.x版本之后，其性能从未被其他Java实现的JSON库超越。</li>\n<li>使用广泛，fastjson在阿里巴巴大规模使用，在数万台服务器上部署，fastjson在业界被广泛接受。在2012年被开源中国评选为最受欢迎的国产开源软件之一。</li>\n<li>使用简单，fastjson的API十分简洁。</li>\n</ul>\n<pre><code class=\"language-java\">//序列化\nString text = JSON.toJSONString(obj); \n//反序列化\nVO vo = JSON.parseObject(\"{...}\", VO.class); \n</code></pre>\n<ul>\n<li>功能完备，支持泛型，支持流处理超大文本，支持枚举，支持序列化和反序列化扩展。</li>\n</ul>\n<blockquote>\n<p>github地址: <a href=\"https://github.com/alibaba/fastjson\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/fastjson</a></p>\n</blockquote>\n<blockquote>\n<p>maven中央仓库: <a href=\"https://mvnrepository.com/artifact/com.alibaba/fastjson\" rel=\"noopener nofollow\" target=\"_blank\">https://mvnrepository.com/artifact/com.alibaba/fastjson</a></p>\n</blockquote>\n<p>配置maven依赖：</p>\n<pre><code class=\"language-java\">&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;\n    &lt;version&gt;1.2.76&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h2 id=\"3-dubbo\">3. Dubbo</h2>\n<p>Apache Dubbo 是一款微服务开发框架，它提供了 RPC通信 与 微服务治理 两大关键能力。这意味着，使用 Dubbo 开发的微服务，将具备相互之间的远程发现与通信能力， 同时利用 Dubbo 提供的丰富服务治理能力，可以实现诸如服务发现、负载均衡、流量调度等服务治理诉求。</p>\n<p>同时 Dubbo 是高度可扩展的，用户几乎可以在任意功能点去定制自己的实现，以改变框架的默认行为来满足自己的业务需求。它目前已交给Apache管理和维护。</p>\n<p>架构图如下：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>Dubbo的主要优点如下：</p>\n<ul>\n<li>基于透明接口的RPC</li>\n<li>智能负载均衡</li>\n<li>自动服务注册和发现</li>\n<li>高扩展性</li>\n<li>运行时流量路由</li>\n<li>可视化服务治理</li>\n<li>云原生友好</li>\n</ul>\n<blockquote>\n<p>github地址: <a href=\"https://github.com/apache/dubbo\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/apache/dubbo</a></p>\n</blockquote>\n<blockquote>\n<p>maven中央仓库: <a href=\"https://mvnrepository.com/artifact/com.alibaba/dubbo/\" rel=\"noopener nofollow\" target=\"_blank\">https://mvnrepository.com/artifact/com.alibaba/dubbo/</a></p>\n</blockquote>\n<p>配置maven依赖：</p>\n<pre><code class=\"language-java\">&lt;properties&gt;\n    &lt;dubbo.version&gt;3.0.3&lt;/dubbo.version&gt;\n&lt;/properties&gt;\n\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;\n        &lt;artifactId&gt;dubbo&lt;/artifactId&gt;\n        &lt;version&gt;${dubbo.version}&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;\n        &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;\n        &lt;version&gt;${dubbo.version}&lt;/version&gt;\n        &lt;type&gt;pom&lt;/type&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>\n<h2 id=\"4-rocketmq\">4. Rocketmq</h2>\n<p>Apache RocketMQ是一个分布式消息和流媒体平台，具有低延迟、高性能和可靠性、万亿级容量和灵活的可扩展性。</p>\n<p>它提供了多种功能：</p>\n<ul>\n<li>消息传递模式，包括发布/订阅、请求/回复和流媒体</li>\n<li>金融级交易消息</li>\n<li>基于DLedger的内置容错和高可用配置选项</li>\n<li>多种跨语言客户端，如Java、C/C++、Python、Go</li>\n<li>可插拔传输协议，例如 TCP、SSL、AIO</li>\n<li>内置消息追踪能力，也支持opentracing</li>\n<li>多功能大数据和流媒体生态系统集成</li>\n<li>按时间或偏移量的消息追溯</li>\n<li>可靠的 FIFO 和同一队列中的严格有序消息传递</li>\n<li>高效的拉推式消费模式</li>\n<li>单个队列百万级消息累积能力</li>\n<li>多种消息传递协议，如 JMS 和 OpenMessaging</li>\n<li>灵活的分布式横向扩展部署架构</li>\n<li>闪电般的批量消息交换系统</li>\n<li>各种消息过滤机制，例如 SQL 和 Tag</li>\n<li>用于隔离测试和云隔离集群的 Docker 镜像</li>\n<li>用于配置、指标和监控的功能丰富的管理仪表板</li>\n<li>认证和授权</li>\n<li>免费的开源连接器，用于源和接收器</li>\n</ul>\n<p>rocketmq后台管理界面：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<blockquote>\n<p>github地址: <a href=\"https://github.com/apache/rocketmq\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/apache/rocketmq</a></p>\n</blockquote>\n<blockquote>\n<p>maven中央仓库: <a href=\"https://mvnrepository.com/artifact/org.apache.rocketmq/rocketmq-spring-boot-starter\" rel=\"noopener nofollow\" target=\"_blank\">https://mvnrepository.com/artifact/org.apache.rocketmq/rocketmq-spring-boot-starter</a></p>\n</blockquote>\n<p>rocketmq包含：服务端和客户端，在我们的项目中主要关注客户端的代码即可。</p>\n<p>配置maven依赖：</p>\n<pre><code class=\"language-java\">&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;\n    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;\n    &lt;version&gt;4.3.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h2 id=\"4-arthas\">4. Arthas</h2>\n<p>Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。</p>\n<p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p>\n<ul>\n<li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li>\n<li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li>\n<li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li>\n<li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li>\n<li>是否有一个全局视角来查看系统的运行状况？</li>\n<li>有什么办法可以监控到JVM的实时运行状态？</li>\n<li>怎么快速定位应用的热点，生成火焰图？</li>\n<li>怎样直接从JVM内查找某个类的实例？</li>\n</ul>\n<p>分析代码消耗时间：<br />\n<img alt=\"\" class=\"lazyload\" /><br />\nArthas支持JDK 6+，能够运行在多种操作系统上，比如：Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。</p>\n<blockquote>\n<p>github地址: <a href=\"https://alibaba.github.io/arthas/\" rel=\"noopener nofollow\" target=\"_blank\">https://alibaba.github.io/arthas/</a></p>\n</blockquote>\n<blockquote>\n<p>maven中央仓库: <a href=\"https://mvnrepository.com/artifact/com.taobao.arthas/arthas-spring-boot-starter\" rel=\"noopener nofollow\" target=\"_blank\">https://mvnrepository.com/artifact/com.taobao.arthas/arthas-spring-boot-starter</a></p>\n</blockquote>\n<p>在目标机器执行如下命令即可启动arthas：</p>\n<pre><code class=\"language-java\">curl -O https://arthas.aliyun.com/arthas-boot.jar\njava -jar arthas-boot.jar\n</code></pre>\n<h2 id=\"5-nacos\">5. Nacos</h2>\n<p>Nacos是一个易于使用的平台，专为动态服务发现和配置以及服务管理而设计。它可以帮助您轻松构建云原生应用程序和微服务平台。</p>\n<p>服务是Nacos的一等公民。Nacos 支持几乎所有类型的服务，例如Dubbo/gRPC 服务、Spring Cloud RESTFul 服务或Kubernetes 服务。</p>\n<p>Nacos 提供了四大功能。</p>\n<ul>\n<li><code>服务发现和服务健康检查</code>。Nacos 使服务通过 DNS 或 HTTP 接口注册自己和发现其他服务变得简单。Nacos 还提供服务的实时健康检查，以防止向不健康的主机或服务实例发送请求。</li>\n<li><code>动态配置管理</code>。动态配置服务允许您在所有环境中以集中和动态的方式管理所有服务的配置。Nacos 无需在更新配置时重新部署应用程序和服务，这使得配置更改更加高效和敏捷。</li>\n<li><code>动态 DNS 服务</code>。Nacos 支持加权路由，让您更容易在数据中心内的生产环境中实现中层负载均衡、灵活的路由策略、流量控制和简单的 DNS 解析服务。它可以帮助您轻松实现基于 DNS 的服务发现，并防止应用程序耦合到特定于供应商的服务发现 API。</li>\n<li><code>服务和元数据管理</code>。Nacos 提供了一个易于使用的服务仪表板，帮助您管理您的服务元数据、配置、kubernetes DNS、服务健康和指标统计。</li>\n</ul>\n<p>Nacos 地图：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>Nacos 生态图：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<blockquote>\n<p>github地址: <a href=\"https://github.com/alibaba/nacos\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/nacos</a></p>\n</blockquote>\n<blockquote>\n<p>maven中央仓库: <a href=\"https://mvnrepository.com/artifact/com.alibaba.cloud/spring-cloud-starter-alibaba-nacos-discovery\" rel=\"noopener nofollow\" target=\"_blank\">https://mvnrepository.com/artifact/com.alibaba.cloud/spring-cloud-starter-alibaba-nacos-discovery</a></p>\n</blockquote>\n<h2 id=\"6-easyexcel\">6. easyexcel</h2>\n<p>Java解析、生成Excel比较有名的框架有Apache poi、jxl。但他们都存在一个严重的问题就是非常的耗内存，poi有一套SAX模式的API可以一定程度的解决一些内存溢出的问题，但POI还是有一些缺陷，比如07版Excel解压缩以及解压后存储都是在内存中完成的，内存消耗依然很大。</p>\n<p>easyexcel重写了poi对07版Excel的解析，一个3M的excel用POI sax解析依然需要100M左右内存，改用easyexcel可以降低到几M，并且再大的excel也不会出现内存溢出；03版依赖POI的sax模式，在上层做了模型转换的封装，让使用者更加简单方便。</p>\n<p>64M内存1分钟内读取75M(46W行25列)的Excel</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<blockquote>\n<p>github地址: <a href=\"https://github.com/alibaba/easyexcel\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/easyexcel</a></p>\n</blockquote>\n<blockquote>\n<p>maven中央仓库: <a href=\"https://mvnrepository.com/artifact/com.alibaba/easyexcel\" rel=\"noopener nofollow\" target=\"_blank\">https://mvnrepository.com/artifact/com.alibaba/easyexcel</a></p>\n</blockquote>\n<p>配置maven依赖：</p>\n<pre><code class=\"language-java\">&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n    &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;\n    &lt;version&gt;2.2.6&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h2 id=\"7-sentinel\">7. Sentinel</h2>\n<p>随着分布式系统变得越来越流行，服务之间的可靠性变得比以往任何时候都更加重要。</p>\n<p>Sentinel以“流量”为切入点，在流量控制、 流量整形、熔断、系统自适应保护等多个领域开展工作，保障微服务的可靠性和弹性。</p>\n<p>Sentinel具有以下特点：</p>\n<ul>\n<li><code>丰富的适用场景</code>：Sentinel在阿里巴巴得到了广泛的应用，几乎覆盖了近10年双11（11.11）购物节的所有核心场景，比如需要限制突发流量的“秒杀”满足系统容量、消息削峰填谷、下游不可靠业务断路、集群流量控制等。</li>\n<li><code>实时监控</code>：Sentinel 还提供实时监控能力。可以实时查看单台机器的运行时信息，以及500个节点以下集群的运行时信息汇总。</li>\n<li><code>广泛的开源生态系统</code>：Sentinel 提供与 Spring Cloud、Dubbo 和 gRPC 等常用框架和库的开箱即用集成。您只需将适配器依赖项添加到您的服务即可轻松使用 Sentinel。</li>\n<li><code>多语言支持</code>：Sentinel 为 Java、Go和C++提供了本机支持。</li>\n<li><code>丰富的SPI扩展</code>：Sentinel提供简单易用的SPI扩展接口，可以让您快速自定义逻辑，例如自定义规则管理、适配数据源等。</li>\n</ul>\n<p>功能概述：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>生态系统景观：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<blockquote>\n<p>github地址: <a href=\"https://github.com/alibaba/Sentinel\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/Sentinel</a></p>\n</blockquote>\n<blockquote>\n<p>maven中央仓库: <a href=\"https://mvnrepository.com/artifact/com.alibaba.csp/sentinel-core\" rel=\"noopener nofollow\" target=\"_blank\">https://mvnrepository.com/artifact/com.alibaba.csp/sentinel-core</a></p>\n</blockquote>\n<p>配置maven依赖：</p>\n<pre><code class=\"language-java\">&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;\n    &lt;artifactId&gt;sentinel-core&lt;/artifactId&gt;\n    &lt;version&gt;1.8.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h2 id=\"8-otter\">8. otter</h2>\n<p>阿里巴巴B2B公司，因为业务的特性，卖家主要集中在国内，买家主要集中在国外，所以衍生出了杭州和美国异地机房的需求，同时为了提升用户体验，整个机房的架构为双A，两边均可写，由此诞生了otter这样一个产品。</p>\n<p>otter第一版本可追溯到04~05年，此次外部开源的版本为第4版，开发时间从2011年7月份一直持续到现在，目前阿里巴巴B2B内部的本地/异地机房的同步需求基本全上了otte4。</p>\n<p>目前同步规模：</p>\n<ul>\n<li>同步数据量6亿</li>\n<li>文件同步1.5TB(2000w张图片)</li>\n<li>涉及200+个数据库实例之间的同步</li>\n<li>80+台机器的集群规模</li>\n</ul>\n<p>otter能解决什么？</p>\n<ul>\n<li>\n<p><code>异构库同步</code>。 mysql -&gt; mysql/oracle. (目前开源版本只支持mysql增量，目标库可以是mysql或者oracle，取决于canal的功能)</p>\n</li>\n<li>\n<p><code>单机房同步</code> (数据库之间RTT &lt; 1ms)</p>\n<p>a. 数据库版本升级</p>\n<p>b. 数据表迁移</p>\n<p>c. 异步二级索引</p>\n</li>\n<li>\n<p><code>异地机房同步</code> (比如阿里巴巴国际站就是杭州和美国机房的数据库同步，RTT &gt; 200ms，亮点)</p>\n<p>a. 机房容灾</p>\n</li>\n<li>\n<p><code>双向同步</code></p>\n<p>a. 避免回环算法 (通用的解决方案，支持大部分关系型数据库)</p>\n<p>b. 数据一致性算法 (保证双A机房模式下，数据保证最终一致性，亮点)</p>\n</li>\n<li>\n<p><code>文件同步</code><br />\n站点镜像 (进行数据复制的同时，复制关联的图片，比如复制产品数据，同时复制产品图片).</p>\n</li>\n</ul>\n<p>工作原理图：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>单机房复制示意图：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>异地机房复制示意图：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<blockquote>\n<p>github地址: <a href=\"https://github.com/alibaba/otter\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/otter</a></p>\n</blockquote>\n<blockquote>\n<p>maven中央仓库: <a href=\"https://mvnrepository.com/artifact/com.alibaba.otter/canal.client\" rel=\"noopener nofollow\" target=\"_blank\">https://mvnrepository.com/artifact/com.alibaba.otter/canal.client</a></p>\n</blockquote>\n<h2 id=\"9-p3c\">9. P3C</h2>\n<p>P3C插件呈现了阿里巴巴 Java 编码指南，它整合了阿里巴巴集团技术团队多年来的最佳编程实践。由于我们鼓励重用和更好地理解彼此的程序，因此大量 Java 编程团队对跨项目的代码质量提出了苛刻的要求。</p>\n<p>阿里巴巴过去见过很多编程问题。例如，有缺陷的数据库表结构和索引设计可能会导致软件架构缺陷和性能风险。另一个例子是混乱的代码结构难以维护。此外，未经身份验证的易受攻击的代码容易受到黑客的攻击。为了解决这些问题，我们为阿里巴巴的Java开发人员编写了这份文档。</p>\n<p>更多信息请参考阿里巴巴Java编码指南：</p>\n<ul>\n<li>中文版：阿里巴巴Java开发手册</li>\n<li>英文版：Alibaba Java Coding Guidelines</li>\n</ul>\n<p>该项目由3部分组成：</p>\n<ul>\n<li>PMD 实现</li>\n<li>IntelliJ IDEA 插件</li>\n<li>Eclipse 插件</li>\n</ul>\n<p>四十九条规则是基于PMD实现的，更多详细信息请参考P3C-PMD文档。IDE 插件（IDEA 和 Eclipse）中实现的四个规则如下：</p>\n<ul>\n<li>\n<p>[Mandatory]禁止使用已弃用的类或方法。<br />\n注意：例如，应该使用 decode(String source, String encode) 而不是不推荐使用的方法 decode(String encodeStr)。一旦接口被弃用，接口提供者就有义务提供一个新的接口。同时，客户端程序员有义务检查它的新实现是什么。</p>\n</li>\n<li>\n<p>[Mandatory]来自接口或抽象类的重写方法必须用 @Override 注释标记。反例：对于 getObject() 和 get0bject()，第一个是字母“O”，第二个是数字“0”。为了准确判断覆盖是否成功，需要一个@Override注解。同时，一旦抽象类中的方法签名发生变化，实现类将立即报告编译时错误。</p>\n</li>\n<li>\n<p>[Mandatory] 静态字段或方法应直接通过其类名而不是其对应的对象名来引用。</p>\n</li>\n<li>\n<p>[Mandatory] hashCode 和 equals 的用法应该遵循：</p>\n</li>\n</ul>\n<ol>\n<li>如果 equals 被覆盖，则覆盖 hashCode。</li>\n<li>这两个方法必须为 Set 重写，因为它们用于确保不会在 Set 中插入重复的对象。</li>\n<li>如果使用自定义对象作为 Map 的键，则必须覆盖这两个方法。注意：String 可以用作 Map 的键，因为这两个方法已经被重写。</li>\n</ol>\n<p>使用p3c插件的效果：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>最新版阿里巴巴Java开发手册下载地址：<br />\n<a href=\"https://github.com/alibaba/p3c/blob/master/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E5%B5%A9%E5%B1%B1%E7%89%88%EF%BC%89.pdf\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/p3c/blob/master/Java开发手册（嵩山版）.pdf</a></p>\n<blockquote>\n<p>github地址:<a href=\"https://github.com/alibaba/p3c/tree/master/idea-plugin\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/p3c/tree/master/idea-plugin</a></p>\n</blockquote>\n<h2 id=\"10-spring-cloud-alibaba\">10. Spring Cloud Alibaba</h2>\n<p>Spring Cloud Alibaba 为分布式应用开发提供一站式解决方案。它包含开发分布式应用程序所需的所有组件，使您可以轻松地使用 Spring Cloud 开发应用程序。</p>\n<p>使用Spring Cloud Alibaba，您只需添加一些注解和少量配置，即可将Spring Cloud应用连接到阿里巴巴的分布式解决方案，并通过阿里巴巴中间件构建分布式应用系统。</p>\n<p>主要功能如下：</p>\n<ul>\n<li><code>流量控制和服务降级</code>：默认支持 HTTP 服务的流量控制。您还可以使用注释自定义流量控制和服务降级规则。规则可以动态更改。</li>\n<li><code>服务注册和发现</code>：可以注册服务，客户端可以使用 Spring 管理的 bean，自动集成 Ribbon 来发现实例。</li>\n<li><code>分布式配置</code>：支持分布式系统中的外化配置，配置变化时自动刷新。</li>\n<li><code>事件驱动</code>：支持构建与共享消息系统连接的高度可扩展的事件驱动微服务。</li>\n<li><code>分布式事务</code>：支持高性能、易用的分布式事务解决方案。</li>\n<li><code>阿里云对象存储</code>：海量、安全、低成本、高可靠的云存储服务。支持随时随地在任何应用程序中存储和访问任何类型的数据。</li>\n<li><code>阿里云SchedulerX</code>：精准、高可靠、高可用的定时作业调度服务，响应时间秒级。</li>\n<li><code>阿里云短信</code>：覆盖全球的短信服务，阿里短信提供便捷、高效、智能的通讯能力，帮助企业快速联系客户。</li>\n</ul>\n<p>主要包含如下组件：</p>\n<ul>\n<li><code>Sentinel</code>：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</li>\n<li><code>Nacos</code>：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</li>\n<li><code>RocketMQ</code>：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</li>\n<li><code>Dubbo</code>：Apache Dubbo™ 是一款高性能 Java RPC 框架。</li>\n<li><code>Seata</code>：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</li>\n<li><code>Alibaba Cloud OSS</code>: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li>\n<li><code>Alibaba Cloud SchedulerX</code>: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。</li>\n<li><code>Alibaba Cloud SMS</code>: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li>\n</ul>\n<blockquote>\n<p>github地址: <a href=\"https://github.com/alibaba/spring-cloud-alibaba\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/spring-cloud-alibaba</a></p>\n</blockquote>\n<p>配置maven依赖：</p>\n<pre><code class=\"language-java\">&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;\n            &lt;version&gt;2.2.6.RELEASE&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;\n</code></pre>\n<h2 id=\"最后说一句求关注别白嫖我\">最后说一句(求关注，别白嫖我)</h2>\n<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>\n<p>求一键三连：点赞、转发、在看。</p>\n<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>\n<p>更多项目实战在我的技术网站：<a href=\"http://www.susan.net.cn/project\" rel=\"noopener nofollow\" target=\"_blank\">http://www.susan.net.cn/project</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 14:35</span>&nbsp;\n<a href=\"https://www.cnblogs.com/12lisu\">苏三说技术</a>&nbsp;\n阅读(<span id=\"post_view_count\">361</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "FastAPI + SQLite：从基础CRUD到安全并发的实战指南",
      "link": "https://www.cnblogs.com/ymtianyu/p/19456330",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ymtianyu/p/19456330\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 13:33\">\n    <span>FastAPI + SQLite：从基础CRUD到安全并发的实战指南</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文提供了FastAPI结合SQLite进行后端开发的完整实战指南。不仅涵盖了基础模型定义和CRUD接口搭建，更深入探讨了生产环境中必备的安全设置（如OAuth2密码流与JWT令牌认证）和高并发处理方案（如数据库连接池配置与异步优化）。通过清晰的代码示例和生动的比喻，帮助你构建既安全又高效的应用。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>你有没有经历过项目越跑越慢，或者因为一个小漏洞导致数据泄露的恐慌时刻？</p>\n<p>试想一下，一个FastAPI项目，简单的内部工具，初期运行飞快。但当用户量从10个增加到100个时，响应时间却增加了近10倍，还差点因为一个未经验证的API参数导致全表数据被意外导出。其实，很多教程只教我们“跑起来”，却没教我们“跑得稳、跑得安全”。</p>\n<h2>📌 核心摘要</h2>\n<p>本文将带你超越FastAPI + SQLite的基础CRUD搭建，聚焦于<strong style=\"color: rgba(186, 55, 42, 1);\">安全防护（认证、授权、输入验证）</strong>与<strong style=\"color: rgba(186, 55, 42, 1);\">并发处理（数据库连接池、异步优化）</strong>两大实战痛点。你会获得一套可直接复用的项目骨架，并理解其背后的设计逻辑，确保你的应用在业务增长时依然稳健。</p>\n<h2>🚀 主要内容脉络</h2>\n<div>\n<p>🎯 1. 快速搭建：5分钟创建一个带CRUD的FastAPI应用</p>\n<p>⚡ 模型定义、数据库连接、基础API</p>\n<p>🎯 2. 安全第一：给你的API加上“门禁”和“监控”</p>\n<p>⚡ OAuth2密码流、JWT令牌、依赖注入保护路由</p>\n<p>🎯 3. 应对高并发：别让数据库连接成为瓶颈</p>\n<p>⚡ 连接池配置、异步会话管理、后台任务</p>\n<p>🎯 4. 完整代码与避坑指南</p>\n<p>⚡ 项目结构、关键配置、常见陷阱</p>\n</div>\n<h2>🔧 第一部分：为什么是FastAPI + SQLite？</h2>\n<p>FastAPI就像一个高效、现代的餐厅点餐系统，你（客户端）递上菜单（JSON请求），厨房（后端逻辑）立刻开动，快速出餐（JSON响应）。而SQLite，则是这家餐厅初期最合适的“本地仓库”——无需复杂配置，一个文件搞定所有库存，对于中小型应用或原型开发来说，<strong style=\"color: rgba(186, 55, 42, 1);\">轻量且完全够用</strong>。</p>\n<p>但问题来了：当顾客（并发请求）暴增，仓库管理员（数据库连接）手忙脚乱；或者有人冒充服务员（未授权访问）进入后厨。我们今天就要解决这些问题。</p>\n<h2>🛡️ 第二部分：从基础CRUD到安全堡垒</h2>\n<h3>1. 搭建基础框架</h3>\n<p>首先，安装必备工具包：</p>\n<pre class=\"highlighter-hljs\" style=\"background-color: rgba(246, 248, 250, 1); padding: 15px; border-radius: 5px;\"><code>pip install fastapi uvicorn sqlalchemy databases[aiosqlite] python-jose[cryptography] passlib[bcrypt]</code></pre>\n<p>接下来，我们定义数据模型并建立连接。SQLAlchemy的ORM让我们能用Python类操作数据库：</p>\n<pre class=\"highlighter-hljs\" style=\"background-color: rgba(246, 248, 250, 1); padding: 15px; border-radius: 5px;\"><code># models.py\nfrom sqlalchemy import Column, Integer, String, create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\n\nDATABASE_URL = \"sqlite:///./test.db\"\n# 注意：`check_same_thread=False` 仅用于SQLite简化示例，生产环境需用更安全的方式\nengine = create_engine(DATABASE_URL, connect_args={\"check_same_thread\": False})\nBase = declarative_base()\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, index=True)\n    description = Column(String, nullable=True)\n\n# 创建表\nBase.metadata.create_all(bind=engine)</code></pre>\n<p>然后，编写FastAPI的核心CRUD接口：</p>\n<pre class=\"highlighter-hljs\" style=\"background-color: rgba(246, 248, 250, 1); padding: 15px; border-radius: 5px;\"><code># main.py (基础版)\nfrom fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom . import models\nfrom .database import SessionLocal, engine\n\napp = FastAPI()\n\n# 依赖项：获取数据库会话\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/items/\")\ndef create_item(name: str, description: str = None, db: Session = Depends(get_db)):\n    db_item = models.Item(name=name, description=description)\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item\n\n@app.get(\"/items/{item_id}\")\ndef read_item(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(models.Item).filter(models.Item.id == item_id).first()\n    if item is None:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    return item\n# ... 更新和删除接口类似</code></pre>\n<h3>2. 构筑安全防线 🎯</h3>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">警告：以下安全设置是生产应用的基石，切勿跳过。</strong></p>\n<p>把API直接暴露在网上，就像把家钥匙放在门垫下。我们需要<strong style=\"color: rgba(186, 55, 42, 1);\">认证（你是谁）</strong>和<strong style=\"color: rgba(186, 55, 42, 1);\">授权（你能干什么）</strong>。我们采用OAuth2密码流（业界标准）与JWT（JSON Web Tokens）组合。</p>\n<p>第一步，处理密码。永远不要明文存储密码！</p>\n<pre class=\"highlighter-hljs\" style=\"background-color: rgba(246, 248, 250, 1); padding: 15px; border-radius: 5px;\"><code># security.py\nfrom passlib.context import CryptContext\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\ndef verify_password(plain_password, hashed_password):\n    return pwd_context.verify(plain_password, hashed_password)\n\ndef get_password_hash(password):\n    return pwd_context.hash(password)</code></pre>\n<p>第二步，创建和验证JWT令牌。</p>\n<pre class=\"highlighter-hljs\" style=\"background-color: rgba(246, 248, 250, 1); padding: 15px; border-radius: 5px;\"><code># auth.py\nfrom jose import JWTError, jwt\nfrom datetime import datetime, timedelta\n\nSECRET_KEY = \"your-secret-key-change-this-in-production\" # 🔴 生产环境必须用强密钥且从环境变量读取！\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n\ndef create_access_token(data: dict):\n    to_encode = data.copy()\n    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\nasync def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):\n    credentials_exception = HTTPException(status_code=401, detail=\"无效凭证\")\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n    user = db.query(models.User).filter(models.User.username == username).first()\n    if user is None:\n        raise credentials_exception\n    return user</code></pre>\n<p>第三步，用依赖项保护路由。现在，只有携带有效令牌的请求才能创建项目：</p>\n<pre class=\"highlighter-hljs\" style=\"background-color: rgba(246, 248, 250, 1); padding: 15px; border-radius: 5px;\"><code>@app.post(\"/secure-items/\")\ndef create_secure_item(\n    item_data: schemas.ItemCreate,\n    db: Session = Depends(get_db),\n    current_user: models.User = Depends(get_current_user) # 🔒 关键的保护层\n):\n    # 现在可以安全地创建，因为用户已通过认证\n    ...</code></pre>\n<h2>⚡ 第三部分：驯服并发——连接池与异步</h2>\n<p>当100个顾客同时点餐，只有1个服务员（数据库连接）会怎样？拥堵！SQLite在默认设置下对并发的支持较弱，但通过正确配置连接池，可以极大改善。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">核心：使用<code style=\"color: rgba(186, 55, 42, 1);\">databases</code>库和异步SQLAlchemy。</strong></p>\n<pre class=\"highlighter-hljs\" style=\"background-color: rgba(246, 248, 250, 1); padding: 15px; border-radius: 5px;\"><code># database_async.py\nfrom sqlalchemy.ext.asyncio import create_async_engine, AsyncSession\nfrom sqlalchemy.orm import sessionmaker\n\n# 使用aiosqlite驱动\nASYNC_DATABASE_URL = \"sqlite+aiosqlite:///./test_async.db\"\nasync_engine = create_async_engine(ASYNC_DATABASE_URL, pool_pre_ping=True, pool_size=10, max_overflow=20)\n\nAsyncSessionLocal = sessionmaker(\n    bind=async_engine,\n    class_=AsyncSession,\n    expire_on_commit=False\n)\n\nasync def get_async_db():\n    async with AsyncSessionLocal() as session:\n        yield session\n\n# 在FastAPI路由中使用\n@app.post(\"/async-items/\", response_model=schemas.Item)\nasync def create_async_item(\n    item: schemas.ItemCreate,\n    db: AsyncSession = Depends(get_async_db)\n):\n    db_item = models.Item(**item.dict())\n    db.add(db_item)\n    await db.commit()\n    await db.refresh(db_item)\n    return db_item</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">关键参数解释：</strong></p>\n<div>\n<p>- <code style=\"color: rgba(186, 55, 42, 1);\">pool_size=10</code>：保持10个常开连接，随时待命。</p>\n<p>- <code style=\"color: rgba(186, 55, 42, 1);\">max_overflow=20</code>：允许在繁忙时临时创建最多20个额外连接。</p>\n<p>- <code style=\"color: rgba(186, 55, 42, 1);\">pool_pre_ping=True</code>：自动检查连接是否存活，避免使用已断开的连接。</p>\n</div>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">重要：</strong>对于发送邮件、处理大文件等<strong>耗时但非数据库密集型</strong>操作，务必使用<code style=\"color: rgba(186, 55, 42, 1);\">BackgroundTasks</code>，避免阻塞主线程，影响API响应速度。</p>\n<h2>🧩 第四部分：整合与避坑指南</h2>\n<h3>项目结构建议</h3>\n<pre class=\"highlighter-hljs\" style=\"background-color: rgba(246, 248, 250, 1); padding: 15px; border-radius: 5px;\"><code>your_project/\n├── main.py          # FastAPI应用创建和路由聚合\n├── models.py        # SQLAlchemy数据模型\n├── schemas.py       # Pydantic请求/响应模型（用于数据验证）\n├── crud.py          # 核心的数据库操作函数\n├── database.py      # 数据库引擎和会话工厂（同步/异步）\n├── auth.py          # 认证、令牌相关函数\n├── security.py      # 密码哈希函数\n└── dependencies.py  # 可重用的FastAPI依赖项</code></pre>\n<h3>一个强化版的主文件示例</h3>\n<pre class=\"highlighter-hljs\" style=\"background-color: rgba(246, 248, 250, 1); padding: 15px; border-radius: 5px;\"><code># main.py 精简示例\nfrom fastapi import FastAPI, Depends, HTTPException, BackgroundTasks\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom . import models, schemas, crud, auth\nfrom .database import AsyncSessionLocal, get_async_db\n\napp = FastAPI(title=\"My Secure API\")\n# 添加CORS中间件（根据需求配置）\napp.add_middleware(CORSMiddleware, allow_origins=[\"*\"]) # 生产环境应指定具体域名\n\n@app.post(\"/token\")\nasync def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends(), db: AsyncSession = Depends(get_async_db)):\n    user = await authenticate_user(form_data.username, form_data.password, db)\n    if not user:\n        raise HTTPException(status_code=400, detail=\"用户名或密码错误\")\n    access_token = auth.create_access_token(data={\"sub\": user.username})\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n\n@app.get(\"/users/me/\")\nasync def read_users_me(current_user: models.User = Depends(auth.get_current_user)):\n    return current_user\n\n# 受保护的、异步的、带后台任务的路由示例\n@app.post(\"/items-with-notify/\")\nasync def create_item_notify(\n    item: schemas.ItemCreate,\n    background_tasks: BackgroundTasks,\n    db: AsyncSession = Depends(get_async_db),\n    current_user: models.User = Depends(auth.get_current_user)\n):\n    db_item = await crud.create_user_item(db=db, item=item, user_id=current_user.id)\n    # 假设有个发送通知的函数\n    background_tasks.add_task(send_notification, f\"新项目 {item.name} 已创建！\")\n    return db_item</code></pre>\n<h3>必须牢记的避坑点</h3>\n<div>\n<p>1️⃣ <strong style=\"color: rgba(186, 55, 42, 1);\">SQLite适用于开发与轻量生产。</strong> 用户量巨大或写入频繁时，考虑PostgreSQL或MySQL。</p>\n<p>2️⃣ <strong style=\"color: rgba(186, 55, 42, 1);\">SECRET_KEY是生命线。</strong> 必须通过环境变量传入，且定期更换。</p>\n<p>3️⃣ <strong style=\"color: rgba(186, 55, 42, 1);\">连接池参数需按压调整。</strong> <code style=\"color: rgba(186, 55, 42, 1);\">pool_size</code>和<code style=\"color: rgba(186, 55, 42, 1);\">max_overflow</code>不是越大越好，根据实际负载测试找到甜蜜点。</p>\n<p>4️⃣ <strong style=\"color: rgba(186, 55, 42, 1);\">善用异步（async/await）。</strong> 在I/O等待时释放CPU，但确保整个调用链（数据库驱动、HTTP客户端）都支持异步。</p>\n<p>5️⃣ <strong style=\"color: rgba(186, 55, 42, 1);\">验证所有输入。</strong> 始终使用Pydantic模型验证请求数据，这是防止注入和错误数据的第一道防线。</p>\n</div>\n<p>&nbsp;</p>\n<p style=\"text-align: center;\">---<strong>写在最后</strong>---<br />希望这份总结能帮你避开一些坑。如果觉得有用，不妨点个 赞👍 或 收藏⭐ 标记一下，方便随时回顾。也欢迎关注我，后续为你带来更多类似的实战解析。有任何疑问或想法，我们评论区见，一起交流开发中的各种心得与问题。</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 13:33</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ymtianyu\">一名程序媛呀</a>&nbsp;\n阅读(<span id=\"post_view_count\">189</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}