{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "模拟退火算法",
      "link": "https://www.cnblogs.com/PaperPlaneFly/p/19626799",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/PaperPlaneFly/p/19626799\" id=\"cb_post_title_url\" title=\"发布于 2026-02-20 20:14\">\n    <span>模拟退火算法</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"模拟退火算法\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220201320618-591678279.png\" />\n        模拟退火算法最早的思想由**Metropolis **等（** **1953** **）提出，** **1983** **年** **Kirkpatrick** **等将其应用于组合优化。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"模拟退火算法\">模拟退火算法</h1>\n<p>​    <strong>模拟退火算法最早的思想由</strong>Metropolis <strong>等（</strong> <strong>1953</strong> <strong>）提出，</strong> <strong>1983</strong> <strong>年</strong> <strong>Kirkpatrick</strong> <strong>等将其应用于组合优化。</strong></p>\n<p><strong>算法的目的</strong>：</p>\n<p><strong>克服优化过程陷入局部极小；</strong></p>\n<p><strong>克服初值依赖性。</strong></p>\n<h2 id=\"物理退火过程\">物理退火过程</h2>\n<p>在物理学中，<strong>退火</strong>是将金属加热到极高温度，然后让其<strong>极其缓慢</strong>地冷却的过程。</p>\n<ul>\n<li><strong>高温状态</strong>：原子运动剧烈，处于无序状态（高能量）。</li>\n<li><strong>等温过程</strong>  <strong>对于与环境换热而温度不变的封闭系统，系统状态的自发变化总是朝自由能减少的方向进行，当自由能达到最小时，系统达到平衡态；</strong></li>\n<li><strong>缓慢冷却</strong>：原子逐渐找到最稳定的位置，形成整齐的晶体结构。</li>\n<li><strong>最终状态</strong>：系统的<strong>内能最低</strong>（全局最优）。</li>\n</ul>\n<p>如果冷却得太快（<strong>淬火</strong>，Quenching），原子来不及调整位置就被“冻结”在杂乱的状态，系统处于亚稳态（局部最优，内能较高，材料脆）。</p>\n<p>温度越低，物体的能量状态越低，到达足够的低点时，液体开始冷凝与结晶，在结晶状态时，系统的能量状态最低。缓慢降温（退火时，可达到最低能量状态；但如果快速降温（淬火，会导致不是最低能态的非晶形。</p>\n<h2 id=\"boltzmann概率分布\"><strong>Boltzmann</strong>概率分布</h2>\n<p>在温度T，分子停留在状态r满足Boltzmann概率分布</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200000416-839968077.png\" /></p>\n<p><img alt=\"科学网—科学史-物理学编年史-80玻尔兹曼分布律 - 张延年的博文\" src=\"https://ts3.tc.mm.bing.net/th/id/OIP-C.F28T_kCjs5-MqGcOpdgA9wHaE1?rs=1&amp;pid=ImgDetMain&amp;o=7&amp;rm=3\" /></p>\n<p>在同一个温度T，选定两个能量E1&lt;E2，有</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200026317-2005365913.png\" /></p>\n<p><strong>（</strong>1<strong>）在同一个温度，分子停留在能量小状态的概率大于停留在能量大状态的概率</strong></p>\n<p><strong>（</strong>2<strong>）温度越高，不同能量状态对应的概率相差越小；温度足够高时，各状态对应概率基本相同。</strong></p>\n<p><strong>（</strong>3<strong>）随着温度的下降，能量最低状态对应概率越来越大；温度趋于</strong>0<strong>时，其状态趋于</strong>1</p>\n<h2 id=\"metropolis准则\"><strong>Metropolis</strong>准则</h2>\n<p><strong>以概率接受新状态</strong></p>\n<p>假设当前状态为 x，能量为 E(x)。</p>\n<p>我们随机生成了一个邻域新解 x'，能量为 E(x')。</p>\n<p>定义能量差为：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200221455-1081080706.png\" /></p>\n<p>简单来说，它的核心数学思想是：<strong>以一定的概率接受一个“更差”的解，从而跳出局部最优陷阱，最终趋向全局最优。</strong></p>\n<h4 id=\"情况-a新解更好-δe0\">情况 A：新解更好 (Δ<em>E</em>&lt;0)</h4>\n<p>如果新解的能量更低（比如在下山），我们<strong>100% 接受</strong>这个新解。</p>\n<p><em>P</em>(accept)=1</p>\n<p>这对应了贪心算法（Gradient Descent）的部分。</p>\n<h4 id=\"情况-b新解更差-δe0\">情况 B：新解更差 (Δ<em>E</em>&gt;0)</h4>\n<p>如果新解的能量更高（比如要爬坡，反方向），我们<strong>不是直接拒绝</strong>，而是<strong>以一定的概率接受它</strong>。这个概率 <em>P</em> 服从 <strong>玻尔兹曼分布 (Boltzmann Distribution)</strong>：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200357347-1971444950.png\" /></p>\n<ul>\n<li>\n<p>Δ<em>E</em>：能量差（肯定为正）。</p>\n</li>\n<li>\n<p><em>T</em>：当前的温度。</p>\n</li>\n<li>\n<p><em>k</em>：物理中的玻尔兹曼常数（在算法中通常设为 1）。</p>\n</li>\n</ul>\n<h4 id=\"1-温度-t-极高时-探索阶段\">(1) 温度 T 极高时 (探索阶段)</h4>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200411620-1794628474.png\" /></p>\n<p>接受概率接近 100%。哪怕新解比旧解差很多，算法也会接受。</p>\n<p>算法在搜索空间中<strong>随机游走 (Random Walk)</strong>，像个醉汉。这保证了它能翻越极高的山峰，从深坑里跳出来，遍历整个空间。</p>\n<h4 id=\"2-温度-t-降低时-过渡阶段\">(2) 温度 T 降低时 (过渡阶段)</h4>\n<p>随着 T 变小，分母变小，指数部分变成较大的负数。<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200433875-1909155565.png\" /></p>\n<p>如果Delta E 很大（解变差很多），概率 P<span class=\"math inline\">\\(就会很小；如果 \\Delta E\\)</span>很小（只差一点点），概率 P$还比较大。</p>\n<p>算法开始变得挑剔。它仍然允许跳出浅坑（局部最优），但不再接受那些太离谱的差解。</p>\n<h4 id=\"3-温度-t-极低时-收敛阶段\">(3) 温度 T 极低时 (收敛阶段)</h4>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200452308-1356373863.png\" /></p>\n<p>接受更差解的概率几乎为 0。</p>\n<p>算法退化为<strong>贪心算法 (Hill Climbing)</strong>。它只接受好解，不再爬坡。这时候它应该已经落入了全局最优</p>\n<h2 id=\"降温系数\">降温系数</h2>\n<p>在每一个固定的温度 T下，算法进行多次迭代。这实际上是在生成一个马尔可夫链。 如果迭代次数足够多，系统会达到服从玻尔兹曼分布<strong>热平衡分布 (Stationary Distribution)</strong>。</p>\n<p>当 T缓慢下降时，概率分布图会变得越来越尖（Peaked），大部分概率密度会集中在全局最小值的附近。</p>\n<p>引入冷却系数：</p>\n<p><strong>数学上的最优降温 (对数冷却)</strong>： Geman 在 1984 年证明，如果降温速度足够慢，满足：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200507935-837856176.png\" /></p>\n<p>那么模拟退火以<strong>概率 1 收敛到全局最优解</strong>。 <em>缺点</em>：这个速度太慢了，慢到实际上无法使用（可能需要几百年）。</p>\n<p><strong>工程上的降温 (指数冷却)</strong>：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200518474-1965198914.png\" /></p>\n<p>这是对收敛速度和求解质量的折衷。虽然理论上不保证 100% 找到全局最优，但在有限时间内能找到“足够好”的解。</p>\n<h2 id=\"rosenbrock-函数验证\">Rosenbrock 函数验证</h2>\n<p>N 维 Rosenbrock 函数的通常定义如下：</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{x}) = \\sum_{i=1}^{N-1} [100 (x_{i+1} - x_i^2)^2 + (1 - x_i)^2]\n\\]</div><p></p><p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200541507-1548156741.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200605031-939946155.png\" /></p>\n<h2 id=\"c库代码如下\">c++库代码如下</h2>\n<p>sa.hpp</p>\n<pre><code>#ifndef SA_SA_HPP\n#define SA_SA_HPP\n\n\n#include \"params.hpp\"\n#include \"policies.hpp\"\n#include \"detail/solver.hpp\"\n\nnamespace sa {\n\n\n    /**\n     * @brief 模拟退火通用求解函数\n     * * @tparam State 状态类型 (自动推导)\n     * @tparam EnergyFunc 能量函数类型 (自动推导)\n     * @tparam NeighborFunc 邻域函数类型 (可选)\n     * @tparam CoolingPolicy 降温策略 (可选)\n     * @tparam ConstraintPolicy 约束策略 (可选)\n     * * @param initial_state 初始状态值\n     * @param energy_func 能量函数句柄\n     * @param params 算法参数配置\n     * @param neighbor 邻域生成器实例\n     * @param cooling 降温器实例\n     * @param constraint 约束器实例\n     * @return std::pair&lt;State, double&gt; {最优状态, 最优能量值}\n     */\n    template&lt;\n            typename State,\n            typename EnergyFunc,\n            typename NeighborFunc = DefaultNeighbor&lt;State&gt;,\n            typename CoolingPolicy = ExponentialCooling,\n            typename ConstraintPolicy = std::nullptr_t\n    &gt;\n    auto solve(\n            const State&amp; initial_state,\n            EnergyFunc energy_func,\n            Params params = Params{},\n            NeighborFunc neighbor = NeighborFunc{},\n            CoolingPolicy cooling = CoolingPolicy{},\n            ConstraintPolicy constraint = ConstraintPolicy{}\n    ) {\n        using AcceptancePolicy = MetropolisAcceptance;\n\n        detail::Solver&lt;State, EnergyFunc, NeighborFunc, CoolingPolicy, AcceptancePolicy, ConstraintPolicy&gt;\n                solver(params, energy_func, neighbor, cooling, AcceptancePolicy{}, constraint);\n\n        return solver.solve(initial_state);\n    }\n\n} // namespace sa\n\n#endif // SA_SA_HPP\n</code></pre>\n<p>policies.hpp</p>\n<pre><code>#ifndef SA_POLICIES_HPP\n#define SA_POLICIES_HPP\n\n#include \"params.hpp\"\n#include \"detail/traits.hpp\"\n\n#include &lt;cmath&gt;\n#include &lt;random&gt;\n#include &lt;algorithm&gt;\n#include &lt;stdexcept&gt;\n#include &lt;vector&gt;\n\nnamespace sa {\n\n    // 默认降温策略\n    struct ExponentialCooling {\n        inline double operator()(double T, const Params&amp; p) const noexcept {\n            return T * p.alpha;\n        }\n    };\n\n\n    // 默认接受策略 (Metropolis 准则)\n    struct MetropolisAcceptance {\n        template&lt;typename RNG&gt;\n        bool operator()(double delta_E,\n                        double T,\n                        RNG&amp; rng,\n                        std::uniform_real_distribution&lt;double&gt;&amp; dist) const\n        {\n            if (delta_E &lt; 0.0) return true;\n            return std::exp(-delta_E / T) &gt; dist(rng);\n        }\n    };\n\n\n    // 默认连续邻域生成策略\n    template&lt;typename State&gt;\n    struct DefaultNeighbor {\n        double sigma = 1.0;\n\n        State operator()(const State&amp; current,\n                         double T,\n                         std::mt19937&amp; rng) const\n        {\n            if constexpr (std::is_arithmetic_v&lt;State&gt;) {\n                std::normal_distribution&lt;double&gt; dist(0.0, sigma * T);\n                return static_cast&lt;State&gt;(current + dist(rng));\n            }\n            else if constexpr (detail::is_std_vector_v&lt;State&gt;) {\n                using ValueType = typename State::value_type;\n                static_assert(std::is_arithmetic_v&lt;ValueType&gt;,\n                              \"vector value type must be arithmetic\");\n\n                std::normal_distribution&lt;double&gt; dist(0.0, sigma * T);\n                State candidate = current;\n                for (auto&amp; v : candidate)\n                    v = static_cast&lt;ValueType&gt;(v + dist(rng));\n                return candidate;\n            }\n            else {\n                static_assert(sizeof(State) == 0, \"No default neighbor for this State type\");\n                return current;\n            }\n        }\n    };\n\n\n    // 离散翻转邻域策略 (针对 vector&lt;bool&gt; 或 vector&lt;int&gt;)\n    template&lt;typename State&gt;\n    struct DiscreteFlipNeighbor {\n        State operator()(const State&amp; current,\n                         double T,\n                         std::mt19937&amp; rng) const\n        {\n            static_assert(detail::is_std_vector_v&lt;State&gt;, \"DiscreteFlipNeighbor requires std::vector\");\n            using ValueType = typename State::value_type;\n\n            static_assert(\n                    std::is_same_v&lt;ValueType, int&gt; || std::is_same_v&lt;ValueType, bool&gt;,\n                    \"DiscreteFlipNeighbor requires vector&lt;int&gt; or vector&lt;bool&gt;\"\n            );\n\n            State candidate = current;\n            std::uniform_int_distribution&lt;std::size_t&gt; dist(0, candidate.size() - 1);\n            std::size_t idx = dist(rng);\n\n            if constexpr (std::is_same_v&lt;ValueType, bool&gt;)\n                candidate[idx] = !candidate[idx];\n            else\n                candidate[idx] = 1 - candidate[idx];\n\n            return candidate;\n        }\n    };\n\n\n    // 边界约束策略 (Box Constraint)\n    template&lt;typename State&gt;\n    class BoxConstraintPolicy {\n    public:\n        using ValueType = std::conditional_t&lt;\n                std::is_arithmetic_v&lt;State&gt;,\n                State,\n                typename State::value_type&gt;;\n\n        BoxConstraintPolicy(ValueType lower, ValueType upper)\n                : lower_(lower), upper_(upper) {}\n\n        void apply(State&amp; state) const noexcept {\n            if constexpr (std::is_arithmetic_v&lt;State&gt;) {\n                state = std::clamp(state, lower_, upper_);\n            }\n            else {\n                for (auto&amp; v : state)\n                    v = std::clamp(v, lower_, upper_);\n            }\n        }\n\n    private:\n        ValueType lower_;\n        ValueType upper_;\n    };\n\n} // namespace sa\n\n#endif // SA_POLICIES_HPP\n</code></pre>\n<p>params.hpp</p>\n<pre><code>//\n// Created by 31007 on 2026/2/12.\n//\n\n#ifndef MATH_TYPES_HPP\n#define MATH_TYPES_HPP\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\nnamespace sa {\n    struct Params {\n        double      initial_temp     = 100.0;       // 初始温度\n        double      final_temp       = 1e-6;        // 终止温度\n        double      alpha            = 0.98;        // 降温系数\n        std::size_t iter_per_temp    = 100;         // 每个温度下的迭代次数\n        std::size_t max_total_iters  = 1'000'000;   // 最大总迭代次数 (防止死循环)\n        std::uint32_t seed           = 0;           // 随机种子 (0表示随机)\n    };\n\n} // namespace sa\n#endif //MATH_TYPES_HPP\n</code></pre>\n<p>solver.hpp</p>\n<pre><code>#ifndef SA_DETAIL_SOLVER_HPP\n#define SA_DETAIL_SOLVER_HPP\n\n#include \"../params.hpp\"\n#include &lt;random&gt;\n#include &lt;utility&gt;\n#include &lt;stdexcept&gt;\n\nnamespace sa::detail {\n\n    template&lt;\n            typename State,\n            typename EnergyFunc,\n            typename NeighborFunc,\n            typename CoolingPolicy,\n            typename AcceptancePolicy,\n            typename ConstraintPolicy\n    &gt;\n    class Solver {\n    public:\n        Solver(Params params,\n               EnergyFunc energy,\n               NeighborFunc neighbor,\n               CoolingPolicy cooling,\n               AcceptancePolicy acceptance,\n               ConstraintPolicy constraint)\n                : params_(params),\n                  energy_(energy),\n                  neighbor_(neighbor),\n                  cooling_(cooling),\n                  acceptance_(acceptance),\n                  constraint_(constraint),\n                  dist_(0.0, 1.0)\n        {\n            validate_params();\n\n            if (params_.seed == 0) {\n                std::random_device rd;\n                rng_ = std::mt19937(rd());\n            } else {\n                rng_ = std::mt19937(params_.seed);\n            }\n        }\n\n        std::pair&lt;State, double&gt; solve(const State&amp; initial_state) {\n            State current = initial_state;\n            double current_energy = energy_(current);\n\n            State best = current;\n            double best_energy = current_energy;\n\n            double T = params_.initial_temp;\n            std::size_t total_iters = 0;\n\n            while (T &gt; params_.final_temp &amp;&amp; total_iters &lt; params_.max_total_iters) {\n                for (std::size_t i = 0;\n                     i &lt; params_.iter_per_temp &amp;&amp; total_iters &lt; params_.max_total_iters;\n                     ++i, ++total_iters)\n                {\n                    State candidate = neighbor_(current, T, rng_);\n\n                    // 编译期判断是否存在约束策略\n                    if constexpr (!std::is_same_v&lt;ConstraintPolicy, std::nullptr_t&gt;) {\n                        constraint_.apply(candidate);\n                    }\n\n                    double candidate_energy = energy_(candidate);\n                    double delta = candidate_energy - current_energy;\n\n                    if (acceptance_(delta, T, rng_, dist_)) {\n                        current = std::move(candidate);\n                        current_energy = candidate_energy;\n\n                        if (current_energy &lt; best_energy) {\n                            best = current;\n                            best_energy = current_energy;\n                        }\n                    }\n                }\n                T = cooling_(T, params_);\n            }\n\n            return {std::move(best), best_energy};\n        }\n\n    private:\n        void validate_params() {\n            if (params_.initial_temp &lt;= 0.0) throw std::invalid_argument(\"initial_temp must be &gt; 0\");\n            if (params_.final_temp &lt;= 0.0) throw std::invalid_argument(\"final_temp must be &gt; 0\");\n            if (params_.alpha &lt;= 0.0 || params_.alpha &gt;= 1.0) throw std::invalid_argument(\"alpha must be in (0,1)\");\n            if (params_.iter_per_temp == 0) throw std::invalid_argument(\"iter_per_temp must be &gt; 0\");\n        }\n\n        Params params_;\n        EnergyFunc energy_;\n        NeighborFunc neighbor_;\n        CoolingPolicy cooling_;\n        AcceptancePolicy acceptance_;\n        ConstraintPolicy constraint_;\n\n        std::mt19937 rng_;\n        std::uniform_real_distribution&lt;double&gt; dist_;\n    };\n\n} // namespace sa::detail\n\n#endif // SA_DETAIL_SOLVER_HPP\n</code></pre>\n<p>traits.hpp</p>\n<pre><code>#ifndef SA_DETAIL_TRAITS_HPP\n#define SA_DETAIL_TRAITS_HPP\n\n#include &lt;vector&gt;\n#include &lt;type_traits&gt;\n\nnamespace sa::detail {\n\n    // 类型萃取：判断是否为 std::vector\n\n    template&lt;typename T&gt;\n    struct is_std_vector : std::false_type {};\n\n    template&lt;typename T, typename Alloc&gt;\n    struct is_std_vector&lt;std::vector&lt;T, Alloc&gt;&gt; : std::true_type {};\n\n    template&lt;typename T&gt;\n    inline constexpr bool is_std_vector_v = is_std_vector&lt;T&gt;::value;\n\n} // namespace sa::detail\n\n#endif // SA_DETAIL_TRAITS_HPP\n</code></pre>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-20 20:14</span>&nbsp;\n<a href=\"https://www.cnblogs.com/PaperPlaneFly\">纸飞机低空飞行</a>&nbsp;\n阅读(<span id=\"post_view_count\">28</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "手把手教你使用vscode开发stm32！",
      "link": "https://www.cnblogs.com/chenyouyuan/p/19626759",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/chenyouyuan/p/19626759\" id=\"cb_post_title_url\" title=\"å‘å¸ƒäºŽ 2026-02-20 19:31\">\n    <span>æ‰‹æŠŠæ‰‹æ•™ä½ ä½¿ç”¨vscodeå¼€å‘stm32ï¼</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        å·²ç»2026å¹´äº†ï¼Œä½ æ˜¯å¦è¿˜åœ¨ä½¿ç”¨å¤è€çš„keil5çš„è°ƒè¯•å‘¢ï¼Ÿæ˜¯å¦è¿˜åœ¨ä¸ºkeil5å¤åˆ¶ç²˜è´´ä»£ç åˆ°èŠå¤©å¼aiå†ç²˜è´´å›žæ¥è€Œçƒ¦æ¼å‘¢ï¼Ÿå¿«å¿«åŠ å…¥vscodeå¼€å‘stm32çš„å¤§éƒ¨é˜ŸæŽ¥å—å…‰è£çš„è¿›åŒ–å§ï¼\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"å¼€å‘å·¥å…·é…ç½®ç¯‡è¿ŽæŽ¥æ–°æ—¶ä»£--ä½¿ç”¨vscodeå¼€å‘stm32\">å¼€å‘å·¥å…·é…ç½®ç¯‡ï¼šè¿ŽæŽ¥æ–°æ—¶ä»£--ä½¿ç”¨vscodeå¼€å‘stm32</h1>\n<blockquote>\n<p>å·²ç»2026å¹´äº†ï¼Œä½ æ˜¯å¦è¿˜åœ¨ä½¿ç”¨å¤è€çš„keil5çš„è°ƒè¯•å‘¢ï¼Ÿæ˜¯å¦è¿˜åœ¨ä¸ºkeil5å¤åˆ¶ç²˜è´´ä»£ç åˆ°èŠå¤©å¼aiå†ç²˜è´´å›žæ¥è€Œçƒ¦æ¼å‘¢ï¼Ÿå¿«å¿«åŠ å…¥vscodeå¼€å‘stm32çš„å¤§éƒ¨é˜ŸæŽ¥å—å…‰è£çš„è¿›åŒ–å§ï¼</p>\n</blockquote>\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">ç›®å½•</div><ul><li><a href=\"#å¼€å‘å·¥å…·é…ç½®ç¯‡è¿ŽæŽ¥æ–°æ—¶ä»£--ä½¿ç”¨vscodeå¼€å‘stm32\" rel=\"noopener nofollow\">å¼€å‘å·¥å…·é…ç½®ç¯‡ï¼šè¿ŽæŽ¥æ–°æ—¶ä»£--ä½¿ç”¨vscodeå¼€å‘stm32</a><ul><li><a href=\"#å‰è¨€\" rel=\"noopener nofollow\">å‰è¨€</a></li><li><a href=\"#æ‰€æœ‰ä¾èµ–çš„è½¯ä»¶ç™¾åº¦ç½‘ç›˜é“¾æŽ¥ä»¥åŠé…å¥—bç«™æ‰‹æŠŠæ‰‹è®²è§£è§†é¢‘\" rel=\"noopener nofollow\">æ‰€æœ‰ä¾èµ–çš„è½¯ä»¶ç™¾åº¦ç½‘ç›˜é“¾æŽ¥ä»¥åŠé…å¥—bç«™æ‰‹æŠŠæ‰‹è®²è§£è§†é¢‘</a></li><li><a href=\"#ä¸€ä¸‹è½½cubemxä»¥åŠå¯¹åº”stm32çš„halåº“\" rel=\"noopener nofollow\">ä¸€ã€ä¸‹è½½cubemxä»¥åŠå¯¹åº”stm32çš„halåº“</a></li><li><a href=\"#äºŒä¸‹è½½vscodeä»¥åŠæ’ä»¶\" rel=\"noopener nofollow\">äºŒã€ä¸‹è½½vscodeä»¥åŠæ’ä»¶</a><ul><li><a href=\"#stm32-for-vscode\" rel=\"noopener nofollow\">stm32 for vscode</a></li><li><a href=\"#makefiel\" rel=\"noopener nofollow\">makefiel</a></li></ul></li><li><a href=\"#ä¸‰stlinké©±åŠ¨å®‰è£\" rel=\"noopener nofollow\">ä¸‰ã€stlinké©±åŠ¨å®‰è£…</a></li><li><a href=\"#å››-é…ç½®å¼€å‘çŽ¯å¢ƒ\" rel=\"noopener nofollow\">å››ã€ é…ç½®å¼€å‘çŽ¯å¢ƒ</a><ul><li><a href=\"#é…ç½®çŽ¯å¢ƒå˜é‡\" rel=\"noopener nofollow\">é…ç½®çŽ¯å¢ƒå˜é‡</a></li><li><a href=\"#å…³äºŽlaunchjsonæ–‡ä»¶\" rel=\"noopener nofollow\">å…³äºŽlaunch.jsonæ–‡ä»¶</a></li><li><a href=\"#å…³äºŽtasksjsonæ–‡ä»¶\" rel=\"noopener nofollow\">å…³äºŽtasks.jsonæ–‡ä»¶</a></li></ul></li><li><a href=\"#å¼€å§‹è°ƒè¯•\" rel=\"noopener nofollow\">å¼€å§‹è°ƒè¯•</a><ul><li><a href=\"#stm32-svdæ–‡ä»¶\" rel=\"noopener nofollow\">stm32 svdæ–‡ä»¶</a></li></ul></li></ul></li></ul></div><p></p>\n<p>æœ¬ç¯‡æ–‡ç« ä¸»è¦å‚è€ƒæ¹–å—å¤§å­¦robomasterè·ƒé¹¿æˆ˜é˜Ÿçš„ç”µæŽ§å¼€æºéƒ¨åˆ†</p>\n<p><a href=\"https://gitee.com/hnuyuelurm/basic_framework/blob/master/.Doc/VSCode+Ozone%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.md\" rel=\"noopener nofollow\" target=\"_blank\">.Doc/VSCode+Ozoneä½¿ç”¨æ–¹æ³•.md Â· HNUYueLuRM/basic_framework - Gitee.com</a></p>\n<h2 id=\"å‰è¨€\">å‰è¨€</h2>\n<p>æœ¬ç¯‡æ–‡ç« ä¸»è¦ä½¿ç”¨vscode + cubemxå¹³æ›¿keil5ï¼Œå®žçŽ°å¿«é€Ÿå¼€å‘ã€å®žæ—¶å¯è§†åŒ–å˜é‡ï¼ˆå…¨å±€ï¼‰ã€å¯ä»¥æŸ¥çœ‹å¯„å­˜å™¨å†…å®¹ã€copilotè¾…åŠ©å¼€å‘....</p>\n<p>æ”¯æŒstlinkï¼Œjlinkï¼Œdaplinkè°ƒè¯•å™¨ï¼Œæš‚æ—¶æ²¡æœ‰æ‰¾åˆ°çº¯é vscodeçš„å®žæ—¶å¯è§†åŒ–å‚æ•°æ³¢å½¢å›¾åŠŸèƒ½çš„æ’ä»¶</p>\n<p>å¦‚æžœå¤§å®¶è¿˜æœ‰å…¶ä»–å¥½ç”¨çš„æ–¹æ¡ˆæ¬¢è¿Žè®¨è®ºå™¢~</p>\n<h2 id=\"æ‰€æœ‰ä¾èµ–çš„è½¯ä»¶ç™¾åº¦ç½‘ç›˜é“¾æŽ¥ä»¥åŠé…å¥—bç«™æ‰‹æŠŠæ‰‹è®²è§£è§†é¢‘\">æ‰€æœ‰ä¾èµ–çš„è½¯ä»¶ç™¾åº¦ç½‘ç›˜é“¾æŽ¥ä»¥åŠé…å¥—bç«™æ‰‹æŠŠæ‰‹è®²è§£è§†é¢‘</h2>\n<p>å¯èƒ½ç½‘ç»œåŽŸå› å¯¼è‡´ä¸€äº›å®‰è£…æ— æ³•å®Œæˆï¼Œæ‰€ä»¥è¿™è¾¹æä¾›æ‰€ç”¨åˆ°çš„æ‰€æœ‰åŒ…ï¼Œæ ¹æ®éœ€è¦å®‰è£…å³å¯<br />\né€šè¿‡ç½‘ç›˜åˆ†äº«çš„æ–‡ä»¶ï¼šall_in_one.zip<br />\né“¾æŽ¥: <a href=\"https://pan.baidu.com/s/12brC2bPmu9wWa2h-VgIZmg?pwd=9xah\" rel=\"noopener nofollow\" target=\"_blank\">https://pan.baidu.com/s/12brC2bPmu9wWa2h-VgIZmg?pwd=9xah</a> æå–ç : 9xah<br />\n--æ¥è‡ªç™¾åº¦ç½‘ç›˜è¶…çº§ä¼šå‘˜v3çš„åˆ†äº«<br />\nbç«™è§†é¢‘é“¾æŽ¥<br />\n<a href=\"https://www.bilibili.com/video/BV1ZMfGBrEFy/?vd_source=f553a12b04c16a678ddc0064cc04563c\" rel=\"noopener nofollow\" target=\"_blank\">https://www.bilibili.com/video/BV1ZMfGBrEFy/?vd_source=f553a12b04c16a678ddc0064cc04563c</a></p>\n<h2 id=\"ä¸€ä¸‹è½½cubemxä»¥åŠå¯¹åº”stm32çš„halåº“\">ä¸€ã€ä¸‹è½½cubemxä»¥åŠå¯¹åº”stm32çš„halåº“</h2>\n<p>cubemxå®˜ç½‘(éœ€è¦ç®€å•çš„æ³¨å†Œå³å¯)ï¼š</p>\n<p><a href=\"https://www.st.com/en/development-tools/stm32cubemx.html#get-software\" rel=\"noopener nofollow\" target=\"_blank\">https://www.st.com/en/development-tools/stm32cubemx.html#get-software</a></p>\n<p>ä¸‹è½½å®Œæˆä¹‹åŽç‚¹å‡»</p>\n<p><img alt=\"\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220181610339.png\" /></p>\n<p>ç›´æŽ¥åœ¨æœç´¢æ æœç´¢ä½ ä½¿ç”¨çš„stm32çš„åž‹å·ï¼Œä»¥f103ä½œä¸ºä¾‹å­</p>\n<p><img alt=\"image-20260220181746320\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220181746320.png\" /></p>\n<p>åŒå‡»è¦é€‰æ‹©çš„æ¿å­å³å¯è¿›å…¥</p>\n<p>å…¶ä½™è¯¦ç»†çš„é…ç½®å¯ä»¥å‚è€ƒå…¶ä»–æ•™ç¨‹</p>\n<p>ä¸»è¦æ³¨æ„çš„æ˜¯ï¼š</p>\n<p>sysçš„é…ç½®è¦é…ç½®æˆswæ¨¡å¼ï¼Œä¸ç„¶ä¼šåªèƒ½çƒ§å½•ä¸€æ¬¡</p>\n<p><img alt=\"image-20260220181938762\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220181938762.png\" /></p>\n<p>å¯¼å‡ºè¿™è¾¹é€‰æ‹©makefile</p>\n<p><img alt=\"image-20260220182046638\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220182046638.png\" /></p>\n<h2 id=\"äºŒä¸‹è½½vscodeä»¥åŠæ’ä»¶\">äºŒã€ä¸‹è½½vscodeä»¥åŠæ’ä»¶</h2>\n<p>vscodeå®˜ç½‘ï¼š</p>\n<p><a href=\"https://www.st.com/en/development-tools/stm32cubemx.html#get-software\" rel=\"noopener nofollow\" target=\"_blank\">https://www.st.com/en/development-tools/stm32cubemx.html#get-software</a></p>\n<p>éœ€è¦å®‰è£…çš„vscdoeæ’ä»¶ï¼š</p>\n<p>ç‚¹å‡»vscodeå·¦ä¾§çš„è¿™ä¸ªå›¾æ ‡</p>\n<p><img alt=\"image-20260220174816604\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220174816604.png\" /></p>\n<h3 id=\"stm32-for-vscode\">stm32 for vscode</h3>\n<p><img alt=\"image-20260220160002646\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220160002646.png\" /></p>\n<p><img alt=\"image-20260220155925565\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220155925565.png\" /></p>\n<p>ç‚¹å‡»install build tools</p>\n<p><img alt=\"image-20260220175156853\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220175156853.png\" /></p>\n<p>å‡ºçŽ°å¦‚ä¸Šé¡µé¢å³ä»£è¡¨å®‰è£…æˆåŠŸï¼ˆå¤§çº¦5~15åˆ†é’Ÿï¼‰</p>\n<p>å¦‚æžœç½‘ç»œä¸å¥½å£è¯­åˆ‡æ¢æ‰‹æœºçƒ­ç‚¹å†æ¬¡å°è¯•</p>\n<p>è¿˜ä¸è¡Œå°±ç›´æŽ¥ä½¿ç”¨æˆ‘çš„ç™¾åº¦ç½‘ç›˜åˆ†äº«çš„zipåŽ‹ç¼©åŒ…ï¼Œå»ºè®®æ”¾åˆ°dç›˜ï¼ˆå¦‚æžœæœ‰çš„è¯ï¼‰</p>\n<h3 id=\"makefiel\">makefiel</h3>\n<p><img alt=\"image-20260220155854381\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220155854381.png\" /></p>\n<h2 id=\"ä¸‰stlinké©±åŠ¨å®‰è£…\">ä¸‰ã€stlinké©±åŠ¨å®‰è£…</h2>\n<p>å¦‚æžœä½ ä¹‹å‰æ²¡æœ‰ä½¿ç”¨è¿‡stlinkï¼Œè¯·æ ¹æ®å¦‚ä¸‹é“¾æŽ¥å®Œæˆstlinké©±åŠ¨çš„å®‰è£…</p>\n<p><a href=\"https://www.st.com.cn/zh/development-tools/stsw-link009.html\" rel=\"noopener nofollow\" target=\"_blank\">STSW-LINK009 | Software - æ„æ³•åŠå¯¼ä½“</a><br />\næ ¹æ®è‡ªå·±çš„ç”µè„‘é…ç½®åŒå‡»ä»¥ä¸‹ä¸¤ä¸ªexeä¸­çš„ä¸€ä¸ª</p>\n<p><img alt=\"image-20260220184946316\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220184946316.png\" /></p>\n<h2 id=\"å››-é…ç½®å¼€å‘çŽ¯å¢ƒ\">å››ã€ é…ç½®å¼€å‘çŽ¯å¢ƒ</h2>\n<h3 id=\"é…ç½®çŽ¯å¢ƒå˜é‡\">é…ç½®çŽ¯å¢ƒå˜é‡</h3>\n<ol>\n<li>\n<p>åœ¨vscodeæ‰¾åˆ°æœ€å·¦è¾¹çš„å››ä¸ªæ–¹å—å›¾æ ‡ï¼Œè¿™é‡Œæ˜¯æˆ‘ä»¬å®‰è£…æ‹“å±•çš„åœ°æ–¹</p>\n<p>ç‚¹å‡»ä¹‹åŽæ‰¾åˆ°stm32 for vscode</p>\n<p><img alt=\"image-20260220174706404\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220174706404.png\" /></p>\n</li>\n<li>\n<p>æ‰“å¼€è¯¦æƒ…é¡µé¢--&gt;ç‚¹å‡»å³ä¸‹è§’è“è‰²çš„ç¼“å­˜æ–‡å­—ï¼Œæ‰“å¼€ç¼“å­˜æ–‡ä»¶å¤¹</p>\n<p><img alt=\"image-20260220175025884\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220175025884.png\" /></p>\n<p>ç¼“å­˜æ–‡ä»¶å¤¹å¦‚ä¸‹</p>\n<p><img alt=\"image-20260220175310991\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220175310991.png\" /></p>\n</li>\n<li>\n<p>è¿›å…¥@å¼€å¤´çš„æ–‡ä»¶å¤¹,å¦‚ä¸‹ï¼Œæˆ‘ä»¬ä¸ºäº†æ–¹ä¾¿ï¼ŒæŠŠè¯¥æ–‡ä»¶å¤¹ä¸‹é¢æ‰€æœ‰çš„ä¸œè¥¿è¿ç§»åˆ°Dç›˜ï¼ˆå¦‚æžœæœ‰çš„è¯ï¼‰ï¼Œåœ¨Dç›˜ç›®å½•ä¸‹æ–°å»ºä¸€ä¸ªæ–‡ä»¶å¤¹å«stm32toolsï¼ŒæŠŠæ–‡ä»¶å…¨éƒ¨æ”¾è¿›åŽ»</p>\n<p><img alt=\"image-20260220175354956\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220175354956.png\" /></p>\n<p>è¿ç§»è·¯å¾„å¦‚ä¸‹å›¾ï¼ˆå› ä¸ºè¿™ä¸ªæ¼”ç¤ºçš„æœºå™¨æ²¡æœ‰åˆ†dç›˜ï¼Œæˆ‘å°±æ”¾åˆ°cç›˜äº†ï¼‰</p>\n<p><img alt=\"image-20260220175533984\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220175533984.png\" /></p>\n</li>\n<li>\n<p>æŽ¥ä¸‹æ¥æŒ‰ä¸‹winé”®ï¼Œåœ¨æœç´¢æ æœç´¢çŽ¯å¢ƒ</p>\n<p>ç‚¹å‡»ç¼–è¾‘ç³»ç»ŸçŽ¯å¢ƒå˜é‡</p>\n<p><img alt=\"\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220174138545.png\" /></p>\n<p>ç‚¹å‡»æœ€ä¸‹é¢çš„çŽ¯å¢ƒå˜é‡ï¼ˆNï¼‰</p>\n<p><img alt=\"image-20260220174230783\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220174230783.png\" /></p>\n<p>åŒå‡»path</p>\n<p><img alt=\"image-20260220174323481\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220174323481.png\" /></p>\n<p>ç‚¹å‡»å³è¾¹çš„æ–°å»ºå³å¯æ–°å»ºå˜é‡ï¼Œctrl+vç²˜è´´ä¸‰ä¸ªbinçš„è·¯å¾„ï¼ˆå¦‚ä¸‹å›¾ï¼Œæ ¹æ®è‡ªå·±çš„æ–‡ä»¶ä½ç½®æ¥</p>\n<p><img alt=\"image-20260220174405199\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220174405199.png\" /></p>\n</li>\n</ol>\n<p>é…ç½®å®Œæˆä¹‹åŽwin + r</p>\n<p>åœ¨å¼¹å‡ºçš„çª—å£è¾“å…¥cmdï¼Œå›žè½¦</p>\n<p>ç²˜è´´å¦‚ä¸‹æŒ‡ä»¤è¿è¡Œ</p>\n<pre><code class=\"language-cmd\">arm-none-eabi-gcc -v\n</code></pre>\n<p>å¦‚æžœå‡ºçŽ°ç±»ä¼¼ä¸‹å›¾è¾“å‡ºï¼Œå°±ä»£è¡¨æˆåŠŸ</p>\n<p><img alt=\"image-20260220180204385\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220180204385.png\" /></p>\n<ol start=\"5\">\n<li>\n<p>æ‰“å¼€vscode è¿›å…¥åˆ°é¡¹ç›®æ–‡ä»¶å¤¹ï¼ˆå‰é¢åˆ›å»ºçš„cubemxé¡¹ç›®æ–‡ä»¶å¤¹ï¼‰</p>\n</li>\n<li>\n<p>ctrl + ï¼Œæ‰“å¼€è®¾ç½®ï¼Œæœç´¢stm32 for vscode<br />\n<img alt=\"image-20260220184204803\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220184204803.png\" /><br />\nç‚¹å‡»åœ¨settings.jsonä¸­ç¼–è¾‘,å®Œå–„å¦‚ä¸‹è·¯å¾„</p>\n<p><img alt=\"image-20260220184315477\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220184315477.png\" /><br />\nsettings.json(æ ¹æ®è‡ªå·±çš„è·¯å¾„é…ç½®)</p>\n<pre><code class=\"language-json\">{\n    \"stm32-for-vscode.openOCDPath\": \"C:\\\\stm32tools\\\\openocd\\\\0.12.0-7.1\\\\.content\\\\bin\\\\openocd.EXE\",\n    \"stm32-for-vscode.makePath\": \"C:\\\\stm32tools\\\\windows-build-tools\\\\4.4.1-3.1\\\\.content\\\\bin\\\\make.EXE\",\n    \"stm32-for-vscode.armToolchainPath\": \"C:\\\\stm32tools\\\\arm-none-eabi-gcc\\\\14.2.1-1.1.1\\\\.content\\\\bin\",\n    \"makefile.configureOnOpen\": true,\n    \"cortex-debug.stm32cubeprogrammer\": \"\",\n    \"cortex-debug.openocdPath\": \"C:\\\\stm32tools\\\\openocd\\\\0.12.0-7.1\\\\.content\\\\bin\\\\openocd.EXE\",\n    \"cortex-debug.armToolchainPath\": \"C:\\\\stm32tools\\\\arm-none-eabi-gcc\\\\14.2.1-1.1.1\\\\.content\\\\bin\",\n}\n</code></pre>\n</li>\n<li>\n<p>ctrl + ~</p>\n<p>åœ¨ç»ˆç«¯è¾“å…¥make -j12 æµ‹è¯•çœ‹çœ‹èƒ½å¦æˆåŠŸç¼–è¯‘,å¦‚ä¸‹å›¾å³ä»£è¡¨æˆåŠŸç¼–è¯‘</p>\n<p><img alt=\"image-20260220182335492\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220182335492.png\" /></p>\n</li>\n</ol>\n<h3 id=\"å…³äºŽlaunchjsonæ–‡ä»¶\">å…³äºŽlaunch.jsonæ–‡ä»¶</h3>\n<p>åœ¨å·¦è¾¹æ æ‰¾åˆ°è¿™ä¸ªå›¾æ ‡</p>\n<p><img alt=\"\" /></p>\n<p>ç‚¹å‡»ä¸€ä¸‹é‡Œé¢çš„åˆ›å»ºlaunchæ–‡ä»¶</p>\n<p>å°±å¯ä»¥åœ¨ç›®å½•çš„.vscodeæ–‡ä»¶å¤¹ä¸‹æ‰¾åˆ°</p>\n<p><img alt=\"image-20260220160146084\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220160146084.png\" /></p>\n<p>æˆ‘ä»¬ç›´æŽ¥å¤åˆ¶ä¸‹é¢æˆ‘ä¿®æ”¹å¥½çš„stlinkçš„ä»£ç ï¼ˆdaplinkã€jlinkæ¹–å¤§å¼€æºçš„giteeä»“åº“å·²ç»æä¾›ï¼‰</p>\n<pre><code class=\"language-json\">{\n    // å¯åŠ¨è°ƒè¯•çš„å¿«æ·é”®æ˜¯F5\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        // ä½¿ç”¨dap-link(å¦‚æ— çº¿è°ƒè¯•å™¨æ—¶çš„å‚è€ƒé…ç½®)\n        {\n            \"name\": \"STlink\",\n            \"cwd\": \"${workspaceRoot}\",\n            \"executable\": \"${workspaceRoot}\\\\build\\\\first.elf\", // è¦ä¸‹è½½åˆ°è°ƒè¯•å™¨çš„æ–‡ä»¶,èŠ±æ‹¬å·ä¸­çš„æ˜¯vscodeä¸¤ä¸ªé¢„å®šä¹‰çš„å‚æ•°\n            \"request\": \"launch\",\n            \"type\": \"cortex-debug\",\n            //ä½¿ç”¨J-link GDB Serveræ—¶å¿…é¡»;å…¶ä»–GBD Serveræ—¶å¯é€‰ï¼ˆæœ‰å¯èƒ½å¸®åŠ©è‡ªåŠ¨é€‰æ‹©SVDæ–‡ä»¶ï¼‰\n            //æ”¯æŒçš„è®¾å¤‡è§ https://www.segger.com/downloads/supported-devices.php\n            //svdæ–‡ä»¶ï¼Œæœ‰è¿™ä¸ªæ–‡ä»¶æ‰èƒ½æŸ¥çœ‹å¯„å­˜å™¨çš„å€¼ï¼Œæ¯ä¸ªå•ç‰‡æœºéƒ½ä¸åŒã€‚å¯ä»¥åœ¨ä»¥ä¸‹åœ°å€æ‰¾åˆ°https://github.com/modm-io/cmsis-svd-stm32 \n            //è¯¥é¡¹ç›®çš„æ ¹ç›®å½•å·²ç»æä¾›äº†Cåž‹å¼€å‘æ¿ä½¿ç”¨çš„å¤–è®¾svdæ–‡ä»¶\n            \"svdFile\": \"./STM32F103.svd\",\n            \"servertype\": \"openocd\", //ä½¿ç”¨çš„GDB Server\n            \"configFiles\": [\n                \"openocd_stlink.cfg\", // é…ç½®æ–‡ä»¶å·²ç»åœ¨æ ¹ç›®å½•æä¾›,è‹¥è¦ä¿®æ”¹ä»¥æ­¤ç±»æŽ¨,openocdçš„è·¯å¾„ä¸‹çš„share/scriptsä¸­æœ‰å„ç§å†™å¥½çš„é…ç½®æ–‡ä»¶\n            ],\n            \"runToEntryPoint\": \"main\", // è°ƒè¯•æ—¶åœ¨mainå‡½æ•°å…¥å£åœä¸‹\n            \"preLaunchTask\": \"build task\",//å…ˆè¿è¡ŒBuildä»»åŠ¡ç¼–è¯‘é¡¹ç›®,å–æ¶ˆæ³¨é‡Šå³å¯ä½¿ç”¨\n            \"liveWatch\": {\n                \"enabled\": true,\n                \"samplesPerSecond\": 4\n            }\n        },\n      \n    ],\n}\n</code></pre>\n<p>é…ç½®å®Œæˆä¹‹åŽåœ¨vscodeçš„å·¦ä¾§debugå›¾æ ‡å³å¯çœ‹åˆ°æ›´æ”¹é…ç½®çš„stlinkçš„é…ç½®<br />\n<img alt=\"image-20260220184555431\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220184555431.png\" /></p>\n<h3 id=\"å…³äºŽtasksjsonæ–‡ä»¶\">å…³äºŽtasks.jsonæ–‡ä»¶</h3>\n<p>ä½ç½®ä¸Žlaunchæ–‡ä»¶ä¸€æ ·ï¼Œæ²¡æœ‰å°±æ–°å»ºä¸€ä¸ª</p>\n<pre><code class=\"language-json\">{\n    // See https://go.microsoft.com/fwlink/?LinkId=733558\n    \"version\": \"2.0.0\",\n    \"tasks\": [\n        {\n            \"label\": \"build task\",         // ä»»åŠ¡æ ‡ç­¾\n            \"type\": \"shell\",               // ä»»åŠ¡ç±»åž‹,å› ä¸ºè¦è°ƒç”¨mingw32-make,æ˜¯åœ¨ç»ˆç«¯(CMD)é‡Œè¿è¡Œçš„,æ‰€ä»¥æ˜¯shellä»»åŠ¡\n            \"command\": \"make -j24\",// ä»»åŠ¡å‘½ä»¤,çº¿ç¨‹æ•°å¯ä»¥æ ¹æ®è‡ªå·±çš„ç”µè„‘ä¿®æ”¹,å»ºè®®ä¸Žcpuæ ¸æ•°ç›¸åŒ\n            \"problemMatcher\": [],          \n            \"group\": {\n                \"kind\": \"build\",\n                \"isDefault\": true\n            }\n        },\n        {\n            \"label\": \"download dap\",\n            \"type\": \"shell\",               // å¦‚æžœå¸Œæœ›åœ¨ä¸‹è½½å‰ç¼–è¯‘,å¯ä»¥æŠŠcommandæ¢æˆä¸‹é¢çš„å‘½ä»¤\n            \"command\":\"make -j24 ; make download_dap\", // \"mingw32-make -j24 ; mingw32-make download_dap\",\n            \"group\": {                     // å¦‚æžœæ²¡æœ‰ä¿®æ”¹ä»£ç ,ç¼–è¯‘ä»»åŠ¡ä¸ä¼šæ¶ˆè€—æ—¶é—´,å› æ­¤æŽ¨èä½¿ç”¨ä¸Šé¢çš„æ›¿æ¢.\n                \"kind\": \"build\",\n                \"isDefault\": false,\n            },\n        },\n        {\n            \"label\": \"download jlink\", // è¦ä½¿ç”¨æ­¤ä»»åŠ¡,éœ€æ·»åŠ jlinkçš„çŽ¯å¢ƒå˜é‡\n            \"type\": \"shell\",\n            \"command\":\"make -j24 ; make download_jlink\", // \"mingw32-make -j24 ; mingw32-make download_jlink\"\n            \"group\": {\n                \"kind\": \"build\",\n                \"isDefault\": false,\n            }\n        },\n        {\n            \"label\": \"log\",\n            \"type\": \"shell\",\n            \"command\":\"JlinkRTTClient\",\n            \"args\": [],\n            \"problemMatcher\": [],\n            // \"dependsOn\":[\n            //     \"build task\", // å¯ä»¥æ·»åŠ å¤šä¸ª.\n            // ]\n            // è‹¥ä½¿ç”¨daplink,åˆ™å°†logä»»åŠ¡è®¾ç½®ä¸ºä¾èµ–äºŽjlink launchä»»åŠ¡,ä¿è¯jlink launchä»»åŠ¡å…ˆäºŽlogä»»åŠ¡æ‰§è¡Œ\n        }\n    ]\n}\n</code></pre>\n<h2 id=\"å¼€å§‹è°ƒè¯•\">å¼€å§‹è°ƒè¯•</h2>\n<p>åˆ°æ­¤é…ç½®åº”å½“å·²ç»å®Œæˆäº†ï¼ŒæŽ¥å¥½stlinkï¼Œè¿žæŽ¥å¥½stm32åŽå°±å¯ä»¥æ„‰å¿«çš„è°ƒè¯•å•¦ï¼Œç‚¹å‡»ç»¿è‰²çš„ä¸‰è§’å½¢å¼€å§‹ç¼–è¯‘å¹¶çƒ§å½•åˆ°å•ç‰‡æœº<br />\n<img alt=\"image-20260220184555431\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220184555431.png\" /></p>\n<p>ç­‰å¾…ä¸€ä¼šåŽï¼Œå°±ä¼šå‡ºçŽ°ä¸‹å›¾æ‰€ç¤ºçš„è°ƒè¯•ç•Œé¢<br />\n<img alt=\"image-20260220185452486\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220185452486.png\" /><br />\nåœ¨å·¦ä¾§å°±æ˜¯è°ƒè¯•å¸¸ç”¨çš„ä¸€äº›å·¥å…·<br />\n<img alt=\"image-20260220185552784\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220185552784.png\" /></p>\n<p>cortex live watchå¯ä»¥å®žæ—¶æŸ¥çœ‹å…¨å±€å˜é‡çš„å€¼ï¼Œåªéœ€è¦ç‚¹å‡»åŠ å·<br />\n<img alt=\"image-20260220185701085\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220185701085.png\" /></p>\n<p>ç²˜è´´éœ€è¦æŸ¥çœ‹çš„å˜é‡åç§°</p>\n<p><img alt=\"image-20260220185726335\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220185726335.png\" /></p>\n<p>å°±å¯ä»¥å®žæ—¶æŸ¥çœ‹åˆ°å˜é‡çš„å€¼å•¦</p>\n<p><img alt=\"image-20260220185758953\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220185758953.png\" /></p>\n<p>ä»Žå·¦åˆ°å³ ç¬¬ä¸€ä¸ªæ˜¯é‡ç½®resetï¼Œæš‚åœï¼Œé€è¿‡ç¨‹ï¼Œå•æ­¥ï¼Œå•æ­¥è·³å‡ºï¼Œé‡æ–°å¼€å§‹è°ƒè¯•ï¼Œé€€å‡º</p>\n<p><img alt=\"image-20260220185836594\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220185836594.png\" /></p>\n<p>XPERIPHERALSå¿…é¡»é…ç½®ä¸Šé¢çš„svdæ–‡ä»¶æ‰èƒ½å¤Ÿçœ‹åˆ°å¯„å­˜å™¨å†…éƒ¨çš„å€¼</p>\n<p><img alt=\"image-20260220190044929\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220190044929.png\" /></p>\n<p>ä½ ä¹Ÿå¯ä»¥ä¼˜é›…çš„ä½¿ç”¨copilotå·¥å…·æ›´å¿«é€Ÿçš„å¼€å‘stm32å•¦</p>\n<h3 id=\"stm32-svdæ–‡ä»¶\">stm32 svdæ–‡ä»¶</h3>\n<p>stmç³»åˆ—svdä»“åº“ï¼š</p>\n<p><a href=\"https://github.com/modm-io/cmsis-svd-stm32\" rel=\"noopener nofollow\" target=\"_blank\">modm-io/cmsis-svd-stm32: CMSIS SVD files for all STM32 devices</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-20 19:31</span>&nbsp;\n<a href=\"https://www.cnblogs.com/chenyouyuan\">ChenYY~</a>&nbsp;\né˜…è¯»(<span id=\"post_view_count\">42</span>)&nbsp;\nè¯„è®º(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">æ”¶è—</a>&nbsp;\n<a href=\"\">ä¸¾æŠ¥</a>\n</div>"
    },
    {
      "title": "凸优化数学基础笔记（六）：凸集、凸函数与凸规划",
      "link": "https://www.cnblogs.com/GeophysicsWorker/p/19626486",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/GeophysicsWorker/p/19626486\" id=\"cb_post_title_url\" title=\"发布于 2026-02-20 14:30\">\n    <span>凸优化数学基础笔记（六）：凸集、凸函数与凸规划</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        现有最优化方法对一般函数只能找到局部最优解，判断有无极值点以及它是否为全局最优解要用到函数凸性概念。一般在现实优化问题上，我们一般把优化问题变成凸优化问题，因为凸优化，**凸优化（Convex OPtimization）**是数学优化中的一个重要分支，研究的是在凸集上极小值的问题。下面首先介绍凸集。从直观上看，凸集是这样一些点的集合，它的内部没有“洞”（hole），边界不向内凹。凸集的基本特征，是其上任取两点所联成线段上的点依然属于这个集合。在数学上就是采用这种描述方法给凸集下定义的。首先给出凸组合的概念，在给出凸集和凸函数的定义，并简单讨论凸函数判定方法\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"凸优化数学基础笔记六凸集凸函数与凸规划\">凸优化数学基础笔记（六）：凸集、凸函数与凸规划</h1>\n<p>现有最优化方法对一般函数只能找到局部最优解，判断有无极值点以及它是否为全局最优解要用到函数凸性概念。一般在现实优化问题上，我们一般把优化问题变成凸优化问题，因为凸优化，凸优化（Convex OPtimization）是数学优化中的一个重要分支，研究的是在凸集上极小值的问题。下面首先介绍凸集。从直观上看，凸集是这样一些点的集合，它的内部没有“洞”（hole），边界不向内凹。凸集的基本特征，是其上任取两点所联成线段上的点依然属于这个集合。在数学上就是采用这种描述方法给凸集下定义的。首先给出凸组合的概念，在给出凸集和凸函数的定义，并简单讨论凸函数判定方法。</p>\n<h2 id=\"1凸-集convex-set\">1.凸 集（Convex Set）</h2>\n<p>​\t<strong>Definition 6.1（凸组合定义）</strong> 设<span class=\"math inline\">\\(\\mathbf{X}_1,\\mathbf{X}_2,\\cdots,\\mathbf{X}_l\\)</span> 是<span class=\"math inline\">\\(\\mathbf{R}^n\\)</span> 中的<span class=\"math inline\">\\(l\\)</span>个已知点。若对于某个点<span class=\"math inline\">\\(\\mathbf{X}\\in\\mathbf{R}^n\\)</span> 存在常数<span class=\"math inline\">\\(\\alpha_1,\\alpha_2,\\cdots,\\alpha_{l}\\geq0\\)</span>，且<span class=\"math inline\">\\(\\sum_{i=1}^{l}\\alpha_i=1\\)</span> 使得<span class=\"math inline\">\\(\\mathbf{X}=\\sum_{i=1}^l\\alpha_i\\mathbf{X}_i\\)</span>，则称<span class=\"math inline\">\\(\\mathbf{X}\\)</span> 是<span class=\"math inline\">\\(\\mathbf{X}_1,\\mathbf{X}_2,\\cdots,\\mathbf{X}_l\\)</span> 的<strong>凸组合</strong>。若 <span class=\"math inline\">\\(\\alpha_1,\\alpha_2,\\cdots,\\alpha_l&gt;0\\)</span> 且<span class=\"math inline\">\\(\\sum_{i=1}^l\\alpha_i=1\\)</span>，则称<span class=\"math inline\">\\(\\mathbf{X}\\)</span>是<span class=\"math inline\">\\(\\mathbf{X_1},\\mathbf{X}_2,\\cdots,\\mathbf{X}_l\\)</span> 的<strong>严格凸组合</strong>。</p>\n<p>​\t考虑两点<span class=\"math inline\">\\(\\mathbf{X}_1\\)</span>和<span class=\"math inline\">\\(\\mathbf{X}_2\\)</span>的凸组合<span class=\"math inline\">\\(\\mathbf{X}=\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2\\)</span> ，其中<span class=\"math inline\">\\(\\alpha_1,\\alpha_2\\geq{0}\\)</span> 且<span class=\"math inline\">\\(\\alpha_1+\\alpha_2=1\\)</span>。把 <span class=\"math inline\">\\(\\alpha_2=1-\\alpha_1\\)</span> 代入<span class=\"math inline\">\\(\\mathbf{X}\\)</span> 的凸组合中得到<span class=\"math inline\">\\(\\mathbf{X}=\\mathbf{X}_2+\\alpha_1(\\mathbf{X}_1-\\mathbf{X}_2)\\)</span> ，其中<span class=\"math inline\">\\(\\alpha\\in[0,1]\\)</span>。由解析几何知识可知，当 <span class=\"math inline\">\\(\\alpha_1\\)</span>从0变到1时，点<span class=\"math inline\">\\(\\mathbf{X}\\)</span> 由点<span class=\"math inline\">\\(\\mathbf{X}_2\\)</span> 出发沿<span class=\"math inline\">\\(\\mathbf{X}_1-\\mathbf{X}_2\\)</span> 的方向移动到<span class=\"math inline\">\\(\\mathbf{X}_1\\)</span> 。由此可知，<span class=\"math inline\">\\(\\mathbf{X}_1\\)</span>和<span class=\"math inline\">\\(\\mathbf{X}_2\\)</span> 所有严格凸组合的集合是不含<span class=\"math inline\">\\(\\mathbf{X}_1\\)</span>和<span class=\"math inline\">\\(\\mathbf{X}_2\\)</span> 两端点的线段。</p>\n<p>​\t<strong>Definition 6.2 （凸集的定义）</strong> 设集合<span class=\"math inline\">\\(\\mathbf{C}\\subseteq{\\mathbf{R}^n}\\)</span>。如果对于任意两点<span class=\"math inline\">\\(\\mathbf{X}_1,\\mathbf{X}_2\\in{\\mathbf{C}}\\)</span> ，它们的任意两点<span class=\"math inline\">\\(\\mathbf{X}_1,\\mathbf{X}_2\\in{\\mathbf{C}}\\)</span> ，它们的任意凸组合仍然属于<span class=\"math inline\">\\(\\mathbf{C}\\)</span> ，则称集合<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 为<strong>凸集</strong>。特别地规定，空集是凸集。</p>\n<p>​\t<strong>Definition 6.3 (半空间的定义)</strong>  设<span class=\"math inline\">\\(\\mathbf{a}\\in\\mathbf{R}^n\\)</span> 且 <span class=\"math inline\">\\(\\mathbf{a}\\neq \\mathbf{0},b\\in{\\mathbf{R}^1}\\)</span> ，则集合<span class=\"math inline\">\\(\\{\\mathbf{X}|\\mathbf{a}^T\\mathbf{X}\\geq{b},\\mathbf{X}\\in{R^n}\\}\\)</span> 称为<span class=\"math inline\">\\(\\mathbf{R}^n\\)</span> 中的一个半空间。</p>\n<p>​\t容易地验证，空间<span class=\"math inline\">\\(\\mathbf{R}^n\\)</span>、半空间、超平面、直线、点、球都是凸集。</p>\n<p>​\t<strong>定理 6.1</strong> 任意一组凸集的交集仍然是<strong>凸集</strong>。</p>\n<p>​\t<strong>证 明：</strong> 设<span class=\"math inline\">\\(C=\\cap_{i\\in I}C_i\\)</span> ,其中<span class=\"math inline\">\\(I\\)</span>是<span class=\"math inline\">\\(\\{C_i\\}\\)</span> 的下标集，<span class=\"math inline\">\\(C_i\\)</span> 都是凸集。任取<span class=\"math inline\">\\(\\mathbf{X}_1,\\mathbf{X}_2\\in{C}\\)</span> , 则对于任意<span class=\"math inline\">\\(i\\in{I}\\)</span> 都有<span class=\"math inline\">\\(\\mathbf{X}_1,\\mathbf{X}_2\\in \\mathbf{C}_i\\)</span>。任取<span class=\"math inline\">\\(\\alpha_1,\\alpha_2\\in{[0,1]}\\)</span> 且<span class=\"math inline\">\\(\\alpha_1+\\alpha_2=1\\)</span>，因为<span class=\"math inline\">\\(C_i\\)</span> 是凸集，有 <span class=\"math inline\">\\(\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2\\in{C_i}\\)</span>。于是，<span class=\"math inline\">\\(\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2\\in \\cap_{i\\in{I}}C_i=C\\)</span>，即<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 是凸集。</p>\n<h2 id=\"2凸函数convex-function\">2.凸函数（Convex Function）</h2>\n<p>​\t<strong>Definition 6.4 （凸函数的定义）</strong> 设<span class=\"math inline\">\\(f:\\mathbf{C}\\subseteq\\mathbf{R}^n\\rightarrow\\mathbf{R}^1\\)</span> , 其中<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 为凸集。若对于任意两点<span class=\"math inline\">\\(\\mathbf{X}_1,\\mathbf{X}_2\\in{C}\\)</span> 和任意一对满足<span class=\"math inline\">\\(\\alpha_1+\\alpha_2=1\\)</span> 的数<span class=\"math inline\">\\(\\alpha_1,\\alpha_2\\in[0,1]\\)</span> ，都有 <span class=\"math inline\">\\(f(\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2)\\leq \\alpha_1f(\\mathbf{X}_1)+\\alpha_2f(\\mathbf{X}_2)\\)</span> ，则称<span class=\"math inline\">\\(f\\)</span> 为定义在<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 上的<strong>凸函数</strong>。若对于任意一对满足<span class=\"math inline\">\\(\\alpha_1+\\alpha_2=1\\)</span>的数<span class=\"math inline\">\\(\\alpha_1,\\alpha_2\\in(0,1)\\)</span> 都有：</p>\n<p></p><div class=\"math display\">\\[f(\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2)&lt;\\alpha_1f(\\mathbf{X}_1)+\\alpha_2f(\\mathbf{X}_2) \\tag{1}\n\\]</div><p></p><p>则称<span class=\"math inline\">\\(f\\)</span>为定义在凸集<span class=\"math inline\">\\(C\\)</span>上<strong>严格凸函数</strong>。</p>\n<p>​\t<strong>Definition 6.5</strong> 若函数<span class=\"math inline\">\\(g(\\mathbf{X})=-f(\\mathbf{X})\\)</span>在凸集<span class=\"math inline\">\\(C\\)</span> 上是（严格）凸函数，则称<span class=\"math inline\">\\(f\\)</span>是定义在凸集<span class=\"math inline\">\\(C\\)</span> 上的（严格）凹函数。</p>\n<p>​\t<strong>定理 6.2</strong> 设<span class=\"math inline\">\\(f:C\\subset\\mathbf{R}^n\\rightarrow\\mathbf{R}^1\\)</span>，其中<span class=\"math inline\">\\(\\mathbf{C}\\)</span>为非空凸集。若<span class=\"math inline\">\\(f\\)</span>是凸函数，则对于任意实数<span class=\"math inline\">\\(\\beta\\)</span>, 水平集<span class=\"math inline\">\\(\\mathbf{D}_{\\beta}=\\{\\mathbf{X}|f(\\mathbf{X})\\leq\\beta,\\mathbf{X}\\in{C}\\}\\)</span> 是凸集。</p>\n<p>​\t<strong>证  明：</strong> 若<span class=\"math inline\">\\(\\mathbf{D}_{\\beta}\\)</span>是空集，则<span class=\"math inline\">\\(\\mathbf{D}_{\\beta}\\)</span> 是凸集。以下设<span class=\"math inline\">\\(\\mathbf{D}_{\\beta}\\)</span> 非空，任取<span class=\"math inline\">\\(\\mathbf{X}_1\\)</span> ,<span class=\"math inline\">\\(\\mathbf{X}_2\\in{D_{\\beta}}\\)</span> ,  则<span class=\"math inline\">\\(f(\\mathbf{X}_1)\\leq\\beta,f(\\mathbf{X}_2)\\leq\\beta\\)</span> 。设<span class=\"math inline\">\\(\\alpha_1,\\alpha_2\\in[0,1]\\)</span> ,且<span class=\"math inline\">\\(\\alpha_1+\\alpha_2=1\\)</span> 根据<span class=\"math inline\">\\(f\\)</span>的凸性，必有</p>\n<p></p><div class=\"math display\">\\[f(\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2)\\leq \\alpha_1f(\\mathbf{X}_1)+\\alpha_2f(\\mathbf{X}_2)\\leq \\alpha_1\\beta+\\alpha_2\\beta=\\beta \\tag{2}\n\\]</div><p></p><p>即 <span class=\"math inline\">\\(\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2\\in{\\mathbf{D}_{\\beta}}\\)</span> ,所以 <span class=\"math inline\">\\(\\mathbf{D}_{\\beta}\\)</span> 是凸集。</p>\n<h2 id=\"3判断凸函数的方法\">3.判断凸函数的方法</h2>\n<p>​\t判定一个函数是否为凸函数，一般来说比较困难，但函数可微时，有如下几个定理可供使用。</p>\n<p>​\t<strong>定理 6.3</strong> 设<span class=\"math inline\">\\(f:\\mathbf{C}\\subseteq\\mathbf{R}^n\\rightarrow{\\mathbf{R}^1}\\)</span> 是可微函数，其中<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 为凸集，则：</p>\n<ol>\n<li>\n<p><span class=\"math inline\">\\(f\\)</span>为凸函数的<strong>充要条件</strong>是，<span class=\"math inline\">\\(\\forall \\mathbf{X}_1,\\mathbf{X}_2\\in{\\mathbf{C}}\\)</span>, 都有</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X}_2)\\geq f(\\mathbf{X}_1)+\\nabla{f(\\mathbf{X}_1)}^T(\\mathbf{X}_2-\\mathbf{X}_1) \\tag{3}\n\\]</div><p></p><p>​</p>\n</li>\n<li>\n<p><span class=\"math inline\">\\(f\\)</span>为严格凸函数的<strong>充要条件</strong>是，<span class=\"math inline\">\\(\\forall \\mathbf{X}_1,\\mathbf{X}_2\\in\\mathbf{C}\\)</span>,且<span class=\"math inline\">\\(\\mathbf{X}_1\\neq\\mathbf{X}_2\\)</span>,都有</p>\n</li>\n</ol>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X}_2)&gt;f(\\mathbf{X}_1)+\\nabla f(\\mathbf{X_1})^T(\\mathbf{X}_2-\\mathbf{X}_1) \\tag{4}\n\\]</div><p></p><p><strong>证 明：</strong> （1）<strong>必要性证明</strong>：已知<span class=\"math inline\">\\(f\\)</span>是<span class=\"math inline\">\\(\\mathbf{C}\\)</span>上的凸函数，证明式（3）。由凸函数定义可知，对满足<span class=\"math inline\">\\(\\alpha_1+\\alpha_2=1\\)</span> 的任意正数<span class=\"math inline\">\\(\\alpha_1,\\alpha_2\\in[0,1]\\)</span>都有</p>\n<p></p><div class=\"math display\">\\[f(\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2)\\leq\\alpha_1f(\\mathbf{X}_1)+\\alpha_2f(\\mathbf{X}_2) \\tag{5}\n\\]</div><p></p><p>令<span class=\"math inline\">\\(\\alpha_2=t\\)</span>，则<span class=\"math inline\">\\(\\alpha_1=1-t\\)</span>，代入上式中，整理得到：</p>\n<p></p><div class=\"math display\">\\[\\frac{f(\\mathbf{X}_1+t(\\mathbf{X}_2-\\mathbf{X}_1))-f(\\mathbf{X}_1)}{t}\\leq f(\\mathbf{X}_2)-f(\\mathbf{X}_1) \\tag{6}\n\\]</div><p></p><p>令 <span class=\"math inline\">\\(t\\rightarrow{0}\\)</span> ,由<span class=\"math inline\">\\(f\\)</span>的可微性，利用一阶Taylor展开式，方向导数定义及式（6）可得：</p>\n<p></p><div class=\"math display\">\\[\\nabla f(\\mathbf{X}_1)^T(\\mathbf{X}_2-\\mathbf{X}_1)\\leq {f(\\mathbf{X}_2)-f(\\mathbf{X}_1)} \\tag{7}\n\\]</div><p></p><p>必要性得证；</p>\n<p><strong>充分性证明：</strong> 任取一对正数<span class=\"math inline\">\\(\\alpha_1,\\alpha_2\\in[0,1]\\)</span> ,且<span class=\"math inline\">\\(\\alpha_1+\\alpha_2=1\\)</span>，考虑点 <span class=\"math inline\">\\(\\mathbf{X}=\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2\\)</span> 根据充分性假设，应有：</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\n&amp;f(\\mathbf{X}_1)\\geq f(\\mathbf{X})+\\nabla f(\\mathbf{X})^T(\\mathbf{X}_1-\\mathbf{X})\\\\\n&amp;f(\\mathbf{X}_2)\\geq f(\\mathbf{X})+\\nabla f(\\mathbf{X})^T(\\mathbf{X}_2-\\mathbf{X})\n\\end{aligned}\n\\tag{8}\n\\]</div><p></p><p>两式分别乘以<span class=\"math inline\">\\(\\alpha_1\\)</span> 和<span class=\"math inline\">\\(\\alpha_2\\)</span> 后相加，得到：</p>\n<p></p><div class=\"math display\">\\[\\alpha_1f(\\mathbf{X}_1)+\\alpha_2f(\\mathbf{X}_2)\\geq f(\\mathbf{X})+\\nabla f(\\mathbf{X})^T(\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2-\\mathbf{X})=f(\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2) \\tag{9} \n\\]</div><p></p><p>由凸函数定义可知，<span class=\"math inline\">\\(f\\)</span> 是<span class=\"math inline\">\\(\\mathbf{C}\\)</span>上的凸函数。</p>\n<p>​\t（2）命题（2）充分性可仿照命题（1）的充分性证得；</p>\n<p>​\t必要性：因为严格凸函数本身是凸函数，所以<span class=\"math inline\">\\(\\forall \\mathbf{X}_1,\\mathbf{X}_2\\in{\\mathbf{C}}\\)</span> ,且<span class=\"math inline\">\\(\\mathbf{X}_1\\neq\\mathbf{X}_2\\)</span> 都有</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X}_2)\\geq f(\\mathbf{X}_1)+\\nabla f(\\mathbf{X}_1)^T(\\mathbf{X}_2-\\mathbf{X}_1) \\tag{10}\n\\]</div><p></p><p>以下证明式中只能取\"&gt;\"号，假设存在<span class=\"math inline\">\\(\\mathbf{X}_1,\\mathbf{X}_2\\in{\\mathbf{C}}\\)</span> 且<span class=\"math inline\">\\(\\mathbf{X}_1\\neq\\mathbf{X}_2\\)</span> ,满足</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X}_2)=f(\\mathbf{X}_1)+\\nabla f(\\mathbf{X}_1)^T(\\mathbf{X}_2-\\mathbf{X}_1) \\tag{11}\n\\]</div><p></p><p>取<span class=\"math inline\">\\(\\mathbf{X}=\\frac{1}{2}\\mathbf{X}_1+\\frac{1}{2}\\mathbf{X}_2\\)</span> ,由<span class=\"math inline\">\\(f\\)</span> 的严格凸性，有：</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X}_3)&lt;\\frac{1}{2}f(\\mathbf{X}_1)+\\frac{1}{2}f(\\mathbf{X}_2) \\tag{12}\n\\]</div><p></p><p>把式（11）代入式（12）中，经整理得：</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X}_3)&lt;f(\\mathbf{X}_1)+\\nabla f(\\mathbf{X}_1)^T(\\mathbf{X}_3-\\mathbf{X}_1) \\tag{13}\n\\]</div><p></p><p>根据本定理（1）部分结论得知，此时与<span class=\"math inline\">\\(f\\)</span>的凸性相矛盾。</p>\n<p>​\t<strong>定 理 6.4</strong> 设<span class=\"math inline\">\\(f:\\mathbf{C}\\subseteq\\mathbf{R}^n\\rightarrow\\mathbf{R}^1\\)</span> 是二次可微函数，<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 为非空开凸集，则<span class=\"math inline\">\\(f\\)</span>为<span class=\"math inline\">\\(C\\)</span>上为凸函数的充要条件是 ，<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 的Hessian矩阵<span class=\"math inline\">\\(\\nabla^2f(\\mathbf{X})\\)</span> 在凸集<span class=\"math inline\">\\(C\\)</span> 处处半正定，即<span class=\"math inline\">\\(\\nabla^2f(\\mathbf{X})\\succeq{0}\\)</span> 。</p>\n<p>​\t<strong>定 理6.5</strong>  设<span class=\"math inline\">\\(f:\\mathbf{C}\\subseteq\\mathbf{R}^n\\rightarrow{\\mathbf{R}^1}\\)</span> 是二次可微函数，<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 为非空凸集。若<span class=\"math inline\">\\(Hessian\\)</span>矩阵<span class=\"math inline\">\\(\\nabla^2f(\\mathbf{X})\\)</span> 在凸集<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 上到处正定，则 <span class=\"math inline\">\\(f\\)</span>在<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 上为严格凸函数。</p>\n<p>​      需要注意，该定理的逆命题不真。</p>\n<p>​      例如 <span class=\"math inline\">\\(f(x)=x^4\\)</span> 在<span class=\"math inline\">\\(\\mathbf{R}^1\\)</span> 上为严格凸函数，但是它的<span class=\"math inline\">\\(Hessian\\)</span>矩阵<span class=\"math inline\">\\(\\nabla^2f(\\mathbf{x})=12x^2\\)</span>在点<span class=\"math inline\">\\(x=0\\)</span> 处是半正定的。</p>\n<h2 id=\"4凸规划-convex-programing\">4.凸规划 （Convex Programing）</h2>\n<p>​\t凸规划是数学优化中的一个重要概念，指目标函数（损失函数）为凸函数、可行域为凸集的优化问题，具有许多的优化性质，例如局部最优解就是全局最优解，且对偶理论成熟。广泛应用于机器学习，信号处理，金融工程等领域。</p>\n<p><strong>Definition 6.6 （凸规划问题）</strong> 设<span class=\"math inline\">\\(f:\\mathbf{C}\\subseteq\\mathbf{R}^n\\rightarrow{\\mathbf{R}^1}\\)</span> ，其中 <span class=\"math inline\">\\(\\mathbf{C}\\)</span> 是非空凸集合 ，<span class=\"math inline\">\\(f\\)</span> 为凸函数，则形式如下：</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\n&amp;\\min f(\\mathbf{X})\\\\\n&amp;s.t. \\mathbf{X}\\in{\\mathbf{C}}\n\\end{aligned}\n\\tag{14}\n\\]</div><p></p><p>的优化问题为<strong>凸规划问题</strong>。更进一步，设将可行域的凸集可写为如下形式：</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\n\\mathbf{C}=\\{\\mathbf{X}|g_i(\\mathbf{X})\\geq0,i=1,\\cdots,l;h_j(\\mathbf{X})=0,j=1,\\cdots,m,\\mathbf{X}\\in R^n\\}\n\\end{aligned}\n\\tag{15}\n\\]</div><p></p><p>若<span class=\"math inline\">\\(g_1,g_2,\\cdots,g_l\\)</span> 都是<span class=\"math inline\">\\(\\mathbf{R}^n\\)</span> 上的凸函数，<span class=\"math inline\">\\(h_1,h_2,\\cdots,h_m\\)</span> 都是<span class=\"math inline\">\\(R^n\\)</span>上的线性函数，则容易验证<span class=\"math inline\">\\(C\\)</span>是凸集 。事实上，因为<span class=\"math inline\">\\(-g_1,-g_2,-g_l\\)</span>都是凸函数，根据定理6.2集合<span class=\"math inline\">\\(\\mathbf{C}_i=\\{\\mathbf{X}|-g(\\mathbf{X})_i\\leq0,\\mathbf{X}\\in{\\mathbf{R}^n}\\}(i=1,2,\\cdots,l)\\)</span> 也都是凸集。此外，超平面<span class=\"math inline\">\\(P_j=\\{\\mathbf{X}|h_j(\\mathbf{X})=0,\\mathbf{X}\\in{\\mathbf{R}^n}\\}(j=1,\\cdots,m)\\)</span> 也都是凸集。显然，<span class=\"math inline\">\\(C\\)</span>是<span class=\"math inline\">\\(C_1,\\cdots,C_l,P_1,\\cdots,P_m\\)</span> 的交集，也是凸集。于是，这种情况下凸规划问题又可表示成如下形式：</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\n&amp;\\min{f(\\mathbf{X})}\\\\\n&amp;s.t.\\begin{cases}\ng_i(\\mathbf{X})\\geq0 ,\\hspace{2em} i=1,2,\\cdots,l\\\\\nh_j(\\mathbf{X})=0,\\hspace{2em} j=1,2,\\cdots,m\n\\end{cases}\n\\end{aligned}\n\\tag{16}\n\\]</div><p></p><p>如下定理指明凸规划的一个重要性质。</p>\n<p>​\t<strong>定 理6.6</strong> 设<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是凸规划问题的局部极小值，</p>\n<ol>\n<li>若<span class=\"math inline\">\\(f\\)</span>是凸函数，则<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是凸规划问题的局部极小值点；</li>\n<li>若<span class=\"math inline\">\\(f\\)</span>是严格凸函数，则<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是凸规划问题的唯一全局极小值点。</li>\n</ol>\n<p><strong>证  明：</strong>（1）使用反证法。假设<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 不是全局极小值点，则必存在<span class=\"math inline\">\\(Z\\in\\mathbf{C}\\)</span> 使得 <span class=\"math inline\">\\(f(\\mathbf{Z})&lt;f(\\mathbf{X})\\)</span> 。对应<span class=\"math inline\">\\(\\mathbf{Z}\\)</span> 与<span class=\"math inline\">\\(\\mathbf{X}^*\\)</span> 的任意凸组合<span class=\"math inline\">\\(\\mathbf{X}=\\alpha_1\\mathbf{Z}+\\alpha_2\\mathbf{X}^*\\)</span>,其中<span class=\"math inline\">\\(\\alpha_1,\\alpha_2\\in(0,1)\\)</span> 且<span class=\"math inline\">\\(\\alpha_1+\\alpha_2=1\\)</span>，根据<span class=\"math inline\">\\(f\\)</span>的凸性，有</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X})=f(\\alpha_1\\mathbf{Z}+\\alpha_2\\mathbf{X}^*)\\leq \\alpha_1f(\\mathbf{Z})+\\alpha_2f(\\mathbf{X}^*)&lt;\\alpha_1f(\\mathbf{X}^*)+\\alpha_2f(\\mathbf{X}^*)=f(\\mathbf{X}^*) \\tag{17}\n\\]</div><p></p><p>由此看到，当<span class=\"math inline\">\\(\\alpha_1&gt;0\\)</span>充分小时，<span class=\"math inline\">\\(\\mathbf{X}\\)</span>充分接近<span class=\"math inline\">\\(\\mathbf{X}^*\\)</span> ，注意到此时也有<span class=\"math inline\">\\(f(\\mathbf{X})&lt;f(\\mathbf{X}^*)\\)</span>，而这与<span class=\"math inline\">\\(\\mathbf{X}^*\\)</span> 是局部极小值点相矛盾，因此<span class=\"math inline\">\\(\\mathbf{X}^*\\)</span> 必是全局极小值。</p>\n<p>​\t        (2) 假设<span class=\"math inline\">\\(\\mathbf{X}^*\\)</span> 不是唯一全局的极小值点，必存在<span class=\"math inline\">\\(\\mathbf{X}^{'}\\in\\mathbf{C}\\)</span> 但<span class=\"math inline\">\\(\\mathbf{X}^{\\prime}\\neq\\mathbf{X}^*\\)</span>，使得<span class=\"math inline\">\\(f(\\mathbf{X}^{\\prime})=f(\\mathbf{X}^*)\\)</span>。考虑中点<span class=\"math inline\">\\(\\mathbf{X}=\\frac{1}{2}(\\mathbf{X}^{\\prime}+\\mathbf{X}^{*})\\in{\\mathbf{C}}\\)</span> 。由于 <span class=\"math inline\">\\(f\\)</span>的严格的凸性，有</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X})=f(\\frac{1}{2}(\\mathbf{X^*}+\\mathbf{X}^{\\prime}))&lt;\\frac{1}{2}(f(\\mathbf{X}^*)+f(\\mathbf{X}^{\\prime}))=f(\\mathbf{X}^{*}) \\tag{18}\n\\]</div><p></p><p>此式与<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 为全局极小值点相矛盾。这就证明了唯一性。</p>\n<p>​       由上面的推导可知，凸规划有如下优秀的重要性质：</p>\n<ol>\n<li>\n<p><strong>局部最优即全局最优</strong>：凸规划的任一局部极小值点都是全局极小值点；</p>\n</li>\n<li>\n<p><strong>最优解集为凸集</strong>：若存在最优解，则所有最优解构成一个凸集；</p>\n</li>\n<li>\n<p><strong>可微情况下的最优性条件</strong>：若<span class=\"math inline\">\\(f\\)</span>可微，则<span class=\"math inline\">\\(\\mathbf{x}^*\\)</span>为全局最优解的情况下，的充要条件：</p>\n<p></p><div class=\"math display\">\\[\\nabla f(\\mathbf{x}^*)^T(\\mathbf{y}-\\mathbf{x}^*)\\geq{0} \\hspace{2em}\\forall{y}\\in{X}\n\\]</div><p></p></li>\n<li>\n<p><strong>对偶理论</strong>：凸规划的对偶问题也是凸的，且强对偶性通常成立（在某些约束品性下，如Slater条件），即原问题与对偶问题的最优值相等。</p>\n</li>\n</ol>\n<p>其常见的优化问题的例子：</p>\n<ul>\n<li><strong>线性规划</strong>：目标函数和约束均为线性，显然满足凸性。</li>\n<li><strong>二次规划</strong>：目标函数为二次型 <span class=\"math inline\">\\(\\frac{1}{2}x^TQx+c^Tx\\)</span>，若 <span class=\"math inline\">\\(Q\\)</span> 半正定，则为凸二次规划。</li>\n<li><strong>最小二乘：</strong><span class=\"math inline\">\\(min||\\mathbf{A}x-b||_2^2\\)</span> 是凸的；</li>\n<li><strong>锥规划</strong>：如二阶锥规划、半定规划，都是凸规划的重要推广。</li>\n</ul>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-20 14:30</span>&nbsp;\n<a href=\"https://www.cnblogs.com/GeophysicsWorker\">GeoFXR</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "9、PipedInputStream和PipedOutputStream的源码分析和使用方法详细分析",
      "link": "https://www.cnblogs.com/Carey-ccl/p/19625392",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Carey-ccl/p/19625392\" id=\"cb_post_title_url\" title=\"发布于 2026-02-19 22:07\">\n    <span>9、PipedInputStream和PipedOutputStream的源码分析和使用方法详细分析</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>  在多线程编程中，线程间的数据交换是一个常见需求。Java IO包中的PipedInputStream和PipedOutputStream提供了一种高效的线程间通信机制，允许一批（多个）线程向PipedOutputStream写入数据，另一批（多个）线程从PipedInputStream读取数据。<br />\n  但是，同一批（多个）线程相互之间会存在竞争，比如，同一批向PipedOutputStream写入数据的线程会存在竞争，同一批从PipedInputStream读取数据的线程也会存在竞争。因此PipedInputStream和PipedOutputStream中的线程安全需要通过synchronized关键字和wait()/notifyAll()机制实现。不建议在一个线程中同时使用PipedInputStream和PipedOutputStream，因为这样可能会导致这个线程陷入死锁状态。<br />\n  PipedInputStream和PipedOutputStream之间的通信本质上是一个生产者-消费者模型，其中PipedOutputStream作为生产者，PipedInputStream作为消费者。两者通过一个循环缓冲区（byte[]数组）进行数据交换，PipedOutputStream将数据缓存在PipedInputStream的数组当中，等待PipedInputStream的读取。<br />\n  PipedInputStream和PipedOutputStream的UML关系图，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<h4 id=\"一pipedoutputstream生产者源码向pipedinputstream消费者中的缓冲区byte数组写入字节数据的输出stream生产者\">一、PipedOutputStream（生产者）源码——向PipedInputStream（消费者）中的缓冲区（byte[]数组）写入字节数据的输出Stream（生产者）</h4>\n<pre><code>package java.io;\n\nimport java.io.*;\n\npublic\nclass PipedOutputStream extends OutputStream {\n    //与这个PipedOutputStream（生产者）相关联的 PipedInputStream （消费者）\n    private PipedInputStream sink;\n    \n    //构造函数\n    public PipedOutputStream(PipedInputStream snk)  throws IOException {\n        connect(snk);//调用connect()函数，来改变PipedInputStream （消费者）中一些变量的值\n    }\n    \n    //构造函数\n    public PipedOutputStream() {\n    }\n    \n    //线程同步函数：用来改变将要关联的PipedInputStream （消费者）中一些变量的值\n    public synchronized void connect(PipedInputStream snk) throws IOException {\n        if (snk == null) {\n            throw new NullPointerException();//如果将要关联的PipedInputStream （消费者）为null，抛出NullPointerException\n        } else if (sink != null || snk.connected) {\n            //如果与这个PipedOutputStream（生产者）相关联的 PipedInputStream （消费者）!=null或者将要关联的PipedInputStream （消费者）的boolean connected变量为true，则抛出IOException\n            throw new IOException(\"Already connected\");\n        }\n        sink = snk;//将这个PipedOutputStream（生产者）与这个PipedInputStream （消费者）相关联\n        snk.in = -1;//改变PipedInputStream （消费者）中的变量int in=-1\n        snk.out = 0;//改变PipedInputStream （消费者）中的变量int out=0\n        snk.connected = true;//改变PipedInputStream （消费者）中的变量boolean connected=true\n    }\n    \n    //向与这个PipedOutputStream（生产者）相关联的 PipedInputStream （消费者）的缓冲区（byte[]数组）写入1个字节\n    public void write(int b)  throws IOException {\n        if (sink == null) {\n             //如果与这个PipedOutputStream（生产者）相关联的 PipedInputStream （消费者）== null，抛出IOException\n            throw new IOException(\"Pipe not connected\");\n        }\n        sink.receive(b);//最终调用的是这个相关联的 PipedInputStream （消费者）的receive(int b)函数\n    }\n    \n    //向与这个PipedOutputStream（生产者）相关联的 PipedInputStream （消费者）的缓冲区（byte[]数组）写入byte[]数组b的[off,off+len)（左闭右开，不包括off+len）索引位置的字节\n    public void write(byte b[], int off, int len) throws IOException {\n        if (sink == null) {\n            //如果与这个PipedOutputStream（生产者）相关联的 PipedInputStream （消费者）== null，抛出IOException\n            throw new IOException(\"Pipe not connected\");\n        } else if (b == null) {\n            throw new NullPointerException();//如果byte[]数组b==null，抛出一个NullPointerException\n        } else if ((off &lt; 0) || (off &gt; b.length) || (len &lt; 0) ||\n                   ((off + len) &gt; b.length) || ((off + len) &lt; 0)) {//byte[]数组b的[off,off+len)（左闭右开）索引位置是否有越界的检查\n            throw new IndexOutOfBoundsException();//越界的话，抛出一个IndexOutOfBoundsException\n        } else if (len == 0) {\n            return;//如果len==0，结束本次函数调用\n        }\n        sink.receive(b, off, len);//最终调用的是这个相关联的 PipedInputStream （消费者）的receive(byte b[], int off, int len)函数\n    }\n    \n    //线程同步函数：使用notifyAll()函数唤醒所有与这个PipedOutputStream（生产者）相关联的 PipedInputStream （消费者）线程（这个消费者可以绑定1~多个线程）\n    public synchronized void flush() throws IOException {\n        if (sink != null) {\n            synchronized (sink) {\n                sink.notifyAll();\n            }\n        }\n    }\n    //关闭这个PipedOutputStream（生产者），这个PipedOutputStream（生产者）不能再向与它相关联的PipedInputStream（消费者）中的缓冲区（byte[]数组）写入字节数据\n    public void close()  throws IOException {\n        if (sink != null) {\n            sink.receivedLast();\n        }\n    }\n}\n</code></pre>\n<h4 id=\"二pipedinputstream消费者源码从自己的缓冲区byte数组读取字节数据的输入stream消费者\">二、PipedInputStream（消费者）源码——从自己的缓冲区（byte[]数组）读取字节数据的输入Stream（消费者）</h4>\n<pre><code>package java.io;\n\npublic class PipedInputStream extends InputStream {\n    //标记符：true表示与这个 PipedInputStream （消费者）相关联的PipedOutputStream（生产者）已经关闭，反之，反之\n    boolean closedByWriter = false;\n    //标记符：true表示当前这个 PipedInputStream （消费者）已经关闭了，反之，反之\n    volatile boolean closedByReader = false;\n    //标记符：true表示与这个 PipedInputStream （消费者）相关联的PipedOutputStream（生产者）已经持有了这个PipedInputStream （消费者）对象（或者叫已经连接上了），反之，反之\n    boolean connected = false;\n\n    Thread readSide;//当前消费的线程\n    Thread writeSide;//当前生产者的线程\n    \n    //默认的PipedInputStream （消费者）的缓冲区（byte[]数组）的长度\n    private static final int DEFAULT_PIPE_SIZE = 1024;\n\n    //PipedInputStream （消费者）的缓冲区（byte[]数组）\n    protected byte buffer[];\n    //缓冲区（byte[]数组）的写指针\n    protected int in = -1;\n    //缓冲区（byte[]数组）的读指针\n    protected int out = 0;\n    //构造函数\n    public PipedInputStream(PipedOutputStream src) throws IOException {\n        this(src, DEFAULT_PIPE_SIZE);//缓冲区（byte[]数组）的长度使用默认值1024\n    }\n\n    //构造函数\n    public PipedInputStream(PipedOutputStream src, int pipeSize)\n            throws IOException {\n         initPipe(pipeSize);//缓冲区（byte[]数组）的长度使用指定的长度\n         //最终还是调用PipedOutputStream（生产者）的connect()函数，并把自身对象this传递进去，然后在PipedOutputStream（生产者）的connect()函数中，改变自己的3个变量int in=-1、int out=0、boolean connected=true\n         connect(src);\n    }\n    \n    //构造函数，缓冲区（byte[]数组）的长度使用默认值1024\n    public PipedInputStream() {\n        initPipe(DEFAULT_PIPE_SIZE);\n    }\n\n    //构造函数，缓冲区（byte[]数组）的长度使用指定的长度\n    public PipedInputStream(int pipeSize) {\n        initPipe(pipeSize);\n    }\n    \n    //初始化缓冲区（byte[]数组）\n    private void initPipe(int pipeSize) {\n         if (pipeSize &lt;= 0) {\n            throw new IllegalArgumentException(\"Pipe Size &lt;= 0\");\n         }\n         buffer = new byte[pipeSize];\n    }\n\n    public void connect(PipedOutputStream src) throws IOException {\n        src.connect(this); //最终还是调用PipedOutputStream（生产者）的connect()函数，并把自身对象this传递进去，然后在PipedOutputStream（生产者）的connect()函数中，改变自己的3个变量int in=-1、int out=0、boolean connected=true\n    }\n    \n    //线程同步函数：该函数只被PipedOutputStream（生产者）的write(int b)函数调用\n    protected synchronized void receive(int b) throws IOException {\n        checkStateForReceive();//检查PipedInputStream （消费者）的状态\n        writeSide = Thread.currentThread();//当前执行该函数的线程，就是生产者线程\n        if (in == out)\n            //如果缓冲区（byte[]数组）的读指针==缓冲区（byte[]数组）的写指针，唤醒所有消费者线程，自己这个生产者线程调用wait(1000)函数\n            awaitSpace();\n        if (in &lt; 0) {//缓冲区（byte[]数组）的写指针&lt;0时，设置缓冲区（byte[]数组）的写指针=0，缓冲区（byte[]数组）的读指针=0\n            in = 0;\n            out = 0;\n        }\n        buffer[in++] = (byte)(b &amp; 0xFF);//向缓冲区的写指针位置写入1个字节\n        if (in &gt;= buffer.length) {\n            in = 0;//如果缓冲区满了，设置缓冲区的写指针=0\n        }\n    }\n\n    //线程同步函数：该函数只被PipedOutputStream（生产者）的write(byte b[], int off, int len)函数调用\n    synchronized void receive(byte b[], int off, int len)  throws IOException {\n        checkStateForReceive();//检查PipedInputStream （消费者）的状态\n        writeSide = Thread.currentThread();//当前执行该函数的线程，就是生产者线程\n        int bytesToTransfer = len;//生产者线程要写入到缓冲区（byte[]数组）中的字节总量\n        while (bytesToTransfer &gt; 0) {\n            if (in == out)\n                //如果缓冲区（byte[]数组）的读指针==缓冲区（byte[]数组）的写指针，唤醒所有消费者线程，自己这个生产者线程调用wait(1000)函数\n                awaitSpace();\n            int nextTransferAmount = 0;//本次生产者线程要写入到缓冲区（byte[]数组）中的字节数量\n            if (out &lt; in) {\n                //如果缓冲区的读指针&lt;缓冲区的写指针，本次要写入到缓冲区（byte[]数组）中的字节数量=缓冲区的长度-缓冲区的写指针\n                nextTransferAmount = buffer.length - in;\n            } else if (in &lt; out) {\n                if (in == -1) {\n                    in = out = 0;\n                    //如果缓冲区的读指针（out）&gt; 缓冲区的写指针（in）并且缓冲区的写指针（in）=-1，先设置缓冲区的读（out）、写（in）指针=0，本次要写入到缓冲区（byte[]数组）中的字节数量=缓冲区的长度\n                    nextTransferAmount = buffer.length - in;\n                } else {\n                    //如果缓冲区的读指针（out）&gt; 缓冲区的写指针（in）并且缓冲区的写指针（in）=-1，本次要写入到缓冲区（byte[]数组）中的字节数量=读指针（out）-写指针（in）\n                    nextTransferAmount = out - in;\n                }\n            }\n            //本次生产者线程要写入到缓冲区（byte[]数组）中的字节数量最多为len，下次为len-本次写入到缓冲区（byte[]数组）中的字节数量，也就是每次写入的基于len个字节循环递减上一次写入的\n            if (nextTransferAmount &gt; bytesToTransfer)\n                nextTransferAmount = bytesToTransfer;\n            assert(nextTransferAmount &gt; 0);\n            System.arraycopy(b, off, buffer, in, nextTransferAmount);//向缓冲区（byte[]数组）的[in,in+nextTransferAmount)索引位置写入byte[]数组b中[off,off+nextTransferAmount)索引位置的字节，都是左闭右开。\n            bytesToTransfer -= nextTransferAmount;//每一次都基于len个字节循环递减本次写入到缓冲区（byte[]数组）中的字节数量nextTransferAmount\n            off += nextTransferAmount;//将下次要从byte[]数组b中取字节的起始索引的位置（偏移量）+本次写入到缓冲区（byte[]数组）中的字节数量nextTransferAmount\n            in += nextTransferAmount;//将缓冲区的写指针（in）+本次写入到缓冲区（byte[]数组）中的字节数量nextTransferAmount\n            if (in &gt;= buffer.length) {\n                in = 0;//如果缓冲区的写指针（in）&gt; 缓冲区（byte[]数组）的长度，设置缓冲区的写指针（in）=0\n            }\n        }\n    }\n\n    //检查PipedInputStream （消费者）的状态\n    private void checkStateForReceive() throws IOException {\n        if (!connected) {\n            throw new IOException(\"Pipe not connected\");\n        } else if (closedByWriter || closedByReader) {\n            throw new IOException(\"Pipe closed\");\n        } else if (readSide != null &amp;&amp; !readSide.isAlive()) {\n            throw new IOException(\"Read end dead\");\n        }\n    }\n    \n    //如果缓冲区（byte[]数组）的读指针==缓冲区（byte[]数组）的写指针，唤醒所有消费者线程，自己这个生产者线程调用wait(1000)函数\n    private void awaitSpace() throws IOException {\n        while (in == out) {\n            checkStateForReceive();\n\n            /* full: kick any waiting readers */\n            notifyAll();\n            try {\n                wait(1000);\n            } catch (InterruptedException ex) {\n                throw new java.io.InterruptedIOException();\n            }\n        }\n    }\n    //关闭与这个 PipedInputStream （消费者）相关联的PipedOutputStream（生产者）\n    synchronized void receivedLast() {\n        closedByWriter = true;\n        notifyAll();//唤醒所有消费者线程\n    }\n    //线程同步函数：消费者线程每次从缓冲区（byte[]数组）中读取1个字节\n    public synchronized int read()  throws IOException {\n        if (!connected) {//检查标记符connected，如果为false，抛出IOException\n            throw new IOException(\"Pipe not connected\");\n        } else if (closedByReader) {//检查标记符closedByReader，如果为true，抛出IOException\n            throw new IOException(\"Pipe closed\");\n        } else if (writeSide != null &amp;&amp; !writeSide.isAlive()\n                   &amp;&amp; !closedByWriter &amp;&amp; (in &lt; 0)) {\n           //检查当前这个PipedInputStream （消费者）对象中引用的生产者线程和生产者线程的状态，如果和标记符closedByWriter还有缓冲区（byte[]数组）的写指针（in）不能对应的话，抛出一个IOException\n            throw new IOException(\"Write end dead\");\n        }\n\n        readSide = Thread.currentThread();//当前执行该函数的线程，就是消费者线程\n        int trials = 2;//这是一个多次检测的策略变量，防止生产者线程没有关闭了与这个 PipedInputStream （消费者）相关联的PipedOutputStream（生产者）时便抛出IOException\n        //in=-1的情况有种：\n        //①、生产者线程还没有向缓冲区（byte[]数组）中写任何字节\n        //②、消费者线程从缓冲区（byte[]数组）中读完字节（byte）数据以后读指针（out）=写指针（in），那么，当前消费者线程会设置写指针（in）=-1\n        //③、消费者线程执行PipedInputStream 的close()函数后，关闭了这个 PipedInputStream （消费者）\n        while (in &lt; 0) {\n            if (closedByWriter) {\n                /* closed by writer, return EOF */\n                return -1;\n            }\n            if ((writeSide != null) &amp;&amp; (!writeSide.isAlive()) &amp;&amp; (--trials &lt; 0)) {\n                //多个消费者线程从缓冲区（byte[]数组）中读的时候，并且前一个消费者线程已经把缓冲区（byte[]数组）中写入的字节读完了，并且前一个线程设置了写指针（in）=-1，生产者线程也关闭了与这个 PipedInputStream （消费者）相关联的PipedOutputStream（生产者）时，抛出一个IOException\n                throw new IOException(\"Pipe broken\");\n            }\n            /* might be a writer waiting */\n            notifyAll();//此处的目的是为了唤醒所有生产者线程\n            try {\n                wait(1000);\n            } catch (InterruptedException ex) {\n                throw new java.io.InterruptedIOException();\n            }\n        }\n        int ret = buffer[out++] &amp; 0xFF;//获取缓冲区（byte[]数组）中读指针（out）索引位置的字节,并且将读指针（out）+1\n        if (out &gt;= buffer.length) {\n            out = 0;//如果读指针（out）&gt;=缓冲区（byte[]数组）的长度，设置读指针（out）=0\n        }\n        if (in == out) {\n            /* now empty */\n            in = -1;//如果消费者线程从缓冲区（byte[]数组）中读完字节（byte）数据以后读指针（out）=写指针（in），那么，当前消费者线程会设置写指针（in）=-1\n        }\n\n        return ret;\n    }\n\n    //线程同步函数：如果缓冲区（byte[]数组）中有足够多的字节的话（数量&gt;len），消费者线程每次从缓冲区（byte[]数组）中读取len个字节放到byte[]数组b的[off, off+len)索引位置（左闭右开，不包括off+len）\n    //如果缓冲区（byte[]数组）中字节的数量&lt;len个（比如有in（写指针）-out（读指针）个），消费者线程每次从缓冲区（byte[]数组）中读取（in-out）个字节放到byte[]数组b的[off, off+in-out)索引位置（左闭右开，不包括off+in-out）\n    public synchronized int read(byte b[], int off, int len)  throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {//byte[]数组b的[off,off+len)（左闭右开）索引位置是否有越界的检查\n            throw new IndexOutOfBoundsException();//越界的话，抛出一个IndexOutOfBoundsException\n        } else if (len == 0) {\n            return 0;//如果len==0，返回0\n        }\n\n        /* possibly wait on the first character */\n        int c = read();//先调用read()函数试探性从缓冲区（byte[]数组）中读1个字节\n        if (c &lt; 0) {\n            return -1;//如果试探性的从缓冲区（byte[]数组）中都读不到1个字节，返回-1\n        }\n        b[off] = (byte) c;//把试探性从缓冲区（byte[]数组）中读到的第1个字节放到byte[]数组b的off索引位置\n        int rlen = 1;//累计从缓冲区（byte[]数组）中读到的所有字节数量\n        while ((in &gt;= 0) &amp;&amp; (len &gt; 1)) {\n\n            int available;//本次执行System.arraycopy()函数可以从缓冲区（byte[]数组）中读到byte[]数组b中的字节数量\n\n            if (in &gt; out) {\n                available = Math.min((buffer.length - out), (in - out));\n            } else {\n                available = buffer.length - out;\n            }\n\n            // A byte is read beforehand outside the loop\n            if (available &gt; (len - 1)) {//减掉试探性从缓冲区（byte[]数组）中读到的第1个字节\n                available = len - 1;\n            }\n            System.arraycopy(buffer, out, b, off + rlen, available);\n            out += available;//读指针（out）+System.arraycopy()函数从缓冲区（byte[]数组）中读到byte[]数组b中的字节数量\n            rlen += available;//累计从缓冲区（byte[]数组）中读到的所有字节数量 + System.arraycopy()函数从缓冲区（byte[]数组）中读到byte[]数组b中的字节数量\n            len -= available;//len - System.arraycopy()函数从缓冲区（byte[]数组）中读到byte[]数组b中的字节数量\n\n            if (out &gt;= buffer.length) {\n                out = 0;//如果读指针（out）&gt;=缓冲区（byte[]数组）的长度，设置读指针（out）=0\n            }\n            if (in == out) {\n                /* now empty */\n                in = -1;//如果消费者线程从缓冲区（byte[]数组）中读完字节（byte）数据以后读指针（out）=写指针（in），那么，当前消费者线程会设置写指针（in）=-1\n            }\n        }\n        return rlen;//返回累计从缓冲区（byte[]数组）中读到的所有字节数量\n    }\n    \n    //线程同步函数：返回缓冲区（byte[]数组）中可以被消费者线程读取的字节数量\n    public synchronized int available() throws IOException {\n        if(in &lt; 0)\n            return 0;\n        else if(in == out)\n            return buffer.length;\n        else if (in &gt; out)\n            return in - out;\n        else\n            return in + buffer.length - out;\n    }\n    \n    //关闭这个 PipedInputStream （消费者），其实就是设置标记符closedByReader=true， 设置写指针（in）=-1\n    public void close()  throws IOException {\n        closedByReader = true;\n        synchronized (this) {\n            in = -1;\n        }\n    }\n}\n</code></pre>\n<h4 id=\"三1个线程向pipedoutputstream生产者写字节数据1个线程从pipedinputstream消费者读取字节数据的过程\">三、1个线程向PipedOutputStream（生产者）写字节数据，1个线程从PipedInputStream（消费者）读取字节数据的过程</h4>\n<h5 id=\"31非循环直接写和非循环直接读\">3.1、非循环直接写和非循环直接读</h5>\n<pre><code>package com.chelong.StreamAndReader;\n\nimport java.io.IOException;\nimport java.io.PipedInputStream;\nimport java.io.PipedOutputStream;\n\npublic class PipedTest {\n   public static void main(String[] args) throws IOException {\n      final PipedOutputStream output = new PipedOutputStream();\n      final PipedInputStream input = new PipedInputStream(output);\n      Thread thread1 = new Thread(new Runnable() {\n         @Override\n         public void run() {\n            try {\n               output.write(\"Hello world, pipe!\".getBytes());//write()函数是阻塞的\n            } catch (IOException e) {\n            }\n         }\n      });\n\n      Thread thread2 = new Thread(new Runnable() {\n         @Override\n         public void run() {\n            try {\n               int data = -1;\n               while ((data = input.read()) != -1) {//read()函数是阻塞的\n                  System.out.print((char) data);\n               }\n            } catch (IOException e) {\n            }\n         }\n      });\n\n      thread1.start();\n      thread2.start();\n   }\n}\n</code></pre>\n<p>程序运行结果，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>  main线程构造PipedOutputStream（生产者）和PipedInputStream（消费者）的过程如下：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>  向PipedOutputStream（生产者）写字节数据的生产者线程的执行过程如下：</p>\n<p><img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>  从PipedInputStream（消费者）读取字节数据的消费者线程的执行过程如下：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<h6 id=\"311非循环直接写和非循环直接读时1个生产者线程和1个消费者线程处理数据的过程\">3.1.1、非循环直接写和非循环直接读时1个生产者线程和1个消费者线程处理数据的过程</h6>\n<p>  Java 语言定义了 6 种线程状态, 在任意一个时间点, 一个线程只能有且只有其中的一种状态, 这 6 种状态分别如下：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>这 6 种线程状态的简单介绍，如下所示<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>  JVM运行时内存结构主要包含了五个部分：程序计数器 （PC寄存器）、 JVM栈、Native方法栈、堆、 方法区。如下图所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>图中红色部分是线程私有区域，进入这个区域的数据不会出现线程竞争的关系。而绿色区域中的数据则被所有线程共享，其中Java堆中存放的是大量对象，方法区中存放class信息、常量、静态变量等数据。<br />\n  每个线程的线程栈中会存放函数（方法）的描述符，成员（本地）变量等，函数（方法）在线程栈中会通过压栈和弹栈来执行，除了8种（byte、short、int、long、float、double、boolean、char）基本的数据类型存储在线程栈中以外，其余的引用数据类型（对象）都存储在堆中，然后通过引用将堆中的对象和线程栈中的变量关联起来（也可以叫线程栈中的引用指向堆中的对象）。<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>那么，当使用者执行3.1中的代码时，1个生产者线程和1个消费者线程处理数据的过程如下：<br />\n①、main线程初始化一个缓冲区（byte[]数组），长度为1024（默认值），然后生产者线程通过不断的压栈来完成函数之间的调用，最终执行PipedInputStream.class::receive(byte b[], int off, int len)函数来对缓冲区（byte[]数组）进行填充，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>②、当生产者线程填充完缓冲区之后，写指针变量int in=17，读指针变量int out=0，Thread writeSide = 当前这个生产者线程（Thread）对象，生产者线程会把自己线程栈中修改的变量最终刷新到堆中PipedInputStream对象中，以确保其它消费者线程的线程栈从堆中读取这3个变量时，这3个变量已经为修改后的值，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>③、消费者线程读缓冲区（byte[]数组）的过程中会不断地执行out++（读指针）以读取缓冲区（byte[]数组）中的可用字节并返回，直到out（读指针）==in（写指针），修改in（写指针）=-1，并且每次同步执行PipedInputStream.class::read()函数时，都会更新Thread readSide = 当前这个消费者线程（Thread）对象，消费者线程也会把自己线程栈中修改的变量最终刷新到堆中PipedInputStream对象中，以确保其它消费者线程的线程栈从堆中读取这3个变量时，这3个变量已经为修改后的值，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>④、更新in（写指针）=-1后，消费者线程再次同步执行PipedInputStream.class::read()函数时，如果PipedInputStream::boolean closedByWriter变量为true，则会返回-1</p>\n<h5 id=\"32加锁循环写和非加锁循环读到byte数组b中再处理\">3.2、加锁循环写和非加锁循环读到byte[]数组b中再处理</h5>\n<pre><code>package com.chelong.pipe;\nimport java.io.IOException;\nimport java.io.PipedInputStream;\nimport java.io.PipedOutputStream;\n\npublic class PipeForTransferInThread {\n   public static void main(String[] args) throws IOException, InterruptedException {\n      final PipedOutputStream output = new PipedOutputStream();\n      final PipedInputStream input = new PipedInputStream(output);\n      //生产者线程\n      Thread producer = new Thread(new Runnable() {\n         @Override\n         public void run() {\n            for (int i = 0; i &lt; 3; i++) {\n               synchronized (input) {\n                  try {\n//                    input.wait();\n                     output.write(\"Hello world, pipe!\".getBytes());\n                     input.wait();//释放锁并无限等待，直到消费者线程consumer 执行notifyAll()函数来唤醒当前阻塞\n                  } catch (Exception e) {\n                     e.printStackTrace();\n                  }\n               }\n            }\n         }\n      },\"生产者线程\");\n      \n      //消费者线程\n      Thread consumer = new Thread(new Runnable() {\n         @Override\n         public void run() {\n            try {\n               byte[] b = new byte[1024];//1KB\n               int readBytes = -1;\n               long lastTime = System.currentTimeMillis();\n               while ((readBytes = input.read(b, 0, b.length)) != -1) {\n                  long curTime = System.currentTimeMillis();\n                  System.out.print(Thread.currentThread().getName()+\"本次读取花费时间：\" + (curTime - lastTime) + \"ms，读到的数据是：\");\n                  lastTime = curTime;\n                  for (int i = 0; i &lt; readBytes; i++) {\n                     System.out.print((char) b[i]);//模拟处理字节数据\n                  }\n                  System.out.println();\n               }\n            } catch (IOException e) {\n               e.printStackTrace();\n            }\n         }\n      },\"消费者线程\");\n      producer.start();//生产者线程启动\n      consumer.start();//消费者线程启动\n   }\n}\n</code></pre>\n<p>程序运行结果，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>  main线程构造PipedOutputStream（生产者）和PipedInputStream（消费者）的过程可以参考3.1；<br />\n  向PipedOutputStream（生产者）写字节数据的生产者线程的执行过程可以参考3.1；<br />\n  从PipedInputStream（消费者）读取字节数据的消费者线程的执行过程如下：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<h6 id=\"321加锁循环写和非加锁循环读到byte数组b中再处理时1个生产者线程和1个消费者线程处理数据的过程\">3.2.1、加锁循环写和非加锁循环读到byte[]数组b中再处理时1个生产者线程和1个消费者线程处理数据的过程</h6>\n<p>  标题3.2中的代码的整个执行过程如下：<br />\n①、main线程初始化一个缓冲区（byte[]数组），长度为1024（默认值），如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>②、然后生产者线程通过不断的压栈来完成函数之间的调用，最终执行PipedInputStream.class::receive(byte b[], int off, int len)函数来对缓冲区（byte[]数组）进行填充，并且先在自己的线程栈中更新in（写指针）=17，out（读指针）=0，writeSide=当前这个生产者线程（Thread）对象 如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>当生产者线程对缓冲区（byte[]数组）填充完成之后，再执行标题3.2中的代码</p>\n<pre><code>input.wait();\n</code></pre>\n<p>这行代码会释放锁并让生产者线程进入无限等待，直到消费者线程consumer执行notifyAll()函数来唤醒当前这个生产者线程。在这之前，生产者线程会将自己线程栈中的in（写指针）=17，out（读指针）=0，writeSide=当前这个生产者线程，这3个变量更新到主内存（也就是堆）中的PipedInputStream对象中。<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>③、消费者线程读缓冲区（byte[]数组）的过程也是通过不断的压栈来完成函数之间的调用，最终执行PipedInputStream::read()函数（试探性的读取1个字节）和PipedInputStream::read(byte b[], int off, int len)函数（读取剩余其它的字节）将步骤②中生产者线程写入到缓冲区（byte[]数组）中的17个字节读取出来<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<blockquote>\n<p>附言：最终消费者线程也会将自己线程栈中的in（写指针）= -1，out（读指针）= 17，writeSide=当前这个消费者线程，这3个变量更新到主内存（也就是堆）中的PipedInputStream对象中。</p>\n</blockquote>\n<p>因此，本次消费者线程从缓冲区（byte[]数组）中读数据的过程中没有执行read()函数中的wait(1000)这一行代码，如下：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>所以，本次消费者线程从缓冲区（byte[]数组）中读取数据到消费者线程中自己创建的byte[]数组中时，只花费了0ms：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>接下来，当消费者线程将步骤②中生产者线程写入到缓冲区（byte[]数组）中的17个字节读取出来以后（通过System.arraycopy()函数复制到了消费者线程中自己创建的byte[]数组中），消费者线程会遍历从缓冲区读到的这个byte[]数组，来处理这些数据，如下所示（标题3.2中的代码片段）：</p>\n<pre><code>                   //标题3.2中的代码片段\n                   for (int i = 0; i &lt; readBytes; i++) {\n                     System.out.print((char) b[i]);//模拟处理字节数据\n                  }\n</code></pre>\n<p>然后，当消费者线程再次执行</p>\n<pre><code>//标题3.2中的代码片段\ninput.read(b, 0, b.length)\n</code></pre>\n<p>从缓冲区（byte[]数组）中读数据到自己创建的byte[]数组中时，由于此时in（写指针）=-1，并且当下图中的其它5个条件都不成立时，唤醒执行了</p>\n<pre><code>input.wait()\n</code></pre>\n<p>的生产者线程，然后当前这个正在从缓冲区(byte数组)中读数据的消费者线程执行wait 1000ms ，如下：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>④、当生产者线程被消费者线程执行的</p>\n<pre><code>notifyAll();\n</code></pre>\n<p>唤醒之后，会再次通过不断的压栈来完成函数之间的调用，再次执行PipedInputStream.class::receive(byte b[], int off, int len)函数来对缓冲区（byte[]数组）进行填充，并且先在自己的线程栈中先更新in（写指针）=17，out（读指针）=0，writeSide=当前这个生产者线程（Thread）对象 如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>当生产者线程对缓冲区（byte[]数组）填充完成之后，再执行标题3.2中的代码</p>\n<pre><code>input.wait();\n</code></pre>\n<p>这行代码会释放锁并让生产者线程进入无限等待，直到消费者线程consumer执行notifyAll()函数来唤醒当前这个生产者线程。在这之前，生产者线程会将自己线程栈中的in（写指针）=17，out（读指针）=0，writeSide=当前这个生产者线程，这3个变量更新到主内存（也就是堆）中的PipedInputStream对象中。如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>⑤、消费者线程在第③步执行了</p>\n<pre><code>wait(1000);\n</code></pre>\n<p>在等待了1000ms之后，消费者线程会自动唤醒继续执行，此时自己线程栈中的in（写指针）= -1，out（读指针）= 17已经被第④步中的生产者线程修改为in（写指针）=17，out（读指针）=0（生产者线程不会直接修改消费者线程栈中的变量，生产者线程会先将自己线程栈中in（写指针），out（读指针）变量的值修改到主内存中，然后消费者线程会自己将主内存中的这2个变量值刷新到消费者自己的线程栈中），如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>然后执行PipedInputStream::read()函数（试探性的读取1个字节）和PipedInputStream::read(byte b[], int off, int len)函数（读取剩余其它的字节）将步骤④中生产者线程写入到缓冲区（byte[]数组）中的17个字节读取出来<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<blockquote>\n<p>附言：最终消费者线程也会将自己线程栈中的in（写指针）= -1，out（读指针）= 17，writeSide=当前这个消费者线程，这3个变量更新到主内存（也就是堆）中的PipedInputStream对象中。</p>\n</blockquote>\n<p>由于，本次消费者线程从缓冲区（byte[]数组）中读数据的过程是从步骤③中自动唤醒继续执行的，所以，本次消费者线程从缓冲区（byte[]数组）中读取数据到消费者线程中自己创建的byte[]数组中时，花费了1015ms：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>接下来，当消费者线程将步骤④中生产者线程写入到缓冲区（byte[]数组）中的17个字节读取出来以后（通过System.arraycopy()函数复制到了消费者线程中自己创建的byte[]数组中），消费者线程会遍历从缓冲区读到的这个byte[]数组，来处理这些数据，如下所示（标题3.2中的代码片段）：</p>\n<pre><code>                   //标题3.2中的代码片段\n                   for (int i = 0; i &lt; readBytes; i++) {\n                     System.out.print((char) b[i]);//模拟处理字节数据\n                  }\n</code></pre>\n<p>然后，当消费者线程再次执行</p>\n<pre><code>//标题3.2中的代码片段\ninput.read(b, 0, b.length)\n</code></pre>\n<p>从缓冲区（byte[]数组）中读数据到自己创建的byte[]数组中时，由于此时in（写指针）=-1，并且当下图中的其它5个条件都不成立时，唤醒执行了</p>\n<pre><code>input.wait()\n</code></pre>\n<p>的生产者线程，然后当前这个正在从缓冲区(byte[]数组)中读数据的消费者线程执行wait 1000ms ，如下：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>⑥、当生产者线程被消费者线程执行的</p>\n<pre><code>notifyAll();\n</code></pre>\n<p>唤醒之后，会再次通过不断的压栈来完成函数之间的调用，再次执行PipedInputStream.class::receive(byte b[], int off, int len)函数来对缓冲区（byte[]数组）进行填充，并且先在自己的线程栈中先更新in（写指针）=17，out（读指针）=0，writeSide=当前这个生产者线程（Thread）对象 如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>当生产者线程对缓冲区（byte[]数组）填充完成之后，再执行标题3.2中的代码</p>\n<pre><code>input.wait();\n</code></pre>\n<p>这行代码会释放锁并让生产者线程进入无限等待，直到消费者线程consumer执行notifyAll()函数来唤醒当前这个生产者线程。在这之前，生产者线程会将自己线程栈中的in（写指针）=17，out（读指针）=0，writeSide=当前这个生产者线程，这3个变量更新到主内存（也就是堆）中的PipedInputStream对象中。如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>⑦、消费者线程在第⑤步执行了</p>\n<pre><code>wait(1000);\n</code></pre>\n<p>在等待了1000ms之后，消费者线程会自动唤醒继续执行，此时自己线程栈中的in（写指针）= -1，out（读指针）= 17已经被第⑥步中的生产者线程修改为in（写指针）=17，out（读指针）=0（生产者线程不会直接修改消费者线程栈中的变量，生产者线程会先将自己线程栈中in（写指针），out（读指针）变量的值修改到主内存中，然后消费者线程会自己将主内存中的这2个变量值刷新到消费者自己的线程栈中），然后执行PipedInputStream::read()函数（试探性的读取1个字节）和PipedInputStream::read(byte b[], int off, int len)函数（读取剩余其它的字节）将步骤⑥中生产者线程写入到缓冲区（byte[]数组）中的17个字节读取出来<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<blockquote>\n<p>附言：最终消费者线程也会将自己线程栈中的in（写指针）= -1，out（读指针）= 17，writeSide=当前这个消费者线程，这3个变量更新到主内存（也就是堆）中的PipedInputStream对象中。</p>\n</blockquote>\n<p>由于，本次消费者线程从缓冲区（byte[]数组）中读数据的过程是从步骤⑤中自动唤醒继续执行的，所以，本次消费者线程从缓冲区（byte[]数组）中读取数据到消费者线程中自己创建的byte[]数组中时，花费了1017ms：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>接下来，当消费者线程将步骤⑥中生产者线程写入到缓冲区（byte[]数组）中的17个字节读取出来以后（通过System.arraycopy()函数复制到了消费者线程中自己创建的byte[]数组中），消费者线程会遍历从缓冲区读到的这个byte[]数组，来处理这些数据，如下所示（标题3.2中的代码片段）：</p>\n<pre><code>                   //标题3.2中的代码片段\n                   for (int i = 0; i &lt; readBytes; i++) {\n                     System.out.print((char) b[i]);//模拟处理字节数据\n                  }\n</code></pre>\n<p>然后，当消费者线程再次执行</p>\n<pre><code>//标题3.2中的代码片段\ninput.read(b, 0, b.length)\n</code></pre>\n<p>从缓冲区（byte[]数组）中读数据到自己创建的byte[]数组中时，由于此时in（写指针）=-1，并且当下图中的其它5个条件都不成立时，唤醒执行了</p>\n<pre><code>input.wait()\n</code></pre>\n<p>的生产者线程，然后当前这个正在从缓冲区(byte[]数组)中读数据的消费者线程执行wait 1000ms ，如下：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>⑧、当生产者线程被消费者线程执行的</p>\n<pre><code>notifyAll();\n</code></pre>\n<p>唤醒之后，会跳出for循环，结束生产者线程的生命周期，之后，该线程对象会被操作系统回收。<br />\n⑨、消费者线程在第⑦步执行了</p>\n<pre><code>wait(1000);\n</code></pre>\n<p>在等待了1000ms之后，消费者线程会自动唤醒继续执行，此时自己线程栈中的in（写指针）= -1，out（读指针）= 17，并且从</p>\n<pre><code>wait(1000);\n</code></pre>\n<p>的代码之后，继续执行，执行过程如下（从下图的紫色流程继续执行）：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>在执行了2个循环后，直到int trials = 0时，执行到判断(writeSide != null) &amp;&amp; (!writeSide.isAlive()) &amp;&amp; (--trials &lt; 0)这个条件时就会为true（下图的红色流程）<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>然后，抛出了一个IOException(\"Pipe broken\")，因此，可以得出int trials变量的含义：这个变量是一个多次检测的策略变量，当生产者线程没有关闭了与这个 PipedInputStream （消费者）相关联的PipedOutputStream（生产者）时，并且writeSide变量指向的当前生产者线程已经被操作系统回收时（此时当前生产者线程对象的isAlive()函数会返回false），消费者线程会抛出1个IOException(\"Pipe broken\")，并结束while循环，进而结束消费者线程的生命周期。之后，该线程对象也会被操作系统回收。如下图所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<h6 id=\"322怎样防止321中第步的生产者线程抛出ioexceptionpipe-broken\">3.2.2、怎样防止3.2.1中第⑨步的生产者线程抛出IOException(\"Pipe broken\")</h6>\n<p>  回顾3.2.1中第⑨步中的消费者线程抛出IOException(\"Pipe broken\")的产生过程：当执行到判断(writeSide != null) &amp;&amp; (!writeSide.isAlive()) &amp;&amp; (--trials &lt; 0)这个条件时就会为true（下图的红色流程）<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>那么，使用者就可以将上图中红色流程的前一步变成true即可，如下代码所示（只修改了生产者线程中的代码，消费者线程中的代码没有变化）：</p>\n<pre><code>package com.chelong.pipe;\nimport java.io.IOException;\nimport java.io.PipedInputStream;\nimport java.io.PipedOutputStream;\n   public static void main(String[] args) throws IOException, InterruptedException {\n      final PipedOutputStream output = new PipedOutputStream();\n      final PipedInputStream input = new PipedInputStream(output);\n      //生产者线程\n      Thread producer = new Thread(new Runnable() {\n         @Override\n         public void run() {\n            try {\n               for (int i = 0; i &lt; 3; i++) {\n                  synchronized (input) {\n//                    input.wait();\n                     output.write(\"Hello world, pipe!\".getBytes());\n                     input.wait();//释放锁并无限等待，直到消费者线程thread2执行notifyAll()函数来唤醒当前阻塞\n                  }\n               }\n            } catch (Exception e) {\n               e.printStackTrace();\n            } finally {\n               try {\n                  if (output != null) output.close();//调用close()函数关闭生产者对象\n               } catch (IOException e) {\n                  e.printStackTrace();\n               }\n            }\n         }\n      }, \"生产者线程\");\n\n      //消费者线程\n      Thread consumer = new Thread(new Runnable() {\n         @Override\n         public void run() {\n            try {\n               byte[] b = new byte[1024];//1KB\n               int readBytes = -1;\n               long lastTime = System.currentTimeMillis();\n               while ((readBytes = input.read(b, 0, b.length)) != -1) {\n                  long curTime = System.currentTimeMillis();\n                  System.out.print(Thread.currentThread().getName() + \"本次读取花费时间：\" + (curTime - lastTime) + \"ms，读到的数据是：\");\n                  lastTime = curTime;\n                  for (int i = 0; i &lt; readBytes; i++) {\n                     System.out.print((char) b[i]);//模拟处理字节数据\n                  }\n                  System.out.println();\n               }\n            } catch (IOException e) {\n               e.printStackTrace();\n            }\n         }\n      }, \"消费者线程\");\n      producer.start();//生产者线程启动\n      consumer.start();//消费者线程启动\n   }\n}\n</code></pre>\n<p>程序运行结果，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>  通过PipedOutputStream.class::close()的源码可以看到这样修改后消费者线程不再抛出IOException(\"Pipe broken\")原因：<br />\nPipedOutputStream.class（生产者类）的源码</p>\n<pre><code>package java.io;\n\nimport java.io.*;\n\npublic\nclass PipedOutputStream extends OutputStream {\n    ...省略部分代码...\n    //关闭这个PipedOutputStream（生产者），这个PipedOutputStream（生产者）不能再向与它相关联的PipedInputStream（消费者）中的缓冲区（byte[]数组）写入字节数据\n    public void close()  throws IOException {\n        if (sink != null) {\n            sink.receivedLast();//调用PipedInputStream.class::receivedLast()函数\n        }\n    }\n}\n</code></pre>\n<p>PipedInputStream .class（消费者类）的源码</p>\n<pre><code>package java.io;\n\npublic class PipedInputStream extends InputStream {\n    //标记符：true表示与这个 PipedInputStream （消费者）相关联的PipedOutputStream（生产者）已经关闭，反之，反之\n    boolean closedByWriter = false;\n    ...省略部分代码...\n    //关闭与这个 PipedInputStream （消费者）相关联的PipedOutputStream（生产者）\n    synchronized void receivedLast() {\n        closedByWriter = true;//关闭后消费者再从缓冲区（byte[]）数组中读取字节数据时，会返回-1，不会抛出IOException了\n        notifyAll();//唤醒所有消费者线程\n    }\n    ...省略部分代码...\n</code></pre>\n<h4 id=\"四多个线程向pipedoutputstream生产者写字节数据多个线程从pipedinputstream消费者读取字节数据的过程\">四、多个线程向PipedOutputStream（生产者）写字节数据，多个线程从PipedInputStream（消费者）读取字节数据的过程</h4>\n<p>  略（待补充）</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-19 22:07</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Carey-ccl\">Carey_ccl</a>&nbsp;\n阅读(<span id=\"post_view_count\">51</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "凸优化数学基础笔记（五）：极小值点的判定条件",
      "link": "https://www.cnblogs.com/GeophysicsWorker/p/19625407",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/GeophysicsWorker/p/19625407\" id=\"cb_post_title_url\" title=\"发布于 2026-02-19 22:06\">\n    <span>凸优化数学基础笔记（五）：极小值点的判定条件</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        函数f(X)在局部极小值点应满足什么条件？反之，满足什么条件的是局部极小点?这就是凸优化的基本问题。下面针对多元函数的情形给出各类极小值点的定义。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>​\t函数<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 在局部极小值点应满足什么条件？反之，满足什么条件的是局部极小点?这就是凸优化的基本问题。下面针对多元函数的情形给出各类极小值点的定义。</p>\n<p>​\t<strong>定义 5.1</strong> 对于任意给定的实数<span class=\"math inline\">\\(\\forall \\delta&gt;0\\)</span>，满足不等式 <span class=\"math inline\">\\(||\\mathbf{X}-\\mathbf{X}_0||&lt;\\delta\\)</span> （<span class=\"math inline\">\\(\\mathbf{X,X_0}\\in\\mathbf{R}^{n}\\)</span>）的集合称为点 <span class=\"math inline\">\\(\\mathbf{X}_0\\)</span> 的领域，记为：</p>\n<p></p><div class=\"math display\">\\[N(\\mathbf{X}_0,\\delta)=\\{\\mathbf{X}|\\space||\\mathbf{X}-\\mathbf{X}_0||&lt;\\delta,\\delta&gt;0\\} \\tag{1}\n\\]</div><p></p><p>​\t<strong>定义 5.2</strong> 设 <span class=\"math inline\">\\(f:\\mathbf{D}\\subseteq\\mathbf{R}^n\\rightarrow\\mathbf{R}\\)</span>，若存在点<span class=\"math inline\">\\(\\mathbf{X}^{*}\\in\\mathbf{D}\\)</span> 和正数<span class=\"math inline\">\\(\\delta&gt;0\\)</span>，<span class=\"math inline\">\\(\\forall \\mathbf{X}\\in{N(\\mathbf{X}^{*},\\delta)}\\cap\\mathbf{D}\\)</span> 都有<span class=\"math inline\">\\(f(\\mathbf{X}^*)\\leq f(\\mathbf{X})\\)</span> ，则称<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 为<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 局部极小值点（非严格）。</p>\n<p>​\t<strong>定义5.3</strong>  设 <span class=\"math inline\">\\(f:\\mathbf{D} \\subseteq{\\mathbf{R}^n}\\rightarrow{\\mathbf{R}}\\)</span> ，若存在点<span class=\"math inline\">\\(\\mathbf{X}^{*}\\in{\\mathbf{D}}\\)</span>和正数<span class=\"math inline\">\\(\\delta&gt;0\\)</span>，<span class=\"math inline\">\\(\\forall {\\mathbf{X}}\\in{N(\\mathbf{X}^{*},\\delta)}\\cap\\mathbf{D}\\)</span> 且 <span class=\"math inline\">\\(\\mathbf{X}\\neq{\\mathbf{X}^{*}}\\)</span> ，都有<span class=\"math inline\">\\(f(\\mathbf{X}^{*})&lt;f(\\mathbf{X})\\)</span> ，则称<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 为<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 在点<span class=\"math inline\">\\(\\mathbf{D}\\)</span> 的严格局部极小值点。</p>\n<p>​\t<strong>定义5.4</strong> 设<span class=\"math inline\">\\(f:\\mathbf{D}\\subseteq{\\mathbf{R}^n}\\rightarrow\\mathbf{R}^1\\)</span>，若存在点<span class=\"math inline\">\\(\\mathbf{X}^{*}\\in{\\mathbf{D}},\\forall \\mathbf{X}\\in{\\mathbf{D}}\\)</span> 都有<span class=\"math inline\">\\(f(\\mathbf{X}^{*})&lt;f(\\mathbf{X})\\)</span> ，则称<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 为<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 在<span class=\"math inline\">\\(\\mathbf{D}\\)</span> 上的全局极小值（非严格）。</p>\n<p>​\t<strong>定义5.5</strong> 设<span class=\"math inline\">\\(f:\\mathbf{D}\\subseteq{\\mathbf{R}^n\\rightarrow{\\mathbf{R}^1}}\\)</span> ，若存在点 <span class=\"math inline\">\\(\\mathbf{X}^{*}\\in{\\mathbf{D}}\\)</span> ，<span class=\"math inline\">\\(\\forall \\mathbf{X}\\in{\\mathbf{D}}\\)</span> 但 <span class=\"math inline\">\\(\\mathbf{X}\\neq \\mathbf{X}^*\\)</span> ,都有<span class=\"math inline\">\\(f(\\mathbf{X}^{*})&lt;f(\\mathbf{X})\\)</span> ，则称<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 为<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 在<span class=\"math inline\">\\(\\mathbf{D}\\)</span> 上的严格全局极小值点。</p>\n<p>​\t由于以上定义看到，<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是<strong>局部极小值点</strong>，是指在以下<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 为中心的一个领域中<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 在点<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 处取得最小的值；而<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是<strong>全局极小值点</strong>，是指在定义域<span class=\"math inline\">\\(\\mathbf{D}\\)</span> 中<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 在点<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 处取得最小的值。全局极小值点可能在某个局部极小值点，也可能在<span class=\"math inline\">\\(\\mathbf{D}\\)</span> 的边界上取得。</p>\n<p>​        由此，实际问题上通常是求取全局极小值点，但到目前为止，最优化中绝大多数方法都是求局部极小值点的，解决这一矛盾的一种方法是求出所有的局部极小值点，再求出全局极小值点。</p>\n<p>​\t<strong>定 理 5.1</strong> 设<span class=\"math inline\">\\(f:\\mathbf{D}\\subseteq {\\mathbf{R}^n}\\rightarrow\\mathbf{R}^1\\)</span> 具有连续的一阶偏导数。若<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 的局部极小值点并且是<span class=\"math inline\">\\(\\mathbf{D}\\)</span> 的内点，则</p>\n<p></p><div class=\"math display\">\\[\\nabla{f(\\mathbf{X}^{*})}=\\mathbf{0}_{n\\times{1}} \\tag{2}\n\\]</div><p></p><p><strong>证 明</strong>：设<span class=\"math inline\">\\(\\mathbf{e}\\)</span> 是任意单位向量，由于<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span>是<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 的局部极小值点，所以存在<span class=\"math inline\">\\(\\delta&gt;0\\)</span>，当<span class=\"math inline\">\\(|t|&lt;\\delta\\)</span>或<span class=\"math inline\">\\(\\mathbf{X}^{*}+t\\mathbf{e}\\in{N(\\mathbf{X}^{*},\\delta)}\\)</span> 时总有</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X}^{*}+t\\mathbf{e})\\geq f(\\mathbf{X}^{*}) \\tag{3}\n\\]</div><p></p><p>引入辅助一元函数<span class=\"math inline\">\\(\\phi(t)=f(\\mathbf{X}^*+t\\mathbf{e})\\)</span>，此时，由式（3）可得，<span class=\"math inline\">\\(\\phi(t)\\geq\\phi(0)\\)</span>。 由于<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是<span class=\"math inline\">\\(\\mathbf{D}\\)</span> 的内点，所以与它对应的<span class=\"math inline\">\\(t=0\\)</span>是<span class=\"math inline\">\\(\\phi(t)\\)</span> 的局部极小值点。又根据一元函数极小值点的必要条件，得到<span class=\"math inline\">\\(\\phi^{\\prime}(t)=0\\)</span> 即利用梯度性质得到<span class=\"math inline\">\\(\\nabla{f(\\mathbf{X})}^T\\mathbf{e}=0\\)</span>。再由单位向量<span class=\"math inline\">\\(\\mathbf{e}\\)</span> 的任意性可得，<span class=\"math inline\">\\(\\nabla{f(\\mathbf{X}^{*})}=\\mathbf{0}\\)</span>。</p>\n<p>​\t这里式（2）仅仅是<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 的局部极小值点的必要条件，而不是充分条件，例如 <span class=\"math inline\">\\(f(x_1,x_2)=x_1x_2\\)</span> 在点<span class=\"math inline\">\\(\\mathbf{X}^{*}=[0,0]^T\\)</span> 处的梯度为<span class=\"math inline\">\\(\\nabla{f(\\mathbf{X}^*)}=[0,0]^T\\)</span>, 但是<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是<strong>双曲面的鞍点</strong>，而不是极小值点。</p>\n<p>​\t<strong>定 义5.6</strong>  设<span class=\"math inline\">\\(f:\\mathbf{D}\\subseteq{\\mathbf{R}^{n}}\\rightarrow\\mathbf{R}^{1}\\)</span> 具有连续二阶偏导数，<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是<span class=\"math inline\">\\(\\mathbf{D}\\)</span> 的一个内点，若<span class=\"math inline\">\\(\\nabla{f(\\mathbf{X^*})}=0\\)</span>，则称<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 为<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> <strong>驻点</strong>。</p>\n<p>​\t<strong>定 理 5.2</strong>  设<span class=\"math inline\">\\(f:\\mathbf{D}\\subseteq{\\mathbf{R}^n\\rightarrow{\\mathbf{R^{1}}}}\\)</span> 具有连续二阶偏导数，<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是<span class=\"math inline\">\\(\\mathbf{D}\\)</span> 的一个内点，若<span class=\"math inline\">\\(\\nabla{f(\\mathbf{X}^{*})}=0\\)</span> ,并且<span class=\"math inline\">\\(\\nabla^2f(\\mathbf{X}^{*})\\)</span>是正定的，则<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 的严格极小值点。</p>\n<p><strong>证 明：</strong> 因为<span class=\"math inline\">\\(\\nabla^2f(\\mathbf{X}^*)\\)</span> 是正定矩阵，则必存在<span class=\"math inline\">\\(\\lambda&gt;0\\)</span>,使得对于所有<span class=\"math inline\">\\(\\mathbf{P}\\in\\mathbf{R}^n\\)</span>都有</p>\n<p></p><div class=\"math display\">\\[\\mathbf{P}^T\\nabla^2f(\\mathbf{X}^{*})\\mathbf{P}&gt;\\lambda||\\mathbf{P}||^2 \\tag{4}\n\\]</div><p></p><p>(其参看高等代数二次型理论)。现在将<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span>在点<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 处按照Taylor 展开的，并注意到<span class=\"math inline\">\\(\\nabla f(\\mathbf{X}^*)=0\\)</span>, 于是可得：</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\nf(\\mathbf{X})-f(\\mathbf{X}^{*})&amp;=\\frac{1}{2}(\\mathbf{X}-\\mathbf{X^*})^T\\nabla^2f(\\mathbf{X}^*)(\\mathbf{X}-\\mathbf{X}^{*})+o(||\\mathbf{X}-\\mathbf{X}^{*}||^2)\\\\\n&amp;\\geq \\frac{1}{2}||\\mathbf{X}-\\mathbf{X}^{*}||^2+o(||\\mathbf{X}-\\mathbf{X}^{*}||^2)\n\\end{aligned}\n\\tag{5}\n\\]</div><p></p><p>当其<span class=\"math inline\">\\(\\mathbf{X}\\)</span> 充分接近<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> （但<span class=\"math inline\">\\(\\mathbf{X}\\neq \\mathbf{X}^{*}\\)</span>） 时，上式左端的符号取决于右端的第一项，因此，<span class=\"math inline\">\\(f(\\mathbf{X})&gt;f(\\mathbf{X}^{*})\\)</span> 。</p>\n<p>​\t一般来说，这个定理具备理论意义。因为对于复杂的目标函数，Hessian矩阵不易求得，它的正定性就更难判定了。</p>\n<p>​\t<strong>定理 5.3</strong> 若多元函数在其极小点处的<span class=\"math inline\">\\(Hessian\\)</span> 矩阵是正定的，则它在这个点附近的等值面近似地呈现为同心椭球面簇。</p>\n<p><strong>证 明：</strong>设<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是多元函数的极小点，并设<span class=\"math inline\">\\(f(\\mathbf{X})=\\gamma\\)</span> 是充分靠近极小点<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 的一个等值面，即<span class=\"math inline\">\\(||\\mathbf{X}-\\mathbf{X}^{*}||\\)</span>充分小。把<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 在<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 点展开Taylor表达式，即</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\nf(\\mathbf{X})=f(\\mathbf{X}^{*})+\\nabla{f(\\mathbf{X}^{*})^{T}}(\\mathbf{X}-\\mathbf{X}^{*})+\\frac{1}{2}(\\mathbf{X}-\\mathbf{X}^{*})^T\\nabla^2f(\\mathbf{X}^*)(\\mathbf{X}-\\mathbf{X}^{*})+o(||\\mathbf{X}-\\mathbf{X}^*||^2)   \n\\end{aligned}\n\\tag{6}\n\\]</div><p></p><p>右端第二项因<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是极小值点有<span class=\"math inline\">\\(\\nabla{f(\\mathbf{X}^{*})}=\\mathbf{0}\\)</span> 而消失。如果略去高阶小项，那么</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X})\\approx f(\\mathbf{X}^{*})+\\frac{1}{2}(\\mathbf{X}-\\mathbf{X}^{*})^T\\nabla^2f(\\mathbf{X}^{*})(\\mathbf{X}-\\mathbf{X}^{*})+O(||\\mathbf{X}-\\mathbf{X}^{*}||^2) \\tag{7}\n\\]</div><p></p><p>又因为<span class=\"math inline\">\\(f(\\mathbf{X})=\\gamma\\)</span> ，所以得到如下近似等式：</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X}^{*})+\\frac{1}{2}(\\mathbf{X}-\\mathbf{X}^{*})^T\\nabla^2f(\\mathbf{X}^{*})(\\mathbf{X}-\\mathbf{X}^{*})=\\gamma \\tag{8}\n\\]</div><p></p><p>其中<span class=\"math inline\">\\(f(\\mathbf{X}^{*})\\)</span>为已知常量 ，整理可得：</p>\n<p></p><div class=\"math display\">\\[(\\mathbf{X}-\\mathbf{X}^{*})^T\\nabla^2f(\\mathbf{X}^{*})(\\mathbf{X}-\\mathbf{X}^{*})=2(\\gamma-f(\\mathbf{X}^{*}))=constant \\tag{9}\n\\]</div><p></p><p>按假设<span class=\"math inline\">\\(\\nabla^2f(\\mathbf{X}^{*})\\)</span> 正定，由二次型理论可知，式（9）是以<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 为中心的椭球面方程。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-19 22:06</span>&nbsp;\n<a href=\"https://www.cnblogs.com/GeophysicsWorker\">GeoFXR</a>&nbsp;\n阅读(<span id=\"post_view_count\">50</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "FastAPI实战：WebSocket长连接保持与心跳机制，从入门到填坑",
      "link": "https://www.cnblogs.com/ymtianyu/p/19625144",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ymtianyu/p/19625144\" id=\"cb_post_title_url\" title=\"发布于 2026-02-19 17:05\">\n    <span>FastAPI实战：WebSocket长连接保持与心跳机制，从入门到填坑</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文通过实战案例，详细讲解FastAPI与JavaScript实现WebSocket长连接保持的心跳机制，包括前后端代码、参数调优和常见陷阱，帮助你打造稳定可靠的双向通信。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<div style=\"margin: 0 auto;\">\n<p style=\"font-size: 16px; color: rgba(93, 109, 126, 1); background-color: rgba(248, 249, 250, 1); padding: 12px 16px; border-radius: 8px; margin: 20px 0;\">📌 摘要：本文通过一个真实的上线案例，详细讲解FastAPI与JavaScript实现WebSocket长连接保持的心跳机制。你会了解为什么连接会断、心跳原理是什么、前后端代码怎么写，以及那些文档里没写的调优陷阱。照着做，让你的实时通信稳如老狗。</p>\n\n<p style=\"font-size: 16px; margin: 20px 0;\">你是不是也遇到过——WebSocket连接动不动就断开，尤其是在移动端，用户切换个Wi-Fi或者电梯里信号晃一下，消息就收不到了？📱 用户投诉说“APP消息延迟”，你一查日志，满屏都是<code style=\"background-color: rgba(246, 248, 250, 1); color: rgba(186, 55, 42, 1); padding: 2px 4px; border-radius: 4px;\">WebSocket disconnected</code>，然后疯狂重连，服务器压力山大，用户体验稀碎。</p>\n<p style=\"font-size: 16px; margin: 20px 0;\">有些项目图省事，觉得WebSocket连上就行了，结果线上跑了半天，运维小哥就发来报警：连接数忽高忽低，很多连接存活不到2分钟。查日志，好家伙，Nginx默认<code style=\"background-color: rgba(246, 248, 250, 1); color: rgba(186, 55, 42, 1); padding: 2px 4px; border-radius: 4px;\">proxy_read_timeout</code> 60秒，加上移动网络运营商会掐掉长时间无流量的连接，双向夹击，连接全断了。😭</p>\n<p style=\"font-size: 16px; margin: 20px 0;\"><strong style=\"color: rgba(186, 55, 42, 1);\">核心结论：</strong>WebSocket长连接保持，不能靠“连上就不管”，必须引入心跳机制——就像两个人打电话，每隔一会儿问一句“喂，还在吗？”。今天我就把FastAPI后端 + JavaScript前端的完整心跳实现，掰开了揉碎了讲给你听，顺便把我踩过的坑标红。</p>\n\n<div style=\"background-color: rgba(240, 247, 255, 1); padding: 16px; border-radius: 8px; margin: 25px 0;\">\n<p style=\"font-size: 18px; font-weight: 600; margin: 0 0 10px;\">🚦 本文路线图</p>\n<div style=\"margin-left: 8px;\">\n<p style=\"margin: 6px 0;\">🔹 为什么WebSocket会断？—— 中间件超时、网络状态变化</p>\n<p style=\"margin: 6px 0;\">🔹 心跳原理：ping-pong 还是 pong-ping？</p>\n<p style=\"margin: 6px 0;\">🔹 FastAPI后端：接收心跳消息 + 超时管理</p>\n<p style=\"margin: 6px 0;\">🔹 JavaScript前端：定时发送心跳 + 断线重连</p>\n<p style=\"margin: 6px 0;\">🔹 完整可运行代码示例</p>\n<p style=\"margin: 6px 0;\">🔹 那些年我踩过的坑（间隔设置、重复定时器、服务端主动断开）</p>\n</div>\n</div>\n<h2 style=\"font-size: 22px; font-weight: 600; margin: 30px 0 15px; padding-bottom: 6px;\">🧠 第一部分：连接为什么会断？</h2>\n<p style=\"font-size: 16px; margin: 20px 0;\">把WebSocket想象成一条水管，数据就是水。如果水管一直流水，它就不会堵。但要是你半天不放水，中间的路由器、防火墙就觉得“嘿，这管子是不是废弃了？”——<strong style=\"color: rgba(186, 55, 42, 1);\">咔嚓一刀给你掐了</strong>。尤其是在移动网络下，运营商的NAT网关空闲超时可能只有30秒到几分钟。还有我们常用的Nginx，默认<code style=\"background-color: rgba(246, 248, 250, 1); color: rgba(186, 55, 42, 1); padding: 2px 4px; border-radius: 4px;\">proxy_read_timeout</code>是60秒，一旦60秒内没有数据从后端发到客户端，Nginx就会自作主张断开连接。</p>\n<p style=\"font-size: 16px; margin: 20px 0;\">所以，要想让连接长存，唯一的方法就是<strong style=\"color: rgba(186, 55, 42, 1);\">定期发送一些“无用”的数据</strong>，告诉中间件：“我还活着，别砍我！”——这就是心跳。</p>\n<h2 style=\"font-size: 22px; font-weight: 600; margin: 30px 0 15px; padding-bottom: 6px;\">💓 第二部分：心跳机制的两种姿势</h2>\n<p style=\"font-size: 16px; margin: 20px 0;\">心跳本质是一种<code style=\"background-color: rgba(246, 248, 250, 1); color: rgba(186, 55, 42, 1); padding: 2px 4px; border-radius: 4px;\">ping/pong</code>模式。WebSocket协议本身有控制帧<code style=\"background-color: rgba(246, 248, 250, 1); color: rgba(186, 55, 42, 1); padding: 2px 4px; border-radius: 4px;\">Ping</code>和<code style=\"background-color: rgba(246, 248, 250, 1); color: rgba(186, 55, 42, 1); padding: 2px 4px; border-radius: 4px;\">Pong</code>，但浏览器原生JS的WebSocket API并没有直接暴露发送Ping帧的方法，所以我们一般用普通消息模拟：</p>\n<div style=\"margin-left: 8px;\">\n<p style=\"margin: 6px 0;\">✨ 方案A：客户端定时发送<code style=\"background-color: rgba(246, 248, 250, 1); color: rgba(186, 55, 42, 1); padding: 2px 4px; border-radius: 4px;\">ping</code>消息，服务器收到后立即回复<code style=\"background-color: rgba(246, 248, 250, 1); color: rgba(186, 55, 42, 1); padding: 2px 4px; border-radius: 4px;\">pong</code>。</p>\n<p style=\"margin: 6px 0;\">✨ 方案B：服务器定时发送<code style=\"background-color: rgba(246, 248, 250, 1); color: rgba(186, 55, 42, 1); padding: 2px 4px; border-radius: 4px;\">ping</code>，客户端回复<code style=\"background-color: rgba(246, 248, 250, 1); color: rgba(186, 55, 42, 1); padding: 2px 4px; border-radius: 4px;\">pong</code>。但同样，客户端需要能解析并回复。</p>\n</div>\n<p style=\"font-size: 16px; margin: 20px 0;\">更常见的做法是<strong style=\"color: rgba(186, 55, 42, 1);\">客户端主动发心跳，服务器只需响应或记录</strong>。为啥？因为客户端更能感知网络变化，且断开后能立即重连。下面我就以客户端发心跳为例，上代码。</p>\n<h2 style=\"font-size: 22px; font-weight: 600; margin: 30px 0 15px; padding-bottom: 6px;\">⚙️ 第三部分：FastAPI后端实战</h2>\n<p style=\"font-size: 16px; margin: 20px 0;\">先搭一个最简单的FastAPI WebSocket端点。这里我用了<code style=\"background-color: rgba(246, 248, 250, 1); color: rgba(186, 55, 42, 1); padding: 2px 4px; border-radius: 4px;\">/ws</code>路径，接收心跳消息（约定JSON格式<code style=\"background-color: rgba(246, 248, 250, 1); color: rgba(186, 55, 42, 1); padding: 2px 4px; border-radius: 4px;\">{\"type\": \"ping\"}</code>），并回复<code style=\"background-color: rgba(246, 248, 250, 1); color: rgba(186, 55, 42, 1); padding: 2px 4px; border-radius: 4px;\">{\"type\": \"pong\"}</code>。同时，为了及时清理死连接，我会记录每个连接的最后心跳时间，启动一个后台任务检查超时（比如60秒没收到心跳就主动close）。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nimport asyncio\nimport json\nfrom datetime import datetime, timedelta\n\napp = FastAPI()\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: dict[WebSocket, datetime] = {}\n        self._heartbeat_check_interval = 30   # 每30秒检查一次\n        asyncio.create_task(self.heartbeat_checker())\n\n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections[websocket] = datetime.utcnow()\n        print(f\"新连接加入，当前连接数：{len(self.active_connections)}\")\n\n    def disconnect(self, websocket: WebSocket):\n        if websocket in self.active_connections:\n            del self.active_connections[websocket]\n            print(f\"连接断开，当前连接数：{len(self.active_connections)}\")\n\n    async def handle_messages(self, websocket: WebSocket):\n        try:\n            while True:\n                data = await websocket.receive_text()\n                try:\n                    msg = json.loads(data)\n                except:\n                    continue\n                # 如果是心跳ping，更新最后心跳时间并回复pong\n                if msg.get(\"type\") == \"ping\":\n                    self.active_connections[websocket] = datetime.utcnow()\n                    await websocket.send_text(json.dumps({\"type\": \"pong\"}))\n                else:\n                    # 其他业务消息，按需处理\n                    await websocket.send_text(json.dumps({\"type\": \"echo\", \"data\": msg}))\n        except WebSocketDisconnect:\n            self.disconnect(websocket)\n\n    async def heartbeat_checker(self):\n        while True:\n            await asyncio.sleep(self._heartbeat_check_interval)\n            now = datetime.utcnow()\n            timeout = timedelta(seconds=70)  # 超过70秒没心跳就断开\n            dead_conns = []\n            for ws, last_ping in self.active_connections.items():\n                if now - last_ping &gt; timeout:\n                    dead_conns.append(ws)\n            for ws in dead_conns:\n                try:\n                    await ws.close(code=1000, reason=\"heartbeat timeout\")\n                except:\n                    pass\n                self.disconnect(ws)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await manager.connect(websocket)\n    await manager.handle_messages(websocket)</code></pre>\n<p style=\"font-size: 16px; margin: 20px 0;\"><strong style=\"color: rgba(186, 55, 42, 1);\">🔔 重点说明：</strong> <span style=\"display: block; margin-left: 16px; margin-top: 6px;\">- <code style=\"background-color: rgba(246, 248, 250, 1); color: rgba(186, 55, 42, 1); padding: 2px 4px; border-radius: 4px;\">handle_messages</code>里只处理心跳，其他业务消息可以自定义。</span> <span style=\"display: block; margin-left: 16px;\">- 后台心跳检查线程每30秒跑一次，如果某连接超过70秒没收到心跳，就主动关闭。这个70秒一定要大于客户端的心跳间隔（比如客户端30秒发一次，那70秒大概漏掉2次都没回复才断，防止网络抖动误杀）。</span> <span style=\"display: block; margin-left: 16px;\">- 注意<code style=\"background-color: rgba(246, 248, 250, 1); color: rgba(186, 55, 42, 1); padding: 2px 4px; border-radius: 4px;\">WebSocketDisconnect</code>的捕获，及时清理字典，避免内存泄漏。</span></p>\n<h2 style=\"font-size: 22px; font-weight: 600; margin: 30px 0 15px; padding-bottom: 6px;\">💻 第四部分：JavaScript前端实现</h2>\n<p style=\"font-size: 16px; margin: 20px 0;\">前端主要做三件事：建立连接、定时发心跳、监听断开自动重连。我习惯把WebSocket封装成一个类，方便复用。直接上代码：</p>\n<pre class=\"language-javascript highlighter-hljs\"><code>class WebSocketClient {\n    constructor(url) {\n        this.url = url;\n        this.ws = null;\n        this.heartbeatInterval = 30000; // 30秒一次心跳\n        this.reconnectInterval = 3000;   // 断线后3秒重连\n        this.heartbeatTimer = null;\n        this.reconnectTimer = null;\n        this.connect();\n    }\n\n    connect() {\n        this.ws = new WebSocket(this.url);\n        this.ws.onopen = () =&gt; {\n            console.log('WebSocket 已连接');\n            // 连接成功后，启动心跳\n            this.startHeartbeat();\n            // 如果之前有重连定时器，清掉\n            if (this.reconnectTimer) {\n                clearTimeout(this.reconnectTimer);\n                this.reconnectTimer = null;\n            }\n        };\n\n        this.ws.onmessage = (event) =&gt; {\n            const data = JSON.parse(event.data);\n            if (data.type === 'pong') {\n                console.log('收到心跳pong，连接正常');\n                // 可以在这里更新UI显示最后心跳时间，但不必须\n            } else {\n                // 处理其他业务消息\n                console.log('业务消息', data);\n            }\n        };\n\n        this.ws.onclose = (e) =&gt; {\n            console.log('WebSocket 关闭', e.reason);\n            // 停止心跳\n            this.stopHeartbeat();\n            // 尝试重连\n            this.reconnect();\n        };\n\n        this.ws.onerror = (err) =&gt; {\n            console.error('WebSocket 错误', err);\n            this.ws.close();\n        };\n    }\n\n    startHeartbeat() {\n        this.heartbeatTimer = setInterval(() =&gt; {\n            if (this.ws &amp;&amp; this.ws.readyState === WebSocket.OPEN) {\n                this.ws.send(JSON.stringify({ type: 'ping' }));\n                console.log('发送心跳ping');\n            } else {\n                console.warn('连接未开启，停止发送心跳');\n                this.stopHeartbeat();\n            }\n        }, this.heartbeatInterval);\n    }\n\n    stopHeartbeat() {\n        if (this.heartbeatTimer) {\n            clearInterval(this.heartbeatTimer);\n            this.heartbeatTimer = null;\n        }\n    }\n\n    reconnect() {\n        this.stopHeartbeat();\n        if (!this.reconnectTimer) {\n            this.reconnectTimer = setTimeout(() =&gt; {\n                console.log('尝试重连...');\n                this.connect();\n            }, this.reconnectInterval);\n        }\n    }\n\n    // 主动关闭连接（比如页面卸载时）\n    close() {\n        this.stopHeartbeat();\n        if (this.ws) {\n            this.ws.close();\n        }\n    }\n}\n\n// 使用示例\nconst client = new WebSocketClient('ws://你的域名/ws');\n// 页面关闭前主动清理\nwindow.addEventListener('beforeunload', () =&gt; client.close());</code></pre>\n<p style=\"font-size: 16px; margin: 20px 0;\"><strong style=\"color: rgba(186, 55, 42, 1);\">⚠️ 关键细节：</strong> <span style=\"display: block; margin-left: 16px; margin-top: 6px;\">- 心跳间隔不要超过Nginx的<code style=\"background-color: rgba(246, 248, 250, 1); color: rgba(186, 55, 42, 1); padding: 2px 4px; border-radius: 4px;\">proxy_read_timeout</code>，一般设30秒比较安全。</span> <span style=\"display: block; margin-left: 16px;\">- 断线重连要防抖：通过<code style=\"background-color: rgba(246, 248, 250, 1); color: rgba(186, 55, 42, 1); padding: 2px 4px; border-radius: 4px;\">reconnectTimer</code>避免重复重连。</span> <span style=\"display: block; margin-left: 16px;\">- 页面关闭时一定要<code style=\"background-color: rgba(246, 248, 250, 1); color: rgba(186, 55, 42, 1); padding: 2px 4px; border-radius: 4px;\">close</code>连接，否则服务端可能保留孤儿连接直到超时。</span></p>\n<h2 style=\"font-size: 22px; font-weight: 600; margin: 30px 0 15px; padding-bottom: 6px;\">🧪 第五部分：跑起来看看效果</h2>\n<p style=\"font-size: 16px; margin: 20px 0;\">启动FastAPI（<code style=\"background-color: rgba(246, 248, 250, 1); color: rgba(186, 55, 42, 1); padding: 2px 4px; border-radius: 4px;\">uvicorn main:app --reload</code>），打开浏览器控制台，你会看到每隔30秒发送一次ping，服务器立即回复pong。即使你断开Wi-Fi再打开，客户端也会自动重连，并且重连后心跳继续。🎯</p>\n<h2 style=\"font-size: 22px; font-weight: 600; margin: 30px 0 15px; padding-bottom: 6px;\">💣 第六部分：那些年我踩过的坑（必看）</h2>\n<div style=\"margin-left: 8px;\">\n<p style=\"margin: 6px 0;\"><strong style=\"color: rgba(186, 55, 42, 1);\">坑1：心跳间隔太短，服务器压力大</strong> —— 1秒一次纯属自残，30秒一次足够，既保活又省资源。</p>\n<p style=\"margin: 6px 0;\"><strong style=\"color: rgba(186, 55, 42, 1);\">坑2：服务端没做超时主动断开</strong> —— 客户端突然掉线（比如用户强制杀进程），服务端不知道，连接一直占着内存。所以后台心跳检查一定要有，超时就close。</p>\n<p style=\"margin: 6px 0;\"><strong style=\"color: rgba(186, 55, 42, 1);\">坑3：重连时忘记清理旧定时器</strong> —— 每次重连都新建一个<code style=\"background-color: rgba(246, 248, 250, 1); color: rgba(186, 55, 42, 1); padding: 2px 4px; border-radius: 4px;\">setInterval</code>，导致多个心跳线程并发，消息爆炸。解决方案：重连前先<code style=\"background-color: rgba(246, 248, 250, 1); color: rgba(186, 55, 42, 1); padding: 2px 4px; border-radius: 4px;\">stopHeartbeat()</code>。</p>\n<p style=\"margin: 6px 0;\"><strong style=\"color: rgba(186, 55, 42, 1);\">坑4：前后端心跳格式约定不一致</strong> —— 我用的是<code style=\"background-color: rgba(246, 248, 250, 1); color: rgba(186, 55, 42, 1); padding: 2px 4px; border-radius: 4px;\">{\"type\":\"ping\"}</code>，如果你后端用字段<code style=\"background-color: rgba(246, 248, 250, 1); color: rgba(186, 55, 42, 1); padding: 2px 4px; border-radius: 4px;\">heartbeat</code>，一定记得对齐，否则服务器不认，相当于没心跳。</p>\n<p style=\"margin: 6px 0;\"><strong style=\"color: rgba(186, 55, 42, 1);\">坑5：没考虑SSL/加密连接</strong> —— 生产环境用<span style=\"color: rgba(186, 55, 42, 1);\"><code>wss://</code></span>，证书配置要正确，否则连接直接被拒绝。</p>\n</div>\n<p style=\"font-size: 16px; margin: 20px 0;\">另外，如果你想更优雅一点，可以结合<code style=\"background-color: rgba(246, 248, 250, 1); color: rgba(186, 55, 42, 1); padding: 2px 4px; border-radius: 4px;\">asyncio.timeout</code>或者<code style=\"background-color: rgba(246, 248, 250, 1); color: rgba(186, 55, 42, 1); padding: 2px 4px; border-radius: 4px;\">websocket.receive()</code>的超时参数，不过我觉得上面这种“记录最后心跳+后台检查”的模式最清晰。</p>\n<h2 style=\"font-size: 22px; font-weight: 600; margin: 30px 0 15px; padding-bottom: 6px;\">📌 最后啰嗦一句</h2>\n<p style=\"font-size: 16px; margin: 20px 0;\">心跳机制不是银弹，但它确实是WebSocket长连接保持最简单有效的办法。结合断线重连，能让你的实时应用在恶劣网络环境下依然坚挺。如果你在生产环境还有更高要求，比如集群下的连接状态同步、心跳与业务消息优先级，欢迎留言交流。</p>\n<hr />\n<p style=\"font-size: 18px; font-weight: 500; color: rgba(44, 62, 80, 1); margin-bottom: 10px;\">老朋友提醒 👋</p>\n<p style=\"font-size: 16px; margin: 10px 0;\">这篇文章里的代码我都是用血泪教训换来的，现在直接抄就能跑。但你的业务场景可能不一样，比如心跳间隔是否需要动态调整？服务端要不要主动ping？欢迎在评论区分享你的“奇葩”踩坑经历，或者收藏起来，下次上线前翻出来看一眼，也许能帮你省下一个通宵。</p>\n<p style=\"font-size: 16px; margin: 30px 0 10px;\"><strong style=\"color: rgba(186, 55, 42, 1);\">如果你觉得有用，点赞或分享给团队，下次遇到WebSocket断连问题，咱们就不再慌了。😎</strong></p>\n</div>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-19 17:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ymtianyu\">一名程序媛呀</a>&nbsp;\n阅读(<span id=\"post_view_count\">84</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "2023年电赛国赛经历",
      "link": "https://www.cnblogs.com/badboy02/p/19623709",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/badboy02/p/19623709\" id=\"cb_post_title_url\" title=\"发布于 2026-02-19 14:06\">\n    <span>2023年电赛国赛经历</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"2023年电赛国赛经历\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3763221/202602/3763221-20260219000428689-1446099918.png\" />\n        2023年全国大学生电子设计竞赛经历，D题信号题，国赛二等奖。\n一些比赛经历和经验技巧\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>--- markdown描述<br />\ntitle: 电赛2023国赛D题比赛经历<br />\ndate: 2023/8/15 11:52:25<br />\ncover: true<br />\nmathjax: false<br />\nsummary: 比赛过程和一些准备工作的碎碎念<br />\ncategories: Note<br />\ntags:</p>\n<ul>\n<li>电赛</li>\n<li>信号</li>\n</ul>\n<hr />\n<h2 id=\"补档声明\">补档声明</h2>\n<p>由于我的博客服务器和备案到期，所以选择转移到博客园平台来进行保存和记录。以后也有可能会在上面不定期更新一些技术类博客。</p>\n<h2 id=\"写在前面\">写在前面</h2>\n<p>🪓突然意识到自己已经8个月没更新博客了，这段时间其实也没遇上啥太复杂的事，大概就是一些沉淀之类的，决定了之后的学业去向，推免了本校的研究生。进一步认识了一群未来志同道合的的同门，激情爽玩塞尔达旷野之息和王国之泪，狠狠地治愈了一阵子的电子阳痿，以及开始健身（存疑）。<br />\n当然，电赛什么的也是有在准备的，由于团队其他两个都是硬件佬，他们承受着画板与焊接调试的水深火热，我只需要安安静静的写代码就足够了（笑），每天实验室上下班，把自己的部分搞定，然后去健身房锻炼一会，回来美美加个餐洗个澡，然后打打机去睡觉，也算是某种意义上的平静的生活，求之不得。毕竟当初决定打电赛说到底也只是为了提升自己，探索一下电子世界的奥妙，这么久走过来也是重在坚持，也希望最后能有一个好结果。<br />\n截止到写博客的时候，我们组的成绩省赛以省一并列第一出线，综合测评应该也能过线，山东大学国测复测不出意外的话，应该是国二以上。</p>\n<p>这篇博客会分为上下两部分，上篇主要是比赛的过程和一些前置的准备(没有营养的碎碎念)，下篇主要是一些算法具体的实现(一些情急之下的灵机一动，大佬轻锤)。</p>\n<h2 id=\"比赛过程\">比赛过程</h2>\n<ol>\n<li>准备阶段</li>\n</ol>\n<p>我们队伍一直以来训练的是仪表和高频题，一开始侧重FPGA高速信号采集和数字域处理这一块，但是后面逐渐意识到，对于电赛的指标范围内好像也不需要这么高的频率，高载波带来的高采样率问题可以通过下混频缓解，而高频直采带来是的FIR滤波器的资源消耗成倍增加，以及数字域处理带来的资源占用和量化噪声问题。</p>\n<p><img alt=\"ZYNQ7100平台\" class=\"lazyload\" /><br />\n这是我们准备的ZYNQ7100的平台，可以外接高速ADDA，板载DDR3.<br />\n但是吧，ZYNQ平台的综合速度和固化难度以及Verilog代码的验证难度，在分秒必争的竞赛里，如果没有长期的训练和准备，在比赛那四天着急上头去写，恐怕会翻车。</p>\n<p>于是在训练后期又重回STM32H743的单片机平台，侧重模块叠加后的健壮性和代码的可复用性。</p>\n<p>从训练开始，🪓就有意识地把一些算法，尤其是FFT分析这一块，写成了独立的函数去进行一些参数的分析，然后把其他的像是屏幕显示，按键输入，外设驱动，都封装成主循环中的函数，用参数和标志位去控制。不得不说在电赛的信号分析题中还是一种很好用的代码架构。</p>\n<p><img alt=\"Main函数截图\" class=\"lazyload\" /></p>\n<p>本次代码的组织结构，可以清楚的看到，是首先进行ADC采集，FFT计算，然后将参数传入Judge_ModeType函数计算出调制类型，然后进入相应的部分去进行分析和显示。</p>\n<p>2.正式开始</p>\n<p>比赛的那几天，第一天上午8点队友一拿到题目基本上就确定了是D题，然后就开始画系统框图，找模块，搭系统。<br />\n🪓是九点钟到的实验室。然后一看题，哦豁，Ma和Mf！ 这不是老朋友吗，去年省赛这两位重量级，特别是Mf，让无数队伍刹羽而归。<br />\n其奇妙的多值和莫名其妙的算不准问题，难到了一大批电赛壬。<br />\n不过算法方面🪓早有应对，具体请看后文分析。<br />\n队友把混频模块弄好，确定好中频频率后，把混频后的信号通入ADC模块，此时🪓进行了简单的测试，确定了ADC采样率。<br />\n然后就开始了算法的编写。在第一天的中午就把Ma的计算搞定了，精度误差大概在0.05左右。<br />\n然后下午把Mf的算法也基本调试正确了，精度误差在0.2左右，有少量的多值问题，这时候时间已经是第一天晚上的8点，🪓进行了第一次备份。（时常备份真是好习惯）<br />\n<img alt=\"备份截图\" class=\"lazyload\" /><br />\n这是工程的几次备份图，可以看到从7月17日确定了基本平台之后，就是几天一备份，在比赛那几天更是一天备份几次。<br />\n为什么没有使用git之类的版本控制工具呢，因为我不会（其实是懒得建仓库+没找到合适的托管平台，github连不上，gitee不想用）<br />\n然后就是ASK，FSK，PSK的判别、解调以及FSK的h参数计算问题，总的说来，这个花费了🪓一番功夫，也算是最核心的代码部分。<br />\n第二天的中午完成了模拟调制和数字调制两大类的初步判断，下午进一步完成了模拟的AM，FM，CW的进一步判断，以及数字的ASK，FSK，PSK的进一步判断和解调。(充实的一天)<br />\n<img alt=\"PSK解调\" class=\"lazyload\" /><br />\n第二天晚上回寝室的时候🪓在和队友闲扯的时候突然想到了FSK的h参数计算方法，然后在小本本上记了下来。<br />\n第三天，🪓一到实验室就开始着手验证自己的想法，发现完全可以，直接芜湖起飞。<br />\n然后下午的时间就是加入射频开关和滤波器，放大器等原件，完成了系统的整体级联和最后解调波形的实时切换。<br />\n第三天的晚上其实整个系统已经级联并且测试好了。<br />\n最后一天就是一些锦上添花的功能，比如实时频谱显示和QPSK的判断以及高频载波下的解调以及准度的修正，在下午三点左右完成了最后的测试和封箱。<br />\n<img alt=\"封箱\" class=\"lazyload\" /><br />\n总的来说这几天的流程还是稳扎稳打，逐步推进的。我们团队一直以来配合的也很不错，效率贼高，最后呈现出来的效果就是电赛这三天每天晚上11点都回寝室睡觉了，第二天9点再到实验室，也还能完成所有的基础和提高指标并做出3项其他指标。不知不觉中完成了我们团队刚开始接触电赛的时的一个玩笑-希望以后能不熬夜就打完电赛。<br />\n<img alt=\"交作品\" class=\"lazyload\" /><br />\n作为东道主，半夜交作品也是很合理的罢。</p>\n<p>3.省赛测评</p>\n<p>封箱后的第二天就是省测了，总的来说还是蛮顺利的，所有功能都演示出来了，测评表的指标也没有很难的点。<br />\n测完直接和朋友出去快乐吃喝，等待综合测评名单。</p>\n<p>4.综合测评<br />\n由于🪓理论上是纯软件队员(其实🪓也会画板子和焊板子，这就是EEer的素养)，综合测评的硬件大业当然就交给我的两位大爹队友了，🪓只需要在旁边写个报告算个参数就好。<br />\n在准备硬件测评器件，我们测试了各种555电路，二极管检波，微分积分器，加法器，带通滤波器的电路图。<br />\n综合测评那天，一进现场，发现题目竟然是模拟计算器，用来解一个微分方程。<br />\n不过稍加分析，就会发现其本质是文氏桥正弦发生器，三角波发生器，两个积分器，一个微分器，一个加法器的组合。<br />\n这一里面的每一项单独拎出来都很简单，但是在当时时间比较紧促的情况下，我们虽然把电路全部级联出来了，但是在零状态的时候，并没有像计算的那样，产生一个33Hz的自激波形。<br />\n也许是中间的某项RC常数没有配置正确，也许是某一段未修正相差，也许是某一段的偏置需要消除，总是零状态的时候就是妹有出波形。<br />\n说到模拟计算电路，其实这是个展开来讲有非常多可以讲的话题，想进一步研究的同学可以移步CNPP大佬的模拟计算 <a href=\"https://hackaday.io/project/191142-analog-lorenz-attractor-computer/details\" rel=\"noopener nofollow\" target=\"_blank\">https://hackaday.io/project/191142-analog-lorenz-attractor-computer/details</a><br />\n我们也就停止了后面的输入激励。静待比赛时间结束，毕竟这只是一个达标测试，就不冒进去做进一步的冒险了。</p>\n<p>有一说一中午学校提供的饭菜还可以，菜品有土豆烧牛肉，木耳炒蛋，水煮虾，还有酸奶和水果，我TM吃吃吃。</p>\n<p>4.国赛评测</p>\n<p>等🪓玩回来更新</p>\n<h2 id=\"题目分析\">题目分析</h2>\n<p><img alt=\"题目描述1\" class=\"lazyload\" /></p>\n<p><img alt=\"题目描述2\" class=\"lazyload\" /></p>\n<p><strong>题目分析（*的数量为重要程度）</strong></p>\n<ul>\n<li>题目的输入信号有100mv，属于一个比较大的信号，从信号源直出，通过SMA线输入，<strong>信噪比非常高，不需要考虑信号在无线传输过程中被干扰和多径效应等问题</strong></li>\n<li>载波频率2MHz，说实话，是一个比较微妙的频率，刚好超过了市面上单片机内置ADC的最大采样频率，但是对于FPGA外挂的50M左右的高速ADC来说(AD9225:没错正是在下)，又看上去是一个很合适的频率。所以使用单片机的组一般会<strong>选择下混频</strong>，而使用FPGA的组如果选择直采，经过我们当时的分析，可能会遇到一些问题问题，比如FFT后频率分辨率不够，FIR资源消耗大带来的综合慢，数字下混频相位不对齐造成的失真和误差(更别提Vivado的FFT的IP核要想用好其实并不容易，定点FFT很容易产生很大的舍入误差)。肯定有FPGA佬能想到规避或者解决的办法。但是受限与我们当时知识理解的程度，我们还是选择了单片机平台。所以从这也可以看出电赛的出题并不一味地要求好的器件，而更多的是<strong>因地制宜选择方案</strong></li>\n<li><strong>要计算调幅度Ma，这就要求获得调制后信号的频谱，也就是要做FFT</strong>。这就要求ADC的采样频率能够高于中心频点+最大频偏之和的两倍。当然，实际上为了频谱的可读性和频率精确度的考量，一般选择4至6倍的采样频率*</li>\n<li>要计算调频度Mf和最大频偏Δf，同上，还涉及到一些算法的<strong>多值问题</strong>，在后面详细讨论</li>\n<li>要进行模拟调制的解调，可以先通过混频**把信号混到10.7M高中频，使用ADL5511 ，NE564等芯片进行解调</li>\n<li>要识别ASK，FSK，PSK等调制方式，这就要求<strong>把它们的频谱差异提取出来并做好特征区分，以及对于某些非常相似情况下引入多重判断维度来进行区分</strong> 。</li>\n<li>要通过频谱进行FSK的h参数的计算，其实在单片机里做是很难的，但是我们可以<strong>通过FM和FSK的相似性，来进行一些取巧的操作</strong>，这个后面详细讨论**</li>\n<li>要识别待调制波的频率，其实就是<strong>计算调制后波形的FFT相邻频点之间的间隔</strong>，这一点是由调制的性质所导致的，所有调制方式都能通过这种方式判断待调制波的频率*</li>\n<li>要进行数字调制波形的解调，<strong>要结合不同调制方式的特点，混合使用模拟模块和数字域判决的方式来进行解调</strong>，比如ASK使用的是先通过模拟AD8310检波后通过直流量高低来判断0，1波形。FSK使用了数字FIR把频率转变为包络的变化，进行0，1的判决。而PSK使用了先数字域下混频和FIR的方式，把相位的跳变导致的相乘后的包络变化通过滤波器检出</li>\n<li>要综合上述的识别和计算，通<strong>过模拟开关将解调结果通过一个通道显示</strong>在示波器上，并通过AGC等手段，保证电压大于1Vpp*</li>\n</ul>\n<h2 id=\"系统架构\">系统架构</h2>\n<p><img alt=\"系统架构\" class=\"lazyload\" /></p>\n<p>本系统硬件框图如图所示，乍一看非常复杂(实际上也确实很复杂，最后数了一下，作品上一共有26块板子)。别急，让我们慢慢来，一步步分析，<br />\n由于输入信号的峰峰值是100mV，换算一下也就是-16dbm，所以首先经过24dB增益的低噪放ERA-3SM进行放大。<br />\n此时的信号幅度有8dbm，也就是峰峰值1.5Vpp，正好适合后面的各种器件的电压范围。<br />\n然后将信号通过功分器，同时混频到50kHz中频和10.7MHz中频。这是为了一路用来分析，一路用来模拟解调。<br />\n50kHz 的中频信号，经过滤波、放大和电平搬移后，一路经过ADS8688变为数字信号送入单片机。另一路经过检波器 AD8310 和滤波器 UAF42 后检出 ASK 的直流，并送给单片机进一步完成 ASK 信号的定时抽判。<br />\n10.7MHz 的中频信号经过陶瓷滤波器、放大器和射频开关后，分别进行基于 ADL5511 的 AM 包络检波解调和基于 NE564 的FM 解调.<br />\n最后通过 MCU 控制的模拟开关TMUX1109，将解调结果送给示波器显示。在单片机内，通过对 50kHz 的中频信号的频谱分析，得到调制信号类型和调制参数，<br />\n以及FSK和PSK的解调结果的输出，并控制其他模块完成最后结果的汇总输出，以及控制液晶屏显示识别结果和参数。</p>\n<h2 id=\"一些准备工作和小寄巧\">一些准备工作和小寄巧</h2>\n<h3 id=\"电压和dbm的换算\">电压和dbm的换算</h3>\n<p>在射频电路中，为了表示比较小的电压，一般采用对数形式，其中dbm是一个常用的单位，它是在某一阻抗匹配系统下，功率相对于1mW的比值，而由于已经射频电路阻抗一般是50欧姆，所以相当于也知道了电压。<br />\n不过由于功率的计算还涉及到波形的有效值啥的，方波1，正弦0.707，三角波0.57，实际中一般不会自己去算，都是使用这种在线计算器。<br />\n可以记忆一下一些常见的值</p>\n<table>\n<thead>\n<tr>\n<th>正弦波</th>\n<th>50欧姆阻抗下</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-116dbm</td>\n<td>1uVpp</td>\n</tr>\n<tr>\n<td>-56dbm</td>\n<td>1mVpp</td>\n</tr>\n<tr>\n<td>-36dbm</td>\n<td>10mVpp</td>\n</tr>\n<tr>\n<td>-16dbm</td>\n<td>100mVpp</td>\n</tr>\n<tr>\n<td>0dbm</td>\n<td>632mVpp</td>\n</tr>\n<tr>\n<td>4dbm</td>\n<td>1Vpp</td>\n</tr>\n<tr>\n<td>14dbm</td>\n<td>3.3Vpp</td>\n</tr>\n</tbody>\n</table>\n<p>实用小工具 电压和dbm的换算<br />\n<a href=\"https://www.analog.com/cn/design-center/interactive-design-tools/dbconvert.html\" rel=\"noopener nofollow\" target=\"_blank\">https://www.analog.com/cn/design-center/interactive-design-tools/dbconvert.html</a></p>\n<p><img alt=\"ADI电压换算工具\" class=\"lazyload\" /><br />\n注意这里的VPeak是峰值，换算成峰峰值的话要乘以2</p>\n<h3 id=\"adc的一些准备工作\">ADC的一些准备工作</h3>\n<p><img alt=\"ADS8688手册\" class=\"lazyload\" /></p>\n<h4 id=\"adc选型\">ADC选型</h4>\n<p>我们本次使用的是ADS8688A作为系统的ADC，它是一个16bit，500KSPS采样率的SAR型ADC。<br />\n它的特点有双极性输入，可配置动态范围，内部基准，八通道MUX采样，误差和漂移都很低，对于本题来说肯定是够用的。<br />\n我们用它主要还是看上了它支持双极性输入和可变动态范围这一点，这样就不用自己做前级的搬移和放大。<br />\n而且自带过压保护，比较耐造。<br />\nPS.我们的STM32H743平台的内置ADC，在某次测试的时候，对单频大幅值信号采样做FFT后，其二次谐波值会大的超出常理，理论上来说是不会有这么大的。<br />\n怀疑内置SAR积分电路被过压橄榄了😓<br />\n所以换用了这个外置的ADC，以后可以开一篇文章讲一下ADC的各种参数，以及这种失真是怎么来的，此时就要请出另一位小信号领域的expert，FloydFish🐟<br />\n可以移步<a href=\"https://www.emoe.xyz/opamp-noise-analyze/\" rel=\"noopener nofollow\" target=\"_blank\">https://www.emoe.xyz/opamp-noise-analyze/</a> ，以及相关的小信号测量。</p>\n<p>驱动代码<br />\n这个的驱动我已经打包好了，下载下来改一下管脚直接用就可以了 <a href=\"https://megrez-hong.oss-cn-shanghai.aliyuncs.com/blogs/ADS8688_Driver.zip\" rel=\"noopener nofollow\" target=\"_blank\">https://megrez-hong.oss-cn-shanghai.aliyuncs.com/blogs/ADS8688_Driver.zip</a><br />\n<strong>ADC的驱动要注意的两点是，一是这个ADC的数据Latch和吐出是根据SPI的速率来的</strong><br />\n所以为了控制采样速率，需要自己控制其中的IO操作后的Delay函数，经过测试，在ARMCC6编译器，O2水平的优化下，使用volatile参数，下面这种delay方法依然可以达到延时效果。</p>\n<p><img alt=\"Delay的实现\" class=\"lazyload\" /></p>\n<p><img alt=\"ADS8688的采样函数\" class=\"lazyload\" /><br />\n二是采样的时候需要关闭中断响应，因为我们不希望采样的时候定时器中断什么的把采样操作打扰了。</p>\n<p>这里的采样率根据实测大概在250K左右，达不到官方的标称的500K。应该是已经达到了软件SPI的IO速度上限了，250kSPS*16bit = 4Mbit的速度了。</p>\n<p>如果要更快一点，可以使用硬件SPI+DMA的方式，但是比赛当前，就不折腾花活了，能用就好。</p>\n<p>另外一点是STM32的H7系列的软SPI的会有的一个毛病，在CubeMX中需要把这些个管脚(CLK,MISO,MOSI,CS)的最大频率设置成Low，否则如果设置为High之类的。</p>\n<p>较大的驱动电流会造成信号的过冲和振铃，造成读出的数据有时是对的，有时读出的会是全1或者全0。</p>\n<p>这一点我是在调试RDA5820的时候发现的，之前用STM32U5驱动RDA5820是正常的，同样的代码在H7下就会有时正确有时不能读出。后来在思考信号完整性链路的时候有了新的想法。</p>\n<p>我个人的看法是，可能由于是H7的驱动电流能力比较强，IO翻转的上升沿相比F1，F7这些要陡峭很多，而数字信号链路是通过一段比较长的XH2.54线接到了外部的模块上，<br />\n根据传输线模型的推论，当传输线长度和1/6上升沿波长可以相比拟时，就有可能造成信号完整性问题。<br />\n所以这时IO驱出来的数字波形会有过冲和振铃等信号完整性问题也是可以理解的。</p>\n<p>验证ADC采集时候，一般会串口打印波形，再使用SerialPlot查看，是不是和理论符合，比如下图就是ASK波形的采样结果。</p>\n<p><img alt=\"ASK的采集到的波形\" class=\"lazyload\" /></p>\n<h3 id=\"fft的准备工作\">FFT的准备工作</h3>\n<ul>\n<li>使用Cmsis DSP库，在Keil的包管理里面勾选即可，最新版本有窗函数的需要从官网上下载（怎么感觉有点似曾相识，我去年暑假好像也写过）</li>\n</ul>\n<p><img alt=\"Keil添加Pack\" class=\"lazyload\" /></p>\n<ul>\n<li>\n<p>在Keil的设置里面，加入ARM_MATH_CM7, ARM_MATH_LOOPUNROLL这两条宏定义，前面是Cortex版本，需要是MCU的内核版本，可以是CM1，CM4，CM7,后面的是控制数学舍入的，一般来说不用动。<br />\n<img alt=\"keil的编译设置\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>然后在include的地方加入 #include \"arm_math.h\"   和  #include \"arm_const_structs.h\"，然后开辟一个fft的全局数组，就可以愉快的调用啦。</p>\n</li>\n<li>\n<p><strong>FFT的调用</strong>**</p>\n</li>\n</ul>\n<pre><code class=\"language-C\">/* ADC采样并做FFT 结果放在全局数组fft_outputbuf中 */\n/* 做FFT 结果放在全局数组fft_outputbuf中 一次4096个点 */\nvoid FFT(unsigned short *ADC_Buffer, unsigned int SampleRate, unsigned int len, int debug, int serialplot)\n{\n    for(int i=0;i&lt;Sampling_CNT;i++)\n    Global_ADC_Value[i] = ADC_Buffer[i]*3.3/4096;   // 将采样结果转化到0-3.3V\n    \n    for(int i=0;i &lt; FFT_LENGTH;i++)   \n    {\n    fft_inputbuf[i*2] = Global_ADC_Value[i];  // 按手册要求的实部虚部交替的方法填充数组\n    fft_inputbuf[2*i +1] = 0;\n    }\n\n    arm_cfft_f32(&amp;arm_cfft_sR_f32_len4096,fft_inputbuf,0,1); // 执行FFT变换，arm_cfft_sR_f32_len4096为宏，定义旋转因子\n    arm_cmplx_mag_f32(fft_inputbuf,fft_outputbuf,FFT_LENGTH);    // 把运算结果复数求模得幅值\n\n    /* Debug打印区 */\n    \n    if(debug == 1)\n     for(int i=0;i &lt; FFT_LENGTH/2;i++)       // 是否打印FFT每个频点的幅值信息\n       printf(\"%d  %.3lf KHz Mag %.3f\\n\", i,SampleRate*1.0/len*i, fft_outputbuf[i] );\n    \n    if(serialplot == 1)\n     for(int i=0;i &lt; FFT_LENGTH;i++)       //  是否打印fft结果到到SerialPlot\n        printf(\"%.3f\\n\", fft_outputbuf[i]);\n\n}\n</code></pre>\n<p>做完FFT后，我们一般会通过SerialPlot软件来查看FFT的结果和和理论估计是否符合。<br />\n下图是1KHz载波，3KHz频偏的FM频谱的实测图<br />\n<img alt=\"FM的频谱\" class=\"lazyload\" /></p>\n<h3 id=\"代码组织的思路\">代码组织的思路</h3>\n<p>这题是一个经典的测量-分析-显示的题目，所以采用的思路就是先采集，判断调制类型后，进一步去对应的部分进行进一步的分析和显示。<br />\n由于FFT分析后给的参数值不止一个，所以使用了函数传地址的办法。<br />\n<img alt=\"函数传参参数\" class=\"lazyload\" /><br />\n而且由于Keil没有比较方便的代码补全和快捷提示功能，如果所有的算法都在main中实现，会导致代码实现那一段到下面的main函数的里调用段，有一段非常长的距离，所以我个人的建议是把一些更基础的算法代码另外封装到一个Algorithm文件里。<br />\n<img alt=\"Algorithm.c截图\" class=\"lazyload\" /></p>\n<h3 id=\"下节预告鸽了实际上因为神秘赛制的原因我们没有去到比赛现场但是还是国赛二等奖就不献丑了\">下节预告（鸽了，实际上因为神秘赛制的原因，我们没有去到比赛现场，但是还是国赛二等奖，就不献丑了）</h3>\n<ul>\n<li>模拟调制和数字调制两个大类的区分(中心载频与相邻频点之间的距离)</li>\n<li>三种模拟调制的区分(CW, AM, FM)</li>\n<li>三种数字调制的区分(ASK, FSK, PSK)</li>\n<li>各种调制载波频率的计算(频谱最近相邻谱线的距离)</li>\n<li>AM调制的Ma的计算(寻峰算法)</li>\n<li>FM调制的Mf的计算(基于模式匹配的思想)</li>\n<li>FSK调制的h参数的计算(基于和FM的相似带来的模式复用)</li>\n<li>ASK的抽判(基于直流量的定时抽判)</li>\n<li>FSK的抽判(两路FIR后的抽判)</li>\n<li>PSK的抽判(满足特定频率的相位突变点抽判法)</li>\n</ul>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-19 14:06</span>&nbsp;\n<a href=\"https://www.cnblogs.com/badboy02\">Badboy02</a>&nbsp;\n阅读(<span id=\"post_view_count\">94</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "从零开始学Flink：实时数仓与维表时态Join实战",
      "link": "https://www.cnblogs.com/daimajiangxin/p/19624638",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/daimajiangxin/p/19624638\" id=\"cb_post_title_url\" title=\"发布于 2026-02-19 12:58\">\n    <span>从零开始学Flink：实时数仓与维表时态Join实战</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"从零开始学Flink：实时数仓与维表时态Join实战\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3365149/202602/3365149-20260219125729266-340455730.png\" />\n        以电商订单实时数仓为例，演示如何在 Flink SQL 中通过维表时态 Join 将事实流与维度数据关联，构建带用户属性的明细宽表，并结合 Kafka 与 MySQL 环境完成一套可落地的实时数仓入门实践。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在前一篇 <a href=\"https://mp.weixin.qq.com/s/kLxoo6mHi49HvrrmaOdTsA\" rel=\"noopener nofollow\" target=\"_blank\">《Flink 双流 JOIN 实战详解》</a> 中，我们用「订单流 + 支付流」搞懂了事实双流之间的时间关联。</p>\n<p>但在真实的实时数仓项目里，光有事实流还不够，业务同学更关心的是：</p>\n<ul>\n<li>下单用户是新客还是老客</li>\n<li>用户当前的等级、城市、渠道</li>\n<li>商品所属品类、类目层级</li>\n</ul>\n<p>这些信息通常存放在 <strong>维度表</strong>（维表）中，例如 MySQL 的 <code>dim_user</code>、<code>dim_product</code> 等。我们希望在实时计算时，能把「事实流」和「维表」在时间维度上正确地关联起来，构建一张带有完整业务属性的<strong>明细宽表</strong>。</p>\n<p>这就是 <strong>维表时态 Join（Temporal Table Join）</strong> 要解决的问题。</p>\n<p>本文我们就以「订单事实流 + 用户维表」为例，完成一个从 Kafka 到 MySQL 的简易实时数仓 Demo，并重点理解 Flink SQL 中维表时态 Join 的语法和注意事项。</p>\n<h2 id=\"一业务场景与数仓目标\">一、业务场景与数仓目标</h2>\n<p>设想一个简化的电商业务场景：</p>\n<ul>\n<li>Kafka 中有实时写入的 <code>orders</code> 订单事实流</li>\n<li>MySQL 中维护一张 <code>dim_user</code> 用户维表，包含用户等级、所属城市、注册渠道等信息</li>\n</ul>\n<p>我们想要在 Flink 中构建一张「<strong>订单明细宽表</strong>」，字段大致包括：</p>\n<ul>\n<li>订单信息：订单号、下单用户、下单金额、下单时间</li>\n<li>用户属性：用户昵称、等级、城市、注册渠道</li>\n</ul>\n<p>并且要求：</p>\n<ul>\n<li>当我们回看 10 分钟前的某条订单时，看到的是 <strong>当时</strong> 用户的等级和城市，而不是被后续变更“冲掉”的最新值</li>\n</ul>\n<p>这正是 <strong>时态 Join</strong> 和「实时数仓」的关键：<strong>按事件发生时刻回放维度视图</strong>。</p>\n<h2 id=\"二环境前提与依赖准备\">二、环境前提与依赖准备</h2>\n<h3 id=\"1-基础组件\">1. 基础组件</h3>\n<p>本篇默认你已经完成前几篇中的环境准备：</p>\n<ul>\n<li>Flink 1.20.1（WSL2 Ubuntu 下部署）</li>\n<li>Kafka 集群已启动，且能正常写入 / 读取 Topic</li>\n<li>Flink SQL Client 可以正常连接集群</li>\n</ul>\n<p>在此基础上，我们还需要：</p>\n<ul>\n<li>一套可访问的 MySQL（本地或远程均可）</li>\n<li>Flink 的 JDBC Connector JAR 包</li>\n</ul>\n<h3 id=\"2-安装-flink-jdbc-connector\">2. 安装 Flink JDBC Connector</h3>\n<p>和 Kafka 一样，JDBC 连接器也需要以 JAR 包形式放到 Flink 的 <code>lib</code> 目录中。</p>\n<p>以 Flink 1.20.x 对应的 <code>flink-connector-jdbc</code> 为例：</p>\n<ol>\n<li>\n<p>确认 Flink 安装目录（假设为 <code>/opt/flink</code>）：</p>\n<pre><code class=\"language-bash\">export FLINK_HOME=/opt/flink\n</code></pre>\n</li>\n<li>\n<p>下载 JDBC Connector JAR 到 Flink 的 <code>lib</code> 目录：</p>\n<pre><code class=\"language-bash\">cd $FLINK_HOME/lib\nwget https://repo1.maven.org/maven2/org/apache/flink/flink-connector-jdbc/3.3.0-1.20/flink-connector-jdbc-3.3.0-1.20.jar\n</code></pre>\n</li>\n<li>\n<p>如果你使用的是独立集群或远程集群，需要重启 Flink 集群，让新 JAR 在 JobManager/TaskManager 上生效：</p>\n<pre><code class=\"language-bash\">cd $FLINK_HOME\nbin/stop-cluster.sh\nbin/start-cluster.sh\n</code></pre>\n</li>\n<li>\n<p>重启 Flink SQL Client，使用新 Connector：</p>\n<pre><code class=\"language-bash\">cd $FLINK_HOME\nbin/sql-client.sh\n</code></pre>\n</li>\n</ol>\n<p>如果你在 Windows + WSL2 上部署，只需在 WSL2 内执行上述命令即可；或者手动下载 JAR 后拷贝到 <code>lib</code> 目录，步骤完全一致。</p>\n<h2 id=\"三准备-mysql-用户维度表-dim_user\">三、准备 MySQL 用户维度表 dim_user</h2>\n<p>首先在 MySQL 中准备一张简单的用户维度表，用来存用户的基础属性。</p>\n<p>在 MySQL 中执行：</p>\n<pre><code class=\"language-sql\">CREATE DATABASE IF NOT EXISTS realtime_dwh;\nUSE realtime_dwh;\n\nCREATE TABLE dim_user (\n  user_id      VARCHAR(32)  PRIMARY KEY,\n  user_name    VARCHAR(64),\n  user_level   VARCHAR(16),\n  city         VARCHAR(64),\n  register_time DATETIME\n);\n\nINSERT INTO dim_user (user_id, user_name, user_level, city, register_time) VALUES\n('u_1', '张三', 'VIP1', '北京', '2025-12-01 10:00:00'),\n('u_2', '李四', 'VIP2', '上海', '2025-12-05 11:00:00'),\n('u_3', '王五', 'VIP1', '广州', '2025-12-10 12:00:00');\n</code></pre>\n<p>为了演示「时态」效果，你可以在后续实验中手动更新某个用户的等级或城市，例如：</p>\n<pre><code class=\"language-sql\">UPDATE dim_user\nSET user_level = 'VIP3'\nWHERE user_id = 'u_2';\n</code></pre>\n<p>这样我们在 Flink 里做时态 Join 时，就能观察“变更前后”的区别。</p>\n<h2 id=\"四在-flink-中注册事实流与维表\">四、在 Flink 中注册事实流与维表</h2>\n<p>接下来回到 Flink SQL Client，把 Kafka 中的订单事实流和 MySQL 中的维表都注册成 Flink 表。</p>\n<h3 id=\"1-kafka-订单事实表-orders\">1. Kafka 订单事实表 orders</h3>\n<p>和上一篇双流 JOIN 类似，我们假设 Kafka 中有一个 <code>orders</code> Topic，写入订单事实数据。</p>\n<p>在 Flink SQL Client 中执行：</p>\n<pre><code class=\"language-sql\">CREATE TABLE orders (\n  order_id     STRING,\n  user_id      STRING,\n  order_amount DECIMAL(10, 2),\n  order_time   TIMESTAMP_LTZ(3),\n  WATERMARK FOR order_time AS order_time - INTERVAL '5' SECOND,\n  proc_time AS PROCTIME()\n) WITH (\n  'connector' = 'kafka',\n  'topic' = 'orders',\n  'properties.bootstrap.servers' = '127.0.0.1:9092',\n  'properties.group.id' = 'flink-orders-dim',\n  'scan.startup.mode' = 'earliest-offset',\n  'format' = 'json',\n  'json.timestamp-format.standard' = 'ISO-8601'\n);\n</code></pre>\n<p>你可以沿用上一篇中 Kafka 造数的方式，用 <code>kafka-console-producer.sh</code> 发送 JSON 订单数据，只需要保证字段名一致。</p>\n<h3 id=\"2-mysql-用户维表-dim_userjdbc-lookup-表\">2. MySQL 用户维表 dim_user（JDBC Lookup 表）</h3>\n<p>然后把刚才在 MySQL 中建好的 <code>dim_user</code> 注册为 Flink 的 JDBC 表：</p>\n<pre><code class=\"language-sql\">CREATE TABLE dim_user (\n  user_id       STRING,\n  user_name     STRING,\n  user_level    STRING,\n  city          STRING,\n  register_time TIMESTAMP(3),\n  PRIMARY KEY (user_id) NOT ENFORCED\n) WITH (\n  'connector' = 'jdbc',\n  'url' = 'jdbc:mysql://127.0.0.1:3306/realtime_dwh',\n  'table-name' = 'dim_user',\n  'driver' = 'com.mysql.cj.jdbc.Driver',\n  'username' = 'root',\n  'password' = '1qaz@WSX'\n);\n</code></pre>\n<p>注意几点：</p>\n<ul>\n<li><code>PRIMARY KEY (user_id) NOT ENFORCED</code> 告诉 Flink 这是一张以 <code>user_id</code> 为主键的表，是做时态 Join 的前提</li>\n<li>这里使用的是典型的 JDBC Lookup 模式，Flink 会在 Join 时按需去 MySQL 查维度信息</li>\n</ul>\n<p>在生产环境中，你可以把 MySQL 作为维度存储，或者通过 CDC 把维表变更同步到 Kafka，构造成 changelog 流，这些都可以和 Temporal Join 结合使用。</p>\n<h2 id=\"五维表时态-join把订单打上用户维度\">五、维表时态 Join：把订单打上用户维度</h2>\n<p>有了订单事实表 <code>orders</code> 和维度表 <code>dim_user</code>，就可以通过时态 Join 来构建订单明细宽表。</p>\n<h3 id=\"1-基础时态-join-语法\">1. 基础时态 Join 语法</h3>\n<p>Flink SQL 中的 Temporal Table Join 对于 JDBC 这类 <strong>外部维表</strong>，通常采用「处理时间（Processing Time）」语义来做 Lookup Join，典型写法如下：</p>\n<pre><code class=\"language-sql\">SELECT\n  o.order_id,\n  o.user_id,\n  d.user_name,\n  d.user_level,\n  d.city,\n  o.order_amount,\n  o.order_time\nFROM orders AS o\nLEFT JOIN dim_user FOR SYSTEM_TIME AS OF o.proc_time AS d\nON o.user_id = d.user_id;\n</code></pre>\n<p><img alt=\"FlinkJoin\" class=\"lazyload\" /><br />\n这里有几个关键点：</p>\n<ul>\n<li><code>proc_time AS PROCTIME()</code> 是在 <code>orders</code> 上定义的处理时间字段</li>\n<li><code>FOR SYSTEM_TIME AS OF o.proc_time</code> 表示“以 Flink 处理这条订单记录的当前时间，去查维表的一个快照”，这是 JDBC Lookup 支持的典型用法</li>\n<li>Join 条件依然是 <code>user_id</code> 等值关联</li>\n<li>使用 <code>LEFT JOIN</code> 可以保留找不到维度的订单，并用空值来表示“维度缺失”</li>\n</ul>\n<p>在 SQL Client 中执行这段查询，会看到实时流式刷新的结果，每一行订单都带上了对应的用户属性。</p>\n<h3 id=\"2-验证时态效果修改维表再观察-join\">2. 验证时态效果：修改维表再观察 Join</h3>\n<p>为了验证这是“时态 Join”而不是“始终查最新维度”，可以按下面步骤操作：</p>\n<ol>\n<li>\n<p>先往 Kafka 的 <code>orders</code> Topic 写入几条订单数据，例如用户 <code>u_2</code> 下单的记录</p>\n</li>\n<li>\n<p>观察 Flink SQL 中 Join 后的结果，此时 <code>u_2</code> 的等级是 <code>VIP2</code></p>\n</li>\n<li>\n<p>回到 MySQL，执行：</p>\n<pre><code class=\"language-sql\">UPDATE dim_user\nSET user_level = 'VIP3'\nWHERE user_id = 'u_2';\n</code></pre>\n</li>\n<li>\n<p>再写入一批新的订单，仍然是用户 <code>u_2</code></p>\n</li>\n</ol>\n<pre><code class=\"language-bash\">bin/kafka-console-producer.sh --bootstrap-server 127.0.0.1:9092 --topic orders\n</code></pre>\n<p>在命令行中输入一条 JSON 数据（按回车发送一条）：</p>\n<pre><code class=\"language-json\">{\"order_id\":\"o_3\",\"user_id\":\"u_2\",\"order_amount\":200.00,\"order_time\":\"2026-02-19T14:42:00Z\"}\n</code></pre>\n<p><img alt=\"FlinkJoin\" class=\"lazyload\" /><br />\n这时你会看到：</p>\n<ul>\n<li>变更前的订单，维度字段仍然显示 <code>VIP2</code></li>\n<li>变更后的订单，维度字段变成了 <code>VIP3</code></li>\n</ul>\n<p>这就说明 Flink 的时态 Join 确实是“按订单发生时刻去回放维度视图”的，而不是简单查当前最新值。</p>\n<h2 id=\"六把结果写回-kafka-或-mysql形成实时数仓明细层\">六、把结果写回 Kafka 或 MySQL，形成实时数仓明细层</h2>\n<p>在真实项目中，我们不会只在 SQL Client 里 <code>SELECT</code> 一下就结束，而是要把 Join 后的订单明细宽表，写回到下游存储，形成实时数仓的一个层级。</p>\n<p>例如，可以把结果写回 Kafka，作为 DWD 层的订单宽表：</p>\n<pre><code class=\"language-sql\">CREATE TABLE dwd_order_user_wide (\n  order_id     STRING,\n  user_id      STRING,\n  user_name    STRING,\n  user_level   STRING,\n  city         STRING,\n  order_amount DECIMAL(10, 2),\n  order_time   TIMESTAMP_LTZ(3),\n  WATERMARK FOR order_time AS order_time - INTERVAL '5' SECOND\n) WITH (\n  'connector' = 'kafka',\n  'topic' = 'dwd_order_user_wide',\n  'properties.bootstrap.servers' = '127.0.0.1:9092',\n  'properties.group.id' = 'flink-dwd-order-wide',\n  'scan.startup.mode' = 'earliest-offset',\n  'format' = 'json',\n  'json.timestamp-format.standard' = 'ISO-8601'\n);\n\nINSERT INTO dwd_order_user_wide\nSELECT\n  o.order_id,\n  o.user_id,\n  d.user_name,\n  d.user_level,\n  d.city,\n  o.order_amount,\n  o.order_time\nFROM orders AS o\nLEFT JOIN dim_user FOR SYSTEM_TIME AS OF o.proc_time AS d\nON o.user_id = d.user_id;\n</code></pre>\n<p>这样，下游的实时应用或 BI 查询就可以直接订阅 <code>dwd_order_user_wide</code> 这个 Topic，拿到已经打好用户标签的订单明细数据。</p>\n<p>你也可以把结果同步到 MySQL、ClickHouse 等分析型数据库中，构建实时明细表，为报表和可视化提供数据。</p>\n<h2 id=\"七小结与下一步建议\">七、小结与下一步建议</h2>\n<p>通过这篇文章，我们完成了这样一件事：</p>\n<ul>\n<li>在 Kafka 中维护订单事实流 <code>orders</code></li>\n<li>在 MySQL 中维护用户维度表 <code>dim_user</code></li>\n<li>使用 Flink SQL 的 JDBC Connector 把 MySQL 注册为维表</li>\n<li>利用 <code>FOR SYSTEM_TIME AS OF</code> 语法做维表时态 Join</li>\n<li>将 Join 结果写回 Kafka，形成实时数仓中的一张订单明细宽表</li>\n</ul>\n<p>这背后有几个非常重要的实时数仓设计理念：</p>\n<ul>\n<li>事实流是不断追加的事件序列，维表是相对缓慢变更的业务视图</li>\n<li>时态 Join 让你能够“按事件发生的时间点”，回看当时的维度快照</li>\n<li>实时数仓的 DWD 层，往往就是「事实表 + 多个维表时态 Join」后形成的明细宽表</li>\n</ul>\n<p>在后续的文章中，我们可以继续沿着这个方向深入：</p>\n<ul>\n<li>在一个任务里同时关联多张维表，构建更宽的明细表</li>\n<li>引入 CDC，把维表变更实时同步到 Kafka，再在 Flink 中构建 changelog 维表</li>\n<li>把实时数仓的明细层、汇总层（DWS）、指标主题层（ADS）串起来，做一个端到端的实时数仓小项目</li>\n</ul>\n<p>如果你已经跑通了本文的 Demo，不妨试着自己设计一张商品维表 <code>dim_product</code>，再给订单打上商品品类维度，体验一下“事实 + 多维表时态 Join”在 Flink SQL 里的完整味道。</p>\n<hr />\n<p><a href=\"http://blog.daimajiangxin.com.cn\" rel=\"noopener nofollow\" target=\"_blank\">原文来自:http://blog.daimajiangxin.com.cn</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-19 12:58</span>&nbsp;\n<a href=\"https://www.cnblogs.com/daimajiangxin\">代码匠心</a>&nbsp;\n阅读(<span id=\"post_view_count\">70</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "赋予 AI Agent “无限续航”：语义保护型上下文压缩技术解析",
      "link": "https://www.cnblogs.com/noear/p/19624614",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/noear/p/19624614\" id=\"cb_post_title_url\" title=\"发布于 2026-02-19 12:21\">\n    <span>赋予 AI Agent “无限续航”：语义保护型上下文压缩技术解析</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        Solon AI框架的SummarizationInterceptor创新性地解决了AI长对话中的\"上下文窗口爆炸\"问题。这套智能记忆管理系统通过四步策略：锁定核心任务指令、确保行动-结果完整性、保持语义连贯性、添加系统提示，实现了优雅的记忆压缩。其采用插件式设计，支持层级压缩、关键信息提取和向量库归档等策略组合，让AI既能记住核心目标，又能处理超长任务。这种\"有逻辑地遗忘\"机制，有效避免了传统粗暴裁剪导致的逻辑混乱，为AI处理复杂任务提供了\"无限续航\"\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>想象一下，你正在指挥一个超级聪明的AI助手（我们称之为Agent）帮你完成一项复杂任务，比如策划一次跨国旅行。一开始，它记得你的所有要求：想去哪些国家、预算多少、喜欢什么类型的酒店。但随着任务的进行，它需要查询航班、比较酒店、查看天气……每一次查询和思考都会增加它的“记忆负担”。</p>\n<p>如果它“记性”不好，聊到一半就会忘了最开始的要求，或者陷入混乱的逻辑中，这就是开发者常说的“上下文窗口爆炸”问题。</p>\n<p>Solon AI 框架里有一个秘密武器——<code>SummarizationInterceptor</code>（智能记忆压缩器），它能让AI助手像人一样，<strong>既不会忘记初心，又能轻装上阵，实现真正的“无限续航”</strong>。它不是简单粗暴地“断片”，而是一套优雅的“记忆管理大师”。</p>\n<h3 id=\"1为什么不能简单粗暴地断片\">1、为什么不能简单粗暴地“断片”？</h3>\n<p>处理长对话，最直接的想法是：对话太长？那就删掉前面一半吧！但这种“暴力裁剪”对AI来说，会带来两个致命伤：</p>\n<ul>\n<li><strong>忘本（失去初心）：</strong> AI Agent 最开头的系统设定和你交给它的第一个任务，如果被删掉，它就会像无头苍蝇一样，完全不知道自己要干嘛了。</li>\n<li><strong>断片（逻辑断层）：</strong> AI Agent 的工作模式通常是“思考 -&gt; 行动 -&gt; 观察结果”（ReAct）。如果你恰好把它的某个“行动”和对应的“观察结果”给拆散了，它看到结果却不知道为什么会有这个结果，逻辑瞬间混乱，甚至陷入死循环，无法自拔。</li>\n</ul>\n<p>所以，忘记也是一门艺术，需要有策略地忘记。</p>\n<h3 id=\"2智能记忆压缩器是如何工作的\">2、智能记忆压缩器是如何工作的？</h3>\n<p><code>SummarizationInterceptor</code> 就像一个聪明的图书管理员，它不会随意丢弃书籍，而是按照一套精密的流程来整理书架。它的工作分为四步：</p>\n<h4 id=\"第一步锁死初心锚点锁定\">第一步：锁死“初心”（锚点锁定）</h4>\n<p>无论后面的对话有多长，管理员都会第一时间找到两样东西并永久保留：</p>\n<ul>\n<li><strong>任务指令：</strong> 你第一次给AI布置的任务（UserMessage），这是它的“初心”。</li>\n<li><strong>基本守则：</strong> AI的系统设定（SystemMessage），这是它的“行为准则”。</li>\n</ul>\n<p>这两样东西被牢牢锁定，确保AI永不迷失方向。</p>\n<h4 id=\"第二步禁止断片原子对齐\">第二步：禁止“断片”（原子对齐）</h4>\n<p>这是整个机制最核心的“黑科技”。当管理员决定要清理一部分旧内容时，他不会直接动手。他会仔细检查，确保永远不会把 <strong>“行动”</strong> 和 <strong>“结果”</strong> 这对“连体婴儿”给拆散。</p>\n<ul>\n<li><strong>智能检查：</strong> 如果发现准备清理的起点正好落在一个“观察结果”（<code>ToolMessage</code>）或者一个“行动指令”（<code>AssistantMessage</code>）上，管理员会立刻把清理起点向后挪，直到确保每一对“行动-结果”都完整地保留下来。</li>\n</ul>\n<h4 id=\"第三步让记忆更连贯语义补齐\">第三步：让记忆更连贯（语义补齐）</h4>\n<p>为了让你和AI的对话读起来更通顺，管理员还会再多做一步“人情味”的检查。如果清理后的第一条记录是一个“行动结果”，管理员会看看它前面是不是紧跟着一条AI的“思考过程”（Thought）。如果是，他会把这条“思考”也一并留下。这样一来，AI看到的历史永远是从一个思考片段开始的，理解起来更自然。</p>\n<h4 id=\"第四步贴个便利贴提醒断裂感知\">第四步：贴个“便利贴”提醒（断裂感知）</h4>\n<p>在永久保存的“初心”和压缩后的“最近记忆”之间，管理员会贴上一张醒目的 <strong>“小贴士”</strong>：</p>\n<pre><code>--- [系统提示：中间部分历史对话已优化压缩，请根据当前计划和剩余历史继续任务...] ---\n</code></pre>\n<p>这张“小贴士”非常重要，它用AI能理解的语言告诉它：“别担心，中间有些细节我帮你精简了，你专注眼前的任务和核心目标就好。”这能有效防止AI因为记忆断层而产生困惑和幻觉。</p>\n<h3 id=\"3如何实现无限续航\">3、如何实现“无限续航”？</h3>\n<p>通过这套“记忆管理术”，SummarizationInterceptor 把AI的内存变成了一个动态的“新陈代谢系统”：</p>\n<ul>\n<li><strong>内存恒定：</strong> 无论AI运行了10步还是1000步，它一次“思考”所需要处理的信息量（Token数）始终维持在一个安全的范围内。</li>\n<li><strong>逻辑清晰：</strong> 因为“原子对齐”机制，AI看到的每一段记忆都是完整的“思考-行动-反馈”闭环，逻辑链条非常稳固。</li>\n<li><strong>目标永存：</strong> “系统设定”和“用户任务”这两大核心目标永远在线，AI永远不会忘记“我是谁”和“我要去哪”。</li>\n</ul>\n<h3 id=\"4更强大的组合插件式的记忆策略\">4、更强大的组合：插件式的记忆策略</h3>\n<p>这个“记忆管理器”最妙的地方在于，它采用了 <strong>策略模式</strong>，就像手机可以安装不同的APP来扩展功能一样，你可以给它接入不同的“记忆处理插件”。框架已经为我们准备了几款强大的插件：</p>\n<ul>\n<li><strong>层级压缩器：</strong> 它会像滚雪球一样，把旧的记忆摘要和新的对话历史不断融合、压缩，生成一个始终更新的“全局进度摘要”，让记忆像洋葱一样层层包裹，永不丢失核心。</li>\n<li><strong>关键信息提取器：</strong> 它像一个信息审计员，只从对话中提取最核心的“干货”，比如用户要求、获取到的数据、已经失败的尝试等，过滤掉那些啰嗦的思考过程。</li>\n<li><strong>向量库记忆师：</strong> 它会将被清理的详细对话“归档”到一个巨大的知识库里（向量数据库）。当AI需要回忆某个细节时，可以通过一个专门的“召回历史”工具，像用搜索引擎一样把它找回来。</li>\n</ul>\n<p>你可以把这些插件组合起来使用，比如先归档，再提纯，最后压缩，打造一个最适合你AI助手的记忆管理方案。</p>\n<p>应用示例：</p>\n<pre><code class=\"language-java\">import org.noear.solon.ai.agent.react.ReActAgent;\nimport org.noear.solon.ai.agent.react.intercept.SummarizationInterceptor;\nimport org.noear.solon.ai.agent.react.intercept.summarize.*;\nimport org.noear.solon.ai.agent.session.InMemoryAgentSession;\nimport org.noear.solon.ai.chat.ChatModel;\n\nCompositeSummarizationStrategy compositeStrategy = new CompositeSummarizationStrategy();\ncompositeStrategy.addStrategy(new KeyInfoExtractionStrategy(chatModel));\ncompositeStrategy.addStrategy(new HierarchicalSummarizationStrategy(chatModel));\nSummarizationInterceptor summarizationInterceptor = new SummarizationInterceptor(12, compositeStrategy);\n\nReActAgent agent = ReActAgent.of(chatModel)\n        .defaultInterceptorAdd(summarizationInterceptor)\n        .build();\n</code></pre>\n<h3 id=\"5总结\">5、总结</h3>\n<p><code>SummarizationInterceptor</code> 的设计哲学是：<strong>有尊严地裁剪，有逻辑地遗忘</strong>。</p>\n<p>它不仅仅是一个节省计算资源的工具，更是AI能够保持逻辑连贯、处理超长复杂任务的“护航者”。有了它，开发者可以放心地让AI助手去处理那些需要几个小时甚至几天才能完成的、真正复杂和智能化的工作，而不用担心它会中途“失忆”或“精神错乱”。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-19 12:21</span>&nbsp;\n<a href=\"https://www.cnblogs.com/noear\">带刺的坐椅</a>&nbsp;\n阅读(<span id=\"post_view_count\">68</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "凸优化数学基础笔记（四）：Hessian 矩阵及 Taylor 展开",
      "link": "https://www.cnblogs.com/GeophysicsWorker/p/19624189",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/GeophysicsWorker/p/19624189\" id=\"cb_post_title_url\" title=\"发布于 2026-02-19 09:48\">\n    <span>凸优化数学基础笔记（四）：Hessian 矩阵及 Taylor 展开</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        上一节说过，梯度 $\\nabla f(\\mathbf{X})$ 是$f(\\mathbf{X})$ 关于$\\mathbf{X}$ 的一阶导数，现在一个问题$f(\\mathbf{X})$ 关于 $\\mathbf{X}$ 的二阶导数是什么？Hessian 矩阵（海森矩阵）是一个多变量实值函数$f(\\mathbf{X})$的二阶导数构成得方阵，其几何意义是描述了一个多元函数或场函数的局部曲率。在机器学习、优化问题和物理反演问题中，Hessian矩阵扮演着重要的角色，尤其是在寻找函数的极值点（如损失函数或目标函数的最小值）和分析系统的稳定性。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"1hessian矩阵定义及性质\">1.Hessian矩阵定义及性质</h2>\n<p>​\t在上一节说过，梯度 <span class=\"math inline\">\\(\\nabla f(\\mathbf{X})\\)</span> 是<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 关于<span class=\"math inline\">\\(\\mathbf{X}\\)</span> 的一阶导数，现在一个问题<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 关于 <span class=\"math inline\">\\(\\mathbf{X}\\)</span> 的二阶导数是什么？Hessian 矩阵（海森矩阵）是一个多变量实值函数<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span>的二阶导数构成得方阵，其几何意义是描述了一个多元函数或场函数的局部曲率。在机器学习、优化问题和物理反演问题中，Hessian矩阵扮演着重要的角色，尤其是在寻找函数的极值点（如损失函数或目标函数的最小值）和分析系统的稳定性。下面是关于Hessian矩阵的详细介绍：</p>\n<p>​\t<strong>Definition 4.1.1</strong>  设<span class=\"math inline\">\\(f:\\mathbb{R}^n\\rightarrow{\\mathbb{R}}\\)</span> , <span class=\"math inline\">\\(\\mathbf{X}\\in{R}^n\\)</span> ,如果<span class=\"math inline\">\\(f\\)</span>在点<span class=\"math inline\">\\(\\mathbf{X}_0\\)</span> 处对于自变量<span class=\"math inline\">\\(\\mathbf{X}\\)</span> 的各个分量<span class=\"math inline\">\\(x_i,x_j\\)</span> 的二阶偏导</p>\n<p></p><div class=\"math display\">\\[\\frac{\\part{f(\\mathbf{X}_0)}}{\\part{x_i}\\part{x_j}} \t\t\\hspace{2em} (i,j=1,2,...,n)\n\\]</div><p></p><p>都存在，则称函数<span class=\"math inline\">\\(f\\)</span> 在点<span class=\"math inline\">\\(\\mathbf{X}_0\\)</span> 处二阶可导，并且称矩阵：</p>\n<p></p><div class=\"math display\">\\[\\nabla^2f(\\mathbf{X}_0)=\\left(\\begin{matrix}\\frac{\\part^2f(\\mathbf{X}_0)}{\\part{x_1^2}},&amp;\\frac{\\part^2f(\\mathbf{X}_0)}{\\part{x_1}\\part{x_2}},&amp;\\cdots,&amp;\\frac{\\part^2f(\\mathbf{X}_0)}{\\part{x_1}\\part{x_n}}\\\\ \n\\frac{\\part^2f(\\mathbf{X}_0)}{\\part{x_1}\\part{x_2}},&amp;\\frac{\\part^2f(\\mathbf{X}_0)}{\\part{x_2^2}},&amp;\\cdots,&amp;\\frac{\\part^2f(\\mathbf{X}_0)}{\\part{x_2}\\part{x_n}}\\\\\n\\cdots &amp;\\cdots &amp;\\cdots &amp;\\cdots \\\\\n\\frac{\\part^2f(\\mathbf{X}_0)}{\\part{x_n}\\part{x_1}},&amp;\\frac{\\part^2f(\\mathbf{X}_0)}{\\part{x_n}\\part{x_2}},&amp;\\cdots,&amp;\\frac{\\part^2f(\\mathbf{X}_0)}{\\part{x_n}^2}\n\\end{matrix}\\right)\n\\tag{2}\n\\]</div><p></p><p>是<span class=\"math inline\">\\(f\\)</span>在点<span class=\"math inline\">\\(\\mathbf{X}_0\\)</span> 处的<strong>Hessian矩阵</strong>，记为<span class=\"math inline\">\\(\\mathbf{H}_{ij}=\\frac{\\part^2{f}}{\\part{x_i}\\part{x_j}}\\)</span>。</p>\n<p>​\t在数学分析中已经知道，当<span class=\"math inline\">\\(f\\)</span> 在点<span class=\"math inline\">\\(\\mathbf{X}_0\\)</span> 处的所有二阶偏导数为连续时有：</p>\n<p></p><div class=\"math display\">\\[\\frac{\\part^2f(\\mathbf{X}_0)}{\\part{x_i}\\part{x_j}}=\\frac{\\part^2{f(\\mathbf{X}_0)}}{\\part{x_j}\\part{x_i}} \\tag{3}\n\\]</div><p></p><p>因此，在这种情况下Hessian矩阵是<strong>对称矩阵</strong>。</p>\n<p><strong>推论 1</strong> 设<span class=\"math inline\">\\(\\mathbf{a}\\in{\\mathbf{R}^n},\\mathbf{X}\\in{\\mathbf{R}^n},b\\in{R}\\)</span>，求线性函数：</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X})=\\mathbf{a}^T\\mathbf{X}+b\\tag{4}\n\\]</div><p></p><p>在任意点<span class=\"math inline\">\\(\\mathbf{X}\\)</span> 处的梯度向量和Hessian矩阵：</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\n&amp;\\nabla{f(\\mathbf{X})}=\\mathbf{a}\\\\\n&amp;\\nabla^2{f(\\mathbf{X})}=\\mathbf{0}\n\\end{aligned}\n\\tag{5}\n\\]</div><p></p><p><strong>证  明：</strong> 设<span class=\"math inline\">\\(\\mathbf{a}=[a_1,a_2,\\cdots,a_n]^{T},\\mathbf{X}=[x_1,x_2,\\cdots,x_n]^{T}\\)</span> 则：</p>\n<p></p><div class=\"math display\">\\[f(x_1,x_2,\\cdots,x_n)=\\sum^{n}_{i=1}a_ix_i+b \\tag{6}\n\\]</div><p></p><p>根据梯度向量<span class=\"math inline\">\\(\\nabla{f}\\)</span>的定义：</p>\n<p></p><div class=\"math display\">\\[\\nabla{f(\\mathbf{X})}=\\frac{\\part{f}}{\\part{x_i}}=a_i \\hspace{2em} (i=1,2,\\cdots,n) \\tag{7}\n\\]</div><p></p><p>由式（7）可知，</p>\n<p></p><div class=\"math display\">\\[\\nabla{f(\\mathbf{X})}=[a_1,a_2,\\cdots,a_n]^T=\\mathbf{a} \\tag{8}\n\\]</div><p></p><p>根据式（2）的<span class=\"math inline\">\\(Hessian\\)</span>矩阵的定义：</p>\n<p></p><div class=\"math display\">\\[\\frac{\\part^2{f}}{\\part{x_i}\\part{x_j}}=0, \\hspace{2em} i,j=1,2,\\cdots,n \\tag{9}\n\\]</div><p></p><p>所以：</p>\n<p></p><div class=\"math display\">\\[\\nabla^2{f(\\mathbf{X})}=\\mathbf{0} \\tag{10}\n\\]</div><p></p><p><strong>推论  2</strong>  设<span class=\"math inline\">\\(\\mathbf{A}\\in{R^{n\\times{n}}}\\)</span> 是对称实方阵，<span class=\"math inline\">\\(\\mathbf{b}\\in{\\mathbf{R}^n},c\\in\\mathbf{R}^1\\)</span> ,其二次函数<span class=\"math inline\">\\(f(\\mathbf{X})=\\frac{1}{2}\\mathbf{X}^T\\mathbf{A}\\mathbf{X}+\\mathbf{b}^T\\mathbf{X}+c\\)</span> ,在任意点处的梯度向量<span class=\"math inline\">\\(\\nabla{f(\\mathbf{X})}\\)</span> 及Hessian矩阵 <span class=\"math inline\">\\(\\nabla^2f(\\mathbf{X})\\)</span> 为如下形式：</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\n&amp;\\nabla{f}=\\mathbf{AX+b} \\\\\n&amp;\\nabla^2{f}=\\mathbf{A}\n\\end{aligned}\n\\tag{11}\n\\]</div><p></p><p><strong>证 明：</strong> 设<span class=\"math inline\">\\(\\mathbf{A}=[a_{ij}]_{n\\times{n}}\\)</span> ,<span class=\"math inline\">\\(\\mathbf{X}=[x_1,x_2,...,x_n]^T\\)</span>, <span class=\"math inline\">\\(\\mathbf{b}=[b_1,b_2,...,b_n]^T\\)</span> ,二次函数<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 可以写成如下形式：</p>\n<p></p><div class=\"math display\">\\[f(x_1,x_2,\\cdots,x_n)=\\frac{1}{2}\\sum_{i=1}^{n}\\sum_{j=1}^{n}a_{ij}x_ix_j+\\sum_{i=1}^{n}b_ix_i+c \\tag{12}\n\\]</div><p></p><p>将它对各个变量 <span class=\"math inline\">\\(x_i\\)</span> (<span class=\"math inline\">\\(i=1,\\cdots,n\\)</span>) 求偏导数，得到：</p>\n<p></p><div class=\"math display\">\\[\\nabla{f(\\mathbf{X})}=\\left( \\begin{matrix} \\sum_{j=1}^n a_{1j}x_j+b_1\\\\\n\\vdots \\\\\\sum_{j=1}^{n}a_{n_j}x_j+b_n \\end{matrix} \\right)= \\left(\\begin{matrix}\\sum_{j=1}^{n}a_{1j}x_j\\\\\\vdots\\\\\\sum_{j=1}^na_{nj}x_j\\end{matrix}\\right)+\\left(\\begin{matrix}b_1\\\\ \\vdots \\\\b_n\\end{matrix}\\right) \\tag{13}\n\\]</div><p></p><p>所以：</p>\n<p></p><div class=\"math display\">\\[\\nabla{f(\\mathbf{X})}=\\mathbf{AX+b} \\tag{14}\n\\]</div><p></p><p>再对它们的求偏导数是：</p>\n<p></p><div class=\"math display\">\\[ \\frac{\\part{f(\\mathbf{X})}}{\\part{x_i}\\part{x_j}}=a_{ij} \\tag{15}\n\\]</div><p></p><p>所以：</p>\n<p></p><div class=\"math display\">\\[\\nabla^2f(\\mathbf{X})=\\mathbf{A} \\tag{16}\n\\]</div><p></p><p>以上两个例子说明，<span class=\"math inline\">\\(n\\)</span>元函数求导与一元函数求导在形式上一致的，即线性函数的一阶导数的求导为常向量，其二阶导数为零矩阵；而二次函数的一阶导数为线性向量函数， 其二阶导数为常矩阵。</p>\n<p>​\t在此介绍在今后的计算中要用到的向量函数的导数。</p>\n<p>​\t<strong>Definition 4.1.2</strong> 设一个向量函数<span class=\"math inline\">\\(h:R^{n}\\rightarrow{R^m}，\\mathbf{X}_0\\in{R^n}\\)</span>，记<span class=\"math inline\">\\(h(\\mathbf{X})=\\{h_1(\\mathbf{X}),h_2(\\mathbf{X}),\\cdots,h_m(\\mathbf{X})\\}^T\\)</span>，如果<span class=\"math inline\">\\(h_i(i=1,2,\\cdots,m)\\)</span> 在点<span class=\"math inline\">\\(\\mathbf{X}_0\\)</span> 处对于自变量<span class=\"math inline\">\\(\\mathbf{X}=[x_1,x_2,x_3,\\cdots,x_n]^T\\)</span> 的各分量的偏导数<span class=\"math inline\">\\(\\frac{\\part{h_i(\\mathbf{X}_0)}}{\\part{x_j}}\\space(j=1,2,3,\\cdots,m)\\)</span> 都存在，则称向量函数<span class=\"math inline\">\\(h(\\mathbf{X})\\)</span> 在点<span class=\"math inline\">\\(\\mathbf{X}_0\\)</span> 处是一阶可导的，并且称矩阵：</p>\n<p></p><div class=\"math display\">\\[\\nabla_{m\\times{n}}h(\\mathbf{X}_0)=\\left[\\begin{matrix} \\frac{\\part{h_1(\\mathbf{X}_0)}}{\\part{x_1}} &amp;\\frac{\\part{h_1(\\mathbf{X}_0)}}{\\part{x_2}} &amp;\\cdots &amp;\\frac{\\part{h_1(\\mathbf{X}_0)}}{\\part{x_n}} \\\\ \\frac{\\part{h_2(\\mathbf{X}_0)}}{\\part{x_1}} &amp;\\frac{\\part{h_2(\\mathbf{X}_0)}}{\\part{x_2}} &amp;\\cdots &amp;\\frac{\\part{h_2(\\mathbf{X}_0)}}{\\part{x_n}}\\\\ \\cdots &amp;\\cdots &amp;\\cdots &amp;\\cdots \\\\ \\frac{\\part{h_m(\\mathbf{X}_0)}}{\\part{x_1}}   &amp;\\frac{\\part{h_2(\\mathbf{X}_0)}}{\\part{x_2}} &amp;\\cdots &amp;\\frac{\\part{h_2(\\mathbf{X}_0)}}{\\part{x_n}} \\end{matrix}\\right] \\tag{17}\n\\]</div><p></p><p>是<span class=\"math inline\">\\(h\\)</span>在点<span class=\"math inline\">\\(X_0\\)</span> 处的一阶导数或Jacobi 矩阵，简记为</p>\n<p></p><div class=\"math display\">\\[\\nabla{\\mathbf{h}(\\mathbf{X}_0)}=\\nabla_{m\\times{n}}\\mathbf{h}(\\mathbf{X}_0) \\tag{18}\n\\]</div><p></p><p>由于<span class=\"math inline\">\\(n\\)</span>元函数<span class=\"math inline\">\\(f:\\mathbf{R}^n\\rightarrow \\mathbf{R}^1\\)</span> 的梯度是向量函数:</p>\n<p></p><div class=\"math display\">\\[\\nabla{f(\\mathbf{X})}=\\left[\\frac{\\part{f(\\mathbf{X})}}{\\part{x_1}},...,\\frac{\\part{f(\\mathbf{X})}}{\\part{x_n}}\\right]^T \n\\tag{19}\n\\]</div><p></p><p>所以<span class=\"math inline\">\\(\\nabla f(\\mathbf{X})\\)</span> 的一阶导数或Jacobi 矩阵为：</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\n\\nabla_{n\\times{n}}\\nabla{f(\\mathbf{X})}&amp;=\\left[\\begin{matrix}\\frac{\\part}{\\part{x_1}}\\left(\\frac{\\part{f(\\mathbf{X})}}{\\part{x_1}}\\right) &amp;\\frac{\\part}{\\part{x_2}}\\left(\\frac{\\part{f(\\mathbf{X})}}{\\part{x_1}}\\right) &amp;\\cdots &amp;\\frac{\\part}{\\part{x_n}}\\left(\\frac{\\part{f(\\mathbf{X})}}{\\part{x_1}}\\right)\\\\\n\\frac{\\part}{\\part{x_1}}\\left(\\frac{\\part{f(\\mathbf{X})}}{\\part{x_2}}\\right) &amp;\\frac{\\part}{\\part{x_2}}\\left(\\frac{\\part{f(\\mathbf{X})}}{\\part{x_2}}\\right) &amp;\\cdots &amp;\\frac{\\part}{\\part{x_n}}\\left(\\frac{\\part{f(\\mathbf{X})}}{\\part{x_2}}\\right)\\\\\n\\cdots &amp;\\cdots &amp;\\cdots &amp;\\cdots \\\\\n\\frac{\\part}{\\part{x_1}}\\left(\\frac{\\part{f(\\mathbf{X})}}{\\part{x_n}}\\right) &amp;\\frac{\\part}{\\part{x_2}}\\left(\\frac{\\part{f(\\mathbf{X})}}{\\part{x_n}}\\right) &amp;\\cdots &amp;\\frac{\\part}{\\part{x_n}}\\left(\\frac{\\part{f(\\mathbf{X})}}{\\part{x_n}}\\right)\n\\end{matrix}\\right]\\\\\n&amp;=\\left[\\begin{matrix}\\frac{\\part^2{f(\\mathbf{X})}}{\\part{x_1^2}} &amp;\\frac{\\part^2{f(\\mathbf{X})}}{\\part{x_1x_2}} &amp;\\cdots &amp;\\frac{\\part^2{f(\\mathbf{X})}}{\\part{x_1x_n}}\\\\\n\\frac{\\part^2{f(\\mathbf{X})}}{\\part{x_1x_2}} &amp;\\frac{\\part^2{f(\\mathbf{X})}}{\\part{x_2^2}} &amp;\\cdots &amp;\\frac{\\part^2{f(\\mathbf{X})}}{\\part{x_2x_n}}\\\\\n\\cdots &amp;\\cdots &amp;\\cdots &amp;\\cdots\\\\\n\\frac{\\part^2{f(\\mathbf{X})}}{\\part{x_1x_n}} &amp;\\frac{\\part^2{f(\\mathbf{X})}}{\\part{x_2x_n}} &amp;\\cdots &amp;\\frac{\\part^2{f(\\mathbf{X})}}{\\part{x_n^2}}\n\\end{matrix}\\right]\\\\\n&amp;=\\nabla^2{f(\\mathbf{X})}\n\\end{aligned}\n\\tag{20}\n\\]</div><p></p><p>即：</p>\n<p></p><div class=\"math display\">\\[\\nabla_{n\\times{n}}\\nabla{f(\\mathbf{X})}=\\nabla^2f(\\mathbf{X}) \\tag{21}\n\\]</div><p></p><p>据此，从上式的得知，函数梯度的Jacobi的矩阵为此函数<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 的Hessian矩阵。</p>\n<p>下面给出常用Jacobi矩阵的几个公式和推论：</p>\n<ol>\n<li><span class=\"math inline\">\\(\\nabla{\\mathbf{c}_{n\\times1}}=\\mathbf{0}_{n\\times{n}}\\)</span> ，其中<span class=\"math inline\">\\(\\mathbf{c}\\)</span> 是分量全部为常量的<span class=\"math inline\">\\(n\\)</span>维向量，<span class=\"math inline\">\\(\\mathbf{0}\\)</span> 是<span class=\"math inline\">\\(n\\times{n}\\)</span> 阶零向量；</li>\n<li><span class=\"math inline\">\\(\\nabla{\\mathbf{X}}=\\mathbf{I}\\)</span>，其中<span class=\"math inline\">\\(\\mathbf{X}\\)</span> 是<span class=\"math inline\">\\(n\\)</span>维向量，<span class=\"math inline\">\\(I\\)</span> 为<span class=\"math inline\">\\(n\\times{n}\\)</span> 阶单位矩阵；</li>\n<li><span class=\"math inline\">\\(\\nabla{\\mathbf{AX}}=\\mathbf{A}^T\\)</span>，其中<span class=\"math inline\">\\(\\mathbf{A}\\)</span>是<span class=\"math inline\">\\(m\\times{n}\\)</span>阶矩阵；</li>\n<li>设 <span class=\"math inline\">\\(\\phi{(t)}=f(\\mathbf{X}_0+t\\mathbf{P})\\)</span>，其中<span class=\"math inline\">\\(f:\\mathbf{R}^n\\rightarrow\\mathbf{R}^{1}\\)</span>, <span class=\"math inline\">\\(\\phi:\\mathbf{R}\\rightarrow\\mathbf{R}\\)</span>，则<span class=\"math inline\">\\(\\phi^{\\prime}(t)=\\nabla f(\\mathbf{X}_0+t\\mathbf{P})^T\\mathbf{P}\\)</span>, <span class=\"math inline\">\\(\\phi^{\\prime\\prime}=\\mathbf{P}^T\\nabla^2{f(\\mathbf{X}_0+t\\mathbf{P})}\\mathbf{P}\\)</span></li>\n</ol>\n<h2 id=\"2多元函数的taylor展开\">2.多元函数的Taylor展开</h2>\n<p>​\t多元函数的Taylor展开式在最优化方法中是十分重要的，许多方法及其收敛方法的证明是从其出发，这里给出Taylor展开定理及其证明。Taylor展开近似可以有效地将复杂函数化为二次函数。</p>\n<p>​\t<strong>定 理 4.2.1</strong> 设<span class=\"math inline\">\\(f:\\mathbf{R}^{n}\\rightarrow\\mathbf{R}\\)</span> 具有二阶连续偏导数，则</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X}+\\mathbf{P})=f(\\mathbf{X})+\\nabla{f(\\mathbf{X})}^T\\mathbf{P}+\\frac{1}{2}\\mathbf{P}^T\\nabla^2f(\\overline{\\mathbf{X}})\\mathbf{P} \\tag{22}\n\\]</div><p></p><p>其中：<span class=\"math inline\">\\(\\overline{\\mathbf{X}}=\\mathbf{X}+\\theta\\mathbf{P}(\\theta\\in{(0,1)})\\)</span>。</p>\n<p><strong>证  明</strong>：设 <span class=\"math inline\">\\(\\psi(t)=f(\\mathbf{X}+t\\mathbf{P})\\)</span> 其中 <span class=\"math inline\">\\(t\\in[0,1]\\)</span>:</p>\n<p></p><div class=\"math display\">\\[\\psi(0)=f(\\mathbf{X}) ， \\psi(1)=f(\\mathbf{X}+\\mathbf{P}) \\tag{23}\n\\]</div><p></p><p>对<span class=\"math inline\">\\(\\psi(t)\\)</span> 按照一元函数在<span class=\"math inline\">\\(t=0\\)</span>点展开，得到下式：</p>\n<p></p><div class=\"math display\">\\[   \\psi(t)=\\psi(0)+\\psi^{\\prime}(0)t+\\frac{1}{2}\\psi^{\\prime\\prime}(\\theta t)t^2 \\tag{24}\n\\]</div><p></p><p>其中 <span class=\"math inline\">\\(\\theta\\in(0,1)\\)</span>。令<span class=\"math inline\">\\(t=1\\)</span>，于是</p>\n<p></p><div class=\"math display\">\\[\\psi(1)=\\psi(0)+\\psi^{\\prime}(0)+\\frac{1}{2}\\psi^{\\prime\\prime}(\\theta) \\tag{25}\n\\]</div><p></p><p>又因为上节中 <span class=\"math inline\">\\(\\psi^{\\prime}(\\theta)=\\nabla{f(\\mathbf{X})}^T\\mathbf{P},\\psi^{\\prime\\prime}(\\theta)=\\mathbf{P}^T\\nabla^2f(\\mathbf{X}+\\theta{\\mathbf{P}})\\mathbf{P}\\)</span> ，代入式（25）中得到：</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X}+\\mathbf{P})=f(\\mathbf{X})+\\nabla{f(\\mathbf{X})}^T\\mathbf{P}+\\frac{1}{2}\\mathbf{P}^T\\nabla^2f(\\mathbf{X}+\\theta\\mathbf{P})\\mathbf{P} \\tag{26}\n\\]</div><p></p><p>式（26）还可以写成：</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X}+\\mathbf{P})=f(\\mathbf{X})+\\nabla{f(\\mathbf{X})}^{T}\\mathbf{P}+\\frac{1}{2}\\mathbf{P}^T\\nabla^2f(\\mathbf{X})\\mathbf{P}+o(||\\mathbf{P}||^2) \\tag{27}\n\\]</div><p></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-19 09:48</span>&nbsp;\n<a href=\"https://www.cnblogs.com/GeophysicsWorker\">GeoFXR</a>&nbsp;\n阅读(<span id=\"post_view_count\">56</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}