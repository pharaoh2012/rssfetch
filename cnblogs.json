{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "MCP Registry v1.4.0 最新进展",
      "link": "https://www.cnblogs.com/shanyou/p/19432926",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/shanyou/p/19432926\" id=\"cb_post_title_url\" title=\"发布于 2026-01-02 22:34\">\n    <span>MCP Registry v1.4.0 最新进展</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><font face=\"微软雅黑 Light\" size=\"3\">2025 年 12 月 16 日发布的 Registry v1.4.0 版本 ，不仅是技术规格的一次迭代，更是整个协议迈向成熟的重要里程碑。该版本引入了严格的 2025-12-11 模式定义 ，正式确立了对 streamable-http 传输层的原生支持，并重构了发布者验证流程。与此同时，MCP 的治理结构发生了历史性变革——Anthropic 将该协议捐赠给 Linux 基金会旗下新成立的 Agentic AI 基金会 (AAIF)。这一举措有效地消除了企业采用该协议的供应商锁定顾虑，促成了包括 AWS、Google Cloud、Cisco 和 Microsoft 在内的行业巨头对该标准的全面拥抱。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\">要理解 v1.4.0 版本的技术意义，必须首先审视 MCP 旨在解决的核心架构挑战。在 MCP 出现之前，将 LLM 连接到外部数据源（如 PostgreSQL 数据库、GitHub 仓库或 Notion 文档）需要针对每个模型提供商编写定制的集成代码。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\">在前 MCP 时代，开发者面临着所谓的“N x M”集成困境。假设有 N 个主流 AI 模型（如 Claude 3.5, GPT-4o, Gemini 1.5）和 M 个外部工具或数据源。若要实现互操作性，理论上需要维护 N * M 个独立的连接器。这种架构不仅脆弱，而且极难扩展。一旦数据源的 API 发生变更，或者开发者决定切换 AI 模型，所有的集成工作都需要推倒重来 。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\">MCP 通过引入标准化的中间层，将这一复杂度降低为 N + M。</font></p><ul><li><p><font face=\"微软雅黑 Light\" size=\"3\">标准化接口： MCP 定义了一套通用的 JSON-RPC 2.0 消息格式，使得任何兼容 MCP 的主机（Host）都可以直接与任何 MCP 服务器（Server）通信，而无需了解后者的底层实现细节。</font></p></li><li><p><font face=\"微软雅黑 Light\" size=\"3\"><font face=\"微软雅黑 Light\" size=\"3\">通用连接器： 这意味着一个针对 Google Drive 开发的 MCP 服务器，可以同时被 Claude Desktop、Cursor IDE、VS Code 甚至定制的企业 AI 代理所使用，真正实现了“一次编写，到处运行”的愿景。</font></font></p></li></ul><p><font face=\"微软雅黑 Light\" size=\"3\">随着 v1.4.0 的发布，MCP 的组件体系已高度成熟，形成了清晰的四层架构：</font></p><ol><li><p><font face=\"微软雅黑 Light\" size=\"3\">MCP Host（主机）：<br />这是 AI 模型的运行环境，也是集成的发起端。典型的主机包括 Claude Desktop、Cursor、Windsurf 以及各类企业级 AI 网关。主机负责管理与用户的交互上下文，并将用户的自然语言意图转化为对 MCP 工具的调用请求 。</font></p></li><li><p><font face=\"微软雅黑 Light\" size=\"3\">MCP Client（客户端）：<br />嵌入在主机内部的协议实现层。它负责与服务器建立 1:1 的连接，处理协议握手、能力协商（Capabilities Negotiation）以及消息的序列化与反序列化。在 v1.4.0 生态中，客户端承担了更多安全职责，如 OAuth 2.0 令牌管理和权限范围（Scope）控制 。</font></p></li><li><p><font face=\"微软雅黑 Light\" size=\"3\">MCP Server（服务器）：<br />这是生态系统的核心资产。服务器是一个轻量级的网关程序，它封装了特定的数据源或工具，并通过 MCP 协议暴露给外界。服务器可以极其简单（如一个只读的 SQLite 查询器），也可以极其复杂（如一个具有推理能力的 GitHub 运维代理）。v1.4.0 版本极大地增强了服务器的元数据定义能力，使其能够更精准地向注册表描述自身行为。</font></p></li><li><p><font face=\"微软雅黑 Light\" size=\"3\">Transport Layer（传输层）：<br />通信的管道。</font></p></li></ol><ul><ul><li><p><font face=\"微软雅黑 Light\" size=\"3\">Stdio（标准输入输出）： 在 MCP 早期主要用于本地开发，通过进程间通信（IPC）实现极其低延迟的交互，且天然隔离网络风险。</font></p></li><li><p><font face=\"微软雅黑 Light\" size=\"3\">SSE (Server-Sent Events) over HTTP: 随着 v1.4.0 对远程连接支持的完善，基于 HTTP 的 SSE 传输已成为主流。它允许服务器独立部署在云端（如 Docker 容器或 Serverless 函数中），并通过标准 URL 被远程客户端访问。这种模式是企业级“远程 MCP”部署的基石。</font></p></li></ul></ul><p><font face=\"微软雅黑 Light\" size=\"3\">&nbsp;&nbsp;&nbsp;&nbsp; 2025 年 12 月 16 日，modelcontextprotocol/registry 仓库发布了 v1.4.0 版本。这一版本不仅仅是代码的更新，更是对整个注册表服务（Registry Service）数据模型的一次重构，旨在适应日益复杂的分布式生态系统。</font></p><p><br /></p><p><font face=\"微软雅黑 Light\" size=\"3\">v1.4.0 最具破坏性但也最具建设性的变更是强制采用了新的 server.json 模式定义，版本号为 2025-12-11。server.json 文件是 MCP 服务器在注册表中的“身份证”，它定义了服务器的名称、描述、安装方式及版本信息。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\">在此之前的版本（如 2025-10-17）中，模式定义相对宽松，允许许多非标准字段存在，且对远程连接的定义不够严谨。新的模式带来了以下关键改进：</font></p><h6><font face=\"微软雅黑 Light\" size=\"3\" style=\"font-weight: normal;\">1 、严格的传输层定义：<font face=\"微软雅黑 Light\" size=\"3\">新模式显式地标准化了 remotes 字段中 streamable-http 的配置方式。<font face=\"微软雅黑 Light\" size=\"3\">在旧版本中，远程服务器的配置往往依赖于特定客户端的约定俗成。而在 v1.4.0 中，server.json 必须严格遵循以下结构来声明远程能力 。<font face=\"微软雅黑 Light\" size=\"3\">这种严格的类型定义（Type Safety）确保了无论是 VS Code 还是 Claude Desktop，在解析远程服务器时都能准确识别连接方式和认证需求，消除了因配置模糊导致的连接失败。</font></font></font></font></h6><h6><font face=\"微软雅黑 Light\" size=\"3\" style=\"font-weight: normal;\">2 、移除 status 字段与动态健康检查：<font face=\"微软雅黑 Light\" size=\"3\">v1.4.0 移除了 server.json 中的 status 字段 。此前，开发者需要手动在 JSON 文件中标记服务器状态（如 \"beta\", \"stable\"）。这种静态标记往往与实际运行状态脱节。<font face=\"微软雅黑 Light\" size=\"3\">新版本的设计理念是：健康状态应当是动态监测的结果，而非静态声明。 注册表服务现在通过内置的验证逻辑（Validation Logic）定期轮询服务器，根据实际响应情况决定其在索引中的可见性。这显著提高了注册表数据的可信度，防止用户安装已停摆的“僵尸服务器”。</font></font></font></h6><h6><font face=\"微软雅黑 Light\" size=\"3\" style=\"font-weight: normal;\">3、 版本一致性强制：<font face=\"微软雅黑 Light\" size=\"3\">新模式引入了严格的版本一致性检查。server.json 中的 version 字段现在必须与 Git Tag 或包管理器（NPM/PyPI）中的版本号严格匹配 。如果注册表检测到版本号不一致（例如 server.json 声明了 v2.0.0 但 Git Tag 只有 v1.9.0），发布流程将自动失败。这一机制有效地杜绝了“幽灵版本”问题，确保用户拉取的代码与注册表描述完全一致。</font></font></h6><p><font face=\"微软雅黑 Light\" size=\"3\">伴随注册表更新，官方发布工具 mcp-publisher 也同步升级至 v1.4.0 17。该 CLI 工具是开发者与 MCP 注册表交互的主要接口。</font> </p><p><font face=\"微软雅黑 Light\" size=\"3\">v1.4.0 版本的发布器深度集成了 OpenID Connect (OIDC) 协议，特别是针对 GitHub Actions 的环境。这意味着开发者不再需要生成和维护长效的 API 密钥（Long-lived Secrets）来发布更新。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\">通过配置 GitHub Action Workflow，mcp-publisher 可以利用临时的 OIDC 令牌向注册表证明身份。注册表服务端会验证该令牌是否由合法的 GitHub 仓库签发，从而授权发布。这极大地提升了供应链的安全性，因为即便发布脚本泄露，攻击者也无法在外部环境伪造有效的 OIDC 令牌 。</font></p><h6><font face=\"微软雅黑 Light\" size=\"3\">新版工具引入了更强大的 check 和 init 命令。</font></h6><ul><li><p><font face=\"微软雅黑 Light\" size=\"3\">mcp-publisher init：能够智能分析当前目录结构（识别是 Node.js 项目还是 Python 项目），自动生成符合 2025-12-11 标准的 server.json 模板。</font></p></li><li><p><font face=\"微软雅黑 Light\" size=\"3\">mcp-publisher check（或集成在发布流程中的验证）：在上传前对 JSON 文件进行本地 Schema 校验。这解决了以往提交后才发现格式错误导致发布失败的痛点，缩短了反馈循环</font> 。</p></li></ul><p><font face=\"微软雅黑 Light\" size=\"3\"><br /></font></p><p><font face=\"微软雅黑 Light\" size=\"3\">如果说 Registry v1.4.0 是技术的升级，那么 Agentic AI 基金会 (AAIF) 的成立则是 MCP 走向行业标准的政治宣言。2025 年 12 月 9 日，Anthropic 正式宣布将 MCP 项目及其相关资产捐赠给 Linux 基金会旗下新成立的 AAIF。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\">在 2024 年至 2025 年间，AI 领域被视为各大巨头（OpenAI, Google, Anthropic, Meta）争夺生态主导权的战场。如果 MCP 始终由 Anthropic 一家公司控制，其他竞争对手（尤其是 OpenAI 和 Google）将很难毫无保留地采纳这一标准，因为这涉及到生态锁定的风险。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\"><font face=\"微软雅黑 Light\" size=\"3\">通过将 MCP 移交给 Linux 基金会这一中立机构，Anthropic 效仿了 Google 捐赠 Kubernetes 给 CNCF 的成功路径。这一举措产生了立竿见影的效果：</font></font></p><ul><li><p><font face=\"微软雅黑 Light\" size=\"3\">消除信任障碍： AWS 和 Google Cloud 随即宣布加强对 MCP 的支持，因为标准不再属于某个单一竞争对手。</font></p></li><li><p><font face=\"微软雅黑 Light\" size=\"3\">统一战线： OpenAI 不仅加入了基金会，还捐赠了其 AGENTS.md 标准。这意味着行业正在走向融合——OpenAI 的代理定义规范与 MCP 的工具连接规范将在 AAIF 的框架下进行整合，形成一套完整的“代理技术栈”。</font></p></li></ul><p><font face=\"微软雅黑 Light\" size=\"3\"><br /></font></p><p><font face=\"微软雅黑 Light\" size=\"3\"><br /></font></p>\n</div>\n<div id=\"MySignature\">\n    <p>欢迎大家扫描下面二维码成为我的客户，扶你上云</p>\n<img src=\"https://images.cnblogs.com/cnblogs_com/shanyou/57459/o_220125090408_%E9%82%80%E8%AF%B7%E4%BA%8C%E7%BB%B4%E7%A0%81-258px.jpeg\" width=\"170\" />\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-02 22:34</span>&nbsp;\n<a href=\"https://www.cnblogs.com/shanyou\">张善友</a>&nbsp;\n阅读(<span id=\"post_view_count\">6</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Contrastive Learning 对比学习 | InfoNCE loss 与互信息的数学关联",
      "link": "https://www.cnblogs.com/moonout/p/19432533",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/moonout/p/19432533\" id=\"cb_post_title_url\" title=\"发布于 2026-01-02 20:07\">\n    <span>Contrastive Learning 对比学习 | InfoNCE loss 与互信息的数学关联</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        InfoNCE loss 可以表示互信息的下界：I(X;Y) ≥ log N - L_InfoNCE 。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<br />\n<p>参考博客：<a href=\"https://blog.csdn.net/iiiiii11/article/details/154584585\" rel=\"noopener nofollow\" target=\"_blank\">CSDN | 【理论推导】互信息与 InfoNCE 损失：从公式推导理解对比学习的本质</a> ，感觉是讲的最清楚的一个博客。</p>\n<hr />\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">目录</div><ul><li><a href=\"#1-infonce-loss-和互信息的数学形式\" rel=\"noopener nofollow\">1 InfoNCE loss 和互信息的数学形式</a><ul><li><a href=\"#11-互信息的数学形式\" rel=\"noopener nofollow\">1.1 互信息的数学形式</a></li><li><a href=\"#12-infonce-loss-的数学形式\" rel=\"noopener nofollow\">1.2 InfoNCE loss 的数学形式</a></li><li><a href=\"#13-为什么我们希望最大化--的互信息\" rel=\"noopener nofollow\">1.3 为什么我们希望最大化 <span class=\"math inline\">\\((X,Y)\\)</span> 的互信息</a></li></ul></li><li><a href=\"#2-infonce-loss-与互信息的数学关联\" rel=\"noopener nofollow\">2 InfoNCE loss 与互信息的数学关联</a></li><li><a href=\"#3-证明过程\" rel=\"noopener nofollow\">3 证明过程</a><ul><li><a href=\"#31-第一步证明使-infonce-loss-取值最小的-满足-\" rel=\"noopener nofollow\">3.1 第一步：证明使 InfoNCE loss 取值最小的 <span class=\"math inline\">\\(f(x,y)\\)</span>，满足 <span class=\"math inline\">\\(f(x, y) = \\log [p(y|x) / p(y)]\\)</span></a></li><li><a href=\"#32-第二步将以上--代入推导互信息下界\" rel=\"noopener nofollow\">3.2 第二步：将以上 <span class=\"math inline\">\\(f(x,y)\\)</span> 代入，推导互信息下界</a></li></ul></li></ul></div><p></p>\n<hr />\n<h2 id=\"1-infonce-loss-和互信息的数学形式\">1 InfoNCE loss 和互信息的数学形式</h2>\n<h3 id=\"11-互信息的数学形式\">1.1 互信息的数学形式</h3>\n<p>互信息 <span class=\"math inline\">\\(I(X,Y)\\)</span> 是信息论中的核心概念，用于衡量两个随机变量 <span class=\"math inline\">\\(X,Y\\)</span> 之间的依赖程度。</p>\n<p>从直观上理解，互信息回答了这样一个问题：知道一个变量 Y 后，我们对另一个变量 X 的不确定性减少了多少？如果 X 的不确定性减少较多，则代表 XY 之间的互信息较大（为正）；如果 X 的不确定性没有减少，则 XY 是相互独立的，即 <span class=\"math inline\">\\(P(X)P(Y) = P(X,Y)\\)</span>，XY 之间的互信息为 0。</p>\n<p>数学上，互信息有三种等价的定义方式：</p>\n<p>① 基于联合分布 <span class=\"math inline\">\\(p(x,y)\\)</span> 和边缘分布 <span class=\"math inline\">\\(p(x)p(y)\\)</span> 的 KL 散度的形式</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = D_{KL}\\big(p(x,y) ~\\|~ p(x)p(y)\\big) = \\mathbb{E}_{p(x,y)}\\left[\\log\\frac{p(x,y)}{p(x)p(y)}\\right]\n\\]</div><p></p><p>这个形式直接体现了互信息的本质：它衡量的是联合分布 <span class=\"math inline\">\\(p(x,y)\\)</span> 与假设 X 和 Y 独立时的分布 <span class=\"math inline\">\\(p(x)p(y)\\)</span> 之间的差异。如果 X 和 Y 独立，这个差异为 0，否则为正数，差异越大说明两个变量关联越强。</p>\n<p>② 基于熵的形式</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = H(X) - H(X|Y) = H(Y) - H(Y|X)\n\\]</div><p></p><p>这里 <span class=\"math inline\">\\(H(X)=\\int p(x)\\log p(x)\\)</span> 是 X 的熵（不确定性），<span class=\"math inline\">\\(H(X|Y)\\)</span> 是已知 Y 时 X 的条件熵，互信息则是不确定性的减少量。</p>\n<p>③ 基于条件概率的形式</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = \\mathbb{E}_{p(x,y)}\\left[\\log\\frac{p(y|x)}{p(y)}\\right]\n\\]</div><p></p><p>这个形式在对比学习中特别有用，因为它直接表达了“在给定 x 的情况下，y 的概率相对于其先验概率的变化”。</p>\n<h3 id=\"12-infonce-loss-的数学形式\">1.2 InfoNCE loss 的数学形式</h3>\n<p>InfoNCE loss 是现代对比学习（Contrastive Learning）的核心。它的设计灵感来自一个简单的直觉：从一堆样本中，找出与给定样本 x 匹配的正样本 y。</p>\n<p>具体的，假设我们有一个正样本对 <span class=\"math inline\">\\((x, y)\\)</span>，比如同一张图片的两种不同数据增强结果，同时从数据集中随机采样 <span class=\"math inline\">\\(N-1\\)</span> 个负样本 <span class=\"math inline\">\\(y_2, y_3, ..., y_N\\)</span>。我们定义一个评分函数 <span class=\"math inline\">\\(f(x, y)\\)</span>（通常是神经网络）来衡量 x 和 y 的相似度。InfoNCE loss 的形式为：</p>\n<p></p><div class=\"math display\">\\[L = -\\mathbb{E}\\left[\\log\\frac{e^{f(x,y)}}{\\sum_{j=1}^{N} e^{f(x,y_j)}}\\right]\n\\]</div><p></p><p>其中，分子 <span class=\"math inline\">\\(e^{f(x,y)}\\)</span> 是正样本的得分，而分母 <span class=\"math inline\">\\(\\sum_{j=1}^{N} e^{f(x,y_j)}\\)</span> 是所有样本（1 个正样本 + N-1 个负样本）得分的总和。整个分式表示：给定 x 和 N 个候选 y，我们正确选出正样本 y 的概率。</p>\n<p>也可将其视为交叉熵损失（cross-entropy loss）的一个变种。交叉熵损失的形式如下：</p>\n<p></p><div class=\"math display\">\\[L_\\text{CE} = \\sum p(a)\\log \\hat p(a)\n\\]</div><p></p><p>其中，<span class=\"math inline\">\\(p(a)\\)</span> 为真是概率，而 <span class=\"math inline\">\\(\\hat p(a)\\)</span> 是我们估计的概率。在 InfoNCE loss 的 setting 中，真概率 <span class=\"math inline\">\\(p(x,y) = 1\\)</span>，而 <span class=\"math inline\">\\(p(x,y_j) = 0\\)</span>。</p>\n<h3 id=\"13-为什么我们希望最大化--的互信息\">1.3 为什么我们希望最大化 <span class=\"math inline\">\\((X,Y)\\)</span> 的互信息</h3>\n<p>在对比学习中，我们希望最大化正样本对的互信息，同时最小化正负样本之间的互信息。这迫使编码器提取出两个不同视图（view）的共享信息（比如同一张图片的不同数据增强版本、语言 / 视觉等不同的模态），这些信息通常对应于数据的内在语义，例如物体的类别、场景等，而忽略无关的噪声或增强引入的变化。</p>\n<p>在 <a href=\"https://www.cnblogs.com/moonout/tag/Skill%20Discovery/\" target=\"_blank\">skill discovery</a>（强化学习的一个子领域）中，我们希望最大化 skill z 和 state s 之间的互信息。从信息理论的角度，最大化 <span class=\"math inline\">\\(I(S;Z)\\)</span> 意味着，我们希望从状态 <span class=\"math inline\">\\(s\\)</span> 中尽可能多地获取关于技能 <span class=\"math inline\">\\(z\\)</span> 的信息。这确保了技能是“有区分度的”：看到智能体的行为，我们就能推断出它使用了哪个技能。</p>\n<h2 id=\"2-infonce-loss-与互信息的数学关联\">2 InfoNCE loss 与互信息的数学关联</h2>\n<p>核心结论：最小化 InfoNCE loss，等价于最大化互信息的一个下界。</p>\n<p>（互信息下界的含义是，互信息的取值将会大于这个值。从这个角度来说，下界的值越大，互信息的值就随之变大，所以，我们最小化 InfoNCE loss，相当于在推动互信息最大化。）</p>\n<p>具体来说，对于任意评分函数 <span class=\"math inline\">\\(f\\)</span>，有以下不等式成立：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) \\geq \\log N - L\n\\]</div><p></p><p>其中，<span class=\"math inline\">\\(L\\)</span> 是我们模型的 InfoNCE loss，这个差值就是互信息的下界。</p>\n<h2 id=\"3-证明过程\">3 证明过程</h2>\n<p>证明过程可以分为两步：</p>\n<h3 id=\"31-第一步证明使-infonce-loss-取值最小的-满足-\">3.1 第一步：证明使 InfoNCE loss 取值最小的 <span class=\"math inline\">\\(f(x,y)\\)</span>，满足 <span class=\"math inline\">\\(f(x, y) = \\log [p(y|x) / p(y)]\\)</span></h3>\n<p>我们要证明：使 InfoNCE loss 最小的 <span class=\"math inline\">\\(f(x,y)\\)</span> 满足：</p>\n<p></p><div class=\"math display\">\\[f(x,y) = \\log\\frac{p(y|x)}{p(y)}\n\\]</div><p></p><p>我们考虑 InfoNCE loss 的期望形式：</p>\n<p></p><div class=\"math display\">\\[L = -\\mathbb{E}_{p(x,y)} \\left[\\log\\frac{e^{f(x,y)}}{\\sum_{j=1}^{N} e^{f(x,y_j)}}\\right]\n\\]</div><p></p><p>我们可以将这个损失看作一个分类问题：给定 x 和 N 个样本 <span class=\"math inline\">\\({y_1, y_2, \\cdots, y_N}\\)</span>，其中只有 <span class=\"math inline\">\\(y_1=y\\)</span> 是正样本，其余是负样本。模型的任务是选出正样本。</p>\n<p>对于固定的 x，最优的分类器应该给出真实的后验概率，即给定 x 后，y 为这个 x 的正样本的概率。那么，真实的后验概率是多少呢？</p>\n<p>根据贝叶斯定理，在给定 x 和 y 样本集合的情况下，第 k 个样本是正样本的概率为（这个没完全看懂）：</p>\n<p></p><div class=\"math display\">\\[p(\\text{第 k 个是正样本} | x, {y_{1\\cdots N}}) = \\frac{p(y_k|x) \\prod_{i\\neq k} p(y_i) }{ \\sum_{j=1}^{N} p(y_j|x) \\prod_{i\\neq j} p(y_i)}\n\\]</div><p></p><p>化简后得到：</p>\n<p></p><div class=\"math display\">\\[= \\frac{p(y_k|x)/p(y_k)}{\\sum_{j=1}^{N} p(y_j|x)/p(y_j)}\n\\]</div><p></p><p>关键观察：如果我们取 <span class=\"math inline\">\\(f(x,y) = \\log\\frac{p(y|x)}{p(y)} + c(x)\\)</span>，其中 <span class=\"math inline\">\\(c(x)\\)</span> 是只依赖于 x 的任意函数，那么：</p>\n<p></p><div class=\"math display\">\\[\\frac{e^{f(x,y_k)}}{\\sum_{j=1}^{N} e^{f(x,y_j)}} = \\frac{p(y_k|x)/p(y_k)}{\\sum_{j=1}^{N} p(y_j|x)/p(y_j)}\n\\]</div><p></p><p>这正是真实的后验分布。因此，这个 <span class=\"math inline\">\\(f(x,y)\\)</span> 取值使得模型的输出分布与真实分布完全一致，从而最小化 InfoNCE loss。</p>\n<p>为简便起见，我们通常取 <span class=\"math inline\">\\(c(x)=0\\)</span>，得到最优 <span class=\"math inline\">\\(f(x,y)\\)</span>：</p>\n<p></p><div class=\"math display\">\\[f^*(x,y) = \\log\\frac{p(y|x)}{p(y)}\n\\]</div><p></p><h3 id=\"32-第二步将以上--代入推导互信息下界\">3.2 第二步：将以上 <span class=\"math inline\">\\(f(x,y)\\)</span> 代入，推导互信息下界</h3>\n<p>现在我们将最优 <span class=\"math inline\">\\(f^*(x,y)\\)</span> 代入 InfoNCE loss：</p>\n<p></p><div class=\"math display\">\\[L_{\\text{min}} = -\\mathbb{E}\\left[\\log\\frac{e^{f^*(x,y)}}{\\sum_{j=1}^{N} e^{f^*(x,y_j)}}\\right]\n= -\\mathbb{E}\\left[\\log\\frac{\\frac{p(y|x)}{p(y)}}{\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}}\\right]\n\\]</div><p></p><p>考虑互信息 <span class=\"math inline\">\\(I(X;Y)\\)</span> 的以下形式：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = \\mathbb{E}\\left[\\log\\frac{p(y|x)}{p(y)}\\right]\n\\]</div><p></p><p>现在，我们想建立 <span class=\"math inline\">\\(I(X;Y)\\)</span> 和 <span class=\"math inline\">\\(L_{\\text{min}}\\)</span> 的关系。通过巧妙的代数变换，把互信息拆开：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = \\mathbb{E}\\left[\\log\\frac{p(y|x)}{p(y)}\\right]\n= \\mathbb{E}\\left[\\log\\frac{\\frac{p(y|x)}{p(y)}}{\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}}\\right] + \\mathbb{E}\\left[\\log\\left(\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right)\\right]\n\\]</div><p></p><p>第一项就是 <span class=\"math inline\">\\(-L_{\\text{min}}\\)</span> 吗？不完全是。实际上，<span class=\"math inline\">\\(-L_{\\text{min}}\\)</span> = 第一项 - log N：</p>\n<p></p><div class=\"math display\">\\[-L_{\\text{min}} = \\mathbb{E}\\left[\\log\\frac{\\frac{p(y|x)}{p(y)}}{\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}}\\right]\n= \\mathbb{E}\\left[\\log\\frac{\\frac{p(y|x)}{p(y)}}{\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}}\\right] - \\log N\n\\]</div><p></p><p>所以：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = (-L_{\\text{min}} + \\log N) + \\mathbb{E}\\left[\\log\\left(\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right)\\right]\n\\]</div><p></p><p>现在看最后一项：<span class=\"math inline\">\\(\\mathbb{E}\\left[\\log\\left(\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right)\\right]\\)</span></p>\n<p>由于对数函数是凹函数，根据琴生不等式（Jensen's Inequality）：</p>\n<p></p><div class=\"math display\">\\[\\mathbb{E}[\\log(Z)] \\leq \\log(\\mathbb{E}[Z])\n\\]</div><p></p><p>因此：</p>\n<p></p><div class=\"math display\">\\[\\mathbb{E}\\left[\\log\\left(\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right)\\right] \\leq \\log\\left(\\mathbb{E}\\left[\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right]\\right)\n\\]</div><p></p><p>我们计算这个 log 里面的期望：</p>\n<p></p><div class=\"math display\">\\[\\mathbb{E}\\left[\\frac{p(y_j|x)}{p(y_j)}\\right] = \\int p(y_j) \\cdot \\frac{p(y_j|x)}{p(y_j)} dy_j = \\int p(y_j|x) dy_j = 1\n\\]</div><p></p><p>期望 = 1。所以：</p>\n<p></p><div class=\"math display\">\\[\\log\\left(\\mathbb{E}\\left[\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right]\\right) = \\log(1) = 0\n\\]</div><p></p><p>代入上式 = 0，使用琴生不等式，因此：</p>\n<p></p><div class=\"math display\">\\[\\mathbb{E}\\left[\\log\\left(\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right)\\right] \\leq 0\n\\]</div><p></p><p>将上式 ≤ 0 代回原式：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) \\geq \\log N - L_{\\text{min}}\n\\]</div><p></p><p>由于 <span class=\"math inline\">\\(f^*\\)</span> 是最优的，所以对于任意评分函数 <span class=\"math inline\">\\(f\\)</span>，有 <span class=\"math inline\">\\(L(f) \\geq L_{\\text{min}}\\)</span>，得到：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) \\geq \\log N - L_{\\text{min}} \\geq \\log N - L(f)\n\\]</div><p></p><p>证毕：对于任意评分函数 <span class=\"math inline\">\\(f\\)</span>，<span class=\"math inline\">\\(\\log N - L(f)\\)</span> 是互信息 <span class=\"math inline\">\\(I(X;Y)\\)</span> 的一个下界。</p>\n<br />\n<br />\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-02 20:07</span>&nbsp;\n<a href=\"https://www.cnblogs.com/moonout\">MoonOut</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "LangChain4j 工具调用实战",
      "link": "https://www.cnblogs.com/BNTang/p/19432093",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/BNTang/p/19432093\" id=\"cb_post_title_url\" title=\"发布于 2026-01-02 15:32\">\n    <span>LangChain4j 工具调用实战</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>你有没有遇到过这种场景：</p>\n<ul>\n<li>用户问 AI：\"帮我查下今天上海的天气\"</li>\n<li>AI 回答：\"抱歉，我无法获取实时信息。\"</li>\n</ul>\n<p><strong>问题的核心是：AI 没有工具。</strong>就像给你一双手脚，让你去盖房子，你也做不到。但如果给你一套工具箱，情况就完全不同了。</p>\n<p><strong>今天我们就来给 AI 装上一套工具箱</strong>，让它能够从博客园实时获取最新技术文章。</p>\n<h2 id=\"什么是工具调用\">什么是工具调用？</h2>\n<p>简单来说，工具调用就是让 AI 能够\"借用\"外部能力。</p>\n<p>这些能力包括但不限于：</p>\n<ul>\n<li>联网搜索</li>\n<li>调用第三方 API</li>\n<li>读写文件</li>\n<li>查询数据库</li>\n<li>执行代码</li>\n</ul>\n<p><strong>但有一个关键点要特别注意</strong>：</p>\n<p>工具调用 <strong>不是</strong> AI 自己去执行这些工具，而是 AI 说\"我需要调用 XX 工具\"，真正执行的是我们的应用程序。</p>\n<p>流程是这样的：</p>\n<pre><code>用户提问 → AI 分析意图 → AI 决定调用工具\n→ 我们的程序执行工具 → 把结果返回给 AI → AI 继续回答\n</code></pre>\n<h2 id=\"要实现的目标\">要实现的目标</h2>\n<p>让 AI 能够查询博客园用户的最新文章，并提取这些信息：</p>\n<ul>\n<li>文章标题</li>\n<li>文章链接</li>\n<li>发布日期</li>\n<li>摘要内容</li>\n<li>阅读数、评论数、推荐数</li>\n</ul>\n<p><strong>实现方案</strong>：用 Jsoup 抓取博客园页面，把数据整理后返回给 AI。</p>\n<h2 id=\"快速了解流程\">快速了解流程</h2>\n<p>完整流程其实很简单：</p>\n<ol>\n<li>用户提问 → 2. AI 分析意图 → 3. AI 决定调用工具 → 4. 程序执行工具 → 5. 结果返回给 AI → 6. AI 整理后回复用户</li>\n</ol>\n<p><strong>核心就是</strong>：AI 不直接调用工具，而是告诉我们的程序\"我需要调用这个工具\"，程序执行完后把结果给 AI，AI 再基于结果回答用户。</p>\n<blockquote>\n<p>想看详细的调用链路？文章最后有完整的时序图，包你一看就懂。</p>\n</blockquote>\n<h2 id=\"动手实现四步搞定\">动手实现（四步搞定）</h2>\n<h3 id=\"步骤-1引入依赖\">步骤 1：引入依赖</h3>\n<p>先在 <code>pom.xml</code> 中加入 Jsoup（网页爬虫库）：</p>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.jsoup&lt;/groupId&gt;\n    &lt;artifactId&gt;jsoup&lt;/artifactId&gt;\n    &lt;version&gt;1.20.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h3 id=\"步骤-2编写工具类\">步骤 2：编写工具类</h3>\n<p>在 <code>tools</code> 包下创建一个工具类，用 <code>@Tool</code> 注解告诉 LangChain4j：\"这是一个工具\"。</p>\n<p><strong>⚠️ 重点</strong>：工具描述一定要写清楚，AI 能否正确调用工具全看这个描述！</p>\n<pre><code class=\"language-java\">/**\n * 博客园文章搜索工具\n * 用于从博客园抓取用户的最新文章信息\n *\n * @author BNTang\n */\n@Slf4j\npublic class CnblogsArticleTool {\n\n    /**\n     * 从指定用户的博客园主页获取最新的技术文章列表。\n     * 支持提取文章标题、链接、发布日期、摘要、阅读数、评论数和推荐数等信息。\n     *\n     * @param input 博客园用户名或URL，可选地附加\"|N\"来限制结果数量\n     * @return 技术文章列表的JSON格式，包含详细信息，若失败则返回错误信息\n     */\n    @Tool(name = \"cnblogsSearch\", value = \"\"\"\n            从博客园获取最新文章。输入可以是：\n            - 博客园用户名（例如：'someUser'）\n            - 完整的个人主页URL（例如：'https://www.cnblogs.com/someUser/'）\n            可选择性地附加'|N'来限制结果数量，例如：'someUser|5'。\n            返回包含标题、链接、日期、摘要、阅读数、评论数、推荐数的JSON数组。\n            \"\"\"\n    )\n    public String searchCnblogsArticles(@P(value = \"用户名或URL（可选地附加|限制数量）\") String input) {\n        if (input == null || input.trim().isEmpty()) {\n            return \"{\\\"error\\\":\\\"Empty input\\\"}\";\n        }\n\n        String[] parts = input.trim().split(\"\\\\|\", 2);\n        String target = parts[0].trim();\n        int limit = 10;\n        if (parts.length == 2) {\n            try {\n                limit = Math.max(1, Math.min(100, Integer.parseInt(parts[1].trim())));\n            } catch (NumberFormatException ignored) { /* keep default */ }\n        }\n\n        String url;\n        if (target.startsWith(\"http://\") || target.startsWith(\"https://\")) {\n            url = target;\n        } else {\n            url = \"https://www.cnblogs.com/\" + target + \"/\";\n        }\n\n        Document doc = fetchDocumentWithRetries(url, 3, 8000);\n        if (doc == null) {\n            return \"{\\\"error\\\":\\\"Failed to fetch or parse page\\\"}\";\n        }\n\n        // 选择博客文章的主容器\n        Elements dayElements = doc.select(\".day\");\n\n        List&lt;ArticleInfo&gt; results = new ArrayList&lt;&gt;();\n\n        for (Element dayEl : dayElements) {\n            if (results.size() &gt;= limit) {\n                break;\n            }\n\n            // 提取标题和链接\n            Element titleEl = dayEl.selectFirst(\".postTitle a, .postTitle2\");\n            if (titleEl == null) {\n                continue;\n            }\n\n            String title = titleEl.text().trim();\n            // 移除\"[置顶]\"标记\n            title = title.replaceAll(\"^\\\\[置顶]\\\\s*\", \"\");\n\n            String href = titleEl.absUrl(\"href\");\n            if (href.isEmpty()) {\n                href = titleEl.attr(\"href\").trim();\n            }\n\n            // 去重检查\n            boolean seen = false;\n            for (ArticleInfo r : results) {\n                if (r.url.equals(href)) {\n                    seen = true;\n                    break;\n                }\n            }\n            if (seen) {\n                continue;\n            }\n\n            // 提取日期\n            String date = \"\";\n            Element dateEl = dayEl.selectFirst(\".dayTitle a\");\n            if (dateEl != null) {\n                date = dateEl.text().trim();\n            }\n\n            // 提取摘要\n            String summary = \"\";\n            Element summaryEl = dayEl.selectFirst(\".c_b_p_desc, .postCon\");\n            if (summaryEl != null) {\n                summary = summaryEl.text().trim();\n                // 移除\"阅读全文\"链接文本\n                summary = summary.replaceAll(\"阅读全文$\", \"\").trim();\n                // 限制摘要长度\n                if (summary.length() &gt; 200) {\n                    summary = summary.substring(0, 200) + \"...\";\n                }\n            }\n\n            // 提取统计信息\n            String viewCount = \"0\";\n            String commentCount = \"0\";\n            String diggCount = \"0\";\n\n            Element postDesc = dayEl.selectFirst(\".postDesc\");\n            if (postDesc != null) {\n                Element viewEl = postDesc.selectFirst(\".post-view-count\");\n                if (viewEl != null) {\n                    viewCount = extractNumber(viewEl.text());\n                }\n\n                Element commentEl = postDesc.selectFirst(\".post-comment-count\");\n                if (commentEl != null) {\n                    commentCount = extractNumber(commentEl.text());\n                }\n\n                Element diggEl = postDesc.selectFirst(\".post-digg-count\");\n                if (diggEl != null) {\n                    diggCount = extractNumber(diggEl.text());\n                }\n            }\n\n            if (!title.isEmpty() &amp;&amp; !href.isEmpty()) {\n                results.add(new ArticleInfo(title, href, date, summary, viewCount, commentCount, diggCount));\n            }\n        }\n\n        if (results.isEmpty()) {\n            return \"{\\\"message\\\":\\\"未找到文章。\\\"}\";\n        }\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        for (int i = 0; i &lt; results.size(); i++) {\n            ArticleInfo article = results.get(i);\n            sb.append(\"{\");\n            sb.append(\"\\\"title\\\":\").append(jsonEscape(article.title)).append(\",\");\n            sb.append(\"\\\"url\\\":\").append(jsonEscape(article.url)).append(\",\");\n            sb.append(\"\\\"date\\\":\").append(jsonEscape(article.date)).append(\",\");\n            sb.append(\"\\\"summary\\\":\").append(jsonEscape(article.summary)).append(\",\");\n            sb.append(\"\\\"viewCount\\\":\").append(article.viewCount).append(\",\");\n            sb.append(\"\\\"commentCount\\\":\").append(article.commentCount).append(\",\");\n            sb.append(\"\\\"diggCount\\\":\").append(article.diggCount);\n            sb.append(\"}\");\n            if (i &lt; results.size() - 1) {\n                sb.append(\",\");\n            }\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }\n\n    /**\n     * 带重试机制获取网页文档\n     *\n     * @param url         目标URL\n     * @param maxAttempts 最大尝试次数\n     * @param timeoutMs   超时时间（毫秒）\n     * @return Jsoup文档对象，失败返回null\n     */\n    private Document fetchDocumentWithRetries(String url, int maxAttempts, int timeoutMs) {\n        String userAgent = \"Mozilla/5.0 (compatible; Bot/1.0; +https://example.com/bot)\";\n        int attempt = 0;\n        while (attempt &lt; maxAttempts) {\n            attempt++;\n            try {\n                return Jsoup.connect(url)\n                        .userAgent(userAgent)\n                        .timeout(timeoutMs)\n                        .referrer(\"https://www.google.com\")\n                        .get();\n            } catch (IOException e) {\n                log.warn(\"第{}次尝试获取 {} 失败: {}\", attempt, url, e.getMessage());\n                try {\n                    Thread.sleep(500L * attempt);\n                } catch (InterruptedException ignored) {\n                    Thread.currentThread().interrupt();\n                    break;\n                }\n            }\n        }\n        log.error(\"所有尝试均失败，无法获取 {}\", url);\n        return null;\n    }\n\n    /**\n     * 从文本中提取数字\n     *\n     * @param text 包含数字的文本，如\"阅读(123)\"\n     * @return 提取的数字字符串\n     */\n    private String extractNumber(String text) {\n        if (text == null) {\n            return \"0\";\n        }\n        text = text.replaceAll(\"[^0-9]\", \"\");\n        return text.isEmpty() ? \"0\" : text;\n    }\n\n    /**\n     * JSON字符串转义\n     *\n     * @param s 待转义的字符串\n     * @return 转义后的JSON字符串\n     */\n    private String jsonEscape(String s) {\n        if (s == null) {\n            return \"\\\"\\\"\";\n        }\n        String escaped = s.replace(\"\\\\\", \"\\\\\\\\\")\n                .replace(\"\\\"\", \"\\\\\\\"\")\n                .replace(\"\\n\", \"\\\\n\")\n                .replace(\"\\r\", \"\\\\r\");\n        return \"\\\"\" + escaped + \"\\\"\";\n    }\n\n    /**\n     * 文章信息类\n     */\n    private static class ArticleInfo {\n        String title;\n        String url;\n        String date;\n        String summary;\n        String viewCount;\n        String commentCount;\n        String diggCount;\n\n        ArticleInfo(String title, String url, String date, String summary,\n                    String viewCount, String commentCount, String diggCount) {\n            this.title = title;\n            this.url = url;\n            this.date = date;\n            this.summary = summary;\n            this.viewCount = viewCount;\n            this.commentCount = commentCount;\n            this.diggCount = diggCount;\n        }\n    }\n}\n</code></pre>\n<p><strong>核心逻辑</strong>：</p>\n<ol>\n<li>解析用户输入（支持用户名或 URL）</li>\n<li>用 Jsoup 抓取博客园页面</li>\n<li>用 CSS 选择器提取文章信息</li>\n<li>返回 JSON 格式的结果</li>\n</ol>\n<h3 id=\"步骤-3把工具绑定到-ai-service\">步骤 3：把工具绑定到 AI Service</h3>\n<pre><code class=\"language-java\">public AiCodeHelperService aiCodeHelperService() {\n    ChatMemory chatMemory = MessageWindowChatMemory.withMaxMessages(10);\n\n    return AiServices.builder(AiCodeHelperService.class)\n            .chatModel(qwenChatModel)\n            .chatMemory(chatMemory)\n            .contentRetriever(contentRetriever)\n            .tools(new CnblogsArticleTool())  // ← 绑定工具\n            .build();\n}\n</code></pre>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2105804/202601/2105804-20260102134201705-1158921879.png\" /></p>\n<h3 id=\"步骤-4测试一下\">步骤 4：测试一下</h3>\n<p>写个单元测试：</p>\n<pre><code class=\"language-java\">@Test\nvoid chatWithTools() {\n    String result = aiCodeHelperService.chat(\n        \"帮我查下博客园用户 BNTang 的最新文章\"\n    );\n    System.out.println(result);\n}\n</code></pre>\n<p><strong>关键来了</strong>，在工具方法里打断点，Debug 运行：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2105804/202601/2105804-20260102134527464-344030566.png\" /></p>\n<p><strong>你会看到断点真的停下来了！</strong></p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2105804/202601/2105804-20260102134605221-2143614017.png\" /></p>\n<p>这说明 <strong>AI 真的调用了我们的工具</strong>！</p>\n<p>工具把数据返回给 AI 后，AI 会整理成自然语言：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2105804/202601/2105804-20260102134407815-1435969741.png\" /></p>\n<p>在 Debug 模式下，你还能看到 AI Service 加载了工具：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2105804/202601/2105804-20260102134818678-1880921390.png\" /></p>\n<p>以及工具的完整调用链路：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2105804/202601/2105804-20260102135157469-2000354683.png\" /></p>\n<p><strong>完美运行！</strong></p>\n<h2 id=\"工具定义的两种方式\">工具定义的两种方式</h2>\n<p>前面用的是声明式定义（注解），LangChain4j 也支持编程式定义：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2105804/202601/2105804-20260102135244721-1011469314.png\" /></p>\n<p><strong>简单场景用声明式，需要动态创建工具用编程式。</strong></p>\n<h2 id=\"还能做更多\">还能做更多</h2>\n<p>除了搜索，工具调用还能实现这些功能：</p>\n<ul>\n<li>读写本地文件</li>\n<li>生成 PDF 报告</li>\n<li>执行 Shell 命令</li>\n<li>生成图表</li>\n<li>调用企业内部 API</li>\n</ul>\n<p><strong>更棒的是</strong>：这些工具不一定都要自己写，可以通过 MCP（Model Context Protocol）协议直接用别人开发好的工具。</p>\n<h2 id=\"完整的调用链路\">完整的调用链路</h2>\n<p>如果想深入理解工具调用的每一步，看这个时序图就对了：</p>\n<div class=\"mermaid\">sequenceDiagram\n      autonumber\n\n      participant U2 as 🧪 Test(用户)\n      participant B1 as AiCodeHelperService\n      participant L1 as LangChain4j框架\n      participant L2 as ChatModel(LLM)\n      participant B3 as CnblogsArticleTool\n      participant T1 as Jsoup(网页抓取)\n\n      Note over U2,T1: chatWithTools() 测试流程\n\n      U2-&gt;&gt;B1: chat(\"帮我查询博客园用户 BNTang 的最新技术文章...\")\n      B1-&gt;&gt;L1: 转发请求\n      L1-&gt;&gt;L1: 加载 system-prompt.txt\n      L1-&gt;&gt;L1: 添加 ChatMemory(最近10条消息)\n      L1-&gt;&gt;L2: 发送用户消息\n\n      L2-&gt;&gt;L2: 分析意图\n      L2-&gt;&gt;L2: 识别需要调用 cnblogsSearch 工具\n\n      L2--&gt;&gt;L1: 返回工具调用请求\n      L1-&gt;&gt;B3: searchCnblogsArticles(\"BNTang\")\n\n      B3-&gt;&gt;B3: 解析输入参数\n      B3-&gt;&gt;B3: 构造URL (https://www.cnblogs.com/BNTang/)\n\n      B3-&gt;&gt;T1: fetchDocumentWithRetries(url, 3, 8000)\n      T1-&gt;&gt;T1: 发送HTTP请求\n      T1--&gt;&gt;B3: 返回HTML文档\n\n      B3-&gt;&gt;B3: 解析HTML (.day 元素)\n      B3-&gt;&gt;B3: 提取文章信息(标题、链接、日期、摘要等)\n      B3-&gt;&gt;B3: 生成JSON结果\n\n      B3--&gt;&gt;L1: 返回文章列表JSON\n      L1-&gt;&gt;L2: 发送工具结果给LLM\n\n      L2-&gt;&gt;L2: 基于工具结果生成最终回复\n      L2--&gt;&gt;L1: 返回最终答案\n      L1--&gt;&gt;B1: 返回结果\n      B1--&gt;&gt;U2: 返回 String 结果\n\n      U2-&gt;&gt;U2: System.out.println(result)\n</div><p><strong>时序图解读</strong>：</p>\n<ol>\n<li><strong>用户发起请求</strong>（步骤 1-4）：Test 调用 Service，Service 转发给 LangChain4j 框架</li>\n<li><strong>AI 分析意图</strong>（步骤 5-7）：LLM 分析用户问题，决定需要调用 <code>cnblogsSearch</code> 工具</li>\n<li><strong>工具执行</strong>（步骤 8-17）：Tool 用 Jsoup 抓取博客园页面，解析数据</li>\n<li><strong>结果返回</strong>（步骤 18-21）：工具结果返回给 LLM，LLM 生成最终答案</li>\n</ol>\n<p><strong>关键点</strong>：工具执行在应用侧（B3、T1），不在 AI 服务器（L2）。</p>\n<h2 id=\"写在最后\">写在最后</h2>\n<p>工具调用是让 AI 突破能力边界的关键技术。</p>\n<p><strong>记住三个要点</strong>：</p>\n<ol>\n<li>工具描述写清楚，AI 才能正确调用</li>\n<li>工具在应用侧执行，不在 AI 服务器</li>\n<li>声明式定义简单，编程式定义灵活</li>\n</ol>\n<p>通过 LangChain4j 的 <code>@Tool</code> 注解，只需要几行代码，就能让 AI 拥有\"超能力\"。</p>\n<hr />\n<p><strong>系列文章持续更新中，关注我不错过每一篇干货。</strong></p>\n<p><strong>这篇文章对你有用的话，点个赞、在看支持一下吧！</strong></p>\n<hr />\n<p><strong>相关文章推荐</strong>：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/XhmFIeKpJR37AqqLg46b5w\" rel=\"noopener nofollow\" target=\"_blank\">智谱 GLM-4.7 编程第一</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/8fRzTXtAJ8_IfX2OggGDsw\" rel=\"noopener nofollow\" target=\"_blank\">LangChain4j 结构化输出实战</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/KtaNzGc3wbVKPwMTVl1z4g\" rel=\"noopener nofollow\" target=\"_blank\">让 AI 不再失忆</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/pnCbt98Ob4hb8sj9WPVV3g\" rel=\"noopener nofollow\" target=\"_blank\">Claude Code 免费指南</a></li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-02 15:32</span>&nbsp;\n<a href=\"https://www.cnblogs.com/BNTang\">BNTang</a>&nbsp;\n阅读(<span id=\"post_view_count\">71</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "独立开发者的 2025：我为什么还在做一个“看起来很普通”的客服系统",
      "link": "https://www.cnblogs.com/sheng_chao/p/19431954",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sheng_chao/p/19431954\" id=\"cb_post_title_url\" title=\"发布于 2026-01-02 15:02\">\n    <span>独立开发者的 2025：我为什么还在做一个“看起来很普通”的客服系统</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        过去几年里，技术社区反复讨论同样几个话题：AI、出海、SaaS、独立开发者。热度在变，说法在升级，但真正把一个系统长期跑起来的人，感受往往更具体也更现实。这篇文章，算是一次不太宏大的回顾——记录我在 2025 年围绕一个客服系统所做的选择、踩过的坑，以及一些被现实反复校正过的认知。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>过去几年里，技术社区反复讨论同样几个话题：AI、出海、SaaS、独立开发者。<br />\n热度在变，说法在升级，但真正把一个系统长期跑起来的人，感受往往更具体也更现实。<br />\n2025 年对我来说，并不是一个有明显拐点的年份，没有爆发式增长，也没有戏剧性转向，只是持续做事、持续暴露问题、持续修正判断的一年。<br />\n这篇文章，算是一次不太宏大的回顾——记录我在 2025 年围绕一个客服系统所做的选择、踩过的坑，以及一些被现实反复校正过的认知。</p>\n<hr />\n<h2 id=\"一2025一个看似普通其实很残酷的一年\">一、2025：一个“看似普通、其实很残酷”的一年</h2>\n<p>如果只看技术社区的热词，2025 年似乎并不特别。<br />\nAI、出海、SaaS、独立开发者，这些词在过去几年里已经被反复讨论，甚至有些“疲劳”。</p>\n<p>但真正身处其中的人，大多能感受到一种很微妙的变化：</p>\n<p><strong>机会并没有消失，但容错率在急剧下降。</strong></p>\n<ul>\n<li>流量不再自然增长</li>\n<li>用户不再愿意“陪你一起成熟”</li>\n<li>技术红利逐步变成工程与耐力的比拼</li>\n</ul>\n<p>你依然可以做产品、写代码、发布版本，但<strong>每一次决策的代价都变得更真实、更不可逆</strong>。</p>\n<hr />\n<h3 id=\"表面平静底层在加速分化\">表面平静，底层在加速分化</h3>\n<p>从外部看，2025 年不像 2020 那样剧烈，也不像 2022 那样充满不确定性。<br />\n但从内部看，它更像是一个<strong>分水岭年份</strong>：</p>\n<ul>\n<li>大厂在收缩战线，只保留“确定性强”的方向</li>\n<li>中小团队开始意识到，靠融资和故事续命越来越难</li>\n<li>独立开发者要么更专业，要么更快放弃</li>\n</ul>\n<p><strong>“能跑起来”已经不算本事，“能活下去”才是。</strong></p>\n<hr />\n<h3 id=\"技术依然重要但不再是护城河本身\">技术依然重要，但不再是护城河本身</h3>\n<p>2025 年我最大的一个感受是：</p>\n<blockquote>\n<p>技术没有贬值，但“只靠技术”的路径，正在快速变窄。</p>\n</blockquote>\n<p>框架在变，模型在升级，工具链越来越完善。<br />\n一个功能，从想法到落地，前所未有地快。</p>\n<p>但这也意味着：</p>\n<ul>\n<li>同质化速度极快</li>\n<li>抄一个“能用的版本”几乎没有门槛</li>\n<li>真正拉开差距的，是长期维护、稳定性、细节和取舍</li>\n</ul>\n<p>很多项目不是死于“做不出来”，<br />\n而是死于 <strong>“做到一半，发现后面的路太长”</strong>。</p>\n<hr />\n<h3 id=\"对独立开发者而言这是清醒的一年\">对独立开发者而言，这是“清醒”的一年</h3>\n<p>如果说前几年还可以抱有某种浪漫幻想，<br />\n那么 2025 年更像是一年集体清醒期：</p>\n<ul>\n<li>你开始认真计算服务器、运维、支持成本</li>\n<li>你意识到每一个“免费用户”都在消耗注意力</li>\n<li>你必须直面一个问题：<strong>这东西有没有人愿意长期用、长期付费</strong></li>\n</ul>\n<p>对我来说，这一年并没有发生什么戏剧性的转折。<br />\n没有爆发式增长，也没有彻底放弃。</p>\n<p>只是逐渐意识到：<br />\n<strong>如果要继续做，就必须把它当成一件长期、甚至有点枯燥的事来对待。</strong></p>\n<hr />\n<h3 id=\"正是在这样的背景下我继续推进了-升讯威在线客服与营销系统\">正是在这样的背景下，我继续推进了 升讯威在线客服与营销系统</h3>\n<p>在 2025 年，我仍然选择把时间投入到一个看起来并不“性感”的方向——客服系统。</p>\n<p>不是因为它新，<br />\n而是因为它<strong>足够现实</strong>：</p>\n<ul>\n<li>足够考验工程能力</li>\n<li>足够暴露产品取舍</li>\n<li>也足够真实地反映“有没有人在用”</li>\n</ul>\n<p>后面的章节，我会具体聊聊这一年里踩过的坑、做过的取舍，以及一些被反复验证过的反直觉结论。</p>\n<p>但所有这些，都源于同一个前提：</p>\n<blockquote>\n<p><strong>2025 年，不再是“试试看”的年份了。</strong></p>\n</blockquote>\n<p>如果你还在做事，大概率和我一样，已经意识到了这一点。</p>\n<hr />\n<h2 id=\"二我为什么在-2025-年还要做一个客服系统\">二、我为什么在 2025 年还要做一个“客服系统”</h2>\n<p>如果只从“赛道选择”的角度看，<br />\n在 2025 年做客服系统，几乎是一个<strong>反直觉</strong>的决定。</p>\n<p>它不新、不酷、不在风口上。<br />\n也很难用一句话讲出“颠覆性”。</p>\n<p>但正因为如此，它反而成了一个非常诚实的选择。</p>\n<hr />\n<h3 id=\"客服系统是一面照妖镜\">客服系统是一面“照妖镜”</h3>\n<p>我一直觉得，客服系统是 SaaS 产品里非常特殊的一类：</p>\n<ul>\n<li>它不解决“增长”，而是暴露问题</li>\n<li>它不创造幻想，而是承接情绪</li>\n<li>它每天面对的，都是系统最真实、最糟糕的状态</li>\n</ul>\n<p>当一切都运转良好时，客服系统几乎是隐形的；<br />\n<strong>只有当别的地方出问题，它才会被频繁打开。</strong></p>\n<p>这意味着两件事：</p>\n<ol>\n<li>它对稳定性和实时性的要求极端苛刻</li>\n<li>它几乎无法靠“营销叙事”掩盖真实体验</li>\n</ol>\n<p><strong>好不好用，用几天就知道。</strong></p>\n<hr />\n<h3 id=\"红海并不等于没问题可解决\">“红海”并不等于“没问题可解决”</h3>\n<p>客服系统常被视为红海产品，但我在实际使用和调研中发现的却是另一种景象：</p>\n<ul>\n<li>功能很多，但长期使用体验割裂</li>\n<li>演示很好看，真实场景却频繁卡壳</li>\n<li>对销售友好，对工程师不友好</li>\n</ul>\n<p>尤其是对中小团队来说，常见的困境是：</p>\n<ul>\n<li>SaaS 版本限制多、定制难</li>\n<li>私有化版本部署复杂、维护成本高</li>\n<li>出了问题，很难快速定位到底是哪一层在出错</li>\n</ul>\n<p><strong>不是没有产品，而是“能安心长期用的产品”不多。</strong></p>\n<hr />\n<h3 id=\"我想验证一件事工程导向能不能做出好产品\">我想验证一件事：工程导向能不能做出好产品</h3>\n<p>在 2025 年继续做客服系统，对我来说更像一次验证，而不是押注。</p>\n<p>我想验证的不是“能不能做成一个大平台”，<br />\n而是一个更具体、也更残酷的问题：</p>\n<blockquote>\n<p>如果从一开始就以工程可控性、可维护性为核心，<br />\n能不能反过来，做出一个真正对用户友好的系统？</p>\n</blockquote>\n<p>这意味着很多不讨巧的选择：</p>\n<ul>\n<li>把时间花在日志、遥测、异常采集上</li>\n<li>花精力设计清晰、可预期的系统边界</li>\n<li>接受“功能慢一点，但稳定优先”的节奏</li>\n</ul>\n<p>这些东西在 Demo 里几乎看不出来，<br />\n但在第 100 次、第 1000 次使用时，会被反复感知。</p>\n<hr />\n<h3 id=\"升讯威在线客服与营销系统-只是这个验证过程的载体\">升讯威在线客服与营销系统 只是这个验证过程的载体</h3>\n<p>在这个过程中，我做了一个叫 <strong>升讯威在线客服与营销系统</strong> 的客服系统。</p>\n<p>但它并不是一个“先定产品、再找用户”的项目，<br />\n更像是一个<strong>长期承载思考和取舍的容器</strong>：</p>\n<ul>\n<li>哪些功能值得做，哪些应该克制</li>\n<li>哪些问题应该由系统解决，哪些必须交还给人</li>\n<li>在 SaaS 和私有化之间，边界应该如何划分</li>\n</ul>\n<p>很多决策，并不是“行业最佳实践”，<br />\n而是一次次被现实逼出来的选择。</p>\n<hr />\n<h3 id=\"为什么是-2025而不是更早或更晚\">为什么是 2025，而不是更早或更晚</h3>\n<p>如果是更早几年，我可能会更激进；<br />\n如果再晚几年，可能会更保守。</p>\n<p>2025 刚好处在一个微妙的位置：</p>\n<ul>\n<li>技术足够成熟，可以把基础问题解决好</li>\n<li>用户足够理性，不再被概念牵着走</li>\n<li>我自己，也已经不再执着于“做一个看起来很厉害的东西”</li>\n</ul>\n<p>而是更在意：</p>\n<blockquote>\n<p><strong>这个系统，在真实世界里，能不能被长期信任。</strong></p>\n</blockquote>\n<p>这就是我在 2025 年，仍然选择做一个客服系统的核心原因。</p>\n<hr />\n<h2 id=\"三2025-年我真正踩过的-5-个坑\">三、2025 年我真正踩过的 5 个坑</h2>\n<p>这一年里，我越来越清楚一件事：</p>\n<blockquote>\n<p>真正决定一个系统能不能“长期活着”的，<br />\n往往不是你最得意的那部分代码。</p>\n</blockquote>\n<p>下面这 5 个坑，都不是概念问题，而是<strong>上线之后、真实使用中反复出现</strong>的问题。</p>\n<hr />\n<h3 id=\"坑一把功能完整误当成系统可用\">坑一：把“功能完整”误当成“系统可用”</h3>\n<p>这是最早、也是最隐蔽的一个坑。</p>\n<p>在开发初期，很容易用 checklist 思维判断进度：</p>\n<ul>\n<li>会话有了</li>\n<li>转接有了</li>\n<li>访客追踪有了</li>\n<li>历史记录能查</li>\n</ul>\n<p><strong>看起来一切都齐了。</strong></p>\n<p>但真正上线后才发现，客服系统的“可用”，并不取决于有没有功能，而取决于：</p>\n<ul>\n<li>高峰期会不会卡</li>\n<li>网络抖动时会不会丢消息</li>\n<li>客服端卡死后能不能恢复</li>\n</ul>\n<p>这些问题，只有在<strong>真实用户、真实压力</strong>下才会暴露。</p>\n<p>后来我不得不承认：<br />\n<strong>客服系统不是功能型产品，而是稳定性型产品。</strong></p>\n<hr />\n<h3 id=\"坑二低估实时系统的复杂度\">坑二：低估“实时系统”的复杂度</h3>\n<p>理论上，一个客服系统就是：</p>\n<blockquote>\n<p>WebSocket + 消息转发 + 状态同步</p>\n</blockquote>\n<p>实际写起来，完全不是一回事。</p>\n<p>只要系统存在：</p>\n<ul>\n<li>多客服</li>\n<li>多会话</li>\n<li>多设备登录</li>\n<li>客服/访客随时上下线</li>\n</ul>\n<p>就必然会遇到这些问题：</p>\n<ul>\n<li>状态不同步</li>\n<li>幽灵会话</li>\n<li>已关闭的连接仍然被认为“在线”</li>\n<li>消息已发送，但对方并未真正接收</li>\n</ul>\n<p>最痛苦的是：<br />\n<strong>这些问题很难稳定复现。</strong></p>\n<p>后来我才真正理解，实时系统的核心不是“快”，<br />\n而是 <strong>状态一致性的收敛能力</strong>。</p>\n<hr />\n<h3 id=\"坑三把日志当成事后工具\">坑三：把日志当成“事后工具”</h3>\n<p>一开始，我也和很多人一样：</p>\n<ul>\n<li>出问题了，再加日志</li>\n<li>定位到了，再删一部分</li>\n</ul>\n<p>直到有一天我意识到：</p>\n<blockquote>\n<p>在客服系统里，如果你需要“复现问题”，<br />\n这个问题本身就已经很严重了。</p>\n</blockquote>\n<p>很多用户反馈的问题，本质是：</p>\n<ul>\n<li>“刚刚还能用，现在不行了”</li>\n<li>“有时候会断”</li>\n<li>“偶尔收不到消息”</li>\n</ul>\n<p>如果没有<strong>结构化、可关联的日志和遥测数据</strong>，<br />\n你根本无法判断问题发生在哪一层。</p>\n<p>从那之后，我开始把日志、异常、遥测当作<strong>系统的一部分</strong>，<br />\n而不是附加模块。</p>\n<hr />\n<h3 id=\"坑四以为-saas-和私有化只是部署方式不同\">坑四：以为 SaaS 和私有化只是“部署方式不同”</h3>\n<p>这是一个非常典型、也非常昂贵的认知错误。</p>\n<p>在早期，我下意识地认为：</p>\n<blockquote>\n<p>SaaS 跑得通，私有化就是“多打个包”。</p>\n</blockquote>\n<p>真正开始支持私有化之后才发现：</p>\n<ul>\n<li>网络环境完全不可控</li>\n<li>依赖服务可能被裁剪</li>\n<li>客户更关心“可诊断性”而不是“自动化”</li>\n</ul>\n<p>很多在 SaaS 下理所当然的假设，在私有化环境中都会失效。</p>\n<p><strong>它们不是同一个产品，只是共享了一部分代码。</strong></p>\n<hr />\n<h3 id=\"坑五忽视非功能需求的长期成本\">坑五：忽视“非功能需求”的长期成本</h3>\n<p>性能、稳定性、可观测性、安全性，<br />\n这些东西在需求评审时，往往排在最后。</p>\n<p>但在客服系统里，它们会以一种非常直接的方式反噬你：</p>\n<ul>\n<li>一次卡顿，就可能造成大量负面体验</li>\n<li>一次异常，客服就会怀疑“是不是系统问题”</li>\n<li>一次数据异常，信任成本要用很久才能修复</li>\n</ul>\n<p>我在 2025 年学到的最重要一课是：</p>\n<blockquote>\n<p><strong>非功能需求不是“以后再补”的东西，<br />\n它们决定了你以后还有没有机会补。</strong></p>\n</blockquote>\n<hr />\n<h2 id=\"四产品层面的-3-个反直觉认知\">四、产品层面的 3 个反直觉认知</h2>\n<p>在 2025 年之前，我对“做产品”这件事，多少还带着一点工程师式的理想主义。<br />\n但真正把一个系统放进长期、真实使用场景后，很多直觉其实是错的。</p>\n<p>下面这 3 个认知，都是踩坑之后才慢慢形成的。</p>\n<hr />\n<h3 id=\"认知一用户真正渴望的不是更多能力而是更少意外\">认知一：用户真正渴望的，不是“更多能力”，而是“更少意外”</h3>\n<p>在做客服系统之前，我也以为：</p>\n<blockquote>\n<p>功能多一点，总是好的。</p>\n</blockquote>\n<p>但真实情况恰恰相反。</p>\n<p>对客服来说，一个“好用”的系统，往往意味着：</p>\n<ul>\n<li>今天和昨天的行为是一致的</li>\n<li>高峰期不会突然变慢</li>\n<li>操作之后的结果是可预期的</li>\n</ul>\n<p>他们并不关心系统“还能不能再多做点事”，<br />\n他们更关心的是：</p>\n<blockquote>\n<p><strong>它会不会在关键时刻出问题。</strong></p>\n</blockquote>\n<p>很多功能一旦进入真实使用场景，就会暴露出维护成本、理解成本、误操作成本。<br />\n这些成本，不会出现在 PRD 里，但会长期存在于用户的心理负担中。</p>\n<hr />\n<h3 id=\"认知二真正能被长期使用的系统往往是没有存在感的\">认知二：真正能被长期使用的系统，往往是“没有存在感”的</h3>\n<p>这是一个很反产品直觉的结论。</p>\n<p>我们习惯于强调：</p>\n<ul>\n<li>易用性</li>\n<li>交互细节</li>\n<li>视觉反馈</li>\n</ul>\n<p>但在客服系统这种<strong>高频、长时间使用</strong>的产品里，<br />\n“存在感”本身，反而是一种负担。</p>\n<p>当系统足够稳定、足够顺滑时，用户甚至不会意识到它在“帮忙”。<br />\n它更像空气或地面——<br />\n<strong>只有消失或出问题时，才会被注意到。</strong></p>\n<p>我后来发现，很多所谓的“高级设计”，<br />\n在长期使用中都会被用户下意识地绕开。</p>\n<hr />\n<h3 id=\"认知三对中小团队来说可控性往往比自动化更重要\">认知三：对中小团队来说，“可控性”往往比“自动化”更重要</h3>\n<p>在产品设计层面，“自动化”听起来永远是正确方向。<br />\n但在真实环境中，它是有前提的。</p>\n<p>对中小团队而言：</p>\n<ul>\n<li>人少，但责任清晰</li>\n<li>出问题时，希望知道“哪里坏了”</li>\n<li>更愿意手动介入，而不是面对黑盒</li>\n</ul>\n<p>这意味着：</p>\n<ul>\n<li>清晰的状态</li>\n<li>可追溯的操作</li>\n<li>可解释的结果</li>\n</ul>\n<p>往往比“全自动”更有价值。</p>\n<p>我在 2025 年最大的转变之一，是开始主动压制某些看起来很“聪明”的设计，<br />\n转而强调：</p>\n<blockquote>\n<p><strong>系统是否让人安心。</strong></p>\n</blockquote>\n<hr />\n<h2 id=\"五2025-年我对-升讯威在线客服与营销系统-的几个关键取舍\">五、2025 年我对 升讯威在线客服与营销系统 的几个关键取舍</h2>\n<p>在前面的章节里，我提到过不少“坑”和认知转变。<br />\n但如果这些东西不能反映到具体决策中，它们就只是感悟。</p>\n<p>2025 年，对 升讯威在线客服与营销系统 来说，不是快速扩张的一年，<br />\n而是一年持续做选择、并且<strong>不断否定“看起来更诱人方案”</strong>的过程。</p>\n<p>下面这几个取舍，基本决定了它今天的形态。</p>\n<hr />\n<h3 id=\"取舍一同时提供-saas-和私有化而不是二选一\">取舍一：同时提供 SaaS 和私有化，而不是二选一</h3>\n<p>这是一个从一开始就很“反效率”的决定。</p>\n<p>从纯开发成本看，<br />\nSaaS + 私有化意味着：</p>\n<ul>\n<li>两套部署逻辑</li>\n<li>更多环境差异</li>\n<li>更高的维护复杂度</li>\n</ul>\n<p>但真实需求非常明确：</p>\n<ul>\n<li>有些团队需要“即开即用”</li>\n<li>有些团队必须“完全可控”</li>\n</ul>\n<p>我不想用一种模式去强迫所有人适应。</p>\n<p>最终的取舍是：<br />\n<strong>共享核心能力，但承认它们是两类不同用户。</strong></p>\n<p>这也直接影响了后面很多架构决策。</p>\n<hr />\n<h3 id=\"取舍二克制功能扩张把精力花在系统边界上\">取舍二：克制功能扩张，把精力花在“系统边界”上</h3>\n<p>在 2025 年，我刻意放慢了新增功能的节奏。</p>\n<p>不是因为没想法，<br />\n而是越来越清楚：</p>\n<blockquote>\n<p>客服系统真正的复杂度，不在功能数量，而在系统边界。</p>\n</blockquote>\n<p>比如：</p>\n<ul>\n<li>哪些状态是“强一致”的</li>\n<li>哪些问题必须在服务端解决</li>\n<li>哪些异常可以交给人工兜底</li>\n</ul>\n<p>这些决定，远比“加一个新功能”更影响长期体验。</p>\n<p>很多时候，我选择<strong>不做</strong>，<br />\n而不是做一个“可能有用”的功能。</p>\n<hr />\n<h3 id=\"取舍三优先工程可诊断性而不是全自动体验\">取舍三：优先工程可诊断性，而不是“全自动体验”</h3>\n<p>这是一个非常工程师导向的选择。</p>\n<p>在 升讯威在线客服与营销系统 中，我把相当一部分精力，<br />\n投入到了普通用户几乎看不到的地方：</p>\n<ul>\n<li>更清晰的日志结构</li>\n<li>更明确的错误分类</li>\n<li>更可追溯的会话和事件链路</li>\n</ul>\n<p>这意味着：</p>\n<ul>\n<li>短期内体验并不会“惊艳”</li>\n<li>但一旦出问题，更容易被定位和解释</li>\n</ul>\n<p>对我来说，这比“自动处理一切”更重要。</p>\n<hr />\n<h3 id=\"取舍四国际化不是加语言包而是提前约束设计\">取舍四：国际化不是“加语言包”，而是提前约束设计</h3>\n<p>在 2025 年，我开始认真推进国际化相关工作。</p>\n<p>但这个过程很快让我意识到：<br />\n国际化并不是后期优化，而是<strong>设计约束</strong>。</p>\n<ul>\n<li>文案长度</li>\n<li>时间与时区</li>\n<li>权限与角色命名</li>\n<li>默认行为假设</li>\n</ul>\n<p>这些一旦在早期写死，后期改动成本会非常高。</p>\n<p>所以在 升讯威在线客服与营销系统 中，<br />\n我宁愿慢一点，也要避免“只为单一市场优化”的捷径。</p>\n<hr />\n<h3 id=\"取舍五把-升讯威在线客服与营销系统-当成一个长期系统而不是可卖的功能集合\">取舍五：把 升讯威在线客服与营销系统 当成一个长期系统，而不是“可卖的功能集合”</h3>\n<p>这是所有取舍背后的底层判断。</p>\n<p>如果目标是尽快卖掉，<br />\n有很多更聪明、更激进的做法。</p>\n<p>但在 2025 年，我更关心的是：</p>\n<ul>\n<li>它能不能在真实环境中稳定跑几年</li>\n<li>它是否经得起不断有人接手、维护</li>\n<li>它会不会在某一天变成“没人敢动的系统”</li>\n</ul>\n<p>这决定了我对技术债、对重构、对节奏的态度。</p>\n<hr />\n<h2 id=\"六2026我打算继续做的-3-件小而确定的事\">六、2026：我打算继续做的 3 件“小而确定的事”</h2>\n<p>如果说 2025 年是一个不断做减法、校正方向的年份，<br />\n那对 2026 年，我反而没有太多宏大的规划。</p>\n<p>不是因为没有野心，<br />\n而是越来越清楚：</p>\n<blockquote>\n<p>在一个长期系统里，<br />\n<strong>真正重要的不是“下一步有多远”，而是“这一步能不能站稳”。</strong></p>\n</blockquote>\n<p>所以在 2026 年，我给自己定下的目标非常克制，只做三件“小而确定”的事。</p>\n<hr />\n<h3 id=\"第一件事把稳定从结果变成能力\">第一件事：把“稳定”从结果，变成能力</h3>\n<p>在 2025 年，稳定更多是一个结果导向的判断：<br />\n“最近没出什么大问题”。</p>\n<p>但到了 2026 年，我希望把它前移，变成一种<strong>系统能力</strong>：</p>\n<ul>\n<li>问题是否能被提前发现</li>\n<li>异常是否有明确归因</li>\n<li>在不同环境下，行为是否可预测</li>\n</ul>\n<p>这意味着我会继续投入在：</p>\n<ul>\n<li>更完整的可观测性</li>\n<li>更明确的系统状态模型</li>\n<li>更保守、但可验证的变更策略</li>\n</ul>\n<p>稳定不应该依赖“经验和小心”，<br />\n而应该来自<strong>结构本身</strong>。</p>\n<hr />\n<h3 id=\"第二件事把国际化真正跑一遍而不是支持一下\">第二件事：把国际化真正跑一遍，而不是“支持一下”</h3>\n<p>在 2025 年，国际化更多是设计层面的准备。<br />\n到了 2026 年，我希望让它进入真实运行状态。</p>\n<p>这包括：</p>\n<ul>\n<li>真正的非中文用户</li>\n<li>真正不同的使用习惯</li>\n<li>真正不同的部署环境</li>\n</ul>\n<p>而不是只停留在“可以切换语言”。</p>\n<p>这一步不一定会带来明显增长，<br />\n但它会非常清楚地暴露：</p>\n<blockquote>\n<p>升讯威在线客服与营销系统 的哪些设计是通用的，<br />\n哪些其实是隐含假设。</p>\n</blockquote>\n<hr />\n<h3 id=\"第三件事更明确地知道谁不适合用-升讯威在线客服与营销系统\">第三件事：更明确地知道“谁不适合用 升讯威在线客服与营销系统”</h3>\n<p>这是一个看起来有些反商业，但我认为非常必要的目标。</p>\n<p>在 2026 年，我希望能更清楚地回答一个问题：</p>\n<ul>\n<li><strong>什么样的团队，用 升讯威在线客服与营销系统 会很舒服</strong></li>\n<li><strong>什么样的团队，用它反而会痛苦</strong></li>\n</ul>\n<p>这包括：</p>\n<ul>\n<li>技术能力与期望的匹配</li>\n<li>对可控性 vs 自动化的偏好</li>\n<li>对私有化与合规的真实需求</li>\n</ul>\n<p>一个产品如果试图取悦所有人，<br />\n最终往往谁都留不住。</p>\n<hr />\n<h2 id=\"七结尾给同样在慢慢做事的人\">七、结尾：给同样在“慢慢做事”的人</h2>\n<p>写到这里，其实已经很清楚了。<br />\n这不是一篇“阶段性胜利”的复盘，也不是某种成功经验。</p>\n<p>它更像是一次记录：<br />\n在一个不再奖励冲动和幻想的阶段，<br />\n一个人如何选择继续把事情做好。</p>\n<hr />\n<p>在 2025 年，我越来越少问自己：</p>\n<ul>\n<li>这个方向是不是风口</li>\n<li>这个产品能不能快速放大</li>\n</ul>\n<p>而是反复确认一些更朴素的问题：</p>\n<ul>\n<li>它是不是在解决真实问题</li>\n<li>它有没有在变得更稳定</li>\n<li>如果明年继续做，我是否还能心安</li>\n</ul>\n<p>很多时候，继续做下去，并不是因为看到了希望，<br />\n而是因为<strong>已经看清了现实，仍然觉得值得</strong>。</p>\n<hr />\n<p>如果你也在做一个进展缓慢、反馈稀疏、很难被外人理解的项目，<br />\n那你大概能体会这种状态：</p>\n<ul>\n<li>每一步都很小</li>\n<li>每一次改动都要反复权衡</li>\n<li>很难兴奋，但也不再轻易动摇</li>\n</ul>\n<p>这并不浪漫，<br />\n但它可能是少数真正可持续的节奏。</p>\n<hr />\n<p>我不确定 升讯威在线客服与营销系统 会走到哪一步，<br />\n也不打算在这里承诺什么结果。</p>\n<p>我能确定的只有一件事：</p>\n<blockquote>\n<p><strong>它至少是按照我能长期负责的方式，被认真对待的。</strong></p>\n</blockquote>\n<p>如果你刚好也在寻找一个<br />\n可控、工程友好、愿意陪你走很久的客服系统，<br />\n你大概能理解我为什么会把它做成现在这个样子。</p>\n<p>项目叫 <strong>升讯威在线客服与营销系统</strong>。</p>\n<p>如果没有，也没关系。<br />\n能在这个阶段，继续慢慢把事做好，本身就已经很难得了。</p>\n<hr />\n<h2 id=\"独立者的产品成果\">独立者的产品成果</h2>\n<blockquote>\n<p><a href=\"https://kf.shengxunwei.com\" rel=\"noopener nofollow\" target=\"_blank\">https://kf.shengxunwei.com</a></p>\n</blockquote>\n<p><strong>可全天候 7 × 24 小时挂机运行，网络中断，拔掉网线，手机飞行模式，不掉线不丢消息，欢迎实测。</strong></p>\n<h3 id=\"访客端轻量直观秒级响应的沟通入口\">访客端：轻量直观、秒级响应的沟通入口</h3>\n<p>访客端是客户接触企业的第一窗口，我们精心打磨每一处交互细节，确保用户无需任何学习成本即可发起对话。无论是嵌入式聊天窗口、悬浮按钮，还是移动端自适应支持，都实现了真正的“即点即聊”。系统支持智能欢迎语、来源识别、设备类型判断，可自动记录访客路径并呈现于客服端，帮助企业更好地理解用户意图。在性能方面，访客端采用异步加载与自动重连机制，即使网络波动也能保障消息顺畅送达，真正做到——轻量不失稳定，简单不失智能。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/78019/202506/78019-20250601110426304-100322970.png\" /></p>\n<h3 id=\"客服端软件为高效率沟通而生\">客服端软件：为高效率沟通而生</h3>\n<p>客服端是客服人员的作战平台，我们构建了一个专注、高效、响应迅速的桌面级体验。系统采用多标签会话设计，让客服可同时处理多组对话；访客轨迹、历史会话、地理位置、设备信息、来源渠道等关键信息一目了然，协助客服快速做出判断。内置快捷回复、常用文件、表情支持和智能推荐功能，大幅降低重复劳动成本。同时，系统还支持智能分配、会话转接、转人工、自定义状态等多种机制，保障团队协作流畅，让客服不仅能应对高峰，更能稳定交付满意度。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/78019/202506/78019-20250601110431346-1228494411.png\" /></p>\n<h3 id=\"web-管理后台\">Web 管理后台：</h3>\n<p>Web 管理后台是企业对客服系统的“驾驶舱”，从接入配置、坐席管理，到数据统计、权限控制，一切尽在掌握。你可以灵活设置接待策略、工作时间、转接规则，支持按部门/标签/渠道精细分配访客，满足复杂业务场景。系统还内置访问监控、聊天记录检索、客服绩效统计、错失会话提醒等运营级功能，助力管理者洞察服务瓶颈，持续优化资源配置。支持私有化部署、分权限管理、日志记录与数据导出，为追求安全性与高可控性的企业，提供真正“掌握在自己手里的客服系统”。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/78019/202506/78019-20250601110403917-63642615.png\" /></p>\n<h2 id=\"希望能够打造-开放开源共享努力打造一款优秀的社区开源产品\">希望能够打造： 开放、开源、共享。努力打造一款优秀的社区开源产品。</h2>\n<p>钟意的话请给个赞支持一下吧，谢谢~</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-02 15:02</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sheng_chao\">升讯威在线客服系统</a>&nbsp;\n阅读(<span id=\"post_view_count\">97</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "2025年终总结——在奔跑中前行",
      "link": "https://www.cnblogs.com/lucky_hu/p/19430418",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lucky_hu/p/19430418\" id=\"cb_post_title_url\" title=\"发布于 2026-01-01 17:27\">\n    <span>2025年终总结——在奔跑中前行</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h3 id=\"导航\">导航</h3>\n<ul>\n<li>前言</li>\n<li>职场人的核心竞争力是什么</li>\n<li>拥抱AI，拥抱大模型</li>\n<li>尝试自媒体</li>\n<li>读毛选</li>\n<li>写过的文章</li>\n<li>结语</li>\n<li>参考</li>\n</ul>\n<br />\n<section>\n    <a href=\"https://img.zhikestreet.com/2026-01-01_165557_428.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" rel=\"noopener nofollow\"><img alt=\"\" src=\"https://img.zhikestreet.com/2026-01-01_165557_428.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></a>\n</section> \n<br />\n<h3 id=\"前言\">前言</h3>\n<blockquote>\n<p>不是先学好了再干，而是干起来再学习，干就是学习。——《毛选》</p>\n</blockquote>\n<p>2025年，对于笔者而言，是极不平凡的一年。</p>\n<p>这一年，有快乐、有焦虑、有遗憾、有成长。</p>\n<p><strong>忙碌了一整年，回顾了这一年的经历，笔者对主要工作做了梳理和总结，同时要有一些自己的感悟,或许能与您产生共鸣。</strong></p>\n<h3 id=\"职场人的核心竞争力是什么\">职场人的核心竞争力是什么</h3>\n<blockquote>\n<p>对大部分企业而言，增长才是的核心竞争力,技术不是。</p>\n</blockquote>\n<p>在很多年的技术职业生涯中，笔者曾坚定地认为把产品做好，技术方案做好，兢兢业业，持续迭代，就一定能赢得公司的认可。(请参考<a href=\"https://www.52interview.com/solutions/31\" rel=\"noopener nofollow\" target=\"_blank\">《技术更迭，一往无前》</a>)</p>\n<p>然而,随着工作年限的增长,发现很多企业并不这么认为。他们更看重的是业绩的增长,技术只是实现增长的手段之一。</p>\n<p><strong>结论：让业绩增长才是职场人的核心竞争力。</strong></p>\n<h3 id=\"拥抱ai拥抱大模型\">拥抱AI，拥抱大模型</h3>\n<blockquote>\n<p>一定不能让自己被AI列车甩下，无论是玩还是工作，一定要经常使用它们。</p>\n</blockquote>\n<p>2025年的年初，deepseek-r1的强势发布，让AI大模型在业界引起了轩然大波，各个行业开始纷纷拥抱AI大模型。</p>\n<p>2025年的年末，Manus被Meta收购，在科技界十分轰动。</p>\n<p>过去，我们认为AI只是个玩具，离自己很远。</p>\n<p>而现在，它已经能够做具体的工作了。</p>\n<h3 id=\"尝试自媒体\">尝试自媒体</h3>\n<blockquote>\n<p>转型，不一定非的转行。</p>\n</blockquote>\n<p>2025年的国庆节后，笔者开始做视频号。</p>\n<p>主要基于两点考虑：</p>\n<ul>\n<li>希望能够突破自我，拓宽自己的视野。</li>\n<li>培养兴趣、爱好，丰富自己的生活。</li>\n</ul>\n<p>干技术工作十几年了，如果只是沉浸在技术领域,那未免有些枯燥。<br />\n何况，生活不止是工作，还有诗和远方。</p>\n<br />\n<section>\n    <a href=\"https://img.zhikestreet.com/2026-01-01_160015_444-min.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" rel=\"noopener nofollow\"><img alt=\"\" src=\"https://img.zhikestreet.com/2026-01-01_160015_444-min.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></a>\n</section> \n<br />\n<br />\n<section>\n    <a href=\"https://img.zhikestreet.com/2026-01-01_160113_397.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" rel=\"noopener nofollow\"><img alt=\"\" src=\"https://img.zhikestreet.com/2026-01-01_160113_397.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></a>\n</section> \n<br />\n<p>做视频很花心思，也很有挑战性，也没啥收益。<br />\n每次期待有粉丝关注，也算是一种成就感。</p>\n<h3 id=\"读毛选\">读毛选</h3>\n<blockquote>\n<p>内心强大才是真正的强大。</p>\n</blockquote>\n<p>2025年，职场遭遇困境，几乎快要到了面临抉择的时候，笔者开始阅读《毛选》。<br />\n就这样，深一脚，浅一脚挺了过来。</p>\n<p>不管是企业还是个人，都有遇到困难的时候。</p>\n<p>有时候，逃避问题很容易，直面问题需要莫大的勇气。</p>\n<p>\"贵人成全你，小人成就你。\"，经历过风雨的人，深有感受。</p>\n<section>\n    <a href=\"https://img.zhikestreet.com/20260101162415_666_2-min.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" rel=\"noopener nofollow\"><img alt=\"\" src=\"https://img.zhikestreet.com/20260101162415_666_2-min.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></a>\n</section> \n<br />\n<section>\n    <a href=\"https://img.zhikestreet.com/1767255242289-min.jpg?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" rel=\"noopener nofollow\"><img alt=\"\" src=\"https://img.zhikestreet.com/1767255242289-min.jpg?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></a>\n</section> \n<br />\n<h3 id=\"写过的文章\">写过的文章</h3>\n<blockquote>\n<p>经验创造价值，分享成就未来。</p>\n</blockquote>\n<ul>\n<li><a href=\"https://www.cnblogs.com/lucky_hu/collections/29080\" target=\"_blank\">《AI工作流实战》</a></li>\n</ul>\n<br />\n<section>\n    <a href=\"https://www.52interview.com/book/100\" rel=\"noopener nofollow\"><img alt=\"\" src=\"https://img.zhikestreet.com/2026-01-01_164320_875.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></a>\n</section> \n<br />\n<h3 id=\"结语\">结语</h3>\n<blockquote>\n<p>我们都在奔跑,但是短暂地停下来思考,是为了更好地再出发。</p>\n</blockquote>\n<p>过去的一年，为了\"柴米油盐、三餐四季\"忙碌奔波。</p>\n<p>新的一年，希望可以多一点战略思考，发掘更多个人的潜力和强项，突破发展瓶颈，找到属于自己的赛道。</p>\n<p>以上只是笔者个人的一点点浅见,有理解不对的地方，请大家多多包含和指正。</p>\n<h3 id=\"致谢\">致谢</h3>\n<p>最后，分享一首《踏莎行·元旦》，祝您在新的一年里，一路向阳，温暖前行，万事无忧。</p>\n<blockquote>\n<p>爆竹庭前，树桃门右。香汤浴罢，五更后。高烧银烛，瑞烟喷金兽。萱堂次第了，相为寿。<br />\n改岁宜新、应时纳祐。从今诸事愿、胜如旧。人生强健，喜一年入手。休辞最后饮，酴酥酒。</p>\n</blockquote>\n<br />\n<section>\n <a href=\"https://www.52interview.com/\" rel=\"noopener nofollow\" target=\"_blank\"><img alt=\"\" src=\"https://img.zhikestreet.com/20210522-22216942.jpg\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></a>\n</section> \n<br />\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-01 17:27</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lucky_hu\">楠木大叔</a>&nbsp;\n阅读(<span id=\"post_view_count\">142</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "实用程序：解放双手！Python 打造 PDF 手写模拟器，轻松搞定手写作业",
      "link": "https://www.cnblogs.com/ChenAI-TGF/p/19430267",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ChenAI-TGF/p/19430267\" id=\"cb_post_title_url\" title=\"发布于 2026-01-01 15:59\">\n    <span>实用程序：解放双手！Python 打造 PDF 手写模拟器，轻松搞定手写作业</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文介绍了一款基于Python开发的PDF手写模拟工具，可自动将电子文本转换为逼真手写效果并填充至PDF指定区域。该工具支持中英文独立配置字体、大小、颜色等参数，通过随机扰动算法模拟真实手写的行倾斜、字符偏移等不规则特性。用户可通过可视化界面框选填写区域、实时预览效果并保存配置模板。技术实现采用PyMuPDF处理PDF核心操作，结合tkinter构建GUI界面，Pillow实现图像渲染。开源项目地址已提供，可帮助学生高效完成手写作业需求，显著提升工作效率。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"前言\">前言</h1>\n<p>作为学生，想必大家都有过被海量手写实验报告、课程作业支配的痛苦。要花费大量时间一笔一划地抄写到纸质文档中再进行扫描成pdf提交，不仅耗时耗力，手写的字迹还可能参差不齐，影响作业美观度。</p>\n<p>为了偷懒，博主开发了一款基于python的PDF手写模拟器，它能够模拟真实手写笔迹，将电脑上的文字批量填充到 PDF 指定区域，支持中文/英文分开配置、手写扰动效果自定义、配置模版复用等功能，生成的效果高度贴近真实手写，帮你彻底告别手动抄写的烦恼。首先来个界面以及效果预览：</p>\n<p><strong>代码已经开源在Github：<a href=\"https://github.com/ChenAI-TGF/PDF_HandWrite\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/ChenAI-TGF/PDF_HandWrite</a><br />\n欢迎大家下载，如果觉得有用的话可以给我点个Star，万分感谢！！<br />\n如果登不上Github的话也欢迎直接私信博主要代码</strong></p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h2 id=\"流程思路总览\">流程思路总览</h2>\n<p>这款 PDF 手写模拟器的整体运作流程可以分为「用户操作流程」和「技术实现流程」两层，清晰易懂：</p>\n<h2 id=\"1--用户操作流程简单易上手\">1.  用户操作流程（简单易上手）</h2>\n<ol>\n<li>\n<p>打开目标 PDF：选择需要填写的实验报告、作业等 PDF 文件；<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /><br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>框选填写区域：在 PDF 预览界面拖动鼠标，框选出需要插入文字的区域（红色矩形标记）；<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>配置手写参数：分别在中文、英文/数字选项卡中调整字体、大小、颜色、扰动效果等参数；<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>输入并预览文字：在右侧文本框输入需要填写的内容，开启「实时预览」查看手写效果；<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /><br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>不满意可实时调整参数<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>确认并保存：效果满意后确认应用笔迹，支持撤销、擦除错误内容，也可保存当前配置为模版，最后导出填写完成的 PDF。</p>\n</li>\n</ol>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"2--技术实现流程分层协作\">2.  技术实现流程（分层协作）</h3>\n<ol>\n<li>UI 交互层：基于 tkinter 搭建可视化界面，提供按钮、选项卡、文本框等交互组件，接收用户操作；</li>\n<li>参数配置层：管理中文/英文手写参数，支持配置保存（JSON）与加载，实现模版复用；</li>\n<li>PDF 操作层：基于 PyMuPDF 实现 PDF 的读取、页面渲染、文字插入、擦除、保存等核心操作；</li>\n<li>手写渲染层：核心逻辑层，实现文字排版、语言区分、手写扰动效果生成，最终将模拟手写文字插入 PDF。</li>\n</ol>\n<pre><code class=\"language-bash\">┌─────────────────────┐\n│  UI交互层（tkinter） │  # 可视化交互，接收操作\n└─────────────┬───────┘\n              ▼\n┌─────────────────────┐\n│  参数配置层（JSON）  │  # 参数管理，模版复用\n└─────────────┬───────┘\n              ▼\n┌─────────────────────┐\n│ PDF操作层（PyMuPDF） │  # PDF核心操作（读写/保存等）\n└─────────────┬───────┘\n              ▼\n┌─────────────────────┐\n│  手写渲染层（核心）  │  # 手写效果生成，文字插入\n└─────────────────────┘\n</code></pre>\n<h1 id=\"涉及的具体技术\">涉及的具体技术</h1>\n<p>这款工具基于 Python 生态的常用库开发，技术栈轻量化且实用性强，核心涉及以下技术：</p>\n<ol>\n<li><strong>tkinter</strong>：Python 内置 GUI 库，无需额外安装，负责搭建整个应用的可视化界面，实现按钮点击、参数调整、文本输入、PDF 预览等交互功能；</li>\n<li><strong>PyMuPDF（fitz）</strong>：核心 PDF 处理库，提供高效的 PDF 读取、写入、页面渲染、文字插入、红act标注（擦除功能）等接口，是实现 PDF 编辑的核心依赖；</li>\n<li><strong>Pillow（PIL）</strong>：图像处理库，将 PyMuPDF 渲染出的 PDF 页面像素数据，转换成 tkinter 画布可显示的图像格式，实现 PDF 页面的可视化预览；</li>\n<li><strong>JSON</strong>：轻量级数据格式，用于保存用户配置的手写参数模版（字体、大小、扰动值等），方便后续直接复用，无需重复调整；</li>\n<li><strong>Python 随机数与数学计算</strong>：实现手写效果的「不规则扰动」，模拟真实手写的位置偏移、大小波动、行倾斜等特性；</li>\n<li><strong>TTF 字体支持</strong>：读取自定义 TrueType 字体文件，支持切换不同手写风格字体，适配不同用户的手写习惯。</li>\n</ol>\n<h1 id=\"最终效果演示\">最终效果演示</h1>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h1 id=\"代码原理简单讲解手写字体生成--扰动效果\">代码原理简单讲解（手写字体生成 + 扰动效果）</h1>\n<p>我们重点讲解核心功能 —— 手写字体生成与扰动效果的实现，忽略 UI 搭建等辅助代码，聚焦核心逻辑：</p>\n<h2 id=\"一-手写字体生成文字插入-pdf-核心\">一、 手写字体生成（文字插入 PDF 核心）</h2>\n<p>这部分的核心是将文字按规则排版后，插入到 PDF 指定区域，关键步骤如下：</p>\n<ol>\n<li>\n<p><strong>文字与区域预处理</strong><br />\n首先获取文本框中的输入文字，按换行符 <code>\\n</code> 分割成多行，同时将用户框选的预览区域坐标（带缩放比例）转换为 PDF 实际坐标（除以缩放系数 <code>self.zoom</code>），得到真实的填写范围 <code>(x1, y1, x2, y2)</code>。</p>\n<pre><code class=\"language-python\"># 读取输入文字并分割行\ntext = self.text_editor.get(\"1.0\", tk.END).strip(\"\\n\")\nlines = text.split('\\n')\n# 转换为 PDF 实际坐标（去除预览缩放影响）\nx1, y1 = min(self.start_x, self.end_x)/self.zoom, min(self.start_y, self.end_y)/self.zoom\nx2, y2 = max(self.start_x, self.end_x)/self.zoom, max(self.start_y, self.end_y)/self.zoom\n</code></pre>\n</li>\n<li>\n<p><strong>语言区分与参数匹配</strong><br />\n通过 <code>is_chinese</code> 函数判断单个字符是中文还是英文/数字，分别匹配对应的配置参数（中文/英文独立的字体、大小、字距等），确保不同语言的手写效果适配合理。</p>\n<pre><code class=\"language-python\"># 判断是否为中文（含中文标点）\ndef is_chinese(self, char):\n    if '\\u4e00' &lt;= char &lt;= '\\u9fff': return True\n    if char in \"。，、？！：；“”‘’（）《》【】\": return True\n    return False\n\n# 遍历字符时匹配对应语言参数\nlang = 'zh' if self.is_chinese(char) else 'en'\np = self.params[lang]  # 获取对应语言的配置参数\n</code></pre>\n</li>\n<li>\n<p><strong>PDF 文字插入核心 API</strong><br />\n使用 PyMuPDF 的 <code>page.insert_text</code> 方法实现文字插入，这是手写字体生成的关键，核心参数说明如下：</p>\n<ul>\n<li><code>fitz.Point(final_x, final_y)</code>：文字的实际插入坐标（经排版和扰动调整后）；</li>\n<li><code>char</code>：要插入的单个字符（逐字符插入实现精细排版）；</li>\n<li><code>fontsize</code>：字符的实际大小（带大小抖动）；</li>\n<li><code>fontfile</code>：TTF 手写字体文件路径，决定字体风格；</li>\n<li><code>color</code>：文字颜色（默认纯黑，支持用户自定义）；</li>\n<li><code>morph</code>：变换矩阵，实现字符旋转效果（叠加行倾斜与字符旋转抖动）。</li>\n</ul>\n</li>\n<li>\n<p><strong>行与字符排版</strong><br />\n按行遍历文字，逐字符计算插入坐标，处理空格（单独预留间距），当字符横坐标超出框选区域右侧时自动换行，同时根据「行距参数」调整下一行的纵坐标，确保文字排版规整且不超出框选范围。</p>\n</li>\n</ol>\n<h2 id=\"二-扰动效果实现模拟真实手写不规则性\">二、 扰动效果实现（模拟真实手写不规则性）</h2>\n<p>这是工具的灵魂所在，通过「行级扰动」和「字符级扰动」两层效果，彻底摆脱打印体的规整感，贴近真实手写，对应代码中的配置参数：</p>\n<ol>\n<li>\n<p><strong>行级扰动（整行不规则性）</strong><br />\n针对每一行文字，添加整体的偏移和倾斜，模拟手写时「行不直、略有偏移」的特点，对应三个参数：</p>\n<ul>\n<li>行左右平移（<code>line_jitter_x</code>）：随机生成 <code>-line_jitter_x ~ line_jitter_x</code> 范围内的偏移量 <code>line_dx</code>，使每行文字左右轻微晃动；</li>\n<li>行上下平移（<code>line_jitter_y</code>）：随机生成 <code>-line_jitter_y ~ line_jitter_y</code> 范围内的偏移量 <code>line_dy</code>，使行与行之间的间距略有差异；</li>\n<li>行整行倾斜（<code>line_tilt</code>）：随机生成倾斜角度 <code>line_angle_deg</code>，转换为弧度后，通过 <code>tilt_y_offset = (curr_x - line_start_x) * math.tan(line_angle_rad)</code> 计算每个字符的Y轴偏移，实现整行轻微倾斜。</li>\n</ul>\n<pre><code class=\"language-python\"># 行级扰动参数计算\nline_dx = random.uniform(-p_line['line_jitter_x'].get(), p_line['line_jitter_x'].get())\nline_dy = random.uniform(-p_line['line_jitter_y'].get(), p_line['line_jitter_y'].get())\nline_angle_deg = random.uniform(-p_line['line_tilt'].get(), p_line['line_tilt'].get())\nline_angle_rad = math.radians(line_angle_deg)\n</code></pre>\n</li>\n<li>\n<p><strong>字符级扰动（单个字符不规则性）</strong><br />\n针对每个字符，添加位置、大小、旋转的细微差异，模拟手写时「每个字大小不一、略有晃动」的特点，对应三个参数：</p>\n<ul>\n<li>字位置抖动（<code>jitter_pos</code>）：随机生成 <code>(-jitter_pos ~ jitter_pos)</code> 的X、Y偏移量，使字符脱离严格的水平对齐；</li>\n<li>字大小抖动（<code>jitter_size</code>）：在基础字体大小上，随机增减 <code>(-jitter_size ~ jitter_size)</code> 的数值，生成 <code>char_jitter_fs</code>，使字符大小略有差异；</li>\n<li>字旋转抖动（<code>jitter_rot</code>）：随机生成 <code>(-jitter_rot ~ jitter_rot)</code> 的旋转角度，叠加行倾斜角度后，通过 <code>morph</code> 参数实现字符轻微旋转。</li>\n</ul>\n<pre><code class=\"language-python\"># 字符级扰动参数计算\nchar_jitter_x = random.uniform(-p['jitter_pos'].get(), p['jitter_pos'].get())\nchar_jitter_y = random.uniform(-p['jitter_pos'].get(), p['jitter_pos'].get())\nchar_jitter_rot = random.uniform(-p['jitter_rot'].get(), p['jitter_rot'].get())\nchar_jitter_fs = f_size + random.uniform(-p['jitter_size'].get(), p['jitter_size'].get())\n</code></pre>\n</li>\n<li>\n<p><strong>随机数控制（预览稳定 + 实际随机）</strong><br />\n为了保证实时预览时效果稳定可调整，设置随机数种子 <code>random.seed(42)</code> 固定扰动效果；实际应用笔迹时，不设置种子 <code>random.seed()</code>，生成随机的扰动效果，让每次生成的手写风格略有差异，更贴近真实场景。</p>\n<pre><code class=\"language-python\">if is_preview: random.seed(42)  # 预览模式：固定随机数，效果稳定\nelse: random.seed()  # 实际生成：随机种子，效果更真实\n</code></pre>\n</li>\n</ol>\n<h1 id=\"总结\">总结</h1>\n<p>这款 PDF 手写模拟器完美解决了手写作业、实验报告的痛点，兼具「实用性」和「灵活性」：</p>\n<ol>\n<li><strong>实用性拉满</strong>：无需手动抄写，一键生成手写风格 PDF，节省大量时间和精力，生成效果高度贴近真实手写；</li>\n<li><strong>自定义性强</strong>：中文/英文独立配置，支持字体、颜色、大小、字距行距调整，多层扰动参数可精细调控手写风格；</li>\n<li><strong>操作便捷</strong>：可视化界面友好，支持实时预览、撤销、擦除、模版复用，零基础用户也能快速上手；</li>\n<li><strong>技术轻量化</strong>：基于 Python 常用库开发，无需复杂环境配置，代码可灵活修改扩展。</li>\n</ol>\n<p>当然，这款工具还有优化空间，比如支持连笔效果、笔迹粗细变化、批量处理多个 PDF 等。如果大家有类似需求，可以基于这份代码进行二次开发，适配自己的使用场景。希望这款工具能帮大家解放双手，把更多时间投入到核心学习和研究中！</p>\n<p><strong>代码已经开源在Github：<a href=\"https://github.com/ChenAI-TGF/PDF_HandWrite\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/ChenAI-TGF/PDF_HandWrite</a><br />\n欢迎大家下载，如果觉得有用的话可以给我点个Star，万分感谢！！<br />\n如果登不上Github的话也欢迎直接私信博主要代码</strong></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-01 15:59</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ChenAI-TGF\">TTGF</a>&nbsp;\n阅读(<span id=\"post_view_count\">109</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Perigon.CLI 10.0 重磅发布【AspNetCore开发模板和辅助工具】",
      "link": "https://www.cnblogs.com/msdeveloper/p/19430150/perigon-10-announce",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/msdeveloper/p/19430150/perigon-10-announce\" id=\"cb_post_title_url\" title=\"发布于 2026-01-01 15:18\">\n    <span>Perigon.CLI 10.0 重磅发布【AspNetCore开发模板和辅助工具】</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"-perigoncli-100-重磅发布\">🎉 Perigon.CLI 10.0 重磅发布</h1>\n<p><img alt=\"perigon_logo320\" src=\"https://img2024.cnblogs.com/blog/1074783/202601/1074783-20260101151334306-54452182.png\" /></p>\n<p>我们很高兴地宣布，Perigon.CLI 10.0 现已正式发布！此次更新带来了众多令人兴奋的新功能和改进，旨在提升开发者的生产力和开发体验。</p>\n<p>简而言之，Perigon是围绕<code>Aspire/AspNetCore/EF Core</code>等相关技术栈的开发辅助工具，帮助你快速构建可维护的项目，它主要提供：</p>\n<ul>\n<li><strong>项目脚手架</strong>：通过解决方案模板(Perigon.templates)，快速创建符合最佳实践的项目结构。</li>\n<li><strong>代码生成器</strong>：提供WebUI界面，用来通过实体来生成对应的增删改查代码，以及客户端请求服务的生成，极大减少重复劳动；同时提供自定义模板功能，满足不同项目需求。</li>\n<li><strong>MCP</strong>: 提供MCP支持，以与现有IDE中的AI集成。</li>\n<li><strong>命令行工具</strong>：用来创建解决方案/启动WebUI/生成客户端请求服务等。</li>\n</ul>\n<h2 id=\"由来\">由来</h2>\n<p>最初，它只是我个人在开发前后端项目时，为了减少重复劳动而开发的简单的项目分层脚手架和代码生成工具。当时(2020年)它叫<code>GT.CLI</code>和<code>GT.Framework.Web</code>。</p>\n<p>2021年，重构了结构，并开始在团队项目中使用，模板改名为<code>ater.web.templates</code>，CLI工具也经过两次大改，分别为<code>ater.droplet.cli</code>和<code>ater.dry</code>，它加入了一些公司内项目需求的功能，如提供更多开箱即用的模块。</p>\n<blockquote>\n<p>[!TIP]<br />\n以上工具可在<code>nuget</code>中找到，但都不再维护。</p>\n</blockquote>\n<h2 id=\"-现在\">✨ 现在</h2>\n<p>2025年.NET10发布，在年初，我开始计划进行全面的重构和优化，提供一个全新的版本，完全基于.NET10，不再兼容之前的版本，经过数月的开发和测试，最终发布了<code>Perigon.CLI</code>和<code>Perigon.templates</code>，该版本主要的特点包括：</p>\n<ul>\n<li>\n<p>操作界面从<code>Angular</code>改为<code>Blazer server</code>，使用<code>fluent-ui</code>组件库，从技术到视觉上都更贴近<code>NET</code>生态。</p>\n</li>\n<li>\n<p>在项目结构上，去复杂化，更加通用。去除了以下设计</p>\n<ul>\n<li><code>仓储模式</code></li>\n<li>默认使用<code>QueryDbContext</code>和<code>CommandDbContext</code>的设计，需要多一层DataAccess来抽象。</li>\n<li>默认生成业务接口类</li>\n<li><code>[Module]</code>特性，直接使用目录结构来区分模块</li>\n<li>其他不必要的抽象和复杂设计</li>\n</ul>\n</li>\n<li>\n<p>重构项目结构，并添加了更多通用和实用的功能</p>\n<ul>\n<li>引入Aspire：解决开发环境基础设施和多服务支持问题</li>\n<li>多服务支持：结合单体和微服务，一个解决方案都搞定</li>\n<li>多租户支持：通过配置在单租户和多租户间切换</li>\n<li>多数据库支持：通过工厂模式支持多种数据库</li>\n<li>多语言支持：内置多语言支持，方便国际化</li>\n<li>MCP支持：直接在IDE中调用工具生成代码</li>\n<li>源代码生成器支持(多语言和自动注入Manager)</li>\n</ul>\n</li>\n</ul>\n<p>更为重要的是，新版本确定了一些核心设计原则：</p>\n<ul>\n<li>通用且开放：不依托于特定设计模式或架构，优先使用通用且成熟的技术栈</li>\n<li>简单易用：不引入新的设计模式或理论，降低学习成本和心智负担</li>\n<li>以开发者为中心：提高开发效率和使用体验是主要目标</li>\n</ul>\n<p>现在，你可以通过我们的📚<a href=\"https://dusi.dev/docs/Perigon.html\" rel=\"noopener nofollow\" target=\"_blank\">官方文档</a>，了解如何安装和使用<code>Perigon.CLI</code>，并开始你的高效开发之旅！</p>\n<h2 id=\"未来\">🚀未来</h2>\n<p>未来将在三个方面持续改进：</p>\n<ul>\n<li>生产力。如今我们通过IDE和代码生成器避免重复性的工作。而今年使用code agent编程已经是非常平常的事情，其能力和效果无需多言，虽然还有些局限性，但其能力还在不断提升。我们会将更多AI编程的实践经验融入到工具中，进一步提升开发效率和开发体验。</li>\n<li>性能。在保持模板框架稳定的基础上，尽可能的提升性能，完善性能方面的最佳实践(文档说明)。</li>\n<li>生态。我们将基于<code>perigon</code>构建更多的内容，如身份验证系统，AIAgent系统等，也就是在基础框架的基础上，提供更多面向特定场景的解决方案。此外，还将尝试对模块进行打包和分发，进一步提高复用性和可维护性。</li>\n</ul>\n<h3 id=\"版本计划\">版本计划</h3>\n<p>对于<code>Perigon.CLI</code>，它将跟随<code>.NET</code>的版本迭代进行更新，计划每年发布一个大版本，单数版本会同时支持上一个LTS版本，偶数版本只支持当前LTS版本。</p>\n<p>对于``Perigon.templates<code>，它从</code>1.0.0`开始，由于它影响整个项目的结构和技术选型，未来主要专注于问题修复和性能提升。新的功能特性尽可能在不改变现有结构的前提下进行添加。</p>\n<h2 id=\"️️社区参与\">🏃‍♂️‍➡️社区参与</h2>\n<p>如果你对.NET开发有兴趣，并希望参与到Perigon.CLI的建设中来，欢迎访问我们的<a href=\"https://github.com/AterDev/Perigon.CLI\" rel=\"noopener nofollow\" target=\"_blank\">GitHub仓库</a>，提交你的想法、建议或贡献代码。我们期待与你一起打造更好的开发工具！</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-01 15:18</span>&nbsp;\n<a href=\"https://www.cnblogs.com/msdeveloper\">TypingLearn</a>&nbsp;\n阅读(<span id=\"post_view_count\">119</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "我为什么用死亡细胞练习 vim",
      "link": "https://www.cnblogs.com/young-tea/p/19433114",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/young-tea/p/19433114\" id=\"cb_post_title_url\" title=\"发布于 2026-01-03 01:04\">\n    <span>我为什么用死亡细胞练习 vim</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>我为什么用死亡细胞练习 vim</p>\n<p>本文主要分析了为什么死亡细胞比别的游戏更适合练习 vim.</p>\n<h1 id=\"首先放一下我的-vimrc\">首先放一下我的 <code>~/.vimrc</code></h1>\n<p>不多, 只有几行, 比较好记.</p>\n<pre><code class=\"language-vimrc\">set noexpandtab\nset nu\nset shiftwidth=8\nset smartindent\nset smarttab\nset tabstop=8\n</code></pre>\n<p>当然这篇网志也是用 vim 写的.</p>\n<h1 id=\"列举一下我玩的游戏\">列举一下我玩的游戏</h1>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\">游戏</th>\n<th style=\"text-align: center;\">维度</th>\n<th style=\"text-align: center;\">激烈程度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\">vim</td>\n<td style=\"text-align: center;\">2d</td>\n<td style=\"text-align: center;\">高???</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">死亡细胞</td>\n<td style=\"text-align: center;\">2d</td>\n<td style=\"text-align: center;\">高</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">俄罗斯方块</td>\n<td style=\"text-align: center;\">2d</td>\n<td style=\"text-align: center;\">低</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">永劫无间</td>\n<td style=\"text-align: center;\">3d</td>\n<td style=\"text-align: center;\">高</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">蛋仔派对</td>\n<td style=\"text-align: center;\">3d</td>\n<td style=\"text-align: center;\">低</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">英雄联盟</td>\n<td style=\"text-align: center;\">离谱</td>\n<td style=\"text-align: center;\">高</td>\n</tr>\n</tbody>\n</table>\n<p>可以看到, 死亡细胞和 vim 同属 2d 且激烈程度都很高.</p>\n<h1 id=\"维度差异\">维度差异</h1>\n<p>永劫无间和蛋仔派对作为 3d 游戏, 不止要操作角色的移动, 还要操作视角的移动.</p>\n<p>但 vim 作为文本编辑器, 可以认为是 2d 游戏, 只需要操作角色 (光标) 的移动, 视角会自动跟随, 所以在这里是俄罗斯方块和死亡细胞更占优势.</p>\n<h1 id=\"激烈程度\">激烈程度</h1>\n<p>为什么要提到激烈程度呢?</p>\n<p>像蛋仔派对 / 俄罗斯方块这种益智 / 养老游戏, 激烈程度不高, 主要是手眼协调和思维博弈 (真的需要思维博弈吗?), 对于操作的要求并不高. 这和我们激烈的编程是截然相反的.</p>\n<p>还有就是说, 在激烈的游戏里练习, 你会把这个技能慢慢变成你的本能反应, 也就是生物老师所谓的非条件反射, 电竞玩家所谓的肌肉记忆.</p>\n<h1 id=\"如何用死亡细胞练习-vim\">如何用死亡细胞练习 vim</h1>\n<p>首当其冲, 祖传的 <code>h</code> <code>j</code> <code>k</code> <code>l</code> 移动, 我们可以直接把 <code>w</code> <code>a</code> <code>s</code> <code>d</code> 给换成 <code>h</code> <code>j</code> <code>k</code> <code>l</code>.</p>\n<p>但是很显然 <code>h</code> <code>j</code> <code>k</code> <code>l</code> 应该用右手操作, 所以我们应该把攻击换成左手.</p>\n<p>可以想到英雄联盟使用 <code>q</code> <code>w</code> <code>e</code> <code>r</code> 释放技能, 那么我们也可以使用 <code>q</code> <code>w</code> 攻击, 用 <code>e</code> <code>r</code> 调用道具.</p>\n<p>别的 vim 操作当然也很有用, 但并不是简单的游戏就能带给你的, 可以多多查看 vim 文档.</p>\n\n</div>\n<div id=\"MySignature\">\n    原文来自CnBlogs, 作者: <a href=\"https://www.cnblogs.com/young-tea/\" target=\"_blank\">young_tea</a>.\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-03 01:04</span>&nbsp;\n<a href=\"https://www.cnblogs.com/young-tea\">young_tea</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Ubuntu22.04(ROS2 humble)小车仿真环境搭建",
      "link": "https://www.cnblogs.com/zylyehuo/p/19432794",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zylyehuo/p/19432794\" id=\"cb_post_title_url\" title=\"发布于 2026-01-02 21:16\">\n    <span>Ubuntu22.04(ROS2 humble)小车仿真环境搭建</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>博客地址：<a href=\"https://www.cnblogs.com/zylyehuo/\" target=\"_blank\">https://www.cnblogs.com/zylyehuo/</a></p>\n</blockquote>\n<p><img alt=\"a8acc3dc8de106604c18b89e5dc35252\" src=\"https://img2024.cnblogs.com/blog/3071480/202601/3071480-20260102210959528-798686129.jpg\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202601/3071480-20260102211243747-1304812705.png\" /></p>\n<h1 id=\"下载-mobile-3d-lidar-sim\">下载 mobile-3d-lidar-sim</h1>\n<blockquote>\n<p>mobile-3d-lidar-sim：ROS2 Humble 社区中最轻量、专门用于 3D 雷达 仿真的项目</p>\n</blockquote>\n<blockquote>\n<p>这个项目结构非常简单，只有一个机器人模型，且原生配置了 Velodyne 3D 雷达 插件。</p>\n</blockquote>\n<pre><code>mkdir -p ~/ros2/mobile-3d-lidar-sim/src\n\ncd ~/ros2/mobile-3d-lidar-sim/src\n\ngit clone https://github.com/louislelay/mobile-3d-lidar-sim.git\n\nsudo apt install ros-humble-velodyne-simulator -y\n\ncd ..\n\ncolcon build --symlink-install\n</code></pre>\n<h1 id=\"发布全局静态地图\">发布全局静态地图</h1>\n<pre><code>cd /home/zylyehuo/ros2/pcd2pgm_ws2/map/custom\n\nros2 run nav2_map_server map_server --ros-args -p yaml_filename:=drone_map_03.yaml -p use_sim_time:=true\n</code></pre>\n<pre><code>ros2 run nav2_lifecycle_manager lifecycle_manager --ros-args -p node_names:=\"['map_server']\" -p autostart:=true\n</code></pre>\n<pre><code>ros2 run tf2_ros static_transform_publisher 0 0 0 0 0 0 map odom\n</code></pre>\n<h1 id=\"发布局部代价地图\">发布局部代价地图</h1>\n<pre><code>cd /home/zylyehuo/ros2/ros2_lexi/src/lexigraph/scripts\n\npython3 ./my_costmap.py\n</code></pre>\n<h2 id=\"my_costmappy\">my_costmap.py</h2>\n<pre><code class=\"language-python\">#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nimport numpy as np\nfrom sensor_msgs.msg import PointCloud2\nfrom nav_msgs.msg import OccupancyGrid\nimport sensor_msgs_py.point_cloud2 as pc2\nfrom scipy.ndimage import distance_transform_edt\nfrom tf2_ros import TransformException\nfrom tf2_ros.buffer import Buffer\nfrom tf2_ros.transform_listener import TransformListener\n\nclass MapFixedCostmap(Node):\n    def __init__(self):\n        super().__init__('map_fixed_costmap_node')\n\n        # --- 参数配置 ---\n        self.declare_parameter('resolution', 0.05)      # 分辨率\n        self.declare_parameter('width_m', 20.0)         # 局部窗口在 map 中的大小\n        self.declare_parameter('inflation_r', 0.4)\n        self.declare_parameter('robot_r', 0.3)\n\n        self.res = self.get_parameter('resolution').value\n        self.width_m = self.get_parameter('width_m').value\n        self.inflation_r = self.get_parameter('inflation_r').value\n        self.robot_r = self.get_parameter('robot_r').value\n        self.grid_dim = int(self.width_m / self.res)\n\n        # --- TF 监听器 ---\n        self.tf_buffer = Buffer()\n        self.tf_listener = TransformListener(self.tf_buffer, self)\n\n        # --- 订阅与发布 ---\n        self.subscription = self.create_subscription(\n            PointCloud2, '/velodyne2/velodyne_points2', self.pc_callback, 10)\n        self.publisher = self.create_publisher(OccupancyGrid, '/my_costmap', 10)\n        \n        self.get_logger().info(\"Costmap Node Started: Fixed to MAP frame.\")\n\n    def pc_callback(self, msg):\n        try:\n            # 1. 获取机器人 (base_link) 在 map 系下的实时位置\n            try:\n                # 获取 map 到 base_link 的变换\n                t = self.tf_buffer.lookup_transform('map', 'base_link', rclpy.time.Time())\n                robot_x = t.transform.translation.x\n                robot_y = t.transform.translation.y\n            except TransformException as ex:\n                self.get_logger().warn(f'Could not transform base_link to map: {ex}')\n                return\n\n            # 2. 解析点云\n            gen = pc2.read_points(msg, field_names=(\"x\", \"y\", \"z\"), skip_nans=True)\n            points_list = list(gen)\n            if not points_list:\n                self.publish_empty_map(robot_x, robot_y)\n                return\n            \n            points = np.array([[p[0], p[1], p[2]] for p in points_list], dtype=np.float32)\n\n            # 3. 高度过滤\n            mask = (points[:, 2] &gt; 0.1) &amp; (points[:, 2] &lt; 1.2)\n            obs_points = points[mask]\n\n            # 4. 初始化栅格\n            grid = np.zeros((self.grid_dim, self.grid_dim), dtype=np.int8)\n            \n            # 这里的投影逻辑：\n            # 点云是在 body 系下的，要发布的地图在 map 系，\n            # 但栅格的内容依然是机器人观察到的局部障碍物。\n            # 将栅格的中心(cx, cy)对应机器人当前的 (robot_x, robot_y)\n            cx, cy = self.grid_dim // 2, self.grid_dim // 2\n            ix = (obs_points[:, 0] / self.res + cx).astype(int)\n            iy = (obs_points[:, 1] / self.res + cy).astype(int)\n\n            valid = (ix &gt;= 0) &amp; (ix &lt; self.grid_dim) &amp; (iy &gt;= 0) &amp; (iy &lt; self.grid_dim)\n            grid[iy[valid], ix[valid]] = 100\n\n            # 5. 膨胀\n            final_data = self.inflate_map(grid)\n\n            # 6. 发布 (传入机器人当前 map 坐标作为原点参考)\n            self.publish_map(final_data, robot_x, robot_y)\n\n        except Exception as e:\n            self.get_logger().error(f\"Error: {str(e)}\")\n\n    def inflate_map(self, grid):\n        if not np.any(grid == 100):\n            return grid.flatten().astype(np.int8)\n        dist_map = distance_transform_edt(grid != 100) * self.res\n        costmap = np.zeros_like(grid, dtype=np.int8)\n        costmap[dist_map &lt;= self.robot_r] = 100\n        inf_mask = (dist_map &gt; self.robot_r) &amp; (dist_map &lt;= self.inflation_r)\n        norm_dist = (dist_map[inf_mask] - self.robot_r) / (self.inflation_r - self.robot_r)\n        costmap[inf_mask] = (99 * np.exp(-5.0 * norm_dist)).astype(np.int8)\n        return costmap.flatten()\n\n    def publish_empty_map(self, rx, ry):\n        self.publish_map(np.zeros(self.grid_dim**2, dtype=np.int8), rx, ry)\n\n    def publish_map(self, data, rx, ry):\n        grid_msg = OccupancyGrid()\n        grid_msg.header.stamp = self.get_clock().now().to_msg()\n        grid_msg.header.frame_id = 'map'  # 固定在 map 系\n        \n        grid_msg.info.resolution = self.res\n        grid_msg.info.width = self.grid_dim\n        grid_msg.info.height = self.grid_dim\n        \n        # 将 OccupancyGrid 的原点动态设为机器人当前坐标减去地图一半\n        # 在 map 系下跟随机器人移动\n        grid_msg.info.origin.position.x = rx - (self.grid_dim * self.res) / 2.0\n        grid_msg.info.origin.position.y = ry - (self.grid_dim * self.res) / 2.0\n        grid_msg.info.origin.position.z = 0.0\n        grid_msg.info.origin.orientation.w = 1.0\n        \n        grid_msg.data = data.tolist()\n        self.publisher.publish(grid_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = MapFixedCostmap()\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n\n</code></pre>\n<h1 id=\"运行仿真环境\">运行仿真环境</h1>\n<pre><code>cd /home/zylyehuo/ros2/mobile-3d-lidar-sim\n\nsource ./install/setup.bash\n\nros2 launch my_bot launch_sim.launch.py\n</code></pre>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202601/3071480-20260102210439242-304426114.png\" /></p>\n<h1 id=\"全局路径规划hybrid-adubins\">全局路径规划（hybrid-A*，Dubins）</h1>\n<pre><code>cd /home/zylyehuo/ros2/ros2_lexi/src/lexigraph/scripts\n\npython3 ./hybrid_planner_ros2.py\n</code></pre>\n<h2 id=\"hybrid_planner_ros2py\">hybrid_planner_ros2.py</h2>\n<pre><code class=\"language-python\">#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile, DurabilityPolicy, HistoryPolicy\nimport numpy as np\nimport heapq\nimport math\nfrom nav_msgs.msg import OccupancyGrid, Path, Odometry\nfrom geometry_msgs.msg import PoseStamped, Point\nfrom scipy.ndimage import binary_dilation\n\n# --- 辅助函数: 四元数转欧拉角 (避免依赖 tf_transformations) ---\ndef euler_from_quaternion(q):\n    \"\"\"\n    Convert a list/obj of [x, y, z, w] to [roll, pitch, yaw]\n    \"\"\"\n    x, y, z, w = q.x, q.y, q.z, q.w\n    t0 = +2.0 * (w * x + y * z)\n    t1 = +1.0 - 2.0 * (x * x + y * y)\n    roll_x = math.atan2(t0, t1)\n    \n    t2 = +2.0 * (w * y - z * x)\n    t2 = +1.0 if t2 &gt; +1.0 else t2\n    t2 = -1.0 if t2 &lt; -1.0 else t2\n    pitch_y = math.asin(t2)\n    \n    t3 = +2.0 * (w * z + x * y)\n    t4 = +1.0 - 2.0 * (y * y + z * z)\n    yaw_z = math.atan2(t3, t4)\n    \n    return roll_x, pitch_y, yaw_z \n\n# --- Dubins 曲线规划器 ---\nclass DubinsPath:\n    def __init__(self, start, end, curvature, step_size=0.1):\n        self.sx, self.sy, self.syaw = start\n        self.gx, self.gy, self.gyaw = end\n        self.c = curvature\n        self.r = 1.0 / curvature\n        self.step_size = step_size\n        self.path_x = []\n        self.path_y = []\n        self.path_yaw = []\n        self.cost = float('inf')\n        self.mode = \"\"\n\ndef mod2pi(theta):\n    return theta - 2.0 * math.pi * math.floor(theta / 2.0 / math.pi)\n\ndef pi_2_pi(angle):\n    return (angle + math.pi) % (2 * math.pi) - math.pi\n\ndef dubins_path_planning(sx, sy, syaw, gx, gy, gyaw, c, step_size=0.1):\n    \"\"\"\n    计算最短的 Dubins 路径\n    \"\"\"\n    gx -= sx\n    gy -= sy\n    \n    l_rot = math.atan2(gy, gx)\n    l_dist = math.hypot(gx, gy)\n    \n    # 将目标旋转到以(0,0,0)为起点的坐标系\n    theta = mod2pi(l_rot - syaw)\n    alpha = mod2pi(syaw - l_rot)\n    beta = mod2pi(gyaw - l_rot)\n    \n    # 归一化距离\n    d = l_dist * c\n    \n    best_cost = float('inf')\n    best_mode = None\n    best_lengths = None\n\n    # 定义6种Dubins模式\n    planners = [lsl, rsr, lsr, rsl, rlr, lrl]\n    modes = [\"LSL\", \"RSR\", \"LSR\", \"RSL\", \"RLR\", \"LRL\"]\n    \n    for planner, mode in zip(planners, modes):\n        lengths = planner(alpha, beta, d)\n        if lengths is None:\n            continue\n        \n        cost = sum(map(abs, lengths))\n        if cost &lt; best_cost:\n            best_cost = cost\n            best_mode = mode\n            best_lengths = lengths\n\n    if best_mode is None:\n        return None\n\n    # 生成路径点\n    lengths = best_lengths\n    px, py, pyaw = [sx], [sy], [syaw]\n    \n    # 辅助生成函数\n    def interpolate(length, mode_char, origin_x, origin_y, origin_yaw):\n        dist = 0.0\n        curr_x, curr_y, curr_yaw = origin_x, origin_y, origin_yaw\n        step = step_size\n        \n        if mode_char == 'S':\n            d_step = step\n        else:\n            d_step = step * c # 弧度步长\n            \n        while dist &lt; length:\n            dist += step\n            if dist &gt;= length: # 修正最后一步\n                d_step -= (dist - length) * (c if mode_char != 'S' else 1.0)\n                dist = length\n                \n            if mode_char == 'L':\n                curr_yaw += d_step\n            elif mode_char == 'R':\n                curr_yaw -= d_step\n            \n            # 移动\n            if mode_char == 'S':\n                curr_x += d_step * math.cos(curr_yaw)\n                curr_y += d_step * math.sin(curr_yaw)\n            else:\n                # 弧线运动 DX = 2*R*sin(d_theta/2)*cos(theta + d_theta/2) 近似\n                # 这里简单积分\n                curr_x += step * math.cos(curr_yaw)\n                curr_y += step * math.sin(curr_yaw)\n                \n            px.append(curr_x)\n            py.append(curr_y)\n            pyaw.append(curr_yaw)\n        \n        return curr_x, curr_y, curr_yaw\n\n    # 根据最佳模式生成\n    cx, cy, cyaw = sx, sy, syaw\n    for i, m in enumerate(best_mode):\n        l_segment = lengths[i] / c\n        cx, cy, cyaw = interpolate(l_segment, m, cx, cy, cyaw)\n        \n    path = DubinsPath((sx, sy, syaw), (gx, gy, gyaw), c, step_size)\n    path.path_x = px\n    path.path_y = py\n    path.path_yaw = pyaw\n    path.cost = best_cost / c # 真实长度\n    path.mode = best_mode\n    return path\n\n# --- Dubins 公式实现 (归一化坐标下) ---\ndef lsl(alpha, beta, d):\n    sa = math.sin(alpha)\n    sb = math.sin(beta)\n    ca = math.cos(alpha)\n    cb = math.cos(beta)\n    c_ab = math.cos(alpha - beta)\n    \n    tmp0 = d + sa - sb\n    p_squared = 2 + (d * d) - (2 * c_ab) + (2 * d * (sa - sb))\n    if p_squared &lt; 0: return None\n    tmp1 = math.atan2((cb - ca), tmp0)\n    t = mod2pi(-alpha + tmp1)\n    p = math.sqrt(p_squared)\n    q = mod2pi(beta - tmp1)\n    return t, p, q\n\ndef rsr(alpha, beta, d):\n    sa = math.sin(alpha)\n    sb = math.sin(beta)\n    ca = math.cos(alpha)\n    cb = math.cos(beta)\n    c_ab = math.cos(alpha - beta)\n    \n    tmp0 = d - sa + sb\n    p_squared = 2 + (d * d) - (2 * c_ab) + (2 * d * (sb - sa))\n    if p_squared &lt; 0: return None\n    tmp1 = math.atan2((ca - cb), tmp0)\n    t = mod2pi(alpha - tmp1)\n    p = math.sqrt(p_squared)\n    q = mod2pi(-beta + tmp1)\n    return t, p, q\n\ndef lsr(alpha, beta, d):\n    sa = math.sin(alpha)\n    sb = math.sin(beta)\n    ca = math.cos(alpha)\n    cb = math.cos(beta)\n    c_ab = math.cos(alpha - beta)\n    \n    p_squared = -2 + (d * d) + (2 * c_ab) + (2 * d * (sa + sb))\n    if p_squared &lt; 0: return None\n    p = math.sqrt(p_squared)\n    tmp2 = math.atan2((-ca - cb), (d + sa + sb)) - math.atan2(-2.0, p)\n    t = mod2pi(-alpha + tmp2)\n    q = mod2pi(-mod2pi(beta) + tmp2)\n    return t, p, q\n\ndef rsl(alpha, beta, d):\n    sa = math.sin(alpha)\n    sb = math.sin(beta)\n    ca = math.cos(alpha)\n    cb = math.cos(beta)\n    c_ab = math.cos(alpha - beta)\n    \n    p_squared = (d * d) - 2 + (2 * c_ab) - (2 * d * (sa + sb))\n    if p_squared &lt; 0: return None\n    p = math.sqrt(p_squared)\n    tmp2 = math.atan2((ca + cb), (d - sa - sb)) - math.atan2(2.0, p)\n    t = mod2pi(alpha - tmp2)\n    q = mod2pi(beta - tmp2)\n    return t, p, q\n\ndef rlr(alpha, beta, d):\n    sa = math.sin(alpha)\n    sb = math.sin(beta)\n    ca = math.cos(alpha)\n    cb = math.cos(beta)\n    c_ab = math.cos(alpha - beta)\n    \n    tmp_rlr = (6.0 - d * d + 2.0 * c_ab + 2.0 * d * (sa - sb)) / 8.0\n    if abs(tmp_rlr) &gt; 1.0: return None\n    p = mod2pi(2 * math.pi - math.acos(tmp_rlr))\n    t = mod2pi(alpha - math.atan2(ca - cb, d - sa + sb) + mod2pi(p / 2.0))\n    q = mod2pi(alpha - beta - t + mod2pi(p))\n    return t, p, q\n\ndef lrl(alpha, beta, d):\n    sa = math.sin(alpha)\n    sb = math.sin(beta)\n    ca = math.cos(alpha)\n    cb = math.cos(beta)\n    c_ab = math.cos(alpha - beta)\n    \n    tmp_lrl = (6.0 - d * d + 2.0 * c_ab + 2.0 * d * (- sa + sb)) / 8.0\n    if abs(tmp_lrl) &gt; 1.0: return None\n    p = mod2pi(2 * math.pi - math.acos(tmp_lrl))\n    t = mod2pi(-alpha - math.atan2(ca - cb, d + sa - sb) + p / 2.0)\n    q = mod2pi(mod2pi(beta) - alpha - t + mod2pi(p))\n    return t, p, q\n\n# --- 节点类 ---\nclass NodeItem:\n    def __init__(self, x_ind, y_ind, theta_ind, x, y, yaw, x_list, y_list, p_ind, cost, steer):\n        self.x_ind = x_ind\n        self.y_ind = y_ind\n        self.theta_ind = theta_ind\n        self.x = x\n        self.y = y\n        self.yaw = yaw\n        self.x_list = x_list\n        self.y_list = y_list\n        self.p_ind = p_ind\n        self.cost = cost\n        self.steer = steer\n\nclass HybridAStarPlanner(Node):\n    def __init__(self):\n        super().__init__('hybrid_astar_planner')\n        \n        # --- Ranger Mini 3.0 参数 ---\n        self.WB = 0.494          \n        self.MAX_STEER = 0.55   \n        self.ROBOT_RADIUS = 0.45 \n        \n        # --- 规划参数 ---\n        self.XY_RES = 0.1      \n        self.YAW_RES = 0.15     # 稍微增大角度分辨率以减少搜索空间\n        self.MOTION_STEP = 0.1 \n        \n        # Dubins 最小转弯半径 R_min\n        # tan(max_steer) = WB / R\n        # R = WB / tan(max_steer)\n        self.MIN_TURN_RADIUS = self.WB / math.tan(self.MAX_STEER)\n        # 对应的曲率 (1/R)\n        self.MAX_CURVATURE = 1.0 / self.MIN_TURN_RADIUS * 0.95 # 留一点余量\n\n        self.get_logger().info(f\"Ranger Mini Params: WB={self.WB}, R_min={self.MIN_TURN_RADIUS:.2f}m\")\n        \n        # --- 内部变量 ---\n        self.map_data = None\n        self.costmap = None\n        self.map_info = None\n        self.current_pose = None \n        \n        # --- ROS 2 通信 ---\n        # Map QoS: 必须是 Transient Local 才能收到并在后续保留 map_server 发出的地图\n        map_qos = QoSProfile(\n            depth=1,\n            durability=DurabilityPolicy.TRANSIENT_LOCAL,\n            history=HistoryPolicy.KEEP_LAST,\n        )\n\n        self.path_pub = self.create_publisher(Path, '/bezai_path', 10)\n        \n        self.create_subscription(OccupancyGrid, '/map', self.map_callback, map_qos)\n        self.create_subscription(Odometry, '/odom', self.odom_callback, 10) \n        self.create_subscription(PoseStamped, '/goal_pose', self.goal_callback, 10) # RViz2 默认话题通常是 /goal_pose\n        \n        self.get_logger().info(\"Hybrid A* Planner (ROS 2 + Dubins) Ready.\")\n\n    def map_callback(self, msg):\n        self.map_info = msg.info\n        self.XY_RES = msg.info.resolution\n        w, h = msg.info.width, msg.info.height\n        \n        grid = np.array(msg.data).reshape((h, w))\n        obstacles = np.where((grid &gt; 50) | (grid == -1), 1, 0)\n        \n        # 膨胀\n        inflation_cells = int(np.ceil(self.ROBOT_RADIUS / self.XY_RES))\n        structure = np.ones((2*inflation_cells+1, 2*inflation_cells+1))\n\n        self.costmap = binary_dilation(obstacles, structure=structure).astype(int)\n        \n        self.costmap = self.costmap.T # 转置以匹配 x,y 索引\n        self.get_logger().info(\"Map updated &amp; Inflated.\")\n\n    def odom_callback(self, msg):\n        p = msg.pose.pose.position\n        o = msg.pose.pose.orientation\n        _, _, yaw = euler_from_quaternion(o)\n        self.current_pose = (p.x, p.y, yaw)\n\n    def goal_callback(self, msg):\n        if self.costmap is None:\n            self.get_logger().warn(\"Map not received!\")\n            return\n        if self.current_pose is None:\n            self.get_logger().warn(\"Odom not received!\")\n            return\n            \n        self.get_logger().info(\"Goal Received. Planning...\")\n        \n        g_x = msg.pose.position.x\n        g_y = msg.pose.position.y\n        _, _, g_yaw = euler_from_quaternion(msg.pose.orientation)\n        \n        path_points = self.hybrid_a_star(self.current_pose, (g_x, g_y, g_yaw))\n        \n        if path_points:\n            self.publish_path(path_points)\n        else:\n            self.get_logger().warn(\"No path found!\")\n\n    def hybrid_a_star(self, start, goal):\n        sx, sy, syaw = start\n        gx, gy, gyaw = goal\n        \n        sx_ind, sy_ind = self.coord2grid(sx, sy)\n        syaw_ind = int(pi_2_pi(syaw) / self.YAW_RES)\n        \n        start_node = NodeItem(sx_ind, sy_ind, syaw_ind, sx, sy, syaw, [sx], [sy], -1, 0, 0)\n        \n        open_list = {}\n        open_list[self.calc_index(start_node)] = start_node\n        pq = []\n        heapq.heappush(pq, (self.calc_cost(start_node, goal), self.calc_index(start_node)))\n        \n        closed_set = {}\n        \n        # 限制迭代次数\n        iter_count = 0\n        max_iter = 50000 \n        \n        while iter_count &lt; max_iter:\n            iter_count += 1\n            if not pq:\n                return None\n            \n            _, c_id = heapq.heappop(pq)\n            if c_id in open_list:\n                current = open_list[c_id]\n                del open_list[c_id]\n            else:\n                continue\n                \n            closed_set[c_id] = current\n            \n            # --- Analytic Expansion (Dubins Shot) ---\n            # 尝试直接用 Dubins 曲线连接当前点和终点\n            # 为节省算力，每隔N次尝试或当距离足够近时尝试\n            dist_to_goal = np.hypot(current.x - gx, current.y - gy)\n            \n            # 策略：如果距离小于一定值，或者随机尝试（这里设置为始终尝试，追求最优解）\n            # 如果障碍物很密集，这一步会经常失败，耗费计算\n            if dist_to_goal &lt; 10.0: # 仅在 10m 范围内尝试直接连接\n                dubins_path = dubins_path_planning(\n                    current.x, current.y, current.yaw, \n                    gx, gy, gyaw, \n                    self.MAX_CURVATURE, self.MOTION_STEP\n                )\n                \n                if dubins_path and self.check_dubins_collision(dubins_path):\n                    self.get_logger().info(f\"Dubins shot found! Mode: {dubins_path.mode}\")\n                    return self.reconstruct_path_with_dubins(current, closed_set, dubins_path)\n\n            # 正常 Hybrid A* 扩展\n            steer_inputs = [-self.MAX_STEER, 0, self.MAX_STEER] \n            \n            for steer in steer_inputs:\n                node = self.kinematic_move(current, steer, self.MOTION_STEP)\n                \n                if not self.check_collision(node):\n                    continue\n                \n                node_ind = self.calc_index(node)\n                if node_ind in closed_set:\n                    continue\n                \n                if node_ind not in open_list:\n                    new_cost = self.calc_cost(node, goal)\n                    open_list[node_ind] = node\n                    heapq.heappush(pq, (new_cost, node_ind))\n                else:\n                    if open_list[node_ind].cost &gt; node.cost:\n                        open_list[node_ind] = node\n                        new_cost = self.calc_cost(node, goal)\n                        heapq.heappush(pq, (new_cost, node_ind))\n        \n        return None\n\n    def kinematic_move(self, node, steer, dt):\n        x, y, yaw = node.x, node.y, node.yaw\n        dist = 0.6 # 扩展弧长\n        step = 0.1 # 积分步长\n        \n        traj_x, traj_y = [], []\n        d = 0\n        while d &lt; dist:\n            x += step * math.cos(yaw)\n            y += step * math.sin(yaw)\n            yaw += step / self.WB * math.tan(steer)\n            d += step\n            traj_x.append(x)\n            traj_y.append(y)\n            \n        yaw = pi_2_pi(yaw)\n        \n        x_ind, y_ind = self.coord2grid(x, y)\n        yaw_ind = int(yaw / self.YAW_RES)\n        \n        # cost 包含移动代价 + 转向惩罚\n        cost = node.cost + dist + abs(steer)*0.5\n        \n        new_node = NodeItem(x_ind, y_ind, yaw_ind, x, y, yaw, traj_x, traj_y, \n                            self.calc_index(node), cost, steer)\n        return new_node\n\n    def check_collision(self, node):\n        for x, y in zip(node.x_list, node.y_list):\n            ix, iy = self.coord2grid(x, y)\n            if self.is_collision(ix, iy):\n                return False\n        return True\n\n    def check_dubins_collision(self, dubins_path):\n        for x, y in zip(dubins_path.path_x, dubins_path.path_y):\n            ix, iy = self.coord2grid(x, y)\n            if self.is_collision(ix, iy):\n                return False\n        return True\n\n    def is_collision(self, ix, iy):\n        if ix &lt; 0 or ix &gt;= self.costmap.shape[0] or iy &lt; 0 or iy &gt;= self.costmap.shape[1]:\n            return True # 出界视为碰撞\n        if self.costmap[ix][iy] == 1:\n            return True\n        return False\n\n    def calc_cost(self, node, goal):\n        # 启发式函数\n        # Euclidean Dist\n        h = np.hypot(node.x - goal[0], node.y - goal[1])\n        return node.cost + h * 1.2 \n\n    def reconstruct_path_with_dubins(self, current, closed_set, dubins_path):\n        # 1. 回溯之前的路径\n        path_x, path_y = [], []\n        curr = current\n        while curr.p_ind != -1:\n            path_x.extend(reversed(curr.x_list))\n            path_y.extend(reversed(curr.y_list))\n            curr = closed_set[curr.p_ind]\n        \n        path_x.append(curr.x)\n        path_y.append(curr.y)\n        \n        # 反转得到从起点到current的顺序\n        final_x = list(reversed(path_x))\n        final_y = list(reversed(path_y))\n        \n        # 2. 加上 Dubins 部分\n        # Dubins路径本身就是顺序的，直接添加\n        final_x.extend(dubins_path.path_x)\n        final_y.extend(dubins_path.path_y)\n        \n        return list(zip(final_x, final_y))\n\n    def publish_path(self, points):\n        path = Path()\n        path.header.frame_id = \"map\"\n        path.header.stamp = self.get_clock().now().to_msg()\n        \n        for p in points:\n            pose = PoseStamped()\n            pose.header.frame_id = \"map\"\n            pose.pose.position.x = p[0]\n            pose.pose.position.y = p[1]\n            pose.pose.position.z = 0.0\n            pose.pose.orientation.w = 1.0 \n            path.poses.append(pose)\n            \n        self.path_pub.publish(path)\n\n    def coord2grid(self, x, y):\n        gx = int((x - self.map_info.origin.position.x) / self.XY_RES)\n        gy = int((y - self.map_info.origin.position.y) / self.XY_RES)\n        return gx, gy\n\n    def calc_index(self, node):\n        return (node.x_ind, node.y_ind, node.theta_ind)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    planner = HybridAStarPlanner()\n    try:\n        rclpy.spin(planner)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        planner.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n\n</code></pre>\n<h1 id=\"局部路径规划lexi避障\">局部路径规划（lexi避障）</h1>\n<pre><code>cd /home/zylyehuo/ros2/ros2_lexi\n\nsource ./install/setup.bash\n\nros2 launch lexigraph run.launch.py\n</code></pre>\n<h1 id=\"启动-rviz\">启动 rviz</h1>\n<pre><code>rviz2\n</code></pre>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202601/3071480-20260102210729419-589686512.png\" /></p>\n<h1 id=\"修改-rviz-配置\">修改 rviz 配置</h1>\n<blockquote>\n<p>按照设置的话题对应添加组件</p>\n</blockquote>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202601/3071480-20260102210815746-1493141898.png\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-02 21:16</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zylyehuo\">zylyehuo</a>&nbsp;\n阅读(<span id=\"post_view_count\">11</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Ansible 学习总结",
      "link": "https://www.cnblogs.com/kqdssheng/p/19432562",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/kqdssheng/p/19432562\" id=\"cb_post_title_url\" title=\"发布于 2026-01-02 17:46\">\n    <span>Ansible 学习总结</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>世事洞明皆学问，人情练达即文章。</p>\n</blockquote>\n<h2 id=\"导航\">导航</h2>\n<ul>\n<li><a href=\"#id1\" rel=\"noopener nofollow\">1 工具介绍</a>\n<ul>\n<li><a href=\"#id1.1\" rel=\"noopener nofollow\">1.1 Ansible 简介</a></li>\n<li><a href=\"#id1.2\" rel=\"noopener nofollow\">1.2 Ansible 概念</a></li>\n<li><a href=\"#id1.3\" rel=\"noopener nofollow\">1.3 工作原理</a></li>\n<li><a href=\"#id1.4\" rel=\"noopener nofollow\">1.4 作用范围</a></li>\n</ul>\n</li>\n<li><a href=\"#id2\" rel=\"noopener nofollow\">2 配套命令</a>\n<ul>\n<li><a href=\"#id2.1\" rel=\"noopener nofollow\">2.1 ansible</a></li>\n<li><a href=\"#id2.2\" rel=\"noopener nofollow\">2.2 ansible-playbook</a></li>\n<li><a href=\"#id2.3\" rel=\"noopener nofollow\">2.3 ansible-doc</a></li>\n<li><a href=\"#id2.4\" rel=\"noopener nofollow\">2.4 ansible-vault</a></li>\n<li><a href=\"#id2.5\" rel=\"noopener nofollow\">2.5 ansible-galaxy</a></li>\n<li><a href=\"#id2.6\" rel=\"noopener nofollow\">2.6 ansible-console</a></li>\n</ul>\n</li>\n<li><a href=\"#id3\" rel=\"noopener nofollow\">3 Inventory - 主机清单</a></li>\n<li><a href=\"#id4\" rel=\"noopener nofollow\">4 Playbook - 任务清单</a>\n<ul>\n<li><a href=\"#id4.1\" rel=\"noopener nofollow\">4.1 Keywords - 关键词</a></li>\n<li><a href=\"#id4.2\" rel=\"noopener nofollow\">4.2 Vars - 变量</a>\n<ul>\n<li><a href=\"#id4.2.1\" rel=\"noopener nofollow\">4.2.1 变量优先级</a></li>\n<li><a href=\"#id4.2.2\" rel=\"noopener nofollow\">4.2.2 文件变量</a></li>\n<li><a href=\"#id4.2.3\" rel=\"noopener nofollow\">4.2.3 特殊变量</a></li>\n<li><a href=\"#id4.2.4\" rel=\"noopener nofollow\">4.2.4 调用变量</a></li>\n</ul>\n</li>\n<li><a href=\"#id4.3\" rel=\"noopener nofollow\">4.3 Tasks - 任务</a>\n<ul>\n<li><a href=\"#id4.3.1\" rel=\"noopener nofollow\">4.3.1 Tasks</a></li>\n<li><a href=\"#id4.3.2\" rel=\"noopener nofollow\">4.3.2 Roles</a></li>\n<li><a href=\"#id4.3.3\" rel=\"noopener nofollow\">4.3.3 Handlers</a></li>\n</ul>\n</li>\n<li><a href=\"#id4.4\" rel=\"noopener nofollow\">4.4 其它技巧</a>\n<ul>\n<li><a href=\"#id4.4.1\" rel=\"noopener nofollow\">4.4.1 When - 判断</a></li>\n<li><a href=\"#id4.4.2\" rel=\"noopener nofollow\">4.4.2 Loop - 循环</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#id5\" rel=\"noopener nofollow\">5 常用模块</a></li>\n<li><a href=\"#id6\" rel=\"noopener nofollow\">6 常用插件</a></li>\n<li><a href=\"#id7\" rel=\"noopener nofollow\">7 杂七杂八</a></li>\n</ul>\n<hr />\n<h2 id=\"1工具介绍\"><strong><div id=\"id1\">1、工具介绍</div></strong></h2>\n<h3 id=\"11ansible-简介\"><strong><div id=\"id1.1\">1.1、Ansible 简介</div></strong></h3>\n<p><strong>Ansible</strong> 是一款开源的自动化运维工具，主要用于服务器批量管理、应用部署和任务自动化。它主要的特点有：（1）<strong>无客户端的架构</strong>，免去了安装客户端的困扰。（2）<strong>基于 YAML 的语法配置</strong>，使得 Playbook 配置很容易阅读。（3）采用了 <strong>模块化的设计</strong>，使得其灵活度较高。（4）<strong>幂等性</strong>。</p>\n<blockquote>\n<p>注：<strong>什么是幂等性？</strong> 当系统处于您的任务所描述的状态时，即使多次运行同一任务，Ansible 也不会更改任何内容。【例如：通过 lineinfile 模块去为 test 文件中以 a 开头的行的前面添加一行字串 test123，当多次执行同一任务 <code>ansible localhost -m lineinfile -a \"path=test  state=present line=test123 insertbefore='^a'\"</code> 时，会发现 test 文件并没有随着任务的重复执行而重复添加多行 test123 字串，这便是幂等性。】</p>\n</blockquote>\n<h3 id=\"12ansible-概念\"><strong><div id=\"id1.2\">1.2、Ansible 概念</div></strong></h3>\n<ul>\n<li>管理节点：运行 Ansible CLI 工具（ansible、ansible-playbook、ansible-vault 等）的机器。</li>\n<li>被管节点：用 Ansible 管理的目标设备（服务器、网络设备或任何计算机）。</li>\n<li>====</li>\n<li>清单-inventory：被管节点的 <strong>主机列表</strong>，也被叫做“主机文件”。</li>\n<li><strong>剧本-playbook</strong>：用 YAML 编写的，用来描述自动化任务（<strong>指定哪些主机运行哪些命令任务</strong>）的文件。\n<ul>\n<li><strong>剧集-play</strong>：一个剧本可以包含多个剧集，而一个剧集可以理解为：<strong>针对一组主机的一次完整执行任务的计划</strong>。【注：一个 Play 是由 <strong>关键词、变量、任务</strong> 组成，其中任务又分为以下三种。】\n<ul>\n<li><strong>任务-task</strong>：用于定义执行的命令操作，相当于执行 <strong>单条命令</strong>。</li>\n<li><strong>角色-role</strong>：多个任务集中整合在了一起，相当于执行 <strong>一个 Bash 脚本</strong>。【注：<a href=\"https://docs.ansible.org.cn/ansible/latest/collections/index_role.html\" rel=\"noopener nofollow\" target=\"_blank\">Ansible 内置角色</a>、<a href=\"https://galaxy.ansible.com/ui/standalone/roles/\" rel=\"noopener nofollow\" target=\"_blank\">第三方角色</a>】</li>\n<li><strong>处理器-handler</strong>：可触发式的任务，相当于 Bash 脚本中定义的 <strong>Bash 函数</strong>。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>====</li>\n<li>模块：一个模块相当于一条 <strong>Linux 命令</strong>。【注：<a href=\"https://docs.ansible.org.cn/ansible/latest/collections/index_module.html\" rel=\"noopener nofollow\" target=\"_blank\">Ansible 内置模块</a>】</li>\n<li>插件：用于 <strong>扩展 Ansible 的功能</strong>。默认情况下，Ansible 远程目标只支持 ssh 的连接协议，但通过连接插件，它还可以支持 winrm、netconf 协议。【注：<a href=\"https://docs.ansible.org.cn/ansible/latest/collections/all_plugins.html\" rel=\"noopener nofollow\" target=\"_blank\">Ansible 内置插件</a>】</li>\n<li>集合：<strong>Ansible 内容的分发格式</strong>，可以包含剧本、角色、模块和插件。默认情况下，我们所使用的模块、插件 都是来自 <a href=\"https://docs.ansible.org.cn/ansible/latest/collections/ansible/builtin/index.html#ansible-builtin\" rel=\"noopener nofollow\" target=\"_blank\">Ansible.Builtin</a> 集合。如果你想管控 windows 设备，那我们一定要使用 <a href=\"https://docs.ansible.org.cn/ansible/latest/collections/ansible/windows/index.html#ansible-windows\" rel=\"noopener nofollow\" target=\"_blank\">Ansible.Windows</a> 集合中的模块。【注：<a href=\"https://docs.ansible.org.cn/ansible/latest/collections/index.html\" rel=\"noopener nofollow\" target=\"_blank\">Ansible 内置集合</a>、<a href=\"https://galaxy.ansible.com/ui/collections/\" rel=\"noopener nofollow\" target=\"_blank\">第三方集合</a>】</li>\n</ul>\n<p><strong>Playbook 用法汇总示例</strong>：</p>\n<pre><code class=\"language-yaml\">#本配置中的所有内容即代表一个剧本\n\n#剧集一\n- hosts: linux\n  tasks:\n##任务1\n\t- name: install nginx\n      yum:\t\t#yum 模块\n        name: nginx\n        state: present\n##任务2\n\t- name: update nginx config\n      template:\t#template 模块\n        src: nginx.conf.j2\n        dest: /etc/nginx/nginx.conf\n        notify: restart nginx\t#调用处理器\n\n  handlers:\t\t\t\t\t\t#定义处理器\n    - name: restart nginx\n      service:\n        name: nginx\n        state: restarted\n\n#剧集二     \n- hosts: windows\n  collections:\t\t#声明集合，不声明调用集合模块需带集合名称，如 ansible.windows.win_file。\n    - ansible.windows\n  tasks:\n    - name: Remove a file, if present\n  \t  win_file:\t\t#调用 windows 集合中的模块\n    \tpath: C:\\Temp\\foo.conf\n    \tstate: absent\n\n#剧集三\n- hosts: web\n  roles:\t#角色\n    - nginx\n</code></pre>\n<h3 id=\"13工作原理\"><strong><div id=\"id1.3\">1.3、工作原理</div></strong></h3>\n<p>Ansible 管理节点（1）首先与被管节点 Agent 建立远程连接，并检查当前系统的模块脚本执行环境。（2）接着管理端将任务模块对应的模块脚本传输至 Agent 端并执行，模块脚本执行时会先进行“<strong>状态检测判断</strong>”，然后将结果以 json 格式返回。（3）最后删除 Agent 处的临时模块脚本文件并关闭连接。</p>\n<blockquote>\n<p>注：（1）<strong>状态检测判断流程</strong>：① 获取当前状态。② 与 Playbook 期望状态对比。③ 决定是否执行修改。【注：以上述修改 test 文件为例。当第二次执行任务时，发现文件中已在 a 行的前面添加了 test123，这正符合 Playbook 的期望，于是本次任务并不会做出任何修改。】（2）Ansible 中的 <strong>模块其实是用 Python/Powershell 脚本实现的，它具有和 Linux 命令相类似的功能。</strong> 因此，这也就说明了为什么 Ansible 要求被管节点需要具备 Python 或 Powershell 的执行环境。</p>\n</blockquote>\n<h3 id=\"14作用范围\"><strong><div id=\"id1.4\">1.4、作用范围</div></strong></h3>\n<p>Ansible 拥有丰富的插件和功能模块。而借助其 <strong>连接插件</strong>，理论上可对大多数设备（Linxu、Windows、网络设备）进行远程管理。但实际上，它只是对 Linux 设备支持度较好（注：大多数功能模块都只对 Linux 有效），对 Windows 和网络设备的管理效果一般。</p>\n<blockquote>\n<p>注：Ansible 对不同设备能否被管理的要求如下：</p>\n<ul>\n<li>对 Linux 设备的要求：（1）开启 SSH 服务。（2）安装 Python 2.7 或更高版本。</li>\n<li>对 Windows 设备的要求：（1）开启 WinRM 服务。（2）安装 PowerShell 3.0 或更高版本，以及至少 .NET 4.0。（3）PowerShell 脚本执行策略设置为 Restricted。</li>\n<li>对网络设备（交换机/路由器）的要求：开启 NETCONF  服务。【注：由于是新协议，因此老旧网络设备可能并不支持该功能。】</li>\n</ul>\n</blockquote>\n<h2 id=\"2配套工具\"><strong><div id=\"id2\">2、配套工具</div></strong></h2>\n<h3 id=\"21ansible\"><strong><div id=\"id2.1\">2.1、ansible</div></strong></h3>\n<p>ansible 是用于临时 <strong>执行单一命令任务</strong> 的工具，不用写 playbook 即可执行任务。</p>\n<pre><code class=\"language-bash\">#对所有主机执行 id 命令，并查看输出结果。\nansible all -i hosts -m command -a \"id\" -v\n</code></pre>\n<h3 id=\"22ansible-playbook\"><strong><div id=\"id2.2\">2.2、ansible-playbook</div></strong></h3>\n<p>ansible-playbook 是用于 <strong>执行复杂命令任务</strong> 的工具，必须依赖 playbook 文件才能运行。</p>\n<pre><code class=\"language-bash\">#执行 task.yml 任务集。\nansible-playbook -i hosts task.yml\n\ncat task.yml\n###文本内容###\n- hosts: linux\n  tasks:\n\t- name: install nginx\n      yum:\n        name: nginx\n        state: present\n######\n</code></pre>\n<h3 id=\"23ansible-doc\"><strong><div id=\"id2.3\">2.3、ansible-doc</div></strong></h3>\n<p>ansible-doc 是用于 <strong>查看模块/插件使用说明</strong> 的工具，相当于是 Ansible 的“man 手册”。</p>\n<pre><code class=\"language-bash\">#查看 ping 模块的参数介绍。\nansible-doc -s ping\n\n#查看 ping 模块的参数介绍。\nansible-doc -t module -s ping\n</code></pre>\n<h3 id=\"24ansible-vault\"><strong><div id=\"id2.4\">2.4、ansible-vault</div></strong></h3>\n<p>ansible-vault 是用于 <strong>加密 playbook 配置</strong> 的工具，防止剧本中的密码信息泄露。</p>\n<pre><code class=\"language-bash\">#加密 playbook 任务文件\nansible-vault encrypt task.yml\n\n#执行被加密的 playbook 任务文件\nansible-playbook task.yml --ask-vault-pass\n</code></pre>\n<h3 id=\"25ansible-galaxy\"><strong><div id=\"id2.5\">2.5、ansible-galaxy</div></strong></h3>\n<p>ansible-galaxy 是用于 <strong>下载管理角色/集合</strong> 的工具，相当于是 Ansible 的“任务/模块应用商店”或是类似 pip 的“包管理器”。</p>\n<p>角色/集合的官网地址：<a href=\"https://galaxy.ansible.com/ui/standalone/roles/%E3%80%81https://galaxy.ansible.com/ui/collections/%E3%80%82\" rel=\"noopener nofollow\" target=\"_blank\">https://galaxy.ansible.com/ui/standalone/roles/、https://galaxy.ansible.com/ui/collections/。</a></p>\n<pre><code class=\"language-bash\">#下载用于自动化部署 nginx 任务的角色\nansible-galaxy role install geerlingguy.nginx\n\n#角色的使用类似 task 一样，具体操作见本文 Playbook 小节。\n</code></pre>\n<h3 id=\"26ansible-console\"><strong><div id=\"id2.6\">2.6、ansible-console</div></strong></h3>\n<p>ansible-console 是用于 <strong>与 Ansible 进行命令交互</strong> 的工具，相当于是面向 Ansible 的 Shell。</p>\n<pre><code class=\"language-bash\">ansible-console\n&gt; hosts web\n&gt; ping\n&gt; shell uptime\n</code></pre>\n<h2 id=\"3inventory---主机清单\"><strong><div id=\"id3\">3、Inventory - 主机清单</div></strong></h2>\n<p>在主机清单中支持定义：<strong>主机、主机组、主机变量、主机组变量</strong>，但一般不建议在主机清单中定义变量，变量都是定义在单独的 <strong>主机/组文件</strong> 中。主机清单支持多种格式去书写，但最常用的格式是 ini 格式。以下是一个主机清单的示例：</p>\n<pre><code class=\"language-ini\"># hosts.ini\n[windows]\t# windows 组定义了5个主机\nwww.test-[01:05].com\n\n[linux]\t\t# linux 组定义了2个主机，其中一个主机自带登录变量。\n192.168.1.1 ansible_user=kali ansible_password=kali\nwww.test-06.com ansible_host=192.168.1.2\n\n[windows:vars]\t# windows 组变量\nansible_connection=winrm\nansible_user=administrator\nansible_password=password123\n\n[hosts:children]\t# 基于组创建的 hosts 组\nwindows\nlinux\n</code></pre>\n<blockquote>\n<p>注：Ansible 默认预定义了两个主机组：<strong>all</strong> 分组（所有主机）、<strong>ungrouped</strong> 分组（不在分组内的主机）。需要注意的是，这两个组都不包括 <strong>localhost</strong>（管理节点本机） 这个特殊的节点。【注：命令 <code>ansible windows --list-hosts</code> 可列出 windows 组中的所有主机。】</p>\n</blockquote>\n<h2 id=\"4playbook---任务清单\"><strong><div id=\"id4\">4、Playbook - 任务清单</div></strong></h2>\n<p>Playbook 是 Ansible 中最重要的一个概念，它定义了批量的主机任务应该如何去执行。而一个 Playbook 则是由一个或多个 Play 构成的，因此，<strong>只要了解了 Play 的构成也就了解了 Playbook</strong>。</p>\n<p>一个 Play 主要是由以下三部分构成:</p>\n<ul>\n<li><strong>Keywords</strong>：指定主机组、远程连接的方式、是否提权等全局参数。其中主机组必须被指定。【注：<a href=\"https://docs.ansible.org.cn/ansible/latest/reference_appendices/playbooks_keywords.html#id2\" rel=\"noopener nofollow\" target=\"_blank\">可用参数参考</a>】</li>\n<li><strong>Vars</strong>：定义 playbook 在运行时需要使用的变量。【非必须】</li>\n<li><strong>Tasks</strong>：指定要执行的任务。</li>\n</ul>\n<h3 id=\"41keywords---关键词\"><strong><div id=\"id4.1\">4.1、Keywords - 关键词</div></strong></h3>\n<p>Play 中的关键词有点像是 C 语言中的全局变量，在一个 Play 中，hosts 和 tasks/roles 是必不可少的，其余参数则可有可无。Play 常用关键词如下：</p>\n<ul>\n<li>hosts：指定要执行任务的主机组。</li>\n<li>connection：使用指定的协议，连接需要执行该任务的主机。默认是 ssh。</li>\n<li>port：指定连接协议对应的端口。默认是指定协议对应的默认端口。</li>\n<li>====</li>\n<li>become：开启提权功能，使用提权之后的身份执行任务。</li>\n<li>become_method：提权支持 sudo、su 这两种方法，默认是使用 sudo 进行提权。</li>\n<li>become_user：指定提权之后获得的用户身份，默认是 root 用户。</li>\n<li>collections：全局声明集合名称，这样在调用此集合的模块时不需要携带集合的前缀名称。</li>\n<li>====</li>\n<li>vars、vars_files：定义变量。【注：这些关键词指的便是下面的小节。】</li>\n<li>tasks、roles、handlers：定义任务。【注：这些关键词指的便是下面的小节。】</li>\n</ul>\n<blockquote>\n<p>注意：并不只是在 Play 中存在关键词的说法，Task、Role 中也依然存在。虽然三者之间的关键词各有差异（关键词 when 在 Play 中没有，但在 Task、Role 中是有的。），但相似的地方有很多，像如关键词 become、vars 等。</p>\n</blockquote>\n<h3 id=\"42vars---变量\"><strong><div id=\"id4.2\">4.2、Vars - 变量</div></strong></h3>\n<h4 id=\"421变量优先级\"><strong><div id=\"id4.2.1\">4.2.1、变量优先级</div></strong></h4>\n<p>Ansible 中支持自定义变量的地方有很多，以下我将按照优先级的顺序依次列出：</p>\n<ol>\n<li>命令行变量：通过命令行参数带入，优先级最高。如：<code>ansible-playbook -i hosts -v main.yml --extra-vars \"v1=a v2=b\"</code>。</li>\n<li>playbook 变量：通过关键词 vars 带入。</li>\n<li>Inventory 主机变量：通过主机 ip 带入。如：<code>1.1.1.1 v1=a v2=b</code></li>\n<li>host_vars 主机变量：不可描述。</li>\n<li>group_vars 主机组变量：不可描述。</li>\n<li>Inventory 主机组变量：不可描述。</li>\n</ol>\n<h4 id=\"422文件变量\"><strong><div id=\"id4.2.2\">4.2.2、文件变量</div></strong></h4>\n<p>在上述变量中，关于文件变量 host_vars、group_vars 的构成不太好理解，故以一个 ansible 项目示例做说明：</p>\n<p>（1）首先，按照如下项目的目录结构制作相应的文件。</p>\n<pre><code class=\"language-wiki\">nginx_install\n├── inventory\n│   ├── group_vars\n│   │   └── lin.yml\n│   ├── hosts\n│   └── host_vars\n│       └── 192.168.56.20.yml\n└── main.yml\n</code></pre>\n<p>其中，hosts 文本内容如下：</p>\n<pre><code class=\"language-ini\">[lin]\n192.168.56.20\n</code></pre>\n<p>（2）然后，以 YAML 的语法格式去编写文件中的变量。lin.yml 文本内容如下：</p>\n<pre><code class=\"language-yaml\">---\nv1: a\nv2: b\n</code></pre>\n<p>（3）最后，在工作目录 nginx_install 下执行命令 <code>ansible-playbook -i inventory -v main.yml</code> 即可。【注：参数 i 的值不仅可以是文件也可以是目录。】</p>\n<h4 id=\"423特殊变量\"><strong><div id=\"id4.2.3\">4.2.3、特殊变量</div></strong></h4>\n<h5 id=\"facts-变量\">Facts 变量</h5>\n<p>为了让 Ansible 更了解目标节点，可以让它去收集目标节点的信息，比如获取目标节点的：主机名、系统版本、IP 地址、分区挂载信息等。这些节点信息被称为 Facts，可通过命令 <code>ansible localhost -m gather_facts</code> 去查看。有了这些信息，我们便可以更灵活的管理节点了，比如当 IP 地址为 xxx 时就怎样，当系统是 CentOS 6 时怎样，等等这些。</p>\n<p><strong>这些变量中以 <code>ansible_</code> 开头的变量默认都被  Ansible 注入到了其自身维护的变量表 hostvars 中了。因此，我们可以直接去访问变量本身，而无需以访问“组变量或字典变量”的方式去访问它们。</strong></p>\n<blockquote>\n<p>注：这些变量只能通过 Playbook 去调用，使用命令 <code>ansible localhost -m debug -a \"var=ansible_facts.ansible_interfaces\"</code> 并不能够查看，应该是 ansible 在执行任务时默认并不会收集 Facts 所导致，但 ansible-playbook 默认是会收集的。</p>\n</blockquote>\n<p>变量 Facts 和 Hostvars 的值还可通过以下 Play 去查看。</p>\n<pre><code class=\"language-yaml\">- name: playbooks\n  hosts: lin\n  tasks:\n    - name: info in ansible_facts\n      debug:\n        var: ansible_facts\n    - name: info in hostvars\n      debug:\n        var: hostvars\n</code></pre>\n<h5 id=\"register-变量\">register 变量</h5>\n<p>有时候，可能需要将某一条任务执行的结果保存下来，以便在接下的任务中调用或者做些判断。这时就可以通过 register 关键字来将某一任务结果保存为一个变量。【注：这个变量的结构类似于 上面的 hostvars 变量，因此在调用的时候需要注意。】</p>\n<pre><code class=\"language-yaml\">- name: register variables\n  hosts: lin\n  tasks:\n    - name: capture output of whoami command\n      command: whoami\n      register: login\n\n    - name: get var\n      debug:\n        msg: \"login user is {{ login.stdout }}\"\n</code></pre>\n<h4 id=\"424调用变量\"><strong><div id=\"id4.2.4\">4.2.4、调用变量</div></strong></h4>\n<p>构造的变量最终都是为了使用，而变量的类型又多种多样，如：整数、字串、数组、字典 等类型，那么面对这些类型的变量该如何使用呢？以下以一个示例的两种用法去调用它们。</p>\n<p>以上面测试 register 变量的示例为例，假设输出的复杂变量 login 的值如下：</p>\n<pre><code class=\"language-wiki\">\"login\": {\n        \"changed\": true,\n        \"cmd\": [\n            \"whoami\"\n        ],\n        \"delta\": \"0:00:00.011976\",\n        \"end\": \"2025-12-31 05:27:48.401127\",\n        \"failed\": false,\n        \"msg\": \"\",\n        \"rc\": 0,\n        \"start\": \"2025-12-31 05:27:48.389151\",\n        \"stderr\": \"\",\n        \"stderr_lines\": [],\n        \"stdout\": \"kali\",\n        \"stdout_lines\": [\n            \"kali\"\n        ]\n    }\n</code></pre>\n<p>那么在 Play 中调用其中值的方法如下：</p>\n<pre><code class=\"language-yaml\">- name: register variables\n  hosts: lin\n  tasks:\n    - name: capture output of whoami command\n      command: whoami\n      register: login\n\n    - name: get var\n      debug:\n        msg: \"login user1 is {{ login.stdout_lines[0] }}\"\n\n    - name: get var\n      debug:\n        msg: \"login user2 is {{ login['stdout_lines'][0] }}\"\n</code></pre>\n<h3 id=\"43tasks---任务\"><strong><div id=\"id4.3\">4.3、Tasks - 任务</div></strong></h3>\n<p>在 Play 中用来执行任务的方式有三种，分别是：tasks（常规任务）、roles（任务组织化）、handlers（可复用任务），三者虽各有各的用法，但本质上都是一样的：执行任务。</p>\n<h4 id=\"431tasks\"><strong><div id=\"id4.3.1\">4.3.1、Tasks</div></strong></h4>\n<ul>\n<li><strong>任务列表中的各任务按次序逐个在 hosts 中指定的所有主机上执行，在所有主机上先完成第一个任务后再开始第二个。</strong></li>\n<li>在自上而下运行某 playbook 时，如果中途发生错误，则整个 playbook 会停止执行，而由于 playbook 的幂等性，playbook 可以被反复执行，所以即使发生了错误，在修复错误后，再执行一次即可。</li>\n</ul>\n<pre><code class=\"language-yaml\">- name: task test\n  hosts: linux\n  tasks:\n    - name: make sure apache is running\n      service: \n        name: httpd\n        state: started\n  \n    - name: run this command and ignore the result\n      command: /usr/bin/somecommand\n      ignore_errors: True\t\t#若命令会返回错误信息，但这个错误对后续任务的执行影响不大时，可使用此关键词忽略错误，让任务继续顺利执行。\n</code></pre>\n<h4 id=\"432roles\"><strong><div id=\"id4.3.2\">4.3.2、Roles</div></strong></h4>\n<ul>\n<li>Roles 的出现完美解决了在<strong>复杂任务下 playbook 篇幅过长、过于臃肿、缺乏灵活性、维护成本巨大</strong>等问题。</li>\n<li>Roles 的构建严重依赖目录命名规则和目录摆放，所以目录的命名和摆放非常重要。【注：但此处不会详述 Roles 的构建过程。】</li>\n<li>由于运维中的很多业务场景都是一样的，因此可以将一些业务的 Playbook 转换为 Role 格式以供其他人复用。为此，官方提供了一个可托管 Role 的平台，让 Role 角色可以像 APT 软件包一样随下随用。【注：<a href=\"https://galaxy.ansible.com/ui/standalone/roles/\" rel=\"noopener nofollow\" target=\"_blank\">官方地址</a>】</li>\n</ul>\n<p><strong>（1）Role 角色的管理</strong>：</p>\n<pre><code class=\"language-bash\">#列出已安装的 Role\nansible-galaxy role list\n\n#安装找到的 Role\nansible-galaxy role install geerlingguy.nginx\n\n#删除指定的 Role\nansible-galaxy role remove geerlingguy.nginx\n</code></pre>\n<p><strong>（2）Role 角色的应用</strong>：</p>\n<pre><code class=\"language-yaml\">- name: install nginx\n  hosts: linux\n  roles:\n    - role: geerlingguy.nginx\n      vars:\n        v1: a\n        v2: b\n</code></pre>\n<p><strong>（3）Role 角色的结构</strong>：</p>\n<pre><code class=\"language-wiki\">#ansible-galaxy init role_name\n#tree role_name/\n\nrole_name/            \\\\ 角色名称\n├── defaults           \\\\ 为当前角色设定默认变量时使用此目录，应当包含一个main.yml文件；\n│   └── main.yml        \n├── files              \\\\ 存放有copy或script等模块调用的文件\n├── handlers           \\\\ 此目录应当包含一个main.yml文件，用于定义各角色用到的各handler\n│   └── main.yml\n├── meta               \\\\ 应当包含一个main.yml，用于定义角色的特殊设定及其依赖关系；1.3及以后版本支持\n│   └── main.yml\n├── README.md\n├── tasks              \\\\ 至少包含一个名为main.yml的文件，定义了此角色的任务列表\n│   └── main.yml\n├── templates          \\\\ template模块会自动在此目录中寻找Jinja2模板文件\n├── tests\n│   ├── inventory\n│   └── test.yml\n└── vars              \\\\ 应当包含一个main.yml，用于定义此角色用到的变量\n   └── main.yml\n</code></pre>\n<h4 id=\"433handlers\"><strong><div id=\"id4.3.3\">4.3.3、Handlers</div></strong></h4>\n<ul>\n<li>Handler 通过任务关键词 notify 来监视某个 task，一旦 task 的执行结果发生变化，则触发 Handler 任务。</li>\n<li>Handler 任务并不是被 notify 后立刻执行的。默认情况下，是在 <strong>“当前 Play 的所有 tasks 执行完之后”</strong> 才执行。</li>\n<li>默认情况下，在一个 Play 中，只要有 task 执行失败，则 play 终止，即使是与 handler 关联的 task 在失败的 task 之前运行成功了，handler 也不会被执行。如果希望在这种情况下 handler 仍然能够执行，可开启 Play 关键词 <code>force_handlers: yes</code>。</li>\n</ul>\n<pre><code class=\"language-yaml\">- name: handler task test\n  hosts: all\n  force_handlers: yes\n  tasks:\n    - name: a task which always notifies its handler\n      command: /bin/true\n      notify: restart the database\n    - name: a task which fails because the package doesn't exist\n      yum:\n        name: notapkg\n        state: latest\n      \n  handlers:\n    - name: restart the database\n      service:\n        name: mariadb\n        state: restarted\n</code></pre>\n<h3 id=\"44其它技巧\"><strong><div id=\"id4.4\">4.4、其它技巧</div></strong></h3>\n<h4 id=\"441when---判断\"><strong><div id=\"id4.4.1\">4.4.1、When - 判断</div></strong></h4>\n<p>任务关键词 when 可根据某些条件的是否达成来决定 task 是否应该被执行。</p>\n<pre><code class=\"language-yaml\">- name: Install vim\n  hosts: all\n  tasks:\n    - name:Install VIM via yum\n      yum: \n        name: vim-enhanced \n        state: installed\n      when: ansible_os_family == \"RedHat\"\n#      when: some_var | float &gt; 90\n#      when: result is changed\n</code></pre>\n<blockquote>\n<p>注：When 的条件判断<strong>因为可以配合过滤器插件和测试插件使用，故使其变得很灵活也很复杂</strong>，具体可参考<a href=\"https://clay-wangzhi.com/devops/ansible/playbook-if.html\" rel=\"noopener nofollow\" target=\"_blank\">第三方手册</a>或<a href=\"https://docs.ansible.org.cn/ansible/latest/playbook_guide/playbooks_conditionals.html\" rel=\"noopener nofollow\" target=\"_blank\">官方手册</a>查看。</p>\n</blockquote>\n<h4 id=\"442loop---循环\"><strong><div id=\"id4.4.2\">4.4.2、Loop - 循环</div></strong></h4>\n<p>任务关键词 loop 可执行一些重复性的操作。</p>\n<p><strong>（1）普通循环</strong></p>\n<pre><code class=\"language-yaml\">tasks:\n  - name: postfix and httpd are running\n    service:\n      name: \"{{ item }}\"\n      state: started\n    loop:\n      - postfix\n      - httpd\n\n- name: retrieve the list of home directories\n    command: ls /home\n    register: home_dirs\n- name: add home dirs to the backup spooler\n    file: \n      path: /mnt/{{ item }}\n      src: /home/{{ item }}\n      state: link\n    loop: \"{{ home_dirs.stdout_lines }}\"\n</code></pre>\n<p><strong>（2）高级循环</strong></p>\n<pre><code class=\"language-yaml\">- name: test loop\n  hosts: test\n  tasks:\n  - name: add several users\n    user: \n      name: \"{{ item.name }}\"\n      state: present \n      groups: \"{{ item.groups }}\"\n    loop:\n      - { name: 'user1', groups: 'wheel' }\n      - { name: 'user2', groups: 'sudo' }\n</code></pre>\n<blockquote>\n<p>注：loop 循环的用法多种多样，具体可参考<a href=\"https://clay-wangzhi.com/devops/ansible/playbook-for.html\" rel=\"noopener nofollow\" target=\"_blank\">第三方手册</a>或<a href=\"https://docs.ansible.org.cn/ansible/latest/playbook_guide/playbooks_loops.html\" rel=\"noopener nofollow\" target=\"_blank\">官方手册</a>查看。</p>\n</blockquote>\n<h2 id=\"5常用模块\"><div id=\"id5\">5、常用模块</div></h2>\n<p>以下模块均来自默认集合 <a href=\"https://docs.ansible.org.cn/ansible/latest/collections/ansible/builtin/index.html#plugins-in-ansible-builtin\" rel=\"noopener nofollow\" target=\"_blank\">ansible.builtin（面向 linux 系统）</a>。此外，还有两个集合也值得关注，分别是：<a href=\"https://docs.ansible.org.cn/ansible/latest/collections/ansible/windows/index.html#plugins-in-ansible-windows\" rel=\"noopener nofollow\" target=\"_blank\">ansible.windows（面向 windows 系统）</a>、<a href=\"https://docs.ansible.org.cn/ansible/latest/collections/ansible/netcommon/index.html#plugins-in-ansible-netcommon\" rel=\"noopener nofollow\" target=\"_blank\">ansible.netcommon（面向网络设备）</a>。</p>\n<ul>\n<li>\n<p>ping 模块 – 对目标节点进行连通性测试。【示例：<code>ansible localhost -m ping</code>】</p>\n</li>\n<li>\n<p>debug 模块 – Playbook 配置调试。【示例：<code>ansible localhost -m debug -e \"str=123\" -a \"var=str\"</code>】</p>\n</li>\n<li>\n<p><strong>copy 模块</strong> – 将本地文件复制到目标节点。【示例：<code>ansible localhost -m copy -a \"src=/etc/hosts dest=/tmp/hosts mode=0777\"</code>】</p>\n</li>\n<li>\n<p>file 模块 – 管理文件和文件属性。【示例：<code>ansible localhost -m file -a \"path=/tmp/hosts state=directory\"</code> - 新建目录】</p>\n</li>\n<li>\n<p><strong>lineinfile 模块</strong> – 类似 sed 的文本编辑器。【示例：<code>ansible localhost -m lineinfile -a \"path=test  state=present line=c=345 regexp='^a'\"</code> - 将 a 开头的整行替换为 c=345】</p>\n</li>\n<li>\n<p><strong>template 模块</strong> – 将模板文件输出到目标节点。【示例：<code>ansible localhost -m template -a \"src=/root/test.sh.j2 dest=/tmp/test.sh\" -e \"arg=id\"</code> - 将 test.sh.j2 文件中的 arg 变量替换之后，将文件传输到目标节点。】</p>\n<pre><code class=\"language-yaml\"># test.sh.j2 文本内容\n\n#!/bin/sh\n{{ arg }} &gt;&gt; /tmp/id.txt\n</code></pre>\n</li>\n<li>\n<p>package 模块 – 通用软件包管理器。【示例：<code>ansible localhost -m package -a \"name=hello state=present\"</code> - 安装 hello 软件包】</p>\n</li>\n<li>\n<p>service/systemd 模块 – 管理系统服务。【示例：<code>ansible localhost -m service -a \"name=apache2 state=stopped\"</code> - 关闭 apache2 服务】</p>\n</li>\n<li>\n<p>command 模块 – 在目标节点上执行命令，<strong>但该模块不支持像如 通配符、管道符 这类特殊符号</strong>。【示例：<code>ansible localhost -m command -a \"id\"</code>】</p>\n</li>\n<li>\n<p><strong>shell 模块</strong> – 在目标节点上启动一个 shell 然后在其中执行命令。【示例：<code>ansible localhost -m shell -a \"id\"</code>】</p>\n</li>\n<li>\n<p>raw 模块 – 目标节点即便不具备 python 环境，依然能够执行命令，就像是通过 ssh 连接之后执行命令一样，此时将失去 ansible 的<strong>幂等性</strong>特点。【示例：<code>ansible localhost -m raw -a \"id\"</code>】</p>\n</li>\n<li>\n<p><strong>script 模块</strong> –- 将本地脚本传输到目标节点并执行，执行之后脚本被删除。【示例：<code>ansible localhost -m script -a \"/root/test.sh --somearg\"</code>】</p>\n</li>\n</ul>\n<blockquote>\n<p>注：通过 ansible 命令使用 command、shell、raw 这三个模块执行命令时，参数不可以以 <code>ansible localhost -m shell -a \"cmd=id\"</code> 这样的方式使用，只能以 <code>ansible localhost -m shell -a \"id\"</code> 这样的方式使用。</p>\n<p>这是因为：只有这三个模块的“核心参数”不是普通 key = value，而是 _raw_params（裸参数），其余大多模块都是以键值对的方式传递参数的。</p>\n</blockquote>\n<h2 id=\"6常用插件\"><strong><div id=\"id6\">6、常用插件</div></strong></h2>\n<p><a href=\"https://docs.ansible.org.cn/ansible/latest/collections/ansible/builtin/index.html#filter-plugins\" rel=\"noopener nofollow\" target=\"_blank\">过滤器插件</a> 主要配合 when 对一些变量做一些<strong>类型转换</strong>，之后再进行判断。</p>\n<p><a href=\"https://docs.ansible.org.cn/ansible/latest/collections/ansible/builtin/index.html#filter-plugins\" rel=\"noopener nofollow\" target=\"_blank\">查找插件</a> 主要配合插件 lookup 从各种类型的文件中<strong>读取文本内容</strong>。</p>\n<p><a href=\"https://docs.ansible.org.cn/ansible/latest/collections/ansible/builtin/index.html#test-plugins\" rel=\"noopener nofollow\" target=\"_blank\">测试插件</a> 主要配合 when 对变量做一些<strong>条件的判断</strong>。</p>\n<h2 id=\"7杂七杂八\"><strong><div id=\"id7\">7、杂七杂八</div></strong></h2>\n<p>（1）学习参考集合。</p>\n<ul>\n<li>Playbook 参考手册：<a href=\"https://docs.ansible.org.cn/ansible/latest/playbook_guide/index.html\" rel=\"noopener nofollow\" target=\"_blank\">官方</a>/<a href=\"https://clay-wangzhi.com/devops/ansible/dir-handler.html\" rel=\"noopener nofollow\" target=\"_blank\">第三方</a>。</li>\n<li>Inventory 参考手册：<a href=\"https://docs.ansible.org.cn/ansible/latest/inventory_guide/index.html\" rel=\"noopener nofollow\" target=\"_blank\">官方</a>/<a href=\"https://clay-wangzhi.com/devops/ansible/inventory.html\" rel=\"noopener nofollow\" target=\"_blank\">第三方</a>。</li>\n<li>Ansible 模块列表：<a href=\"https://docs.ansible.org.cn/ansible/latest/collections/index_module.html\" rel=\"noopener nofollow\" target=\"_blank\">官方</a>。</li>\n<li>Ansible 集合列表：<a href=\"https://docs.ansible.org.cn/ansible/latest/collections/index.html\" rel=\"noopener nofollow\" target=\"_blank\">官方</a>。</li>\n<li>Ansible 角色商店：<a href=\"https://galaxy.ansible.com/ui/standalone/roles/\" rel=\"noopener nofollow\" target=\"_blank\">官方</a>。</li>\n<li>Playbook 关键词：<a href=\"https://docs.ansible.org.cn/ansible/latest/reference_appendices/playbooks_keywords.html\" rel=\"noopener nofollow\" target=\"_blank\">官方</a>。</li>\n<li>视频教程：<a href=\"https://www.bilibili.com/video/BV1qq4y1u7x2\" rel=\"noopener nofollow\" target=\"_blank\">B 站</a>。</li>\n</ul>\n<p>（2）命令技巧。</p>\n<pre><code class=\"language-bash\">#对主机清单和 playbook 进行语法检查。\nansible-playbook -i hosts --syntax-check playbook\n\n#在开始批量执行任务之前，最好先对所有的目标主机进行通性测试。\nansible all -i hosts -m ping\n\n#查看 web 组有哪些主机\nansible web --list\n\n#以 kali 用户的身份去远程目标，同时再进行 sudo 提权，并打开 5 个并发连接。\nansible lin -i hosts -u kali -k -b -K -f 5 -m command -a \"whoami\"\n</code></pre>\n<p>（3）Playbook 示例。</p>\n<pre><code class=\"language-yaml\">#本配置中的所有内容即代表一个剧本\n\n#剧集一\n- hosts: linux\n  tasks:\n##任务1\n\t- name: install nginx\n      yum:\t\t#yum 模块\n        name: nginx\n        state: present\n##任务2\n\t- name: update nginx config\n      template:\t#template 模块\n        src: nginx.conf.j2\n        dest: /etc/nginx/nginx.conf\n        notify: restart nginx\t#调用处理器\n\n  handlers:\t\t\t\t\t\t#定义处理器\n    - name: restart nginx\n      service:\n        name: nginx\n        state: restarted\n\n#剧集二     \n- hosts: windows\n  collections:\t\t#声明集合，不声明调用集合模块需带集合名称，如 ansible.windows.win_file。\n    - ansible.windows\n  tasks:\n    - name: Remove a file, if present\n  \t  win_file:\t\t#调用 windows 集合中的模块\n    \tpath: C:\\Temp\\foo.conf\n    \tstate: absent\n\n#剧集三\n- hosts: web\n  roles:\t#角色\n    - nginx\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-02 17:46</span>&nbsp;\n<a href=\"https://www.cnblogs.com/kqdssheng\">扛枪的书生</a>&nbsp;\n阅读(<span id=\"post_view_count\">7</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}