{"title":"主页 - 博客园","link":"https://www.cnblogs.com/","description":"主页 - 博客园 RSS","language":"zh-cn","lastBuildDate":"2025-12-22T03:30:03.675Z","items":[{"title":"STM32HAL库中断教程以及分装中断工具函数（附下载地址）","link":"https://www.cnblogs.com/pc2005/p/19381393","description":"<h1 class=\"postTitle\">\n                <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/pc2005/p/19381393\" title=\"发布于 2025-12-22 11:20\">\n    <span role=\"heading\" aria-level=\"2\">STM32HAL库中断教程以及分装中断工具函数（附下载地址）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\n<h1 id=\"文章内容\">文章内容</h1>\n<ol>\n<li>使用HAL库实现引脚外部中断</li>\n<li>封装中断工具函数</li>\n</ol>\n<h1 id=\"快速入门\">快速入门</h1>\n<ol>\n<li>访问git仓库: <a href=\"https://github.com/Guardian-Elf/Guardian-Elf-Embedded\" target=\"_blank\" rel=\"noopener nofollow\">Guardian-Elf/Guardian-Elf-Embedded</a></li>\n<li>找到并下载中断工具文件（2个文件：Interrupt.h/.c）</li>\n<li>由于我的项目中使用了串口来调试中断函数，所以如果报错就把无关的代码删除</li>\n<li>代码示例</li>\n</ol>\n<pre><code class=\"language-c\">// 配置GPIOB的1，0引脚\nvoid Interrupt_Service_Init(void) {  \n    Interrupt_Init(GPIOB, GPIO_PIN_0, 1, 3);  \n    Interrupt_Init(GPIOB, GPIO_PIN_1, 1, 3);  \n}  \n  \n// 中断触发时会执行这两个函数\nvoid Interrupt_0(void) {  \n    OLED_NextPage();  // 这个OLED的驱动函数，你可以改成LED点灯来判断是否成功\n}  \nvoid Interrupt_1(void) {  \n    OLED_PrevPage();  \n}\n</code></pre>\n<h1 id=\"hal库实现串口中断\">HAL库实现串口中断</h1>\n<h2 id=\"初始化引脚\">初始化引脚</h2>\n<pre><code class=\"language-c\">__HAL_RCC_GPIOB_CLK_ENABLE() // 开启引脚使能\n\nGPIO_InitTypeDef GPIO_InitStruct = {0};  \nGPIO_InitStruct.Pin = GPIO_PIN_0;  // GPIOB 0引脚\nGPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;  // 下降沿触发（按键按下为低）\nGPIO_InitStruct.Pull = GPIO_PULLUP;  // 默认上拉，未按下时为高\nGPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;  \nHAL_GPIO_Init(GPIO_PORT, &amp;GPIO_InitStruct);\n\n// 配置中断优先级并使能  \n// EXTI0_IRQn 表示0通道，当A0，B0，C0...触发中断后会激活这个通道\nHAL_NVIC_SetPriority(EXTI0_IRQn, 3, 0);  \nHAL_NVIC_EnableIRQ(EXTI0_IRQn);\n</code></pre>\n<h2 id=\"中断触发函数\">中断触发函数</h2>\n<ol>\n<li>EXTI0_IRQHandler实现</li>\n</ol>\n<pre><code class=\"language-c\">// 当A0，B0，C0...触发中断后会进入这个函数\nvoid EXTI0_IRQHandler(void)    {  \n    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0); // 内部自动处理有关中断的寄存器标志位\n}\n</code></pre>\n<ol start=\"2\">\n<li>HAL_GPIO_EXTI_IRQHandler解析</li>\n</ol>\n<p>这个函数是HAL库自带的，用于自带处理中断标志位，这样用户就可以不用操作寄存器，而是实现具体中断业务代码</p>\n<p>因为这个函数是用来处理所有组的所有引脚的中断，所有需要判断引脚</p>\n<pre><code class=\"language-c\">/**  \n  * @brief  This function handles EXTI interrupt request.  * @param  GPIO_Pin: Specifies the pins connected EXTI line  * @retval None  */void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)  \n{  \n  /* EXTI line interrupt detected */  \n  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)  \n  {  \n    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);  \n    HAL_GPIO_EXTI_Callback(GPIO_Pin);  \n  }  \n}\n</code></pre>\n<p>可以看到当产生中断是会执行HAL_GPIO_EXTI_Callback函数，所以用户只需要重写这个函数即可</p>\n<ol start=\"3\">\n<li>void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)</li>\n</ol>\n<pre><code class=\"language-c\">void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)\n{\n    if(GPIO_Pin == GPIO_PIN_0)\n    {\n        // 这里写你的中断处理代码\n        \n        // 示例：翻转LED\n        HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);\n        \n        // 示例：发送消息\n        // UART_SendString(\"EXTI0 Triggered!\\r\\n\");\n    }\n}\n</code></pre>\n<h1 id=\"结语\">结语</h1>\n<p>如果觉得有帮助到你，就请给仓库一个 star 吧！</p>\n<p>git仓库: <a href=\"https://github.com/Guardian-Elf/Guardian-Elf-Embedded\" target=\"_blank\" rel=\"noopener nofollow\">Guardian-Elf/Guardian-Elf-Embedded</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\" data-last-update-days=\"0.002777777777777778\" data-date-updated=\"2025-12-22 11:24\">2025-12-22 11:20</span>&nbsp;\n<a href=\"https://www.cnblogs.com/pc2005\">PC2005-cloud</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19381393);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19381393', targetLink: 'https://www.cnblogs.com/pc2005/p/19381393', title: 'STM32HAL库中断教程以及分装中断工具函数（附下载地址）' })\">举报</a>\n</div>","guid":{"value":"0d0f5f8c2827fec053165a52cb6e01a3"}},{"title":"追踪链路--使用envoy来记录后端pod真实ip","link":"https://www.cnblogs.com/MrVolleyball/p/19381159","description":"<h1 class=\"postTitle\">\n                <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/MrVolleyball/p/19381159\" title=\"发布于 2025-12-22 11:11\">\n    <span role=\"heading\" aria-level=\"2\">追踪链路--使用envoy来记录后端pod真实ip</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\n<h2 id=\"前言\">前言</h2>\n<p>之前使用了iptables、ipvs，在数据包的必经之路（POSTROUTING）上拦截并且记录日志，本文使用一个比较成熟的组件envoy来记录后端pod的真实ip</p>\n<h2 id=\"环境准备\">环境准备</h2>\n<p>环境准备如同之前</p>\n<pre><code>▶ kubectl get pod  -owide\nNAME                          READY   STATUS    RESTARTS        AGE    IP            NODE     NOMINATED NODE   READINESS GATES\nbackend-6d4cdd4c68-mqzgj      1/1     Running   4               8d     10.244.0.73   wilson   &lt;none&gt;           &lt;none&gt;\nbackend-6d4cdd4c68-qjp9m      1/1     Running   4               7d3h   10.244.0.74   wilson   &lt;none&gt;           &lt;none&gt;\nnginx-test-54d79c7bb8-zmrff   1/1     Running   2               23h    10.244.0.75   wilson   &lt;none&gt;           &lt;none&gt;\n</code></pre>\n<pre><code>▶ kubectl get svc\nNAME              TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                          AGE\nbackend-service   ClusterIP   10.105.148.194   &lt;none&gt;        10000/TCP                        8d\nnginx-test        NodePort    10.110.71.55     &lt;none&gt;        80:30785/TCP                     14d\n</code></pre>\n<p><img alt=\"watermarked-envoy_1\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1416773/202512/1416773-20251217101544698-1932761968.png\" class=\"lazyload\"></p>\n<h2 id=\"envoy\">envoy</h2>\n<p>如同之前所说，需要有一个做负载均衡的组件来转发到后端的多pod，之前使用的是iptables/ipvs，它们对于链路追踪比较困难，那就要有一个组件来代替它们做负载均衡，所以该组件要么在backend之前，要么在nginx之后，那我们选择在nginx之后</p>\n<p><img alt=\"watermarked-envoy_2\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1416773/202512/1416773-20251222105046623-26228955.png\" class=\"lazyload\"></p>\n<h4 id=\"创建envoy-configmap\">创建envoy configmap</h4>\n<pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: envoy-config\ndata:\n  envoy.yaml: |\n    static_resources:\n      listeners:\n        - name: ingress_listener\n          address:\n            socket_address:\n              address: 0.0.0.0\n              port_value: 10000\n          filter_chains:\n            - filters:\n                - name: envoy.filters.network.http_connection_manager\n                  typed_config:\n                    \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n                    stat_prefix: ingress_http\n                    http_protocol_options:\n                      accept_http_10: true\n                    common_http_protocol_options:\n                      idle_timeout: 300s\n                    codec_type: AUTO\n                    route_config:\n                      name: local_route\n                      virtual_hosts:\n                        - name: app\n                          domains: [\"*\"]\n                          routes:\n                            - match: { prefix: \"/test\" }\n                              route:\n                                cluster: app_service\n                    http_filters:\n                      - name: envoy.filters.http.router\n                        typed_config:\n                          \"@type\": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router\n                    access_log:\n                    - name: envoy.access_loggers.stdout\n                      typed_config:\n                        \"@type\": type.googleapis.com/envoy.extensions.access_loggers.stream.v3.StdoutAccessLog\n                        log_format:\n                          text_format: \"[%START_TIME%] \\\"%REQ(:METHOD)% %REQ(X-ENVOY-ORIGINAL-PATH?:PATH)% %PROTOCOL%\\\" %RESPONSE_CODE% %BYTES_SENT% %DURATION% %REQ(X-REQUEST-ID)% \\\"%REQ(USER-AGENT)%\\\" \\\"%REQ(X-FORWARDED-FOR)%\\\" %UPSTREAM_HOST% %UPSTREAM_CLUSTER% %RESPONSE_FLAGS%\\n\"\n\n      clusters:\n        - name: app_service\n          connect_timeout: 1s\n          type: STRICT_DNS\n          lb_policy: ROUND_ROBIN\n          load_assignment:\n            cluster_name: app_service\n            endpoints:\n              - lb_endpoints:\n                  - endpoint:\n                      address:\n                        socket_address:\n                          address: \"backend-service\"\n                          port_value: 10000\n\n    admin:\n      access_log_path: \"/tmp/access.log\"\n      address:\n        socket_address:\n          address: 0.0.0.0\n          port_value: 9901\n\n</code></pre>\n<h4 id=\"创建sidecar\">创建sidecar</h4>\n<p>与nginx-test同pod，通过patch的方式添加container</p>\n<pre><code>kubectl patch deployment nginx-test --type='json' -p='\n[\n  {\n    \"op\": \"add\",\n    \"path\": \"/spec/template/spec/volumes/-\",\n    \"value\": {\n      \"configMap\": {\n        \"defaultMode\": 420,\n        \"name\": \"envoy-config\"\n      },\n      \"name\": \"envoy-config\"\n    }\n  },\n  {\n    \"op\": \"add\",\n    \"path\": \"/spec/template/spec/containers/-\",\n    \"value\": {\n      \"args\": [\n        \"-c\",\n        \"/etc/envoy/envoy.yaml\"\n      ],\n      \"image\": \"registry.cn-beijing.aliyuncs.com/wilsonchai/envoy:v1.32-latest\",\n      \"imagePullPolicy\": \"IfNotPresent\",\n      \"name\": \"envoy\",\n      \"ports\": [\n        {\n          \"containerPort\": 10000,\n          \"protocol\": \"TCP\"\n        },\n        {\n          \"containerPort\": 9901,\n          \"protocol\": \"TCP\"\n        }\n      ],\n      \"volumeMounts\": [\n        {\n          \"mountPath\": \"/etc/envoy\",\n          \"name\": \"envoy-config\"\n        }\n      ]\n    }\n  }\n]'\n</code></pre>\n<pre><code>▶ kubectl get pod -owide -l app=nginx-test\nNAME                          READY   STATUS    RESTARTS       AGE    IP            NODE     NOMINATED NODE   READINESS GATES\nnginx-test-6df974c9f9-qksd4   2/2     Running   0              1d     10.244.0.80   wilson   &lt;none&gt;           &lt;none&gt;\n\n</code></pre>\n<p>在nginx-test pod中额外创建了envoy container，envoy打开了10000端口，并且envoy将访问<code>/test</code>的请求都转发到了<code>backend-service:10000</code>，现在需要将nginx-test的出流量转发至envoy，让envoy做负载均衡</p>\n<h4 id=\"修改nginx-test的upstream\">修改nginx-test的upstream</h4>\n<p>将<code>backend-service</code>改成<code>127.0.0.1</code>，由于在同一个pod，同一个net namespace，直接用127即可</p>\n<pre><code>upstream backend_ups {\n    # server backend-service:10000;\n    server 127.0.0.1:10000;\n}\n\n\nserver {\n    listen       80;\n    listen  [::]:80;\n    server_name  localhost;\n\n    location /test {\n        proxy_pass http://backend_ups;\n    }\n}\n\n</code></pre>\n<p>重启后生效</p>\n<h2 id=\"验证\">验证</h2>\n<p><code>curl 10.22.12.178:30785/test</code>，并且监控envoy的日志<code>kubectl logs -f -l app=nginx-test -c envoy</code></p>\n<pre><code>[2025-12-16T09:45:56.365Z] \"GET /test HTTP/1.0\" 200 40 0 99032619-a060-481d-8f0d-9d773fad9b12 \"curl/7.81.0\" \"-\" 10.105.148.194:10000 app_service -\n</code></pre>\n<p>咦？<code>upstream_host</code>怎么显示得还是<code>10.105.148.194</code>，这是service ip，并不是后端pod的真实ip，这是怎么回事？？</p>\n<h2 id=\"问题解决\">问题解决</h2>\n<p>仔细回想一下负载均衡的工作原理：根据不同的算法（如：rr，wlc等）转发到后端的real server，但是当前提供的后端，依然是k8s的service：<code>backend-service</code>，所以这种配置方式，虽然加了一层envoy，但是本质依然还是使用k8s service作为负载均衡</p>\n<p>k8s service不但提供了负载均衡的作用，还有个重要的功能，就是服务发现，所以必须要使用service来做服务发现，又不能使用service的负载均衡</p>\n<p>所幸k8s提供了headless service来满足这种需求，访问headless service，返回一组running的pod列表，让访问者自定义做负载均衡，ok，那就使用headless试试</p>\n<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-headless-service\nspec:\n  clusterIP: None\n  selector:\n    app: backend\n  ports:\n    - name: http\n      port: 10000\n      targetPort: 10000\n</code></pre>\n<p>这里的<code>clusterIP: None</code>是创建headless service的关键</p>\n<p>再修改envoy的配置文件，将转发修改为headless service</p>\n<pre><code>...\n      clusters:\n        - name: app_service\n          connect_timeout: 1s\n          type: STRICT_DNS\n          lb_policy: ROUND_ROBIN\n          load_assignment:\n            cluster_name: app_service\n            endpoints:\n              - lb_endpoints:\n                  - endpoint:\n                      address:\n                        socket_address:\n                          address: \"backend-headless-service\"\n                          port_value: 10000\n\n...\n</code></pre>\n<pre><code>[2025-12-16T10:05:56.365Z] \"GET /test HTTP/1.0\" 200 40 0 2b029187-cddb-4278-99b8-2953a7e841a0 \"curl/7.81.0\" \"-\" 10.244.0.81:10000 app_service -\n[2025-12-16T10:05:57.453Z] \"GET /test HTTP/1.0\" 200 40 1 384f9394-7ff9-4abb-b0f8-f9b69f2ba992 \"curl/7.81.0\" \"-\" 10.244.0.82:10000 app_service -\n</code></pre>\n<p>确实已经转发到后端真实pod ip去了</p>\n<h2 id=\"小结\">小结</h2>\n<p>当前的架构：</p>\n<p><img alt=\"watermarked-envoy_3\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1416773/202512/1416773-20251222105103234-17784520.png\" class=\"lazyload\"></p>\n<p>每个pod都有一个envoy sidecar，想要节约envoy资源，可以多个pod使用一个envoy，将envoy部署为daemonset，每个节点一个，然后调度到该节点的pod都转发到该envoy即可</p>\n<h2 id=\"联系我\">联系我</h2>\n<ul>\n<li>联系我，做深入的交流</li>\n</ul>\n<p><img alt=\"\" width=\"500\" height=\"200\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1416773/202411/1416773-20241121135740959-1907948957.png#\" class=\"lazyload\"></p>\n<hr>\n<p>至此，本文结束<br>\n在下才疏学浅，有撒汤漏水的，请各位不吝赐教...</p>\n\n</div>\n<div id=\"MySignature\" role=\"contentinfo\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/MrVolleyball/\" target=\"_blank\">it排球君</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/MrVolleyball/p/19381159\" target=\"_blank\">https://www.cnblogs.com/MrVolleyball/p/19381159</a></p>\n<div>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须在文章页面给出原文连接，否则保留追究法律责任的权利。 </div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\" data-last-update-days=\"0\" data-date-updated=\"2025-12-22 11:11\">2025-12-22 11:11</span>&nbsp;\n<a href=\"https://www.cnblogs.com/MrVolleyball\">it排球君</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19381159);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19381159', targetLink: 'https://www.cnblogs.com/MrVolleyball/p/19381159', title: '追踪链路--使用envoy来记录后端pod真实ip' })\">举报</a>\n</div>","guid":{"value":"2846ed9d0ad27094d793bc39e9de00c3"}},{"title":"从零实现富文本编辑器#9-编辑器文本结构变更的受控处理","link":"https://www.cnblogs.com/WindrunnerMax/p/19381254","description":"<h1 class=\"postTitle\">\n                <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/WindrunnerMax/p/19381254\" title=\"发布于 2025-12-22 10:53\">\n    <span role=\"heading\" aria-level=\"2\">从零实现富文本编辑器#9-编辑器文本结构变更的受控处理</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\n<p>先前我们主要处理了浏览器复杂<code>DOM</code>结构的默认行为，以及兼容<code>IME</code>输入法的各种输入场景，以此需要针对性地处理输入法和浏览器兼容的行为。在这里我们关注于处理文本结构性变更行为的处理，主要是针对行级别的操作、文本拖拽操作等，分别处于文本结构结构以及变更操作扩展。</p>\n<ul>\n<li>开源地址: <a href=\"https://github.com/WindRunnerMax/BlockKit\" target=\"_blank\" rel=\"noopener nofollow\">https://github.com/WindRunnerMax/BlockKit</a></li>\n<li>在线编辑: <a href=\"https://windrunnermax.github.io/BlockKit/\" target=\"_blank\" rel=\"noopener nofollow\">https://windrunnermax.github.io/BlockKit/</a></li>\n<li>项目笔记: <a href=\"https://github.com/WindRunnerMax/BlockKit/blob/master/NOTE.md\" target=\"_blank\" rel=\"noopener nofollow\">https://github.com/WindRunnerMax/BlockKit/blob/master/NOTE.md</a></li>\n</ul>\n<details>\n<summary><strong>从零实现富文本编辑器系列文章</strong></summary>\n<ul>\n<li><a href=\"https://www.cnblogs.com/WindrunnerMax/p/18816107\" target=\"_blank\">深感一无所长，准备试着从零开始写个富文本编辑器</a></li>\n<li><a href=\"https://www.cnblogs.com/WindrunnerMax/p/18826249\" target=\"_blank\">从零实现富文本编辑器#2-基于MVC模式的编辑器架构设计</a></li>\n<li><a href=\"https://www.cnblogs.com/WindrunnerMax/p/18840221\" target=\"_blank\">从零实现富文本编辑器#3-基于Delta的线性数据结构模型</a></li>\n<li><a href=\"https://www.cnblogs.com/WindrunnerMax/p/18899981\" target=\"_blank\">从零实现富文本编辑器#4-浏览器选区模型的核心交互策略</a></li>\n<li><a href=\"https://www.cnblogs.com/WindrunnerMax/p/18921725\" target=\"_blank\">从零实现富文本编辑器#5-编辑器选区模型的状态结构表达</a></li>\n<li><a href=\"https://www.cnblogs.com/WindrunnerMax/p/19022750\" target=\"_blank\">从零实现富文本编辑器#6-浏览器选区与编辑器选区模型同步</a></li>\n<li><a href=\"https://www.cnblogs.com/WindrunnerMax/p/19069539\" target=\"_blank\">从零实现富文本编辑器#7-基于组合事件的半受控输入模式</a></li>\n<li><a href=\"https://www.cnblogs.com/WindrunnerMax/p/19152103\" target=\"_blank\">从零实现富文本编辑器#8-浏览器输入模式的非受控DOM行为</a></li>\n<li><a href=\"\" rel=\"noopener nofollow\">从零实现富文本编辑器#9-编辑器文本结构变更的受控处理</a></li>\n</ul>\n</details>\n<h2 id=\"概述\">概述</h2>\n<p>在当前我们主要聊的编辑器输入模式中，主要是关注于文本的半受控输入以及脏<code>DOM</code>的检测，输入状态同步是比较复杂且容易出问题的地方。而在这里我们则关注于输入同步行为扩展，例如回车、删除、拖拽文本等操作，相当于完善了编辑器整体输入模式的处理。</p>\n<p>具体来说，执行换行和删除回车时会变更<code>DOM</code>结构，而删除文本以及拖拽文本同样是由<code>BeforeInput</code>等事件组合执行的，在编辑器中这些操作都是输入的一部分。此外，这些操作通常都是可以受控处理的，因此并不太容易出现脏<code>DOM</code>的问题，但是整体上还是有很多需要注意的点:</p>\n<ul>\n<li>回车操作通常需要拆分当前行结构，并且还需要关注到行格式的继承问题，特别是类似于列表等结构处理起来会更复杂一些。此外由于数据结构本身的设计不同，回车的操作实现也会有很大的差异，还有诸如软回车、硬回车等不同的回车类型。</li>\n<li>删除操作同样会涉及行结构的处理，即删除回车时需要合并行结构，并且也会受到数据结构本身的影响，删除可能并不会符合操作直觉，因此需要手动校正行格式。并且删除的时候还需要关注<code>Unicode</code>字符的处理，特别是类似于<code>Emoji</code>等符号的删除需要特殊处理。</li>\n<li>拖拽操作同样会涉及行结构的处理，而在我们的状态管理中本就是以行为单位进行管理的，因此拖拽行级结构相对会简单，当然实现的交互上还是有些工作量。而文本节点本身同样是可以拖拽的，因此我们同样需要根据选区范围进行文本的剪切和插入。</li>\n</ul>\n<h2 id=\"回车操作\">回车操作</h2>\n<p>在最开始的时候，我们就聊到了<code>ContentEditable</code>的不受控行为，特别是回车操作在不同浏览器中的表现是不一致的。在之前的例子中，我们就提到了回车操作在不同浏览器中的表现差异:</p>\n<ul>\n<li>在空<code>contenteditable</code>编辑器的情况下，直接按下回车键，在<code>Chrome</code>中的表现是会插入<code>&lt;div&gt;&lt;br&gt;&lt;/div&gt;</code>，而在<code>FireFox(&lt;60)</code>中的表现是会插入<code>&lt;br&gt;</code>，<code>IE</code>中的表现是会插入<code>&lt;p&gt;&lt;br&gt;&lt;/p&gt;</code>。</li>\n<li>在有文本的编辑器中，如果在文本中间插入回车例如<code>123|123</code>，在<code>Chrome</code>中的表现内容是<code>123&lt;div&gt;123&lt;/div&gt;</code>，而在<code>FireFox</code>中的表现则是会将内容格式化为<code>&lt;div&gt;123&lt;/div&gt;&lt;div&gt;123&lt;/div&gt;</code>。</li>\n<li>同样在有文本的编辑器中，如果在文本中间插入回车后再删除回车，例如<code>123|123-&gt;123123</code>，在<code>Chrome</code>中的表现内容会恢复原本的<code>123123</code>，而在<code>FireFox</code>中的表现则是会变为<code>&lt;div&gt;123123&lt;/div&gt;</code>。</li>\n</ul>\n<p>其实这些示例其实也写过很多次了，每次提到浏览器的不受控行为都会提到相关的差异，这些默认行为也变成了我们处理状态同步时需要关注的点。而实际上，关于回车的行为本身我们是可以受控处理的，即阻止其默认行为，然后根据当前的选区状态进行行结构的拆分和格式继承等处理。</p>\n<p>通常来说，我们可以通过两种方式阻止默认行为，一种是监听<code>BeforeInput</code>事件并阻止其默认行为，另一种是监听<code>KeyDown</code>事件并阻止其默认行为。前者的好处是可以直接获取到事件的输入类型，例如软硬回车等，而后者的好处则是可以更早地阻止默认行为。</p>\n<p>那么自然的我们还是借助<code>BeforeInput</code>事件来处理回车操作，这样会比较方便一些。那么这里的实现就比较简单，理论上来说我们只需要在数据结构中插入一个<code>\\n</code>的<code>op</code>即可。此外由于我们的编辑器本身不支持软回车，因此这两种类型的回车都需要统一处理为硬回车。</p>\n<pre><code class=\"language-js\">switch (inputType) {\n  case \"insertLineBreak\":\n  case \"insertParagraph\": {\n    this.editor.perform.insertBreak(sel);\n    break;\n  }\n}\n\nexport class Perform {\n  public insertBreak(sel: Range, attributes?: AttributeMap) {\n    const raw = RawRange.fromRange(this.editor, sel);\n    const start = raw.start;\n    const len = raw.len;\n    const delta = new Delta().retain(start);\n    len &amp;&amp; delta.delete(len);\n    delta.insertEOL();\n    this.editor.state.apply(delta, { range: raw });\n  }\n}\n</code></pre>\n<p>这件事看起来并没有那么复杂，因为<code>DOM</code>的结构变更处理是由我们的<code>LineState</code>以及<code>Mutate</code>模块实现的，<code>Mutate</code>模块实现了<code>key</code>值的维护以及<code>immutable</code>。接下来，在<code>React</code>适配器中，我们就可以直接以<code>LineState</code>为基准渲染行结构，渲染这件事就自然而然地交给了<code>React</code>。</p>\n<pre><code class=\"language-js\">/**\n * 数据同步变更, 异步批量绘制变更\n */\nconst onContentChange = useMemoFn(() =&gt; {\n    setLines(state.getLines());\n});\n\n/**\n * 监听内容变更事件, 更新当前块视图\n */\nuseLayoutEffect(() =&gt; {\n  editor.event.on(EDITOR_EVENT.CONTENT_CHANGE, onContentChange);\n  return () =&gt; {\n    editor.event.off(EDITOR_EVENT.CONTENT_CHANGE, onContentChange);\n  };\n}, [editor.event, onContentChange]);\n</code></pre>\n<p><code>Mutate</code>模块实现的算法会比较复杂，这里就暂时先不展开了。简单来说，就是会根据当前的选区位置，找到对应的行结构，然后将其拆分为两行，并且继承当前行的格式属性。当然我们并不是<code>Case By Case</code>地处理，而是根据变更的<code>Delta</code>操作实现一个通用的变更模式。</p>\n<p>看起来插入回车这件事就简单的结束了，然而实际上并没有，这件事复杂的点在于行格式的继承问题。在我们的<code>Mutate</code>的设计中，在行样式的处理上我们是完全遵循着<code>delta</code>的数据结构设计，即最后的<code>EOL</code>节点才承载行样式。</p>\n<p>那么这样会造成一个比较反直觉的问题，如果我们直接在行中间插入<code>\\n</code>的话，原本的行样式是会处于下一行的，因为本质上是因为<code>EOL</code>节点是在末尾的，此时插入<code>\\n</code>自然原本的<code>EOL</code>是会直接跟随到下一行的。</p>\n<p>这个问题本质上是由于<code>\\n</code>太滞后了导致了，而如果我们将承载行内容的节点前提，也就是在行首加入<code>SOL-Start Of Line</code>节点，由该节点来承载样式，<code>\\n</code>节点仅用于分割行，那么在执行<code>Mutate Insert</code>的时候自然就能很轻松地得到将行样式保留在上一行，而不是跟随到下一行。</p>\n<p>但是这种方式很明显会因为破坏了原本的数据结构，因此导致整个状态管理发生新的问题，需要很多额外的<code>Case</code>来处理这个不需要渲染的节点所带来的问题。还有一种方案是在<code>Mutate Iterator</code>对象中加入<code>used</code>标记，当插入的节点为<code>\\n</code>时会检查当前的存量<code>LineState</code>是否被复用过。</p>\n<p>如果没有被复用过的话就直接将该<code>State</code>的<code>key</code>、<code>attrs</code>全部复用过来，当后续的<code>\\n</code>节点再读区时则会因为已经复用过导致无法再复用，此时就是完全重新创建的新状态。</p>\n<p>但是这里的问题是无法很好地保证第二个<code>\\n</code>的实际值，也就是说破坏了我们原本的模型结构，其并不是交换式的，也无法将确定的新值传递到第二个<code>\\n</code>上，而且在<code>Mutate Compose</code>的过程中做这件事是会导致真的需要实现这种效果时无法规避这个行为。</p>\n<p>实际上<code>Quill</code>则是会存在同样的问题，我发现其如果直接执行插入<code>\\n</code>的话也是会将样式跟随到下一行，那么其实这样就意味着其行样式继承是在回车的事件处理的，设想了一下这种方式的处理是合理的，这种情况下我们就可以是完全受控的情况处理。</p>\n<pre><code class=\"language-js\">// https://quilljs.com/playground/snow\nquill.updateContents([{ retain: 3 }, { insert: \"\\n\" }]);\n</code></pre>\n<p>那么回到编辑器回车这件事上，在行格式的继承上，如果接着上述的操作实现，则很容易地可以看出来行格式的继承问题。在下面的例子中，<code>quota</code>表示引用格式，如果在<code>Md</code>中引用是以<code>&gt;</code>在行首表示的，插入回车时原始行应该保持引用格式，而下面的例子中引用格式却仅表现在了新行。</p>\n<pre><code class=\"language-js\">[ { insert: \"abc{caret}def\" }, { insert: \"\\n\", attributes: { quote: \"true\" } } ]\n// 插入回车后 =&gt;\n[ { insert: \"abc\" }, { insert: \"\\n\" }, { insert: \"{caret}def\" }, { insert: \"\\n\", attributes: { quote: \"true\" } } ]\n</code></pre>\n<p>那么在这里就需要区分多种情况，那么如果是在行首，就将当前属性全部带入下一行，即默认的行为。如果在末尾插入回车，则需要将下一行的属性全部清空，此时也需要合并传入的属性。如果在行中间插入属性，则需要拷贝当前行属性放置于当前插入的新行属性，如果此时存在传入的属性则同样需要合并。</p>\n<pre><code class=\"language-js\">// |xx(\\n {y:1}) =&gt; (\\n)xx(\\n {y:1})\n// xx|(\\n {y:1}) =&gt; xx(\\n {y:1})(\\n)\n// xx|(\\n {y:1}) =&gt; xx(\\n {y:1})(\\n &amp; attributes)\n// x|x(\\n {y:1}) =&gt; x(\\n {y:1})x(\\n {y:1})\n// x|x(\\n {y:1}) =&gt; x(\\n {y:1})x(\\n {y:1 &amp; attributes})\n</code></pre>\n<pre><code class=\"language-js\">// 当光标在行首时, 直接移动行属性\n// |xx(\\n {y:1}) =&gt; (\\n)|xx(\\n {y:1} &amp; attributes)\nif (start === startLine.start) {\n  delta.insertEOL();\n  const lineOffset = endLine.length - 1;\n  delta.retain(lineOffset - sel.end.offset).retain(1, attributes);\n  point = new Point(sel.start.line + 1, 0);\n  // 当光标在行尾时, 将行属性保留在当前行\n  // xx|(\\n {y:1}) =&gt; xx(\\n {y:1})(\\n attributes)\n} else if (start === startLine.start + startLine.length - 1) {\n  delta.retain(1).insertEOL(attributes);\n  point = new Point(sel.start.line + 1, 0);\n  // 当光标在行中时, 将行属性保留在当前行, 下一行合并新属性\n  // x|x(\\n {y:1}) =&gt; xx(\\n {y:1})(\\n {y:1} &amp; attributes)\n} else {\n  delta.insertEOL(startLine.attributes);\n  const lineOffset = endLine.length - 1;\n  const attrs = { ...startLine.attributes, ...attributes };\n  delta.retain(lineOffset - sel.end.offset).retain(1, attrs);\n}\n</code></pre>\n<h2 id=\"删除操作\">删除操作</h2>\n<p>删除操作同样是文本结构变更中比较重要的一个操作，而同样的删除也需要关注行结构的合并以及行格式的问题。首先聊的是相对简单的部分，删除文本片段内容，由于本身我们的选区是携带<code>Range</code>信息的，因此删除文本片段内容其实并没有什么复杂的地方，直接根据选区删除对应的内容即可。</p>\n<pre><code class=\"language-js\">export class Perform {\n  public deleteFragment(sel: Range) {\n    if (sel.isCollapsed) return void 0;\n    const raw = RawRange.fromRange(this.editor, sel);\n    if (!raw) return void 0;\n    const len = Math.max(raw.len, 0);\n    const start = Math.max(raw.start, 0);\n    if (start &lt; 0 || len &lt;= 0) return void 0;\n    const delta = new Delta().retain(start).delete(len);\n    this.editor.state.apply(delta, { range: raw });\n    return void 0;\n  }\n}\n</code></pre>\n<p>而删除本身还存在向前删除和向后删除的情况，因此我们需要分别处理<code>deleteContentBackward</code>和<code>deleteContentForward</code>两种输入类型。实际上这两种删除的实现是类似的，主要是计算删除的位置不同而已，但是也需要分别处理行首行末等情况。</p>\n<p>处理<code>backward</code>删除时主要是处理行首删除的情况，即处于当前行的行首, 且存在行状态节点。此时分别处理上个节点为块节点、当前行存在行属性、当前行不存在行属性三种情况，这里的主要目标是删除时要删除当前行结构，以此更加符合操作直觉，并且将光标移动到合适的位置。</p>\n<pre><code class=\"language-js\">// 处于当前行的行首, 且存在行状态节点\nif (line &amp;&amp; sel.start.offset === 0) {\n  const prevLine = line &amp;&amp; line.prev();\n  // 上一行为块节点且处于当前行首时, 删除则移动光标到该节点上\n  if (prevLine &amp;&amp; isBlockLine(prevLine)) {\n  // 当前行为空时特殊处理, 先删除掉该行\n    if (isEmptyLine(line)) {\n      const delta = new Delta().retain(line.start).delete(1);\n      this.editor.state.apply(delta, { autoCaret: false });\n    }\n    const firstLeaf = prevLine.getFirstLeaf();\n    const range = firstLeaf &amp;&amp; firstLeaf.toRange();\n    range &amp;&amp; this.editor.selection.set(range, true);\n    return void 0;\n  }\n  const attrsLength = Object.keys(line.attributes).length;\n  // 如果在当前行的行首, 且存在其他行属性, 则删除当前行的行属性\n  if (attrsLength &gt; 0) {\n    const delta = new Delta().retain(line.start + line.length - 1).retain(1, invertAttributes(line.attributes));\n    this.editor.state.apply(delta, { autoCaret: false });\n    return void 0;\n  }\n  // 如果在当前行的行首, 且不存在其他行属性, 则将当前行属性移到下一行\n  if (prevLine &amp;&amp; !attrsLength) {\n    const prevAttrs = { ...prevLine.attributes };\n    const delta = new Delta().retain(line.start - 1).delete(1).retain(line.length - 1).retain(1, prevAttrs);\n    this.editor.state.apply(delta);\n    return void 0;\n  }\n}\n</code></pre>\n<p>而处理<code>forward</code>删除时主要是处理行末删除的情况，这个情况相对起来会更简单一些，此时并没处理复杂情况，因为其操作更不高频。如果此时光标位于块节点上，那么删除时直接执行当前块节点的删除操作即可。如果光标位于当前行的行末，且下一行为块节点，那么删除时则将光标移动到该块节点上。</p>\n<pre><code class=\"language-js\">// 当前行为块结构时, 执行 backward 删除操作\nif (line &amp;&amp; sel.start.offset === 1 &amp;&amp; isBlockLine(line)) { \n  this.deleteBackward(sel);\n  return void 0;\n}\nconst nextLine = line &amp;&amp; line.next();\n// 下一行为块节点且处于当前行末时, 删除则移动光标到该节点上\nif (line &amp;&amp; sel.start.offset === line.length - 1 &amp;&amp; nextLine &amp;&amp; isBlockLine(nextLine)) {\n  const firstLeaf = nextLine.getFirstLeaf();\n  const range = firstLeaf &amp;&amp; firstLeaf.toRange();\n  range &amp;&amp; this.editor.selection.set(range, true);\n  return void 0;\n}\n</code></pre>\n<p>在删除内容这里最需要关注的其实是视图层问题，当与<code>React</code>结合的视图层面更新时，同样也会出现非受控行为的问题，这里的不受控是<code>React</code>数据层及其渲染层的问题。其实，这里本质上还是跟<code>IME</code>输入的<code>DOM</code>变更有关。</p>\n<p>具体来说，当选区存在跨节点行为时，无论是行内还是跨行的选区，唤醒输入法<code>Composing</code>输入内容后，这部分节点内容会被删除，并且替换为输入的内容。但是当确定内容之后，编辑器便会崩溃，这也是删除与插入的合并操作造成的问题，报错内容如下:</p>\n<pre><code>Failed to execute 'removeChild' on 'Node': The node to be removed is not a child of this node.\n</code></pre>\n<p>从报错上来看，<code>React</code>会将子节点从父节点移除，这本身是非常合理的行为。举个例子，当实现一个列表时，如果数据源删除了某些节点，那么<code>React</code>就会将对应的<code>DOM</code>节点自动移除掉，也就是不需要操作<code>DOM</code>，而是可以直接通过声明式的方式来实现变更。</p>\n<p>那么这里的问题就出现在这些<code>DOM</code>已经实际上被移除了，因此当<code>React</code>尝试移除这些节点时就会报错，而这个异常会导致整个编辑器崩溃，因此我们就需要避免这个情况的发生。那么首先就需要避免<code>removeChild</code>的异常，我们很难直接避免<code>React</code>的行为，因此只能在<code>DOM</code>节点上进行拦截。</p>\n<p>然而，即使是在<code>DOM</code>上处理拦截行为也并不容易，<code>removeChild</code>方法是在<code>Node</code>对象上的，如果我们直接重写<code>Node.prototype.removeChild</code>方法，那么就会影响到整个页面的<code>DOM</code>节点，因此我们只能尝试在编辑器的<code>ref</code>上处理。</p>\n<pre><code class=\"language-js\">/**\n * 重写 removeChild 方法\n * - 避免 IME 破坏跨节点渲染造成问题\n * - https://github.com/facebookarchive/draft-js/issues/1320\n */\nexport const rewriteRemoveChild = (node: Node) =&gt; {\n  const removeChild = Node.prototype.removeChild;\n  node.removeChild = function &lt;T extends Node&gt;(child: T) {\n    if (child.parentNode !== this) return child;\n    return removeChild.call(this, child) as T;\n  };\n};\n</code></pre>\n<p>然而编辑器本身会存在大量的<code>DOM</code>节点，我们很难在所有的节点上进行重写，因此我们还需要限制<code>DOM</code>变动的范围。在<code>React</code>中控制重渲染的方式可以通过<code>key</code>来实现，因此就需要在<code>IME</code>输入起始时刷新相关节点的<code>key</code>，以此来避免<code>React</code>复用这些节点，然后刷新范围就限制在了行节点上。</p>\n<pre><code class=\"language-js\">/**\n * 组合输入开始\n * @param event\n */\n@Bind\nprotected onCompositionStart() {\n  // 需要强制刷新 state.key, 且需要配合 removeChild 避免抛出异常\n  const sel = this.editor.selection.get();\n  if (!sel || sel.isCollapsed) return void 0;\n  for (let i = sel.start.line; i &lt;= sel.end.line; ++i) {\n    const line = this.editor.state.block.getLine(i);\n    line &amp;&amp; line.forceRefresh();\n  }\n}\n</code></pre>\n<p>然后在<code>React</code>控制节点的部分，就需要将重写的逻辑加入到块节点以及行节点的<code>DOM</code>上，以此来避免异常的发生。这里还需要避免<code>ref</code>函数的重复执行，<code>React</code>的特性是如果<code>ref</code>引用不同就会原始的引用再调用新的方法，因此这里需要借助<code>useMemoFn</code>实现。</p>\n<pre><code class=\"language-js\">const setModel = useMemoFn((ref: HTMLDivElement | null) =&gt; {\n  if (ref) {\n    rewriteRemoveChild(ref);\n  }\n});\n</code></pre>\n<p>从本质上来看，是执行输入法时没有办法控制<code>DOM</code>的变更行为，或者阻止浏览器的默认行为。但是我们却可以在<code>start</code>的时候就执行相关的处理，类似于将<code>end</code>时的删除且插入的行为分离出来，也就是说先执行<code>deleteFragment</code>方法，将所有的<code>DOM</code>直接通过先移除掉来同步行为。</p>\n<p>但是这里又出现了新的问题，因为本身的<code>delete</code>方法会将选区内的内容全部删除，这样的话会导致唤醒<code>IME</code>时，选区所在的<code>DOM</code>节点会被删除。因此浏览器会将光标兜底到当前行的起始位置，虽然不影响最终输入的内容，但是在输入的时候就可以明显地看出来问题，有些影响用户体验。</p>\n<p>在这里其实还可以考虑一种实现，在组合输入时同样会删除选区的内容，但是保留光标所在的<code>DOM</code>节点，这个实现就会很复杂。其实如果能在唤醒输入法前就将选区删除并且再设置好光标位置，再出现输入法的话，倒是就不会出现这个问题，然而目前并没有相关的<code>API</code>可以实现这样的行为。</p>\n<p>但是在后期研究<code>slate</code>的实现发现，其仅仅是在<code>IME</code>组合输入开始的时候删除了相关的节点，而我们的编辑器却无法做到。经过排查之后发现是更新内容后的浏览器选区事件被我们阻止了，但是这里的表现也比较奇怪，阻止了选区更新竟然会导致行的该节点后的所有节点都无法渲染出来。</p>\n<pre><code class=\"language-js\">export class Input {\n  @Bind\n  protected onCompositionStart() {\n    // 避免 IME 破坏跨节点渲染造成问题\n    const sel = this.editor.selection.get();\n    if (!sel || sel.isCollapsed) return void 0;\n    this.editor.perform.deleteFragment(sel);\n  }\n}\n</code></pre>\n<p>因此在这里放行选区更新的事件，即在<code>Update Effect</code>时不再通过<code>Composing</code>状态阻止选区的更新行为，这样就可以避免上述的问题了。然而这里的表现确实是非常奇怪的，<code>React</code>确实是持有了<code>DOM</code>状态，而改动就是这里的更新选区行为，选区本身导致节点无法正常渲染实在是有点费解。</p>\n<pre><code class=\"language-js\">useLayoutEffect(() =&gt; {\n  const selection = editor.selection.get();\n  // 渲染完成后更新浏览器选区\n  if (editor.state.isFocused() &amp;&amp; selection) {\n    editor.logger.debug(\"UpdateDOMSelection\");\n    editor.selection.updateDOMSelection(true);\n  }\n});\n</code></pre>\n<h3 id=\"emoji-处理\">Emoji 处理</h3>\n<p><code>Unicode</code>可以视为<code>Map</code>，可以从数值<code>code point</code>映射到具体的字形，这样就可以直接引用符号而不需要实际使用符号本身。可能的代码点值范围是从<code>U+0000</code>到<code>U+10FFFF</code>，有超过<code>110</code>万个可能的符号，为了保持条理性，<code>Unicode</code>将此代码点范围划分为<code>17</code>个平面。</p>\n<p>首个平面<code>U+0000 -&gt; U+FFFF</code>称为基本多语言平面或<code>BMP</code>，包含了最常用的字符。这样<code>BMP</code>之外就剩下大约<code>100</code>万个代码点<code>U+010000 -&gt; U+10FFFF</code>，这些代码点所属的平面称为补充平面或星面。</p>\n<p><code>JavaScript</code>的单个字符由无符号的<code>16</code>位整数支持，因此其无法容纳任何高于<code>U+FFFF</code>的代码点，而是需要将其拆分为代理对。这其实就是<code>JS</code>的<code>UCS-2</code>编码形式，造成了所有字符在<code>JS</code>中都是<code>2</code>个字节，而如果是<code>4</code>个字节的字符，那么就会当作两个双字节的字符处理即代理对。</p>\n<p>其实这么说起来<code>UTF-8</code>的变长<code>1-4</code>字节的编码是无法表示的，代理对自然是可以解决这个问题。而表达<code>UTF-16</code>的编码长度要么是<code>2</code>个字节，要么是<code>4</code>个字节。在<code>ECMAScript 6</code>中引入了新的表达方式，但是为了向后兼容<code>ECMAScript 5</code>依然可以用代理对的形式表示星面。</p>\n<pre><code class=\"language-js\">\"\\u{1F3A8}\"\n// 🎨\n\"\\uD83C\\uDFA8\"\n// 🎨\n</code></pre>\n<p>实际上在<code>ES6</code>中引入的函数也解决了字符串遍历的问题，正则表达式也提供了<code>u</code>修饰符来处理<code>4</code>字节的字符。</p>\n<pre><code class=\"language-js\">Array.from(\"1🎨1\")\n// [\"1\", \"🎨\", \"1\"]\n/^.$/u.test(\"🎨\")\n// true\n\"1🎨1\".split(\"\")\n// [\"1\", \"\\uD83C\", \"\\uDFA8\", \"1\"]\n</code></pre>\n<p>另外在基本平面即低位代理对内，从<code>U+D800</code>到<code>U+DFFF</code>是一个空段，即这些码点不对应任何字符，自然可以避免原本基本平面的冲突，因此可以用来映射辅助平面的字符。高位<code>[\\uD800-\\uDBFF]</code>与低位<code>[\\uDC00-\\uDFFF]</code>恰好是<code>2^10 * 2^10</code>长度，恰好<code>100</code>多万个代码点。</p>\n<pre><code class=\"language-js\">(0xDBFF - 0xD800 + 1) * (0xDFFF - 0xDC00 + 1) = 1024 * 1024 = 1048576\n</code></pre>\n<p>虽然可以已经用<code>Unicode</code>代理对的方式表达<code>4</code>字节符号，但是类似<code>Emoji</code>这些符号是可以组合的。那么这样会导致字形上看起来是单个字符，实际上是通过<code>\\u200d</code>即<code>ZWJ</code>组合起来的字符，因此其长度会更长，且<code>ES6</code>的函数也是会将其拆离表现的。</p>\n<pre><code class=\"language-js\">\"🧑\" + \"\\u200d\" + \"🎨\"\n// 🧑‍🎨\n\"🧑‍🎨\".length\n// 5\nArray.from(\"🧑‍🎨\")\n// [\"🧑\", \"‍\", \"🎨\"]\n</code></pre>\n<p>因此，在这里我们需要在删除之前判断即将要删除的文本长度，这本身其实是可以有多种方式来实现的。例如我们即将要提到的词级别的内容删除，将其转换为非受控的状态来删除，而在这里我们则是通过计算末尾的<code>Unicode</code>字符长度来实现删除。</p>\n<pre><code class=\"language-js\">/**\n * 获取末尾 Unicode 字符长度\n * @param str\n */\nexport const getLastUnicodeLen = (str: string | P.Nil) =&gt; {\n  if (!str || str.length &lt; 2) {\n    return str ? str.length : 0;\n  }\n  const first = str.charCodeAt(str.length - 2);\n  const second = str.charCodeAt(str.length - 1);\n  if (0xd800 &lt; first &amp;&amp; first &lt; 0xdbff &amp;&amp; 0xdc00 &lt; second &amp;&amp; second &lt; 0xdfff) {\n    // 此时基本 Unicode 字符长度为 2\n    let len = 2;\n    // 通过连接符号来组合单个 Unicode 字符长度\n    // [-][-] \\u200d [-][-] \\u200d [-][-]\n    for (let i = str.length - 3; i &gt; 0; i = i - 3) {\n      if (str[i].charCodeAt(0) !== 0x200d) break;\n      len = len + 3;\n    }\n    return len;\n  }\n  return 1;\n};\n</code></pre>\n<h3 id=\"词级文本处理\">词级文本处理</h3>\n<p>先前我们针对<code>Emoji</code>的删除做了特殊处理，因为其本身是多个字符组成的内容，所以在删除时如果直接取长度为<code>1</code>的话会导致出现遗留不可见字符的情况。那么除了<code>Emoji</code>可能存在删除多个字符的情况，使用<code>Alt + Del</code>组合键在默认情况下是删除词级别内容，同样是存在多个字符的情况。</p>\n<p>如果仅仅是使用<code>ContentEditable</code>的情况下，浏览器会自动处理词级别的删除行为，包括<code>Emoji</code>的删除行为也是可以自动处理的。因此针对非受控输入的编辑器例如<code>Quill</code>、飞书文档的实现，是不太需要主动处理相关行为的，主要关注点在于<code>DOM</code>变更后的被动同步状态。</p>\n<p>而在我们实现的编辑器中，因为输入的相关实现是完全基于<code>beforeInput</code>事件来处理的，是完全受控的行为，因此我们必须要主动处理删除的行为。实际上在事件中，<code>inputType</code>值是给出了<code>deleteWordBackward</code>和<code>deleteWordForward</code>的，却没有给出默认行为要删除的长度。</p>\n<p>因此我最开始是想要么改为非受控输入，要么是通过<code>Intl.Segmenter</code>方法来主动分词实现。然而在看到<code>MDN</code>的<code>DEMO</code>之后，发现这个构造器需要传递语言参数，这样的话在编辑器中是没有办法实现的，因为编辑器中无法实际确定语言类型。</p>\n<pre><code class=\"language-js\">const segmenterZH = new Intl.Segmenter(\"ZH-CN\", { granularity: \"word\" });\nconst string1 = \"当前所有功能都是基于插件化定义实现\";\nconst iterator1 = segmenterZH.segment(string1)[Symbol.iterator]();\nconsole.log(iterator1.next().value.segment); // 当前\n</code></pre>\n<p>因此我去找了相关开源编辑器的实现，<code>slate</code>是完全自定义处理的行为，使用<code>getWordDistance</code>来自行计算词的距离。这样对于英文问题不大，但是对于中文词组的处理就比较差了，是以标点符号为准作为切割目标的，因此对于中文实现更像是按句删除了。</p>\n<p>而在<code>Lexical</code>中尝试了删除词组的表现则比较符合预期，本来我以为也是非受控的输入，但是查阅源码后发现同样是基于<code>beforeInput</code>事件来处理的。那么这个表现就非常符合浏览器的行为，本来我以为也是基于<code>Segmenter</code>实现，想查看是如何处理语言问题的，发现首参数是可以不传递的。</p>\n<pre><code class=\"language-js\">const segmenterZH = new Intl.Segmenter(undefined, { granularity: \"word\" });\nconst string1 = \"当前所有功能都是基于插件化定义实现\";\nconst iterator1 = segmenterZH.segment(string1)[Symbol.iterator]();\nconsole.log(iterator1.next().value.segment); // 当前\n</code></pre>\n<p>然而，再细致地查阅源码后发现，<code>Lexical</code>并未直接使用<code>Segmenter</code>来处理分词，而是使用了<code>selection.modify</code>这个<code>API</code>来预处理选区的变更。基于这个<code>API</code>可以同步地变更选区的<code>DOM</code>引用，然后我们就可以立即得到未来的选区状态，因此就可以构造删除的范围。</p>\n<pre><code class=\"language-js\">const root = this.editor.getContainer();\nconst domSelection = getRootSelection(root);\nconst selection = this.current;\nif (!domSelection || !selection) return null;\ndomSelection.modify(ALERT.MOVE, direction, granularity);\nconst staticSel = getStaticSelection(domSelection);\nif (!staticSel || this.limit()) return null;\nconst { startContainer } = staticSel;\nif (!root.contains(startContainer)) return null;\nconst newRange = toModelRange(this.editor, staticSel, false);\nnewRange &amp;&amp; this.set(newRange);\n</code></pre>\n<p>并且在<code>Lexical</code>中还解释了<code>beforeInput</code>事件以及对应的<code>getTargetRanges()</code>方法。由此先前我对于浏览器没有给出默认要删除的长度的判断是错误的，其是通过<code>Range</code>来表达的。但是注释中还提到了这个方案不可靠，其在复杂场景下可能无法正确反应操作后的选区状态。</p>\n<p>而对于使用像<code>Intl.Segmenter</code>等按词组分割的工具，比较容易出错，而且需要对于整个<code>Op</code>进行分词，也有很多不必要的计算。不同语言的分词规则差异巨大，例如英文空格分词以及中文无空格分词，自动识别词边界非常困难，尤其是在涉及自动换行和非罗马语言的情况下会非常困难。</p>\n<ul>\n<li><a href=\"https://github.com/facebook/lexical/blob/af687fa/packages/lexical/src/LexicalSelection.ts#L1605\" target=\"_blank\" rel=\"noopener nofollow\">https://github.com/facebook/lexical/blob/af687fa/packages/lexical/src/LexicalSelection.ts#L1605</a></li>\n</ul>\n<p>总结起来，使用<code>selection.modify</code>方法直接利用了浏览器引擎自身对选区计算的内置、高度优化的逻辑，浏览器如何分词自然是浏览器本身最熟知。此外，实际上<code>BeforeInput</code>事件还有诸多方法，词级别删除这件事本身其实也可以用<code>getTargetRanges</code>来实现。</p>\n<pre><code class=\"language-js\">event.getTargetRanges()[0] // InputEvent\n// StaticRange {startContainer: text, startOffset: 13, endContainer: text, endOffset: 14, collapsed: false}\n</code></pre>\n<h2 id=\"文本拖拽\">文本拖拽</h2>\n<p>既然都提到了<code>getTargetRanges</code>方法，我们自然就可以顺理成章地以此为基础聊一下文本拖拽的实现。在<code>beforeInput</code>事件中，<code>inputType</code>值是有<code>deleteByDrag</code>以及<code>insertFromDrop</code>两种类型，拖拽需要有两个操作组合而来，分别是文本的删除与插入操作。</p>\n<p><code>getTargetRanges</code>方法返回的实际上是个<code>static range</code>数组，因此需要调用先前我们实现的<code>toModelRange</code>方法来转换到编辑器的选区模型。那么移动文本的这个操作实际上只需要关注两个<code>Range</code>，分别记录删除和插入的位置就可以实现了。</p>\n<p>因此基于<code>beforeInput</code>事件的拖拽实现其实是非常简单的，主要是将删除和插入的逻辑组合在一起即可。这里需要放置一个临时的变量，用来记录起始的位置，因为这里是两个事件分别发生的，因此需要将删除的位置保存下来，然后在插入时使用这个位置来移动文本片段。</p>\n<pre><code class=\"language-js\">switch (inputType) {\n  case \"deleteByDrag\": {\n    const domRange = event.getTargetRanges()[0];\n    const range = domRange &amp;&amp; toModelRange(this.editor, domRange, false);\n    this.dragStartRange = range || null;\n  }\n  case \"insertFromDrop\": {\n    const domRange = event.getTargetRanges()[0];\n    const range = domRange &amp;&amp; toModelRange(this.editor, domRange, false);\n    range &amp;&amp; this.editor.perform.moveFragment(this.dragStartRange, range);\n  }\n}\n</code></pre>\n<p>移动内容片段的部分则比较简单，唯一一个需要关注的点是使用了<code>transformPosition</code>函数来处理位置偏移。因为在删除内容片段后，插入位置会发生变化，两次变更的基准都是同一个草稿，而变更则是顺序的关系，此时就需要假设<code>A</code>发生来处理对<code>B</code>的影响。</p>\n<pre><code class=\"language-js\">export class Perform {\n  /**\n   * 移动选区内容片段到目标选区处\n   * @param from\n   * @param to\n   */\n  public moveFragment(from: Range, to: Range) {\n    const rawFrom = RawRange.fromRange(this.editor, from);\n    const rawTo = RawRange.fromRange(this.editor, to);\n    if (!rawFrom || !rawTo) return void 0;\n    const fragment = this.editor.lookup.getFragment(from);\n    if (!fragment) return void 0;\n    const delDelta = new Delta().retain(rawFrom.start).delete(rawFrom.len);\n    const toStart = delDelta.transformPosition(rawTo.start);\n    const insertDelta = new Delta().retain(toStart).merge(new Delta(fragment));\n    const composed = delDelta.compose(insertDelta);\n    this.editor.state.apply(composed, { range: rawTo });\n    return void 0;\n  }\n}\n</code></pre>\n<p>而除了在<code>BeforeInput</code>事件中处理拖拽外，我们还可以在<code>DragEvent</code>事件中处理拖拽的逻辑，在<code>slate</code>中就是基于<code>Drag</code>相关的事件来完成的。实际上这也是在阻止<code>Drag</code>默认行为后，手动处理拖拽的逻辑，如果需要接管诸如图片的拖拽行为等，那么就必须要采用这个方案了。</p>\n<p>基于<code>DragEvent</code>的方案中，主要关注点有三部分，首先是需要在<code>DragStart</code>事件中将当前的选区位置在<code>dataTransfer</code>中保存下来，其次是在<code>DragOver</code>事件中阻止默认行为以允许拖拽，最后是在<code>Drop</code>事件中获取拖拽的内容并且执行移动操作。下面是<code>Slate</code>中的实现:</p>\n<pre><code class=\"language-js\">&lt;div\n  onDragStart={useCallback(() =&gt; {\n    ReactEditor.setFragmentData(\n      editor,\n      event.dataTransfer,\n      'drag'\n    )\n   }, [])}\n  onDragOver={useCallback(() =&gt; {\n    event.preventDefault();\n  }, [])}\n  onDrop={useCallback(() =&gt; {\n    const draggedRange = editor.selection\n    const range = ReactEditor.findEventRange(editor, event);\n    const data = event.dataTransfer\n    Transforms.delete(editor, { at: draggedRange })\n    Transforms.select(editor, range)\n    ReactEditor.insertData(editor, data)\n  }, [])}\n&gt;&lt;/div&gt;\n</code></pre>\n<p>在这里的<code>findEventRange</code>方法是比较需要关注的，因为此时的<code>DragEvent</code>并没有提供类似于<code>getTargetRanges</code>的方法，因此我们并没有办法直接获取拖拽的目标位置。在之前我们提到了在<code>DOM</code>基础上的自绘选区实现，在这里仍然可以调用相关<code>API</code>来实现指定位置的选区获取。</p>\n<pre><code class=\"language-js\">let domRange: Range;\nif (document.caretRangeFromPoint) {\n  domRange = document.caretRangeFromPoint(x, y);\n} else {\n  const position = document.caretPositionFromPoint(x, y);\n  if (position) {\n    domRange = document.createRange();\n    domRange.setStart(position.offsetNode, position.offset);\n    domRange.setEnd(position.offsetNode, position.offset);\n  }\n}\nconst range = domRange &amp;&amp; toModelRange(this.editor, domRange, false);\n// ...\n</code></pre>\n<h2 id=\"总结\">总结</h2>\n<p>先前我们针对性地处理输入法和浏览器兼容的行为，由于输入法会直接操作<code>DOM</code>，因此实现编辑器模型的输入状态同步需要处理很多问题。而在这里我们关注于处理文本结构性变更行为的处理，主要是实现了回车插入、删除、拖拽等文本变更行为的处理，至此完成了编辑器输入同步部分的实现。</p>\n<p>接下来我们需要实现编辑器的视图层同步能力，即<code>React/Vue</code>等视图层的适配器实现，以此来对接核心层的编辑器模型。先前我们已经实现了模型层<code>delta</code>、控制器层<code>core</code>，再加上视图层的适配器<code>react</code>，就可以完整实现编辑器的<code>MVC</code>框架了。</p>\n<h2 id=\"每日一题\">每日一题</h2>\n<ul>\n<li><a href=\"https://github.com/WindRunnerMax/EveryDay\" target=\"_blank\" rel=\"noopener nofollow\">https://github.com/WindRunnerMax/EveryDay</a></li>\n</ul>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li><a href=\"https://mathiasbynens.be/notes/javascript-unicode\" target=\"_blank\" rel=\"noopener nofollow\">https://mathiasbynens.be/notes/javascript-unicode</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2014/12/unicode.html\" target=\"_blank\" rel=\"noopener nofollow\">http://www.ruanyifeng.com/blog/2014/12/unicode.html</a></li>\n<li><a href=\"https://eev.ee/blog/2015/09/12/dark-corners-of-unicode\" target=\"_blank\" rel=\"noopener nofollow\">https://eev.ee/blog/2015/09/12/dark-corners-of-unicode</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/InputEvent\" target=\"_blank\" rel=\"noopener nofollow\">https://developer.mozilla.org/zh-CN/docs/Web/API/InputEvent</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Selection/modify\" target=\"_blank\" rel=\"noopener nofollow\">https://developer.mozilla.org/zh-CN/docs/Web/API/Selection/modify</a></li>\n<li><a href=\"https://w3c.github.io/input-events/#interface-InputEvent-Attributes\" target=\"_blank\" rel=\"noopener nofollow\">https://w3c.github.io/input-events/#interface-InputEvent-Attributes</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/InputEvent/getTargetRanges\" target=\"_blank\" rel=\"noopener nofollow\">https://developer.mozilla.org/zh-CN/docs/Web/API/InputEvent/getTargetRanges</a></li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\" data-last-update-days=\"0\" data-date-updated=\"2025-12-22 10:53\">2025-12-22 10:53</span>&nbsp;\n<a href=\"https://www.cnblogs.com/WindrunnerMax\">WindRunnerMax</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19381254);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19381254', targetLink: 'https://www.cnblogs.com/WindrunnerMax/p/19381254', title: '从零实现富文本编辑器#9-编辑器文本结构变更的受控处理' })\">举报</a>\n</div>","guid":{"value":"00de918bb64fdb0cb074115b56da9883"}},{"title":"Spring+MyBatis环境下SqlSession管理机制详解","link":"https://www.cnblogs.com/sun-10387834/p/19368685","description":"<h1 class=\"postTitle\">\n                <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sun-10387834/p/19368685\" title=\"发布于 2025-12-22 10:49\">\n    <span role=\"heading\" aria-level=\"2\">Spring+MyBatis环境下SqlSession管理机制详解</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\n<p><strong>在生产环境中，我们几乎从不手动管理SqlSession</strong>，而是由Spring框架来管理。让我详细解释这套机制。</p>\n<h2 id=\"一springmybatis的整合模式\">一、Spring+MyBatis的整合模式</h2>\n<h3 id=\"11-核心组件sqlsessiontemplate\">1.1 核心组件：SqlSessionTemplate</h3>\n<pre><code class=\"language-java\">// Spring管理SqlSession的核心组件\npublic class SqlSessionTemplate implements SqlSession, DisposableBean {\n    \n    private final SqlSessionFactory sqlSessionFactory;\n    private final ExecutorType executorType;\n    \n    // 关键：通过ThreadLocal为每个线程绑定SqlSession\n    private final ThreadLocal&lt;SqlSession&gt; sqlSessionHolder = \n        new ThreadLocal&lt;&gt;();\n    \n    // 执行数据库操作\n    public &lt;T&gt; T selectOne(String statement) {\n        // 1. 获取当前线程的SqlSession\n        SqlSession sqlSession = getSqlSession();\n        try {\n            // 2. 执行查询\n            return sqlSession.selectOne(statement);\n        } finally {\n            // 3. 不关闭！由Spring管理生命周期\n        }\n    }\n}\n</code></pre>\n<h2 id=\"二spring如何管理sqlsession生命周期\">二、Spring如何管理SqlSession生命周期</h2>\n<h3 id=\"21-三种主要模式\">2.1 三种主要模式</h3>\n<h4 id=\"模式1mapper代理模式最常用\"><strong>模式1：Mapper代理模式（最常用）</strong></h4>\n<pre><code class=\"language-java\">// 配置类\n@Configuration\n@MapperScan(\"com.example.mapper\")  // 自动扫描Mapper接口\npublic class MyBatisConfig {\n    @Bean\n    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {\n        SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();\n        factoryBean.setDataSource(dataSource);\n        return factoryBean.getObject();\n    }\n}\n\n// Service中使用\n@Service\npublic class UserService {\n    // 直接注入Mapper接口，不需要知道SqlSession\n    @Autowired\n    private UserMapper userMapper;\n    \n    public User getUser(Long id) {\n        // Spring自动管理SqlSession\n        return userMapper.selectById(id);\n    }\n}\n</code></pre>\n<h4 id=\"模式2sqlsessiontemplate直接使用\"><strong>模式2：SqlSessionTemplate直接使用</strong></h4>\n<pre><code class=\"language-java\">@Service\npublic class UserService {\n    \n    @Autowired\n    private SqlSessionTemplate sqlSessionTemplate;\n    \n    public User getUser(Long id) {\n        // 手动获取Mapper（较少使用）\n        UserMapper mapper = sqlSessionTemplate.getMapper(UserMapper.class);\n        return mapper.selectById(id);\n    }\n}\n</code></pre>\n<h3 id=\"22-核心问题解答一次请求是否对应一个sqlsession\">2.2 核心问题解答：<strong>一次请求是否对应一个SqlSession？</strong></h3>\n<p><strong>答案是：取决于事务配置！</strong></p>\n<h2 id=\"三不同场景下的sqlsession管理\">三、不同场景下的SqlSession管理</h2>\n<h3 id=\"31-无事务方法每次mapper方法调用都是新的sqlsession\">3.1 无事务方法：每次Mapper方法调用都是新的SqlSession</h3>\n<pre><code class=\"language-java\">@Service\npublic class UserService {\n    \n    @Autowired\n    private UserMapper userMapper;\n    \n    // 没有@Transactional注解\n    public void demoNoTransaction() {\n        System.out.println(\"=== 无事务方法演示 ===\");\n        \n        // 第一次查询：创建新的SqlSession1\n        User user1 = userMapper.selectById(1);\n        System.out.println(\"查询1：创建SqlSession1，执行SQL\");\n        \n        // 第二次查询：创建新的SqlSession2\n        User user2 = userMapper.selectById(1);\n        System.out.println(\"查询2：创建SqlSession2，执行SQL\");\n        \n        // 结论：两次查询在两个不同的SqlSession中\n        // 一级缓存不生效！会执行两次SQL\n    }\n}\n</code></pre>\n<h3 id=\"32-有事务方法整个方法使用同一个sqlsession\">3.2 有事务方法：整个方法使用同一个SqlSession</h3>\n<pre><code class=\"language-java\">@Service\npublic class UserService {\n    \n    @Autowired\n    private UserMapper userMapper;\n    \n    @Transactional  // 关键注解！\n    public void demoWithTransaction() {\n        System.out.println(\"=== 有事务方法演示 ===\");\n        \n        // 第一次查询：创建SqlSession\n        User user1 = userMapper.selectById(1);\n        System.out.println(\"查询1：创建SqlSession，执行SQL\");\n        \n        // 第二次查询：复用同一个SqlSession\n        User user2 = userMapper.selectById(1);\n        System.out.println(\"查询2：复用SqlSession，从一级缓存读取，无SQL\");\n        \n        // 第三次查询不同参数\n        User user3 = userMapper.selectById(2);\n        System.out.println(\"查询3：参数不同，执行SQL\");\n        \n        // 第四次查询相同参数\n        User user4 = userMapper.selectById(2);\n        System.out.println(\"查询4：从一级缓存读取，无SQL\");\n        \n        // 方法结束：提交事务，关闭SqlSession\n        System.out.println(\"方法结束：提交事务，关闭SqlSession\");\n        \n        // 结论：整个方法在同一个SqlSession中\n        // 一级缓存生效！相同查询只执行一次SQL\n    }\n}\n</code></pre>\n<h3 id=\"33-web请求场景通常每个请求是一个事务\">3.3 Web请求场景：通常每个请求是一个事务</h3>\n<pre><code class=\"language-java\">@RestController\n@RequestMapping(\"/users\")\npublic class UserController {\n    \n    @Autowired\n    private UserService userService;\n    \n    @GetMapping(\"/{id}\")\n    // @Transactional  // Controller层一般不直接加事务\n    public User getUser(@PathVariable Long id) {\n        // 通常Service方法有@Transactional\n        return userService.getUserWithCache(id);\n    }\n}\n\n@Service\npublic class UserService {\n    \n    @Transactional  // Service层加事务，一个HTTP请求对应一个事务\n    public User getUserWithCache(Long id) {\n        // 这个Service方法中的所有数据库操作\n        // 都在同一个SqlSession中\n        // 一级缓存生效\n        return userMapper.selectById(id);\n    }\n}\n</code></pre>\n<h2 id=\"四spring事务管理机制\">四、Spring事务管理机制</h2>\n<h3 id=\"41-事务管理器与sqlsession绑定\">4.1 事务管理器与SqlSession绑定</h3>\n<pre><code class=\"language-java\">// Spring的事务管理机制\npublic class SpringManagedTransaction implements Transaction {\n    \n    private final DataSource dataSource;\n    private Connection connection;\n    private boolean isConnectionTransactional;\n    \n    // 获取连接（关键：从事务同步管理器中获取）\n    @Override\n    public Connection getConnection() throws SQLException {\n        if (this.connection == null) {\n            openConnection();\n        }\n        return this.connection;\n    }\n    \n    private void openConnection() throws SQLException {\n        // 从Spring的事务同步管理器中获取连接\n        this.connection = DataSourceUtils.getConnection(this.dataSource);\n        this.isConnectionTransactional = DataSourceUtils.isConnectionTransactional(\n            this.connection, this.dataSource);\n    }\n}\n</code></pre>\n<h3 id=\"42-事务传播行为的影响\">4.2 事务传播行为的影响</h3>\n<pre><code class=\"language-java\">@Service\npublic class ComplexService {\n    \n    @Autowired\n    private UserMapper userMapper;\n    @Autowired\n    private OrderMapper orderMapper;\n    \n    // 外层事务\n    @Transactional(propagation = Propagation.REQUIRED)\n    public void complexBusiness(Long userId) {\n        // 在事务中：创建/获取SqlSession1\n        User user = userMapper.selectById(userId);  // SqlSession1\n        \n        // 调用内层方法（默认REQUIRED，加入现有事务）\n        processOrders(userId);  // 仍然使用SqlSession1\n        \n        // 结论：整个方法使用同一个SqlSession\n    }\n    \n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    public void processOrders(Long userId) {\n        // 创建新的事务，新的SqlSession2\n        List&lt;Order&gt; orders = orderMapper.selectByUserId(userId);  // SqlSession2\n        \n        // 与complexBusiness方法不在同一个SqlSession\n        // 一级缓存不共享\n    }\n    \n    @Transactional(propagation = Propagation.NOT_SUPPORTED)\n    public void logOperation(Long userId) {\n        // 非事务执行，没有SqlSession绑定\n        // 每次数据库操作可能使用不同的SqlSession\n    }\n}\n</code></pre>\n<h2 id=\"五如何判断当前是否在同一个sqlsession中\">五、如何判断当前是否在同一个SqlSession中</h2>\n<h3 id=\"51-调试方法查看sqlsession-id\">5.1 调试方法：查看SqlSession ID</h3>\n<pre><code class=\"language-java\">@Service\npublic class DebugService {\n    \n    @Autowired\n    private SqlSessionTemplate sqlSessionTemplate;\n    \n    @Transactional\n    public void debugSqlSession() {\n        // 方法1：获取当前SqlSession（仅用于调试）\n        SqlSession sqlSession = sqlSessionTemplate.getSqlSessionFactory()\n            .openSession();\n        \n        // 获取SqlSession的唯一标识\n        System.out.println(\"SqlSession hashCode: \" + sqlSession.hashCode());\n        \n        // 方法2：通过反射查看ThreadLocal中的SqlSession\n        try {\n            Field field = sqlSessionTemplate.getClass()\n                .getDeclaredField(\"sqlSessionHolder\");\n            field.setAccessible(true);\n            ThreadLocal&lt;SqlSession&gt; holder = (ThreadLocal&lt;SqlSession&gt;) field.get(sqlSessionTemplate);\n            SqlSession currentSession = holder.get();\n            System.out.println(\"Current SqlSession: \" + currentSession.hashCode());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>\n<h3 id=\"52-实践判断方法\">5.2 实践判断方法</h3>\n<pre><code class=\"language-java\">public class SqlSessionInspector {\n    \n    /**\n     * 判断两个操作是否在同一个SqlSession中的实用方法\n     * \n     * 规则：\n     * 1. 在同一个@Transactional方法中 → 同一个SqlSession ✓\n     * 2. 在同一个Service方法中（无@Transactional）→ 可能不同 ✗\n     * 3. 跨Service方法调用 → 取决于事务传播行为\n     */\n    public static boolean isSameSqlSession() {\n        // 实际判断逻辑：\n        // 1. 查看当前线程是否有活跃事务\n        TransactionStatus status = TransactionAspectSupport.currentTransactionStatus();\n        return status != null &amp;&amp; !status.isCompleted();\n    }\n}\n</code></pre>\n<h2 id=\"六生产环境配置示例\">六、生产环境配置示例</h2>\n<h3 id=\"61-spring-boot--mybatis配置\">6.1 Spring Boot + MyBatis配置</h3>\n<pre><code class=\"language-yaml\"># application.yml\nmybatis:\n  configuration:\n    cache-enabled: true  # 开启二级缓存\n    local-cache-scope: statement  # 一级缓存作用域\n    \nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/test\n    username: root\n    password: 123456\n    hikari:\n      maximum-pool-size: 20\n      \n  # 事务管理配置\n  transaction:\n    default-timeout: 30  # 事务超时时间30秒\n</code></pre>\n<h3 id=\"62-事务配置类\">6.2 事务配置类</h3>\n<pre><code class=\"language-java\">@Configuration\n@EnableTransactionManagement  // 启用事务管理\npublic class TransactionConfig {\n    \n    @Bean\n    public PlatformTransactionManager transactionManager(DataSource dataSource) {\n        return new DataSourceTransactionManager(dataSource);\n    }\n    \n    @Bean\n    public TransactionTemplate transactionTemplate(PlatformTransactionManager manager) {\n        TransactionTemplate template = new TransactionTemplate(manager);\n        template.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);\n        template.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);\n        return template;\n    }\n}\n</code></pre>\n<h2 id=\"七实际案例分析\">七、实际案例分析</h2>\n<h3 id=\"71-案例1web应用中的典型流程\">7.1 案例1：Web应用中的典型流程</h3>\n<pre><code class=\"language-java\">// HTTP请求：GET /users/1\n// 1. 请求到达DispatcherServlet\n// 2. 调用UserController.getUser(1)\n// 3. 调用UserService.getUserWithCache(1)\n\n@Slf4j\n@Service\npublic class UserService {\n    \n    @Autowired\n    private UserMapper userMapper;\n    \n    @Transactional(readOnly = true)\n    public User getUserWithCache(Long id) {\n        log.info(\"开始查询用户 {}\", id);\n        \n        // 第一次查询\n        long start1 = System.currentTimeMillis();\n        User user1 = userMapper.selectById(id);\n        log.info(\"第一次查询耗时: {}ms\", System.currentTimeMillis() - start1);\n        \n        // 第二次查询（应该从一级缓存读取）\n        long start2 = System.currentTimeMillis();\n        User user2 = userMapper.selectById(id);\n        log.info(\"第二次查询耗时: {}ms\", System.currentTimeMillis() - start2);\n        \n        // 验证是同一个对象（一级缓存直接返回引用）\n        boolean sameReference = (user1 == user2);\n        log.info(\"两次查询返回同一对象: {}\", sameReference);\n        \n        return user2;\n    }\n}\n\n// 日志输出：\n// 第一次查询耗时: 15ms  (执行SQL)\n// 第二次查询耗时: 0ms   (一级缓存)\n// 两次查询返回同一对象: true\n</code></pre>\n<h3 id=\"72-案例2批量操作优化\">7.2 案例2：批量操作优化</h3>\n<pre><code class=\"language-java\">@Service\npublic class BatchService {\n    \n    @Autowired\n    private UserMapper userMapper;\n    \n    // 错误示例：非事务中批量查询\n    public List&lt;User&gt; getUsersWrong(List&lt;Long&gt; ids) {\n        List&lt;User&gt; users = new ArrayList&lt;&gt;();\n        for (Long id : ids) {\n            // 每次循环都创建新的SqlSession\n            User user = userMapper.selectById(id);  // N次SQL查询\n            users.add(user);\n        }\n        return users;\n    }\n    \n    // 正确示例1：使用事务包装\n    @Transactional(readOnly = true)\n    public List&lt;User&gt; getUsersRight1(List&lt;Long&gt; ids) {\n        List&lt;User&gt; users = new ArrayList&lt;&gt;();\n        for (Long id : ids) {\n            // 同一个SqlSession，但相同查询只执行一次\n            User user = userMapper.selectById(id);\n            users.add(user);\n        }\n        return users;\n    }\n    \n    // 正确示例2：批量查询方法\n    public List&lt;User&gt; getUsersRight2(List&lt;Long&gt; ids) {\n        // 一次SQL查询，返回所有结果\n        return userMapper.selectByIds(ids);\n    }\n    \n    // 正确示例3：使用IN查询\n    @Select(\"&lt;script&gt;\" +\n            \"SELECT * FROM user WHERE id IN \" +\n            \"&lt;foreach collection='ids' item='id' open='(' separator=',' close=')'&gt;\" +\n            \"#{id}\" +\n            \"&lt;/foreach&gt;\" +\n            \"&lt;/script&gt;\")\n    List&lt;User&gt; selectByIds(@Param(\"ids\") List&lt;Long&gt; ids);\n}\n</code></pre>\n<h2 id=\"八最佳实践总结\">八、最佳实践总结</h2>\n<h3 id=\"81-判断规则总结\">8.1 判断规则总结</h3>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>是否同一个SqlSession</th>\n<th>一级缓存是否生效</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>同一个@Transactional方法内</strong></td>\n<td>✓ 是</td>\n<td>✓ 生效</td>\n</tr>\n<tr>\n<td><strong>同一个非事务方法内</strong></td>\n<td>✗ 否（每次调用新建）</td>\n<td>✗ 不生效</td>\n</tr>\n<tr>\n<td><strong>跨@Transactional方法调用</strong></td>\n<td>取决于传播行为</td>\n<td>可能不生效</td>\n</tr>\n<tr>\n<td><strong>Web请求（Service有@Transactional）</strong></td>\n<td>✓ 是（每个请求一个）</td>\n<td>✓ 生效</td>\n</tr>\n<tr>\n<td><strong>异步方法（@Async）</strong></td>\n<td>✗ 否（不同线程）</td>\n<td>✗ 不生效</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"82-生产环境建议\">8.2 生产环境建议</h3>\n<ol>\n<li>\n<p><strong>Service层添加事务注解</strong>：</p>\n<pre><code class=\"language-java\">@Service\n@Transactional(readOnly = true)  // 类级别默认只读\npublic class UserService {\n    \n    @Transactional  // 写操作单独标记\n    public User updateUser(User user) {\n        // ...\n    }\n}\n</code></pre>\n</li>\n<li>\n<p><strong>合理设置事务边界</strong>：</p>\n<pre><code class=\"language-java\">// 合适的事务边界：一个完整的业务操作\n@Transactional\npublic Order createOrder(OrderRequest request) {\n    // 验证库存\n    // 扣减库存\n    // 创建订单\n    // 记录日志\n    // 所有操作在同一个事务中\n}\n</code></pre>\n</li>\n<li>\n<p><strong>监控SqlSession使用</strong>：</p>\n<pre><code class=\"language-java\">// 添加监控点\n@Aspect\n@Component\npublic class SqlSessionMonitor {\n    \n    @Around(\"@within(org.springframework.stereotype.Service)\")\n    public Object monitor(ProceedingJoinPoint joinPoint) throws Throwable {\n        String methodName = joinPoint.getSignature().getName();\n        long start = System.currentTimeMillis();\n        \n        try {\n            return joinPoint.proceed();\n        } finally {\n            long duration = System.currentTimeMillis() - start;\n            if (duration &gt; 1000) {  // 超过1秒警告\n                log.warn(\"方法 {} 执行时间过长: {}ms\", methodName, duration);\n            }\n        }\n    }\n}\n</code></pre>\n</li>\n<li>\n<p><strong>一级缓存注意事项</strong>：</p>\n<ul>\n<li>长事务可能导致一级缓存积累大量数据</li>\n<li>考虑设置<code>localCacheScope=STATEMENT</code>（每次查询后清空一级缓存）</li>\n<li>复杂对象修改可能影响缓存中的对象</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"九常见问题解答\">九、常见问题解答</h2>\n<h3 id=\"q1spring-boot中默认的sqlsession管理策略是什么\">Q1：Spring Boot中默认的SqlSession管理策略是什么？</h3>\n<p>A：Spring Boot + MyBatis Starter默认配置：</p>\n<ul>\n<li>使用<code>SqlSessionTemplate</code>管理SqlSession</li>\n<li>默认不开启事务时，每个Mapper方法调用使用新的SqlSession</li>\n<li>开启事务时，整个事务使用同一个SqlSession</li>\n</ul>\n<h3 id=\"q2如何查看当前是否有活跃的sqlsession\">Q2：如何查看当前是否有活跃的SqlSession？</h3>\n<pre><code class=\"language-java\">// 方法1：通过TransactionSynchronizationManager\nboolean hasActiveTransaction = TransactionSynchronizationManager\n    .isActualTransactionActive();\n\n// 方法2：通过DataSourceUtils\nConnection conn = DataSourceUtils.getConnection(dataSource);\nboolean isTransactional = DataSourceUtils.isConnectionTransactional(conn, dataSource);\n</code></pre>\n<h3 id=\"q3一级缓存在微服务架构中有什么问题\">Q3：一级缓存在微服务架构中有什么问题？</h3>\n<p>A：在微服务中：</p>\n<ul>\n<li>每个实例有自己的JVM，一级缓存不共享</li>\n<li>可能导致不同实例数据不一致</li>\n<li>建议：关闭一级缓存或设置很短的作用域，使用分布式缓存</li>\n</ul>\n<h3 id=\"q4如何强制清空一级缓存\">Q4：如何强制清空一级缓存？</h3>\n<pre><code class=\"language-java\">@Service\npublic class CacheService {\n    \n    @Autowired\n    private SqlSessionTemplate sqlSessionTemplate;\n    \n    public void clearLocalCache() {\n        // 获取当前SqlSession并清空缓存\n        sqlSessionTemplate.clearCache();\n    }\n    \n    @Transactional\n    public void updateAndClear() {\n        // 更新操作会自动清空相关缓存\n        userMapper.updateUser(user);\n        \n        // 如果需要手动清空\n        sqlSessionTemplate.clearCache();\n    }\n}\n</code></pre>\n<h2 id=\"总结\">总结</h2>\n<p>在生产环境中，<strong>Spring通过事务管理自动控制SqlSession的生命周期</strong>：</p>\n<ol>\n<li><strong>没有事务</strong>：每次Mapper方法调用都创建新的SqlSession</li>\n<li><strong>有事务</strong>：整个事务使用同一个SqlSession（通常是一个HTTP请求对应一个事务）</li>\n</ol>\n<p><strong>关键判断标准</strong>：</p>\n<ul>\n<li>查看方法是否有<code>@Transactional</code>注解</li>\n<li>同一个<code>@Transactional</code>方法内 → 同一个SqlSession → 一级缓存生效</li>\n<li>不同方法或没有事务 → 不同SqlSession → 一级缓存不生效</li>\n</ul>\n<p>实际开发中，我们通常：</p>\n<ol>\n<li>在Service层方法添加<code>@Transactional</code></li>\n<li>让Spring自动管理SqlSession</li>\n<li>通过事务边界控制一级缓存的作用范围</li>\n<li>监控长事务避免一级缓存过大</li>\n</ol>\n<p>这样既能享受一级缓存的性能优势，又避免了手动管理SqlSession的复杂性。</p>\n\n</div>\n<div id=\"MySignature\" role=\"contentinfo\">\n    \n<p>❤️ 如果你喜欢这篇文章，请点赞支持！ 👍 同时欢迎关注我的博客，获取更多精彩内容！</p>\n\n<p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/sun-10387834/\" target=\"_blank\">佛祖让我来巡山</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/sun-10387834/p/19368685\" target=\"_blank\">https://www.cnblogs.com/sun-10387834/p/19368685</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\" data-last-update-days=\"0\" data-date-updated=\"2025-12-22 10:50\">2025-12-22 10:49</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sun-10387834\">佛祖让我来巡山</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19368685);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19368685', targetLink: 'https://www.cnblogs.com/sun-10387834/p/19368685', title: 'Spring+MyBatis环境下SqlSession管理机制详解' })\">举报</a>\n</div>","guid":{"value":"3a6b72f3f2f1b42c3e1b17c4426205cb"}},{"title":"Lit 架构解析：从 Web Components 到 lit-html 的底层原理","link":"https://www.cnblogs.com/zxlh1529/p/19370741","description":"<h1 class=\"postTitle\">\n                <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zxlh1529/p/19370741\" title=\"发布于 2025-12-22 10:32\">\n    <span role=\"heading\" aria-level=\"2\">Lit 架构解析：从 Web Components 到 lit-html 的底层原理</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\n<p>Lit（原名 lit-element + lit-html）并不是一个“对标 React/Vue 的框架”，而是一套<strong>围绕 Web Components 的最小化渲染与响应式方案</strong>。</p>\n<p>它的设计目标非常明确：</p>\n<blockquote>\n<p><strong>用最少的运行时代码，解决组件化与高性能 DOM 更新问题</strong></p>\n</blockquote>\n<p>本文将从架构层面，逐步拆解：</p>\n<ul>\n<li>Lit 在整个前端生态中的位置</li>\n<li>Lit 的核心组成</li>\n<li>lit-html 的模板与更新机制</li>\n<li>Lit 与 React / Vue 的根本差异</li>\n</ul>\n<hr>\n<h2 id=\"一lit-在前端架构中的定位\">一、Lit 在前端架构中的定位</h2>\n<h3 id=\"11-lit-解决的不是应用而是组件\">1.1 Lit 解决的不是“应用”，而是“组件”</h3>\n<p>对比常见框架的定位：</p>\n<table>\n<thead>\n<tr>\n<th>技术</th>\n<th>核心目标</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>React / Vue</td>\n<td>构建完整应用</td>\n</tr>\n<tr>\n<td>Lit</td>\n<td>构建标准 Web Components</td>\n</tr>\n<tr>\n<td>Web Components</td>\n<td>浏览器原生组件模型</td>\n</tr>\n</tbody>\n</table>\n<p>Lit 的核心思想是：</p>\n<blockquote>\n<p><strong>不发明组件标准，只补齐 Web Components 的开发体验</strong></p>\n</blockquote>\n<hr>\n<h3 id=\"12-lit-架构全景\">1.2 Lit 架构全景</h3>\n<pre><code class=\"language-text\">浏览器原生能力\n├── Custom Elements\n├── Shadow DOM\n├── HTML Template\n│\nLit 提供\n├── lit-html（渲染引擎）\n├── 响应式系统\n├── 生命周期封装\n└── DX 改进（装饰器、模板语法）\n</code></pre>\n<blockquote>\n<p><strong>Lit = Web Components + lit-html + 响应式封装</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"二lit-的整体架构拆解\">二、Lit 的整体架构拆解</h2>\n<h3 id=\"21-核心模块组成\">2.1 核心模块组成</h3>\n<p>现代 Lit（v3+）主要由三部分构成：</p>\n<pre><code class=\"language-text\">lit\n├── ReactiveElement（响应式基础类）\n├── LitElement（组件基类）\n└── lit-html（模板 &amp; 渲染引擎）\n</code></pre>\n<p>它们的职责非常清晰：</p>\n<table>\n<thead>\n<tr>\n<th>模块</th>\n<th>职责</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ReactiveElement</td>\n<td>响应式属性、更新调度</td>\n</tr>\n<tr>\n<td>LitElement</td>\n<td>生命周期 + render 桥接</td>\n</tr>\n<tr>\n<td>lit-html</td>\n<td>高性能 DOM 渲染</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"22-继承关系\">2.2 继承关系</h3>\n<pre><code class=\"language-ts\">HTMLElement\n  └── ReactiveElement\n        └── LitElement\n              └── YourComponent\n</code></pre>\n<p>Lit <strong>没有虚拟 DOM 层</strong>，这是理解其底层原理的关键。</p>\n<hr>\n<h2 id=\"三web-components-是-lit-的根基\">三、Web Components 是 Lit 的根基</h2>\n<h3 id=\"31-custom-elements\">3.1 Custom Elements</h3>\n<pre><code class=\"language-ts\">customElements.define('my-element', MyElement)\n</code></pre>\n<ul>\n<li>浏览器原生注册</li>\n<li>生命周期标准化</li>\n<li>不依赖任何框架</li>\n</ul>\n<hr>\n<h3 id=\"32-shadow-dom\">3.2 Shadow DOM</h3>\n<pre><code class=\"language-ts\">this.attachShadow({ mode: 'open' })\n</code></pre>\n<ul>\n<li>样式隔离</li>\n<li>DOM 隔离</li>\n<li>原生封装能力</li>\n</ul>\n<hr>\n<h3 id=\"33-html-template\">3.3 HTML Template</h3>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;p&gt;Hello&lt;/p&gt;\n&lt;/template&gt;\n</code></pre>\n<ul>\n<li>惰性解析</li>\n<li>可复用</li>\n<li>浏览器级优化</li>\n</ul>\n<p>Lit <strong>大量依赖 <code>&lt;template&gt;</code> 的原生特性</strong>。</p>\n<hr>\n<h2 id=\"四lit-html-的核心思想\">四、lit-html 的核心思想</h2>\n<h3 id=\"41-lit-html-是什么\">4.1 lit-html 是什么</h3>\n<p>lit-html 是 Lit 的<strong>渲染引擎</strong>，核心目标只有一个：</p>\n<blockquote>\n<p><strong>在不使用 Virtual DOM 的情况下，做到最小粒度 DOM 更新</strong></p>\n</blockquote>\n<hr>\n<h3 id=\"42-模板是静态的数据是动态的\">4.2 模板是“静态的”，数据是“动态的”</h3>\n<pre><code class=\"language-ts\">html`&lt;p&gt;Hello ${name}&lt;/p&gt;`\n</code></pre>\n<p>模板会被拆分为：</p>\n<pre><code class=\"language-text\">静态字符串数组 + 动态表达式数组\n</code></pre>\n<p>类似于：</p>\n<pre><code class=\"language-ts\">[\n  \"&lt;p&gt;Hello \",\n  \"&lt;/p&gt;\"\n]\n</code></pre>\n<hr>\n<h3 id=\"43-templateresult-结构\">4.3 TemplateResult 结构</h3>\n<pre><code class=\"language-ts\">{\n  strings: TemplateStringsArray,\n  values: any[]\n}\n</code></pre>\n<blockquote>\n<p><strong>模板结构在第一次渲染时就固定下来</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"五lit-html-的底层渲染流程importance\">五、lit-html 的底层渲染流程（Importance）</h2>\n<h3 id=\"51-首次渲染流程\">5.1 首次渲染流程</h3>\n<pre><code class=\"language-text\">1. 解析模板字符串\n2. 生成 &lt;template&gt; DOM\n3. 标记动态插槽（Part）\n4. clone template.content\n5. 插入真实 DOM\n</code></pre>\n<p>动态插槽被称为 <strong>Part</strong>。</p>\n<hr>\n<h3 id=\"52-part更新单元\">5.2 Part（更新单元）</h3>\n<p>Lit 将 DOM 中“可能变化的位置”抽象成 Part：</p>\n<table>\n<thead>\n<tr>\n<th>Part 类型</th>\n<th>对应位置</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ChildPart</td>\n<td>文本节点 / 子节点</td>\n</tr>\n<tr>\n<td>AttributePart</td>\n<td>普通属性</td>\n</tr>\n<tr>\n<td>PropertyPart</td>\n<td>DOM 属性</td>\n</tr>\n<tr>\n<td>BooleanAttributePart</td>\n<td>布尔属性</td>\n</tr>\n<tr>\n<td>EventPart</td>\n<td>事件</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"53-更新阶段没有-diff\">5.3 更新阶段（没有 Diff）</h3>\n<pre><code class=\"language-text\">状态变化\n  ↓\n重新执行 render()\n  ↓\n生成新的 values\n  ↓\n逐个 Part 对比并更新\n</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li>不比较 DOM 树</li>\n<li>只更新“表达式对应的节点”</li>\n</ul>\n<hr>\n<h3 id=\"54-为什么比-virtual-dom-快\">5.4 为什么比 Virtual DOM 快</h3>\n<p>React/Vue：</p>\n<pre><code class=\"language-text\">state → vdom → diff → patch\n</code></pre>\n<p>lit-html：</p>\n<pre><code class=\"language-text\">state → values → Part.update()\n</code></pre>\n<blockquote>\n<p><strong>Lit 的更新路径更短，内存占用更小</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"六lit-的响应式系统原理\">六、Lit 的响应式系统原理</h2>\n<h3 id=\"61-reactiveelement-的核心机制\">6.1 ReactiveElement 的核心机制</h3>\n<pre><code class=\"language-ts\">@property({ type: String })\nname = 'lit'\n</code></pre>\n<p>底层原理：</p>\n<ol>\n<li>将属性转为 getter/setter</li>\n<li>setter 触发 <code>requestUpdate</code></li>\n<li>更新被批量调度（microtask）</li>\n<li>调用 <code>update()</code> → <code>render()</code></li>\n</ol>\n<hr>\n<h3 id=\"62-更新是异步批量的\">6.2 更新是异步批量的</h3>\n<pre><code class=\"language-text\">多次 set\n  ↓\n一次 render\n</code></pre>\n<p>类似 Vue 的 nextTick，但实现更轻量。</p>\n<hr>\n<h2 id=\"七lit-的生命周期设计\">七、Lit 的生命周期设计</h2>\n<pre><code class=\"language-ts\">connectedCallback()\ndisconnectedCallback()\nshouldUpdate()\nwillUpdate()\nupdate()\nupdated()\n</code></pre>\n<p>特点：</p>\n<ul>\n<li>与 Custom Elements 生命周期对齐</li>\n<li>不引入额外概念</li>\n<li>更贴近浏览器模型</li>\n</ul>\n<hr>\n<h2 id=\"八lit-与-react--vue-的根本差异\">八、Lit 与 React / Vue 的根本差异</h2>\n<h3 id=\"81-架构层面对比\">8.1 架构层面对比</h3>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>Lit</th>\n<th>React</th>\n<th>Vue</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>核心模型</td>\n<td>Web Components</td>\n<td>VDOM</td>\n<td>VDOM + 响应式</td>\n</tr>\n<tr>\n<td>DOM 更新</td>\n<td>定点更新</td>\n<td>Diff</td>\n<td>Diff</td>\n</tr>\n<tr>\n<td>样式隔离</td>\n<td>Shadow DOM</td>\n<td>CSS-in-JS</td>\n<td>Scoped CSS</td>\n</tr>\n<tr>\n<td>运行时</td>\n<td>极小</td>\n<td>较大</td>\n<td>中等</td>\n</tr>\n<tr>\n<td>框架侵入</td>\n<td>极低</td>\n<td>高</td>\n<td>中</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"82-lit-的优势场景\">8.2 Lit 的优势场景</h3>\n<ul>\n<li>组件库（跨框架）</li>\n<li>微前端</li>\n<li>Design System</li>\n<li>嵌入第三方系统</li>\n<li>对 bundle size 极敏感场景</li>\n</ul>\n<hr>\n<h3 id=\"83-lit-的局限\">8.3 Lit 的局限</h3>\n<ul>\n<li>不适合复杂应用状态管理</li>\n<li>社区生态不如 React/Vue</li>\n<li>对 Web Components 理解有门槛</li>\n</ul>\n<hr>\n<h2 id=\"九一个关键结论\">九、一个关键结论</h2>\n<blockquote>\n<p><strong>Lit 并不是“下一代前端框架”</strong><br>\n<strong>而是“更接近浏览器的组件开发方式”</strong></p>\n</blockquote>\n<p>它选择相信浏览器，而不是包揽一切。</p>\n<hr>\n<h2 id=\"十总结\">十、总结</h2>\n<ul>\n<li>Lit 的架构极度克制</li>\n<li>lit-html 是一个“模板驱动的定点更新引擎”</li>\n<li>没有 Virtual DOM 是它最重要的设计选择</li>\n<li>Web Components 是它真正的护城河</li>\n</ul>\n<p>如果你需要构建：</p>\n<ul>\n<li><strong>长期维护的组件库</strong></li>\n<li><strong>跨技术栈 UI 组件</strong></li>\n<li><strong>低运行时成本的前端模块</strong></li>\n</ul>\n<p><a href=\"https://github.com/lit/lit\" target=\"_blank\" rel=\"noopener nofollow\">Lit</a> 是一个非常值得深入理解的方案。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\" data-last-update-days=\"0.03263888888888889\" data-date-updated=\"2025-12-22 11:19\">2025-12-22 10:32</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zxlh1529\">幼儿园技术家</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19370741);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19370741', targetLink: 'https://www.cnblogs.com/zxlh1529/p/19370741', title: 'Lit 架构解析：从 Web Components 到 lit-html 的底层原理' })\">举报</a>\n</div>","guid":{"value":"9b4d5fcca0fec481cf41ce9809b58233"}},{"title":"Minio开始收费了？别慌，这5种免费的分布式文件系统更香！","link":"https://www.cnblogs.com/12lisu/p/19380992","description":"<h1 class=\"postTitle\">\n                <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/12lisu/p/19380992\" title=\"发布于 2025-12-22 10:11\">\n    <span role=\"heading\" aria-level=\"2\">Minio开始收费了？别慌，这5种免费的分布式文件系统更香！</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\n<h2 id=\"前言\">前言</h2>\n<p>最近，不少技术圈的朋友都在讨论一个话题：<strong>Minio是不是开始收费了？</strong></p>\n<p>这背后其实涉及到一个更深刻的问题——开源许可证的商业化边界。</p>\n<p>有些小伙伴在工作中可能已经遇到了这样的困惑：公司法务审查后，认为Minio的AGPLv3许可证在商业产品中使用存在风险，要求寻找替代方案。</p>\n<p>今天就给大家推荐5种其他开源的分布式文件系统替代方案。</p>\n<h2 id=\"01-minio许可证的罗生门\">01 Minio许可证的“罗生门”</h2>\n<p>MinIO自2025年10月起实施以下关键变化：</p>\n<ul>\n<li>停止免费Docker镜像分发‌：社区版不再提供预构建的Docker镜像，用户需从源码自行编译构建。‌</li>\n<li>功能限制与移除‌：控制台管理功能被删除，仅保留基础存储能力。‌</li>\n<li>社区版文档从官网移除，且不再接受新功能请求。‌‌</li>\n</ul>\n<p>‌许可证策略收紧‌：从Apache 2.0协议转向AGPLv3许可证，强化对衍生作品的约束，若违反需购买商业授权。‌</p>\n<p>首先，让我们明确一点：<strong>Minio的核心产品仍然是开源的，使用AGPLv3许可证</strong>。</p>\n<p>但是，这里有几个关键细节需要理解：</p>\n<h3 id=\"agplv3许可证的传染性\">AGPLv3许可证的“传染性”</h3>\n<p>AGPLv3（GNU Affero通用公共许可证第3版）有一个著名特性：<strong>“网络服务即分发”</strong>。</p>\n<p>简单来说，如果你的服务通过网络提供基于AGPLv3代码的功能，那么你必须开源整个服务的源代码。</p>\n<pre><code class=\"language-java\">// 假设你基于Minio开发了一个文件管理服务\npublic class FileManagementService {\n    // 这段代码本身可能没问题...\n    private MinioClient minioClient;\n    \n    public void processUserFile(UserFile file) {\n        // 但是，如果你的整个服务基于AGPLv3代码\n        // 根据严格解释，你可能需要开源整个项目\n        minioClient.putObject(...);\n        // 更多业务逻辑...\n    }\n}\n</code></pre>\n<h3 id=\"minio的商业化策略\">Minio的商业化策略</h3>\n<p>Minio公司确实提供了：</p>\n<ol>\n<li><strong>企业版</strong>：包含更多企业功能（如多站点复制、监控等）</li>\n<li><strong>商业许可证</strong>：允许在不开放源代码的情况下使用Minio</li>\n</ol>\n<p>这使得很多公司面临选择：<strong>是接受AGPLv3的开源要求，还是购买商业许可证？</strong></p>\n<h3 id=\"为什么这很重要\">为什么这很重要？</h3>\n<p>如果你的公司属于以下情况之一，可能需要重新考虑Minio的使用：</p>\n<ul>\n<li><strong>SaaS提供商</strong>：通过网络提供服务</li>\n<li><strong>专有软件开发商</strong>：不希望开源核心代码</li>\n<li><strong>对许可证合规性严格的企业</strong>：有专门的法务审查</li>\n</ul>\n<p>下面的决策流程图清晰地展示了这一困境：</p>\n<p><img alt=\"image\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/2238006/202512/2238006-20251222100953131-1545189214.png\" class=\"lazyload\"></p>\n<p><strong>接下来介绍的5个免费替代方案，可能会适合你。</strong></p>\n<h2 id=\"02-seaweedfs极致简单的海量小文件专家\">02 SeaweedFS：极致简单的海量小文件专家</h2>\n<p>首先介绍的是我个人非常喜欢的<strong>SeaweedFS</strong>。</p>\n<p>它最初是为小文件存储优化的，但现在已经成为功能全面的分布式文件系统。</p>\n<h3 id=\"核心优势\">核心优势</h3>\n<ul>\n<li><strong>完全开源</strong>：Apache License 2.0（商业友好）</li>\n<li><strong>架构简单</strong>：学习曲线平缓</li>\n<li><strong>性能卓越</strong>：特别适合海量小文件场景</li>\n<li><strong>S3兼容</strong>：提供完整的S3 API支持</li>\n</ul>\n<h3 id=\"部署示例5分钟快速搭建\">部署示例：5分钟快速搭建</h3>\n<pre><code class=\"language-bash\"># SeaweedFS的部署简单到令人惊讶\n# 1. 下载（只有一个二进制文件！）\nwget https://github.com/seaweedfs/seaweedfs/releases/download/3.55/linux_amd64.tar.gz\ntar -xzf linux_amd64.tar.gz\n\n# 2. 启动主服务器（管理元数据）\n./weed master -ip=localhost -port=9333\n\n# 3. 启动存储节点\n./weed volume -dir=\"./data\" -max=100 -mserver=\"localhost:9333\" -port=8080\n\n# 就是这么简单！现在你已经有了一个分布式文件系统\n</code></pre>\n<h3 id=\"java客户端集成示例\">Java客户端集成示例</h3>\n<pre><code class=\"language-java\">// SeaweedFS的Java客户端使用示例\npublic class SeaweedFSExample {\n    // SeaweedFS提供S3兼容接口，可以使用标准的AWS SDK\n    private AmazonS3 s3Client;\n    \n    public void init() {\n        // 配置连接到SeaweedFS的Filer组件（提供S3接口）\n        AWSCredentials credentials = new BasicAWSCredentials(\n            \"your-access-key\",  // SeaweedFS默认无需认证，但可以配置\n            \"your-secret-key\"\n        );\n        \n        s3Client = AmazonS3ClientBuilder.standard()\n            .withEndpointConfiguration(\n                new AwsClientBuilder.EndpointConfiguration(\n                    \"http://localhost:8333\",  // Filer默认端口\n                    \"us-east-1\"\n                )\n            )\n            .withCredentials(new AWSStaticCredentialsProvider(credentials))\n            .withPathStyleAccessEnabled(true)  // SeaweedFS需要此设置\n            .build();\n    }\n    \n    // 上传文件到SeaweedFS\n    public void uploadFile(String bucketName, String objectKey, File file) {\n        // 创建存储桶（如果需要）\n        if (!s3Client.doesBucketExistV2(bucketName)) {\n            s3Client.createBucket(bucketName);\n        }\n        \n        // 上传文件\n        s3Client.putObject(bucketName, objectKey, file);\n        \n        System.out.println(\"文件已上传至SeaweedFS\");\n        System.out.println(\"下载URL: http://localhost:8333/\" + bucketName + \"/\" + objectKey);\n    }\n    \n    // SeaweedFS特色功能：小文件合并存储\n    public void uploadSmallFiles(List&lt;File&gt; smallFiles, String bucketName) {\n        // SeaweedFS内部会自动将小文件合并存储\n        // 这大大提高了海量小文件的存储效率\n        \n        for (int i = 0; i &lt; smallFiles.size(); i++) {\n            File file = smallFiles.get(i);\n            String objectKey = \"small-file-\" + i + \"-\" + file.getName();\n            s3Client.putObject(bucketName, objectKey, file);\n        }\n        \n        System.out.println(\"已上传 \" + smallFiles.size() + \" 个小文件\");\n        System.out.println(\"SeaweedFS会自动优化这些文件的存储\");\n    }\n}\n</code></pre>\n<h3 id=\"适用场景\">适用场景</h3>\n<ul>\n<li>图片、文档等小文件存储服务</li>\n<li>需要快速部署和验证的场景</li>\n<li>对S3兼容性有要求的迁移项目</li>\n<li>资源有限的团队或环境</li>\n</ul>\n<p><strong>为什么选择SeaweedFS替代Minio？</strong></p>\n<ol>\n<li><strong>许可证更友好</strong>：Apache 2.0 vs AGPLv3</li>\n<li><strong>部署更简单</strong>：单二进制文件 vs 需要Docker或复杂配置</li>\n<li><strong>小文件性能更好</strong>：专门为小文件优化</li>\n<li><strong>社区活跃</strong>：持续更新和维护</li>\n</ol>\n<h2 id=\"03-garage专注于去中心化的新选择\">03 Garage：专注于去中心化的新选择</h2>\n<p><strong>Garage</strong>是一个相对较新但非常有潜力的分布式对象存储系统，源自法国国立计算机与自动化研究所（INRIA）。</p>\n<h3 id=\"核心特色\">核心特色</h3>\n<ul>\n<li><strong>完全开源</strong>：Apache License 2.0</li>\n<li><strong>去中心化设计</strong>：无单点故障</li>\n<li><strong>轻量级</strong>：资源消耗少</li>\n<li><strong>兼容S3 API</strong>：完美替代Minio</li>\n</ul>\n<h3 id=\"集群部署示例\">集群部署示例</h3>\n<pre><code class=\"language-yaml\"># docker-compose.yml - 3节点Garage集群\nversion: '3.8'\nservices:\n  garage1:\n    image: dxflrs/garage:v0.9.0\n    command: \"garage server\"\n    environment:\n      - GARAGE_NODE_NAME=node1\n      - GARAGE_RPC_SECRET=my-secret-key\n      - GARAGE_BIND_ADDR=0.0.0.0:3901\n      - GARAGE_RPC_BIND_ADDR=0.0.0.0:3902\n      - GARAGE_REPLICATION_MODE=3\n    volumes:\n      - ./data/garage1:/var/lib/garage\n    ports:\n      - \"3901:3901\"\n      - \"3902:3902\"\n      \n  garage2:\n    image: dxflrs/garage:v0.9.0\n    command: \"garage server\"\n    environment:\n      - GARAGE_NODE_NAME=node2\n      - GARAGE_RPC_SECRET=my-secret-key\n      - GARAGE_BIND_ADDR=0.0.0.0:3901\n      - GARAGE_RPC_BIND_ADDR=0.0.0.0:3902\n      - GARAGE_SEED=garage1:3902\n    volumes:\n      - ./data/garage2:/var/lib/garage\n      \n  garage3:\n    image: dxflrs/garage:v0.9.0\n    command: \"garage server\"\n    environment:\n      - GARAGE_NODE_NAME=node3\n      - GARAGE_RPC_SECRET=my-secret-key\n      - GARAGE_BIND_ADDR=0.0.0.0:3901\n      - GARAGE_RPC_BIND_ADDR=0.0.0.0:3902\n      - GARAGE_SEED=garage1:3902\n    volumes:\n      - ./data/garage3:/var/lib/garage\n</code></pre>\n<h3 id=\"java集成代码\">Java集成代码</h3>\n<pre><code>// Garage的Java客户端示例\npublic class GarageExample {\n    // Garage完全兼容S3 API，可以直接使用AWS SDK\n    private AmazonS3 garageClient;\n    \n    public void initGarageConnection() {\n        // Garage的配置与Minio非常相似\n        AWSCredentials credentials = new BasicAWSCredentials(\n            \"GK...\",  // Garage生成的访问密钥\n            \"...\"     // 对应的秘密密钥\n        );\n        \n        garageClient = AmazonS3ClientBuilder.standard()\n            .withEndpointConfiguration(\n                new AwsClientBuilder.EndpointConfiguration(\n                    \"http://localhost:3900\",  // Garage的S3 API端口\n                    \"garage\"  // 区域名称可自定义\n                )\n            )\n            .withCredentials(new AWSStaticCredentialsProvider(credentials))\n            .withPathStyleAccessEnabled(true)\n            .build();\n    }\n    \n    // 创建存储桶并设置策略\n    public void createBucketWithPolicy(String bucketName) {\n        // 创建存储桶\n        garageClient.createBucket(bucketName);\n        \n        // Garage支持灵活的存储策略配置\n        String bucketPolicy = \"\"\"\n        {\n            \"version\": \"2012-10-17\",\n            \"statement\": [\n                {\n                    \"effect\": \"Allow\",\n                    \"principal\": \"*\",\n                    \"action\": \"s3:GetObject\",\n                    \"resource\": \"arn:aws:s3:::%s/*\"\n                }\n            ]\n        }\n        \"\"\".formatted(bucketName);\n        \n        garageClient.setBucketPolicy(bucketName, bucketPolicy);\n        \n        System.out.println(\"存储桶创建完成，已设置公开读取策略\");\n    }\n    \n    // 上传文件并生成访问URL\n    public String uploadAndGenerateUrl(String bucketName, \n                                       String objectKey, \n                                       InputStream inputStream) {\n        ObjectMetadata metadata = new ObjectMetadata();\n        // 可以在这里设置内容类型等元数据\n        metadata.setContentType(\"application/octet-stream\");\n        \n        PutObjectRequest request = new PutObjectRequest(\n            bucketName, objectKey, inputStream, metadata\n        );\n        \n        garageClient.putObject(request);\n        \n        // 生成预签名URL（Garage支持此功能）\n        java.util.Date expiration = new java.util.Date();\n        long expTimeMillis = expiration.getTime();\n        expTimeMillis += 1000 * 60 * 60; // 1小时有效期\n        expiration.setTime(expTimeMillis);\n        \n        GeneratePresignedUrlRequest generatePresignedUrlRequest = \n            new GeneratePresignedUrlRequest(bucketName, objectKey)\n                .withMethod(HttpMethod.GET)\n                .withExpiration(expiration);\n        \n        return garageClient.generatePresignedUrl(\n            generatePresignedUrlRequest).toString();\n    }\n}\n</code></pre>\n<h3 id=\"适用场景-1\">适用场景</h3>\n<ul>\n<li>去中心化应用或区块链项目</li>\n<li>需要轻量级对象存储的场景</li>\n<li>研究或教育项目</li>\n<li>对新兴技术有兴趣的团队</li>\n</ul>\n<h2 id=\"04-ceph企业级的全能开源方案\">04 Ceph：企业级的全能开源方案</h2>\n<p><strong>Ceph</strong>是最知名、功能最全面的开源分布式存储系统之一。</p>\n<p>虽然它比Minio复杂得多，但也强大得多。</p>\n<h3 id=\"为什么ceph是真正的免费\">为什么Ceph是真正的免费？</h3>\n<ul>\n<li><strong>开源许可证</strong>：LGPL（较GPL更宽松）</li>\n<li><strong>社区驱动</strong>：由Red Hat支持但社区主导</li>\n<li><strong>无商业限制</strong>：可以自由用于商业产品</li>\n</ul>\n<h3 id=\"部署架构\">部署架构</h3>\n<p><img alt=\"image\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/2238006/202512/2238006-20251222101020635-2090096718.png\" class=\"lazyload\"></p>\n<h3 id=\"java客户端操作ceph\">Java客户端操作Ceph</h3>\n<pre><code class=\"language-java\">// 使用Ceph的S3兼容接口（RADOSGW）\npublic class CephExample {\n    private AmazonS3 cephClient;\n    \n    public void initCephConnection() {\n        // Ceph通过RADOSGW提供S3兼容接口\n        // 配置方式与AWS S3几乎完全相同\n        AWSCredentials credentials = new BasicAWSCredentials(\n            System.getenv(\"CEPH_ACCESS_KEY\"),\n            System.getenv(\"CEPH_SECRET_KEY\")\n        );\n        \n        cephClient = AmazonS3ClientBuilder.standard()\n            .withCredentials(new AWSStaticCredentialsProvider(credentials))\n            .withEndpointConfiguration(\n                new AwsClientBuilder.EndpointConfiguration(\n                    \"http://ceph-gateway.example.com:7480\",\n                    \"\"  // Ceph可以不指定区域\n                )\n            )\n            .withPathStyleAccessEnabled(true)\n            .build();\n    }\n    \n    // Ceph的高级特性：多部分上传\n    public void uploadLargeFileToCeph(String bucketName, \n                                      String objectKey, \n                                      File largeFile) \n                                      throws Exception {\n        \n        // 初始化多部分上传\n        InitiateMultipartUploadRequest initRequest = \n            new InitiateMultipartUploadRequest(bucketName, objectKey);\n        InitiateMultipartUploadResult initResponse = \n            cephClient.initiateMultipartUpload(initRequest);\n        String uploadId = initResponse.getUploadId();\n        \n        // 分片上传（Ceph可以处理非常大的文件）\n        long fileSize = largeFile.length();\n        long partSize = 100 * 1024 * 1024; // 100MB分片\n        long bytePosition = 0;\n        List&lt;PartETag&gt; partETags = new ArrayList&lt;&gt;();\n        int partNumber = 1;\n        \n        try (FileInputStream fis = new FileInputStream(largeFile)) {\n            while (bytePosition &lt; fileSize) {\n                long currentPartSize = Math.min(partSize, fileSize - bytePosition);\n                \n                UploadPartRequest uploadRequest = new UploadPartRequest()\n                    .withBucketName(bucketName)\n                    .withKey(objectKey)\n                    .withUploadId(uploadId)\n                    .withPartNumber(partNumber)\n                    .withInputStream(fis)\n                    .withPartSize(currentPartSize);\n                \n                UploadPartResult uploadResult = cephClient.uploadPart(uploadRequest);\n                partETags.add(uploadResult.getPartETag());\n                \n                bytePosition += currentPartSize;\n                partNumber++;\n            }\n            \n            // 完成上传\n            CompleteMultipartUploadRequest compRequest = \n                new CompleteMultipartUploadRequest(\n                    bucketName, objectKey, uploadId, partETags);\n            cephClient.completeMultipartUpload(compRequest);\n            \n        } catch (Exception e) {\n            // 发生错误时中止上传\n            cephClient.abortMultipartUpload(\n                new AbortMultipartUploadRequest(bucketName, objectKey, uploadId));\n            throw e;\n        }\n    }\n    \n    // Ceph特有的功能：获取存储使用情况\n    public void checkCephUsage() {\n        // 注意：Ceph不通过S3 API提供使用统计\n        // 需要通过管理API或命令行获取\n        System.out.println(\"Ceph使用统计需通过以下方式获取：\");\n        System.out.println(\"1. 命令行: ceph df\");\n        System.out.println(\"2. 管理API: /api/auth\");\n        System.out.println(\"3. Dashboard: 内置Web界面\");\n    }\n}\n</code></pre>\n<h3 id=\"适用场景-2\">适用场景</h3>\n<ul>\n<li>大型企业存储需求</li>\n<li>需要同时支持对象、块和文件存储</li>\n<li>已经有一定运维能力的团队</li>\n<li>对可靠性和扩展性要求极高的场景</li>\n</ul>\n<h2 id=\"05-glusterfs简单可靠的横向扩展文件系统\">05 GlusterFS：简单可靠的横向扩展文件系统</h2>\n<p><strong>GlusterFS</strong>是一个开源的分布式横向扩展文件系统，特别适合需要POSIX文件系统语义的场景。</p>\n<h3 id=\"核心优势-1\">核心优势</h3>\n<ul>\n<li><strong>开源许可证</strong>：GPLv3（但无AGPL的网络服务条款）</li>\n<li><strong>无元数据服务器</strong>：独特的无中心架构</li>\n<li><strong>部署简单</strong>：易于理解和维护</li>\n<li><strong>成熟稳定</strong>：经过多年生产验证</li>\n</ul>\n<h3 id=\"快速部署脚本\">快速部署脚本</h3>\n<pre><code class=\"language-bash\">#!/bin/bash\n# GlusterFS 3节点集群快速部署脚本\n\n# 在三个节点上执行类似命令\n# 节点1:\ngluster peer probe node2\ngluster peer probe node3\n\n# 创建分布式卷（数据分散在所有节点）\ngluster volume create gv0 disperse 3 node1:/data/brick1 node2:/data/brick1 node3:/data/brick1\n\n# 或创建复制卷（数据在所有节点复制）\ngluster volume create gv1 replica 3 node1:/data/brick2 node2:/data/brick2 node3:/data/brick2\n\n# 启动卷\ngluster volume start gv0\ngluster volume start gv1\n\n# 在客户端挂载\nmount -t glusterfs node1:/gv0 /mnt/glusterfs\n</code></pre>\n<h3 id=\"java中使用glusterfs\">Java中使用GlusterFS</h3>\n<pre><code class=\"language-java\">// 通过标准的Java文件API访问GlusterFS\npublic class GlusterFSExample {\n    private Path glusterMountPoint;\n    \n    public GlusterFSExample(String mountPath) {\n        this.glusterMountPoint = Paths.get(mountPath);\n        \n        // 验证挂载点\n        if (!Files.exists(glusterMountPoint)) {\n            throw new IllegalArgumentException(\"GlusterFS挂载点不存在: \" + mountPath);\n        }\n        \n        System.out.println(\"GlusterFS挂载点: \" + mountPoint.toAbsolutePath());\n    }\n    \n    // 写入文件 - GlusterFS自动处理数据分布\n    public void writeFile(String filename, String content) throws IOException {\n        Path filePath = glusterMountPoint.resolve(filename);\n        \n        // 创建父目录（如果需要）\n        if (filePath.getParent() != null) {\n            Files.createDirectories(filePath.getParent());\n        }\n        \n        // 写入文件\n        Files.write(filePath, \n                   content.getBytes(StandardCharsets.UTF_8),\n                   StandardOpenOption.CREATE,\n                   StandardOpenOption.WRITE,\n                   StandardOpenOption.TRUNCATE_EXISTING);\n        \n        System.out.println(\"文件已写入GlusterFS: \" + filePath);\n    }\n    \n    // 读取文件\n    public String readFile(String filename) throws IOException {\n        Path filePath = glusterMountPoint.resolve(filename);\n        \n        if (Files.exists(filePath)) {\n            byte[] content = Files.readAllBytes(filePath);\n            return new String(content, StandardCharsets.UTF_8);\n        }\n        \n        return null;\n    }\n    \n    // 列出目录内容\n    public List&lt;String&gt; listFiles(String directory) throws IOException {\n        Path dirPath = glusterMountPoint.resolve(directory);\n        \n        if (Files.exists(dirPath) &amp;&amp; Files.isDirectory(dirPath)) {\n            try (Stream&lt;Path&gt; stream = Files.list(dirPath)) {\n                return stream\n                    .filter(Files::isRegularFile)\n                    .map(Path::getFileName)\n                    .map(Path::toString)\n                    .collect(Collectors.toList());\n            }\n        }\n        \n        return Collections.emptyList();\n    }\n    \n    // 获取文件信息\n    public void printFileInfo(String filename) throws IOException {\n        Path filePath = glusterMountPoint.resolve(filename);\n        \n        if (Files.exists(filePath)) {\n            BasicFileAttributes attrs = Files.readAttributes(\n                filePath, BasicFileAttributes.class);\n            \n            System.out.println(\"文件: \" + filename);\n            System.out.println(\"大小: \" + attrs.size() + \" 字节\");\n            System.out.println(\"创建时间: \" + attrs.creationTime());\n            System.out.println(\"修改时间: \" + attrs.lastModifiedTime());\n            System.out.println(\"访问时间: \" + attrs.lastAccessTime());\n        }\n    }\n}\n</code></pre>\n<h3 id=\"适用场景-3\">适用场景</h3>\n<ul>\n<li>需要标准文件系统接口的应用</li>\n<li>媒体处理、日志存储等场景</li>\n<li>已有大量基于文件API的遗留系统</li>\n<li>希望避免学习新API的团队</li>\n</ul>\n<h2 id=\"06-openstack-swift企业级对象存储标准\">06 OpenStack Swift：企业级对象存储标准</h2>\n<p><strong>OpenStack Swift</strong>是OpenStack生态中的对象存储组件，是一个完全开源、高度可扩展的对象存储系统。</p>\n<h3 id=\"开源承诺\">开源承诺</h3>\n<ul>\n<li><strong>完全开源</strong>：Apache License 2.0</li>\n<li><strong>社区治理</strong>：由OpenStack基金会管理</li>\n<li><strong>无商业限制</strong>：真正的自由使用</li>\n</ul>\n<h3 id=\"swift集群架构\">Swift集群架构</h3>\n<pre><code class=\"language-python\"># 简化的Swift集群配置示例\n# swift.conf - 主要配置文件\n[swift-hash]\n# 随机hash种子，集群中所有节点必须相同\nswift_hash_path_prefix = changeme\nswift_hash_path_suffix = changeme\n\n[storage-policy:0]\nname = Policy-0\ndefault = yes\n\n# ring文件 - 数据分布配置\n# 使用swift-ring-builder工具管理\n$ swift-ring-builder account.builder create 10 3 24\n$ swift-ring-builder container.builder create 10 3 24\n$ swift-ring-builder object.builder create 10 3 24\n\n# 添加存储节点\n$ swift-ring-builder object.builder add r1z1-127.0.0.1:6010/sdb1 100\n$ swift-ring-builder object.builder rebalance\n</code></pre>\n<h3 id=\"java客户端示例\">Java客户端示例</h3>\n<pre><code class=\"language-java\">// 使用jclouds库访问OpenStack Swift\npublic class SwiftExample {\n    private BlobStore blobStore;\n    \n    public void initSwiftConnection() {\n        // 配置Swift连接\n        Properties overrides = new Properties();\n        overrides.setProperty(\"jclouds.swift.auth.version\", \"3\");\n        \n        // Swift支持多种认证方式\n        SwiftApi swiftApi = ContextBuilder.newBuilder(\"openstack-swift\")\n            .endpoint(\"http://swift.example.com:5000/v3\")\n            .credentials(\"project:username\", \"password\")\n            .overrides(overrides)\n            .buildApi(SwiftApi.class);\n        \n        blobStore = swiftApi.getBlobStore(\"RegionOne\");\n    }\n    \n    // 上传对象到Swift\n    public String uploadToSwift(String containerName, \n                                String objectName, \n                                InputStream data, \n                                long size) {\n        \n        // 确保容器存在\n        if (!blobStore.containerExists(containerName)) {\n            blobStore.createContainerInLocation(null, containerName);\n        }\n        \n        // 创建Blob对象\n        Blob blob = blobStore.blobBuilder(objectName)\n            .payload(data)\n            .contentLength(size)\n            .contentType(\"application/octet-stream\")\n            .build();\n        \n        // 上传\n        String etag = blobStore.putBlob(containerName, blob);\n        \n        System.out.println(\"对象上传成功，ETag: \" + etag);\n        \n        // 生成临时URL（Swift支持此功能）\n        return generateTempUrl(containerName, objectName);\n    }\n    \n    private String generateTempUrl(String container, String object) {\n        // Swift支持通过临时URL共享对象\n        // 这里需要Swift集群配置了临时URL密钥\n        long expires = System.currentTimeMillis() / 1000 + 3600; // 1小时后过期\n        \n        // 临时URL生成逻辑（实际实现更复杂）\n        return String.format(\n            \"http://swift.example.com:8080/v1/AUTH_%s/%s/%s?temp_url_sig=xxx&amp;temp_url_expires=%d\",\n            \"account\", container, object, expires\n        );\n    }\n    \n    // 大对象分片上传（Swift称为\"静态大对象\"）\n    public void uploadLargeObject(String container, \n                                  String objectName, \n                                  List&lt;File&gt; segments) {\n        \n        // 上传所有分片\n        List&lt;String&gt; segmentPaths = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; segments.size(); i++) {\n            String segmentName = String.format(\"%s/%08d\", objectName, i);\n            try (InputStream is = new FileInputStream(segments.get(i))) {\n                uploadToSwift(container, segmentName, is, segments.get(i).length());\n                segmentPaths.add(String.format(\"/%s/%s\", container, segmentName));\n            } catch (IOException e) {\n                throw new RuntimeException(\"分片上传失败\", e);\n            }\n        }\n        \n        // 创建清单文件\n        String manifest = String.join(\"\\n\", segmentPaths);\n        try (InputStream is = new ByteArrayInputStream(manifest.getBytes())) {\n            blobStore.putBlob(container, \n                blobStore.blobBuilder(objectName)\n                    .payload(is)\n                    .contentLength(manifest.length())\n                    .contentType(\"text/plain\")\n                    .build());\n        } catch (IOException e) {\n            throw new RuntimeException(\"清单文件创建失败\", e);\n        }\n        \n        System.out.println(\"大对象上传完成，共 \" + segments.size() + \" 个分片\");\n    }\n}\n</code></pre>\n<h3 id=\"适用场景-4\">适用场景</h3>\n<ul>\n<li>OpenStack云环境</li>\n<li>需要高持久性保证的企业应用</li>\n<li>多地域复制需求</li>\n<li>已有OpenStack基础设施的团队</li>\n</ul>\n<h2 id=\"07-综合对比与选型指南\">07 综合对比与选型指南</h2>\n<p>现在我们已经了解了5个Minio的免费替代方案。</p>\n<p>如何选择最适合你的那个？</p>\n<p>下面的对比表格和决策指南可以帮助你：</p>\n<p><img alt=\"image\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/2238006/202512/2238006-20251222101045370-1386142031.png\" class=\"lazyload\"></p>\n<h3 id=\"详细对比表\">详细对比表</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>SeaweedFS</th>\n<th>Garage</th>\n<th>Ceph</th>\n<th>GlusterFS</th>\n<th>OpenStack Swift</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>许可证</strong></td>\n<td>Apache 2.0</td>\n<td>Apache 2.0</td>\n<td>LGPL</td>\n<td>GPLv3</td>\n<td>Apache 2.0</td>\n</tr>\n<tr>\n<td><strong>部署复杂度</strong></td>\n<td>⭐☆☆☆☆ (极简)</td>\n<td>⭐⭐☆☆☆ (简单)</td>\n<td>⭐⭐⭐⭐⭐ (复杂)</td>\n<td>⭐⭐⭐☆☆ (中等)</td>\n<td>⭐⭐⭐⭐☆ (较复杂)</td>\n</tr>\n<tr>\n<td><strong>S3兼容性</strong></td>\n<td>完全兼容</td>\n<td>完全兼容</td>\n<td>通过RADOSGW</td>\n<td>通过第三方</td>\n<td>原生支持</td>\n</tr>\n<tr>\n<td><strong>文件系统支持</strong></td>\n<td>有限</td>\n<td>无</td>\n<td>CephFS</td>\n<td>原生POSIX</td>\n<td>无</td>\n</tr>\n<tr>\n<td><strong>适用规模</strong></td>\n<td>中小规模</td>\n<td>中小规模</td>\n<td>超大规模</td>\n<td>中大规模</td>\n<td>大规模</td>\n</tr>\n<tr>\n<td><strong>小文件性能</strong></td>\n<td>⭐⭐⭐⭐⭐</td>\n<td>⭐⭐⭐☆☆</td>\n<td>⭐⭐⭐☆☆</td>\n<td>⭐⭐☆☆☆</td>\n<td>⭐⭐⭐⭐☆</td>\n</tr>\n<tr>\n<td><strong>大文件性能</strong></td>\n<td>⭐⭐⭐☆☆</td>\n<td>⭐⭐⭐⭐☆</td>\n<td>⭐⭐⭐⭐⭐</td>\n<td>⭐⭐⭐⭐☆</td>\n<td>⭐⭐⭐⭐⭐</td>\n</tr>\n<tr>\n<td><strong>运维要求</strong></td>\n<td>低</td>\n<td>低</td>\n<td>高</td>\n<td>中</td>\n<td>中高</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"总结\">总结</h2>\n<p>有些小伙伴在工作中可能会因为Minio的许可证变化而感到焦虑，但实际上，开源世界给了我们丰富的选择。</p>\n<p>关键是要根据你的具体需求做出明智的决策：</p>\n<ol>\n<li>\n<p><strong>如果你是小型团队或创业公司</strong>，需要快速部署且主要处理小文件，<strong>SeaweedFS</strong>是最佳选择。</p>\n</li>\n<li>\n<p><strong>如果你在构建去中心化应用</strong>或需要极简架构，<strong>Garage</strong>值得考虑。</p>\n</li>\n<li>\n<p><strong>如果你有企业级需求</strong>，需要同时支持对象、块和文件存储，<strong>Ceph</strong>是行业标准。</p>\n</li>\n<li>\n<p><strong>如果你需要标准的文件系统接口</strong>，并且希望迁移简单，<strong>GlusterFS</strong>非常合适。</p>\n</li>\n<li>\n<p><strong>如果你已经在OpenStack环境中</strong>或需要企业级对象存储，<strong>OpenStack Swift</strong>是最佳选择。</p>\n</li>\n</ol>\n<p><strong>记住，技术选型的核心原则是：没有最好的系统，只有最适合的系统</strong>。</p>\n<p>许可证只是考量的一个方面，你还需要考虑性能需求、团队技能、运维成本等多个因素。</p>\n<h2 id=\"最后说一句求关注别白嫖我\">最后说一句(求关注，别白嫖我)</h2>\n<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>\n<p>求一键三连：点赞、转发、在看。</p>\n<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>\n<p>更多项目实战在我的技术网站：<a href=\"http://www.susan.net.cn/project\" target=\"_blank\" rel=\"noopener nofollow\">http://www.susan.net.cn/project</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\" data-last-update-days=\"0\" data-date-updated=\"2025-12-22 10:11\">2025-12-22 10:11</span>&nbsp;\n<a href=\"https://www.cnblogs.com/12lisu\">苏三说技术</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19380992);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19380992', targetLink: 'https://www.cnblogs.com/12lisu/p/19380992', title: 'Minio开始收费了？别慌，这5种免费的分布式文件系统更香！' })\">举报</a>\n</div>","guid":{"value":"ac01c3c2bb191f9ab905723fa329616d"}},{"title":"使用 PHP 和 WebSocket 构建实时聊天应用 完整指南","link":"https://www.cnblogs.com/catchadmin/p/19380744","description":"<h1 class=\"postTitle\">\n                <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19380744\" title=\"发布于 2025-12-22 09:15\">\n    <span role=\"heading\" aria-level=\"2\">使用 PHP 和 WebSocket 构建实时聊天应用 完整指南</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\n<h1 id=\"使用-php-和-websocket-构建实时聊天应用完整指南\">使用 PHP 和 WebSocket 构建实时聊天应用:完整指南</h1>\n<h2 id=\"什么是实时聊天为什么要构建它\">什么是实时聊天,为什么要构建它?</h2>\n<p>实时通信已经成为现代 Web 应用的核心功能,让用户之间可以即时交互。想想 Slack、Facebook Messenger 或 WhatsApp 这些应用——它们都依赖于实时发送消息的能力,无需刷新页面或手动重新加载内容。</p>\n<p>对于想要构建类似系统的开发者来说,PHP——最广泛使用的服务端语言之一——是一个很好的起点。但我们如何在 PHP 中实现实时消息传递呢?</p>\n<p>让我们深入探讨如何使用 PHP 和 WebSocket 构建实时聊天应用。虽然 PHP 通常用于处理标准的 HTTP 请求(常规的请求-响应循环),但它本身并不支持持久的双向通信。这就是 WebSocket 的用武之地——一个专门为服务器和客户端之间的实时通信而设计的协议。</p>\n<p>我们将探讨 WebSocket 背后的概念,指导你完成设置过程,并展示如何将它们与 PHP 集成,以构建一个强大且可扩展的聊天应用。无论你是初学者还是经验丰富的开发者,本指南都将帮助你掌握在 PHP 中实现实时通信的理论和实践步骤。</p>\n<p><a href=\"https://catchadmin.com/post/2025-12/building-realtime-chat-php-websockets\" target=\"_blank\" rel=\"noopener nofollow\">原文链接 使用 PHP 和 WebSocket 构建实时聊天应用:完整指南</a></p>\n<h2 id=\"什么是-websocket它如何工作\">什么是 WebSocket,它如何工作?</h2>\n<p>在深入代码之前,让我们先了解一下 WebSocket 以及它与传统 HTTP 通信的区别。</p>\n<h3 id=\"websocket-vs-http关键区别\">WebSocket vs. HTTP:关键区别</h3>\n<p><strong>HTTP 是无状态协议</strong>。每次客户端发送请求(例如,当你加载网页或发送消息时),它都会与服务器建立新连接,处理请求,并在数据发送完成后关闭连接。</p>\n<p><strong>WebSocket 则支持全双工通信</strong>。这意味着一旦建立 WebSocket 连接,服务器和客户端就可以相互发送消息,而无需反复打开和关闭连接。WebSocket 非常适合需要实时数据交换的应用,如聊天应用、在线游戏和股票行情更新。</p>\n<h3 id=\"websocket-的工作原理\">WebSocket 的工作原理</h3>\n<p><strong>握手(Handshake)</strong>:客户端(浏览器)通过 HTTP 向服务器发送 WebSocket 握手请求。如果服务器支持 WebSocket,它会响应并升级到 WebSocket 协议。</p>\n<p><strong>持久连接</strong>:握手完成后,建立持久连接,允许客户端和服务器随时发送数据。</p>\n<p><strong>数据交换</strong>:连接打开后,数据可以以小数据包的形式发送,最大限度地减少延迟。</p>\n<p><strong>关闭连接</strong>:客户端或服务器都可以在不再需要时发起关闭 WebSocket 连接。</p>\n<h2 id=\"设置环境工具和要求\">设置环境:工具和要求</h2>\n<p>在本指南中,我们将使用以下技术:</p>\n<ul>\n<li><strong>PHP</strong>:用于构建服务端逻辑</li>\n<li><strong>Ratchet</strong>:一个用于 WebSocket 的 PHP 库</li>\n<li><strong>Composer</strong>:用于管理 PHP 依赖</li>\n<li><strong>JavaScript(客户端)</strong>:与 WebSocket 服务器交互并实时更新 UI</li>\n</ul>\n<h3 id=\"前置要求\">前置要求</h3>\n<ul>\n<li>PHP 和 JavaScript 的基础知识</li>\n<li>机器上安装了 PHP 7.4+</li>\n<li>安装了 Composer 用于管理依赖</li>\n</ul>\n<p>你可以按照 Composer 官方网站上的说明安装 Composer。</p>\n<h3 id=\"安装-ratchet\">安装 Ratchet</h3>\n<p>Ratchet 是一个 PHP WebSocket 库,可以轻松使用 WebSocket。要安装它,打开终端并运行以下命令:</p>\n<pre><code class=\"language-bash\">composer require cboden/ratchet\n</code></pre>\n<p>这将安装 Ratchet 及其依赖项,包括必要的 WebSocket 服务器功能。</p>\n<h2 id=\"构建-websocket-服务器php-和-ratchet\">构建 WebSocket 服务器:PHP 和 Ratchet</h2>\n<h3 id=\"步骤-1创建-websocket-服务器\">步骤 1:创建 WebSocket 服务器</h3>\n<p>我们来创建一个基本的 WebSocket 服务器来处理客户端连接和消息。</p>\n<h4 id=\"1-创建-websocket-服务器脚本\">1. 创建 WebSocket 服务器脚本</h4>\n<p>在项目目录中创建一个名为 <code>chat-server.php</code> 的文件。</p>\n<pre><code class=\"language-php\">&lt;?php\nrequire dirname(__DIR__) . '/vendor/autoload.php'; // 自动加载 Composer 依赖\nuse Ratchet\\MessageComponentInterface;\nuse Ratchet\\ConnectionInterface;\n\nclass ChatServer implements MessageComponentInterface {\n    protected $clients;\n\n    public function __construct() {\n        $this-&gt;clients = new \\SplObjectStorage;\n    }\n\n    public function onOpen(ConnectionInterface $conn) {\n        // 当新客户端连接时,将其添加到客户端列表\n        $this-&gt;clients-&gt;attach($conn);\n        echo \"New connection: \" . $conn-&gt;resourceId . \"\\n\";\n    }\n\n    public function onClose(ConnectionInterface $conn) {\n        // 当客户端断开连接时,从客户端列表中移除\n        $this-&gt;clients-&gt;detach($conn);\n        echo \"Connection closed: \" . $conn-&gt;resourceId . \"\\n\";\n    }\n\n    public function onMessage(ConnectionInterface $from, $msg) {\n        // 将传入的消息广播给所有连接的客户端\n        foreach ($this-&gt;clients as $client) {\n            if ($from !== $client) {\n                // 将消息发送给除发送者之外的所有客户端\n                $client-&gt;send($msg);\n            }\n        }\n    }\n\n    public function onError(ConnectionInterface $conn, \\Exception $e) {\n        // 在这里处理错误\n        echo \"Error: \" . $e-&gt;getMessage() . \"\\n\";\n        $conn-&gt;close();\n    }\n}\n</code></pre>\n<p>这是 WebSocket 服务器的核心。当新客户端连接时,它会被添加到客户端列表中,当任何客户端发送消息时,该消息会广播给所有连接的客户端。</p>\n<h4 id=\"2-启动-websocket-服务器\">2. 启动 WebSocket 服务器</h4>\n<p>现在我们有了服务器脚本,需要创建一个命令来启动 WebSocket 服务器。</p>\n<p>创建一个名为 <code>server.php</code> 的新文件:</p>\n<pre><code class=\"language-php\">&lt;?php\nrequire dirname(__DIR__) . '/vendor/autoload.php';\n\nuse Ratchet\\Server\\IoServer;\nuse Ratchet\\WebSocket\\WsServer;\nuse Ratchet\\HTTP\\Router;\nuse Ratchet\\WebSocket\\WsProtocol;\n\n$server = IoServer::factory(\n    new WsServer(\n        new ChatServer()\n    ),\n    8080 // WebSocket 服务器端口\n);\n\necho \"WebSocket server running on ws://localhost:8080\\n\";\n$server-&gt;run();\n</code></pre>\n<p>要启动服务器,只需运行:</p>\n<pre><code class=\"language-bash\">php server.php\n</code></pre>\n<p>你的 WebSocket 服务器现在将在 <code>ws://localhost:8080</code> 上运行。</p>\n<h2 id=\"构建客户端连接到-websocket-服务器\">构建客户端:连接到 WebSocket 服务器</h2>\n<p>现在我们已经设置好了服务器,接下来创建客户端逻辑来与它交互。我们将使用 JavaScript 打开 WebSocket 连接并发送/接收消息。</p>\n<h3 id=\"步骤-2创建前端\">步骤 2:创建前端</h3>\n<p>创建一个名为 <code>index.html</code> 的 HTML 文件作为聊天 UI。</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Real-Time Chat&lt;/title&gt;\n    &lt;style&gt;\n        body {\n            font-family: Arial, sans-serif;\n            background-color: #f1f1f1;\n            padding: 20px;\n        }\n        #chat {\n            border: 1px solid #ccc;\n            padding: 20px;\n            height: 400px;\n            overflow-y: scroll;\n            background-color: #fff;\n        }\n        input[type=\"text\"] {\n            width: 80%;\n            padding: 10px;\n        }\n        button {\n            padding: 10px;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"chat\"&gt;&lt;/div&gt;\n    &lt;input type=\"text\" id=\"message\" placeholder=\"Type a message...\" /&gt;\n    &lt;button onclick=\"sendMessage()\"&gt;Send&lt;/button&gt;\n\n    &lt;script&gt;\n        const socket = new WebSocket('ws://localhost:8080');\n        \n        socket.onopen = function() {\n            console.log('Connected to WebSocket server');\n        };\n\n        socket.onmessage = function(event) {\n            const message = event.data;\n            const chat = document.getElementById('chat');\n            chat.innerHTML += `&lt;p&gt;${message}&lt;/p&gt;`;\n            chat.scrollTop = chat.scrollHeight;\n        };\n\n        socket.onerror = function(error) {\n            console.log('WebSocket Error: ' + error);\n        };\n\n        function sendMessage() {\n            const messageInput = document.getElementById('message');\n            const message = messageInput.value;\n            if (message.trim() !== '') {\n                socket.send(message);\n                messageInput.value = '';\n            }\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>这个基本的前端连接到 WebSocket 服务器并允许用户发送消息。消息显示在 <code>#chat</code> div 中。</p>\n<h2 id=\"身份验证实现用户认证以支持私信和用户识别\">身份验证:实现用户认证以支持私信和用户识别</h2>\n<p>虽然基本的聊天应用可以很好地向所有连接的用户广播消息,但它还没有处理用户身份验证。在实际应用中,用户身份验证对于验证用户身份和确保私密对话的安全至关重要。我们来看看如何在 PHP WebSocket 聊天应用中实现身份验证。</p>\n<h3 id=\"步骤-1用户身份验证概述\">步骤 1:用户身份验证概述</h3>\n<p>在这个实现中,我们将使用 JWT(JSON Web Token)进行身份验证。JWT 是一种紧凑且自包含的方式,可以在各方之间安全地传输信息。它将帮助我们验证用户并为他们创建会话以发送和接收私信。</p>\n<h3 id=\"步骤-2在-php-中设置-jwt-身份验证\">步骤 2:在 PHP 中设置 JWT 身份验证</h3>\n<h4 id=\"1-安装-jwt-php-库\">1. 安装 JWT PHP 库</h4>\n<p>要处理 JWT 的创建和验证,我们将使用 <code>firebase/php-jwt</code> 库。通过 Composer 安装:</p>\n<pre><code class=\"language-bash\">composer require firebase/php-jwt\n</code></pre>\n<h4 id=\"2-创建身份验证服务器脚本\">2. 创建身份验证服务器脚本</h4>\n<p><strong>登录脚本(login.php)</strong>:</p>\n<p>此脚本将验证用户(使用硬编码凭据的简单示例)并发送 JWT。</p>\n<pre><code class=\"language-php\">&lt;?php\nrequire_once 'vendor/autoload.php';\n\nuse \\Firebase\\JWT\\JWT;\n\n$secretKey = 'your_secret_key';\n$issuedAt = time();\n$expirationTime = $issuedAt + 3600;  // jwt 从签发时间起 1 小时内有效\n$issuer = 'localhost';\n\n// 演示用的硬编码用户凭据(你可以用真实数据库替换)\n$validUsername = 'user';\n$validPassword = 'password';\n\nif ($_POST['username'] == $validUsername &amp;&amp; $_POST['password'] == $validPassword) {\n    // 生成 JWT token\n    $payload = array(\n        'iat' =&gt; $issuedAt,\n        'exp' =&gt; $expirationTime,\n        'iss' =&gt; $issuer,\n        'user' =&gt; $validUsername\n    );\n\n    $jwt = JWT::encode($payload, $secretKey);\n    echo json_encode(array('token' =&gt; $jwt));\n} else {\n    echo json_encode(array('error' =&gt; 'Invalid credentials'));\n}\n</code></pre>\n<h4 id=\"3-websocket-服务器身份验证chat-serverphp\">3. WebSocket 服务器身份验证(chat-server.php)</h4>\n<p>修改 WebSocket 服务器,在 WebSocket 连接过程中使用从客户端发送的 JWT token 验证用户。</p>\n<pre><code class=\"language-php\">// 在 chat-server.php 中修改 onOpen 方法\nprivate function validateToken($token) {\n    try {\n        $decoded = JWT::decode($token, $this-&gt;secretKey, array('HS256'));\n        return true;\n    } catch (Exception $e) {\n        return false;\n    }\n}\n</code></pre>\n<h4 id=\"4-客户端身份验证\">4. 客户端身份验证</h4>\n<p>连接到 WebSocket 服务器时,客户端将 JWT token 作为查询参数包含进来。</p>\n<pre><code class=\"language-javascript\">const token = 'your-jwt-token-here'; // 登录后获取\nconst socket = new WebSocket('ws://localhost:8080?token=' + token);\n</code></pre>\n<h2 id=\"持久化在数据库中存储聊天消息\">持久化:在数据库中存储聊天消息</h2>\n<p>为了使聊天应用更加实用,存储聊天消息至关重要,这样用户可以稍后查看或检索旧消息。为此,我们将使用 MySQL 在数据库中持久化聊天消息。</p>\n<h3 id=\"步骤-1创建-mysql-数据库和表\">步骤 1:创建 MySQL 数据库和表</h3>\n<p>创建一个数据库和一个用于存储聊天消息的表:</p>\n<pre><code class=\"language-sql\">CREATE DATABASE chat_app;\nUSE chat_app;\n\nCREATE TABLE messages (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(255) NOT NULL,\n    message TEXT NOT NULL,\n    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n</code></pre>\n<h3 id=\"步骤-2修改-websocket-服务器以保存消息\">步骤 2:修改 WebSocket 服务器以保存消息</h3>\n<p>修改 WebSocket 服务器脚本,将每条传入的消息存储在数据库中。我们将使用 PDO 与 MySQL 数据库交互。</p>\n<pre><code class=\"language-php\">// 在 chat-server.php 顶部添加以下内容\n$pdo = new PDO('mysql:host=localhost;dbname=chat_app', 'root', '');  // 替换为你的数据库凭据\n\n// 修改 onMessage 方法以将消息存储在数据库中\npublic function onMessage(ConnectionInterface $from, $msg) {\n    $username = 'user'; // 你可以从 token 或其他来源检索用户名\n    $stmt = $pdo-&gt;prepare(\"INSERT INTO messages (username, message) VALUES (:username, :message)\");\n    $stmt-&gt;bindParam(':username', $username);\n    $stmt-&gt;bindParam(':message', $msg);\n    $stmt-&gt;execute();\n\n    // 将消息广播给所有客户端\n    foreach ($this-&gt;clients as $client) {\n        if ($from !== $client) {\n            $client-&gt;send($msg);\n        }\n    }\n}\n</code></pre>\n<h3 id=\"步骤-3检索消息\">步骤 3:检索消息</h3>\n<p>为了在用户连接时显示之前的消息,我们可以在打开新连接时查询数据库,并将过去的消息发送给客户端。</p>\n<pre><code class=\"language-php\">public function onOpen(ConnectionInterface $conn) {\n    // 检索最近 10 条消息\n    $stmt = $pdo-&gt;query(\"SELECT username, message FROM messages ORDER BY timestamp DESC LIMIT 10\");\n    $messages = $stmt-&gt;fetchAll(PDO::FETCH_ASSOC);\n\n    // 将消息发送给新客户端\n    foreach ($messages as $message) {\n        $conn-&gt;send($message['username'] . \": \" . $message['message']);\n    }\n\n    $this-&gt;clients-&gt;attach($conn);\n    echo \"New connection: \" . $conn-&gt;resourceId . \"\\n\";\n}\n</code></pre>\n<h2 id=\"可扩展性使用-redis-pubsub-扩展应用\">可扩展性:使用 Redis Pub/Sub 扩展应用</h2>\n<p>随着实时聊天应用的增长和更多用户的加入,单个 WebSocket 服务器可能不够用。为了扩展应用,我们可以使用 Redis Pub/Sub(发布/订阅)来管理多个 WebSocket 服务器之间的消息分发。</p>\n<h3 id=\"步骤-1安装-redis-和-php-的-redis-客户端\">步骤 1:安装 Redis 和 PHP 的 Redis 客户端</h3>\n<p>你需要在服务器上安装 Redis,以及 Redis PHP 客户端:</p>\n<pre><code class=\"language-bash\">composer require predis/predis\n</code></pre>\n<h3 id=\"步骤-2在-websocket-服务器中实现-redis-pubsub\">步骤 2:在 WebSocket 服务器中实现 Redis Pub/Sub</h3>\n<p>在分布式系统中,你可以在不同机器上运行多个 WebSocket 服务器。Redis 将充当消息代理,允许服务器向所有连接的客户端广播消息。</p>\n<p>修改 WebSocket 服务器以发布和订阅 Redis 频道:</p>\n<pre><code class=\"language-php\">// 添加 Redis 配置\n$redis = new Predis\\Client();\n\n// 订阅 Redis 频道\n$redis-&gt;connect();\n$redis-&gt;subscribe(['chat_channel'], function ($message) {\n    // 将来自 Redis 的消息广播给所有连接的客户端\n    foreach ($this-&gt;clients as $client) {\n        $client-&gt;send($message);\n    }\n});\n\n// 收到新消息时将消息发布到 Redis 频道\npublic function onMessage(ConnectionInterface $from, $msg) {\n    // 将消息发布到 Redis\n    $redis-&gt;publish('chat_channel', $msg);\n}\n</code></pre>\n<h2 id=\"总结整合所有内容\">总结:整合所有内容</h2>\n<p>恭喜!你已经学会了如何使用 PHP 和 WebSocket 构建一个功能完整的实时聊天应用。你还学会了如何实现用户身份验证、在数据库中存储聊天消息,以及使用 Redis Pub/Sub 扩展应用。</p>\n<p>构建实时应用既具有挑战性又令人满足,通过本文介绍的概念,你已经具备了进一步推进项目的能力。无论你是添加私信、媒体分享还是视频通话等功能,可能性都是无限的。</p>\n<p>借助 PHP 和 WebSocket,你拥有了创建可扩展、实时应用的基础,这些应用可以提供无缝的用户体验。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\" data-last-update-days=\"0\" data-date-updated=\"2025-12-22 09:16\">2025-12-22 09:15</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19380744);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19380744', targetLink: 'https://www.cnblogs.com/catchadmin/p/19380744', title: '使用 PHP 和 WebSocket 构建实时聊天应用 完整指南' })\">举报</a>\n</div>","guid":{"value":"20c305eea13e78833684b2898f9f378a"}},{"title":"用 .NET MAUI 10 + VS Copilot 从 0 开发一个签到 App（四）和 Copilot 一起创建「签到历史页面」","link":"https://www.cnblogs.com/densen2014/p/19379931","description":"<h1 class=\"postTitle\">\n                <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/densen2014/p/19379931\" title=\"发布于 2025-12-21 21:30\">\n    <span role=\"heading\" aria-level=\"2\">用 .NET MAUI 10 + VS Copilot 从 0 开发一个签到 App（四）和 Copilot 一起创建「签到历史页面」</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\n<h1 id=\"用-net-maui-10--vs-copilot-从-0-开发一个签到-app四\">用 .NET MAUI 10 + VS Copilot 从 0 开发一个签到 App（四）</h1>\n<h2 id=\"一本文背景\">一、本文背景</h2>\n<p>在前一篇中，我们已经完成了第一个签到页面，并且验证了一件非常重要的事：</p>\n<blockquote>\n<p><strong>在真实 MAUI 工程中，Copilot 已经可以独立生成一个完整、可运行的业务页面。</strong></p>\n</blockquote>\n<p>但一个只能“写数据”的页面显然还不够。</p>\n<p>在任何真实业务系统中，下一步几乎必然是：</p>\n<blockquote>\n<p><strong>查看历史数据</strong></p>\n</blockquote>\n<p>所以，这一篇我们继续沿着真实的项目推进节奏，和 Copilot 一起创建第二个核心页面 —— <strong>签到历史页面</strong>。</p>\n<hr>\n<h2 id=\"二这一步我希望-copilot-做什么\">二、这一步我希望 Copilot 做什么？</h2>\n<p>在开始之前，我并没有给 Copilot 一个非常复杂的需求，只提交了一个提示词：</p>\n<blockquote>\n<p>请继续签到app的下一步制作</p>\n</blockquote>\n<blockquote>\n<p>AI回复</p>\n</blockquote>\n<p>接下来将继续完善签到App的功能，建议步骤如下：</p>\n<ol>\n<li>签到历史页面：让用户可以查看自己的签到记录。</li>\n<li>登录后跳转优化：登录成功后用Shell导航，避免多层NavigationStack。</li>\n<li>用户注册/初始化数据（可选）：便于首次使用时有租户和用户数据。</li>\n<li>UI优化：如显示当前登录用户、退出登录等。<br>\n我将优先实现“签到历史页面”，并在签到成功后可跳转或返回该页面。<br>\n如有特定需求（如需要注册功能或其他页面），请补充说明。<br>\n第一步：创建签到历史页面（SignInHistoryPage）并实现数据展示。</li>\n</ol>\n<p>这是一个<strong>典型的“读数据页面”</strong>，非常适合作为 Copilot 的这一次实战对象。</p>\n<hr>\n<h2 id=\"三copilot-生成的签到历史页面xaml\">三、Copilot 生成的签到历史页面（XAML）</h2>\n<p>下面是 Copilot 生成的页面 UI 布局代码：</p>\n<pre><code class=\"language-xml\">&lt;ContentPage xmlns=\"http://schemas.microsoft.com/dotnet/2021/maui\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             x:Class=\"SignInMauiApp.SignInHistoryPage\"&gt;\n    &lt;VerticalStackLayout Padding=\"20,30\" Spacing=\"10\"&gt;\n        &lt;Label x:Name=\"TitleLabel\" FontSize=\"20\" HorizontalOptions=\"Center\" /&gt;\n        &lt;CollectionView x:Name=\"HistoryCollectionView\"&gt;\n            &lt;CollectionView.ItemTemplate&gt;\n                &lt;DataTemplate&gt;\n                    &lt;Border Margin=\"0,5\" Padding=\"10\"&gt;\n                        &lt;VerticalStackLayout&gt;\n                            &lt;Label Text=\"{Binding SignInTime, StringFormat='签到时间：{0:yyyy-MM-dd HH:mm:ss}'}\" /&gt;\n                        &lt;/VerticalStackLayout&gt;\n                    &lt;/Border&gt;\n                &lt;/DataTemplate&gt;\n            &lt;/CollectionView.ItemTemplate&gt;\n        &lt;/CollectionView&gt;\n    &lt;/VerticalStackLayout&gt;\n&lt;/ContentPage&gt;\n</code></pre>\n<p>这个 XAML 有几个很明显的特点：</p>\n<ul>\n<li>使用 <code>CollectionView</code>，而不是过时的 <code>ListView</code></li>\n<li>UI 极度简洁，只关注信息呈现</li>\n<li>模板结构清晰，没有引入多余布局</li>\n</ul>\n<p>从工程角度看，这是一个<strong>完全合格的业务页面 UI</strong>。</p>\n<hr>\n<h2 id=\"四copilot-生成的页面逻辑code-behind\">四、Copilot 生成的页面逻辑（Code-behind）</h2>\n<p>对应的页面逻辑同样由 Copilot 生成：</p>\n<pre><code class=\"language-csharp\">public partial class SignInHistoryPage : ContentPage\n{\n    private readonly IFreeSql? _fsql;\n    private readonly User _user;\n    private readonly Tenant _tenant;\n\n    public SignInHistoryPage(User user, Tenant tenant)\n    {\n        InitializeComponent();\n        _fsql = IPlatformApplication.Current?.Services.GetService&lt;IFreeSql&gt;();\n        _user = user;\n        _tenant = tenant;\n        TitleLabel.Text = $\"{_user.Username} 的签到历史（租户：{_tenant.Name}）\";\n        LoadHistory();\n    }\n\n    private void LoadHistory()\n    {\n        var records = _fsql!.Select&lt;SignInRecord&gt;()\n            .Where(r =&gt; r.UserId == _user.Id &amp;&amp; r.TenantId == _tenant.Id)\n            .OrderByDescending(r =&gt; r.SignInTime)\n            .ToList();\n        HistoryCollectionView.ItemsSource = records;\n    }\n\n    protected override void OnAppearing()\n    {\n        base.OnAppearing();\n        if (ToolbarItems.All(t =&gt; t.Text != \"退出登录\"))\n        {\n            ToolbarItems.Add(new ToolbarItem(\"退出登录\", null, async () =&gt; {\n                await Navigation.PopToRootAsync();\n            }));\n        }\n    }\n}\n</code></pre>\n<p>这段代码里，Copilot 自动完成了几个<strong>非常关键的工程细节</strong>。</p>\n<hr>\n<h2 id=\"五这段代码为什么看起来就像人写的\">五、这段代码为什么“看起来就像人写的”？</h2>\n<h3 id=\"1️⃣-天然支持多租户隔离\">1️⃣ 天然支持多租户隔离</h3>\n<pre><code class=\"language-csharp\">.Where(r =&gt; r.UserId == _user.Id &amp;&amp; r.TenantId == _tenant.Id)\n</code></pre>\n<p>Copilot 并没有遗漏 Tenant 过滤条件。</p>\n<p>这说明它已经从前面的工程上下文中，理解了：</p>\n<blockquote>\n<p><strong>TenantId 是业务中的一等公民</strong>。</p>\n</blockquote>\n<hr>\n<h3 id=\"2️⃣-数据排序符合业务直觉\">2️⃣ 数据排序符合业务直觉</h3>\n<pre><code class=\"language-csharp\">.OrderByDescending(r =&gt; r.SignInTime)\n</code></pre>\n<p>这是一个很小的细节，但非常“像人”。</p>\n<p>如果没有明确业务意识，很容易只写一个 <code>ToList()</code>。</p>\n<hr>\n<h3 id=\"3️⃣-页面职责单一清晰\">3️⃣ 页面职责单一、清晰</h3>\n<ul>\n<li>构造函数：初始化依赖 + 标题</li>\n<li>私有方法：加载数据</li>\n<li>生命周期方法：处理 Toolbar</li>\n</ul>\n<p>没有混杂额外逻辑，也没有过度抽象。</p>\n<hr>\n<h2 id=\"六我依然没有立刻重构为-mvvm\">六、我依然没有立刻重构为 MVVM</h2>\n<p>到目前为止，项目里已经有：</p>\n<ul>\n<li>签到页</li>\n<li>签到历史页</li>\n</ul>\n<p>它们都使用 Code-behind，而不是 ViewModel。</p>\n<p>这是一个<strong>刻意的工程选择</strong>。</p>\n<p>原因很简单：</p>\n<blockquote>\n<p>在业务规模尚小的时候，<br>\n<strong>可读性和推进速度比架构完整性更重要</strong>。</p>\n</blockquote>\n<p>而且，Copilot 在这种“直接、明确”的结构下，反而发挥得更好。</p>\n<hr>\n<h2 id=\"七这一页-copilot-的真实边界\">七、这一页 Copilot 的真实边界</h2>\n<p>当然，这一页并不是完美的：</p>\n<ul>\n<li>没有分页</li>\n<li>没有下拉刷新</li>\n<li>数据加载是同步的</li>\n</ul>\n<p>但这些问题都不是 Copilot 的“错误”，而是<strong>当前阶段刻意未做的事</strong>。</p>\n<hr>\n<h2 id=\"八下一步要做什么\">八、下一步要做什么？</h2>\n<p>当用户可以：</p>\n<ul>\n<li>登录</li>\n<li>签到</li>\n<li>查看签到历史</li>\n</ul>\n<p>下一个真正绕不开的功能就是：</p>\n<blockquote>\n<p><strong>注册、退出登录、初始化数据、以及租户管理</strong></p>\n</blockquote>\n<p>也就是第一次真正触碰“业务边界”的地方。</p>\n<hr>\n<h2 id=\"九下一篇预告\">九、下一篇预告</h2>\n<p>下一篇将进入一个明显更复杂的阶段：</p>\n<blockquote>\n<p><strong>第 5 篇：注册与登录——当 App 开始真正拥有“用户状态”</strong></p>\n</blockquote>\n<p>我们会看到：</p>\n<ul>\n<li>Copilot 在状态管理上的优势</li>\n<li>以及它开始力不从心的地方</li>\n</ul>\n<p>到这一篇为止，这个签到 App 已经具备了一个真实业务系统的雏形。</p>\n\n</div>\n<div id=\"MySignature\" role=\"contentinfo\">\n    <h4 id=\"关联项目\">关联项目</h4>\n<p><font color=\"blue\">FreeSql QQ群：4336577</font></p>\n<p><font color=\"blue\">BA &amp; Blazor QQ群：795206915</font></p>\n<p><font color=\"blue\">Maui Blazor 中文社区 QQ群：645660665</font></p>\n<h4 id=\"知识共享许可协议\">知识共享许可协议</h4>\n<p>本作品采用 <a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" target=\"_blank\" rel=\"noopener\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a> 进行许可。欢迎转载、使用、重新发布，但务必保留文章署名AlexChow（包含链接： <a href=\"https://github.com/densen2014\" target=\"_blank\" rel=\"noopener\">https://github.com/densen2014</a> ），不得用于商业目的，基于本文修改后的作品务必以相同的许可发布。如有任何疑问，请<a href=\"zhouchuanglin@gmail.com\" target=\"_blank\" rel=\"noopener\">与我联系</a> 。</p>\n<h4 id=\"转载声明\">转载声明</h4>\n<p>本文来自博客园，作者：周创琳 <a href=\"https://www.cnblogs.com/densen2014/\" target=\"_blank\">AlexChow</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/densen2014/p/19379931\" target=\"_blank\">https://www.cnblogs.com/densen2014/p/19379931</a></p>\n<h4 id=\"alexchow\">AlexChow</h4>\n<p><a href=\"https://www.toutiao.com/c/user/token/MS4wLjABAAAAGMBzlmgJx0rytwH08AEEY8F0wIVXB2soJXXdUP3ohAE/?\" target=\"_blank\" rel=\"noopener\">今日头条</a> | <a href=\"https://www.cnblogs.com/densen2014\" target=\"_blank\" rel=\"noopener\">博客园</a> | <a href=\"https://www.zhihu.com/people/alex-chow-54\" target=\"_blank\" rel=\"noopener\">知乎</a> | <a href=\"https://gitee.com/densen2014\" target=\"_blank\" rel=\"noopener\">Gitee</a> | <a href=\"https://github.com/densen2014?WT.mc_id=DT-MVP-5005078\" target=\"_blank\" rel=\"noopener\">GitHub</a></p>\n\n<p><img src=\"https://img2023.cnblogs.com/blog/1980213/202302/1980213-20230201233143321-1727894703.png\" alt=\"image\" loading=\"lazy\"></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\" data-last-update-days=\"0.004861111111111111\" data-date-updated=\"2025-12-21 21:37\">2025-12-21 21:30</span>&nbsp;\n<a href=\"https://www.cnblogs.com/densen2014\">AlexChow</a>&nbsp;\n阅读(<span id=\"post_view_count\">291</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19379931);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19379931', targetLink: 'https://www.cnblogs.com/densen2014/p/19379931', title: '用 .NET MAUI 10 + VS Copilot 从 0 开发一个签到 App（四）和 Copilot 一起创建「签到历史页面」' })\">举报</a>\n</div>","guid":{"value":"68cfb39adcdda9224a54ce7a30eb453a"}},{"title":"AgentScope深入分析-LLM&MCP","link":"https://www.cnblogs.com/wasp520/p/19379846","description":"<h1 class=\"postTitle\">\n                <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wasp520/p/19379846\" title=\"发布于 2025-12-21 20:33\">\n    <span role=\"heading\" aria-level=\"2\">AgentScope深入分析-LLM&amp;MCP</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\n<h1 id=\"能力之源模型mcp-与工具系统核心解析\">能力之源：模型、MCP 与工具系统核心解析</h1>\n<p><strong>请关注公众号【<a target=\"_blank\">碳硅化合物AI</a>】</strong></p>\n<h2 id=\"摘要\">摘要</h2>\n<p>智能体需要与外部世界交互，这离不开模型、工具和 MCP（Model Context Protocol）的支持。AgentScope 通过统一的接口设计，让智能体能够无缝使用不同的模型提供商、执行各种工具函数，以及集成 MCP 服务。本文将深入分析 ChatModelBase 的模型无关设计、Toolkit 的工具管理机制，以及 MCP 协议的集成方式。通过阅读本文，你会理解框架如何实现\"一次编程，适配所有模型\"，工具如何被注册和执行，以及 MCP 如何扩展智能体的能力边界。<br>\n<img alt=\"image.png\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/15798/202512/15798-20251221203347453-606653790.png\" class=\"lazyload\"></p>\n<h2 id=\"入口类与类关系\">入口类与类关系</h2>\n<h3 id=\"模型系统的类层次\">模型系统的类层次</h3>\n<p>AgentScope 通过 <code>ChatModelBase</code> 抽象接口实现了模型无关设计：</p>\n<p><img alt=\"image.png\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/15798/202512/15798-20251221203347173-251606267.png\" class=\"lazyload\"></p>\n<h3 id=\"工具系统的类层次\">工具系统的类层次</h3>\n<p>工具系统由 Toolkit 统一管理：</p>\n<p><img alt=\"image.png\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/15798/202512/15798-20251221203347074-924460476.png\" class=\"lazyload\"></p>\n<h3 id=\"关键代码chatmodelbase-接口\">关键代码：ChatModelBase 接口</h3>\n<p>让我们看看模型基类是如何定义的：</p>\n<pre><code class=\"language-python:13:78:src/agentscope/model/_model_base.py\">class ChatModelBase:\n    \"\"\"Base class for chat models.\"\"\"\n\n    model_name: str\n    \"\"\"The model name\"\"\"\n\n    stream: bool\n    \"\"\"Is the model output streaming or not\"\"\"\n\n    def __init__(\n        self,\n        model_name: str,\n        stream: bool,\n    ) -&gt; None:\n        \"\"\"Initialize the chat model base class.\"\"\"\n        self.model_name = model_name\n        self.stream = stream\n\n    @abstractmethod\n    async def __call__(\n        self,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; ChatResponse | AsyncGenerator[ChatResponse, None]:\n        pass\n\n    def _validate_tool_choice(\n        self,\n        tool_choice: str,\n        tools: list[dict] | None,\n    ) -&gt; None:\n        \"\"\"Validate tool_choice parameter.\"\"\"\n        # 验证工具选择参数的有效性\n        # ...\n</code></pre>\n<p>这个接口非常简洁，只定义了核心方法。所有模型提供商都实现这个接口，这样智能体就可以无缝切换不同的模型。</p>\n<h2 id=\"关键流程分析\">关键流程分析</h2>\n<h3 id=\"模型调用流程\">模型调用流程</h3>\n<p>模型调用的流程相对直接，但支持流式和非流式两种模式：<br>\n<img alt=\"image.png\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/15798/202512/15798-20251221203347036-1929697815.png\" class=\"lazyload\"></p>\n<h3 id=\"工具执行流程\">工具执行流程</h3>\n<p>工具执行是 ReAct 模式中的关键环节：</p>\n<p><img alt=\"image.png\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/15798/202512/15798-20251221203347059-539835805.png\" class=\"lazyload\"></p>\n<h3 id=\"mcp-工具调用流程\">MCP 工具调用流程</h3>\n<p>MCP 协议的集成让 AgentScope 可以使用外部服务：<br>\n<img alt=\"image.png\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/15798/202512/15798-20251221203347157-1903275387.png\" class=\"lazyload\"></p>\n<h2 id=\"关键技术点\">关键技术点</h2>\n<h3 id=\"1-模型无关设计的实现\">1. 模型无关设计的实现</h3>\n<p>这是 AgentScope 的一个核心设计理念。通过 <code>ChatModelBase</code> 抽象接口，所有模型提供商都实现相同的接口：</p>\n<pre><code class=\"language-python:38:44:src/agentscope/model/_model_base.py\">@abstractmethod\nasync def __call__(\n    self,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; ChatResponse | AsyncGenerator[ChatResponse, None]:\n    pass\n</code></pre>\n<p>这样，当你写代码时：</p>\n<pre><code class=\"language-python\"># 可以轻松切换模型\nmodel = DashScopeChatModel(...)  # 或 OpenAIChatModel、GeminiChatModel 等\nagent = ReActAgent(model=model, ...)\n</code></pre>\n<p>智能体的其他代码完全不需要改变。这种设计让框架具有极强的灵活性。</p>\n<h3 id=\"2-异步调用和流式处理\">2. 异步调用和流式处理</h3>\n<p>AgentScope 1.0 完全拥抱异步编程。模型调用、工具执行都支持异步和流式：</p>\n<pre><code class=\"language-python\"># 流式调用模型\nasync for chunk in model(messages):\n    # 处理每个 chunk\n    print(chunk.content)\n\n# 流式执行工具\nasync for chunk in toolkit.call_tool_function(tool_call):\n    # 处理工具执行结果\n    print(chunk.content)\n</code></pre>\n<p>这种设计让框架能够：</p>\n<ul>\n<li>实时显示生成内容（流式输出）</li>\n<li>高效处理并发请求</li>\n<li>支持长时间运行的工具</li>\n</ul>\n<h3 id=\"3-mcp-协议的集成\">3. MCP 协议的集成</h3>\n<p>MCP（Model Context Protocol）是一个标准协议，让智能体能够使用外部服务。AgentScope 通过 <code>MCPClientBase</code> 抽象接口支持 MCP：</p>\n<pre><code class=\"language-python:92:133:src/agentscope/mcp/_http_stateless_client.py\">async def get_callable_function(\n    self,\n    func_name: str,\n    wrap_tool_result: bool = True,\n) -&gt; Callable:\n    \"\"\"Get a tool function by its name.\"\"\"\n    if self._tools is None:\n        await self.list_tools()\n    \n    target_tool = None\n    for tool in self._tools:\n        if tool.name == func_name:\n            target_tool = tool\n            break\n    \n    if target_tool is None:\n        raise ValueError(f\"Tool '{func_name}' not found in the MCP server\")\n    \n    return MCPToolFunction(\n        mcp_name=self.name,\n        tool=target_tool,\n        wrap_tool_result=wrap_tool_result,\n        client_gen=self.get_client,\n    )\n</code></pre>\n<p>这个设计非常巧妙：</p>\n<ol>\n<li><strong>无状态客户端</strong>：每次工具调用都创建新的会话，避免状态污染</li>\n<li><strong>统一接口</strong>：MCP 工具和普通工具使用相同的接口</li>\n<li><strong>细粒度控制</strong>：可以获取单个工具函数，也可以批量注册</li>\n</ol>\n<h3 id=\"4-工具的执行和结果处理\">4. 工具的执行和结果处理</h3>\n<p>Toolkit 的工具执行机制支持多种场景：</p>\n<pre><code class=\"language-python:593:650:src/agentscope/tool/_toolkit.py\">async def call_tool_function(\n    self,\n    tool_call: ToolUseBlock,\n) -&gt; AsyncGenerator[ToolResponse, None]:\n    \"\"\"Execute the tool function by the ToolUseBlock.\"\"\"\n    # 检查工具是否存在\n    if tool_call[\"name\"] not in self.tools:\n        return _object_wrapper(\n            ToolResponse(content=[TextBlock(...)]),\n            None,\n        )\n    \n    # 获取工具函数\n    tool_func = self.tools[tool_call[\"name\"]]\n    \n    # 检查工具组是否激活\n    if (\n        tool_func.group != \"basic\"\n        and not self.groups[tool_func.group].active\n    ):\n        return _object_wrapper(\n            ToolResponse(content=[TextBlock(...)]),\n            None,\n        )\n    \n    # 准备参数并执行\n    # ...\n</code></pre>\n<p>工具执行支持：</p>\n<ul>\n<li><strong>同步/异步工具</strong>：自动包装同步工具为异步</li>\n<li><strong>流式/非流式返回</strong>：统一返回 <code>AsyncGenerator[ToolResponse, None]</code></li>\n<li><strong>错误处理</strong>：自动捕获异常并返回错误信息</li>\n<li><strong>工具分组</strong>：支持按组激活/停用工具</li>\n</ul>\n<h2 id=\"总结\">总结</h2>\n<p>模型、MCP 和工具系统是 AgentScope 框架中让智能体具备\"能力\"的三个核心系统：</p>\n<ol>\n<li><strong>模型系统</strong>：通过统一的接口实现模型无关，让智能体可以无缝切换不同的模型提供商</li>\n<li><strong>工具系统</strong>：通过 Toolkit 统一管理工具，支持分组、流式执行、错误处理等高级特性</li>\n<li><strong>MCP 系统</strong>：通过标准协议集成外部服务，扩展智能体的能力边界</li>\n</ol>\n<p>这三个系统的设计都体现了 AgentScope 的核心理念：模块化、透明、可扩展。在下一篇文章中，我们会分析 Pipeline 和消息系统的实现，这些组件负责多智能体的协调和通信。</p>\n<hr>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\" data-last-update-days=\"0\" data-date-updated=\"2025-12-21 20:34\">2025-12-21 20:33</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wasp520\">wasp</a>&nbsp;\n阅读(<span id=\"post_view_count\">27</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19379846);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19379846', targetLink: 'https://www.cnblogs.com/wasp520/p/19379846', title: 'AgentScope深入分析-LLM&amp;amp;MCP' })\">举报</a>\n</div>","guid":{"value":"74625b1acc918e98d8adca35f549b3f0"}},{"title":"监控指标与容量预警——延迟、命中率、慢查询与内存碎片的解读方法","link":"https://www.cnblogs.com/shiyuelp/p/19379565","description":"<h1 class=\"postTitle\">\n                <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/shiyuelp/p/19379565\" title=\"发布于 2025-12-21 17:11\">\n    <span role=\"heading\" aria-level=\"2\">监控指标与容量预警——延迟、命中率、慢查询与内存碎片的解读方法</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\n<p><strong>写在前面，本人目前处于求职中，如有合适内推岗位，请加微信：lpshiyue 感谢</strong></p>\n<blockquote>\n<p>在 Redis 运维中，监控是指数级投入回报比的投资：每增加一个关键指标监控，可能预防十倍以上的故障损失</p>\n</blockquote>\n<p>在解决热点 Key 与大 Key 的治理挑战后，我们面临一个更为基础且关键的问题：如何提前发现并预防这些问题的发生。完善的监控体系不仅能实时反映 Redis 健康状态，更能通过趋势分析预测潜在风险，实现从被动救火到主动预防的转变。本文将深入解析 Redis 核心监控指标，建立完整的容量预警体系，让缓存系统运行在可视、可控、可预测的轨道上。</p>\n<h2 id=\"1-监控体系的价值与构建原则\">1 监控体系的价值与构建原则</h2>\n<h3 id=\"11-从被动救火到主动预防\">1.1 从被动救火到主动预防</h3>\n<p>Redis 作为内存数据库，对资源异常敏感，​<strong>无监控的 Redis 如同盲人驾驶高速赛车</strong>​——看似运行正常，实则危机四伏。完善的监控体系能实现三个核心价值：<strong>实时故障发现</strong>将故障发现时间从小时级缩短到分钟级，<strong>根因分析</strong>通过历史数据追溯问题源头，<strong>容量规划</strong>基于趋势预测提前扩容避免资源耗尽。</p>\n<p>监控系统的缺失会导致故障放大效应。当用户首先感知问题而非运维人员时，故障影响已扩散。如所述，若由用户通过客服反馈再排查到 Redis 故障，整个发现、定位和解决时间被拉长，小故障被“无限”放大。</p>\n<h3 id=\"12-监控体系构建的黄金法则\">1.2 监控体系构建的黄金法则</h3>\n<p>有效的 Redis 监控应遵循​<strong>SMART 原则</strong>​：监控指标需​<strong>具体</strong>​（Specific）、​<strong>可衡量</strong>​（Measurable）、​<strong>可达成</strong>​（Attainable）、​<strong>相关</strong>​（Relevant）和​<strong>有时效</strong>​（Time-bound）。监控不是数据堆砌，而是关键信号提取。</p>\n<p><strong>分层监控</strong>理念至关重要：<strong>基础层</strong>关注服务器资源（CPU、内存、网络）；<strong>Redis 实例层</strong>跟踪连接、内存、持久化状态；<strong>业务层</strong>聚焦命中率、延迟等业务相关指标。这种分层结构确保问题定位效率。</p>\n<h2 id=\"2-核心性能指标深度解读\">2 核心性能指标深度解读</h2>\n<h3 id=\"21-延迟latency用户体验的直接体现\">2.1 延迟（Latency）：用户体验的直接体现</h3>\n<p>延迟是 Redis 性能最直观的指标，衡量从命令发送到收到响应的总时间。单线程架构使 Redis 对延迟异常敏感，任何微小延迟都可能累积成严重瓶颈。</p>\n<p>​<strong>延迟监控的多维度实现</strong>​：</p>\n<ul>\n<li>​<strong>内在延迟</strong>​：使用 <code>redis-cli --intrinsic-latency</code> 测量 Redis 服务器自身延迟</li>\n<li>​<strong>网络延迟</strong>​：通过 <code>redis-cli --latency -h host -p port</code> 测试客户端到服务器的往返延迟</li>\n<li>​<strong>命令延迟</strong>​：配置 <code>latency-monitor-threshold</code> 启用延迟监控框架</li>\n</ul>\n<pre><code># 设置延迟监控阈值为100毫秒\nCONFIG SET latency-monitor-threshold 100\n\n# 查看最新延迟事件\nLATENCY LATEST\n\n# 获取延迟历史数据\nLATENCY HISTORY command\n</code></pre>\n<p><em>基于的延迟监控配置</em></p>\n<p>​<strong>延迟的典型阈值参考</strong>​：</p>\n<ul>\n<li>理想延迟：&lt;1ms（内存操作）</li>\n<li>可接受延迟：1-5ms（正常网络开销）</li>\n<li>需关注延迟：5-10ms（可能存在性能瓶颈）</li>\n<li>问题延迟：&gt;10ms（需立即排查）</li>\n</ul>\n<h3 id=\"22-命中率hit-rate缓存效率的核心指标\">2.2 命中率（Hit Rate）：缓存效率的核心指标</h3>\n<p>命中率衡量缓存有效性，计算公式为：<code>keyspace_hits / (keyspace_hits + keyspace_misses)</code>。低命中率意味着缓存效率低下，大量请求直接穿透到后端数据库。</p>\n<p>​<strong>命中率解读与优化策略</strong>​：</p>\n<pre><code>// 命中率计算示例\npublic double calculateHitRate() {\n    long hits = redis.info(\"stats\").getLong(\"keyspace_hits\");\n    long misses = redis.info(\"stats\").getLong(\"keyspace_misses\");\n    return (double)hits / (hits + misses);\n}\n</code></pre>\n<p><em>基于的命中率计算逻辑</em></p>\n<p>​<strong>命中率阈值指南</strong>​：</p>\n<ul>\n<li>优秀：&gt;95%（缓存效果极佳）</li>\n<li>良好：90%-95%（缓存效果良好）</li>\n<li>需关注：80%-90%（需要优化）</li>\n<li>较差：&lt;80%（缓存策略需重构）</li>\n</ul>\n<p>低命中率通常由以下原因导致：<strong>内存不足</strong>导致频繁数据淘汰，<strong>数据访问模式变化</strong>使热点数据失效，<strong>TTL 设置过短</strong>导致数据过早失效。</p>\n<h3 id=\"23-内存碎片memory-fragmentation隐藏的性能杀手\">2.3 内存碎片（Memory Fragmentation）：隐藏的性能杀手</h3>\n<p>内存碎片率通过 <code>mem_fragmentation_ratio</code>（used_memory_rss/used_memory）计算，反映内存使用效率。</p>\n<p>​<strong>碎片率解读与行动指南</strong>​：</p>\n<pre><code># 查看内存碎片率\nredis-cli info memory | grep mem_fragmentation_ratio\n</code></pre>\n<p>​<em>碎片率判断标准</em>​：</p>\n<ul>\n<li>​<strong>理想状态</strong>​（1.0-1.5）：内存分配紧凑，无显著碎片</li>\n<li>​<strong>需关注</strong>​（1.5-2.0）：存在一定碎片，考虑监控优化</li>\n<li>​<strong>问题状态</strong>​（&gt;2.0）：碎片严重，需要重启或内存优化</li>\n<li>​<strong>危险信号</strong>​（&lt;1.0）：内存交换到磁盘，性能严重下降</li>\n</ul>\n<p>高碎片率通常由​<strong>频繁修改不同大小数据</strong>​、<strong>大量键过期</strong>导致。解决方案包括重启实例、使用 <code>MEMORY PURGE</code>（需 Jemalloc）或优化数据访问模式。</p>\n<h2 id=\"3-容量预警指标体系\">3 容量预警指标体系</h2>\n<h3 id=\"31-内存容量规划与预警\">3.1 内存容量规划与预警</h3>\n<p>内存是 Redis 最关键的资源，需建立多级预警机制：</p>\n<p>​<strong>内存使用率预警阈值</strong>​：</p>\n<table>\n<thead>\n<tr>\n<th>使用率</th>\n<th>告警级别</th>\n<th>处理动作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>≤70%</td>\n<td>正常</td>\n<td>持续监控</td>\n</tr>\n<tr>\n<td>70%-85%</td>\n<td>警告</td>\n<td>检查大 Key，优化数据</td>\n</tr>\n<tr>\n<td>85%-95%</td>\n<td>严重</td>\n<td>准备扩容，优化过期策略</td>\n</tr>\n<tr>\n<td>≥95%</td>\n<td>紧急</td>\n<td>立即扩容，可能已拒绝写入</td>\n</tr>\n</tbody>\n</table>\n<pre><code># 监控内存使用情况\nredis-cli info memory\nused_memory: 1000000       # Redis分配内存总量\nused_memory_rss: 1500000   # 操作系统视角内存占用\nused_memory_peak: 1200000  # 历史峰值内存\nmaxmemory: 2000000        # 最大内存限制\n</code></pre>\n<p><em>基于的内存监控指标</em></p>\n<p>​<strong>内存优化策略</strong>​：</p>\n<ul>\n<li>​<strong>数据分片</strong>​：将大数据集分布到多个实例</li>\n<li>​<strong>压缩存储</strong>​：对适合数据启用压缩</li>\n<li>​<strong>过期策略</strong>​：设置合理的 TTL 和淘汰策略</li>\n</ul>\n<h3 id=\"32-连接数容量管理\">3.2 连接数容量管理</h3>\n<p>连接数超限会导致新连接被拒绝，监控 <code>connected_clients</code> 并设置合理阈值至关重要：</p>\n<p>​<strong>连接数监控要点</strong>​：</p>\n<pre><code># 查看连接数信息\nredis-cli info clients\nconnected_clients: 100        # 当前连接数\nmaxclients: 10000            # 最大连接数限制\nblocked_clients: 0           # 阻塞连接数\n</code></pre>\n<p><em>基于的连接数监控</em></p>\n<p>​<strong>连接数预警阈值</strong>​：</p>\n<ul>\n<li>​<strong>正常</strong>​：&lt;80% maxclients</li>\n<li>​<strong>警告</strong>​：80%-95% maxclients</li>\n<li>​<strong>紧急</strong>​：&gt;95% maxclients 或出现 <code>rejected_connections</code></li>\n</ul>\n<p>连接数突增通常由​<strong>连接池配置错误</strong>​、<strong>客户端未正确关闭连接</strong>或<strong>慢查询阻塞</strong>导致。应监控 <code>blocked_clients</code> 了解阻塞命令情况。</p>\n<h3 id=\"33-网络带宽与吞吐量监控\">3.3 网络带宽与吞吐量监控</h3>\n<p>网络带宽影响 Redis 吞吐能力，需监控网络输入输出：</p>\n<p>​<strong>关键网络指标</strong>​：</p>\n<ul>\n<li>​<strong>instantaneous_input_kbps</strong>​：瞬时输入带宽</li>\n<li>​<strong>instantaneous_output_kbps</strong>​：瞬时输出带宽</li>\n<li>​<strong>total_net_input_bytes</strong>​：累计输入流量</li>\n<li>​<strong>total_net_output_bytes</strong>​：累计输出流量</li>\n</ul>\n<p>千兆网卡理论极限约 125MB/s，当网络吞吐接近极限时需考虑分片或升级网络。</p>\n<h2 id=\"4-慢查询分析与优化\">4 慢查询分析与优化</h2>\n<h3 id=\"41-慢查询诊断框架\">4.1 慢查询诊断框架</h3>\n<p>慢查询是 Redis 性能的常见瓶颈，通过慢日志功能识别：</p>\n<p>​<strong>慢查询配置与查看</strong>​：</p>\n<pre><code># 设置慢查询阈值（微秒）\nCONFIG SET slowlog-log-slower-than 10000\n\n# 设置慢查询日志长度\nCONFIG SET slowlog-max-len 128\n\n# 查看慢查询\nSLOWLOG GET 10\n</code></pre>\n<p><em>基于的慢查询配置</em></p>\n<p>​<strong>慢查询分析维度</strong>​：</p>\n<ol>\n<li>​<strong>命令类型</strong>​：识别耗时最高的命令模式</li>\n<li>​<strong>执行时间</strong>​：分析命令执行时间分布</li>\n<li>​<strong>发生频率</strong>​：统计慢查询发生频率</li>\n<li>​<strong>时间规律</strong>​：寻找慢查询的时间规律</li>\n</ol>\n<h3 id=\"42-常见慢查询场景与解决方案\">4.2 常见慢查询场景与解决方案</h3>\n<p>​<strong>大 Key 操作</strong>​：拆分超过 10KB 的 String 或元素超 1000 的集合</p>\n<p>​<strong>复杂运算</strong>​：避免在 Redis 内执行 O(N)复杂度的操作</p>\n<p>​<strong>阻塞命令</strong>​：谨慎使用 BLPOP、BRPOP 等阻塞命令</p>\n<p>优化方案包括​<strong>数据分片</strong>​、<strong>管道化操作</strong>减少网络往返，<strong>Lua 脚本优化</strong>将多个操作合并。</p>\n<h2 id=\"5-持久化与复制监控\">5 持久化与复制监控</h2>\n<h3 id=\"51-持久化健康度检查\">5.1 持久化健康度检查</h3>\n<p>持久化影响数据安全，需关注关键指标：</p>\n<p>​<strong>RDB 持久化监控</strong>​：</p>\n<pre><code># 检查RDB状态\nredis-cli info persistence\nrdb_last_bgsave_status:ok    # 上次bgsave状态\nrdb_last_bgsave_time_sec:2    # 上次bgsave耗时\nlatest_fork_usec:500          # 最近fork耗时(微秒)\n</code></pre>\n<p><em>基于的持久化监控</em></p>\n<p>​<strong>AOF 持久化监控</strong>​：</p>\n<ul>\n<li>​<strong>aof_last_bgrewrite_status</strong>​：AOF 重写状态</li>\n<li>​<strong>aof_current_size</strong>​：AOF 当前大小</li>\n<li>​<strong>aof_base_size</strong>​：AOF 基础大小</li>\n</ul>\n<p>持久化故障预警点包括 bgsave 失败、fork 耗时过长（&gt;1 秒）、AOF 重写异常等。</p>\n<h3 id=\"52-主从复制健康监控\">5.2 主从复制健康监控</h3>\n<p>复制延迟可能导致数据不一致，需密切监控：</p>\n<p>​<strong>复制状态监控</strong>​：</p>\n<pre><code># 查看复制信息\nredis-cli info replication\nrole:master                    # 实例角色\nmaster_repl_offset:1000       # 主节点复制偏移量\nslave_repl_offset:980         # 从节点复制偏移量\nreplica_backlog_histlen:100   # 复制积压缓冲区长度\n</code></pre>\n<p><em>基于的复制监控</em></p>\n<p>​<strong>复制延迟计算与告警</strong>​：</p>\n<pre><code>// 计算复制延迟\npublic long getReplicationLag(String masterHost, int masterPort) {\n    long masterOffset = getMasterOffset(masterHost, masterPort);\n    long slaveOffset = getSlaveOffset();\n    return masterOffset - slaveOffset;  // 延迟偏移量\n}\n</code></pre>\n<p><em>基于的复制延迟计算</em></p>\n<p>复制延迟告警阈值建议：​<strong>警告</strong>​&gt;10MB，​<strong>严重</strong>​&gt;100MB，​<strong>紧急</strong>​&gt;1GB（可能触发全量同步）。</p>\n<h2 id=\"6-监控系统实战部署\">6 监控系统实战部署</h2>\n<h3 id=\"61-prometheus--grafana-监控栈\">6.1 Prometheus + Grafana 监控栈</h3>\n<p>现代监控推荐使用 Prometheus 采集数据，Grafana 展示：</p>\n<p>​<strong>部署 Redis Exporter</strong>​：</p>\n<pre><code># docker-compose.yml示例\nservices:\n  redis-exporter:\n    image: oliver006/redis_exporter\n    ports:\n      - \"9121:9121\"\n    environment:\n      - REDIS_ADDR=redis://redis:6379\n</code></pre>\n<p><em>基于的 Exporter 部署</em></p>\n<p>​<strong>Prometheus 配置</strong>​：</p>\n<pre><code>scrape_configs:\n  - job_name: 'redis'\n    static_configs:\n      - targets: ['redis-exporter:9121']\n    scrape_interval: 15s\n</code></pre>\n<p><em>基于的 Prometheus 配置</em></p>\n<h3 id=\"62-关键告警规则配置\">6.2 关键告警规则配置</h3>\n<p>基于 Prometheus 的告警规则示例：</p>\n<pre><code>groups:\n- name: redis.rules\n  rules:\n  - alert: RedisDown\n    expr: up{job=\"redis\"} == 0\n    for: 1m\n    labels:\n      severity: critical\n    annotations:\n      summary: \"Redis实例下线\"\n      \n  - alert: RedisMemoryUsageHigh\n    expr: (redis_memory_used_bytes / redis_memory_max_bytes) * 100 &gt; 85\n    for: 2m\n    labels:\n      severity: warning\n    annotations:\n      summary: \"Redis内存使用率过高\"\n      \n  - alert: RedisHitRateLow\n    expr: (rate(redis_keyspace_hits_total[5m]) / (rate(redis_keyspace_hits_total[5m]) + rate(redis_keyspace_misses_total[5m]))) * 100 &lt; 90\n    for: 5m\n    labels:\n      severity: warning\n    annotations:\n      summary: \"Redis缓存命中率过低\"\n</code></pre>\n<p><em>基于的告警规则</em></p>\n<h2 id=\"7-容量规划与预警实战\">7 容量规划与预警实战</h2>\n<h3 id=\"71-容量规划方法论\">7.1 容量规划方法论</h3>\n<p>有效的容量规划基于历史数据趋势分析，需考虑以下因素：</p>\n<p>​<strong>数据增长趋势</strong>​：分析日常数据增量，预测未来容量需求</p>\n<p>​<strong>业务增长预期</strong>​：结合业务规划，预估访问量增长</p>\n<p>​<strong>季节性波动</strong>​：识别业务高峰期，预留足够缓冲容量</p>\n<p>容量规划公式示例：</p>\n<pre><code>所需容量 = 当前数据量 × (1 + 月增长率)^月份 + 安全余量(20%)\n</code></pre>\n<h3 id=\"72-预警等级与响应机制\">7.2 预警等级与响应机制</h3>\n<p>建立多级预警机制，确保及时响应：</p>\n<p>​<strong>三级预警体系</strong>​：</p>\n<ul>\n<li>​<strong>黄色预警</strong>​（使用率 &gt;80%）：监控关注，每周回顾</li>\n<li>​<strong>橙色预警</strong>​（使用率 &gt;90%）：立即分析，3 天内处理</li>\n<li>​<strong>红色预警</strong>​（使用率 &gt;95%）：紧急处理，立即扩容</li>\n</ul>\n<h2 id=\"总结\">总结</h2>\n<p>Redis 监控不是简单的数据收集，而是通过关键指标洞察系统状态的艺术。有效的监控体系应聚焦<strong>延迟、命中率、内存碎片、慢查询</strong>等核心指标，建立<strong>多级预警</strong>机制，实现从被动救火到主动预防的转变。</p>\n<p>监控的价值不仅在于实时告警，更在于提供<strong>容量规划</strong>的数据支撑和<strong>性能优化</strong>的决策依据。通过完善的监控体系，Redis 运维团队能够提前发现潜在风险，优化资源配置，确保缓存系统持续稳定运行。</p>\n<p><strong>监控的终极目标不是收集数据，而是通过数据驱动决策，将问题消灭在发生之前。</strong></p>\n<hr>\n<p><strong>📚 下篇预告</strong>​</p>\n<p>《MQ 选型框架——Kafka/RabbitMQ/RocketMQ 的模型差异与业务匹配清单》—— 我们将深入探讨：</p>\n<ul>\n<li>📨 ​<strong>消息模型对比</strong>​：发布-订阅、点对点、事务消息的适用场景分析</li>\n<li>🚀 ​<strong>吞吐性能基准</strong>​：百万级消息吞吐的架构设计与优化策略</li>\n<li>💾 ​<strong>可靠性保障</strong>​：消息持久化、副本同步与故障恢复机制</li>\n<li>📊 ​<strong>运维复杂度评估</strong>​：集群管理、监控告警与扩展性对比</li>\n<li>🎯 ​<strong>选型决策矩阵</strong>​：不同业务场景下的技术选型标准指南</li>\n</ul>\n<p><strong>​点击关注，掌握消息中间件选型的核心方法论！​</strong>​</p>\n<blockquote>\n<p>​<strong>今日行动建议</strong>​：</p>\n<ol>\n<li>检查现有 Redis 监控覆盖度，确保关键指标无遗漏</li>\n<li>配置多级预警阈值，建立预警响应流程</li>\n<li>分析历史容量数据，制定未来 3-6 个月扩容规划</li>\n<li>建立慢查询定期分析机制，持续优化性能瓶颈</li>\n</ol>\n</blockquote>\n\n</div>\n<div id=\"MySignature\" role=\"contentinfo\">\n    进阶之路，神挡杀神佛挡杀佛，欢迎大家一起加ＱＱ群共同讨论成长，群号：<a href=\"https://jq.qq.com/?_wv=1027&amp;k=4AiobC0\" target=\"view_window\">620095084</a>\n<br>\n欢迎搜索关注微信公众号 基础全知道 ：JavaBasis ，第一时间阅读最新文章\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\" data-last-update-days=\"0\" data-date-updated=\"2025-12-21 17:12\">2025-12-21 17:11</span>&nbsp;\n<a href=\"https://www.cnblogs.com/shiyuelp\">十月南城</a>&nbsp;\n阅读(<span id=\"post_view_count\">66</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19379565);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19379565', targetLink: 'https://www.cnblogs.com/shiyuelp/p/19379565', title: '监控指标与容量预警——延迟、命中率、慢查询与内存碎片的解读方法' })\">举报</a>\n</div>","guid":{"value":"9d3a4391e67d78bade089bd0be5d857c"}}]}