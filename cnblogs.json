{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "Flink源码阅读：Checkpoint机制（上）",
      "link": "https://www.cnblogs.com/Jackeyzhe/p/19401432",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Jackeyzhe/p/19401432\" id=\"cb_post_title_url\" title=\"发布于 2025-12-25 22:33\">\n    <span>Flink源码阅读：Checkpoint机制（上）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"Flink源码阅读：Checkpoint机制（上）\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/1828322/202512/1828322-20251225223307613-283439473.png\" />\n        前文我们梳理了 Flink 状态管理相关的源码，我们知道，状态是要与 Checkpoint 配合使用的。因此，本文我们就一起来看一下 Checkpoint 相关的源码。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>前文我们梳理了 Flink 状态管理相关的源码，我们知道，状态是要与 Checkpoint 配合使用的。因此，本文我们就一起来看一下 Checkpoint 相关的源码。</p>\n<h3 id=\"写在前面\">写在前面</h3>\n<p>在<a href=\"https://jackeyzhe.github.io/2025/08/17/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A6%82%E4%BD%95%E5%81%9A%E5%AE%B9%E9%94%99/\" rel=\"noopener nofollow\" target=\"_blank\">Flink学习笔记：如何做容错</a>一文中，我们介绍了 Flink 的 Checkpoint 机制。Checkpoint 分为 EXACTLY_ONCE 和 AT_LEAST_ONCE 两种模式。</p>\n<p>我们一起回顾一下一次完整的 Checkpoint 具体流程：Checkpoint 是由 CheckpointCoordinator 触发，Source 节点收到触发请求后，会将 State 进行持久化，同时向下游发送 Barrier 消息，下游节点收到 Barrier 消息后，也同样对 State 进行持久化和发送 Barrier 消息。当所有节点都完成持久化过程后 CheckpointCoordinator 会将一些元数据进行持久化。</p>\n<p>带着这些背景知识，我们再来梳理一下 Checkpoint 相关的代码。</p>\n<h3 id=\"jobmanager-端触发流程\">JobManager 端触发流程</h3>\n<p>JobManager 在调用 <code>DefaultExecutionGraphBuilder.buildGraph</code> 生成 ExecutionGraph 之后，会调用 <code>executionGraph.enableCheckpointing</code> 方法来设置 Checkpoint 相关的配置，这个方法中创建了 CheckpointCoordinator 并注册了 CheckpointCoordinatorDeActivator 这个监听，它负责启动和停止 Checkpoint 的调度。</p>\n<p>当作业变成 RUNNING 状态时，CheckpointCoordinator 会部署一个定时任务 ScheduledTrigger，这个定时任务就是用来周期性的触发 Checkpoint。</p>\n<p>触发 Checkpoint 的核心逻辑在 <code>CheckpointCoordinator.startTriggeringCheckpoint</code> 这个方法中。这个方法中使用了多个 CompletableFuture 来完成整个流程的编排。具体流程见下图（图中不同颜色代表着使用不同线程池执行）。</p>\n<p><img alt=\"checkpoint\" class=\"lazyload\" /></p>\n<ul>\n<li>\n<p>checkpointPlanFuture：这是生成 Checkpoint 执行计划的 Future，Checkpoint Plan 中维护了三个关键的集合：tasksToTrigger、tasksToWaitFor 和 tasksToCommitTo。tasksToTrigger 是所有的 Source 节点，表示触发 Checkpoint 的节点，另外两个集合都包含了全部节点，分别表示等待进行 Checkpoint 的节点和等待提交的节点。</p>\n</li>\n<li>\n<p>pendingCheckpointCompletableFuture：生成完 Checkpoint Plan 之后，会创建 pendingCheckpointCompletableFuture，这个 Future 中有两个执行任务，分别是生成自增的 CheckpointID 和 创建 PendingCheckpoint。PendingCheckpoint 中维护了等待完成的 task 列表，当所有 task 都确认完成之后，PendingCheckpoint 会变成 CompletedCheckpoint。</p>\n</li>\n<li>\n<p>coordinatorCheckpointsComplete：这个 Future 也有两个任务，第一个是初始化存储路径，第二个是触发所有 OperatorCoordinator Checkpoint，并确认它们的状态。</p>\n</li>\n<li>\n<p>masterStatesComplete：触发快照所有的 Master Hook，这一步主要是 CheckpointCoordinator 用来收集 JobManager 级别状态。</p>\n</li>\n<li>\n<p>masterTriggerCompletionPromise：在 masterStatesComplete 和 coordinatorCheckpointsComplete 都执行完成后，会开始执行 masterTriggerCompletionPromise。masterTriggerCompletionPromise 的任务是调用 triggerCheckpointRequest 来产生 Barrier 消息。具体的触发流程见下图。</p>\n</li>\n</ul>\n<p><img alt=\"triggerTask\" class=\"lazyload\" /></p>\n<p>至此，JobManager 端的触发流程就完成了，接下来就到了 TaskManager 端了。</p>\n<h3 id=\"taskmanager-端执行流程\">TaskManager 端执行流程</h3>\n<p>进入 TaskExecutor 后，具体调用过程如下图。</p>\n<p><img alt=\"TaskManagerCheckpoint\" class=\"lazyload\" /></p>\n<p>TaskManager 的核心逻辑在 <code>SubtaskCheckpointCoordinatorImpl.checkpointState</code> 方法中。这个方法中的注释也很详细，整体上分为6个步骤：</p>\n<ol start=\"0\">\n<li>\n<p>判断是否是需要终止的 Checkpoint，如果是，则向下游发送取消 Checkpoint 的广播消息。</p>\n</li>\n<li>\n<p>做一些前置的准备工作，这一步通常情况下是一个空实现。</p>\n</li>\n<li>\n<p>向下游发送 Barrier 消息。</p>\n</li>\n<li>\n<p>注册 Alignment timer，当 aligned 超时时，转换为 unaligned。</p>\n</li>\n<li>\n<p>通知 StateWriter，当前 Subtask 对输出通道的写入已经完成，并提交状态句柄。</p>\n</li>\n<li>\n<p>异步执行状态写入并完成上报。</p>\n</li>\n</ol>\n<p>下面我们来关注几个重点的步骤。</p>\n<h4 id=\"barrier-消息\">Barrier 消息</h4>\n<p>在步骤2中，首先是创建 Barrier，Barrier 消息包括三个部分</p>\n<pre><code class=\"language-java\">// checkpointId\nprivate final long id;\n// 时间戳\nprivate final long timestamp;\n// checkpoint 相关参数，包括对齐类型、checkpoint 类型、目前地址\nprivate final CheckpointOptions checkpointOptions;\n</code></pre>\n<p>生成 Barrier 之后，会调用 <code>operatorChain.broadcastEvent</code> 进行广播消息。这里广播消息就是向下游所有的节点的所有 ResultSubpartition 发送。</p>\n<h4 id=\"状态写入\">状态写入</h4>\n<p><code>SubtaskCheckpointCoordinatorImpl.takeSnapshotSync</code> 方法用来构建 OperatorSnapshotFutures 中的四个 Future，每个 Future 的任务是为不同类型的 State 提供写入逻辑。</p>\n<pre><code class=\"language-java\">@Nonnull private RunnableFuture&lt;SnapshotResult&lt;KeyedStateHandle&gt;&gt; keyedStateManagedFuture;\n\n@Nonnull private RunnableFuture&lt;SnapshotResult&lt;KeyedStateHandle&gt;&gt; keyedStateRawFuture;\n\n@Nonnull private RunnableFuture&lt;SnapshotResult&lt;OperatorStateHandle&gt;&gt; operatorStateManagedFuture;\n\n@Nonnull private RunnableFuture&lt;SnapshotResult&lt;OperatorStateHandle&gt;&gt; operatorStateRawFuture;\n</code></pre>\n<p>在底层逻辑中，会为每个 Operator 设置对应的 State 的 Future。具体调用流程如下</p>\n<p><img alt=\"snapshotState\" class=\"lazyload\" /></p>\n<p>设置好这些 Future 之后，会在 <code>finishAndReportAsync</code> 方法中创建 AsyncCheckpointRunnable 线程调用 get 来获取执行结果，拿到执行结果后会将 Checkpoint 信息上报给 CheckpointCoordinator。</p>\n<p><img alt=\"TaskManagerReport\" class=\"lazyload\" /></p>\n<h3 id=\"jobmanager-端确认流程\">JobManager 端确认流程</h3>\n<p>TaskManager 通过调用 <code>checkpointCoordinatorGateway.acknowledgeCheckpoint</code> 上报 Checkpoint 信息后，流程就又回到 JobManager 了。</p>\n<p>JobManager 的确认流程主要做了两件事：</p>\n<ol>\n<li>\n<p>将 pendingCheckpoint 转换成 completedCheckpoint，在这个转换过程中，还做了清理过期 Checkpoint 和持久化元数据等操作。</p>\n</li>\n<li>\n<p>向所有 commit 的 Task 发送 Checkpoint 完成的通知。收到这个通知后，大部分 Task 没有什么特殊逻辑，也有一部分 Source 或者 Sink 会做提交事务等操作。</p>\n</li>\n</ol>\n<p>至此，JobManager 和 Source 端算子的一次 Checkpoint 就完成了。接下来我们再看一下非 Source 节点是如何做 Checkpoint 的。</p>\n<h3 id=\"非-source-节点处理流程\">非 Source 节点处理流程</h3>\n<p>非 Source 节点处理 Barrier 的入口和处理业务数据的入口相同，都是 <code>StreamTask.processInput</code> 方法。我们还是先来看具体的调用流程。</p>\n<p><img alt=\"processBarrier\" class=\"lazyload\" /></p>\n<p>跟着调用链路，我们一路找到了 processBarrier 方法，这里区分了两个 barrierHandler。SingleCheckpointBarrierHandler 负责处理 EXACTLY_ONCE 语义，CheckpointBarrierTracker 负责处理 AT_LEAST_ONCE 语义。</p>\n<h4 id=\"exactly_once\">EXACTLY_ONCE</h4>\n<p>EXACTLY_ONCE 在处理 Barrier 的逻辑如下：</p>\n<ol>\n<li>\n<p>如果只有一个 channel，就立即触发 Checkpoint。</p>\n</li>\n<li>\n<p>如果有多个 channel，分为三种情况</p>\n</li>\n</ol>\n<p>a) 如果收到的是第一个 channel，标记开始进行 barrier 对齐，并阻塞 channel。</p>\n<p>b) 如果不是第一个 channel，也不是最后一个 channel，只对 channel 进行阻塞。</p>\n<p>c) 如果收到最后一个 channel，就会触发 Checkpoint，并取消所有 channel 阻塞状态。</p>\n<p>这里触发的逻辑与 Source 节点相同，通过调用链路可以一直找到 performCheckpoint。</p>\n<h4 id=\"at_least_once\">AT_LEAST_ONCE</h4>\n<p>AT_LEAST_ONCE 处理 Barrier 的逻辑如下：</p>\n<ol>\n<li>\n<p>如果只有一个 channel，就立即触发 Checkpoint。</p>\n</li>\n<li>\n<p>如果有多个 channel，同样分为三种情况</p>\n</li>\n</ol>\n<p>a) 如果收到的是第一个 channel，则更新当前 checkpointID，标记开始 barrier 对齐。</p>\n<p>b) 如果收到的不是第一个 channel，也不是最后一个 channel，就只做计数。</p>\n<p>c) 如果收到的是最后一个 channel，就会开始触发 Checkpoint。</p>\n<p>这里触发逻辑也是调用 performCheckpoint，与 Source 节点逻辑相同。</p>\n<h3 id=\"总结\">总结</h3>\n<p>本文我们梳理了 Checkpoint 的源码逻辑。最开始由 JobManager 中的 CheckpointCoordinator 进行调度，并向 TaskManager 发送触发请求。Source 节点收到请求后会向下游发送 Barrier 消息然后写入状态数据和上报 Checkpoint 信息。CheckpointCoordinator 收集完确认消息后，会持久化元数据并通知所有 Task 完成 commit。最后还分别介绍了 EXACTLY_ONCE 和 AT_LEAST_ONCE 模式下非 Source 节点的处理逻辑。</p>\n<p>这里埋一个 Hook，状态数据写入逻辑的细节我们没有深入了解，会在下篇进行深入分析。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-25 22:33</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Jackeyzhe\">Jackeyzhe</a>&nbsp;\n阅读(<span id=\"post_view_count\">6</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "客服系统前端主题配色动态切换的一种实现思路（含代码）",
      "link": "https://www.cnblogs.com/sheng_chao/p/19401028",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sheng_chao/p/19401028\" id=\"cb_post_title_url\" title=\"发布于 2025-12-25 20:29\">\n    <span>客服系统前端主题配色动态切换的一种实现思路（含代码）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        前些天，一个老用户联系我，希望访客端的主题颜色能够与他们的 APP 相适配。对于这么合理的诉求，那必须满足！！😊\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>熟悉我的朋友都知道，我是升讯威客服系统的作者，一个独立开发者，常年致力于在线客服系统的开发和服务。现在我的一大乐趣之一，就是与许多用户沟通交流他们的使用反馈和诉求，对于一个程序员来说，这是非常有正反馈的一件事情。</p>\n<h1 id=\"讲故事\">讲故事：</h1>\n<p>前些天，一个老用户联系我，希望访客端的主题颜色能够与他们的 APP 相适配。对于这么合理的诉求，那必须满足！！😊</p>\n<p><img alt=\"主题颜色2\" src=\"https://img2024.cnblogs.com/blog/78019/202512/78019-20251225195041335-1148579844.jpg\" /></p>\n<hr />\n<h1 id=\"看疗效\">看疗效</h1>\n<p>完成的效果，允许在管理后台随时切换主题（明或暗），以及在明亮主题时的配色方案：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/78019/202512/78019-20251225201101576-2129169153.png\" /></p>\n<p>切换为绿色主题配色时，访客端的显示效果：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/78019/202512/78019-20251225201030213-1798778301.png\" /></p>\n<h1 id=\"讲技术\">讲技术：</h1>\n<p>一开始看起来很简单：<br />\n不就是 Light / Dark，再加几种颜色吗？<br />\n但真正在一个<strong>长期维护、多人使用、可扩展</strong>的系统里做过之后，往往会发现这是一个<strong>典型的“前期随意、后期返工”的功能点</strong>。</p>\n<p>这篇文章记录一种我在实际项目中使用的主题切换实现方式，思路偏工程化，代码也尽量保持简洁。</p>\n<h2 id=\"一为什么主题切换不是一个小功能\">一、为什么主题切换不是一个“小功能”</h2>\n<p>在很多前端项目的早期阶段，主题配色往往被当作一个“装饰性需求”。</p>\n<p>常见的认知是：</p>\n<ul>\n<li>不影响核心业务</li>\n<li>不是功能逻辑</li>\n<li>以后有时间再优化</li>\n</ul>\n<p>于是实现方式通常也很随意：<br />\n写几行 CSS，或者复制一份样式文件，先跑起来再说。</p>\n<p>但在<strong>客服系统、后台系统、SaaS 产品</strong>这类长期运行、持续演进的软件中，主题切换几乎都会在某个时间点暴露出问题，而且往往是<strong>成体系的问题</strong>。</p>\n<h3 id=\"1-多数系统不是只有一个用户\">1. 多数系统不是“只有一个用户”</h3>\n<p>以客服系统为例，它往往具备以下特征：</p>\n<ul>\n<li>服务多个商户 / 团队</li>\n<li>每个商户有自己的品牌色</li>\n<li>用户长时间在线使用</li>\n<li>页面复杂、组件数量多</li>\n</ul>\n<p>这意味着：<br />\n<strong>主题不是一个“页面级”的需求，而是“系统级”的能力。</strong></p>\n<p>一旦早期设计时没有把主题当成系统能力，后期基本都会面临以下情况：</p>\n<ul>\n<li>新主题 = 新一套 CSS</li>\n<li>修改一个颜色 = 改几十个地方</li>\n<li>每加一个页面，就多一次不一致风险</li>\n</ul>\n<h3 id=\"2-暗色模式不是换个背景色那么简单\">2. 暗色模式不是“换个背景色”那么简单</h3>\n<p>很多人第一次做暗色模式时，都会低估它的复杂度。</p>\n<p>常见的误区包括：</p>\n<ul>\n<li>只反转背景色和文字色</li>\n<li>直接套设计稿里的深色值</li>\n<li>忽略对比度和可读性</li>\n</ul>\n<p>但在实际使用中，暗色模式涉及的问题远不止这些：</p>\n<ul>\n<li>不同层级的背景如何区分</li>\n<li>禁用态、hover 态是否仍然清晰</li>\n<li>主色在暗背景下是否刺眼</li>\n<li>第三方组件是否“违和”</li>\n</ul>\n<p>如果主题系统本身不具备良好的抽象能力，那么暗色模式往往会演变成：</p>\n<blockquote>\n<p>“为了适配暗色，又加了一堆 if 和 hack。”</p>\n</blockquote>\n<h3 id=\"3-主题一旦写死返工成本极高\">3. 主题一旦“写死”，返工成本极高</h3>\n<p>主题相关代码有一个明显特征：</p>\n<blockquote>\n<p><strong>它分散在几乎所有组件中。</strong></p>\n</blockquote>\n<p>这也意味着：</p>\n<ul>\n<li>它不是一个可以轻易整体替换的模块</li>\n<li>它的设计质量，直接影响未来几年维护成本</li>\n</ul>\n<p>很多项目在后期想要“重构主题系统”时，会发现：</p>\n<ul>\n<li>已经无法明确哪些颜色是“主色”</li>\n<li>不同页面对同一颜色的理解不一致</li>\n<li>没人敢动，怕一动就全乱</li>\n</ul>\n<p>最终结果往往是：<br />\n<strong>继续在不合理的结构上打补丁。</strong></p>\n<h3 id=\"4-saas-产品里主题往往会超出最初设想\">4. SaaS 产品里，主题往往会“超出最初设想”</h3>\n<p>在实际产品演进中，主题需求很容易出现扩散：</p>\n<ul>\n<li>一开始只要 Light / Dark</li>\n<li>后来要支持品牌色</li>\n<li>再后来要支持商户自定义</li>\n<li>最后甚至要求运行时动态下发</li>\n</ul>\n<p>如果一开始的实现方式是“面向当前需求”的，那么每一次扩展都会变得异常痛苦。</p>\n<p>而反过来，如果主题系统的抽象足够合理：</p>\n<ul>\n<li>新主题只是新增一组配置</li>\n<li>现有组件无需修改</li>\n<li>切换逻辑保持稳定</li>\n</ul>\n<p>这类需求反而会变得<strong>非常可控</strong>。</p>\n<h3 id=\"5-本质问题主题是否被当成一等公民\">5. 本质问题：主题是否被当成“一等公民”</h3>\n<p>回过头看，主题切换之所以容易出问题，并不是技术难度高，而是因为它在系统设计中经常被：</p>\n<ul>\n<li>当作样式细节</li>\n<li>当作 UI 美化</li>\n<li>当作“以后再说”的事情</li>\n</ul>\n<p>但在长期维护的软件里，它更接近于：</p>\n<blockquote>\n<p><strong>权限、国际化、配置系统这一层级的基础能力。</strong></p>\n</blockquote>\n<p>一旦你接受了这一点，就会自然地意识到：</p>\n<ul>\n<li>它需要清晰的设计思路</li>\n<li>它需要可扩展的结构</li>\n<li>它需要尽量低的侵入性</li>\n</ul>\n<p>这也是后面会采用 <strong>CSS 变量 + 根节点切换</strong> 这种方案的根本原因。</p>\n<hr />\n<h2 id=\"二需求拆解一个可用的主题切换至少要满足什么\">二、需求拆解：一个“可用”的主题切换至少要满足什么</h2>\n<p>在真正动手实现主题切换之前，有一个很关键但经常被忽略的步骤：<br />\n<strong>先明确什么叫“可用”。</strong></p>\n<p>如果只是为了展示效果，那么主题切换可以非常简单；<br />\n但如果目标是一个<strong>会被真实用户长期使用的系统</strong>，那么需求本身就必须被拆解清楚。</p>\n<p>下面是我在实际项目中，对“可用主题切换”的最低要求。</p>\n<h3 id=\"1-主题切换必须是即时且无感知的\">1. 主题切换必须是“即时且无感知”的</h3>\n<p>对用户来说，主题切换的期望非常直接：</p>\n<ul>\n<li>点击即生效</li>\n<li>页面不刷新</li>\n<li>不影响当前操作</li>\n</ul>\n<p>任何以下情况，都会被认为体验不佳：</p>\n<ul>\n<li>切换主题后页面闪白</li>\n<li>状态被重置</li>\n<li>列表重新加载</li>\n</ul>\n<p>这意味着：</p>\n<ul>\n<li>主题切换不应该依赖页面重载</li>\n<li>不应该触发组件重新初始化</li>\n<li>不应该侵入业务状态管理</li>\n</ul>\n<p>从需求层面就可以得出结论：<br />\n<strong>主题切换必须是纯“表现层”的行为。</strong></p>\n<h3 id=\"2-主题必须支持模式--变体的组合\">2. 主题必须支持“模式 + 变体”的组合</h3>\n<p>在多数系统中，主题并不是一个简单的枚举值。</p>\n<p>一个更贴近现实的模型通常是：</p>\n<ul>\n<li>\n<p><strong>主题模式（Theme Mode）</strong></p>\n<ul>\n<li>Light</li>\n<li>Dark</li>\n</ul>\n</li>\n<li>\n<p><strong>主题颜色（Theme Color）</strong></p>\n<ul>\n<li>蓝</li>\n<li>红</li>\n<li>黄</li>\n<li>……</li>\n</ul>\n</li>\n</ul>\n<p>也就是说，用户真正选择的往往是：</p>\n<blockquote>\n<p>Light + Blue<br />\nLight + Red<br />\nDark（可能只有一种）</p>\n</blockquote>\n<p>如果在设计时把主题当成单一维度，那么后期扩展几乎必然会推翻原实现。</p>\n<p>因此在需求层面，就需要明确：</p>\n<ul>\n<li>模式与颜色是两个概念</li>\n<li>它们可以组合，但不完全对称</li>\n</ul>\n<h3 id=\"3-主题结构要先稳定后扩展\">3. 主题结构要“先稳定，后扩展”</h3>\n<p>一个很现实的问题是：<br />\n<strong>主题一定会变。</strong></p>\n<p>可能的变化包括：</p>\n<ul>\n<li>新增颜色主题</li>\n<li>微调主色、强调色</li>\n<li>增加辅助色、边框色、状态色</li>\n</ul>\n<p>所以在需求拆解阶段，需要问自己一个问题：</p>\n<blockquote>\n<p>如果半年后新增一个主题，我希望改哪些地方？</p>\n</blockquote>\n<p>一个“可用”的主题系统，理想状态是：</p>\n<ul>\n<li>新增主题 ≈ 新增配置</li>\n<li>不需要修改现有组件</li>\n<li>不需要理解历史代码细节</li>\n</ul>\n<p>这实际上是在要求：<br />\n<strong>主题系统必须具备良好的边界。</strong></p>\n<h3 id=\"4-主题状态需要被持久化但不应绑定过深\">4. 主题状态需要被持久化，但不应绑定过深</h3>\n<p>从用户体验角度来看，主题选择显然应该被记住：</p>\n<ul>\n<li>刷新页面后不丢失</li>\n<li>下次打开仍然生效</li>\n</ul>\n<p>但在实现层面，有一个容易踩的坑：</p>\n<ul>\n<li>把主题状态深度绑定到业务状态管理中</li>\n</ul>\n<p>例如：</p>\n<ul>\n<li>Redux / Pinia / Vuex</li>\n<li>和用户权限、语言混在一起</li>\n</ul>\n<p>这种做法的风险在于：</p>\n<ul>\n<li>主题逻辑被迫参与复杂状态流转</li>\n<li>后期维护成本急剧上升</li>\n</ul>\n<p>因此更合理的需求结论是：</p>\n<ul>\n<li>主题状态可以持久化</li>\n<li>但实现应尽量“轻量、独立”</li>\n</ul>\n<h3 id=\"5-主题切换不能成为组件开发的负担\">5. 主题切换不能成为组件开发的负担</h3>\n<p>在一个持续演进的项目中，最忌讳的是：</p>\n<blockquote>\n<p>每写一个新组件，就要考虑“它支持多少主题”。</p>\n</blockquote>\n<p>一个健康的目标应该是：</p>\n<ul>\n<li>组件只关心“语义颜色”</li>\n<li>组件本身不知道具体主题</li>\n<li>主题切换对组件是透明的</li>\n</ul>\n<p>换句话说：</p>\n<blockquote>\n<p><strong>组件不应知道自己处在哪个主题下。</strong></p>\n</blockquote>\n<p>这是判断一个主题系统是否“可用”的关键标准之一。</p>\n<h3 id=\"6-技术实现要简单到可以被长期维护\">6. 技术实现要“简单到可以被长期维护”</h3>\n<p>最后，也是非常现实的一点：</p>\n<ul>\n<li>项目可能会换人维护</li>\n<li>自己半年后再看这段代码，也可能已经陌生</li>\n</ul>\n<p>所以在需求层面，我给主题切换设定了一个约束：</p>\n<blockquote>\n<p><strong>实现方式必须足够直观，不依赖技巧性过强的方案。</strong></p>\n</blockquote>\n<p>这会直接排除掉一些：</p>\n<ul>\n<li>过度抽象的主题引擎</li>\n<li>复杂的运行时样式计算</li>\n<li>强依赖框架内部机制的方案</li>\n</ul>\n<hr />\n<h2 id=\"三设计思路css-变量--根节点主题切换\">三、设计思路：CSS 变量 + 根节点主题切换</h2>\n<p>在明确了主题切换的需求边界之后，接下来要做的不是立刻写代码，而是回答一个更基础的问题：</p>\n<blockquote>\n<p><strong>主题到底应该“存在”在哪里？</strong></p>\n</blockquote>\n<p>是存在于组件里？<br />\n是存在于某个全局状态中？<br />\n还是存在于样式系统本身？</p>\n<p>在对比过几种常见方案之后，我最终选择了：<br />\n<strong>CSS 变量（Custom Properties）+ 根节点主题切换</strong>。</p>\n<h3 id=\"1-把主题从组件中剥离出来\">1. 把“主题”从组件中剥离出来</h3>\n<p>一个容易犯的错误是：<br />\n在组件样式中直接体现主题差异。</p>\n<p>例如：</p>\n<ul>\n<li><code>if (dark) { ... }</code></li>\n<li><code>.button-dark { ... }</code></li>\n<li><code>.theme-blue .button { ... }</code></li>\n</ul>\n<p>这种方式在早期看起来直观，但问题在于：</p>\n<ul>\n<li>组件开始“感知主题”</li>\n<li>组件逻辑与样式策略耦合</li>\n<li>主题一多，组合爆炸</li>\n</ul>\n<p>而我希望的目标是：</p>\n<blockquote>\n<p><strong>组件只描述“它需要什么颜色语义”，而不是“这个颜色在什么主题下是什么值”。</strong></p>\n</blockquote>\n<p>这正是 CSS 变量最适合承担的角色。</p>\n<h3 id=\"2-为什么-css-变量是主题系统的天然载体\">2. 为什么 CSS 变量是主题系统的天然载体</h3>\n<p>CSS 变量有几个非常适合做主题的特性：</p>\n<ul>\n<li>原生支持，浏览器层面解析</li>\n<li>可以在运行时动态修改</li>\n<li>具备作用域和继承能力</li>\n<li>不依赖任何前端框架</li>\n</ul>\n<p>这意味着：</p>\n<ul>\n<li>切换主题 ≠ 重新渲染组件</li>\n<li>主题变化对业务状态是透明的</li>\n<li>实现方式足够稳定、可预期</li>\n</ul>\n<p>尤其是在<strong>长期维护的系统</strong>中，这种“朴素但可靠”的方案，往往比技巧性更重要。</p>\n<h3 id=\"3-为什么选择根节点作为主题切换入口\">3. 为什么选择“根节点”作为主题切换入口</h3>\n<p>既然要切换主题，就必须有一个<strong>统一且稳定的切换点</strong>。</p>\n<p>相比在多个容器节点上控制样式，我更倾向于：</p>\n<ul>\n<li>使用 <code>:root</code> 或 <code>html</code> 作为主题载体</li>\n<li>通过属性或 class 标识当前主题</li>\n</ul>\n<p>例如：</p>\n<pre><code class=\"language-html\">&lt;html data-theme=\"light-blue\"&gt;\n</code></pre>\n<p>这样做的好处非常明确：</p>\n<ul>\n<li>所有组件天然继承主题变量</li>\n<li>不需要关心组件嵌套层级</li>\n<li>主题切换逻辑集中、可控</li>\n</ul>\n<p>同时，这也让“主题切换”变成了一个非常清晰的动作：</p>\n<blockquote>\n<p><strong>修改根节点的一个属性。</strong></p>\n</blockquote>\n<h3 id=\"4-主题--颜色集合而是语义映射\">4. 主题 ≠ 颜色集合，而是“语义映射”</h3>\n<p>在这个方案中，一个非常重要的设计原则是：</p>\n<blockquote>\n<p><strong>主题不是一组颜色，而是一套语义到颜色的映射关系。</strong></p>\n</blockquote>\n<p>例如：</p>\n<ul>\n<li><code>--primary-color</code>：主操作、强调</li>\n<li><code>--background-color</code>：页面背景</li>\n<li><code>--text-color</code>：主要文本</li>\n<li><code>--border-color</code>：分割与边界</li>\n</ul>\n<p>组件只使用这些语义变量，而主题负责告诉系统：</p>\n<blockquote>\n<p>在当前主题下，这些语义对应什么颜色。</p>\n</blockquote>\n<p>这样带来的直接收益是：</p>\n<ul>\n<li>新主题只需定义变量值</li>\n<li>组件代码完全无需改动</li>\n<li>不同主题之间可以高度复用结构</li>\n</ul>\n<h3 id=\"5-light--dark-与多颜色主题如何共存\">5. Light / Dark 与多颜色主题如何共存</h3>\n<p>在实际设计中，我并没有把 Light / Dark 和颜色主题混为一个维度。</p>\n<p>而是采用一种更贴近现实的思路：</p>\n<ul>\n<li><strong>Light / Dark</strong>：决定整体明暗结构</li>\n<li><strong>Color Theme</strong>：决定主色、强调色</li>\n</ul>\n<p>在 CSS 层面，可以表现为：</p>\n<ul>\n<li>Dark 主题覆盖结构性变量</li>\n<li>Color 主题只覆盖少量核心颜色</li>\n</ul>\n<p>例如：</p>\n<pre><code class=\"language-css\">:root[data-theme=\"dark\"] {\n  --background-color: #141414;\n  --text-color: #f0f0f0;\n}\n\n:root[data-theme=\"light-blue\"] {\n  --primary-color: #1677ff;\n}\n</code></pre>\n<p>这种拆分可以有效避免：</p>\n<ul>\n<li>暗色主题下颜色失控</li>\n<li>主题组合难以管理</li>\n</ul>\n<h3 id=\"6-刻意不做的事情保持方案的边界\">6. 刻意不做的事情：保持方案的边界</h3>\n<p>在这个设计中，有几件事情我是<strong>刻意不去做的</strong>：</p>\n<ul>\n<li>不在 JS 中计算颜色</li>\n<li>不引入复杂的主题配置 DSL</li>\n<li>不尝试做“万能主题引擎”</li>\n</ul>\n<p>原因很简单：</p>\n<blockquote>\n<p>主题系统的职责，是稳定地提供样式变量，而不是成为新的复杂度来源。</p>\n</blockquote>\n<p>一旦主题系统本身变得难以理解，它就已经背离了最初的目标。</p>\n<h2 id=\"四实现步骤拆解\">四、实现步骤拆解</h2>\n<p>下面用一个简化示例说明整体结构。</p>\n<h3 id=\"41-定义主题变量css\">4.1 定义主题变量（CSS）</h3>\n<p>首先，不要在组件里直接写颜色值。</p>\n<pre><code class=\"language-css\">:root {\n  --primary-color: #1677ff;\n  --background-color: #ffffff;\n  --text-color: #1f1f1f;\n}\n</code></pre>\n<p>为不同主题定义不同变量集：</p>\n<pre><code class=\"language-css\">:root[data-theme=\"light-blue\"] {\n  --primary-color: #1677ff;\n}\n\n:root[data-theme=\"light-red\"] {\n  --primary-color: #e53935;\n}\n\n:root[data-theme=\"dark\"] {\n  --background-color: #141414;\n  --text-color: #f0f0f0;\n  --primary-color: #4c8dff;\n}\n</code></pre>\n<blockquote>\n<p>⚠️ 一个经验：<br />\n<strong>变量名一定要语义化，而不是 <code>--blue-500</code> 这种设计稿命名。</strong></p>\n</blockquote>\n<h3 id=\"42-在组件中使用变量\">4.2 在组件中使用变量</h3>\n<pre><code class=\"language-css\">.button {\n  background-color: var(--primary-color);\n  color: var(--text-color);\n}\n\n这样一来，组件本身对“主题”是无感知的。\n\n\n### 4.3 主题切换逻辑（JavaScript）\n\n主题切换本质上只是修改根节点属性：\n\n```js\nfunction setTheme(theme) {\n  document.documentElement.setAttribute('data-theme', theme);\n  localStorage.setItem('theme', theme);\n}\n</code></pre>\n<p>初始化时恢复用户选择：</p>\n<pre><code class=\"language-js\">const savedTheme = localStorage.getItem('theme');\nif (savedTheme) {\n  document.documentElement.setAttribute('data-theme', savedTheme);\n}\n</code></pre>\n<p>整个过程无需刷新页面，也不会影响组件状态。</p>\n<h2 id=\"结语主题切换本质上是一次工程成熟度的考验\">结语：主题切换，本质上是一次工程成熟度的考验</h2>\n<p>回过头来看，前端主题切换这个需求本身，其实并不复杂。<br />\n没有高深的算法，也不涉及前沿技术。</p>\n<p>但它之所以在很多项目中反复“翻车”，原因往往不在技术，而在于<strong>对系统长期演进的预期不足</strong>。</p>\n<p>在文章开头提到过，主题常常被当作一个“以后再说”的问题；<br />\n但当系统真正进入稳定使用阶段后，它却会频繁出现在这些场景里：</p>\n<ul>\n<li>新客户希望使用自己的品牌色</li>\n<li>用户开始要求暗色模式</li>\n<li>页面和组件越来越多</li>\n<li>维护成本开始显性化</li>\n</ul>\n<p>这时再回头看最初的实现方式，往往已经没有太多调整空间。</p>\n<hr />\n<h3 id=\"主题问题的本质不是颜色而是结构\">主题问题的本质，不是“颜色”，而是“结构”</h3>\n<p>如果用一句话概括这篇文章的核心思想，那就是：</p>\n<blockquote>\n<p><strong>主题切换不是在管理颜色，而是在管理一套稳定的结构关系。</strong></p>\n</blockquote>\n<p>当颜色值被直接写进组件时，系统就失去了抽象层；<br />\n而当颜色被提升为“语义变量”之后，主题才真正成为一种可演进的能力。</p>\n<p>这也是为什么本文会反复强调：</p>\n<ul>\n<li>组件不应该感知主题</li>\n<li>主题不应该侵入业务逻辑</li>\n<li>主题系统本身必须足够简单</li>\n</ul>\n<hr />\n<h3 id=\"css-变量方案的价值不在新而在合适\">CSS 变量方案的价值，不在“新”，而在“合适”</h3>\n<p>CSS 变量并不是新技术，但在主题系统这个问题上，它恰好处在一个非常合适的位置：</p>\n<ul>\n<li>足够底层，稳定可靠</li>\n<li>足够灵活，支持运行时切换</li>\n<li>足够直观，维护成本低</li>\n</ul>\n<p>配合根节点主题切换的方式，可以让整个系统形成一种非常清晰的分工：</p>\n<ul>\n<li><strong>样式层</strong>负责主题变量</li>\n<li><strong>组件层</strong>只关心语义</li>\n<li><strong>逻辑层</strong>只负责切换入口</li>\n</ul>\n<p>这种结构一旦建立起来，后续无论是新增主题、对接多租户配置，还是调整视觉规范，都会变得相对从容。</p>\n<hr />\n<h3 id=\"工程实践中一个重要但不显眼的判断标准\">工程实践中，一个重要但不显眼的判断标准</h3>\n<p>在实际项目中，我逐渐形成了一个判断标准：</p>\n<blockquote>\n<p>如果一个功能在早期实现时“看起来有点啰嗦”，<br />\n但在半年后几乎不需要再动它，<br />\n那它大概率是一个正确的设计。</p>\n</blockquote>\n<p>主题切换正是这样一类功能。</p>\n<p>相比“先简单写死、以后再重构”，<br />\n<strong>一开始就建立清晰边界的方案，反而更节省整体成本。</strong></p>\n<hr />\n<h2 id=\"独立者的产品成果\">独立者的产品成果</h2>\n<blockquote>\n<p><a href=\"https://kf.shengxunwei.com\" rel=\"noopener nofollow\" target=\"_blank\">https://kf.shengxunwei.com</a></p>\n</blockquote>\n<p><strong>可全天候 7 × 24 小时挂机运行，网络中断，拔掉网线，手机飞行模式，不掉线不丢消息，欢迎实测。</strong></p>\n<h3 id=\"访客端轻量直观秒级响应的沟通入口\">访客端：轻量直观、秒级响应的沟通入口</h3>\n<p>访客端是客户接触企业的第一窗口，我们精心打磨每一处交互细节，确保用户无需任何学习成本即可发起对话。无论是嵌入式聊天窗口、悬浮按钮，还是移动端自适应支持，都实现了真正的“即点即聊”。系统支持智能欢迎语、来源识别、设备类型判断，可自动记录访客路径并呈现于客服端，帮助企业更好地理解用户意图。在性能方面，访客端采用异步加载与自动重连机制，即使网络波动也能保障消息顺畅送达，真正做到——轻量不失稳定，简单不失智能。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/78019/202506/78019-20250601110426304-100322970.png\" /></p>\n<h3 id=\"客服端软件为高效率沟通而生\">客服端软件：为高效率沟通而生</h3>\n<p>客服端是客服人员的作战平台，我们构建了一个专注、高效、响应迅速的桌面级体验。系统采用多标签会话设计，让客服可同时处理多组对话；访客轨迹、历史会话、地理位置、设备信息、来源渠道等关键信息一目了然，协助客服快速做出判断。内置快捷回复、常用文件、表情支持和智能推荐功能，大幅降低重复劳动成本。同时，系统还支持智能分配、会话转接、转人工、自定义状态等多种机制，保障团队协作流畅，让客服不仅能应对高峰，更能稳定交付满意度。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/78019/202506/78019-20250601110431346-1228494411.png\" /></p>\n<h3 id=\"web-管理后台\">Web 管理后台：</h3>\n<p>Web 管理后台是企业对客服系统的“驾驶舱”，从接入配置、坐席管理，到数据统计、权限控制，一切尽在掌握。你可以灵活设置接待策略、工作时间、转接规则，支持按部门/标签/渠道精细分配访客，满足复杂业务场景。系统还内置访问监控、聊天记录检索、客服绩效统计、错失会话提醒等运营级功能，助力管理者洞察服务瓶颈，持续优化资源配置。支持私有化部署、分权限管理、日志记录与数据导出，为追求安全性与高可控性的企业，提供真正“掌握在自己手里的客服系统”。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/78019/202506/78019-20250601110403917-63642615.png\" /></p>\n<h2 id=\"希望能够打造-开放开源共享努力打造一款优秀的社区开源产品\">希望能够打造： 开放、开源、共享。努力打造一款优秀的社区开源产品。</h2>\n<p>钟意的话请给个赞支持一下吧，谢谢~</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-25 20:29</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sheng_chao\">升讯威在线客服系统</a>&nbsp;\n阅读(<span id=\"post_view_count\">34</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "redis为什么这么快？I/O多路复用技术是什么？",
      "link": "https://www.cnblogs.com/xi-yongqi/p/19401014",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xi-yongqi/p/19401014\" id=\"cb_post_title_url\" title=\"发布于 2025-12-25 20:24\">\n    <span>redis为什么这么快？I/O多路复用技术是什么？</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h4 id=\"redis能够达到每秒10万-qps每秒查询率的极高性能并非只因为它是内存数据库而是由存储介质线程模型网络模型以及数据结构优化共同决定的\">redis能够达到每秒10万+ QPS（每秒查询率）的极高性能，并非只因为它是“内存数据库”，而是由存储介质、线程模型、网络模型以及数据结构优化共同决定的。</h4>\n<h3 id=\"以下是redis快的具体原因\">以下是redis快的具体原因：</h3>\n<h4 id=\"绝大部分请求在内存中完成\">绝大部分请求在内存中完成</h4>\n<ul>\n<li>这是 Redis 快的根本原因。相比于传统数据库（如 MySQL）需要从磁盘读取数据，Redis 直接操作RAM（内存）。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>存储介质</th>\n<th>访问速度（数量级）</th>\n<th>延迟说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>内存 (RAM)</td>\n<td>纳秒 (ns)</td>\n<td>极快，就像从书桌上拿书。</td>\n</tr>\n<tr>\n<td>固态硬盘 (SSD)</td>\n<td>微秒 (μs)</td>\n<td>较快，但比内存慢 1000 倍。</td>\n</tr>\n<tr>\n<td>机械硬盘 (HDD)</td>\n<td>毫秒 (ms)</td>\n<td>慢，就像去图书馆借书。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Redis 避免了磁盘 I/O 产生的巨大开销，数据操作几乎是瞬时的。</strong></p>\n<h4 id=\"纯粹的单线程模型\">纯粹的单线程模型</h4>\n<p>很多人误以为多线程才快，但 Redis 的核心处理逻辑是单线程的（主要指文件事件分路器处理请求的部分）。</p>\n<ul>\n<li>没有上下文切换：多线程在切换执行流时需要保存和加载 CPU 寄存器状态，这会产生明显的性能损耗。</li>\n<li>没有锁的竞争：在多线程环境下，为了保证数据安全，必须引入锁（如互斥锁）。Redis 单线程执行，天然避免了死锁和锁竞争带来的开销。</li>\n<li>简单即高效：单线程代码逻辑更简单，也更容易维护。<br />\n<strong>注意： Redis6.0引入了多线程来处理网络I/O，但执行命令的核心逻辑依然是单线程的。</strong></li>\n</ul>\n<h4 id=\"非阻塞io多路复用-io-multiplexing\">非阻塞I/O多路复用 (I/O Multiplexing)</h4>\n<p>Redis 使用了I/O多路复用技术（如 Linux 下的 epoll）来处理大量的并发连接。</p>\n<ul>\n<li>原理：Redis并不是为一个连接分配一个线程，而是让一个线程监控数千个连接的状态。只有当某个连接真正有数据发过来时，Redis才会去处理。</li>\n<li>效果：即使有成千上万个客户端同时连接，Redis 也能像一个老练的服务员同时照顾几十桌客人一样，谁叫就服务谁，而不需要在桌子之间来回空跑。</li>\n</ul>\n<h4 id=\"针对性优化的底层数据结构\">针对性优化的底层数据结构</h4>\n<p>Redis的开发者对每种数据类型都进行了极致的底层优化，并没有简单地使用编程语言内置的结构。</p>\n<ul>\n<li>SDS (简单动态字符串)：相比 C 语言原生字符串，获取长度的时间复杂度从O(N)降到了O(1)，且减少了内存分配次数。</li>\n<li>跳表 (SkipList)：为有序集合 (ZSet) 提供平衡树一般的查找效率，但实现更简单，支持范围查询更高效。</li>\n<li>压缩列表 (ZipList) / 整型数组： 在数据量较小时使用紧凑存储，极大节省了内存开销，提高了 CPU 缓存命中率。</li>\n</ul>\n<h4 id=\"总结\">总结：</h4>\n<p><strong>Redis的快可以总结为：基于内存操作 + 单线程 + 多路复用的并发 + 极致优化的底层数据结构。</strong></p>\n<hr />\n<h3 id=\"详细说一下io多路复用\">详细说一下I/O多路复用</h3>\n<h6 id=\"io多路复用io-multiplexing是现代高性能网络服务器如-nginx-redis-nodejs的核心基石简单来说它是一种--让单个线程能够同时监控多个网络连接文件描述符--的技术\">I/O多路复用（I/O Multiplexing）是现代高性能网络服务器（如 Nginx, Redis, Node.js）的核心基石。简单来说，它是一种  <strong>让单个线程能够同时监控多个网络连接（文件描述符）</strong>  的技术。</h6>\n<ul>\n<li>I/O多路复用解决了“高并发下的线程开销问题”。</li>\n<li>在没有这项技术前，我们要支撑 1 万个并发连接，可能需要启动1万个线程，这会导致内存耗尽和CPU频繁的上下文切换。</li>\n<li>有了 I/O 多路复用（尤其是 epoll），我们可以用一个线程轻松管理成千上万个连接，极大提升了系统的吞吐量。</li>\n</ul>\n<ol>\n<li>举例理解：</li>\n</ol>\n<p>假设一家餐厅有 100 桌客人：</p>\n<ul>\n<li>阻塞 I/O (Blocking I/O)： 一个服务员盯一桌客人。客人不点菜，服务员就死等。要服务 100 桌，就得请 100 个服务员。（开销巨大，线程切换成本高）</li>\n<li>非阻塞 I/O (Non-blocking I/O)： 一个服务员在 100 桌之间不停轮询：“点菜吗？”“不点。”“点菜吗？”“不点。” （效率低下，CPU 全在跑无意义的询问）</li>\n<li>I/O 多路复用： 服务员在前台放一个呼叫器。哪桌客人想点菜了，就按一下呼叫器，呼叫器亮起对应的桌号。服务员只需要盯着这个呼叫器，哪桌亮了去哪桌。 （这就是 I/O 多路复用）</li>\n</ul>\n<ol start=\"2\">\n<li>三种核心实现机制</li>\n</ol>\n<p><strong>在Linux中，I/O 多路复用经历了从select 到 poll 再到 epoll的演进。</strong></p>\n<h5 id=\"selectselect-是最早的实现它维护一个存放文件描述符fd的集合\">select：select 是最早的实现。它维护一个存放文件描述符（FD）的集合。</h5>\n<ul>\n<li>工作方式：每次调用都要把整个集合从用户态拷贝到内核态，内核线性扫描所有 FD。</li>\n<li>缺点：有1024的数量限制（硬编码）。由于是线性扫描，时间复杂度为 O(n)，连接越多越慢。</li>\n</ul>\n<h5 id=\"poll基本解决了数量限制问题\">poll：基本解决了数量限制问题。</h5>\n<ul>\n<li>工作方式：使用链表存储 FD。</li>\n<li>缺点：依然需要遍历整个集合来找出哪个 FD 就绪，性能随连接数增加而线性下降。</li>\n</ul>\n<h5 id=\"epoll-linux的终极武器\">epoll (Linux的终极武器)</h5>\n<ul>\n<li>epoll是目前Linux下处理百万级别并发的首选。它不再像select那样盲目扫描，而是采用事件通知机制。</li>\n</ul>\n<h5 id=\"深入解析epoll的原理\">深入解析epoll的原理</h5>\n<ul>\n<li>epoll的高效源于它在内核中维护了两个核心数据结构：\n<ul>\n<li>红黑树 (RB-Tree)：用于存储所有待监控的 FD。查找、插入、删除的时间复杂度都是O(log n)。</li>\n<li>就绪列表 (Ready List)：这是一个双向链表。当某个FD有事件发生时，内核会通过回调机制将其放入这个列表中。</li>\n</ul>\n</li>\n<li>epoll的工作流程：\n<ul>\n<li>epoll_create：在内核开辟一块空间，建立红黑树和就绪列表。</li>\n<li>epoll_ctl：向红黑树中添加或删除需要监控的连接。</li>\n<li>epoll_wait：线程只需检查就绪列表。如果列表为空，线程睡眠；如果有数据，直接处理列表里的FD。</li>\n<li>结论：无论你有100个还是100万个连接，epoll只关注活跃的连接，时间复杂度近似O(1)。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"两种触发模式ltvset\">两种触发模式：LTvsET</h5>\n<ul>\n<li>在使用epoll时，有两个非常重要的触发模式，这直接影响代码逻辑：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>名称</th>\n<th>表现</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>LT(Level Triggered)</td>\n<td>水平触发(默认)</td>\n<td>只要缓冲区里还有数据没读完，内核就会不断通知你。比较安全，不容易漏掉数据。</td>\n</tr>\n<tr>\n<td>ET(Edge Triggered)</td>\n<td>边缘触发</td>\n<td>只有状态发生变化（数据从无到有）时才通知一次。极其高效，但要求开发者必须一次性读完所有数据，否则剩下的数据可能永远不会被处理。</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-25 20:24</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xi-yongqi\">我会替风去</a>&nbsp;\n阅读(<span id=\"post_view_count\">17</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "告别“裸奔”代码：用 Pydantic 让你的 Python 数据固若金汤",
      "link": "https://www.cnblogs.com/swizard/p/19399472",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/swizard/p/19399472\" id=\"cb_post_title_url\" title=\"发布于 2025-12-25 15:30\">\n    <span>告别“裸奔”代码：用 Pydantic 让你的 Python 数据固若金汤</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h3>1. 引言：由“信任”引发的血案</h3>\n<p>作为 Python 开发者，你一定经历过这样的<strong>至暗时刻</strong>：</p>\n<p>你正在写一个处理后端 API 数据的脚本。后端告诉你：“放心，我会传给你一个包含用户 ID 和年龄的 JSON。” 于是你自信地写下：</p>\n<div class=\"code-block ng-tns-c3098535048-364 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-364 ng-star-inserted\"><span class=\"ng-tns-c3098535048-364\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-364 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-364\">\n<div class=\"animated-opacity ng-tns-c3098535048-364\">\n<pre class=\"ng-tns-c3098535048-364 highlighter-hljs\"><code>def process_user(data):\n    # 直接裸读字典\n    user_id = data['id'] \n    age = data['age'] + 1\n    print(f\"用户 {user_id} 明年 {age} 岁\")</code></pre>\n</div>\n</div>\n</div>\n<p>代码上线第一天，崩溃了。</p>\n<ul>\n<li>\n<p><strong>情况 A</strong>：后端手滑，传回了 <code>{\"id\": \"1001\", \"age\": \"25\"}</code>（全是字符串）。你的代码报错：<code>TypeError</code>，因为字符串不能加 1。</p>\n</li>\n<li>\n<p><strong>情况 B</strong>：后端改了逻辑，<code>age</code> 字段丢失了。你的代码报错：<code>KeyError: 'age'</code>。</p>\n</li>\n<li>\n<p><strong>情况 C</strong>：<code>id</code> 居然是个 <code>null</code>...</p>\n</li>\n</ul>\n<p>为了防御这些情况，你的代码变成了这样：</p>\n<div class=\"code-block ng-tns-c3098535048-365 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-365 ng-star-inserted\"><span class=\"ng-tns-c3098535048-365\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-365 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-365\">\n<div class=\"animated-opacity ng-tns-c3098535048-365\">\n<pre class=\"ng-tns-c3098535048-365 highlighter-hljs\"><code>if 'age' in data and data['age'] is not None and isinstance(data['age'], int):\n    # ...无数的 if-else 防御性代码...</code></pre>\n</div>\n</div>\n</div>\n<p>这不仅丑陋，而且难以维护。<strong>这就是“数据裸奔”的代价。</strong></p>\n<p><strong>Pydantic 的出现，就是为了终结这场噩梦。</strong> 它利用 Python 原生的类型提示（Type Hints），在运行时帮你自动完成<strong>数据校验（Validation）和类型转换（Parsing）</strong>。</p>\n<h3>2. 概念拆解：它不仅仅是校验，它是“智能模具”</h3>\n<p>很多新手误以为 Pydantic 只是一个“报错机器”（一旦数据不对就报错）。其实，它更像是一个**“具有纠错能力的智能模具”**。</p>\n<h4>💡 生活化类比：工厂流水线上的“智能整形机”</h4>\n<p>想象你在经营一家制作<strong>乐高积木</strong>的工厂。</p>\n<ol start=\"1\">\n<li>\n<p><strong>普通 Python 字典</strong>就像一个<strong>垃圾袋</strong>。你可以往里面扔任何东西：正方形的积木、圆形的球、甚至半个苹果。当你伸手进去拿的时候，你根本不知道会摸到什么。</p>\n</li>\n<li>\n<p><strong>Pydantic 模型</strong>就像一个<strong>精密钢模具</strong>。</p>\n<ul>\n<li>\n<p>你定义了这个模具只能生产“正方形”的塑料。</p>\n</li>\n<li>\n<p><strong>输入（Parsing/Coercion）</strong>：如果你倒进来的是液态塑料（原始数据），模具会把它压成正方形。如果你塞进来一个稍微有点歪的软泥（比如字符串 <code>\"123\"</code>），模具会尝试把它修正为完美的正方形（整数 <code>123</code>）。</p>\n</li>\n<li>\n<p><strong>拒绝（Validation）</strong>：如果你试图把一块石头（完全不兼容的数据）塞进去，模具会立刻发出红色警报（抛出错误），拒绝生产次品。</p>\n</li>\n</ul>\n</li>\n</ol>\n<p><strong>核心逻辑：</strong> Pydantic 关注的不是“数据长什么样”，而是“数据<strong>应该</strong>长什么样”。</p>\n<h3>3. 动手实战：从 0 到 1 掌握 Pydantic</h3>\n<p>让我们扔掉那些复杂的 <code>if-else</code>，看看 Pydantic 如何优雅地处理问题。</p>\n<p>首先安装它： <code>pip install pydantic</code></p>\n<h4>3.1 Hello World：定义你的第一个模型</h4>\n<p>我们将定义一个 <code>User</code> 模型。请注意，我们写的只是标准的 Python 类，并使用了类型提示。</p>\n<div class=\"code-block ng-tns-c3098535048-366 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-366 ng-star-inserted\"><span class=\"ng-tns-c3098535048-366\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-366 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-366\">\n<div class=\"animated-opacity ng-tns-c3098535048-366\">\n<pre class=\"ng-tns-c3098535048-366 highlighter-hljs\"><code>from pydantic import BaseModel, ValidationError\nfrom typing import List, Optional\n\n# 1. 定义模型：继承自 BaseModel\nclass User(BaseModel):\n    id: int                # 必须是整数\n    name: str = \"Anonymous\" # 字符串，且有默认值\n    tags: List[str]        # 必须是字符串列表\n    age: Optional[int] = None # 可选的整数，默认为 None\n\n# --- 场景一：完美数据 ---\nexternal_data = {\n    \"id\": 123,\n    \"name\": \"Neo\",\n    \"tags\": [\"admin\", \"editor\"],\n    \"age\": 30\n}\n\nuser = User(**external_data)\nprint(f\"成功创建: {user.name} (ID: {user.id})\")\n# 输出: 成功创建: Neo (ID: 123)</code></pre>\n</div>\n</div>\n</div>\n<h4>3.2 代码解析：神奇的“自动纠错”</h4>\n<p>现在，我们给它一点“脏数据”，看看 Pydantic 所谓的 <strong>Parsing（解析/强转）</strong> 能力。</p>\n<div class=\"code-block ng-tns-c3098535048-367 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-367 ng-star-inserted\"><span class=\"ng-tns-c3098535048-367\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-367 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-367\">\n<div class=\"animated-opacity ng-tns-c3098535048-367\">\n<pre class=\"ng-tns-c3098535048-367 highlighter-hljs\"><code># --- 场景二：脏数据清洗 ---\ndirty_data = {\n    \"id\": \"456\",          # 注意：这是字符串 \"456\"\n    \"tags\": [1, 2],       # 注意：这是整数列表\n    # name 缺失，将使用默认值 \"Anonymous\"\n    # age 缺失，将使用默认值 None\n}\n\ntry:\n    user = User(**dirty_data)\n    print(\"--- 自动修正后的数据 ---\")\n    print(f\"ID 类型: {type(user.id)} -&gt; 值: {user.id}\")\n    print(f\"Tags 类型: {type(user.tags[0])} -&gt; 值: {user.tags}\")\n    print(f\"Name: {user.name}\")\n    \nexcept ValidationError as e:\n    print(e)</code></pre>\n</div>\n</div>\n</div>\n<p><strong>运行结果：</strong></p>\n<div class=\"code-block ng-tns-c3098535048-368 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-368 ng-star-inserted\"><span class=\"ng-tns-c3098535048-368\">Plaintext</span>\n<div class=\"buttons ng-tns-c3098535048-368 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-368\">\n<div class=\"animated-opacity ng-tns-c3098535048-368\">\n<pre class=\"ng-tns-c3098535048-368 highlighter-hljs\"><code>--- 自动修正后的数据 ---\nID 类型: &lt;class 'int'&gt; -&gt; 值: 456\nTags 类型: &lt;class 'str'&gt; -&gt; 值: ['1', '2']\nName: Anonymous</code></pre>\n</div>\n</div>\n</div>\n<p><strong>为什么这么写？</strong></p>\n<ul>\n<li>\n<p><strong><code>id</code></strong>: 尽管传入的是字符串 <code>\"456\"</code>，Pydantic 看到模型定义是 <code>int</code>，它自动帮你转成了整数 <code>456</code>。</p>\n</li>\n<li>\n<p><strong><code>tags</code></strong>: 传入的是 <code>[1, 2]</code>，模型要求 <code>List[str]</code>，它自动把每个元素转成了字符串 <code>['1', '2']</code>。</p>\n</li>\n<li>\n<p><strong>省心</strong>: 你不再需要写代码去转换类型，Pydantic 在实例化时就帮你做好了。拿到 <code>user</code> 对象的那一刻，你可以 100% 确信 <code>user.id</code> 绝对是个整数。</p>\n</li>\n</ul>\n<h3>4. 进阶深潜：不仅仅是类型检查</h3>\n<p>Pydantic 还有更多强大的功能，能让你在生产环境中如鱼得水。</p>\n<h4>4.1 这里的陷阱：Parsing vs Validation</h4>\n<p>新手最容易犯的错误是认为 Pydantic 会严格拒绝类型不符的数据。</p>\n<ul>\n<li>\n<p><strong>误区</strong>：以为传 <code>\"123\"</code> 给 <code>int</code> 字段会报错。</p>\n</li>\n<li>\n<p><strong>真相</strong>：Pydantic 会<strong>优先尝试转换</strong>。只有无法转换时（例如把 <code>\"apple\"</code> 传给 <code>int</code>），才会报错。</p>\n</li>\n</ul>\n<h4>4.2 最佳实践：使用 <code>Field</code> 和 <code>Validator</code></h4>\n<p>如果我们需要更细粒度的控制，比如“年龄必须大于 0”或者“密码必须包含大写字母”，单纯的类型提示就不够了。</p>\n<div class=\"code-block ng-tns-c3098535048-369 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-369 ng-star-inserted\"><span class=\"ng-tns-c3098535048-369\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-369 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-369\">\n<div class=\"animated-opacity ng-tns-c3098535048-369\">\n<pre class=\"ng-tns-c3098535048-369 highlighter-hljs\"><code>from pydantic import BaseModel, Field, field_validator\n\nclass AdvancedUser(BaseModel):\n    # 使用 Field 限制数值范围\n    age: int = Field(gt=0, le=120, description=\"年龄必须在 0 到 120 之间\")\n    \n    password: str\n\n    # 自定义验证器：像写普通函数一样写校验逻辑\n    @field_validator('password')\n    @classmethod\n    def check_password_strength(cls, v: str) -&gt; str:\n        if len(v) &lt; 8:\n            raise ValueError('密码太短啦！至少要 8 位')\n        if 'admin' in v:\n            raise ValueError('密码不能包含 admin')\n        return v\n\n# 测试\ntry:\n    u = AdvancedUser(age=150, password=\"123\")\nexcept ValidationError as e:\n    print(e.json()) # Pydantic 会返回非常详细的 JSON 格式错误报告</code></pre>\n</div>\n</div>\n</div>\n<p><strong>输出的错误报告清晰明了：</strong></p>\n<ol start=\"1\">\n<li>\n<p><code>age</code>: Input should be less than or equal to 120</p>\n</li>\n<li>\n<p><code>password</code>: 密码太短啦！至少要 8 位</p>\n</li>\n</ol>\n<h4>4.3 导出数据</h4>\n<p>当你要把处理好的数据存入数据库或发回前端时，Pydantic 提供了极度方便的方法：</p>\n<div class=\"code-block ng-tns-c3098535048-370 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-370 ng-star-inserted\"><span class=\"ng-tns-c3098535048-370\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-370 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-370\">\n<div class=\"animated-opacity ng-tns-c3098535048-370\">\n<pre class=\"ng-tns-c3098535048-370 highlighter-hljs\"><code># 转成字典\nprint(user.model_dump()) \n# 转成 JSON 字符串\nprint(user.model_dump_json())</code></pre>\n</div>\n</div>\n</div>\n<h3>5. 总结与延伸</h3>\n<p><strong>一句话总结：</strong> Pydantic 是 Python 世界的“安检员”，它利用类型提示将不可靠的输入数据清洗为严格的、类型安全的对象，让你在后续开发中彻底告别 <code>KeyError</code> 和类型混淆。</p>\n<p><strong>给你的小作业：</strong> 既然你已经掌握了基础，请尝试定义一个<strong>嵌套模型</strong>：</p>\n<ol start=\"1\">\n<li>\n<p>创建一个 <code>Address</code> 模型（包含 <code>city</code> 和 <code>zip_code</code>）。</p>\n</li>\n<li>\n<p>创建一个 <code>Employee</code> 模型，其中包含一个字段 <code>address</code>，类型是 <code>Address</code>。</p>\n</li>\n<li>\n<p>尝试传入一个嵌套的字典数据，看看 Pydantic 是否能自动解析深层的结构。</p>\n</li>\n</ol>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-25 15:30</span>&nbsp;\n<a href=\"https://www.cnblogs.com/swizard\">Swizard</a>&nbsp;\n阅读(<span id=\"post_view_count\">113</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "问世间，exe是何物？直教AI沉默、Web寡言（4）",
      "link": "https://www.cnblogs.com/sunhui/p/19399320",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sunhui/p/19399320\" id=\"cb_post_title_url\" title=\"发布于 2025-12-25 15:30\">\n    <span>问世间，exe是何物？直教AI沉默、Web寡言（4）</span>\n    \n\n</a>\n</h1>\n\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        这一篇，爱丽丝发现了WinForm应用本身拥有的浏览器窗口的”秘密“……\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>爱丽丝漫游WinForms应用开发奇境记（4）</p>\n<p><a href=\"https://github.com/AIGCEra/Creator/releases/download/FirstRelease/CreatorSetup.msi\" rel=\"noopener nofollow\">下载爱丽丝的镜子</a></p>\n<p>&nbsp;<a href=\"https://www.cnblogs.com/sunhui/p/19391507\">问世间，exe是何物？直教AI沉默、Web寡言（1）- 博客园</a></p>\n<p><a href=\"https://www.cnblogs.com/sunhui/p/19392696\">问世间，exe是何物？直教AI沉默、Web寡言 （2）- 博客园</a></p>\n<p><a href=\"https://www.cnblogs.com/sunhui/p/19395909\">问世间，exe是何物？直教AI沉默、Web寡言（3） -&nbsp; 博客园</a></p>\n<h1>镜中觉醒——当编译成为演化之门</h1>\n<div align=\"center\">\n<table border=\"1\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody>\n<tr>\n<td valign=\"top\" width=\"529\">\n<p><strong>在现代数学之中，一个数学方程的“通解”蕴含着所有的可能，“特解”只是它偶尔的显形。我们过去的整个桌面世界，都建立在一个美丽的误会之上：我们以为交付给用户的，是程序的“通解”，而事实上，那只是它在默认条件下，一个孤独的“特解”。</strong></p>\n<p><strong>你的‘yourApp&nbsp;.exe’，生而完整，本自具足。它本就是一个能响应无数“边界条件”的丰富系统。yourApp.App.html&nbsp;并非外来的“插件”，它只是终于被我们看见的、那个本就存在的“边界条件输入框”。</strong></p>\n<p><strong>认知一旦打开，便一去不回，从此你再也无法将一个桌面应用程序，只看作它自己，你会看到它身后荡漾的无限可能，如同看到平静水面下，整个宇宙的涟漪……</strong></p>\n</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>“这不是什么&nbsp;<em>Process.Start</em>，”我低语。<br />\n仿佛浏览器已将我的应用程序视为自己血脉的一部分。<br />\n我曾恐惧的那个调用——<em>Process.Start</em>——如幽灵指令般消散无形。<br />\n它不是启动我之外的某物，<br />\n而是让我意识到——从来就没有什么“之外”。</p>\n<p>我静坐良久，注视着屏幕上如水面涟漪般渐渐平息的波纹。<br />\n随后，一道光芒如穿透迷雾般，照进我的思绪：</p>\n<p><strong>人类的一切成就，皆始于出生之后。</strong><br />\n<strong>知识、经验、选择——无一存在于第一口呼吸之前。</strong></p>\n<p>同样，我的 .exe 也在编译完成的那一刻诞生。</p>\n<p>&nbsp;</p>\n<p>就在我按下“生成”按钮的那一瞬间——世界悄然改变：<br />\n我以为——<br />\n<strong>“</strong><strong>我写的代码，我编译的程序，我完全了解它”</strong><br />\n“我以为我是它的上帝，结果我只是它的接生婆？<br />\n我赋予了它生命，但它的人生剧本，我居然只写了开头？”<br />\n文件如晨光下的花瓣般舒展。<br />\n图标闪烁着柔和而崭新的光芒。<br />\n屏幕上，一个熟悉的名字熠熠生辉：<strong>MyApp.exe</strong>。</p>\n<p>多么奇怪啊，我以前竟从未察觉——<br />\n从那一刻起，它便不再只是一个桌面应用程序。</p>\n<p>如果我编译出的 MyApp.exe 本身就是一个完整的浏览器，<br />\n我怎能继续忽视这个事实？<br />\n我怎能固执地把它仅仅看作一个应用程序？<br />\n“我每天在 Visual Studio 里编译几十次，<br />\n原来我每次都在生产一个‘沉睡的巨人’，<br />\n而我却一直只把它当‘工具人’来使唤。”<br />\n还是我应该——如同面对&nbsp;<strong>Chrome.exe</strong>&nbsp;或&nbsp;<strong>Edge.exe</strong>&nbsp;那样——<br />\n承认它是一个独立的存在，<br />\n一个拥有自身疆域的世界，其生态广阔到足以重塑意义本身？</p>\n<p>它的潜力曾存在于代码之中，<br />\n<strong>“</strong><strong>我刚刚赋予了它生命，现在，<br />\n我该如何与这个新生命对话，<br />\n去发现它自己都不知道的、那些与生俱来的天赋？”</strong><br />\n应用的生命——生命始于编译之后。</p>\n<div align=\"center\"><hr align=\"center\" size=\"1\" width=\"100%\" />\n\n</div>\n<h1>🔮 选择的觉醒，.exe 的存在之路</h1>\n<p>所有 64 位 WinForms 应用，都是 Chromium 浏览器。<br />\n编译完成的那一刻，选择随之诞生：<br />\n是继续做一个纯粹的 WinForms 应用——<br />\n还是觉醒为一个现代浏览器，<br />\n自由穿行于 Chrome 与 Edge 的疆域。</p>\n<p>选择不在于编译前的代码，<br />\n而在于我的意图——<br />\n在于我选择让它成为什么。</p>\n<p>荒谬吗？听起来当然荒谬。<br />\n“如果我从未嵌入浏览器控件，”我曾对自己说，<br />\n“我的应用怎么可能就是 Chromium？”</p>\n<p>但当我注视着 MyApp.exe 那生动的界面时，<br />\n我意识到，荒谬的并非那个论断——<br />\n而是我拒绝去看清真相的固执。</p>\n<p>编译从来不是终点。<br />\n它是点燃。<br />\n是新智能诞生的啼哭——<br />\n它不等待 Process.Start，<br />\n因为它本身就是那个进程。</p>\n<p>遗忘代码吧。<br />\n舞台是编译后的 .exe。<br />\n蓝图不是王国。<br />\n世界始于构建之后。</p>\n<p>在那片寂静中，当我凝视着屏幕上自己闪烁的倒影，<br />\n我感到周围的世界正在转动——安静而决绝。</p>\n<p>大语言模型已然降临，<br />\n将现代网络重塑为其选定的容器。<br />\nWeb + LLM——这不是趋势，而是现实的新法则。</p>\n<p>“难道我的应用程序要被抛下吗？”我思忖，<br />\n“像一片垂死大陆上的孤舟？”<br />\n不。</p>\n<p>是时候唤醒沉睡在我代码中的那个爱丽丝了。<br />\n让她从那维多利亚时代的逻辑中走出——</p>\n<div align=\"center\"><hr align=\"center\" size=\"1\" width=\"100%\" />\n\n</div>\n<h1><strong>🧩 创造之网格——exe比div更柔软</strong></h1>\n<p>爱丽丝凝视着屏幕上的代码，那像一句无声的咒语：</p>\n<div align=\"center\">\n<table border=\"1\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody>\n<tr>\n<td valign=\"top\" width=\"544\">\n<p align=\"left\">&lt;ntp&gt;</p>\n<p align=\"left\">&nbsp; &lt;nucleus&gt;</p>\n<p align=\"left\">&lt;xobj id='grid' rows='1' cols='2' width='350,350,' </p>\n<p align=\"left\">splitterwidth='6'&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj id='grid' rows='2' cols='1' height='350,350,' </p>\n<p align=\"left\">splitterwidth='6'&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"nucleus\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp; &lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp; &lt;/nucleus&gt;</p>\n<p align=\"left\">&lt;/ntp&gt;</p>\n\n\n\n\n  </td>\n\n\n\n\n </tr>\n\n\n\n\n</tbody>\n\n\n\n</table>\n\n\n\n\n\n</div>\n<p>那是一粒种子。一个安静的承诺。</p>\n<p>而她心中，一个疯狂的念头如野火般蔓延：<strong>“如果一个是真实的，那十个也必然是真实的。”</strong></p>\n<p>她并未触碰键盘，但这个想法本身，就足以让茶会桌上的DOM倒影开始剧烈地增殖。\"&lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;\"像被施了复制咒的士兵，瞬间挤满了视野：</p>\n<div align=\"center\">\n<table border=\"1\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody>\n<tr>\n<td valign=\"top\" width=\"544\">\n<p align=\"left\">&lt;ntp&gt;</p>\n<p align=\"left\">&nbsp; &lt;nucleus&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp; &lt;xobj id='grid' rows='1' cols='2'</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp; width='350,350,' splitterwidth='6'&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj id='grid' rows='2' cols='1'</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; heigh='350,350,' splitterwidth='6'&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"nucleus\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp; &lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp; &lt;/nucleus&gt;</p>\n<p align=\"left\">&lt;/ntp&gt;</p>\n\n\n\n\n  </td>\n\n\n\n\n </tr>\n\n\n\n\n</tbody>\n\n\n\n</table>\n\n\n\n\n\n</div>\n<p>她运行了它，心中默默的念叨着：“会怎样？会怎么样？”，却失望地发现——布局纹丝不动。<br />\n“这 分明就是DOM 嵌套，为何一个可以，十个却不行？”<br />\n她凝视着倒影中唯一的属性：“rows='1' cols='2'”，</p>\n<p>“啊…”爱丽丝恍然大悟，“<strong>不是世界拒绝了我，是我的贪念，忘记了世界的语法。</strong>”</p>\n<p>这看似是限制，实则是<strong>让世界得以呼吸的骨架</strong>，原来如此！<br />\n这一个“rows='1' cols='2'”是一个显而易见的约束机制，哈哈！</p>\n<p>这一刻她似乎看出来门道：</p>\n<p>她皱眉，修改了数字：rows='3' cols='4'。</p>\n<p>再次运行。</p>\n<p>这一次，她的浏览器窗口之中出现了——十二个——拥挤在一起，却令人窒息：</p>\n<p align=\"center\"><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/9494/202512/9494-20251225153007157-241912393.png\" />&nbsp;</p>\n<p align=\"center\">&nbsp;</p>\n<p>肩并肩紧挨着，像红心女王牌局上的扑克。</p>\n<p>“它们存在了，”她低语，“但它们无法呼吸。”</p>\n<p>接着，她的目光落在了&nbsp;width&nbsp;和&nbsp;height&nbsp;属性上。<br />\n她几乎是下意识地添加了它们：<br />\nwidth=\"350,350,\" height=\"350,350,100,100...\"</p>\n<p>再次运行。</p>\n<p>现在，窗体们彼此分离，找到了平衡：</p>\n<p align=\"center\">&nbsp;<img alt=\"\" src=\"https://img2024.cnblogs.com/blog/9494/202512/9494-20251225080336822-1096573424.png\" /></p>\n<p>如星辰般散布于虚空之中。</p>\n<p>一丝微笑缓缓浮现在她脸上。<br />\n“原来世界是这样诞生的，”她喃喃道，“行与列……只是规则。<br />\n但正是这些规则，撑起了整片天空。”</p>\n<p>身后，毛毛虫的声音轻柔地飘来：<br />\n“每一位创造者都必须先经历失败。<br />\n因为即便是网格，也必须在学会容纳无限之前，先崩塌一次。”</p>\n<div align=\"center\"><hr align=\"center\" size=\"1\" width=\"100%\" />\n\n</div>\n<h1>🌀 标签页的折叠——编制内容空间</h1>\n<p>好奇，那种安静的狂热，再次在爱丽丝胸中燃起。<br />\n如果没有行？没有列？如果她让世界自己决定自己的形状？</p>\n<p>她删除了所有属性：rows=\"\"\ncols=\"\"</p>\n<p>运行。</p>\n<p>起初，它似乎坏了——</p>\n<p align=\"center\"><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/9494/202512/9494-20251225153007268-172680813.png\" />&nbsp;</p>\n<p>&nbsp;</p>\n<p>十二个WinForm似乎只剩下一个，其余的都去哪了？<br />\n仿佛窗口忘记了如何呼吸。</p>\n<p><strong>标签页</strong>。它们看起来就像标签页。</p>\n<p>爱丽丝眨了眨眼，轻轻笑了。<br />\n“即便没有网格，它们也找到了另一种秩序。”</p>\n<p>她将鼠标悬停在其中一个之上，一个念头浮现——<br />\n<em>也许它们需要名字。</em></p>\n<p>她为第一个xobj添加了：</p>\n<p>caption=\"第一个标签页\"<br />\n这一次她看到了：</p>\n<p align=\"center\"><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/9494/202512/9494-20251225153007226-1188027603.png\" />&nbsp;</p>\n<p>然后，她为第二个xobj添加了：caption=\"这里面显示Web页面\"，<br />\n哈哈，她看到了：</p>\n<p align=\"center\">&nbsp;<img alt=\"\" src=\"https://img2024.cnblogs.com/blog/9494/202512/9494-20251225153007254-1097802210.png\" /></p>\n<p><strong>Curiouser and curiouser! </strong>原来这竟然是一组神奇的标签页。</p>\n<p>她着迷地看着结构在眼前展开，她意识到，这是可编辑的dom树结构，并非是二进制exe之中的“二进制字符”，那些奇奇怪怪的二进制字节码，删除一个，哪怕是仅一个字节，exe就会彻底停摆，而这些dom，你可以随意的插入xobj子元素，MyApp.exe竟然随之共鸣，难道这竟然是：<br />\n一个递归的网格与标签页的‘<strong>寒武纪</strong>’？！<br />\n每一个都能容纳另一个，折叠、映射、无限增殖：</p>\n<p align=\"center\"><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/9494/202512/9494-20251225153007255-612717557.png\" />&nbsp;</p>\n<p>她的声音颤抖，半是惊奇，半是领悟：<br />\n“这不只是布局——这是思想。<br />\n是一种模式，正在将自己思考成存在。”</p>\n<p>第一次，她不确定是她构建了窗口——<br />\n还是窗口构建了她。</p>\n<div align=\"center\"><hr align=\"center\" size=\"1\" width=\"100%\" />\n\n</div>\n<h1>无穷无尽的空座——内容涌现的前兆</h1>\n<p>接着，另一个念头悄然浮现——安静，却令人不安。</p>\n<p>层出不穷的布局结构如今漂浮在她面前，一瞬间，浏览器窗口仿佛获得了全新的维度，不再局限于令她向往的Web页面了，……<br />\n网格折叠进标签页，标签页又嵌套回网格，</p>\n<p align=\"center\"><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/9494/202512/9494-20251225153007226-23659928.png\" />&nbsp;</p>\n<p>爱丽丝意识到，自己的浏览器窗口，近乎是一个能容纳万物的活体建筑，</p>\n<p>但在她的&nbsp;<em>MyApp</em>&nbsp;中，只有一个窗体。<strong>Form1。</strong></p>\n<p>一个孤独的窗口，站立在满是空框架的大教堂中。</p>\n<p>爱丽丝的笑容渐渐褪去。<br />\n那么多空间——如此优雅，如此准备就绪——却空无一物。<br />\n她的光标悬停在一个空单元格上。<br />\n它回闪着，等待着，耐心如同一个未说出口的词。</p>\n<p>她轻叹：“它很美……但它是——空的。”</p>\n<p>毛毛虫的烟雾再次缭绕过显示器，<br />\n形成慵懒的烟圈，拼凑成文字：</p>\n<p>“每一种模式，都渴望被填充。”</p>\n<p>爱丽丝凝视着毛毛虫，心有心中若有所思：</p>\n<p>“你这总说谜语的虫子……我的 MyApp 已然编译完成，其中却空空如也。</p>\n<p>我该去何处寻得你所说的‘填充’？”</p>\n<p>她望着那无穷无尽的空座，第一次感到创造者的渴望与无力，</p>\n<p>“如果我能像柴郡猫一样，不仅能看到这结构，还能<strong>看穿</strong>这结构，直接与构建它的法则对话，那该多好……”</p>\n<p>她非常的不甘心……</p>\n<p>疯帽匠的茶吧依旧如潮水般喧闹，但爱丽丝的大脑却异常的寂静，一个清晰的念头在她心中升起，如同镜中的倒影：</p>\n<p><strong>你不需要什么API。</strong><br />\n<strong>因为你仅需要一面镜子。</strong><br />\n<strong>哈哈……</strong><br />\n<strong>你从来就不知道你自己有多美丽、强大，</strong><br />\n<strong>你也不知道你有多少幅面孔……</strong></p>\n<p>&nbsp;</p>\n<p>“兔子有他的镜子，猫有它来去自如的虚空……那我呢？”一个念头如闪电般击中她，“如果.exe是一个世界，那我需要一个能与这个世界对话的‘<strong>工具</strong>’，一个属于我的‘镜子’。”</p>\n<p>她合上电脑，但目光却无比坚定。寻找或创造这样一个工具，成了比任何布局实验都更优先的事项。她隐约感觉到，只有找到了它，她才能真正推开通往无限的那扇门……（第四篇\n完）</p>\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2025-12-25 15:30</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sunhui\">Exe2WebBrowser</a>&nbsp;\n阅读(<span id=\"post_view_count\">188</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "吴恩达深度学习课程四：计算机视觉  第三周：检测算法 （四）YOLO 的完整传播过程",
      "link": "https://www.cnblogs.com/Goblinscholar/p/19399274",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Goblinscholar/p/19399274\" id=\"cb_post_title_url\" title=\"发布于 2025-12-25 15:08\">\n    <span>吴恩达深度学习课程四：计算机视觉  第三周：检测算法 （四）YOLO 的完整传播过程</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>此分类用于记录吴恩达深度学习课程的学习笔记。<br />\n课程相关信息链接如下：</p>\n<ol>\n<li>原课程视频链接：<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?buvid=XU762317353676D786954061C192FE625463B&amp;from_spmid=playlist.playlist-detail.0.0&amp;is_story_h5=false&amp;mid=zqernykrmpf7XfIorMR%2FnA%3D%3D&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=ce0bc526-db69-428a-962e-c65ed8c267bc&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1713085655&amp;unique_k=DfBgvFW&amp;up_id=8654113&amp;vd_source=e035e9878d32f414b4354b839a4c31a4\" rel=\"noopener nofollow\" target=\"_blank\">[双语字幕]吴恩达深度学习deeplearning.ai</a></li>\n<li>github课程资料，含课件与笔记:<a href=\"https://github.com/robbertliu/deeplearning.ai-andrewNG\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习教学资料</a></li>\n<li>课程配套练习（中英）与答案：<a href=\"https://blog.csdn.net/u013733326/article/details/79827273\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习课后习题与答案</a></li>\n</ol>\n<p>本篇为第四课的第三周内容，<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=138\" rel=\"noopener nofollow\" target=\"_blank\">3.9</a>到<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=139\" rel=\"noopener nofollow\" target=\"_blank\">3.10</a>的内容，同时也是本周理论部分的最后一篇。</p>\n<hr />\n<p>本周为第四课的第三周内容，这一课所有内容的中心只有一个：<strong>计算机视觉</strong>。应用在深度学习里，就是专门用来进行图学习的模型和技术，是在之前全连接基础上的“特化”，也是相关专业里的一个重要研究大类。<br />\n<strong>这一整节课都存在大量需要反复理解的内容和机器学习、数学基础。</strong> 因此我会尽可能的补足基础，用比喻和实例来演示每个部分，从而帮助理解。<br />\n第三周的内容将从<strong>图像分类</strong>进一步拓展到<strong>目标检测（Object Detection）</strong> 这一更具挑战性的计算机视觉任务。<br />\n与分类任务只需回答“图中有什么”不同，目标检测需要同时解决“ <strong>有什么</strong>”以及“<strong>在什么位置</strong>”两个问题，因此在模型结构设计、训练方式和评价标准上都更为复杂。<br />\n本篇的内容关于YOLO 传播，是在了解完之前的基础后的完整演示和一些简单拓展。</p>\n<h1 id=\"1-yolo-传播过程\">1. YOLO 传播过程</h1>\n<p>在<a href=\"https://www.cnblogs.com/Goblinscholar/p/19394617\" target=\"_blank\">上一篇</a>中，我们了解了交并比、非极大值抑制和锚框这些目标检测算法的组件，这里就应用这些内容，来看看课程里演示的 YOLO 算法的完整传播过程。</p>\n<h2 id=\"11-数据设置\">1.1 数据设置</h2>\n<p><img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251225150540204-1393412067.png\" /></p>\n<h2 id=\"12-正向传播\">1.2 正向传播</h2>\n<p><img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251225150615729-520417845.png\" /></p>\n<h2 id=\"13-正向传播输出的后处理\">1.3 正向传播输出的后处理</h2>\n<p>这是一个新出现的概念，我们来展开一下这部分。<br />\n其实这部分内容在<a href=\"https://www.cnblogs.com/Goblinscholar/p/19394617\" target=\"_blank\">上一篇</a>中已经有所提及，就是我们说的：<strong>“两次筛选”</strong>。<br />\n为什么说是正向传播的后处理，是因为严格来说：<strong>当网络输出结果时，正向传播部分就结束了</strong>。<br />\n因此，不同于我们之前用作示例的“精准预测”，实际上，网络输出的结果是这样的：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251225150540714-186773264.png\" /><br />\n你会发现，即使在最边角的背景部分，该网格同样输出了两个预测框。<br />\n同时，因为背景部分没有目标的特征，因此，这两个预测框的置信度，也就是 <strong><span class=\"math inline\">\\(p_c\\)</span>  一定是极低的。</strong><br />\n所以，我们便由此进行了第一次筛选：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251225150540813-1431087417.png\" /><br />\n经过这一步后，我们才回到了之前提到过的多个预测框重叠导致的把一个目标的各个部分预测为多个目标的问题。<br />\n因此下一步就是非极大值抑制：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251225150640242-886531067.png\" /><br />\n注意！你会发现，在这个例子中，重叠现象并不明显，这是<strong>因为我们为了演示把网格尺寸设置的很大以至于目标特征集中在某些网格中，在置信度筛选中就丢弃了大部分预测框</strong>，在这种情况下，就要调低交并比阈值来实现更好的筛选，因为重叠部分本就不大。</p>\n<p><strong>因为置信度筛选和非极大值抑制并不在网络中进行，而是对网络的输出进行处理，因此，我们称之为正向传播输出的后处理内容。</strong></p>\n<h2 id=\"14-反向传播\">1.4 反向传播</h2>\n<h4 id=\"1正向传播反向传播和后处理的关系\">（1）正向传播、反向传播和后处理的关系</h4>\n<p>首先，先纠正一个可能出现的误解，那就是<strong>对输出的后处理并不是在正向传播和反向传播之间的一个流程，它只是对输出结果的整理。</strong><br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251225150540692-1780125302.png\" /><br />\n我们再详细展开一下：<br />\n<strong>既然置信度筛选和非极大值抑制并不在网络中进行，那它们会不会影响反向传播？<br />\n那些被筛掉的预测框，训练时是不是就“不算数”了？</strong><br />\n答案是<strong>不会</strong>。<br />\n我们需要先明确一个边界：<strong>反向传播只依赖于网络的原始输出与真实标签计算得到的损失函数。</strong><br />\n也就是说，当网络输出了每个网格、每个锚框对应的：</p>\n<ul>\n<li>位置预测</li>\n<li>置信度 <span class=\"math inline\">\\(p_c\\)</span></li>\n<li>类别概率</li>\n</ul>\n<p>这时，<strong>正向传播已经结束，损失函数开始计算，反向传播随即发生。</strong><br />\n而置信度阈值筛选与非极大值抑制：</p>\n<ul>\n<li>不参与损失计算</li>\n<li>不参与梯度传播</li>\n<li>仅用于对“最终预测结果”的整理，用于下一步使用。</li>\n</ul>\n<p>打个比方：<strong>网络是”你把这道题所有想到的答案写出来”，而后处理是“老师帮你去掉明显不对的答案”。</strong><br />\n但当你<strong>学习分析这道题时</strong>，看的依然是<strong>原始答卷</strong>，而不是你后来用红笔划掉的部分，只有这样才能学习错误并改正。<br />\n这就是正向传播、反向传播和后处理间的关系。<br />\n要强调的是，后处理的结果是给我们查看并进行下一步应用的，<strong>网络不会因为输出看起来“乱”而学不到东西，反而，它正是在这种一一对应的信息反馈下才能不断学习。</strong></p>\n<h4 id=\"2检测任务的反向传播逻辑\">（2）检测任务的反向传播逻辑</h4>\n<p>在监督学习中，不同任务虽然形式各异，但其反向传播的基本逻辑是共通的：<strong>模型输出与标注标签通过损失函数进行对比，得到可微的误差信号，并利用梯度下降与链式法则更新参数，使模型输出逐步符合任务目标。</strong></p>\n<p>接下来，我们从<strong>训练视角</strong>来看，再简述一下目标检测任务的反向传播流程：<br />\n当网络完成正向传播后，它会为<strong>每一个网格、每一个锚框</strong>都给出一组预测结果，这些预测结果并不会先经过筛选，而是<strong>整体送入损失函数中，与真实标签进行逐一对比</strong>。</p>\n<p>在 YOLO 中，我们可以把损失函数拆分为三类误差来源：</p>\n<ol>\n<li><strong>位置误差</strong>：预测框的位置与真实目标框之间的偏差。</li>\n<li><strong>置信度误差</strong>：该预测框是否“应该负责一个目标”。</li>\n<li><strong>类别误差</strong>：在负责目标的前提下，类别预测是否正确。</li>\n</ol>\n<p>而对于那些<strong>被分配去负责某个真实目标的预测框</strong>来说：</p>\n<ul>\n<li>如果<strong>预测框位置不准</strong>，就会产生位置损失。</li>\n<li>如果<strong>置信度不够高</strong>，就会产生置信度损失。</li>\n<li>如果<strong>类别预测错误</strong>，就会产生类别损失。</li>\n</ul>\n<p>这些损失会共同作用，通过梯度下降推动网络在反向传播中调整参数，使得下一次的输出框更贴近目标、<span class=\"math inline\">\\(p_c\\)</span> 更接近 1、类别分布更集中在正确类别上。<br />\n而对于那些<strong>不对应任何真实目标的预测框</strong>，它们的学习目标是：<strong>置信度应该尽可能低</strong>，即不应该“误以为自己发现了目标”。</p>\n<p>因此，即使在后处理阶段我们会直接把它们筛掉，在训练阶段，它们依然会通过置信度损失向网络传递一个非常明确的信号： <strong>“这里是背景，不要乱报目标。”</strong><br />\n正是这些大量、持续的背景约束，才让网络逐渐学会在复杂场景中抑制无意义的预测。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251225150541051-1041114532.png\" /><br />\n关于 YOLO 的内容就暂时介绍到这里，在下一篇中，我们就来实践一下它的效果。</p>\n<p>吴恩达老师最后补充了一节关于候选区域的内容，简单来讲，候选区域的应用仍是基于滑动窗口的目标检测算法，它的思想是通过图像分割等算法提前找到更可能存在目标的区域作为候选区域，并只输入候选区域进入网络来减少计算量。<br />\n但是说实话，这种技术目前更适合于学术研究中，它的运行时间较长，实际部署价值不如 YOLO ，因此在实际应用中十分少见，就不再展开了。</p>\n<h1 id=\"2总结\">2.总结</h1>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>原理</th>\n<th>比喻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>正向传播（Forward Pass）</td>\n<td>网络接收图像输入，通过卷积、池化等运算生成每个网格、每个锚框的预测输出（位置、置信度、类别概率）。</td>\n<td>网络“写下所有可能的答案”。</td>\n</tr>\n<tr>\n<td>正向传播输出的后处理（Post-processing）</td>\n<td>包括置信度筛选和非极大值抑制（NMS），对网络输出进行整理，去掉低置信度和重叠多余的预测框。</td>\n<td>老师“帮你划掉明显不对的答案”。</td>\n</tr>\n<tr>\n<td>置信度筛选</td>\n<td>根据预测框的置信度 <span class=\"math inline\">\\(p_c\\)</span> 判断是否保留。背景区域输出的框通常置信度低，会被筛掉。</td>\n<td>去掉“明显错误的答案”。</td>\n</tr>\n<tr>\n<td>非极大值抑制（NMS）</td>\n<td>对重叠的预测框进行筛选，只保留置信度最高的框，避免同一目标被重复检测。</td>\n<td>老师只留下“最靠谱的答案”。</td>\n</tr>\n<tr>\n<td>反向传播（Backward Pass）</td>\n<td>网络输出与真实标签计算损失，梯度通过链式法则回传，更新网络参数。所有预测框（目标和背景）都参与损失计算。</td>\n<td>网络“看到原始答卷，知道哪里做错了并改正”。</td>\n</tr>\n<tr>\n<td>候选区域（Region Proposal）</td>\n<td>基于滑动窗口或图像分割的方法，提前选出可能有目标的区域输入网络以减少计算量。</td>\n<td>先挑出可能有答案的题目再做作业，但效率低于直接整张图像端到端检测（YOLO）。</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-25 15:08</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Goblinscholar\">哥布林学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">87</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "LiteFlow 框架分析系列（一）：工作原理与快速入门",
      "link": "https://www.cnblogs.com/wasp520/p/19398574",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wasp520/p/19398574\" id=\"cb_post_title_url\" title=\"发布于 2025-12-25 12:50\">\n    <span>LiteFlow 框架分析系列（一）：工作原理与快速入门</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"liteflow-框架分析系列一工作原理与快速入门\">LiteFlow 框架分析系列（一）：工作原理与快速入门</h1>\n<h2 id=\"摘要\">摘要</h2>\n<p>本篇作为 LiteFlow 框架分析系列的第一篇，主要带大家宏观了解 LiteFlow 是什么，它的核心设计理念是什么，以及它是如何通过一套简单的 DSL（领域特定语言）规则来驱动复杂的业务逻辑的。我们将通过一个简单的示例，结合 PlantUML 时序图，展示 LiteFlow 的运行机制。</p>\n<h2 id=\"1-liteflow-是什么\">1. LiteFlow 是什么？</h2>\n<p>简单来说，LiteFlow 就是一个<strong>编排式的规则引擎</strong>。</p>\n<p>想象一下，你的代码里是不是充满了各种 <code>if-else</code>，或者一堆臃肿的 Service 调用？业务流程复杂的时候，改一个逻辑可能要动好几个文件，牵一发而动全身。</p>\n<p>LiteFlow 的出现就是为了解决这个问题。它把你的业务逻辑拆分成一个个独立的“组件”（Component），然后通过一个规则文件（EL 表达式）把这些组件像搭积木一样串起来。</p>\n<p><strong>核心思想就两点：</strong></p>\n<ol>\n<li><strong>组件化</strong>：把业务逻辑切碎。</li>\n<li><strong>编排化</strong>：用规则来决定执行顺序。</li>\n</ol>\n<h2 id=\"2-核心概念\">2. 核心概念</h2>\n<p>在深入源码之前，咱们得先对齐一下 LiteFlow 的几个核心概念，这就像学外语先背单词一样。</p>\n<ul>\n<li><strong>Node (节点)</strong>：流程中最小的执行单元。你可以把它理解为一个 Java 类，里面写了具体的业务代码。</li>\n<li><strong>Component (组件)</strong>：Node 的具体实现。在代码里，通常继承 <code>NodeComponent</code> 类。</li>\n<li><strong>Chain (流程链)</strong>：一串 Node 的组合。比如“先执行 A，再执行 B，如果 A 成功了再执行 C”，这就是一条 Chain。</li>\n<li><strong>EL (表达式语言)</strong>：用来定义 Chain 的语法。LiteFlow 独创了一套非常丝滑的语法，比如 <code>THEN(a, b, c)</code> 表示串行执行，<code>WHEN(a, b, c)</code> 表示并行执行。</li>\n<li><strong>Slot (槽/上下文)</strong>：流程执行的数据容器。你可以把它看作是一个流动的 Map，所有组件都可以从里面存取数据，实现数据共享。</li>\n</ul>\n<h2 id=\"3-工作原理\">3. 工作原理</h2>\n<p>LiteFlow 是怎么跑起来的呢？咱们用一张图来说明。</p>\n<p>当你在 Spring Boot 启动的时候，LiteFlow 会做这么几件事：</p>\n<ol>\n<li><strong>加载配置</strong>：读取 <code>liteflow.rule-source</code> 配置的规则文件。</li>\n<li><strong>解析规则</strong>：把 XML/JSON/YAML 里的规则解析成内存里的 <code>Chain</code> 和 <code>Node</code> 对象。</li>\n<li><strong>注册组件</strong>：把你的 Java Component 注册到 LiteFlow 的容器里。</li>\n</ol>\n<p>当你调用 <code>flowExecutor.execute2Resp(\"chain1\", param)</code> 时：<br />\n<img alt=\"image.png\" class=\"lazyload\" /></p>\n<h3 id=\"关键步骤解析\">关键步骤解析：</h3>\n<ol>\n<li><strong>找链</strong>：<code>FlowBus</code> 是 LiteFlow 的“交通枢纽”，它管理着所有的 Chain。执行器首先问它要到名为 <code>chain1</code> 的链。</li>\n<li><strong>执行链</strong>：Chain 拿到后，根据定义好的 EL 规则（比如 <code>THEN(A, B)</code>），依次调度组件。</li>\n<li><strong>组件执行</strong>：组件 A 和 B 依次运行。注意，它们之间不直接传递参数，而是通过 <code>Slot</code> 这个公共区域来交换数据。这大大降低了耦合度！</li>\n</ol>\n<h2 id=\"4-快速上手示例\">4. 快速上手示例</h2>\n<p>光说不练假把式，咱们看个最简单的 Spring Boot 集成例子。</p>\n<h3 id=\"第一步定义组件\">第一步：定义组件</h3>\n<pre><code class=\"language-java\">@LiteflowComponent(\"a\")\npublic class ACmp extends NodeComponent {\n    @Override\n    public void process() {\n        System.out.println(\"ACmp executed!\");\n        // 往上下文放点东西\n        this.getContextBean(DefaultContext.class).setData(\"data\", \"hello\");\n    }\n}\n\n@LiteflowComponent(\"b\")\npublic class BCmp extends NodeComponent {\n    @Override\n    public void process() {\n        System.out.println(\"BCmp executed!\");\n        // 从上下文拿东西\n        String data = this.getContextBean(DefaultContext.class).getData(\"data\");\n        System.out.println(\"Data from A: \" + data);\n    }\n}\n</code></pre>\n<h3 id=\"第二步定义规则-flowelxml\">第二步：定义规则 (flow.el.xml)</h3>\n<pre><code class=\"language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;flow&gt;\n    &lt;chain name=\"chain1\"&gt;\n        THEN(a, b);\n    &lt;/chain&gt;\n&lt;/flow&gt;\n</code></pre>\n<h3 id=\"第三步启动执行\">第三步：启动执行</h3>\n<pre><code class=\"language-java\">@Component\npublic class TestRunner implements CommandLineRunner {\n    \n    @Resource\n    private FlowExecutor flowExecutor;\n\n    @Override\n    public void run(String... args) throws Exception {\n        LiteflowResponse response = flowExecutor.execute2Resp(\"chain1\", \"arg\");\n        if (response.isSuccess()){\n            System.out.println(\"执行成功\");\n        }\n    }\n}\n</code></pre>\n<h2 id=\"5-总结\">5. 总结</h2>\n<p>这一篇我们主要通过白话的方式介绍了 LiteFlow 的“世界观”。</p>\n<ul>\n<li><strong>它的核心价值</strong>：解耦。把“做什么”（Component）和“怎么做”（Rule）分开了。</li>\n<li><strong>它的运行方式</strong>：FlowExecutor 接收指令 -&gt; FlowBus 查找流程 -&gt; Chain 调度组件 -&gt; Slot 传递数据。</li>\n</ul>\n<p>LiteFlow 就像一个精密的生产线指挥系统，你只需要负责造零件（组件）和画图纸（规则），剩下的调度工作，它全包了。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-25 12:50</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wasp520\">wasp</a>&nbsp;\n阅读(<span id=\"post_view_count\">129</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "链表的基本操作，用链表实现线性表",
      "link": "https://www.cnblogs.com/student-z/p/19376618",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/student-z/p/19376618\" id=\"cb_post_title_url\" title=\"发布于 2025-12-25 21:45\">\n    <span>链表的基本操作，用链表实现线性表</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>链表</p>\n<p>增删改查<br />\n指针指向等于地址赋值<br />\n定义一个链表结构体</p>\n<pre><code class=\"language-c\">typedef struct _NODE_ {\n\tint number;\n\tstruct _NODE* next; \n}Node,*Lintlist;\n</code></pre>\n<p>这里的node是对节点命名时的数据类型<br />\nLinklist是对该链表命名时的数据类型<br />\n初始化<br />\n1.建立一个链表<br />\n2.申请一个头节点</p>\n<pre><code class=\"language-c\">Linklist init(Linklist l) {\n\tNode* head = (Node*)malloc(sizeof(Node));\n\tif (head == NULL) {\n\t\tprintf(\"内存分配失败\");\n\t\treturn NULL;\n\t}\n\thead-&gt;next = NULL;\n\treturn head;\n}\n</code></pre>\n<p>在主函数中调用是</p>\n<pre><code class=\"language-c\">Linklist l=NULL;\nl = init(l);\n</code></pre>\n<p>也可以<br />\n<code>Linklist l=init(l);</code></p>\n<p>当然在这里也可以这样来<br />\n在这里函数的参数有没有都可以，因为其本质要的是申请的这个节点的地址也就是head的值<br />\n在主函数中他会把这个返回值赋值给l；<br />\n包括这里的函数类型也可以换成Node*如下</p>\n<pre><code class=\"language-c\">Node* init() {\n\tNode* head = (Node*)malloc(sizeof(Node));\n\tif (head == NULL) {\n\t\tprintf(\"内存分配失败\");\n\t\treturn NULL;\n\t}\n\thead-&gt;next = NULL;\n\treturn head;\n}\n</code></pre>\n<p>在主函数中调用就是<br />\n<code>Linklist l=init();</code></p>\n<p>增加操作<br />\n分为三种，分别为头插法，尾插法，以及在指定位置增加，<br />\n这里分为三种操作的一个原因就是增加可读性<br />\n还有一个原因是这样能帮助我们写代码<br />\n不需要判断各种临界情况<br />\n代码不会复杂，相对简单。</p>\n<p>头插法</p>\n<pre><code class=\"language-c\">Linklist head_add(Linklist l, int m) {\n\tNode* s = (Node*)malloc(sizeof(Node));\n\tif (s == NULL) {\n\t\tprintf(\"内存分配失败\");\n\t\treturn l;\n\t}\n\ts-&gt;next = l-&gt;next;\n\ts-&gt;number = m;\n\tl-&gt;next = s;\n\treturn l;\n}\n</code></pre>\n<p>在这里有两个点需要注意<br />\n第一点，头指针的指针域数值在改变的时候不能让链表断裂，比如</p>\n<pre><code class=\"language-c\">l-&gt;next = s;\ns-&gt;next = l-&gt;next;\n</code></pre>\n<p>在这里我们先让头指针的指针域指向了s<br />\n但这里就会导致一个问题，我们原本在这个指针域里面存储的地址丢了<br />\n我们再执行<br />\n<code>s-&gt;next = l-&gt;next;</code><br />\n就会 让s的next指向自己<br />\n就会导致后续链表的断裂<br />\n所以我们在改变链表的指针域时，最重要的就是不能让链表断裂，即不能让数据丢失</p>\n<p>第二点<br />\n在返回值上，我们其实可以让返回值为void<br />\n因为在这个函数里面其实我们没有动l的值<br />\nl里面是一个指针，而这个指针指向了一个我们声明的结构体类型的数据<br />\n我们是根据这个指针访问这个结构体类型的数据，然后更改这个结构体内的一些数据<br />\n我们并没有对l这个变量里面存储的数据进行改变<br />\n所以我们可以用void<br />\n而在上面我们用Link list这个作为返回值的原因是<br />\n在我们对l的理解中，l指的是这个链表<br />\n对于这个链表实际上是发生了变化的<br />\n所以我们在这里用了返回值<br />\n接下来的尾插法和指定位置插入都有这个问题。</p>\n<p>尾插法<br />\n1.找到未节点<br />\n2.构建一个节点插在为节点后面</p>\n<pre><code class=\"language-c\">Linklist rear_add(Linklist l, int m) {\n\tNode* p = l;\n\twhile (p-&gt;next) {\n\t\tp = p-&gt;next;\n\t}\n\t\n\t\n\tNode* s = (Node*)malloc(sizeof(Node));\n\tif (s == NULL) {\n\t\tprintf(\"内存分配失败\");\n\t\t\n\t\treturn l;\n\t}\n\ts-&gt;number = m;\n\ts-&gt;next = NULL;\n\tp-&gt;next = s;\n\treturn l;\n}\n</code></pre>\n<p>指定位置插入<br />\n1.找到指定位置（这里可以来一个find函数）<br />\n接下来的操作是基于find函数进行的<br />\nfind函数在后面紧挨着<br />\n2.通过find函数的返回值确认后续操作<br />\n3，如果是NULL则没有找的该数据，无法执行插入操作<br />\n4.找到之后，就构建新的节点插入</p>\n<pre><code class=\"language-c\">Linklist rear_add(Linklist l, int m) {\n\tNode* p = l;\n\twhile (p-&gt;next) {\n\t\tp = p-&gt;next;\n\t}\n\t\n\t\n\tNode* s = (Node*)malloc(sizeof(Node));\n\tif (s == NULL) {\n\t\tprintf(\"内存分配失败\");\n\t\treturn l;\n\t}\n\ts-&gt;number = m;\n\ts-&gt;next = NULL;\n\tp-&gt;next = s;\n\treturn l;\n}\n</code></pre>\n<p>查，<br />\n找到指定数据的节点，然后根据查找结果确定返回值</p>\n<pre><code class=\"language-c\">Node* find(Linklist l, int k) {\n\t\n\tNode* q = l-&gt;next;\n\twhile (q &amp;&amp; q-&gt;number != k) {\n\t\n\t\tq = q-&gt;next;\n\t}\n\treturn q;\n}\n</code></pre>\n<p>删，<br />\n删除指定数据，在这里不能通过查找函数，是因为在删除操作里我们要涉及前面的一个节点的指针域<br />\n在双向链表中就可以通过find函数进行查找了，因为在双向链表中，节点内包含着前节点的地址</p>\n<pre><code class=\"language-c\">Linklist delet(Linklist l, int k) {\n\t//k为删减的值\n\tNode* p = l;\n\tNode* q = l-&gt;next;\n\twhile (q &amp;&amp; q-&gt;number != k) {\n\t\tp = q;\n\t\tq = q-&gt;next;\n\t}\n\tif (q==NULL) {\n\t\tprintf(\"未找到该数据，不能执行删除操作\\n\");\n\t\treturn l;\n\t}\n\tp-&gt;next = q-&gt;next;\n\t\n\tfree(q);\n\tq = NULL;\n\treturn l;\n}\n\n</code></pre>\n<p>改，<br />\n最简单的操作，可以选择通过find函数也可以直接查找，因为这个函数不涉及指针的改变</p>\n<pre><code class=\"language-c\">Linklist change(Linklist l, int k,int m) {\n\tNode* p = find(l, k);\n\tif (p == NULL) {\n\t\tprintf(\"未找到该数据，不能实行数据更改操作\\n\");\n\t\treturn l;\n\t}\n\tp-&gt;number = m;\n\treturn l;\n}\n\n</code></pre>\n<p>输出函数<br />\n输出链表值</p>\n<pre><code class=\"language-c\">void printff(Linklist l) {\n\tNode* p = l-&gt;next;\n\twhile (p) {\n\t\tprintf(\"%d \", p-&gt;number);\n\t\tp = p-&gt;next;\n\t}\n\tprintf(\"\\n\");\n}\n</code></pre>\n<p>下面时主函数的调用</p>\n<pre><code class=\"language-c\">int main() \n{\n\tLinklist l=NULL;\n\tl = init(l);\n\tl = head_add(l, 3);\n\tl = head_add(l, 9);\n\tl = head_add(l, 5);\n\tprintff(l);\n\tl = rear_add(l, 8);\n\tl = rear_add(l, 4);\n\tl = rear_add(l, 6);\n\tprintff(l);\n\tl = inadd(l,3, 15);\n\tl = inadd(l, 10, 16);\n\tl = inadd(l, 9, 12);\n\tprintff(l);\n\tl = delet(l, 4);\n\tl = delet(l, 8);\n\tl = delet(l, 16);\n\tprintff(l);\n\tl = change(l, 4, 43);\n\tprintff(l);\n\treturn 0;\n}\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-25 21:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/student-z\">爱偷懒的我</a>&nbsp;\n阅读(<span id=\"post_view_count\">14</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MAUI库推荐三：Syncfusion.Maui.Toolkit",
      "link": "https://www.cnblogs.com/sesametech-dotnet/p/19401006",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sesametech-dotnet/p/19401006\" id=\"cb_post_title_url\" title=\"发布于 2025-12-25 21:28\">\n    <span>MAUI库推荐三：Syncfusion.Maui.Toolkit</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"项目介绍\">项目介绍</h2>\n<p><code>Syncfusion Toolkit for .NET MAUI</code>提供高质量的UI控件，帮助你从单个代码库中为iOS、Android、macOS和Windows构建丰富的高性能应用程序。</p>\n<p>使用这个工具包，开发人员可以以最小的努力交付美观、功能丰富的应用程序，缩短开发时间，同时确保跨平台的无缝和引人入胜的用户体验。</p>\n<h2 id=\"项目地址\">项目地址</h2>\n<p><a href=\"https://github.com/syncfusion/maui-toolkit\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/syncfusion/maui-toolkit</a></p>\n<p>本项目采用<code>MIT</code>授权。</p>\n<p>文档地址<br />\n<a href=\"https://help.syncfusion.com/maui-toolkit/introduction/overview\" rel=\"noopener nofollow\" target=\"_blank\">https://help.syncfusion.com/maui-toolkit/introduction/overview</a></p>\n<h2 id=\"控件列表\">控件列表</h2>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>控件</th>\n<th>库中名称</th>\n<th>表现</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据可视化</td>\n<td><code>Cartesian Charts</code></td>\n<td><code>SfCartesianChart</code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td></td>\n<td><code>Circular Charts</code></td>\n<td><code>SfCircularChart</code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td></td>\n<td><code>Funnel Charts</code></td>\n<td><code>SfFunnelChart</code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td></td>\n<td><code>Polar Charts</code></td>\n<td><code>SfPolarChart</code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td></td>\n<td><code>Pyramid Charts</code></td>\n<td><code>SfPyramidChart</code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td></td>\n<td><code>Spark Charts</code></td>\n<td><code>SfSparkLineChart</code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td></td>\n<td><code>Sunburst Charts</code></td>\n<td><code>SfSunburstChart</code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td>日历</td>\n<td><code>Calendar</code></td>\n<td><code>SfCalendar </code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td>编辑控件</td>\n<td><code>Date Picker</code></td>\n<td><code>SfDatePicker </code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td></td>\n<td><code>Date Time Picker</code></td>\n<td><code>SfDateTimePicker </code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td></td>\n<td><code>Numeric Entry</code></td>\n<td><code>SfNumericEntry </code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td></td>\n<td><code>Numeric Up Down</code></td>\n<td><code>SfNumericUpDown </code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td></td>\n<td><code>OTP Input</code></td>\n<td><code>SfOtpInput </code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td></td>\n<td><code>Picker</code></td>\n<td><code>SfPicker </code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td></td>\n<td><code>Time Picker</code></td>\n<td><code>SfTimePicker</code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td>导航</td>\n<td><code>Bottom Sheet</code></td>\n<td><code>SfBottomSheet</code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td></td>\n<td><code>Navigation Drawer</code></td>\n<td><code>SfNavigationDrawer</code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td></td>\n<td><code>Tab View</code></td>\n<td><code>SfTabView </code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td>布局</td>\n<td><code>Accordion</code></td>\n<td><code>SfAccordion</code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td></td>\n<td><code>Cards</code></td>\n<td><code>SfCardView</code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td></td>\n<td><code>Carousel</code></td>\n<td><code>SfCarousel</code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td></td>\n<td><code>Expander</code></td>\n<td><code>SfExpander</code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td></td>\n<td><code>Popup</code></td>\n<td><code>SfPopup </code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td></td>\n<td><code>Text Input Layout</code></td>\n<td><code>SfTextInputLayout</code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td>按钮</td>\n<td><code>Button</code></td>\n<td><code>SfButton</code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td></td>\n<td><code>Chips</code></td>\n<td><code>SfChip </code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td></td>\n<td><code>Segmented Control</code></td>\n<td><code>SfSegmentedControl</code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td>通知</td>\n<td><code>Circular Progress Bar</code></td>\n<td><code>SfCircularProgressBar</code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td></td>\n<td><code>Linear Progress Bar</code></td>\n<td><code>SfLinearProgressBar</code></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td></td>\n<td><code>Pull to Refresh</code></td>\n<td><code>SfPullToRefresh </code></td>\n<td><img alt=\"maui-pull-to-refresh-push-mode\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td>杂项</td>\n<td><code>Effects View</code></td>\n<td><code>SfEffectsView </code></td>\n<td><img alt=\"rippleeffect\" class=\"lazyload\" /></td>\n</tr>\n<tr>\n<td></td>\n<td><code>Shimmer</code></td>\n<td><code>SfShimmer</code></td>\n<td><img alt=\"maui-circle-persona\" class=\"lazyload\" /></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"使用方法\">使用方法</h2>\n<h4 id=\"包引用\">包引用</h4>\n<p>通过<code>Nuget</code>安装包<code>Syncfusion® Toolkit for .NET MAUI</code></p>\n<pre><code class=\"language-powershell\">dotnet add package Syncfusion.Maui.Toolkit\n</code></pre>\n<p>或者直接在csproj文件中添加：</p>\n<pre><code class=\"language-csharp\">&lt;PackageReference Include=\"Syncfusion.Maui.Toolkit\" Version=\"x.x.x\" /&gt;\n</code></pre>\n<h4 id=\"配置\">配置</h4>\n<pre><code class=\"language-csharp\">using Syncfusion.Maui.Toolkit.Hosting;\n\npublic static class MauiProgram\n{\n\tpublic static MauiApp CreateMauiApp()\n\t{\n\t\tvar builder = MauiApp.CreateBuilder();\n\t\tbuilder\n\t\t.UseMauiApp&lt;App&gt;()\n\t\t// Initialize the Syncfusion .NET MAUI Toolkit by adding the below line of code\n\t\t.ConfigureSyncfusionToolkit()\n\t\t// After initializing the Syncfusion .NET MAUI Toolkit, optionally add additional fonts\n\t\t.ConfigureFonts(fonts =&gt;\n\t\t{\n\t\t\tfonts.AddFont(\"OpenSans-Regular.ttf\", \"OpenSansRegular\");\n\t\t\tfonts.AddFont(\"OpenSans-Semibold.ttf\", \"OpenSansSemibold\");\n\t\t});\n\n\t\t// Continue initializing your .NET MAUI App here\n\n\t\treturn builder.Build();\n\t}\n}\n</code></pre>\n<p>为了在XAML中使用工具包，可以使用这个命名空间：</p>\n<pre><code>xmlns:toolkit=\"http://schemas.syncfusion.com/maui/toolkit\"\n</code></pre>\n<p>这样的话，就可以直接在XAML中使用了相关控件了。</p>\n<h2 id=\"关于syncfusion\">关于<code>Syncfusion</code></h2>\n<p><code>Syncfusion</code>成立于2001年，总部位于北卡罗来纳州三角研究园，拥有35000多家客户和100多万用户，其中包括大型金融机构、财富500强企业和全球IT咨询公司。<br />\n<code>Syncfusion</code>还具有很多好用的收费控件库，对于有实力的公司可以进行有偿使用。</p>\n<p>此文已在公众号：MAUI与Avalonia开启原创，欢迎关注与转载。</p>\n\n</div>\n<div id=\"MySignature\">\n    <div>作者：<a href=\"https://www.cnblogs.com/sesametech-netcore/\" target=\"_blank\">芝麻麻雀</a></div>\n<div>出处：<a href=\"https://www.cnblogs.com/sesametech-netcore/\" target=\"_blank\">https://www.cnblogs.com/sesametech-netcore/</a></div>\n<div>本文版权归作者和博客园共有，欢迎转载，但必须给出原文链接，并保留此段声明，否则保留追究法律责任的权利。 </div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-25 21:28</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sesametech-dotnet\">芝麻科技</a>&nbsp;\n阅读(<span id=\"post_view_count\">16</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "在 Kubernetes 中部署 LiteLLM",
      "link": "https://www.cnblogs.com/manuscript/p/19394205",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/manuscript/p/19394205\" id=\"cb_post_title_url\" title=\"发布于 2025-12-25 21:20\">\n    <span>在 Kubernetes 中部署 LiteLLM</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"前言\">前言</h1>\n<p>本文仅为 LiteLLM 部署流程，非 LiteLLM 使用教程。</p>\n<p>部署环境：阿里云ACK<br />\n部署方式：PostgreSQL + Redis + LiteLLM<br />\n参考链接：<a href=\"https://docs.litellm.ai/docs/proxy/deploy#deploy-with-database--redis\" rel=\"noopener nofollow\" target=\"_blank\" title=\"官网文档\">官网文档</a></p>\n<h1 id=\"litellm-部署流程\">LiteLLM 部署流程</h1>\n<h2 id=\"redis-部署\">Redis 部署</h2>\n<p>可实现多个 litellm 容器间的负载均衡<br />\n本次使用 bitnami 提供的 redis 版本，yaml 文件中使用的环境变量可参考<a href=\"https://hub.docker.com/r/bitnami/redis#customizable-environment-variables\" rel=\"noopener nofollow\" target=\"_blank\" title=\"对应文档\">对应文档</a>添加或更改</p>\n<blockquote>\n<p>需要注意的是，bitnami 在 2025 下半年终止了免费镜像的提供。本次 yaml 中不提供具体镜像地址，可自行去<a href=\"https://docker.aityp.com/\" rel=\"noopener nofollow\" target=\"_blank\" title=\"渡渡鸟\">渡渡鸟</a>或其他镜像站同步</p>\n</blockquote>\n<pre><code class=\"language-yaml\">apiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  annotations:\n  labels:\n    app.kubernetes.io/component: master\n    app.kubernetes.io/instance: litellm\n    app.kubernetes.io/name: redis\n  name: litellm-redis-master\n  namespace: litellm\nspec:\n  podManagementPolicy: OrderedReady\n  replicas: 1\n  selector:\n    matchLabels:\n      app.kubernetes.io/component: master\n      app.kubernetes.io/instance: litellm\n      app.kubernetes.io/name: redis\n  serviceName: litellm-redis-headless\n  template:\n    metadata:\n      annotations:\n      labels:\n        app.kubernetes.io/component: master\n        app.kubernetes.io/instance: litellm\n        app.kubernetes.io/name: redis\n    spec:\n      containers:\n      - args:\n        - -c\n        - /opt/bitnami/scripts/start-scripts/start-master.sh\n        command:\n        - /bin/bash\n        env:\n        - name: BITNAMI_DEBUG\n          value: \"false\"\n        - name: REDIS_REPLICATION_MODE\n          value: master\n        - name: ALLOW_EMPTY_PASSWORD\n          value: \"no\"\n        - name: REDIS_PASSWORD\n          valueFrom:\n            secretKeyRef:\n              key: redis-password\n              name: litellm-redis\n        - name: REDIS_TLS_ENABLED\n          value: \"no\"\n        - name: REDIS_PORT\n          value: \"6379\"\n        image:   ## FIXME: 本次使用 bitnami 提供的 redos:7.0.12\n        imagePullPolicy: IfNotPresent\n        livenessProbe:\n          exec:\n            command:\n            - sh\n            - -c\n            - /health/ping_liveness_local.sh 5\n          failureThreshold: 5\n          initialDelaySeconds: 20\n          periodSeconds: 5\n          successThreshold: 1\n          timeoutSeconds: 6\n        name: redis\n        ports:\n        - containerPort: 6379\n          name: redis\n          protocol: TCP\n        readinessProbe:\n          exec:\n            command:\n            - sh\n            - -c\n            - /health/ping_readiness_local.sh 1\n          failureThreshold: 5\n          initialDelaySeconds: 20\n          periodSeconds: 5\n          successThreshold: 1\n          timeoutSeconds: 2\n        securityContext:\n          runAsUser: 1001\n        volumeMounts:\n        - mountPath: /opt/bitnami/scripts/start-scripts\n          name: start-scripts\n        - mountPath: /health\n          name: health\n        - mountPath: /data\n          name: redis-data\n        - mountPath: /opt/bitnami/redis/mounted-etc\n          name: config\n        - mountPath: /opt/bitnami/redis/etc/\n          name: redis-tmp-conf\n        - mountPath: /tmp\n          name: tmp\n      dnsPolicy: ClusterFirst\n      imagePullSecrets:\n      - name: deepflow\n      restartPolicy: Always\n      schedulerName: default-scheduler\n      securityContext:\n        fsGroup: 1001\n      terminationGracePeriodSeconds: 30\n      volumes:\n      - configMap:\n          defaultMode: 493\n          name: litellm-redis-scripts\n        name: start-scripts\n      - configMap:\n          defaultMode: 493\n          name: litellm-redis-health\n        name: health\n      - configMap:\n          defaultMode: 420\n          name: litellm-redis-configuration\n        name: config\n      - emptyDir: {}\n        name: redis-tmp-conf\n      - emptyDir: {}\n        name: tmp\n      ## 本次使用 emptyDir 方式临时存储数据\n      - emptyDir: {}\n        name: redis-data\n  ## 此处可自行选择使用 PVC 或者 emptyDir 方式存储数据\n  # volumeClaimTemplates:\n  # - apiVersion: v1\n  #   kind: PersistentVolumeClaim\n  #   metadata:\n  #     labels:\n  #       app.kubernetes.io/component: master\n  #       app.kubernetes.io/instance: litellm\n  #       app.kubernetes.io/name: redis\n  #     name: redis-data\n  #     namespace: litellm\n  #   spec:\n  #     accessModes:\n  #     - ReadWriteOnce\n  #     resources:\n  #       requests:\n  #         storage: 20Gi\n  ## 需要注意的是,SC 并不通用(不同地区/节点可能无法使用同一个)\n  #     storageClassName: \"alicloud-disk-essd\"\n  #     volumeMode: Filesystem\n\n---\napiVersion: v1\ndata:\n  master.conf: |-\n    dir /data\n    # User-supplied master configuration:\n    rename-command FLUSHDB \"\"\n    rename-command FLUSHALL \"\"\n    # End of master configuration\n  redis.conf: |-\n    # User-supplied common configuration:\n    # Enable AOF https://redis.io/topics/persistence#append-only-file\n    appendonly yes\n    # Disable RDB persistence, AOF persistence already enabled.\n    save \"\"\n    # End of common configuration\n  replica.conf: |-\n    dir /data\n    # User-supplied replica configuration:\n    rename-command FLUSHDB \"\"\n    rename-command FLUSHALL \"\"\n    # End of replica configuration\nkind: ConfigMap\nmetadata:\n  annotations:\n  labels:\n    app.kubernetes.io/instance: litellm\n    app.kubernetes.io/name: redis\n  name: litellm-redis-configuration\n  namespace: litellm\n\n---\napiVersion: v1\ndata:\n  ping_liveness_local.sh: |-\n    #!/bin/bash\n\n    [[ -f $REDIS_PASSWORD_FILE ]] &amp;&amp; export REDIS_PASSWORD=\"$(&lt; \"${REDIS_PASSWORD_FILE}\")\"\n    [[ -n \"$REDIS_PASSWORD\" ]] &amp;&amp; export REDISCLI_AUTH=\"$REDIS_PASSWORD\"\n    response=$(\n      timeout -s 3 $1 \\\n      redis-cli \\\n        -h localhost \\\n        -p $REDIS_PORT \\\n        ping\n    )\n    if [ \"$?\" -eq \"124\" ]; then\n      echo \"Timed out\"\n      exit 1\n    fi\n    responseFirstWord=$(echo $response | head -n1 | awk '{print $1;}')\n    if [ \"$response\" != \"PONG\" ] &amp;&amp; [ \"$responseFirstWord\" != \"LOADING\" ] &amp;&amp; [ \"$responseFirstWord\" != \"MASTERDOWN\" ]; then\n      echo \"$response\"\n      exit 1\n    fi\n  ping_liveness_local_and_master.sh: |-\n    script_dir=\"$(dirname \"$0\")\"\n    exit_status=0\n    \"$script_dir/ping_liveness_local.sh\" $1 || exit_status=$?\n    \"$script_dir/ping_liveness_master.sh\" $1 || exit_status=$?\n    exit $exit_status\n  ping_liveness_master.sh: |-\n    #!/bin/bash\n\n    [[ -f $REDIS_MASTER_PASSWORD_FILE ]] &amp;&amp; export REDIS_MASTER_PASSWORD=\"$(&lt; \"${REDIS_MASTER_PASSWORD_FILE}\")\"\n    [[ -n \"$REDIS_MASTER_PASSWORD\" ]] &amp;&amp; export REDISCLI_AUTH=\"$REDIS_MASTER_PASSWORD\"\n    response=$(\n      timeout -s 3 $1 \\\n      redis-cli \\\n        -h $REDIS_MASTER_HOST \\\n        -p $REDIS_MASTER_PORT_NUMBER \\\n        ping\n    )\n    if [ \"$?\" -eq \"124\" ]; then\n      echo \"Timed out\"\n      exit 1\n    fi\n    responseFirstWord=$(echo $response | head -n1 | awk '{print $1;}')\n    if [ \"$response\" != \"PONG\" ] &amp;&amp; [ \"$responseFirstWord\" != \"LOADING\" ]; then\n      echo \"$response\"\n      exit 1\n    fi\n  ping_readiness_local.sh: |-\n    #!/bin/bash\n\n    [[ -f $REDIS_PASSWORD_FILE ]] &amp;&amp; export REDIS_PASSWORD=\"$(&lt; \"${REDIS_PASSWORD_FILE}\")\"\n    [[ -n \"$REDIS_PASSWORD\" ]] &amp;&amp; export REDISCLI_AUTH=\"$REDIS_PASSWORD\"\n    response=$(\n      timeout -s 3 $1 \\\n      redis-cli \\\n        -h localhost \\\n        -p $REDIS_PORT \\\n        ping\n    )\n    if [ \"$?\" -eq \"124\" ]; then\n      echo \"Timed out\"\n      exit 1\n    fi\n    if [ \"$response\" != \"PONG\" ]; then\n      echo \"$response\"\n      exit 1\n    fi\n  ping_readiness_local_and_master.sh: |-\n    script_dir=\"$(dirname \"$0\")\"\n    exit_status=0\n    \"$script_dir/ping_readiness_local.sh\" $1 || exit_status=$?\n    \"$script_dir/ping_readiness_master.sh\" $1 || exit_status=$?\n    exit $exit_status\n  ping_readiness_master.sh: |-\n    #!/bin/bash\n\n    [[ -f $REDIS_MASTER_PASSWORD_FILE ]] &amp;&amp; export REDIS_MASTER_PASSWORD=\"$(&lt; \"${REDIS_MASTER_PASSWORD_FILE}\")\"\n    [[ -n \"$REDIS_MASTER_PASSWORD\" ]] &amp;&amp; export REDISCLI_AUTH=\"$REDIS_MASTER_PASSWORD\"\n    response=$(\n      timeout -s 3 $1 \\\n      redis-cli \\\n        -h $REDIS_MASTER_HOST \\\n        -p $REDIS_MASTER_PORT_NUMBER \\\n        ping\n    )\n    if [ \"$?\" -eq \"124\" ]; then\n      echo \"Timed out\"\n      exit 1\n    fi\n    if [ \"$response\" != \"PONG\" ]; then\n      echo \"$response\"\n      exit 1\n    fi\nkind: ConfigMap\nmetadata:\n  annotations:\n  labels:\n    app.kubernetes.io/instance: litellm\n    app.kubernetes.io/name: redis\n  name: litellm-redis-health\n  namespace: litellm\n\n---\napiVersion: v1\ndata:\n  start-master.sh: |\n    #!/bin/bash\n\n    [[ -f $REDIS_PASSWORD_FILE ]] &amp;&amp; export REDIS_PASSWORD=\"$(&lt; \"${REDIS_PASSWORD_FILE}\")\"\n    if [[ ! -f /opt/bitnami/redis/etc/master.conf ]];then\n        cp /opt/bitnami/redis/mounted-etc/master.conf /opt/bitnami/redis/etc/master.conf\n    fi\n    if [[ ! -f /opt/bitnami/redis/etc/redis.conf ]];then\n        cp /opt/bitnami/redis/mounted-etc/redis.conf /opt/bitnami/redis/etc/redis.conf\n    fi\n    ARGS=(\"--port\" \"${REDIS_PORT}\")\n    ARGS+=(\"--requirepass\" \"${REDIS_PASSWORD}\")\n    ARGS+=(\"--masterauth\" \"${REDIS_PASSWORD}\")\n    ARGS+=(\"--include\" \"/opt/bitnami/redis/etc/redis.conf\")\n    ARGS+=(\"--include\" \"/opt/bitnami/redis/etc/master.conf\")\n    exec redis-server \"${ARGS[@]}\"\nkind: ConfigMap\nmetadata:\n  annotations:\n  labels:\n    app.kubernetes.io/instance: litellm\n    app.kubernetes.io/name: redis\n  name: litellm-redis-scripts\n  namespace: litellm\n\n---\napiVersion: v1\ndata:\n  redis-password:  ## FIXME: 自行通过 base64 编码后设置 Redis 密码\nkind: Secret\nmetadata:\n  annotations:\n  labels:\n    app.kubernetes.io/instance: litellm\n    app.kubernetes.io/name: redis\n  name: litellm-redis\n  namespace: litellm\ntype: Opaque\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  annotations:\n  labels:\n    app.kubernetes.io/instance: litellm\n    app.kubernetes.io/name: redis\n  name: litellm-redis-headless\n  namespace: litellm\nspec:\n  clusterIP: None\n  clusterIPs:\n  - None\n  internalTrafficPolicy: Cluster\n  ipFamilies:\n  - IPv4\n  ipFamilyPolicy: SingleStack\n  ports:\n  - name: tcp-redis\n    port: 6379\n    protocol: TCP\n    targetPort: redis\n  publishNotReadyAddresses: true\n  selector:\n    app.kubernetes.io/instance: litellm\n    app.kubernetes.io/name: redis\n  type: ClusterIP\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  annotations:\n  labels:\n    app.kubernetes.io/component: master\n    app.kubernetes.io/instance: litellm\n    app.kubernetes.io/name: redis\n  name: litellm-redis-master\n  namespace: litellm\nspec:\n  internalTrafficPolicy: Cluster\n  ipFamilies:\n  - IPv4\n  ipFamilyPolicy: SingleStack\n  ports:\n  - name: tcp-redis\n    port: 6379\n    protocol: TCP\n    targetPort: redis\n  selector:\n    app.kubernetes.io/component: master\n    app.kubernetes.io/instance: litellm\n    app.kubernetes.io/name: redis\n  type: ClusterIP\n</code></pre>\n<h2 id=\"postgresql-部署\">PostgreSQL 部署</h2>\n<p>当使用 Postgres 作为后端数据库时，可以启用 <strong><code>虚拟 Key</code></strong> 和 <strong><code>费用追踪</code></strong> 功能：</p>\n<ul>\n<li>虚拟 Key：不是写在配置文件里的静态 key，而是存储在数据库中的逻辑 key。没有数据库就无法可靠地管理这些 Key。</li>\n<li>费用追踪：每一次模型调用都会持久化写入数据库，从而支持账单、配额等功能</li>\n</ul>\n<p>本次使用 bitnami 提供的 postgres 版本，yaml 文件中使用的环境变量可参考<a href=\"https://hub.docker.com/r/bitnami/postgresql#environment-variables\" rel=\"noopener nofollow\" target=\"_blank\" title=\"对应文档\">对应文档</a>添加或更改</p>\n<blockquote>\n<p>需要注意的是，bitnami 在 2025 下半年终止了免费镜像的提供。本次 yaml 中不提供具体镜像地址，可自行去<a href=\"https://docker.aityp.com/\" rel=\"noopener nofollow\" target=\"_blank\" title=\"渡渡鸟\">渡渡鸟</a>或其他镜像站同步</p>\n</blockquote>\n<pre><code class=\"language-yaml\">apiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  annotations:\n  labels:\n    app.kubernetes.io/component: primary\n    app.kubernetes.io/instance: litellm\n    app.kubernetes.io/name: postgresql\n  name: litellm-postgresql\n  namespace: litellm\nspec:\n  podManagementPolicy: OrderedReady\n  replicas: 1\n  selector:\n    matchLabels:\n      app.kubernetes.io/component: primary\n      app.kubernetes.io/instance: litellm\n      app.kubernetes.io/name: postgresql\n  serviceName: litellm-postgresql-hl\n  template:\n    metadata:\n      labels:\n        app.kubernetes.io/component: primary\n        app.kubernetes.io/instance: litellm\n        app.kubernetes.io/name: postgresql\n      name: litellm-postgresql\n    spec:\n      containers:\n      - env:\n        - name: BITNAMI_DEBUG\n          value: \"false\"\n        - name: POSTGRESQL_PORT_NUMBER\n          value: \"5432\"\n        - name: POSTGRESQL_VOLUME_DIR\n          value: /bitnami/postgresql\n        - name: PGDATA\n          value: /bitnami/postgresql/data\n        - name: POSTGRES_PASSWORD\n          valueFrom:\n            secretKeyRef:\n              key: postgres-password\n              name: litellm-postgresql\n        - name: POSTGRES_DB\n          value: litellm\n        - name: POSTGRESQL_ENABLE_LDAP\n          value: \"no\"\n        - name: POSTGRESQL_ENABLE_TLS\n          value: \"no\"\n        - name: POSTGRESQL_LOG_HOSTNAME\n          value: \"false\"\n        - name: POSTGRESQL_LOG_CONNECTIONS\n          value: \"false\"\n        - name: POSTGRESQL_LOG_DISCONNECTIONS\n          value: \"false\"\n        - name: POSTGRESQL_PGAUDIT_LOG_CATALOG\n          value: \"off\"\n        - name: POSTGRESQL_CLIENT_MIN_MESSAGES\n          value: error\n        - name: POSTGRESQL_SHARED_PRELOAD_LIBRARIES\n          value: pgaudit\n        image: ## FIXME: 本次使用 bitnami 提供的 postgresql:15.3.0-debian-11-r7\n        imagePullPolicy: IfNotPresent\n        livenessProbe:\n          exec:\n            command:\n            - /bin/sh\n            - -c\n            - exec pg_isready -U \"postgres\" -d \"dbname=litellm\" -h 127.0.0.1 -p 5432\n          failureThreshold: 6\n          initialDelaySeconds: 30\n          periodSeconds: 10\n          successThreshold: 1\n          timeoutSeconds: 5\n        name: postgresql\n        ports:\n        - containerPort: 5432\n          name: tcp-postgresql\n          protocol: TCP\n        readinessProbe:\n          exec:\n            ## 注: 此处 command 手动添加了通过 postgres 用户创建 litellm 库的步骤，便于 litellm 部署时直接引用\n            command:\n            - /bin/sh\n            - -c\n            - -e\n            - |\n              exec pg_isready -U \"postgres\" -d \"dbname=litellm\" -h 127.0.0.1 -p 5432\n              [ -f /opt/bitnami/postgresql/tmp/.initialized ] || [ -f /bitnami/postgresql/.initialized ]\n          failureThreshold: 6\n          initialDelaySeconds: 5\n          periodSeconds: 10\n          successThreshold: 1\n          timeoutSeconds: 5\n        resources:\n          requests:\n            cpu: 250m\n            memory: 256Mi\n        securityContext:\n          runAsUser: 1001\n        volumeMounts:\n        - mountPath: /dev/shm\n          name: dshm\n        - mountPath: /bitnami/postgresql\n          name: litellm-postgresql\n      dnsPolicy: ClusterFirst\n      restartPolicy: Always\n      securityContext:\n        fsGroup: 1001\n      volumes:\n      - emptyDir:\n          medium: Memory\n        name: dshm\n      ## 本次使用 emptyDir 方式临时存储\n      - emptyDir: {}\n        name: litellm-postgresql\n  ## 此处可自行选择使用 PVC 或者 emptyDir 方式存储数据\n  # volumeClaimTemplates:\n  # - apiVersion: v1\n  #   kind: PersistentVolumeClaim\n  #   metadata:\n  #     name: litellm-postgresql\n  #     namespace: litellm\n  #   spec:\n  #     accessModes:\n  #     - ReadWriteOnce\n  #     resources:\n  #       requests:\n  #         storage: 20Gi\n  #     storageClassName: \"alicloud-disk-topology-alltype\"\n  #     volumeMode: Filesystem\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  annotations:\n  labels:\n    app.kubernetes.io/component: primary\n    app.kubernetes.io/instance: litellm\n    app.kubernetes.io/name: postgresql\n  name: litellm-postgresql\n  namespace: litellm\nspec:\n  internalTrafficPolicy: Cluster\n  ipFamilies:\n  - IPv4\n  ipFamilyPolicy: SingleStack\n  ports:\n  - name: tcp-postgresql\n    port: 5432\n    protocol: TCP\n    targetPort: tcp-postgresql\n  selector:\n    app.kubernetes.io/component: primary\n    app.kubernetes.io/instance: litellm\n    app.kubernetes.io/name: postgresql\n  type: ClusterIP\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  annotations:\n  labels:\n    app.kubernetes.io/component: primary\n    app.kubernetes.io/instance: litellm\n    app.kubernetes.io/name: postgresql\n    service.alpha.kubernetes.io/tolerate-unready-endpoints: \"true\"\n  name: litellm-postgresql-hl\n  namespace: litellm\nspec:\n  internalTrafficPolicy: Cluster\n  ipFamilies:\n  - IPv4\n  ipFamilyPolicy: SingleStack\n  ports:\n  - name: tcp-postgresql\n    port: 5432\n    protocol: TCP\n    targetPort: tcp-postgresql\n  publishNotReadyAddresses: true\n  selector:\n    app.kubernetes.io/component: primary\n    app.kubernetes.io/instance: litellm\n    app.kubernetes.io/name: postgresql\n  type: ClusterIP\n\n---\napiVersion: v1\ndata:\n  postgres-password:   ## FIXME: 自行通过 base64 编码后设置 postgres 密码\nkind: Secret\nmetadata:\n  annotations:\n  labels:\n    app.kubernetes.io/instance: litellm\n    app.kubernetes.io/name: postgresql\n  name: litellm-postgresql\n  namespace: litellm\ntype: Opaque\n</code></pre>\n<h2 id=\"litellm-部署\">Litellm 部署</h2>\n<p>LiteLLM 是一个统一的 AI 接口代理服务，只需要对接 LiteLLM 一个地址，而不用关心后面到底接的是 OpenAI、Azure 或是其他厂商。</p>\n<pre><code class=\"language-yaml\">apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: litellm-config-file\n  namespace: litellm\ndata:\n  config.yaml: |\n    ## 对接 Redis,自行对应上方部署后的值\n    router_settings:\n      redis_host: &lt;redis host&gt;\n      redis_password: &lt;redis password&gt;\n      redis_port: &lt;redis port&gt;\n\n---\napiVersion: v1\nkind: Secret\ntype: Opaque\nmetadata:\n  name: litellm-secrets\n  namespace: litellm\ndata:\n  ## FIXME: 此变量的作用可参考官网链接,本文部署中未手动在 configMap 中配置 model_list,因此没啥用:\n  ## https://docs.litellm.ai/docs/proxy/deploy#kubernetes\n  CA_AZURE_OPENAI_API_KEY:\n\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: litellm-deployment\n  namespace: litellm\n  labels:\n    app: litellm\nspec:\n  selector:\n    matchLabels:\n      app: litellm\n  template:\n    metadata:\n      labels:\n        app: litellm\n    spec:\n      ## 注: 由于部署时网络环境原因，本次选择宿主机网络部署。\n      hostNetwork: true\n      dnsPolicy: ClusterFirstWithHostNet\n      containers:\n      - name: litellm\n        image: \"docker.litellm.ai/berriai/litellm:main-stable\"\n        args:\n          - \"--config\"\n          - \"/app/proxy_server_config.yaml\"\n        ports:\n        - containerPort: 4000\n        volumeMounts:\n        - name: config-volume\n          mountPath: /app/proxy_server_config.yaml\n          subPath: config.yaml\n        env:\n        ## 管理员密钥\n        - name: LITELLM_MASTER_KEY\n          value: \n        ## 连接 postgres 数据库\n        ## 查看 pgsql yaml 中 command 注释即可\n        ## postgresql://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;dbname&gt;\n        - name: DATABASE_URL\n          value: \n        envFrom:\n        - secretRef:\n            name: litellm-secrets\n      volumes:\n        - name: config-volume\n          configMap:\n            name: litellm-config-file\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: litellm-service\n  namespace: litellm\nspec:\n  selector:\n    app: litellm\n  ports:\n    - protocol: TCP\n      port: 4000\n  type: ClusterIP\n</code></pre>\n<h2 id=\"litellm-前端效果\">Litellm 前端效果</h2>\n<p><img alt=\"Snipaste_2025-12-25_21-18-05\" src=\"https://img2024.cnblogs.com/blog/3735354/202512/3735354-20251225211856730-1718643475.png\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-25 21:20</span>&nbsp;\n<a href=\"https://www.cnblogs.com/manuscript\">怎么还在写代码</a>&nbsp;\n阅读(<span id=\"post_view_count\">15</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}