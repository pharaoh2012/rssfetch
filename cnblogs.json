{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "Zq-蓝桥杯python-循环语句进阶",
      "link": "https://www.cnblogs.com/dylanzhou/p/19391957",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/dylanzhou/p/19391957\" id=\"cb_post_title_url\" title=\"发布于 2025-12-24 12:32\">\n    <span>Zq-蓝桥杯python-循环语句进阶</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"for循环回顾\">for循环回顾</h1>\n<p>for循环主要用于遍历一个序列（如列表、range生成的序列），其循环次数在开始前是确定的。</p>\n<h1 id=\"while循环当条件为真时重复\">while循环：当条件为真时重复</h1>\n<h3 id=\"基本语法\">基本语法</h3>\n<pre><code>while condition:\n    # 条件为True时，重复执行这里的代码\n    #（注意缩进）\n</code></pre>\n<h3 id=\"eg打印一到五\">eg：打印一到五</h3>\n<pre><code>#1.初始化循环变量\ncount = 1\n#2.检查循坏条件\nwhile count &lt;= 5:\n    print(count,end=' ')\n    # 3.更新循环变量\n\tcount += 1\n</code></pre>\n<h3 id=\"避免无限循环\">避免无限循环</h3>\n<p>while循环必须包含能改变循环条件的语句（如count += 1），否则条件将永远为True，程序会陷入\"无限循环\"。</p>\n<h1 id=\"break彻底退出循环\">break：彻底退出循环</h1>\n<h3 id=\"功能\">功能</h3>\n<p>break语句可以用来立即终止其所在的 <strong>当前层</strong>循环，程序将跳转到循环结构之后的下一行代码继续执行。</p>\n<h3 id=\"eg寻找并打印第一个偶数\">eg：寻找并打印第一个偶数</h3>\n<pre><code>numbers = [1, 3, 5, 8, 9, 10]\n\nfor num in numbers:\n    print(\"正在检查:\", num)\n    if num % 2 == 0:\n        print(\"找到了第一个偶数:\", num)\n        break #\n</code></pre>\n<h3 id=\"输出\">输出：</h3>\n<pre><code>正在检查: 1\n正在检查: 3\n正在检查: 5\n正在检查: 8\n找到了第一个偶数: 8\n循环结束\n</code></pre>\n<h1 id=\"continue跳出本次循环\">continue：跳出本次循环</h1>\n<h3 id=\"功能-1\">功能</h3>\n<p>continue语句用于结束当前这次循环，并立即开始下一次循环。循环体中continue之后的代码将被跳过。</p>\n<h3 id=\"eg只打印列表中的奇数\">eg.只打印列表中的奇数</h3>\n<pre><code>numbers = [1, 2, 3, 4, 5, 6]\nfor num in numbers:\n    if num % 2 == 0:\n        continue\n    print(\"奇数:\", num)\n</code></pre>\n<p><strong>输出：</strong></p>\n<pre><code>奇数: 1\n奇数: 3\n奇数: 5\n</code></pre>\n<h1 id=\"while-true与嵌套循环\">while True与嵌套循环</h1>\n<h3 id=\"while-true模式处理多组输入\">while True模式：处理多组输入</h3>\n<p>在算法竞赛中，题目有时会要求处理多组输入数据，直到遇到一个特定的结束标记（如输入0）。while True结合break是实现这种逻辑的经典模式。</p>\n<h3 id=\"嵌套循环\">嵌套循环</h3>\n<p>一个循环结构内部可以包含另一个完整的循环结构。<br />\n外层循环每执行一次，内层循环会 <strong>完整地</strong>执行一遍</p>\n<h1 id=\"breakcontinue的作用范围\">break/continue的作用范围</h1>\n<h3 id=\"break和continue的作用域\">'break'和'continue'的作用域</h3>\n<p>'break'和'continue'语句只会影响其所在的 <strong>最内层</strong>循环</p>\n<h1 id=\"如何跳出多层循环\">如何跳出多层循环?</h1>\n<h3 id=\"方法使用标志位flag\">方法：使用标志位（Flag）</h3>\n<p>我们可以定义一个外部的布尔变量（标志位），在内层循环中改变它，并在外层循环中检查它，从而实现多层跳出。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-24 12:32</span>&nbsp;\n<a href=\"https://www.cnblogs.com/dylanzhou\">森鹿执夏</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "大模型应用开发必需了解的基本概念",
      "link": "https://www.cnblogs.com/crossoverJie/p/19391958",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/crossoverJie/p/19391958\" id=\"cb_post_title_url\" title=\"发布于 2025-12-24 12:32\">\n    <span>大模型应用开发必需了解的基本概念</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"背景\">背景</h1>\n<p>AI/LLM 大模型最近几年毋庸置疑的是热度第一，虽然我日常一直在用 AI 提效，但真正使用大模型做一个应用的机会还是少。</p>\n<p>最近正好有这么个机会，需要将公司内部的代码 repo 转换为一个 wiki，同时还可以基于项目内容进行对话了解更具体的内容。</p>\n<p>实际效果大概和上半年很火的 <a href=\"https://deepwiki.com/redis/redis\" rel=\"noopener nofollow\" target=\"_blank\">deepwiki</a> 类似。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>而我们是想基于开源的 <a href=\"github.com/AsyncFuncAI/deepwiki-open\" rel=\"noopener nofollow\" target=\"_blank\">deepwiki-open</a>进行开发，提供的功能都是类似的。</p>\n<p>在这个过程中我也从一个大模型应用开发的小白逐步理解了其中的一些关键概念，以及了解了一个大模型应用的运行原理。</p>\n\n<h1 id=\"llm\">LLM</h1>\n<p>LLM（Large Language Model，大语言模型）大家应该都比较熟悉了：</p>\n<ul>\n<li>本质：一个通过海量文本训练出来的概率模型</li>\n<li>能力：理解/生成文本、代码，做推理、对话等</li>\n<li>特点：\n<ul>\n<li><strong>参数固定</strong>：训练完之后“记忆”是固化在参数里的</li>\n<li><strong>知识有时间点</strong>：只知道训练截止前的数据（有知识截止时间）</li>\n</ul>\n</li>\n</ul>\n<p>可以把&nbsp;<strong>LLM</strong>&nbsp;当成一个“通用大脑”，但不一定知道最新的、你的私有数据。</p>\n<p>目前的 AI 也就是大模型本质上还是概率预测，当你给它一段话（Prompt）时，它在后台做的事情是：<strong>“根据我读过的几万亿字，接在这段话后面，概率最高的下一个字（Token）是什么？”</strong></p>\n<p>所以大模型每次回答的内容可能不同，也不能 100% 的告诉你准确答案。</p>\n<h2 id=\"token\">Token</h2>\n<p>大模型并不直接认识<code>java</code>、<code>Rust</code> 或者“编程”这些词。在模型内部，所有的文字都会先被转换成一系列数字。</p>\n<ul>\n<li><strong>字/词 ≠ Token</strong>：一个 Token 既不是一个字符，也不是一个单纯的单词。</li>\n<li><strong>灵活切分</strong>：\n<ul>\n<li>常见的词（如&nbsp;<code>the</code>,&nbsp;<code>apple</code>）通常对应&nbsp;<strong>1 个 Token</strong>。</li>\n<li>罕见的词或长的复合词（如&nbsp;<code>microservices</code>）可能会被拆分成几个 Token（如&nbsp;<code>micro</code>&nbsp;+&nbsp;<code>services</code>）。</li>\n<li>中文通常比较特殊：一个常用的汉字可能是 1 个 Token，但不常用的汉字可能会占用 2-3 个 Token。</li>\n</ul>\n</li>\n</ul>\n<p>在做大模型应用开发的时候尤其需要注意 token 的用量，毕竟这是计费的标准。</p>\n<p>还有一个是上下文窗口的限制，每个模型都会有最大 token 的限制（如 8k, 32k, 128k）。</p>\n<p>如果你的 Prompt 加上模型的回复超过了这个限制，模型就会丢掉前面的记忆或者直接报错。</p>\n<p>在日常开发估算中，可以大概估算一下这个比例：</p>\n<ul>\n<li><strong>英文文本</strong>：1000 Tokens&nbsp;≈&nbsp;750 个单词。</li>\n<li><strong>中文文本</strong>：1000 Tokens&nbsp;≈&nbsp;500 到 600 个汉字（随着模型词表的演进，现在的模型处理中文的效率在不断提升。）。</li>\n<li><strong>代码</strong>：代码中的空格、缩进和特殊符号都会消耗 Token。Python 等由于缩进较多，消耗通常比纯文本快。</li>\n</ul>\n<p>也有相关的库可以帮我们计算 token：</p>\n<pre><code class=\"language-python\">  \n# Choose encoding based on embedder type  \nif embedder_type == 'ollama':  \n    # Ollama typically uses cl100k_base encoding  \n    encoding = tiktoken.get_encoding(\"cl100k_base\")  \nelif embedder_type == 'google':  \n    # Google uses similar tokenization to GPT models for rough estimation  \n    encoding = tiktoken.get_encoding(\"cl100k_base\")  \nelse:  # OpenAI or default  \n    # Use OpenAI embedding model encoding    \n    encoding = tiktoken.encoding_for_model(\"text-embedding-3-small\")  \n  \nreturn len(encoding.encode(text))\n</code></pre>\n<p>也可以通过 <a href=\"https://platform.openai.com/tokenizer\" rel=\"noopener nofollow\" target=\"_blank\">openai</a> 的一个实例网站来可视化查看 token 的计算规则：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<h1 id=\"rag\">RAG</h1>\n<p>RAG 的全程是Retrieval-Augmented Generation（检索增强生成），他不是类似于 LLM 的模型，而是一种架构模式。</p>\n<p>举个例子：<br />\n比如你问 ChatGPT 关于你们公司的某一个规章制度，大概率 ChatGPT 的训练语料是你没有你们公司的内部数据的。</p>\n<p>所以他回复你的多半是瞎编的内容，或者直接告诉你不知道。</p>\n<p>此时就需要 RAG 了，他可以在真正询问 LLM 之前先到内部的资料库里通过用户的问题将相关上下文查询出来，然后再拼接成一个完整的 prompt 发送给 LLM，让 LLM 根据你通过的数据进行回答。</p>\n<p>这样能解决一下三个问题：</p>\n<ol>\n<li><strong>幻觉问题</strong>：你问它一个它不知道的事情，它会一本正经地胡说八道。</li>\n<li><strong>知识过时</strong>：大模型的知识停留在它训练结束的那一天。</li>\n<li><strong>私有数据安全</strong>：你不能为了让 AI 懂你的业务代码，就把几百万行私有代码全发给模型提供商训练一个新模型，那太贵且不安全。</li>\n</ol>\n<p>使用 RAG 时还需要额外考虑到数据清洗的步骤，比如我们这里的 repo wiki 的场景，我们需要把一些第三方库、编译后产生的 target 目录等不需要的内容排除掉。</p>\n<p>避免在查询时带上这些内容，干扰最终的结果。</p>\n<h1 id=\"向量数据库\">向量数据库</h1>\n<p>上文里提到 RAG 模式，需要一个非常关键的组件，那就是向量数据库。</p>\n<p>我们先要在 RAG 里检索出相关的上下文就是在向量数据库里做查询，具体流程如下：</p>\n<ol>\n<li><strong>把文档切块</strong>（段落级别）</li>\n<li>用一个&nbsp;<strong>Embedding 模型</strong>&nbsp;把每个块转成向量</li>\n<li>把这些向量存进&nbsp;<strong>向量数据库</strong></li>\n<li>用户提问时，也把问题转成向量</li>\n<li>用向量相似度检索出最相关的文档块</li>\n<li>把这些文档块 + 问题喂给 LLM，让它生成答案</li>\n</ol>\n<p>简单来说就是将一些非结构化的数据（图片、视频、文字）通过<strong>Embedding 模型</strong>&nbsp;转换成一串数字数组，即<strong>向量</strong>（例如：<code>[0.12, -0.59, 0.88, ...]</code>）。</p>\n<p>查询的时候也会将查询内容转换为向量，然后返回在向量空间里相近的数据。</p>\n<h1 id=\"qa\">Q&amp;A</h1>\n<p>此时也许你会有以下一些问题：</p>\n<p>LLM + RAG + 向量数据库，是不是类似于用 LLM 训练私有化数据？这两者的效果是否类似？ 如果不同，区别在哪里？</p>\n<p>LLM + RAG + 向量数据库：</p>\n<ul>\n<li>\n<p>本质是：</p>\n<blockquote>\n<p>不改模型参数，用<strong>检索到的外部资料</strong>来“喂”模型，让它<strong>查完再答</strong>。</p>\n</blockquote>\n</li>\n<li>\n<p>你的数据在<strong>外部（向量数据库里）</strong>，只是当作参考材料塞进 prompt。</p>\n</li>\n</ul>\n<p>在私有数据上训练（微调 / 预训练）：</p>\n<ul>\n<li>\n<p>本质是：</p>\n<blockquote>\n<p>用你的数据<strong>更新模型参数</strong>，让模型“记住”这些模式和知识。</p>\n</blockquote>\n</li>\n<li>\n<p>你的数据被“烤进”模型权重里，调用时不需要再查这份数据。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>RAG（向量库）</th>\n<th>微调 / 私有训练</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>知识存放</td>\n<td>外部向量库</td>\n<td>模型参数里</td>\n</tr>\n<tr>\n<td>更新成本</td>\n<td>改文档即可，重建 / 增量向量索引</td>\n<td>需要重新训练部署</td>\n</tr>\n<tr>\n<td>生效时间</td>\n<td>几分钟级</td>\n<td>训练+上线，小时～天级</td>\n</tr>\n<tr>\n<td>支持频繁变更</td>\n<td>很适合</td>\n<td>很不适合</td>\n</tr>\n<tr>\n<td>透明度/可解释性</td>\n<td><strong>高</strong>（可以追溯到原文出处）</td>\n<td><strong>低</strong>（模型直接给出，无法确切知道来源）</td>\n</tr>\n</tbody>\n</table>\n<p>总的来说使用 RAG 外挂私有化向量数据的成本更低，也更灵活。<br />\n对于一些更垂直的场景，可以考虑使用私有数据训练模型。</p>\n<h1 id=\"总结\">总结</h1>\n<p>总体下来的感受是 LLM 应用大部分的<strong>代码</strong>都是 prompt 提示词，普通 app 的主要内容是代码，而不同大模型应用的主要区别是提示词；反而代码大部分都是趋同的。</p>\n<p>区别就是用了什么框架，但是共同的就是调用大模型 API，将传统的 request/reponse 的请求模式换为流式响应（大模型的响应很慢）。</p>\n<p>在开发应用时，需要了解&nbsp;<strong>System Prompt</strong>（系统预设角色）、<strong>User Prompt</strong>（用户提问）和&nbsp;<strong>Few-shot</strong>（给模型几个例子引导它）。好的 Prompt 是让 RAG 结果准确的关键。</p>\n<p>后续还需要更加完善 <code>deepwiki-open</code>：</p>\n<ul>\n<li>优化 splitter，使用更适合代码分割的 splitter，比如 <a href=\"https://tree-sitter.github.io/tree-sitter/\" rel=\"noopener nofollow\" target=\"_blank\">tree-sitter</a></li>\n<li>将存储在本地的向量替换为一个独立的向量数据库</li>\n<li>持续优化提示词，更加符合我们的项目背景</li>\n</ul>\n<h1 id=\"blog\">Blog</h1>\n\n</div>\n<div id=\"MySignature\">\n    <div style=\"font-size: small;\">\n\n<p>\n        作者： \n        <a href=\"https://crossoverjie.top/about/\">crossoverJie</a>\n</p>\n<p>\n        出处：\n        <a href=\"https://crossoverjie.top/\">https://crossoverjie.top</a>\n</p>\n<img src=\"https://i.loli.net/2019/05/19/5ce16dbc99cfa13989.jpg\" />\n<p>\n欢迎关注博主公众号与我交流。\n</p>\n<p>\n         本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出,\n            如有问题， 可邮件（crossoverJie#gmail.com）咨询。\n</p>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-24 12:32</span>&nbsp;\n<a href=\"https://www.cnblogs.com/crossoverJie\">crossoverJie</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "BI报表及可视化分析类工具使用经验总结（上）",
      "link": "https://www.cnblogs.com/davablog/p/19205294",
      "published": "",
      "description": "<h2>\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/davablog/p/19205294\" id=\"cb_post_title_url\" title=\"发布于 2025-12-24 12:04\">\n    <span>BI报表及可视化分析类工具使用经验总结（上）</span>\n    \n\n</a>\n\n\t\t</h2>\n\t\t<div class=\"postText\"><div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<div>作为数据工程师，必定会在日常工作中会频繁的使用到BI报表及可视化分析类工具。这些工具可以帮助领导或者一线业务人员快速的查看数据，发现数据规律，探查数据背后的业务价值。以下是基于十多年的工作经历中实际的使用经验，对这类工具进行的经验总结。</div>\n<div>\n<h1>一、工具列表</h1>\n</div>\n<p>以下是深度参与开发或者运维的工具（按照使用时间的先后顺序排列）：</p>\n<ol>\n<li>微软SSRS：曾在国外的某ToB数据营销供应商中使用，SSRS作为报表工具，常常配套SQL Server一并使用，与微软系列产品匹配度较高。数据源除了支持SQL Server之外，也支持Oracle、Teradata、DB2以及任何符合 ODBC/OLE DB 规范的数据源。工具使用便捷，上手容易。适合小型项目中使用。</li>\n<li>Oracle BIEE：曾在某OTA在线旅游公司中参与开发和运维，该工具被用于给近百位各条线一线业务人员及中层领导推送各类日报、周报数据。OBIEE特别的地方在与其数据集建模功能强大，可以利用三层模型来表示复杂的数据关系。但入门曲线较陡，使用较复杂目前OBIEE产品线已停止维护，后续由Oracle Analytics Server来替代。整体产品价格较贵。</li>\n<li>帆软FineReport：目前在某小型券商中开发基于该工具的报表，Finereport定位制式表格类报表，尤其擅长中国式复杂报表。整体功能强大，支持各类数据源（传统DBMS及大数据系统），支持嵌入脚本语言（javascript），可支持做一个简单的小型应用系统。</li>\n<li>网易有数BI：目前在某小型券商中参与采购选型并基于该平台进行数据报告及数据门户的开发。有数BI定位为数据可视化交互分析，页面美观，通过自带的数据门户功能可快速集成各类展示报告、填报入口及外部第三方网址，迅速搭建一个小型的应用系统。支持高性能缓存（如ClickHouse），支持移动端展示，价格较便宜，购买后不限制License数量。早期版本性能不太稳定，新的版本（如V9.0）已稳定很多。</li>\n<li>Excel：在没有BI工具的情况、数据量较小的情况下，Excel透视图也可以做简单的图表，如折线图，饼图等。</li>\n</ol>\n<p>以下是作为用户参与使用或评测的工具：</p>\n<ol>\n<li>Tableau：曾在某澳洲保险公司数据仓库项目中使用，作为国外的一款数据可视化和交互式分析工具，Tableau视觉效果卓越（据说是有心理学家参与设计视觉UI配色等方面），操作便捷，上手容易，常用于多维数据分析场景，适合数据分析师和数据科学家使用。缺点是License价格较贵（据说按照安装机器数量进行收费：Desktop, 一万左右一个， Server10万，只有10个账号，每增加一个账号需要2千）。</li>\n<li>Apache Superset：开源免费工具，最初源于 Airbnb 内部的一个 hackathon 项目，2022 年初成为 Apache 的顶级项目。除了作为数据可视化工具外，还可以当做数据开发工具（后台开启相应设置后，就可以针对数据源编写DDL/DML语句）。缺点：学习曲线较陡。</li>\n<li>Dataease：国产的一款小型开源BI工具，部署便捷。</li>\n<li>PowerBI：PowerBI定位为数据可视化分析工具，功能强大。</li>\n<li>FineBI：FineBI定位为可视化交互分析，按照开发用户数量收费，相对来说费用较高。</li>\n</ol>\n<h1>二、部署架构</h1>\n<p>软件部署一般分为C/S架构和B/S架构。C/S架构中C代表客户端，用户通过客户端可以直连本地的数据源，直接制作报告图表。B/S架构B代表浏览器，用户首先通过浏览器连接服务器，再基于服务器进行操作。另外还有混合架构，将客户端服务器端进行一体化部署。</p>\n<div>具体来看：</div>\n<div>1、C/S架构：主要有Tableau、SSRS，一般都是基于Windows环境部署客户端和服务器端。</div>\n<div><ol>\n<li>Tableau：采用Desktop客户端（只支持Windows或者MacOS图形化操作系统安装）进行开发，安装客户端的机器需要能与各类数据源服务器的网络联通上，利用Tableau Server来发布部署报告，这样报告使用者只需要用浏览器访问server服务器即可。Tableau public（只能安装在Windows服务器上）：用于静态报表发布（数据源数据无法动态更新获取最新数据）。&nbsp; &nbsp; &nbsp;&nbsp;</li>\n<li>SSRS：本地采用SSRS客户端软件进行开发（需要有访问数据源的权限），RDL/RDS/DATA等文件本地保存。发布时首先需要在服务器端安装SSRS服务，然后将本地报表文件上传至服务器。</li>\n</ol>\n<p>以下是典型的C/S架构的报表工具部署架构图（以Tableau为例）</p>\n<p><img alt=\"0\" class=\"lazyload\" height=\"144\" width=\"630\" /></p>\n</div>\n<div>&nbsp;</div>\n<div>2、B/S架构：主要有网易有数BI、OBIEE、Superset，一般都是基于Linux服务器后端进行部署，利用网页端进行报表设计。</div>\n<div><ol>\n<li>\n<p>网易有数BI：<span>整体应用部署在Linux环境服务器上，报告、数据源等各类元数据部署在Mysql数据库中（内置或者外接）。报表开发者无需使用客户端软件，直接连接服务器基于网页端进行开发。报表查看者同样基于网页进行访问。后台管理界面中可设置不同用户对同一张报表的访问权限。</span></p>\n</li>\n<li>OBIEE：基于后台服务器进行部署，开发时基于网页端进行报告开发。而数据集建模功能则需要在Windows环境中安装客户端连接服务器并在客户端中进行设计开发（模型保存成RPD文件）。</li>\n</ol>\n<p>以下是典型的B/S架构的报表部署架构图</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"228\" width=\"532\" /></p>\n<p>&nbsp;</p>\n</div>\n<div>总结：架构没有优劣，只有合适与否。实际选择架构时一般会根据企业的环境来适配。不同的企业中，环境管理差别较大，在外企中，数据类系统中往往会有开发环境、测试环境及生产环境。此时可采用C/S架构的工具，本地安装好客户端之后可以直接连接测试环境的数据源进行报表开发。当开发完成后，将报告发布到服务器上（需要将报告中的数据源替换成生产环境的数据源）。而如果企业中，只有一套环境（中小型民企比较常见），此时B/S架构的工具，可以直接部署到生产环境，连接各类数据源。通过反向代理等技术，可以将生产环境的服务器映射到办公网络，供开发人员或者测试人员进行使用。</div>\n<div>&nbsp;</div>\n<div>以上为各类BI报表及可视化分析类工具的架构分析，下一篇会针对各个工具的功能特性、性能调优以及典型应用场景进行总结。</div>\n</div>\n<div class=\"clear\"></div>\n</div>\n\t\t<p class=\"postfoot\">\n\t\t\tposted on \n<span id=\"post-date\">2025-12-24 12:04</span>&nbsp;\n<a href=\"https://www.cnblogs.com/davablog\">davawang</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</p>"
    },
    {
      "title": "问世间，exe是何物？直教AI沉默、Web寡言（1）",
      "link": "https://www.cnblogs.com/sunhui/p/19391507",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sunhui/p/19391507\" id=\"cb_post_title_url\" title=\"发布于 2025-12-24 11:22\">\n    <span>问世间，exe是何物？直教AI沉默、Web寡言（1）</span>\n    \n\n</a>\n</h1>\n\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本连载以《爱丽丝漫游奇境记》的叙事风格，系统接受一个全新的桌面应用开发技术：所有64位WinForm、MFC、WPF桌面应用，都是“超级Chromium浏览器”，这意味着：你的应用不需要修改源代码、无需重新编译，即可成为超越主流浏览器的Web浏览器，可以直接支持当下最新的AI、Web技术。这一个结论针对编译之后的桌面应用，您只需要确保您的编译、运行正常即可，对编译之前的代码，没有要求，不需要嵌入CEF、WebView2等浏览器控件。即使您没有这一类桌面应用的源代码，也可以直接为其写任意数量的Web页面\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>爱丽丝漫游WinForms应用开发奇境记（1）</p>\n<p><a href=\"https://github.com/AIGCEra/Creator/releases/download/FirstRelease/CreatorSetup.msi\" rel=\"noopener nofollow\">下载爱丽丝的镜子</a></p>\n<h1><strong>序言——送给每一位热衷于梦想的朋友</strong></h1>\n<p>爱丽丝认为，现代最伟大的魔法，都封装在那些以&nbsp;<strong>.exe</strong>&nbsp;结尾的小小符石里。<br />\n人们告诉她：“编译完成，魔法便已定型。”就像维多利亚时代的蝴蝶标本，被钢针固定在绒布上——美丽，但不再振翅。<br />\n她对此将信将疑。因为在她钟爱的“浏览器”窗口里，世界明明是活的：它会回应、会流动、会与她从云端苏醒的智能体朋友（它们叫ChatGPT、DeepSeek…）对话。<br />\n“为什么我的 .exe 不能这样？”她问。<br />\n她的编程老师，一位活在终端窗口里的隐士，回答道：“因为\n.exe 是理性的终点，是逻辑的琥珀。你要它生动，就得为它嵌入另一颗心——比如 CEF，或者 WebView2。”<br />\n爱丽丝的眉头皱成了困惑的涟漪。她听不懂这些咒语般的缩写。<br />\n直到那只穿马甲、怀表嘀嗒作响的兔子再次出现，嘟囔着一段更离奇的话：<br />\n“何必嵌入？每一个 .exe 生来就有一颗浏览器的灵魂，只是缺一面镜子将它唤醒……”<br />\n说完，他丢下一面看似普通的镜子，消失在数据流的荒原里。</p>\n<p><strong>&nbsp;</strong></p>\n<p>在 AI 与 Web 技术日新月异的时代，爱丽丝穿越时空归来，从奇境中为我们带来一面“镜子”。正如我们每个人都需要镜子来看见自己不断变化的模样，这面镜子也让我们看到：一个编译后的桌面应用（.exe），竟能呈现出无数种不同的面貌——每一个面貌，都是一个活生生的 Web 页面。从此，面对桌面应用 exe，AI 可以不再沉默、Web 也不必寡言……</p>\n<p>&nbsp;</p>\n<p>认知的牢笼，总需一面镜子来打破。亚里士多德时代的天文学家困于地心说，直至伽利略的望远镜将其升维至宇宙视角；而今，当你编译一个 .exe 并断言了解它时，你也困于同样的牢笼——你缺少的，正是一面能照见其数字本质的镜子，没有它，你的程序只是孤岛；拥有它，你便是伽利略——你将目睹 .exe 在镜中呈现的无数侧面：原生应用、完整的互联网浏览器，或一个你无法想象的数字智能体，正静候觉醒……</p>\n<p>&nbsp;</p>\n<p><strong>我们曾经以为我们编译的是“软件”——一个功能固定的工具。</strong><br />\n<strong>但或许，我们真正编译的是“智能体”的胚胎——一个被赋予基础感官（能接收输入）、基础神经（能调用系统API）、基础意识（能维持状态和逻辑）的生命。这个生命诞生后，其命运不再由最初的代码完全决定，而取决于它将被放入怎样的环境，以及它如何学习与环境共舞。</strong></p>\n<h1><strong>她是维多利亚时代的WinForms学徒</strong></h1>\n<p>爱丽丝不属于这个时代。</p>\n<p>她来自近两个世纪前的维多利亚时代。<br />\n眼前的一切——翱翔的铁鸟、永不熄灭的灯火、<br />\n在玻璃板上流动的影像——都让她目眩神迷。</p>\n<p>这是一个被数次工业革命烈火重塑的世界，<br />\n与她记忆中的故乡截然不同。</p>\n<p>在所有奇迹中，最让她着迷的，<br />\n是那个名为“浏览器”的窗口。</p>\n<p>“这小小的屏幕多么奇妙啊！”<br />\n她惊叹不已：“只需输入一行符号，仿佛念出咒语，<br />\n世界便在眼前展开。冰冷的文字秩序，化为鲜活的色彩与图景！”</p>\n<p>她常常一坐就是几个小时，<br />\n沉浸在这神秘的窗口之中。</p>\n<p>直到有一天，她听闻了更奇异的存在——<strong>大语言模型</strong>。</p>\n<p><strong>ChatGPT</strong>、<strong>DeepSeek</strong>……这些名字如魔法般传入她的耳中。<br />\n它们，难道比浏览器的魔法更强大？</p>\n<p>她迫不及待地去探寻，却被所见震撼：</p>\n<p>这些“<strong>模型”</strong>不仅理解她的提问，<br />\n还知晓她的来历、她的故土，<br />\n甚至——她那被尘封的维多利亚记忆。</p>\n<p>“这是什么巫术？”她捂住嘴，心脏狂跳，<br />\n“它们怎会知道我的秘密？<strong>Curiouser and curiouser!</strong>”</p>\n<p>惊讶之余，一个疯狂的念头萌生了——她要把这些奇迹带回她的时代。</p>\n<p>她要让蒸汽与齿轮的世界，沐浴在数字的曙光之下。</p>\n<p>于是，她开始学习现代的炼金术——<strong>编程</strong>。</p>\n<p>“我该从何开始？”她问。<br />\n老师答：“从 <strong>WinForms</strong> 开始，这是一种古老的技艺——<br />\n<strong>虽然如今或许陈旧，但若你将它带回十九世纪，<br />\n人们会奉你为神明。”</strong></p>\n<h1>二进制的绝对理性</h1>\n<p align=\"right\">——<strong><em>理性让世界稳定，却也可能抑制世界的生长</em></strong></p>\n<p>教科书以冰冷的确定性宣告：<br />\n“.exe 不是文本文件。<br />\n一旦编译，<br />\n逻辑便被封存——不可更改，<br />\n除非你重新编译。”</p>\n<p>爱丽丝觉得这古怪极了。<br />\n她钟爱的网页鲜活善变，<br />\n但这些 .exe 文件——它们究竟是什么？</p>\n<p style=\"text-align: left;\">带着一贯的反叛，<br />\n她用文本编辑器打开了一个刚编译好的 .exe：</p>\n<p style=\"text-align: center;\"><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/9494/202512/9494-20251224112159370-525395918.png\" />&nbsp;</p>\n<p>里面只有一片混沌——其中充斥着毫无意义的符号。<br />\n“我不信，”她低语，“如果我只删掉一个字符呢？肯定没事的。”</p>\n<p>她小心地编译了最简单的 WinForm，<br />\n确认它能运行，<br />\n然后——在好奇心的驱使下——<br />\n从二进制文件中删去了一个看上去毫无意义的字符。</p>\n<p>结果，程序再也无法启动了。</p>\n<p>爱丽丝用文本编辑器打开.exe失败后，并没有完全放弃。她尝试使用了一个名为&nbsp;ildasm&nbsp;的古老工具，像透过一片模糊的镜片一样，窥见了.exe内部的元数据表。她看到了许多奇怪的命名空间和类名，如同一个个被封存的真名（<strong>AssemblyQualifiedName</strong>）:</p>\n<p align=\"center\">&nbsp;<img alt=\"\" src=\"https://img2024.cnblogs.com/blog/9494/202512/9494-20251224112159491-529519835.png\" /></p>\n<p>“如果我不能改变它，”她若有所思，“那我至少应该能呼唤它。每一个对象，都该有一个能让世界识别它的名字吧？”</p>\n<p>这个念头一闪而过，<br />\n爱丽丝很清楚，<br />\n自己还是一个初学者，<br />\n一个“<strong>很菜很菜</strong>”的菜鸟。<br />\n但她心中已然埋下了一颗种子：<br />\n<strong>名字，或许是这个理性世界里唯一的咒语。</strong></p>\n<p>那一夜，她将一条规则深深铭刻于心：<br />\n<strong>.exe </strong><strong>的世界，是绝对理性的世界。</strong><br />\n<strong>没有写下的功能，绝不会出现；没有编码的行为，绝不会发生。</strong><br />\n<strong>要创造，必先编写，而后编译。</strong><br />\n<strong>这便是此间不容置疑的法则。</strong></p>\n<p>她接受了这套严峻但稳定的世界观。<br />\n她开始规划——要写多少行代码，<br />\n要经历多少次编译——才能构建她梦中的<strong>浏览器</strong>。</p>\n<p>然而，在许多漫长的编译与运行的夜晚，<br />\n爱丽丝仍会沉默地凝望<strong>浏览器窗口</strong>，<br />\n她心想——<br />\n<strong>何时，我的 .exe 才能拥有这样一个属于自己的<em>真真正正的浏览器窗口？</em></strong></p>\n<h1>爱丽丝的困境—通向浏览器的两扇大门</h1>\n<p>数月过去，爱丽丝已精通 WinForm 之术——<br />\n她曾经空白的窗口如今流光溢彩，<br />\n按钮听从她的意志，面板随她的指令舞动。<br />\n然而，浏览器的梦想在她心中愈发炽烈——<br />\n她思忖：何时我的.exe才能加载一个网页？</p>\n<p>&nbsp;</p>\n<p>毫无疑问，在她自己的exe之中加载第一个网页，是构建属于她自己的浏览器的第一步。</p>\n<p>于是她开始在浩瀚的技术文档海洋之中搜寻。无数的控件在她眼前闪耀——有的优雅，有的笨拙，有的号称无所不能，有的包裹着神秘。<br />\n但在一片喧嚣中，有两个名字反复浮现：<strong>CEF</strong> 和\n<strong>WebView2</strong>。</p>\n<p>它们都许诺力量，都要求效忠。<br />\n一个传承了 Chromium 的血统，跃动着开源引擎的力量；另一个则带着微软王朝的印记。</p>\n<p>爱丽丝站在它们面前，如同站在两扇高耸的门扉前——<br />\n一左一右，闪烁着未知的光芒——<br />\n她明白，无论推开哪一扇，门后的世界都将永远改变。</p>\n<p>&nbsp;</p>\n<p>它们如同两座巨门矗立在她面前，左右两侧，都闪烁着令人期待的光芒。哪一个是正确的选择？哪一个更强大？问题在她脑海中盘旋。</p>\n<p>&nbsp;</p>\n<p>思绪纷乱间，她的眼皮越来越重，沉入黑暗。当她再次睁开双眼，天空已是暮色苍茫，狂风在周遭呼啸，她发现自己置身于一片荒野。</p>\n<p>&nbsp;</p>\n<p>接着，那只熟悉的兔子出现了，怀表滴答作响，声音大得令人不安。<br />\n他没有看爱丽丝，只是喃喃自语：</p>\n<p><strong>“每一个 WinForm 应用程序，生来就是 Chromium 浏览器。何必执着于 CEF？何必纠缠于 WebView2？无需嵌入那些所谓的神级控件——只需完成编译，然后开始写下你的Web页面，一切便已完成……”</strong></p>\n<p>这话语如风般溜进爱丽丝的耳朵。这是梦中的低语，还是未来的启示？“<strong>这可能是真的吗？我不需要嵌入 CEF 或 WebView2？抑或这只是疯帽匠的胡言乱语？</strong>……”</p>\n<p>&nbsp;</p>\n<p>她的疑虑增长——直到柴郡猫诡异的声音在空中响起：“<strong>真的假不了，假的真不了</strong>。兔子有一面镜子；凝视它，你便会明白。” 说罢，猫便消失在夜色中。</p>\n<p>&nbsp;</p>\n<p>爱丽丝意识到非凡之事即将发生。她急忙追上兔子，想问个明白：<strong>为什么一个\nWinForm 应用程序已经是一个浏览器？</strong>在不远处，她看到兔子打开了他的笔记本电脑。屏幕中央只有一行文字……：<br />\n<strong>“</strong><strong>将你的 exe 拖拽至此 ……”</strong></p>\n<p align=\"center\">&nbsp;<img alt=\"\" src=\"https://img2024.cnblogs.com/blog/9494/202512/9494-20251224112159447-1199271438.png\" /></p>\n<h1>喝下我（Drink me），吃掉我（Eat me）</h1>\n<p align=\"center\">&nbsp;</p>\n<p>爱丽丝的心跳漏了一拍——她想起了昔日仙境的标签：“<strong>Drink me</strong>、<strong>Eat me</strong>”。她的好奇心陡然苏醒。</p>\n<p>兔子双击启动了一个普通的 WinForm 应用。里面只有一个面板，平平无奇。爱丽丝失望地叹了口气：<br />\n“这看起来和我自己写的没什么不同。也许那只猫终究是在撒谎……”</p>\n<p>但接着，兔子用鼠标抓起同一个 exe 文件，将其拖放到标有“将你的 exe 拖拽至此”的窗口。下一刻，爱丽丝惊得下巴几乎掉下来——那个普通、空无一物的 Panel 突然向外绽放，边缘冒出了完整的 <strong>Chromium</strong> 标签页栏！</p>\n<p>你或许在想：“我的 WinForm 只是一个窗口——它怎么可能变成浏览器？”我曾也这么想——直到有一天，在疯帽匠的茶会上，我偶然发现了这个奇妙的工具。</p>\n<p>兔子依旧神叨叨的喃喃自语，仿佛知道爱丽丝在听：“我那普通的老 Panel——毫不起眼的矩形，Dock 属性设为 Fill 或 None——突然变成了一面窥探互联网的镜子。”<br />\n从那一刻起，WinForm 应用程序不再是承载\nChromium 浏览器。<br />\n<strong>它，就是浏览器。</strong></p>\n<p>突然，兔子的耳朵抽动了一下——他似乎听到了红心女王权杖敲击的声响从远处传来。匆忙中，他跳了起来，留下开着的笔记本电脑，消失在夜色里。</p>\n<p>爱丽丝靠近屏幕，乍一看，它不过是个普通的工具窗口。<br />\n“真的吗？这就是所谓的魔法？太令人失望了。”</p>\n<p>她几乎要转身离开——但她的好奇心，一如既往地不肯放手。所以她决定验证一下真伪，她在兔子的电脑之中创建了一个属于自己的新\n<strong>WinForm</strong> 应用<strong>MyApp</strong>：</p>\n<p align=\"center\"><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/9494/202512/9494-20251224112159620-629149399.png\" />&nbsp;</p>\n<p>WinForm窗体之中只有一个面板，里面仅添加了一个button，面板的<strong>Dock</strong> 属性设为 Fill，爱丽丝的想法是：</p>\n<p>1、 你打算在我的“<strong>地盘（WinForm窗体）</strong>”之中显示Web页面，我彻底堵死这一条路，所以，panel的<strong>dock</strong>属性，设置为“dockfill”；</p>\n<p>2、 如果你计划让<strong>panel</strong>成为“<strong>占位符</strong>”，那么，我在其中添加一个<strong>button</strong>，<strong>button</strong>通常情况下是有功能的，如果你企图替换掉panel，就等于将<strong>button</strong>的功能屏蔽，这就是“违规、作弊”；</p>\n<p>3、 默认情况下，<strong>panel</strong>的颜色与<strong>WinForm</strong>的背景色是一致的，所以，我将<strong>panel</strong>的颜色设置为“橙色”或者其它颜色，如果你用Web页面覆盖了<strong>panel</strong>，那么，不需要过多的解释，这就是作弊；</p>\n<p>4、 没有多余的引用，完全是默认的；没有访问NuGet，意味着，没有神奇的代码；</p>\n<p>5、 一行代码都不写，想看一看，这一个<strong>myApp</strong>，究竟是什么样的“<strong>超级浏览器</strong>”。</p>\n<p>此时此刻，她内心的独白：“<strong>我的panel填满了整个WinForm窗体</strong>，那么，<strong>Web</strong>页面会显示在哪里？难道说：</p>\n<p align=\"center\"><strong>“真的会将我的panel替换掉，让按钮消失，然后让出位置，显示页面？”</strong></p>\n<p>如果桌面应用一定是<strong>Chromium</strong>浏览器，那么，这个一行代码都没有的WinForm应用，会不会如传说那样神奇？” 不用说，<strong>她坚信</strong>——编译之后，<strong>无论在哪里运行myApp.exe，它都会无条件的显示以下画面：</strong></p>\n<p align=\"center\">&nbsp;<img alt=\"\" src=\"https://img2024.cnblogs.com/blog/9494/202512/9494-20251224112159403-269855728.png\" /></p>\n<p>她单纯的想法就想证实一件事情：自己的“<strong>一张白纸</strong>”性质的<strong>myApp</strong>，究竟能否成为“<strong>超越Chrome浏览器</strong>”的存在。</p>\n<h1><strong>对话DeepSeek—当你遇见“会说话的猫”</strong></h1>\n<p>爱丽丝将编译之后的<strong>myApp.exe</strong>，拖入镜子，WinForm窗体竟然毫无变化——兔子向她展示的 <strong>Chromium</strong> 标签页拒绝出现。“<strong>完全不是那么回事</strong>，一点变化都没有！那只猫是个骗子” ，她想道，挫败感油然而生。</p>\n<p>然而，就在她打算合上电脑时，一个念头击中了她：“等等——这是 <strong>64 位的时代</strong>，我是不是选错了编译模式？” 她意识到，这个时代的魔法分两种：32位的轻语和64位的强音。她之前一直在轻语，而镜子可能只回应强音。</p>\n<p>爱丽丝心怦怦直跳，她重新编译。这一次——再次将其拖入，期待中她倒吸一口气……</p>\n<p align=\"center\"><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/9494/202512/9494-20251224112159600-1470573829.png\" />&nbsp;</p>\n<p><strong>面板周围竟然绽放出 Chromium 标签页！</strong>&nbsp;一条“<strong>红色分隔条</strong>”闪烁着出现，页面被激活，一个完整的“Chromium\n标签组”包裹住了她简陋的面板。</p>\n<p>让爱丽丝惊讶的是，这一组标签之中，竟然有<strong>DeepSeek</strong>，这些对她了如指掌的怪物——难道说，我竟然可以在其中与它们对话？会不会是一个忽悠人的<strong>“赝品”</strong>？，爱丽丝觉得非常有意思，于是，抱着试一试的想法，问了一个问题：</p>\n<p align=\"center\">&nbsp;<img alt=\"\" src=\"https://img2024.cnblogs.com/blog/9494/202512/9494-20251224112159545-1389854249.png\" /></p>\n<p>没想到，爱丽丝竟然看到了如下的画面：</p>\n<p align=\"center\">&nbsp;<img alt=\"\" src=\"https://img2024.cnblogs.com/blog/9494/202512/9494-20251224112159625-817099406.png\" /></p>\n<p align=\"center\">&nbsp;<img alt=\"\" height=\"601\" src=\"https://img2024.cnblogs.com/blog/9494/202512/9494-20251224112159574-991230763.png\" width=\"661\" /></p>\n<p>这一切 让她想起200年前仙境中的“<strong>会说话的猫、古怪的毛毛虫，……</strong>”，这个WinForm窗体竟然可以对话，“<strong>Curiouser and curiouser</strong>!”，逻辑上完全不可解释！\n她发现自己大叫：<strong>“我的 WinForm 怎么就成了 Chromium？</strong>这就像那个‘<strong>乌鸦像写字台</strong>’的谜语——<strong>根本没有道理，但它就是发生了！</strong>&nbsp;<strong>我何时添加过这样的代码？什么 API 能解释这一切——或者说，这奇迹真的仅仅是通过镜子的这一次拖放？”</strong></p>\n<p>空气波动着；虚空之中绽放出一个笑容。柴郡猫现身了。</p>\n<p>“<strong>API</strong>？”它发出咕噜声，“你依然相信每一种力量都必须追溯到你写下的一行代码。但你的 .exe 已经编译完成了，爱丽丝。你还不明白吗？<strong>编译即是你应用exe的诞生，但其许多行为从未被书写——它们是出生前就具备的。拖放并非嫁接新物；它只是揭开了早已存在其中的本质。</strong>”</p>\n<p>爱丽丝皱起眉头，目光锁定在发光的面板上。“但肯定有……什么东西，”她争辩道，“一个接口，一份契约，某些我从未写过的隐藏代码。没有代码，什么也运作不了。没有规则，什么也不存在。”</p>\n<p>柴郡猫的笑容咧得更开了。“还抓着契约不放吗，爱丽丝？你以为每个奇迹都会屈服于你笔下的墨水？有些真相是与生俱来的——并非因你编写了什么神奇的代码……”</p>\n<p>&nbsp;</p>\n<p><strong>屏幕上的对话渐渐沉寂，DeepSeek的输入框却依旧在那里闪烁着，像一个安静的邀请。</strong></p>\n<p><strong>爱丽丝的目光从Chromium的标签页，移回自己那橙色的、朴素的Panel上。一道裂隙，就在这两者之间——一道介于她亲手编译的理性世界，与那个知晓她所有秘密的云端智能之间的、温柔的裂隙。</strong></p>\n<p><strong>一个比恐惧更先抵达的，是孩童般的好奇。</strong></p>\n<p><strong>“如果这面镜子能让我看见它……”她伸出手指，仿佛要触碰那道看不见的裂隙。</strong><br />\n<strong>“</strong><strong>那么，如果我写一张小纸条，从我的世界，悄悄塞进它的世界呢？”</strong></p>\n<p><strong>这个念头让她心跳加速。那张想象中的“纸条”上可以写什么？一个她解不开的数学谜题？一段维多利亚时代的诗歌？还是……一句直接指挥这个WinForm窗体的咒语？</strong></p>\n<p><strong>她刚刚才将一条法则刻入骨髓：</strong>.exe<strong>的世界，没有写下的功能，绝不会出现。</strong><br />\n<strong>但现在，一个未曾写下的“邮差”，似乎已经站在了理性世界的围墙之下。</strong></p>\n<p><strong>深夜的荒野，编译器的余温似乎还未散去。爱丽丝静静地望着</strong>MyApp.exe<strong>的图标。</strong><br />\n<strong>她第一次觉得，这个由她接生到世间的数字生命，在拥有了Chromium的灵魂之后，或许也同时拥有了一只，等待接收“纸条”的、看不见的手。</strong></p>\n<p><strong>（作者按：当编译完成的程序，获得了一条通往智能的隐秘通道时，“创造”的终点，究竟在哪里？第一篇结束了，我们下一篇见。）</strong></p>\n<p>&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2025-12-24 11:22</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sunhui\">WebRuntime</a>&nbsp;\n阅读(<span id=\"post_view_count\">71</span>)&nbsp;\n评论(<span id=\"post_comment_count\">6</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "用了MySQL的INSERT ON DUPLICATE KEY UPDATE，怎么还报唯一索引冲突错误",
      "link": "https://www.cnblogs.com/youzhibing/p/19388304",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/youzhibing/p/19388304\" id=\"cb_post_title_url\" title=\"发布于 2025-12-24 09:00\">\n    <span>用了MySQL的INSERT ON DUPLICATE KEY UPDATE，怎么还报唯一索引冲突错误</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"开心一刻\">开心一刻</h2>\n<p>一天，老婆笑容满面的冲到我面前<br />\n老婆：你娶我到底是图我啥<br />\n我：便宜<br />\n老婆笑容瞬间消失，气呼呼的道：你会不会说话？<br />\n并且强调：我爸当年那是可怜你，没跟你多要<br />\n我：不是，你爸不是这么说的<br />\n老婆：那怎么说的<br />\n我开始学着老丈人的口吻：不许退，给你便宜点</p>\n<div align=\"center\"><img alt=\"开心一刻\" src=\"https://img2024.cnblogs.com/blog/747662/202512/747662-20251223173616476-1594142117.gif\" /></div>\n<h2 id=\"insert-on-duplicate-key-update\">INSERT ON DUPLICATE KEY UPDATE</h2>\n<p>关于 <code>INSERT ... ON DUPLICATE KEY UPDATE</code>，相信大家都有所了解，是 <code>MySQL</code> 针对</p>\n<blockquote>\n<p>不存在则插入，存在则更新</p>\n</blockquote>\n<p>的一种方言实现；<code>存不存在</code> 该如何判定呢，基于表的 <code>唯一索引</code> 或 <code>主键</code></p>\n<p>举个例子，如果列 <code>a</code> 被声明为 <code>唯一</code> 且表中已经存在 <code>a=1</code> 的记录，则以下两条语句具有类似的效果</p>\n<pre><code class=\"language-sql\">INSERT INTO t1 (a,b,c) VALUES (1,2,3)\n  ON DUPLICATE KEY UPDATE c=c+1;\n\nUPDATE t1 SET c=c+1 WHERE a=1;\n</code></pre>\n<p>假设我们有表</p>\n<pre><code class=\"language-sql\">CREATE TABLE `tbl_insert_on_update` (\n  `id` bigint NOT NULL,\n  `name` varchar(255) NOT NULL,\n  `uk_column1` varchar(255) NOT NULL,\n  `uk_column2` varchar(255) NOT NULL,\n  `remark` text,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `name` (`name`)\n) ENGINE=InnoDB\n</code></pre>\n<p>一开始表中没有数据，那么</p>\n<pre><code class=\"language-sql\">INSERT tbl_insert_on_update(id, name, uk_column1, uk_column2, remark)\nVALUES(1, '张三', '20050101001', '男一号', '风一样的男子')\nON DUPLICATE KEY UPDATE uk_column1='20050101002', uk_column2='男二号', remark='狂风一样的男子';\n</code></pre>\n<p>的作用，相信大家都知道，与</p>\n<pre><code class=\"language-sql\">INSERT tbl_insert_on_update(id, name, uk_column1, uk_column2, remark)\nVALUES(1, '张三', '20050101001', '男一号', '风一样的男子');\n</code></pre>\n<p>作用一样，会往表中插入一条新的记录；如果再执行一次</p>\n<pre><code class=\"language-sql\">INSERT tbl_insert_on_update(id, name, uk_column1, uk_column2, remark)\nVALUES(1, '张三', '20050101001', '男一号', '风一样的男子')\nON DUPLICATE KEY UPDATE uk_column1='20050101002', uk_column2='男二号', remark='狂风一样的男子';\n</code></pre>\n<p>呢，会是怎么样的结果？相信大家都知道</p>\n<div align=\"center\"><img alt=\"insert_on_update_再执行一次\" src=\"https://img2024.cnblogs.com/blog/747662/202512/747662-20251223173615289-1171352990.png\" /></div>\n<p>与</p>\n<pre><code class=\"language-sql\">UPDATE tbl_insert_on_update SET uk_column1='20050101002', uk_column2='男二号', remark='狂风一样的男子' WHERE id = 1;\n</code></pre>\n<p>的效果一样。我们接着做个简单调整，拿掉 <code>name</code></p>\n<pre><code class=\"language-sql\">INSERT tbl_insert_on_update(id, uk_column1, uk_column2, remark)\nVALUES(1, '20050101001', '男一号', '风一样的男子')\nON DUPLICATE KEY UPDATE uk_column1='20050101003', uk_column2='男三号', remark='暴风一样的男子';\n</code></pre>\n<p>或者拿掉 <code>id</code></p>\n<pre><code class=\"language-sql\">INSERT tbl_insert_on_update(name, uk_column1, uk_column2, remark)\nVALUES('张三', '20050101001', '男一号', '风一样的男子')\nON DUPLICATE KEY UPDATE uk_column1='20050101003', uk_column2='男三号', remark='暴风一样的男子';\n</code></pre>\n<p>会是怎么样的一个结果，你们可以大胆猜一下。这两个 SQL 的执行结果是一样的</p>\n<div align=\"center\"><img alt=\"男三浩\" src=\"https://img2024.cnblogs.com/blog/747662/202512/747662-20251223173615313-938765406.png\" /></div>\n<p>此时你们是不是有疑问呢</p>\n<blockquote>\n<p>为什么拿掉 <code>name</code> 和拿掉 <code>id</code> 的 INSERT ... ON DUPLICATE KEY UPDATE 的执行结果会是一样的？</p>\n</blockquote>\n<p>这个问题先放一放，我们先录入女一号的数据</p>\n<pre><code class=\"language-sql\">INSERT tbl_insert_on_update(id, name, uk_column1, uk_column2, remark)\nVALUES(2, '婉儿', '20050101001X', '女一号', '花一样的女子');\n</code></pre>\n<p>假设我们要修改女一号的信息，包括 <code>姓名</code>，是不是可以这么实现</p>\n<pre><code class=\"language-sql\">INSERT tbl_insert_on_update(id, name, uk_column1, uk_column2, remark)\nVALUES(2, '婉儿', '20050101001X', '女一号', '花一样的女子')\nON DUPLICATE KEY UPDATE, name='张三', uk_column1='20050101002X', uk_column2='女二号', remark='牵牛花一样的女子';\n</code></pre>\n<p>有什么问题吗，执行下就知道了嘛</p>\n<div align=\"center\"><img alt=\"唯一索引冲突\" src=\"https://img2024.cnblogs.com/blog/747662/202512/747662-20251223173615530-841103305.png\" width=\"90%\" /></div>\n<p>执行报错了，提示</p>\n<blockquote>\n<p>1062 - Duplicate entry '张三' for key 'tbl_insert_on_update.name'</p>\n</blockquote>\n<p>这个错误信息我们是不是很熟悉？不就是唯一索引冲突吗？那么问题又来了</p>\n<blockquote>\n<p>用了MySQL的INSERT ON DUPLICATE KEY UPDATE，为什么还会唯一索引冲突？</p>\n</blockquote>\n<h2 id=\"如何判断是否存在\">如何判断是否存在</h2>\n<p>我们写 <code>INSERT ... ON DUPLICATE KEY UPDATE</code> 语句时，并未指定用哪个 <code>主键</code> 或者 <code>唯一索引</code> 来判定记录是否存在</p>\n<blockquote>\n<p>Oracle、SQL Server、PostgreSQL 的 <code>MERGE</code> 有类似作用</p>\n<pre><code class=\"language-sql\">MERGE INTO TBL_INSERT_ON_UPDATE t\nUSING (\n    SELECT 1 AS ID, '张三' AS NAME, '20050101001' AS UK_COLUMN1, '男一号' AS UK_COLUMN2, '风一样的男子' AS REMARK FROM dual\n) s\nON (t.NAME = s.NAME)  -- 基于 NAME 字段匹配\nWHEN MATCHED THEN\n    UPDATE SET\n        t.ID = s.ID,\n        t.UK_COLUMN1 = s.UK_COLUMN1,\n        t.UK_COLUMN2 = s.UK_COLUMN2,\n        t.REMARK = s.REMARK\nWHEN NOT MATCHED THEN\n    INSERT (ID, NAME, UK_COLUMN1, UK_COLUMN2, REMARK)\n    VALUES (s.ID, s.NAME, s.UK_COLUMN1, s.UK_COLUMN2, s.REMARK);\n</code></pre>\n<p>其中的 <code>ON</code>  明确指定匹配字段（根据哪些字段判断记录是否存在），一般是指定 <code>主键</code>字段或 <code>唯一索引</code>字段</p>\n</blockquote>\n<p>那 MySQL 是如何判定记录是否存在的呢？我们可以翻阅下官方文档：<a href=\"https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html\" rel=\"noopener nofollow\" target=\"_blank\">INSERT ... ON DUPLICATE KEY UPDATE Statement</a>。一开头有如下一段描述</p>\n<blockquote>\n<p>If you specify an <code>ON DUPLICATE KEY UPDATE</code> clause and a row to be inserted would cause a duplicate value in a <code>UNIQUE</code> index or <code>PRIMARY KEY</code>, an <a href=\"https://dev.mysql.com/doc/refman/8.0/en/update.html\" rel=\"noopener nofollow\" target=\"_blank\"><code>UPDATE</code></a> of the old row occurs</p>\n<p>当我们使用 <code>ON DUPLICATE KEY UPDATE</code>  子句时，插入的行导致 <code>唯一</code> 索引或者 <code>主键</code> 重复时，会更新旧的行</p>\n</blockquote>\n<p>通过这段话，我们只知道 MySQL 是根据唯一索引或主键来判定行是否存在，并不知道</p>\n<ol>\n<li>先根据主键判定，不冲突之后再根据唯一索引判定？</li>\n<li>有多个唯一索引时，这些唯一索引的判定优先级是怎样的？</li>\n</ol>\n<p>官方文档里面并未明确说明这些问题，只是在结尾进行了如下说明</p>\n<blockquote>\n<p>An <a href=\"https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html\" rel=\"noopener nofollow\" target=\"_blank\"><code>INSERT ... ON DUPLICATE KEY UPDATE</code></a> statement against a table having more than one unique or primary key is also marked as unsafe. (Bug #11765650, Bug #58637)</p>\n<p>当表中有多个唯一索引或者主键时，INSERT ... ON DUPLICATE KEY UPDATE 语句不安全</p>\n</blockquote>\n<p>不安全代表执行结果不固定，会出现我们预期之外的结果</p>\n<h2 id=\"工作原理\">工作原理</h2>\n<p>如果让你们来实现 <code>不存在则插入，存在则更新</code>，你们会怎么实现？</p>\n<p>逐个查询主键以及所有唯一索引，判断该行数据是否存在，一旦存在则根据重复的主键或者唯一索引进行 <code>UPDATE</code>，都不存在则进行 <code>INSERT</code>；这不仅是你们最容易想到的实现方式，也是我最容易想到的方式。</p>\n<p>但 MySQL 并未采用这种方式，而是采用了另外一种更高效的方式，先尝试插入，存储引擎会向<strong>所有相关的唯一索引（包括主键）</strong> 中插入对应的索引条目，如果都插入成功，说明数据行不存在，那么 <code>INSERT</code> 数据行；一旦存储引擎尝试插入某个唯一索引时，发现该数据行已经存在，会立即停止插入动作，并向MySQL服务层抛出 <code>重复键</code> 错误，服务层收到重复键错误后，并不会让整个语句失败（因为使用了 ON DUPLICATE KEY UPDATE 子句），而是转换执行模式，会先回滚之前的插入，然后根据重复的那个唯一索引找到数据行对应的 <code>旧行</code> 数据，最后 <code>UPDATE</code> 数据行；总结下来分三步</p>\n<ol>\n<li>\n<p>尝试插入</p>\n<p>所有唯一索引（包括主键）都插入成功，则插入数据行，相当于完成普通的 <code>INSERT</code></p>\n<p>一旦某个唯一索引插入失败，则立即停止插入，存储引擎会向上层抛出一个 <code>重复键</code> 错误</p>\n</li>\n<li>\n<p>模式转换</p>\n<p>MySQL服务器收到重复键后，发现执行语句中有 <code>ON DUPLICATE KEY UPDATE</code> 子句，不会直接让整个语句失败，而是先回滚之前的那部分唯一索引的插入，然后根据插入失败的唯一索引找到已经存在的 <code>旧行</code></p>\n</li>\n<li>\n<p>执行更新</p>\n<p>根据插入失败的唯一索引，对旧行执行更新操作，相当于完成普通的 <code>UPDATE</code></p>\n</li>\n</ol>\n<p>整个 <code>尝试-失败-转换-更新</code> 过程时一个原子操作，那么完全成功，要么完全失败；相比于 <code>先查询后判断</code> 的传统实现，这种实现方式效率更高。</p>\n<h2 id=\"问题答疑\">问题答疑</h2>\n<p>前面涉及到两个问题，现在我们来解惑下</p>\n<ol>\n<li>\n<p>为什么拿掉 <code>name</code> 和拿掉 <code>id</code> 的 INSERT ... ON DUPLICATE KEY UPDATE 的执行结果会是一样的？</p>\n<pre><code class=\"language-sql\">-- 拿掉name\nINSERT tbl_insert_on_update(id, uk_column1, uk_column2, remark)\nVALUES(1, '20050101001', '男一号', '风一样的男子')\nON DUPLICATE KEY UPDATE uk_column1='20050101003', uk_column2='男三号', remark='暴风一样的男子';\n\n-- 拿掉id\nINSERT tbl_insert_on_update(name, uk_column1, uk_column2, remark)\nVALUES('张三', '20050101001', '男一号', '风一样的男子')\nON DUPLICATE KEY UPDATE uk_column1='20050101003', uk_column2='男三号', remark='暴风一样的男子';\n</code></pre>\n<p>这个问题是不是很简单，我们一起来分析下</p>\n<pre><code class=\"language-sql\">INSERT tbl_insert_on_update(id, uk_column1, uk_column2, remark)\nVALUES(1, '20050101001', '男一号', '风一样的男子')\nON DUPLICATE KEY UPDATE uk_column1='20050101003', uk_column2='男三号', remark='暴风一样的男子';\n</code></pre>\n<p>INSERT 的字段中没有 <code>name</code>，但有 <code>id</code>，可想而知判断数据行是否存在，用到的是 <code>主键</code>，因为 <code>id=1</code> 的记录已经存在，所以根据 id 去更新其他字段值；那么执行结果与如下 SQL 一致</p>\n<pre><code class=\"language-sql\">UPDATE tbl_insert_on_update SET uk_column1='20050101003', uk_column2='男三号', remark='暴风一样的男子' WHERE id = 1;\n</code></pre>\n<p>同理</p>\n<pre><code class=\"language-sql\">INSERT tbl_insert_on_update(name, uk_column1, uk_column2, remark)\nVALUES('张三', '20050101001', '男一号', '风一样的男子')\nON DUPLICATE KEY UPDATE uk_column1='20050101003', uk_column2='男三号', remark='暴风一样的男子';\n</code></pre>\n<p>INSERT 的字段中没有 <code>id</code>，但有 <code>name</code>，可想而知判断数据行是否存在，用到的是 <code>唯一索引</code>，因为 <code>name=张三</code> 的记录已经存在，所以根据 name 去更新其他字段值；那么执行结果与如下 SQL 一致</p>\n<pre><code class=\"language-sql\">UPDATE tbl_insert_on_update SET uk_column1='20050101003', uk_column2='男三号', remark='暴风一样的男子' WHERE name = '张三';\n</code></pre>\n<p><code>id = 1</code> 与 <code>name = '张三'</code> 指向的本来就是同一行数据，更新的列与列值都一致，那么执行结果自然就一样了</p>\n</li>\n<li>\n<p>存在多个唯一索引（包含主键）时，判断数据行是否存在，这些唯一索引的优先级顺序是怎样的？</p>\n<p>MySQL 官方文档并未明确说明这个优先级顺序，但在 MySQL 的实现中肯定有这个优先级顺序的实现算法，可能跟版本、存储引擎有关</p>\n<p>基于 <code>8.0.31</code> 版本，简单测试出以下优先级</p>\n<blockquote>\n<p>主键 &gt; 唯一索引</p>\n<p>唯一索引之间按创建顺序，先创建的优先级高</p>\n</blockquote>\n<p>官方文档已经明确说明：当表中有多个唯一索引或者主键时，INSERT ... ON DUPLICATE KEY UPDATE 语句不安全，所以如上的测试结果并不具备确定性，不能作为使用准则</p>\n</li>\n<li>\n<p>用了MySQL的INSERT ON DUPLICATE KEY UPDATE，怎么还报唯一索引冲突错误</p>\n<p>MySQL是基于尝试插入的第一个冲突的唯一索引来执行更新的，更新的字段完全有可能触发其他唯一索引（包括主键）冲突</p>\n<p>这个问题根本不成立！</p>\n</li>\n</ol>\n<h2 id=\"总结\">总结</h2>\n<ol>\n<li>\n<p>不管是 MySQL，还是 Oracle、SQL Server、PostgreSQL，针对 <code>不存在则插入，存在则更新</code> 判断数据是否存在的逻辑都是一样的，只是 MySQL 不需要显示指定 <code>判存</code> 的唯一索引（包括主键），由 MySQL 引擎内部自动实现</p>\n</li>\n<li>\n<p>关于判断数据行是否存在，多个唯一索引的优先级，看似能测出 MySQL 中的优先级，但并不具备确定性，不能作为使用准则</p>\n<p>类似不确定的排序问题还有：<a href=\"https://juejin.cn/post/7290017749715632168\" rel=\"noopener nofollow\" target=\"_blank\">我试图扯掉这条 SQL 的底裤</a></p>\n</li>\n<li>\n<p>INSERT ... ON DUPLICATE KEY UPDATE 使用过程中有一些需要注意的点，需要结合自己的业务来分析是否可以忽略这些点</p>\n<p><a href=\"https://www.cnblogs.com/youzhibing/p/15248758.html\" target=\"_blank\">记录不存在则插入，存在则更新 → MySQL 的实现方式有哪些？</a></p>\n</li>\n</ol>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-24 09:00</span>&nbsp;\n<a href=\"https://www.cnblogs.com/youzhibing\">青石路</a>&nbsp;\n阅读(<span id=\"post_view_count\">37</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【面试题】MySQL 中使用索引一定有效吗？如何排查索引效果？",
      "link": "https://www.cnblogs.com/sun-10387834/p/19371499",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sun-10387834/p/19371499\" id=\"cb_post_title_url\" title=\"发布于 2025-12-24 08:42\">\n    <span>【面试题】MySQL 中使用索引一定有效吗？如何排查索引效果？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"-mysql-索引失效的8大陷阱及排查指南\">📉 MySQL 索引失效的8大陷阱及排查指南</h1>\n<h2 id=\"-一句话明白\">🎯 一句话明白</h2>\n<p><strong>索引不是万能的！用不对反而更慢！</strong></p>\n<h2 id=\"-索引失效的8大常见场景\">🚫 索引失效的8大常见场景</h2>\n<h3 id=\"1-索引列上做计算最常见\"><strong>1. 索引列上做计算（最常见）</strong></h3>\n<pre><code class=\"language-sql\">-- ❌ 错误：在索引列上计算\nSELECT * FROM users WHERE YEAR(created_time) = 2024;\nSELECT * FROM products WHERE price * 2 &gt; 100;\n\n-- ✅ 正确：把计算移到右边\nSELECT * FROM users WHERE created_time &gt;= '2024-01-01' AND created_time &lt; '2025-01-01';\nSELECT * FROM products WHERE price &gt; 50;\n</code></pre>\n<p><strong>原因</strong>：数据库必须对<strong>每一行</strong>都计算才能比较，无法用索引快速定位。</p>\n<h3 id=\"2-索引列使用函数\"><strong>2. 索引列使用函数</strong></h3>\n<pre><code class=\"language-sql\">-- ❌ 错误：使用函数包裹索引列\nSELECT * FROM users WHERE UPPER(name) = 'JOHN';\nSELECT * FROM logs WHERE DATE(create_time) = '2024-01-01';\n\n-- ✅ 正确：使用范围查询\nSELECT * FROM users WHERE name = 'john';  -- 存入时统一小写\nSELECT * FROM logs WHERE create_time &gt;= '2024-01-01' AND create_time &lt; '2024-01-02';\n</code></pre>\n<h3 id=\"3-模糊查询开头用通配符\"><strong>3. 模糊查询开头用通配符</strong></h3>\n<pre><code class=\"language-sql\">-- ❌ 错误：以 % 开头\nSELECT * FROM users WHERE name LIKE '%张%';  -- 全表扫描\nSELECT * FROM users WHERE name LIKE '%明';\n\n-- ✅ 正确：以确定字符开头\nSELECT * FROM users WHERE name LIKE '张%';   -- 可以使用索引\nSELECT * FROM users WHERE name LIKE '张_明'; -- _匹配一个字符\n</code></pre>\n<p><strong>生活类比</strong>：</p>\n<ul>\n<li><code>张%</code> → 知道姓张，直接翻到张姓区域 ✅</li>\n<li><code>%张</code> → 不知道姓什么，只能一页页翻 ❌</li>\n</ul>\n<h3 id=\"4-or-条件使用不当\"><strong>4. OR 条件使用不当</strong></h3>\n<pre><code class=\"language-sql\">-- ❌ 错误：OR 条件中有的列没索引\nSELECT * FROM users WHERE age = 25 OR salary &gt; 10000;\n-- 如果 salary 没索引，整个查询都无法用索引\n\n-- ✅ 正确：确保 OR 两边都有索引\n-- 或者分开查询\nSELECT * FROM users WHERE age = 25\nUNION\nSELECT * FROM users WHERE salary &gt; 10000;\n</code></pre>\n<h3 id=\"5-类型不匹配隐式转换\"><strong>5. 类型不匹配（隐式转换）</strong></h3>\n<pre><code class=\"language-sql\">-- ❌ 错误：字符串列用数字查询\nCREATE TABLE users (\n    id VARCHAR(20) PRIMARY KEY,  -- 字符串类型\n    name VARCHAR(50)\n);\nSELECT * FROM users WHERE id = 123;  -- 字符串和数字比较\n\n-- ✅ 正确：类型一致\nSELECT * FROM users WHERE id = '123';\n</code></pre>\n<p><strong>测试隐式转换</strong>：</p>\n<pre><code class=\"language-sql\">-- 查看执行计划\nEXPLAIN SELECT * FROM users WHERE id = 123;\n-- 注意看 key 列是否为 NULL（没走索引）\n</code></pre>\n<h3 id=\"6-联合索引没用最左列\"><strong>6. 联合索引没用最左列</strong></h3>\n<pre><code class=\"language-sql\">-- 索引：idx_abc (a, b, c)\n\n-- ✅ 有效：用了最左列\nSELECT * FROM table WHERE a = 1;\nSELECT * FROM table WHERE a = 1 AND b = 2;\nSELECT * FROM table WHERE a = 1 AND b = 2 AND c = 3;\n\n-- ❌ 无效：没从最左开始\nSELECT * FROM table WHERE b = 2;            -- 跳过 a\nSELECT * FROM table WHERE c = 3;            -- 跳过 a,b\nSELECT * FROM table WHERE b = 2 AND c = 3;  -- 跳过 a\n</code></pre>\n<p><strong>记忆技巧</strong>：就像查字典，必须知道<strong>第一个字母</strong>才能快速查找。</p>\n<h3 id=\"7-数据量太少不如全表扫描\"><strong>7. 数据量太少，不如全表扫描</strong></h3>\n<pre><code class=\"language-sql\">-- 假设表只有 100 行数据\nSELECT * FROM small_table WHERE id = 50;\n\n-- 数据库会想：走索引要查索引树 + 回表，不如直接全表扫描更快\n</code></pre>\n<h3 id=\"8-索引列选择性太低\"><strong>8. 索引列选择性太低</strong></h3>\n<pre><code class=\"language-sql\">-- 比如\"性别\"列，只有\"男/女\"两种值\nCREATE INDEX idx_gender ON users(gender);\n\nSELECT * FROM users WHERE gender = '男';\n-- 可能失效，因为要返回接近一半的数据，不如全表扫描\n</code></pre>\n<h2 id=\"-如何排查索引失效\">🔍 如何排查索引失效？</h2>\n<h3 id=\"第1步用-explain-快速诊断\"><strong>第1步：用 EXPLAIN 快速诊断</strong></h3>\n<pre><code class=\"language-sql\">-- 在查询前加 EXPLAIN\nEXPLAIN SELECT * FROM users WHERE name LIKE '%张%';\n\n-- 关键看这几列：\n-- 1. type: ALL → 全表扫描（最差）\n-- 2. key: NULL → 没走索引\n-- 3. rows: 数值很大 → 要扫描很多行\n-- 4. Extra: Using filesort, Using temporary → 性能警告\n</code></pre>\n<h3 id=\"第2步看懂-explain-结果\"><strong>第2步：看懂 EXPLAIN 结果</strong></h3>\n<pre><code class=\"language-sql\">EXPLAIN SELECT * FROM orders WHERE user_id = 100 AND status = 'paid';\n\n-- 理想结果：\n+----+-------------+--------+------+---------------+---------+---------+-------------+------+\n| id | select_type | table  | type | possible_keys | key     | key_len | rows        | Extra|\n+----+-------------+--------+------+---------------+---------+---------+-------------+------+\n|  1 | SIMPLE      | orders | ref  | idx_user      | idx_user| 8       | 10          | NULL |\n+----+-------------+--------+------+---------------+---------+---------+-------------+------+\n\n-- type 从好到差：\n-- system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL\n-- 至少要到 range 级别才合格\n</code></pre>\n<h3 id=\"第3步使用性能分析工具\"><strong>第3步：使用性能分析工具</strong></h3>\n<pre><code class=\"language-sql\">-- 1. 开启 profiling（查看详细耗时）\nSET profiling = 1;\nSELECT * FROM users WHERE ...;\nSHOW PROFILES;\nSHOW PROFILE FOR QUERY 1;\n\n-- 2. 查看索引使用统计\nSELECT * FROM sys.schema_index_statistics \nWHERE table_name = 'users';\n\n-- 3. 找出从未使用的索引（该删除了！）\nSELECT * FROM sys.schema_unused_indexes;\n</code></pre>\n<h3 id=\"第4步慢查询日志分析\"><strong>第4步：慢查询日志分析</strong></h3>\n<pre><code class=\"language-sql\">-- 1. 开启慢查询日志\nSET GLOBAL slow_query_log = 'ON';\nSET GLOBAL long_query_time = 2;  -- 超过2秒记录\n\n-- 2. 查看慢查询日志位置\nSHOW VARIABLES LIKE 'slow_query_log_file';\n\n-- 3. 使用工具分析（推荐）\n-- mysqldumpslow 或 pt-query-digest\n</code></pre>\n<h2 id=\"️-实战排查案例\">🛠️ 实战排查案例</h2>\n<h3 id=\"案例1为什么这个查询慢\"><strong>案例1：为什么这个查询慢？</strong></h3>\n<pre><code class=\"language-sql\">-- 原始查询（很慢）\nSELECT * FROM orders \nWHERE DATE_FORMAT(create_time, '%Y-%m') = '2024-01'\nORDER BY amount DESC;\n\n-- 步骤1：EXPLAIN分析\nEXPLAIN SELECT * FROM orders WHERE DATE_FORMAT(create_time, '%Y-%m') = '2024-01';\n\n-- 发现：type=ALL, key=NULL（没走索引）\n-- 原因：对 create_time 使用了函数\n\n-- 优化方案：\nSELECT * FROM orders \nWHERE create_time &gt;= '2024-01-01' \n  AND create_time &lt; '2024-02-01'\nORDER BY amount DESC;\n\n-- 再 EXPLAIN：type=range, key=idx_create_time ✅\n</code></pre>\n<h3 id=\"案例2联合索引问题\"><strong>案例2：联合索引问题</strong></h3>\n<pre><code class=\"language-sql\">-- 查询：经常按城市和年龄搜索用户\nSELECT * FROM users WHERE city = '北京' AND age &gt; 25;\n\n-- 现有索引：idx_age_city (age, city)\n-- 问题：最左列是 age，但查询先过滤 city\n\n-- 解决方案：\n-- 1. 调整查询顺序（如果业务允许）\nSELECT * FROM users WHERE age &gt; 25 AND city = '北京';\n\n-- 2. 或创建新索引\nCREATE INDEX idx_city_age ON users(city, age);\n</code></pre>\n<h2 id=\"-索引效果评估表\">📊 索引效果评估表</h2>\n<table>\n<thead>\n<tr>\n<th>检查项</th>\n<th>合格标准</th>\n<th>如何检查</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>索引使用率</strong></td>\n<td>&gt; 90%</td>\n<td><code>SHOW STATUS LIKE 'Handler_read%'</code></td>\n</tr>\n<tr>\n<td><strong>查询响应时间</strong></td>\n<td>&lt; 100ms</td>\n<td>慢查询日志</td>\n</tr>\n<tr>\n<td><strong>扫描行数</strong></td>\n<td>rows &lt; 1000</td>\n<td>EXPLAIN 的 rows 列</td>\n</tr>\n<tr>\n<td><strong>临时表使用</strong></td>\n<td>尽量避免</td>\n<td>EXPLAIN 的 Extra 列</td>\n</tr>\n<tr>\n<td><strong>文件排序</strong></td>\n<td>尽量避免</td>\n<td>EXPLAIN 的 Extra 列</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"-最佳实践清单\">🎯 最佳实践清单</h2>\n<h3 id=\"创建索引前问自己\"><strong>创建索引前问自己：</strong></h3>\n<ol>\n<li>✅ 这个查询真的需要索引吗？（数据量小不需要）</li>\n<li>✅ 索引列的选择性高吗？（唯一值多吗？）</li>\n<li>✅ 会频繁更新这个列吗？（更新频繁的列不适合建索引）</li>\n<li>✅ 已经有类似的索引了吗？（避免重复索引）</li>\n</ol>\n<h3 id=\"创建索引后要检查\"><strong>创建索引后要检查：</strong></h3>\n<pre><code class=\"language-sql\">-- 1. 验证索引被使用\nEXPLAIN SELECT ...;\n\n-- 2. 监控索引大小\nSELECT \n    table_name,\n    index_name,\n    ROUND(SUM(index_length)/1024/1024, 2) AS '索引大小(MB)'\nFROM information_schema.TABLES \nWHERE table_schema = '你的数据库'\nGROUP BY table_name, index_name;\n\n-- 3. 定期清理无用索引\n-- 查看使用频率低的索引\nSELECT * FROM sys.schema_unused_indexes;\n</code></pre>\n<h2 id=\"-简单记忆口诀\">💡 简单记忆口诀</h2>\n<p><strong>索引失效八大坑：</strong></p>\n<ol>\n<li>计算函数不用想</li>\n<li>模糊查询百分左</li>\n<li>类型转换隐式藏</li>\n<li>OR 条件要全防</li>\n<li>最左前缀不能忘</li>\n<li>数据量少全表爽</li>\n<li>选择性低是白忙</li>\n<li>不等号&lt;&gt;也够呛</li>\n</ol>\n<p><strong>排查四步曲：</strong></p>\n<ol>\n<li><strong>EXPLAIN</strong> 看计划</li>\n<li><strong>慢日志</strong> 抓真凶</li>\n<li><strong>PROFILE</strong> 查明细</li>\n<li><strong>统计表</strong> 清无用</li>\n</ol>\n<p>记住：<strong>索引就像书的目录，但翻目录本身也需要时间。如果书只有10页，不如直接翻；如果目录编排不合理，还不如不用！</strong></p>\n\n</div>\n<div id=\"MySignature\">\n    \n<p>❤️ 如果你喜欢这篇文章，请点赞支持！ 👍 同时欢迎关注我的博客，获取更多精彩内容！</p>\n\n<p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/sun-10387834/\" target=\"_blank\">佛祖让我来巡山</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/sun-10387834/p/19371499\" target=\"_blank\">https://www.cnblogs.com/sun-10387834/p/19371499</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-24 08:42</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sun-10387834\">佛祖让我来巡山</a>&nbsp;\n阅读(<span id=\"post_view_count\">47</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "FastAPI快速上手：请求与响应的核心玩法",
      "link": "https://www.cnblogs.com/ymtianyu/p/19389987",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ymtianyu/p/19389987\" id=\"cb_post_title_url\" title=\"发布于 2025-12-24 08:24\">\n    <span>FastAPI快速上手：请求与响应的核心玩法</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文详细介绍了如何使用FastAPI框架处理Web开发中的核心请求与响应。内容涵盖路由定义、GET与POST请求方法、查询参数与路径参数的使用、请求头与响应头的操作、表单数据的解析以及重定向的实现，并提供了可直接运行的完整代码示例，帮助读者快速掌握FastAPI的基础应用。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<div>\n<div style=\"margin-bottom: 30px;\">\n<p style=\"font-size: 18px; color: rgba(102, 102, 102, 1);\">还在为构建高性能API而烦恼？知道吗，<strong style=\"color: rgba(186, 55, 42, 1);\">FastAPI</strong>框架的性能与<code>NodeJS</code>和<code>Go</code>相当，同时提供极佳的开发体验。</p>\n</div>\n<div style=\"background-color: rgba(249, 249, 249, 1); padding: 15px 20px; margin: 25px 0; border-radius: 0 4px 4px 0;\">\n<p style=\"margin: 0; color: rgba(44, 62, 80, 1); font-weight: bold;\">📖 文章摘要</p>\n<p style=\"margin: 10px 0 0; color: rgba(85, 85, 85, 1);\">本文带你快速上手FastAPI的请求与响应处理核心。你将清晰地掌握如何定义路由、处理GET/POST请求、玩转查询与路径参数、管理请求头与响应头、解析表单数据以及实现页面重定向。文末附有可直接运行的完整代码示例。</p>\n<br />\n<p style=\"margin: 0; color: rgba(44, 62, 80, 1); font-weight: bold;\">🚀 你将学到：</p>\n<p style=\"margin: 5px 0 0; color: rgba(85, 85, 85, 1);\">- 路由与请求方法的基础定义<br />- 如何接收查询参数和路径参数<br />- 处理POST请求与JSON数据<br />- 读取请求头与设置自定义响应头<br />- 解析application/x-www-form-urlencoded表单数据<br />- 实现简单的重定向响应</p>\n</div>\n<h2 style=\"padding-bottom: 10px; margin-top: 40px;\">✨ 目录</h2>\n<p style=\"color: rgba(85, 85, 85, 1);\">- 🛣️ 第一步：从路由与请求方法开始<br />- 🔍 GET请求：查询参数与路径参数<br />- 📤 POST请求：接收JSON与表单数据<br />- 📨 请求头与响应头：细节控制<br />- ↪️ 重定向：让请求跳转起来<br />- 💻 完整代码示例：一个迷你API服务</p>\n<h2 id=\"route\" style=\"margin-top: 45px; color: rgba(44, 62, 80, 1);\">🛣️ 第一步：从路由与请求方法开始</h2>\n<p>在FastAPI中，一切从<code>app</code>实例和装饰器开始。<code>@app.get()</code>、<code>@app.post()</code>等装饰器定义了URL路径和HTTP方法。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import FastAPI\n\napp = FastAPI()\n\n# 定义一个处理根路径GET请求的路由\n@app.get(\"/\")\ndef read_root():\n    return {\"message\": \"Hello, FastAPI World!\"}\n\n# 定义一个处理'/items'路径GET请求的路由\n@app.get(\"/items/\")\ndef read_items():\n    return [{\"item_id\": 1, \"name\": \"Foo\"}]</code></pre>\n<p>看，就这么简单！<strong style=\"color: rgba(186, 55, 42, 1);\">每个函数对应一个API端点</strong>，返回值自动转换为JSON响应。</p>\n<h2 id=\"get\" style=\"margin-top: 45px; color: rgba(44, 62, 80, 1);\">🔍 GET请求：查询参数与路径参数</h2>\n<p>GET请求常用于获取数据，参数通常通过URL传递。主要有两种方式：<strong style=\"color: rgba(186, 55, 42, 1);\">查询参数</strong>和<strong style=\"color: rgba(186, 55, 42, 1);\">路径参数</strong>。</p>\n<p><strong>查询参数</strong>：跟在URL问号<code>?</code>后面，如<code>/items/?skip=0&amp;limit=10</code>。在函数参数中声明即可自动获取。</p>\n<pre class=\"language-python highlighter-hljs\"><code>@app.get(\"/items/\")\ndef read_items(skip: int = 0, limit: int = 10):\n    # 模拟从数据库读取数据\n    fake_items = [{\"item_id\": i} for i in range(skip, skip + limit)]\n    return fake_items</code></pre>\n<p><strong>路径参数</strong>：直接嵌在URL路径中，如<code>/items/123</code>。在路由中用<code>{}</code>声明。</p>\n<pre class=\"language-python highlighter-hljs\"><code>@app.get(\"/items/{item_id}\")\ndef read_item(item_id: int): # 类型注解会自动进行验证和转换\n    return {\"item_id\": item_id, \"name\": f\"Item {item_id}\"}</code></pre>\n<p>FastAPI的<strong style=\"color: rgba(186, 55, 42, 1);\">类型提示</strong>功能会帮你自动验证参数类型，并提供漂亮的API文档！</p>\n<h2 id=\"post\" style=\"margin-top: 45px; color: rgba(44, 62, 80, 1);\">📤 POST请求：接收JSON与表单数据</h2>\n<p>POST请求用于创建或提交数据。最常见的是接收<strong style=\"color: rgba(186, 55, 42, 1);\">JSON</strong>和<strong style=\"color: rgba(186, 55, 42, 1);\">表单</strong>数据。</p>\n<p><strong>1. 接收JSON数据</strong>：使用Pydantic模型来定义数据结构。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n    price: float\n    tax: float | None = None\n\n@app.post(\"/items/\")\ndef create_item(item: Item): # 将请求体声明为Item类型\n    # 可以直接使用item的属性\n    item_dict = item.dict()\n    if item.tax:\n        total_price = item.price + item.tax\n        item_dict.update({\"total_price\": total_price})\n    return item_dict</code></pre>\n<p><strong>2. 接收表单数据</strong>：当数据来自HTML表单时，使用<code>Form</code>。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import Form\n\n@app.post(\"/login/\")\ndef login(username: str = Form(...), password: str = Form(...)):\n    # Form(...)表示必填字段\n    return {\"username\": username, \"login_status\": \"success\"}</code></pre>\n<p>注意：使用<code>Form</code>前需要先安装<code>python-multipart</code>库。</p>\n<h2 id=\"header\" style=\"margin-top: 45px; color: rgba(44, 62, 80, 1);\">📨 请求头与响应头：细节控制</h2>\n<p>有时你需要读取客户端的请求头，或者为响应添加自定义头部信息。</p>\n<p><strong>读取请求头</strong>：使用<code>Header</code>函数。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import Header\n\n@app.get(\"/headers/\")\ndef read_headers(user_agent: str | None = Header(None)):\n    return {\"User-Agent\": user_agent}</code></pre>\n<p><strong>设置响应头</strong>：返回一个<code>Response</code>对象，或在依赖中设置。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import Response\n\n@app.get(\"/custom-header/\")\ndef set_custom_header(response: Response):\n    response.headers[\"X-Custom-Header\"] = \"MyCustomValue\"\n    return {\"message\": \"Check the headers!\"}</code></pre>\n<h2 id=\"redirect\" style=\"margin-top: 45px; color: rgba(44, 62, 80, 1);\">↪️ 重定向：让请求跳转起来</h2>\n<p>重定向在Web开发中很常见，比如登录后跳转到首页。使用<code>RedirectResponse</code>即可轻松实现。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi.responses import RedirectResponse\n\n@app.get(\"/old-link/\")\ndef old_link():\n    # 永久重定向到新的URL\n    return RedirectResponse(url=\"/new-link/\", status_code=301)\n\n@app.get(\"/new-link/\")\ndef new_link():\n    return {\"message\": \"This is the new endpoint!\"}</code></pre>\n<h2 id=\"full-code\" style=\"margin-top: 45px; color: rgba(44, 62, 80, 1);\">💻 完整代码示例：一个迷你API服务</h2>\n<p>将上面的知识点整合，创建一个简单的笔记API。保存为<code>main.py</code>，然后用<code>uvicorn main:app --reload</code>运行它！</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import FastAPI, Path, Query, Header, Form, Response\nfrom fastapi.responses import RedirectResponse\nfrom pydantic import BaseModel\nfrom typing import Optional\n\napp = FastAPI(title=\"迷你笔记API\")\n\n# 数据模型\nclass Note(BaseModel):\n    title: str\n    content: str\n\n# 模拟数据库\nfake_notes_db = [{\"id\": 1, \"title\": \"First Note\", \"content\": \"Hello!\"}]\n\n# 首页重定向到文档\n@app.get(\"/\")\ndef home():\n    return RedirectResponse(url=\"/docs\")\n\n# 获取所有笔记 (带查询参数分页)\n@app.get(\"/notes/\")\ndef get_notes(skip: int = Query(0, ge=0), limit: int = Query(10, le=100)):\n    return fake_notes_db[skip : skip + limit]\n\n# 根据ID获取特定笔记 (路径参数)\n@app.get(\"/notes/{note_id}\")\ndef get_note_by_id(note_id: int = Path(..., title=\"笔记ID\", gt=0)):\n    for note in fake_notes_db:\n        if note[\"id\"] == note_id:\n            return note\n    return {\"error\": \"Note not found\"}\n\n# 创建新笔记 (POST JSON)\n@app.post(\"/notes/\")\ndef create_note(note: Note, response: Response):\n    new_id = max([n[\"id\"] for n in fake_notes_db], default=0) + 1\n    new_note = {\"id\": new_id, **note.dict()}\n    fake_notes_db.append(new_note)\n    response.headers[\"Location\"] = f\"/notes/{new_id}\"\n    response.status_code = 201\n    return new_note\n\n# 一个需要User-Agent头的端点\n@app.get(\"/check-agent/\")\ndef check_user_agent(user_agent: Optional[str] = Header(None)):\n    return {\"received_user_agent\": user_agent}\n\n# 表单登录示例\n@app.post(\"/login-form/\")\ndef login_form(username: str = Form(...), password: str = Form(...)):\n    # 这里应该有真实的验证逻辑\n    if username == \"admin\" and password == \"secret\":\n        return {\"message\": \"Login successful\"}\n    return {\"message\": \"Invalid credentials\"}</code></pre>\n<p>启动后，访问 <a href=\"http://127.0.0.1:8000/docs\" rel=\"noopener nofollow\" style=\"color: rgba(76, 175, 80, 1); text-decoration: none;\">http://127.0.0.1:8000/docs</a> 即可看到交互式API文档，并直接测试所有端点！</p>\n<hr style=\"border-right: none; border-bottom: none; border-left: none; margin: 40px 0;\" />\n<div style=\"text-align: center; color: rgba(119, 119, 119, 1); margin-bottom: 40px;\">\n<p>---</p>\n<p style=\"font-size: 15px;\">喜欢本文？不要错过✨，点赞👍收藏⭐关注我👆，一起学习更多有用的知识，完善你我的技能树！</p>\n</div>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-24 08:24</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ymtianyu\">曲幽</a>&nbsp;\n阅读(<span id=\"post_view_count\">18</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一条SQL直接跑崩288核，1.5T内存数据库",
      "link": "https://www.cnblogs.com/idealx/p/19389621",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/idealx/p/19389621\" id=\"cb_post_title_url\" title=\"发布于 2025-12-23 23:48\">\n    <span>一条SQL直接跑崩288核，1.5T内存数据库</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>最近遇到一个Oracle的SQL语句引发的线上故障，数据库服务被重启。主机288核，1.5T也没抗住。</p>\n<pre><code>select  count(*) from dev_db.t1 t1,dev_db.t2 t2 where t1.object_name = t2.object_name or t1.DATA_OBJECT_ID = t2.DATA_OBJECT_ID and t1.OBJECT_ID = 123 and rownum = 1;\n--------------------------------------------------------------------------------\n| Id  | Operation               | Name | Rows  | Bytes | Cost (%CPU)| Time     |\n--------------------------------------------------------------------------------\n|   0 | SELECT STATEMENT        |      |     1 |    77 |    31M  (1)| 00:20:50 |\n|   1 |  SORT AGGREGATE         |      |     1 |    77 |            |          |\n|   2 |   COUNT                 |      |       |       |            |          |\n|*  3 |    FILTER               |      |       |       |            |          |\n|   4 |     MERGE JOIN CARTESIAN|      |  6131M|   439G|    31M  (1)| 00:20:50 |\n|   5 |      TABLE ACCESS FULL  | T1   | 78306 |  3135K|   411   (1)| 00:00:01 |\n|   6 |      BUFFER SORT        |      | 78307 |  2752K|    31M  (1)| 00:20:50 |\n|   7 |       TABLE ACCESS FULL | T2   | 78307 |  2752K|   409   (1)| 00:00:01 |\n--------------------------------------------------------------------------------\n\nPredicate Information (identified by operation id):\n---------------------------------------------------\n\n   3 - filter(\"T1\".\"OBJECT_NAME\"=\"T2\".\"OBJECT_NAME\" OR\n              \"T1\".\"DATA_OBJECT_ID\"=\"T2\".\"DATA_OBJECT_ID\" AND \"T2\".\"DATA_OBJECT_ID\"\n              IS NOT NULL AND \"T1\".\"DATA_OBJECT_ID\" IS NOT NULL AND\n              \"T1\".\"OBJECT_ID\"=123 AND ROWNUM=1)\n</code></pre>\n<p>在执行计划中看到步骤4产生了笛卡尔积连接，成本相当的高，这两个表仅有7万行数据，执行时间超过了5分钟。<br />\n数据库中关于NOT、AND、OR的逻辑运算优先级就是按这个顺序进行的，判断是开发人员失误造成的。下面是经过优化后的执行计划。</p>\n<pre><code>select  count(*) from dev_db.t1 t1,dev_db.t2 t2 where (t1.object_name = t2.object_name or t1.DATA_OBJECT_ID = t2.DATA_OBJECT_ID) and t1.OBJECT_ID = 123 and rownum = 1;\n-----------------------------------------------------------------------------\n| Id  | Operation            | Name | Rows  | Bytes | Cost (%CPU)| Time     |\n-----------------------------------------------------------------------------\n|   0 | SELECT STATEMENT     |      |     1 |    77 |   822   (1)| 00:00:01 |\n|   1 |  SORT AGGREGATE      |      |     1 |    77 |            |          |\n|*  2 |   COUNT STOPKEY      |      |       |       |            |          |\n|   3 |    NESTED LOOPS      |      |     1 |    77 |   822   (1)| 00:00:01 |\n|*  4 |     TABLE ACCESS FULL| T1   |     1 |    41 |   411   (1)| 00:00:01 |\n|*  5 |     TABLE ACCESS FULL| T2   |     1 |    36 |   411   (1)| 00:00:01 |\n-----------------------------------------------------------------------------\n\nPredicate Information (identified by operation id):\n---------------------------------------------------\n\n   2 - filter(ROWNUM=1)\n   4 - filter(\"T1\".\"OBJECT_ID\"=123)\n   5 - filter(\"T1\".\"OBJECT_NAME\"=\"T2\".\"OBJECT_NAME\" OR\n              \"T2\".\"DATA_OBJECT_ID\" IS NOT NULL AND\n              \"T1\".\"DATA_OBJECT_ID\"=\"T2\".\"DATA_OBJECT_ID\" AND \"T1\".\"DATA_OBJECT_ID\"\n              IS NOT NULL)\n</code></pre>\n<p>在这个执行计划中，t1表作为驱动表，过滤条件是object_id=123,线上这个条件是主键，因为懒没有创建这个主键，所以是全表扫描。<br />\nt2表作为被驱动表只匹配到了一条数据。因为STOPKEY的优化，在取到一条数据后SQL停止，无需扫描全部数据，因此执行时间非常短。</p>\n<h2 id=\"总结\">总结</h2>\n<p>本次问题原因是因为一个逻辑运算的优先级判断错误，以至于数据库资源被使用完导致数据库节点被重启。<br />\n对于自己拿不准的SQL语句，查阅官方文档是最权威的参考依据。<br />\n其次，在测试环境就算只有少量数据也可以看到执行计划是否合理。<br />\n最后，上线时SQL语句经过把关，可以最大限度减少SQL语句引发的线上故障。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-23 23:48</span>&nbsp;\n<a href=\"https://www.cnblogs.com/idealx\">ideal_x</a>&nbsp;\n阅读(<span id=\"post_view_count\">297</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "envoy使用consul做服务发现",
      "link": "https://www.cnblogs.com/MrVolleyball/p/19390666",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/MrVolleyball/p/19390666\" id=\"cb_post_title_url\" title=\"发布于 2025-12-24 10:22\">\n    <span>envoy使用consul做服务发现</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>上一篇内容，我们详细讨论了怎么使用envoy做负载均衡，并且记录详细的地址，其中还解决了一个问题，那就是怎么让envoy获取真实后端pod ip地址，后面使用headless service，既使用了service的服务发现能力，又不使用service的负载均衡能力</p>\n<p>如果在某些特殊的场景下完全放弃的k8s service（比如混合云部署机房，两边云都需要有相同的服务，但是服务之间不能跨云访问），怎么赋予envoy服务发现的能力</p>\n<h2 id=\"静态配置服务发现\">静态配置服务发现</h2>\n<p>顾名思义，直接写在配置里面</p>\n<pre><code>...\nstatic_resources:\n...\n\n  clusters:\n  - name: backend_cluster\n    connect_timeout: 0.25s\n    type: STATIC\n    load_assignment:\n      cluster_name: backend_cluster\n      endpoints:\n      - lb_endpoints:\n        - endpoint:\n            address:\n              socket_address:\n                address: 192.168.1.100\n                port_value: 8080\n        - endpoint:\n            address:\n              socket_address:\n                address: 192.168.1.101\n                port_value: 8080\n...\n</code></pre>\n<p><code>type: STATIC</code>是关键配置</p>\n<h2 id=\"基于dns的服务发现\">基于dns的服务发现</h2>\n<p>之前的k8s服务发现，就是利用k8s dns做的服务发现，这里再举一个例子，也是经常使用的三方注册中心，consul</p>\n<h4 id=\"安装consul\">安装consul</h4>\n<pre><code>docker run -d --name consul \\\n -p 8300-8302:8300-8302 \\\n -p 8500:8500 \\\n -p 8301-8302 \\\n -p 8600:8600/udp \\\n hashicorp/consul:1.22\n</code></pre>\n<p>这里的关键是<code>-p 8600:8600/udp</code></p>\n<h4 id=\"修改coredns配置\">修改coredns配置</h4>\n<p>kubectl -n kube-system edit cm coredns</p>\n<pre><code>...\n        forward consul 10.22.12.178:8600 {\n            prefer_udp\n        }\n...\n</code></pre>\n<p>只要访问*.consul的域名，都去访问10.22.12.178:8600，而8600端口，就是consul提供的dns udp端口</p>\n<p>至于为什么是*.consul呢？.service.consul 是 Consul 官方规定的服务发现域名</p>\n<table>\n<thead>\n<tr>\n<th>域名</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>service.consul</code></td>\n<td>服务发现（最常用）</td>\n</tr>\n<tr>\n<td><code>node.consul</code></td>\n<td>查询节点 IP</td>\n</tr>\n<tr>\n<td><code>query.consul</code></td>\n<td>Prepared Query</td>\n</tr>\n<tr>\n<td><code>dc.consul</code></td>\n<td>跨数据中心</td>\n</tr>\n</tbody>\n</table>\n<p>所以直接转发*.consul，粗暴有效</p>\n<h4 id=\"往consul注册数据\">往consul注册数据</h4>\n<pre><code>curl -X PUT http://10.22.12.178:8500/v1/agent/service/register \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"Name\": \"backend-service-consul\",\n    \"ID\": \"service-1\",\n    \"Address\": \"10.244.0.82\",\n    \"Port\": 10000\n  }'\n</code></pre>\n<h4 id=\"修改envoy配置\">修改envoy配置</h4>\n<pre><code>...\n      clusters:\n        - name: app_service\n          connect_timeout: 1s\n          type: STRICT_DNS\n          lb_policy: ROUND_ROBIN\n          load_assignment:\n            cluster_name: app_service\n            endpoints:\n              - lb_endpoints:\n                  - endpoint:\n                      address:\n                        socket_address:\n                          address: \"backend-service-consul.service.consul\"\n                          port_value: 10000\n...\n</code></pre>\n<p>修改完之后重启服务</p>\n<p>这里需要注意的是<code>address: \"backend-service-consul.service.consul\"</code></p>\n<ul>\n<li><code>backend-service-consul</code>是注册到consul的名字</li>\n<li><code>.service.consul</code>上面已经说过，这是consul的固定格式</li>\n</ul>\n<h4 id=\"验证\">验证</h4>\n<p><code>curl 10.22.12.178:30785/test</code></p>\n<pre><code>[2025-12-18T09:42:47.296Z] \"GET /test HTTP/1.0\" 200 40 1 fd326a0e-ec4f-4cf3-a244-b29f4c0c0173 \"curl/7.81.0\" \"-\" 10.244.0.82:10000 app_service -\n[2025-12-18T09:42:47.584Z] \"GET /test HTTP/1.0\" 200 40 0 b44ce502-a8ed-489a-b95b-d3c21af9d24d \"curl/7.81.0\" \"-\" 10.244.0.82:10000 app_service -\n[2025-12-18T09:42:47.816Z] \"GET /test HTTP/1.0\" 200 40 1 f6ac4149-1e58-4b0e-a263-85fc89cef968 \"curl/7.81.0\" \"-\" 10.244.0.82:10000 app_service -\n[2025-12-18T09:42:48.039Z] \"GET /test HTTP/1.0\" 200 40 1 c64c7f05-bcbb-42a7-9e68-a376217a4ca2 \"curl/7.81.0\" \"-\" 10.244.0.82:10000 app_service -\n[2025-12-18T09:42:48.240Z] \"GET /test HTTP/1.0\" 200 40 1 96097880-bc28-4686-98d3-ab09848cf28a \"curl/7.81.0\" \"-\" 10.244.0.82:10000 app_service -\n[2025-12-18T09:42:48.464Z] \"GET /test HTTP/1.0\" 200 40 0 799f7f10-1cb1-447a-828a-45ccc50273f5 \"curl/7.81.0\" \"-\" 10.244.0.82:10000 app_service -\n</code></pre>\n<p>确实已经生效了</p>\n<h4 id=\"consul小结\">consul小结</h4>\n<p>这里展示了怎么使用consul作为服务发现，不管是用headless还是consul，都是dns的服务发现，在consul的例子中，将固定域名（.service.consul）引导至consul提供的dns服务，从而实现</p>\n<h2 id=\"小结\">小结</h2>\n<p>本文介绍了如何使用静态的服务发现以及基于dns的服务发现，但是他们都存在一个问题，一旦envoy的配置有所改变，比如<code>\"backend-service-consul.service.consul\"</code>域名发生变化，或者<code>port_value: 10000</code> 端口发生变化， 那就势必要重启envoy来重新加载配置，这就带来了系统的复杂性与不稳定性了</p>\n<p>那有没有什么方法是可以自动加载配置呢？肯定是有的，那又是下一文的内容</p>\n<h2 id=\"联系我\">联系我</h2>\n<ul>\n<li>联系我，做深入的交流</li>\n</ul>\n<p><img alt=\"\" class=\"lazyload\" height=\"200\" width=\"500\" /></p>\n<hr />\n<p>至此，本文结束<br />\n在下才疏学浅，有撒汤漏水的，请各位不吝赐教...</p>\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/MrVolleyball/\" target=\"_blank\">it排球君</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/MrVolleyball/p/19390666\" target=\"_blank\">https://www.cnblogs.com/MrVolleyball/p/19390666</a></p>\n<div>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须在文章页面给出原文连接，否则保留追究法律责任的权利。 </div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-24 10:22</span>&nbsp;\n<a href=\"https://www.cnblogs.com/MrVolleyball\">it排球君</a>&nbsp;\n阅读(<span id=\"post_view_count\">23</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "ClaudeCode 使用指南",
      "link": "https://www.cnblogs.com/QccupiedByAurora/p/19390729",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/QccupiedByAurora/p/19390729\" id=\"cb_post_title_url\" title=\"发布于 2025-12-24 10:19\">\n    <span>ClaudeCode 使用指南</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"安装\">安装</h1>\n<h2 id=\"win环境\">Win环境</h2>\n<p><strong>1. 安装Node.js</strong></p>\n<pre><code class=\"language-cpp\">// 使用NodeSource仓库（推荐）\ncurl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -\nsudo apt-get install -y nodejs\n\n// 验证安装\nnode --version\nnpm --version\n</code></pre>\n<p><strong>2. 安装Git</strong></p>\n<pre><code class=\"language-cpp\">// 官网下载比较慢，推荐使用镜像下载，我这里用的是清华大学镜像源\nhttps://mirrors.tuna.tsinghua.edu.cn/github-release/git-for-windows/git/\n</code></pre>\n<p><strong>3. 安装Claude code</strong></p>\n<pre><code class=\"language-cpp\">// 全局安装\nnpm install -g @anthropic-ai/claude-code\n\n// 验证安装\nclaude --version\n\n// 启动Claude\nclaude \n</code></pre>\n<p><strong>4.配置Anthropic服务</strong><br />\n当启动claude时，报错</p>\n<pre><code class=\"language-cpp\">Unable to connect to Anthropic services \nFailed to connect to api.anthropic.com: ERR_BAD _REQUEST\n</code></pre>\n<p>解决方法：</p>\n<ol>\n<li>\n<p>找到<code>.claude.json</code>文件，一般在 <code>c://Users//your_name//</code> 路径下</p>\n</li>\n<li>\n<p>添加&nbsp;hasCompletedOnboarding&nbsp;字段<br />\n在</p>\n</li>\n</ol>\n<pre><code class=\"language-cpp\">{\n  \"installMethod\": \"unknown\",\n  \"autoUpdates\": true,\n   ····\n  // 可以不管上面的内容\n  \"hasCompletedOnboarding\": true  // 新增字段\n}\n</code></pre>\n<p><strong>5.配置GLM api</strong><br />\n在 <code>C:\\Users\\Administrator\\.claude</code>路径下修改（新增）<code>setting.json</code> 文件<br />\n内容如下：</p>\n<pre><code class=\"language-cpp\">{\n  \"env\": {\n    \"ANTHROPIC_AUTH_TOKEN\": \" 你的api密钥 \",\n    \"ANTHROPIC_BASE_URL\": \"https://open.bigmodel.cn/api/anthropic\",\n    \"API_TIMEOUT_MS\": \"3000000\",\n    \"ANTHROPIC_DEFAULT_HAIKU_MODEL\": \"glm-4.5-air\",\n    \"ANTHROPIC_DEFAULT_SONNET_MODEL\": \"glm-4.6\",\n    \"ANTHROPIC_DEFAULT_OPUS_MODEL\": \"glm-4.6\"\n  }\n}\n</code></pre>\n<p><strong>6.重新启动Claude</strong></p>\n<pre><code class=\"language-cpp\">// 关闭所有Claude进程（如果有）\npkill -f claude\n \n// 重新启动Claude\nclaude\n</code></pre>\n<h1 id=\"基础使用\">基础使用</h1>\n<h2 id=\"会话内命令斜杠命令\">会话内命令（斜杠命令）##</h2>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>/compact</td>\n<td>压缩对话上下文</td>\n<td>保留核心信息，节省Token</td>\n</tr>\n<tr>\n<td>/clear</td>\n<td>清除对话历史</td>\n<td>完全重置当前对话</td>\n</tr>\n<tr>\n<td>/history</td>\n<td>查看历史对话</td>\n<td>选择之前的对话继续</td>\n</tr>\n<tr>\n<td>/edit</td>\n<td>编辑记忆文件</td>\n<td>修改用户或项目记忆</td>\n</tr>\n<tr>\n<td>/model</td>\n<td>切换AI模型</td>\n<td>选择不同的Claude模型</td>\n</tr>\n<tr>\n<td>/help</td>\n<td>显示帮助</td>\n<td>查看所有可用命令</td>\n</tr>\n<tr>\n<td>/exit</td>\n<td>退出Claude Code</td>\n<td>返回普通终端</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"think模式完全指南\">Think模式完全指南</h2>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>思考深度</th>\n<th>Token消耗</th>\n<th>适用场景</th>\n<th>响应时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>think</td>\n<td>基础</td>\n<td>低</td>\n<td>简单问题、快速回答</td>\n<td>2-5秒</td>\n</tr>\n<tr>\n<td>think hard</td>\n<td>深度</td>\n<td>中</td>\n<td>复杂逻辑、算法设计</td>\n<td>5-15秒</td>\n</tr>\n<tr>\n<td>think harder</td>\n<td>更深度</td>\n<td>高</td>\n<td>架构设计、难题分析</td>\n<td>15-30秒</td>\n</tr>\n<tr>\n<td>ultrathink</td>\n<td>极深度</td>\n<td>极高</td>\n<td>最复杂问题、创新方案</td>\n<td>30-60秒</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"创建自定义命令\">创建自定义命令</h2>\n<p>Claude Code 支持自定义命令，你可以创建一些命令来快速执行特定的提示或任务。<br />\n自定义命令语法：</p>\n<pre><code class=\"language-cpp\">/&lt;prefix&gt;:&lt;command-name&gt; [arguments]\n</code></pre>\n<p><strong>自定义命令解读：</strong></p>\n<ul>\n<li>命令分为用户级和项目级；</li>\n<li>用户级命令所有项目都能用，项目级命令只有当前项目可以用；</li>\n<li>用户级命令放在个人 <code>~/.claude/commands</code>目录下，而项目级命令放在当前项目<code>.claude/commands</code>目录下；</li>\n<li>使用命令时，用户级命令以 <code>/user: </code>为前缀，项目级命令<code>/project:</code>为前缀，后面跟的是<code>命令文件名称</code>，可级联；</li>\n<li>命令文件支持使用<code>$ARGUMENTS</code>参数占位符，在命令后面带上参数，如：/project:test 123 它会用 123 替换命令文件中的<code>$ARGUMENTS</code>标记。<br />\n比如如果有 .claude/commands/component.md 自定义命令，使用方法 就是：/project:component。</li>\n</ul>\n<p><strong>实战使用</strong></p>\n<p>项目级命令</p>\n<p>在当前项目创建自定义命令目录：</p>\n<pre><code class=\"language-cpp\">mkdir -p .claude/commands\n</code></pre>\n<p>创建一个项目级优化命令：</p>\n<pre><code class=\"language-cpp\">echo \"分析这个项目的性能，并提出三个具体的优化建议。\" &gt; .claude/commands/optimize.md\n</code></pre>\n<p>在 Claude Code 中使用自定义命令：</p>\n<pre><code class=\"language-cpp\">/project:optimize\n</code></pre>\n<h2 id=\"mcp服务器配置详解\">MCP服务器配置详解</h2>\n<p>MCP基础概念<br />\nMCP（Model Context Protocol）是Anthropic推出的开源通信标准，让Claude Code可以：</p>\n<ul>\n<li>📁 访问本地文件系统</li>\n<li>🌐 连接各种API服务</li>\n<li>🗄️ 操作数据库</li>\n<li>🛠️ 集成开发工具</li>\n<li>🔧 自动化任务</li>\n</ul>\n<p><strong>MCP服务器作用域</strong></p>\n<table>\n<thead>\n<tr>\n<th>作用域</th>\n<th>配置位置</th>\n<th>适用场景</th>\n<th>命令标志</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Local</td>\n<td>当前目录</td>\n<td>项目特定工具</td>\n<td>默认</td>\n</tr>\n<tr>\n<td>User</td>\n<td>~/.claude.json</td>\n<td>全局常用工具</td>\n<td>-s user</td>\n</tr>\n<tr>\n<td>Project</td>\n<td>.mcp.json</td>\n<td>团队共享工具</td>\n<td>-s project</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li>添加MCP服务器</li>\n</ol>\n<pre><code class=\"language-cpp\">// 基本语法\nclaude mcp add &lt;名称&gt; [选项] -- &lt;命令&gt; [参数...]\n\n// 添加文件系统访问\nclaude mcp add filesystem -s user -- npx -y @modelcontextprotocol/server-filesystem ~/Documents ~/Projects //后面跟路径\n// 如果要追加路径的话需要删除掉之前的再添加\nclaude mcp remove filesystem -s user\nclaude mcp add filesystem -s user -- npx -y @modelcontextprotocol/server-filesystem  \"路径一\" \"路径二\"\n\n// 添加GitHub集成\nclaude mcp add github -s user -e GITHUB_TOKEN=your_token -- npx -y @modelcontextprotocol/server-github\n\n// 添加Gitee集成\n\n// 添加Sequential Thinking（思维链）\nclaude mcp add thinking -s user -- npx -y @modelcontextprotocol/server-sequential-thinking\n\n</code></pre>\n<ol start=\"2\">\n<li>MCP管理命令</li>\n</ol>\n<pre><code class=\"language-cpp\">// 查看已安装的MCP服务器\nclaude mcp list\n\n// 删除MCP服务器\nclaude mcp remove &lt;server_name&gt;\n\n// 测试MCP服务器\nclaude mcp test &lt;server_name&gt;\n\n// 查看MCP状态\n/mcp\n</code></pre>\n<h2 id=\"记忆系统详解\">记忆系统详解</h2>\n<p>Claude Code的记忆系统让AI能够记住你的偏好和项目信息。</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>位置</th>\n<th>作用域</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>用户记忆</td>\n<td>~/.claude/CLAUDE.md</td>\n<td>全局</td>\n<td>个人偏好、编码风格</td>\n</tr>\n<tr>\n<td>项目记忆</td>\n<td>项目根目录/.CLAUDE.md</td>\n<td>项目</td>\n<td>项目特定信息</td>\n</tr>\n</tbody>\n</table>\n<p>记忆文件管理</p>\n<pre><code class=\"language-cpp\">/memory\n可以在系统编辑器中打开记忆文件\n</code></pre>\n<h2 id=\"openspec-安装与使用\">OpenSpec 安装与使用</h2>\n<p>openSpec是一个比spec-kit更轻量的spec driven开发套件，有了他，你可以一定程度上解决ai coding失控膨胀，以致越来越不可维护的问题。</p>\n<p><strong>1. 原理</strong></p>\n<ol>\n<li>在项目中创建一个 openspec/ 目录，作为“规格 + 变更记录中心”。</li>\n<li>每次需求或改动，都用一个 changes// 文件夹描述：</li>\n</ol>\n<ul>\n<li>为什么改（proposal.md）</li>\n<li>要做什么（spec diff）</li>\n<li>怎么做（tasks.md）</li>\n</ul>\n<p><strong>2.安装OpenSpec</strong></p>\n<pre><code class=\"language-cpp\">npm install -g @fission-ai/openspec@latest\nopenspec --version   //  确认安装成功\n</code></pre>\n<p><strong>3.初始化项目</strong></p>\n<pre><code class=\"language-cpp\">cd your-project  // 切换到你项目路径\nopenspec init\n</code></pre>\n<p>它会询问你使用哪些 AI 工具（Claude Code / Cursor / Factory / Codex / KiloCode 等）</p>\n<p><strong>4.OpenSpec使用</strong><br />\nOpenSpec 的核心是三个命令：</p>\n<table>\n<thead>\n<tr>\n<th>阶段</th>\n<th>命令</th>\n<th>目标</th>\n<th>输出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>规划期</td>\n<td><code>/openspec:proposal</code></td>\n<td>对齐需求与规范</td>\n<td><code>proposal.md</code> + 规范差异（spec diff）</td>\n</tr>\n<tr>\n<td>实施期</td>\n<td><code>/openspec:apply</code></td>\n<td>按任务执行开发</td>\n<td>更新后的代码 + 完成的任务清单</td>\n</tr>\n<tr>\n<td>收尾期</td>\n<td><code>/openspec:archive</code></td>\n<td>合并与归档变更</td>\n<td>更新 <code>specs/</code> 目录 + 归档变更记录</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-24 10:19</span>&nbsp;\n<a href=\"https://www.cnblogs.com/QccupiedByAurora\">一楼二栋</a>&nbsp;\n阅读(<span id=\"post_view_count\">65</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}