{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "字典树的一百种用法",
      "link": "https://www.cnblogs.com/rp-plus-plus/p/19435184",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/rp-plus-plus/p/19435184\" id=\"cb_post_title_url\" title=\"发布于 2026-01-04 00:08\">\n    <span>字典树的一百种用法</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p></p><div class=\"math display\">\\[\\huge\\texttt{0/1 Trie}\n\\]</div><p></p><p></p><div class=\"math display\">\\[\\LARGE\\texttt{\\#1-Count Inversions}\n\\]</div><p></p><p></p><div class=\"math display\">\\[\\large\\texttt{Problem}\n\\]</div><p></p><p><a href=\"https://www.luogu.com.cn/problem/P1908\" rel=\"noopener nofollow\" target=\"_blank\">$$\\texttt{link}$$</a></p>\n<p></p><div class=\"math display\">\\[\\large\\texttt{Idea}\n\\]</div><p></p><p>考虑逆序对总个数的表达式：</p>\n<p></p><div class=\"math display\">\\[\\sum_{i=2}^{n}\\sum_{j=1}^{i-1}\\left[a_i&lt;a_j\\right]\n\\]</div><p></p><p>显然，通过式子直接暴力，复杂度为 <span class=\"math inline\">\\(\\mathcal{O}(n^2)\\)</span>，显然错误。</p>\n<p>考虑对于内层循环进行优化，主要问题在于如果最原始地进行比较大小需要一个一个进行比较。</p>\n<p>于是，想到高位更大的数字一定更大，我们可以从高位依次比较。</p>\n<p>于是我们可以考虑使用字典树，利用字典树存储二进制下每个数的每一位数。</p>\n<p></p><div class=\"math display\">\\[\\large\\texttt{Solution}\n\\]</div><p></p><p>对于每个数一次插入字典树，具体参考模板，以下仅赘述统计逆序对的部分。</p>\n<p>假设当前插入的数为 <span class=\"math inline\">\\(x\\)</span>：</p>\n<ul>\n<li>若当前遍历的位数上的编码为 <span class=\"math inline\">\\(\\texttt{0}\\)</span>，则这一位编码为 <span class=\"math inline\">\\(\\texttt{1}\\)</span> 的数能与 <span class=\"math inline\">\\(x\\)</span> 构成逆序对，更新答案，继续向下一位遍历。</li>\n<li>若当前遍历的位数上的编码为 <span class=\"math inline\">\\(\\texttt{1}\\)</span>，则继续向下一位遍历。</li>\n</ul>\n<p>具体统计可以记录每个节点下存有几个数。</p>\n<p>这里注意一个细节，每个数二进制形式的长度不同，需要统一长度，一种方法是都将长度变为 <span class=\"math inline\">\\(30\\)</span>，在前面填 <span class=\"math inline\">\\(\\texttt{0}\\)</span> 即可。</p>\n<p>时间复杂度 <span class=\"math inline\">\\(\\mathcal{O}(n)\\)</span>，实则如果全部统一成 <span class=\"math inline\">\\(30\\)</span> 位是有一个大常数 <span class=\"math inline\">\\(30\\)</span> 的，写标准复杂度应该是 <span class=\"math inline\">\\(\\mathcal{O}\\left(n\\log\\left(\\max\\limits_{1\\le i\\le n}\\left\\{a_i\\right\\}\\right)\\right)\\)</span>。</p>\n<p>当然还有其它解决长度不统一的方法。</p>\n<p></p><div class=\"math display\">\\[\\large\\texttt{Code}\n\\]</div><p></p><pre><code class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint n,nex[15000005][2],cnt,siz[15000005];\nlong long ans;\nvoid insert(int s){\n    int p=0;\n    for(int i=29;i&gt;=0;i--){\n        int c=(s&gt;&gt;i)&amp;1;\n        if(c==0)ans+=siz[nex[p][1]];\n        if(!nex[p][c])nex[p][c]=++cnt;\n        p=nex[p][c];\n        siz[p]++;\n    }\n}\nsigned main(){\n    cin&gt;&gt;n;\n    for(int a,i=1;i&lt;=n;i++){\n        cin&gt;&gt;a;\n        insert(a);\n    }\n    cout&lt;&lt;ans;\n    return 0;\n}\n</code></pre>\n<p>又短又好写。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-04 00:08</span>&nbsp;\n<a href=\"https://www.cnblogs.com/rp-plus-plus\">盼满天繁星</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "C++ 中的 vector",
      "link": "https://www.cnblogs.com/bfmhno3/p/19435123",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/bfmhno3/p/19435123\" id=\"cb_post_title_url\" title=\"å‘å¸ƒäºŽ 2026-01-03 23:00\">\n    <span>C++ ä¸­çš„ vector</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        æ·±å…¥ç†è§£ C++ ä¸­æœ€å¸¸ç”¨çš„å®¹å™¨ std::vectorï¼šåŠ¨æ€æ•°ç»„çš„æ ¸å¿ƒç‰¹æ€§ã€å†…å­˜ç®¡ç†ã€æ‰©å®¹æœºåˆ¶ã€è¿­ä»£å™¨å¤±æ•ˆé—®é¢˜ï¼Œä»¥åŠ reserveã€emplace_back ç­‰çŽ°ä»£åŒ–æœ€ä½³å®žè·µã€‚ç‰¹åˆ«æé†’ std::vector\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">ç›®å½•</div><ul><li><a href=\"#æ ¸å¿ƒç‰¹æ€§ä¸Žåº•å±‚åŽŸç†\" rel=\"noopener nofollow\">æ ¸å¿ƒç‰¹æ€§ä¸Žåº•å±‚åŽŸç†</a></li><li><a href=\"#åˆå§‹åŒ–ä¸Žæž„é€\" rel=\"noopener nofollow\">åˆå§‹åŒ–ä¸Žæž„é€ </a></li><li><a href=\"#å®¹é‡ä¸Žå¤§å°\" rel=\"noopener nofollow\">å®¹é‡ä¸Žå¤§å°</a><ul><li><a href=\"#ä¸ºä»€ä¹ˆ-reserve-éžå¸¸é‡è¦\" rel=\"noopener nofollow\">ä¸ºä»€ä¹ˆ <code>reserve</code> éžå¸¸é‡è¦ï¼Ÿ</a></li></ul></li><li><a href=\"#å¢žåˆ æŸ¥æ”¹\" rel=\"noopener nofollow\">å¢žåˆ æŸ¥æ”¹</a><ul><li><a href=\"#æ’å…¥ä¸Žæ·»åŠ\" rel=\"noopener nofollow\">æ’å…¥ä¸Žæ·»åŠ </a></li><li><a href=\"#åˆ é™¤\" rel=\"noopener nofollow\">åˆ é™¤</a></li><li><a href=\"#è®¿é—®\" rel=\"noopener nofollow\">è®¿é—®</a></li></ul></li><li><a href=\"#è¿­ä»£å™¨å¤±æ•ˆ\" rel=\"noopener nofollow\">è¿­ä»£å™¨å¤±æ•ˆ</a></li><li><a href=\"#ç‰¹æ®Šç‰ˆæœ¬stdvectorbool\" rel=\"noopener nofollow\">ç‰¹æ®Šç‰ˆæœ¬ï¼š<code>std::vector&lt;bool&gt;</code></a></li><li><a href=\"#çŽ°ä»£åŒ–æ“ä½œ\" rel=\"noopener nofollow\">çŽ°ä»£åŒ–æ“ä½œ</a><ul><li><a href=\"#c20stderase-å’Œ-stderase_if\" rel=\"noopener nofollow\">C++20ï¼š<code>std::erase</code> å’Œ <code>std::erase_if</code></a></li></ul></li><li><a href=\"#æœ€ä½³å®žè·µ\" rel=\"noopener nofollow\">æœ€ä½³å®žè·µ</a></li></ul></div><p></p>\n<blockquote>\n<p><strong>æœ¬æ–‡é¦–å‘äºŽæˆ‘çš„ä¸ªäººåšå®¢ï¼š<a href=\"https://bfmhno3.github.io/\" rel=\"noopener nofollow\" target=\"_blank\">Better Mistakes</a></strong></p>\n<p><strong>ç‰ˆæƒå£°æ˜Ž</strong>ï¼šæœ¬æ–‡ä¸ºåŽŸåˆ›æ–‡ç« ï¼Œè½¬è½½è¯·é™„ä¸ŠåŽŸæ–‡å‡ºå¤„é“¾æŽ¥åŠæœ¬å£°æ˜Žã€‚<br />\nç”±äºŽæŠ€æœ¯è¿­ä»£è¾ƒå¿«ï¼Œæ–‡ç« å†…å®¹å¯èƒ½éšæ—¶æ›´æ–°ï¼ˆå«å‹˜è¯¯åŠè¡¥å……ï¼‰ã€‚ä¸ºäº†ç¡®ä¿æ‚¨çœ‹åˆ°çš„æ˜¯æœ€æ–°ç‰ˆæœ¬ï¼Œå¹¶èŽ·å¾—æ›´å¥½çš„ä»£ç é˜…è¯»ä½“éªŒï¼Œè¯·è®¿é—®ï¼š</p>\n<p>ðŸ­ <strong>åŽŸæ–‡é“¾æŽ¥</strong>ï¼š<a href=\"https://bfmhno3.github.io/note/vector-in-cpp/\" rel=\"noopener nofollow\" target=\"_blank\">https://bfmhno3.github.io/note/vector-in-cpp/</a></p>\n</blockquote>\n<hr />\n<p><code>std::vector</code> æ˜¯ C++ ä¸­<strong>æœ€é‡è¦</strong>ã€<strong>æœ€å¸¸ç”¨</strong>çš„å®¹å™¨ï¼Œæ²¡æœ‰ä¹‹ä¸€ã€‚å®ƒçš„æœ¬è´¨æ˜¯<strong>åŠ¨æ€æ•°ç»„</strong>ï¼ˆDynamic Arrayï¼‰ã€‚</p>\n<p><code>std::vector</code> æ˜¯åœ¨å †ï¼ˆHeapï¼‰ä¸Šç®¡ç†ä¸€å—è¿žç»­çš„å†…å­˜ï¼Œå¯ä»¥å­˜æ”¾ä»»æ„ç±»åž‹çš„å¯¹è±¡ã€‚</p>\n<h2 id=\"æ ¸å¿ƒç‰¹æ€§ä¸Žåº•å±‚åŽŸç†\">æ ¸å¿ƒç‰¹æ€§ä¸Žåº•å±‚åŽŸç†</h2>\n<ul>\n<li>å¤´æ–‡ä»¶ï¼š<code>#include &lt;vector&gt;</code></li>\n<li>å†…å­˜æ¨¡åž‹ï¼š<strong>è¿žç»­å†…å­˜</strong>ã€‚è¿™æ„å‘³ç€å®ƒå’Œ C æ•°ç»„ä¸€æ ·ï¼Œæ”¯æŒé€šè¿‡æŒ‡é’ˆåç§»é‡å¿«é€Ÿè®¿é—®ï¼Œå¹¶ä¸”å¯¹ CPU ç¼“å­˜ï¼ˆCacheï¼‰éžå¸¸å‹å¥½ã€‚</li>\n<li><strong>è‡ªåŠ¨æ‰©å®¹</strong>ï¼šå½“å­˜å…¥æ•°æ®é‡è¶…è¿‡å½“å‰å®¹é‡æ—¶ï¼Œ<code>std::vector</code> å°±ä¼šç”³è¯·ä¸€å—æ›´å¤§çš„å†…å­˜ï¼ˆé€šå¸¸æ˜¯åŽŸæ¥çš„ 1.5 å€æˆ– 2 å€ï¼‰ï¼Œå°†æ—§æ•°æ®ç§»åŠ¨/æ‹·è´è¿‡åŽ»ï¼Œç„¶åŽé‡Šæ”¾æ—§å†…å­˜ã€‚</li>\n</ul>\n<h2 id=\"åˆå§‹åŒ–ä¸Žæž„é€ \">åˆå§‹åŒ–ä¸Žæž„é€ </h2>\n<pre><code class=\"language-cpp\">#include &lt;vector&gt;\n\n// 1. é»˜è®¤æž„é€ ï¼ˆç©º vectorï¼‰\nstd::vector&lt;int&gt; v1;\n\n// 2. æŒ‡å®šå¤§å°å’Œé»˜è®¤å€¼\nstd::vector&lt;int&gt; v2(10);        // 10 ä¸ªå…ƒç´ ï¼Œé»˜è®¤åˆå§‹åŒ– 0\nstd::vector&lt;int&gt; v3(10, 5);     // 10 ä¸ªå…ƒç´ ï¼Œæ¯ä¸ªéƒ½æ˜¯ 5\n\n// 3. åˆ—è¡¨åˆå§‹åŒ–ï¼ˆC++11ï¼‰\nstd::vector&lt;int&gt; v4 = {1, 2, 3, 4};\n\n// 4. æ‹·è´æž„é€ \nstd::vector&lt;int&gt; v5(v4);\n\n// 5. è¿­ä»£å™¨èŒƒå›´æž„é€ ï¼ˆå¸¸ç”¨ä¸Žä»Žå…¶ä»–å®¹å™¨æ‹·è´ï¼‰\nint arr[] = {10, 20, 30}\nstd::vector&lt;int&gt; v6(arr, arr + 3);\n</code></pre>\n<h2 id=\"å®¹é‡ä¸Žå¤§å°\">å®¹é‡ä¸Žå¤§å°</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">å‡½æ•°</th>\n<th style=\"text-align: left;\">è¯´æ˜Ž</th>\n<th style=\"text-align: left;\">å¤‡æ³¨</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><code>size()</code></td>\n<td style=\"text-align: left;\">å½“å‰å…ƒç´ ä¸ªæ•°</td>\n<td style=\"text-align: left;\">å®žé™…å­˜äº†å¤šå°‘ä¸ª</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>capacity()</code></td>\n<td style=\"text-align: left;\">å½“å‰åˆ†é…çš„å†…å­˜èƒ½å­˜å¤šå°‘ä¸ª</td>\n<td style=\"text-align: left;\"><code>capacity</code> <span class=\"math inline\">\\(\\geqslant\\)</span> <code>size</code></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>empty()</code></td>\n<td style=\"text-align: left;\">æ˜¯å¦ä¸ºç©º</td>\n<td style=\"text-align: left;\">æŽ¨èä½¿ç”¨ï¼Œæ¯” <code>size() == 0</code> æ›´è¯­ä¹‰åŒ–</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>reserve()</code></td>\n<td style=\"text-align: left;\">é¢„åˆ†é…å†…å­˜</td>\n<td style=\"text-align: left;\">ä»…æ”¹å˜ <code>capacity</code>ï¼Œä¸æ”¹å˜ <code>size</code></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>resize(n)</code></td>\n<td style=\"text-align: left;\">æ”¹å˜å…ƒç´ ä¸ªæ•°</td>\n<td style=\"text-align: left;\">æ”¹å˜ <code>size</code>ï¼Œå¦‚æžœå˜å¤§åˆ™å¡«å……é»˜è®¤å€¼</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>shrink_to_fit()</code></td>\n<td style=\"text-align: left;\">é‡Šæ”¾æœªä½¿ç”¨çš„å†…å­˜ï¼ˆC++11ï¼‰</td>\n<td style=\"text-align: left;\">è®© <code>capacity</code> æœç´¢åˆ° <code>size</code> å¤§å°</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ä¸ºä»€ä¹ˆ-reserve-éžå¸¸é‡è¦\">ä¸ºä»€ä¹ˆ <code>reserve</code> éžå¸¸é‡è¦ï¼Ÿ</h3>\n<pre><code class=\"language-cpp\">std::vector&lt;int&gt; v;\nv.reserve(1000); // ä¸€æ¬¡æ€§åˆ†é…å¥½å†…å­˜\nfor (int i = 0; i &lt; 1000; i++) {\n    v.push_back(i); // è¿™é‡Œä¸ä¼šå†å‘ç”Ÿå†…å­˜é‡æ–°åˆ†é…ï¼Œæ•ˆçŽ‡æžé«˜\n}\n</code></pre>\n<h2 id=\"å¢žåˆ æŸ¥æ”¹\">å¢žåˆ æŸ¥æ”¹</h2>\n<h3 id=\"æ’å…¥ä¸Žæ·»åŠ \">æ’å…¥ä¸Žæ·»åŠ </h3>\n<ul>\n<li><code>push_back(val)</code>ï¼šåœ¨å°¾éƒ¨æ·»åŠ å…ƒç´ ï¼ˆä¼šå‘ç”Ÿæ‹·è´æˆ–ç§»åŠ¨ï¼‰ã€‚</li>\n<li><code>emplace_back(arg...)</code>ï¼ˆC++11ï¼‰ï¼š<strong>åŽŸåœ°æž„é€ </strong>ã€‚ç›´æŽ¥åœ¨ <code>std::vector</code> å°¾éƒ¨æž„é€ å¯¹è±¡ï¼ŒçœåŽ»äº†ä¸€æ¬¡ä¸´æ—¶å¯¹è±¡çš„æž„é€ å’Œæ‹·è´ / ç§»åŠ¨ï¼Œ<strong>æ•ˆçŽ‡é€šå¸¸æ›´é«˜</strong>ã€‚</li>\n<li><code>insert(it, val)</code>ï¼šåœ¨è¿­ä»£å™¨æŒ‡å‘çš„ä½ç½®æ’å…¥ã€‚æ•ˆçŽ‡ä¸º <span class=\"math inline\">\\(O(N)\\)</span>ï¼Œå› ä¸ºè¦ç§»åŠ¨åŽç»­æ‰€æœ‰å…ƒç´ ã€‚</li>\n</ul>\n<h3 id=\"åˆ é™¤\">åˆ é™¤</h3>\n<ul>\n<li><code>pop_back</code>ï¼šåˆ é™¤å°¾éƒ¨å…ƒç´ ï¼ˆ<span class=\"math inline\">\\(O(1)\\)</span>ï¼‰ã€‚</li>\n<li><code>erase(it)</code>ï¼šåˆ é™¤æŒ‡å®šä½ç½®å…ƒç´ ï¼ˆ<span class=\"math inline\">\\(O(N)\\)</span>ï¼ŒåŽç»­å…ƒç´ å‰ç§»ï¼‰ã€‚</li>\n<li><code>clear()</code>ï¼šæ¸…ç©ºæ‰€æœ‰å…ƒç´ ï¼Œ<code>szie</code> å˜ä¸º 0ï¼Œä½† <code>capacity</code> é€šå¸¸ä¸å˜ï¼ˆå†…å­˜ä¸é‡Šæ”¾ï¼‰ã€‚</li>\n</ul>\n<h3 id=\"è®¿é—®\">è®¿é—®</h3>\n<ul>\n<li><code>v[i]</code>ï¼šä¸‹æ ‡è®¿é—®ï¼Œä¸æ£€æŸ¥è¶Šç•Œã€‚</li>\n<li><code>v.at[i]</code>ï¼šæ£€æŸ¥è¶Šç•Œï¼Œè¶Šè§‰æŠ› <code>std::out_of_range</code>ã€‚</li>\n<li><code>v.front()</code> / <code>v.back()</code>ï¼šè®¿é—®é¦–å°¾ã€‚</li>\n<li><code>v.data()</code>ï¼šè¿”å›žæŒ‡å‘åº•å±‚æ•°ç»„é¦–å…ƒç´ çš„æŒ‡é’ˆï¼ˆ<code>T*</code>ï¼‰ã€‚å¸¸ç”¨äºŽå’Œ C è¯­è¨€ API äº¤äº’ã€‚</li>\n</ul>\n<h2 id=\"è¿­ä»£å™¨å¤±æ•ˆ\">è¿­ä»£å™¨å¤±æ•ˆ</h2>\n<p>ç”±äºŽ <code>std::vector</code> æ˜¯è¿žç»­å†…å­˜ï¼Œå½“ç»“æž„å‘ç”Ÿå˜åŒ–æ—¶ï¼ŒæŒ‡å‘æ—§å†…å­˜çš„<strong>è¿­ä»£å™¨</strong>ã€<strong>æŒ‡é’ˆ</strong>ã€<strong>å¼•ç”¨</strong>å¯èƒ½ä¼šå¤±æ•ˆã€‚</p>\n<ol>\n<li>æ‰©å®¹æ—¶å¤±æ•ˆï¼šå½“ <code>push_back</code> å¯¼è‡´ <code>std::vector</code> æ‰©å®¹ï¼ˆ<code>reallocate</code>ï¼‰æ—¶ï¼ŒåŽŸå†…å­˜è¢«é‡Šæ”¾ï¼Œ<strong>æ‰€æœ‰</strong>æŒ‡å‘åŽŸæ•°æ®çš„è¿­ä»£å™¨ / æŒ‡é’ˆçž¬é—´å…¨éƒ¨å¤±æ•ˆã€‚</li>\n<li>æ’å…¥ / åˆ é™¤æ—¶å¤±æ•ˆï¼šå½“ <code>insert</code> æˆ– <code>erase</code> ä¸€ä¸ªä½ç½®æ—¶ï¼Œè¯¥ä½ç½®<strong>ä¹‹åŽ</strong>çš„æ‰€æœ‰è¿­ä»£å™¨éƒ½ä¼šå¤±æ•ˆï¼ˆå› ä¸ºæ•°æ®ç§»åŠ¨äº†ï¼‰ã€‚</li>\n</ol>\n<pre><code class=\"language-cpp\">std::vector&lt;int&gt; v = {1, 2, 3, 4};\nfor (auto it = v.begin(); it != v.end(); ++it) {\n    if (*it % 2 == 0) {\n        v.erase(it); // é”™è¯¯ï¼erase åŽ it å·²å¤±æ•ˆï¼Œä¸‹ä¸€æ¬¡ ++it ä¼šå´©æºƒ\n    }\n}\n\n// æ­£ç¡®å†™æ³•ï¼ˆåˆ©ç”¨ erase è¿”å›žå€¼æ›´æ–°è¿­ä»£å™¨ï¼‰\nfor (auto it =  v.begin(); it != v.end()) {\n    if (*it % 2 == 0) {\n        it = v.erase(it); // erase è¿”å›žæŒ‡å‘ä¸‹ä¸€ä¸ªå…ƒç´ çš„è¿­ä»£å™¨\n    } else {\n        ++it;\n    }\n}\n</code></pre>\n<h2 id=\"ç‰¹æ®Šç‰ˆæœ¬stdvectorbool\">ç‰¹æ®Šç‰ˆæœ¬ï¼š<code>std::vector&lt;bool&gt;</code></h2>\n<p>è¿™æ˜¯ä¸€ä¸ªåŽ†å²é—ç•™çš„ â€œå‘â€ã€‚ä¸ºäº†èŠ‚çœç©ºé—´ï¼ŒC++ æ ‡å‡†åº“ç‰¹åŒ–äº† <code>std::vector&lt;bool&gt;</code>ï¼Œå®ƒä¸æ˜¯å­˜å‚¨ <code>bool</code>ï¼ˆ1 å­—èŠ‚ï¼‰ï¼Œè€Œæ˜¯å­˜å‚¨ <code>bit</code>ï¼ˆ1 æ¯”ç‰¹ï¼‰ã€‚</p>\n<p>åŽæžœï¼š</p>\n<ul>\n<li>ä½ æ— æ³•èŽ·å¾—å…ƒç´ çš„åœ°å€ï¼š<code>&amp;v[0]</code> æ˜¯éžæ³•çš„ï¼Œå› ä¸ºæ— æ³•å¯»å€å•ä¸ªæ¯”ç‰¹ã€‚</li>\n<li>å®ƒçš„ <code>operator[]</code> è¿”å›žçš„ä¸æ˜¯ <code>bool&amp;</code>ï¼Œè€Œæ˜¯ä¸€ä¸ªä»£ç†å¯¹è±¡ã€‚</li>\n<li><strong>éžçº¿ç¨‹å®‰å…¨</strong>ï¼šå¹¶å‘è¯»å†™é‚»è¿‘çš„ bit å¯èƒ½ä¼šå¯¼è‡´æ•°æ®ç«žäº‰ï¼ˆå› ä¸ºå®ƒä»¬ä½äºŽåŒä¸€ä¸ªå­—èŠ‚å†…ï¼‰ã€‚</li>\n</ul>\n<p>å»ºè®®ï¼šå¦‚æžœéœ€è¦å­˜å¸ƒå°”å€¼ä¸”ä¸ç¼ºé‚£ç‚¹å†…å­˜ï¼Œç”¨ <code>std::vector&lt;char&gt;</code> æˆ– <code>std::deque&lt;bool&gt;</code> ä»£æ›¿ã€‚å¦‚æžœç¡®å®žéœ€è¦ä½æ“ä½œï¼Œè€ƒè™‘ä½¿ç”¨ <code>std::bitset</code>ã€‚</p>\n<h2 id=\"çŽ°ä»£åŒ–æ“ä½œ\">çŽ°ä»£åŒ–æ“ä½œ</h2>\n<h3 id=\"c20stderase-å’Œ-stderase_if\">C++20ï¼š<code>std::erase</code> å’Œ <code>std::erase_if</code></h3>\n<p>åœ¨ C++20 ä¹‹å‰ï¼Œè¦ä»Ž <code>std::vector</code> ä¸­åˆ é™¤æ»¡è¶³ç‰¹å®šæ¡ä»¶çš„æ‰€ä»¥å…ƒç´ ï¼Œéœ€è¦ä½¿ç”¨ \"Erase-Remove Idiom\"ï¼ˆ<code>v.erase(std::remove(...), v.end()ï¼‰</code>ï¼Œéžå¸¸å•°å—¦ã€‚</p>\n<p>C++20 ç®€åŒ–äº†ï¼š</p>\n<pre><code class=\"language-cpp\">std::vector&lt;int&gt; v = {1, 2, 3, 4, 5, 6};\n\n// åˆ é™¤æ‰€æœ‰å¶æ•°\nstd::erase_if(v, [](int x) { return x % 2 == 0; });\n</code></pre>\n<h2 id=\"æœ€ä½³å®žè·µ\">æœ€ä½³å®žè·µ</h2>\n<ol>\n<li>ä¼˜å…ˆä½¿ç”¨ <code>emplace_back</code>ï¼šä»£æ›¿ <code>push_back</code>ï¼Œç‰¹åˆ«æ˜¯å­˜æ”¾å¤æ‚å¯¹è±¡æ—¶ã€‚</li>\n<li>å–„ç”¨ <code>reserve</code>ï¼šå¦‚æžœä½ èƒ½é¢„ä¼°æ•°æ®é‡ï¼Œä¸€å®šè¦å…ˆ <code>reserve</code>ï¼Œåœ¨æ•°æ®é‡è¾ƒå¤§æ—¶ï¼Œèƒ½å¤Ÿæžå¤§çš„ä¼˜åŒ–æ€§èƒ½ã€‚</li>\n<li>é¿å…å¤´éƒ¨/ä¸­é—´æ’å…¥ï¼šåœ¨ <code>std::vector</code> å¤´éƒ¨æ’å…¥æ•°æ®ï¼ˆ<code>insert(begin(), val)</code>ï¼‰æ˜¯éžå¸¸æ…¢çš„ï¼ˆ<span class=\"math inline\">\\(O(N)\\)</span>ï¼‰ï¼Œå¦‚æžœæœ‰è¿™ç§éœ€æ±‚ï¼Œè¯·æ”¹ç”¨ <code>std::deque</code> æˆ– <code>std::list</code>ã€‚</li>\n<li>æ…Žç”¨ <code>std::vector&lt;bool&gt;</code>ï¼šé™¤éžä½ æ¸…æ¥šä½ è‡ªå·±åœ¨åšä»€ä¹ˆã€‚</li>\n<li>å°å¿ƒå¼•ç”¨å¤±æ•ˆï¼šåœ¨å¾ªçŽ¯ä¸­åš <code>push_back</code> æ—¶ï¼Œåƒä¸‡ä¸è¦åŒæ—¶æŒæœ‰æŒ‡å‘è¯¥ <code>std::vector</code> å†…éƒ¨å…ƒç´ çš„å¼•ç”¨ï¼Œä¸€æ—¦æ‰©å®¹ï¼Œå¼•ç”¨å°±å˜æˆæ‚¬ç©ºæŒ‡é’ˆäº†ã€‚</li>\n</ol>\n<hr />\n<blockquote>\n<p>ðŸ“¢ <strong>å†™åœ¨æœ€åŽ</strong></p>\n<p>å¦‚æžœä½ è§‰å¾—è¿™ç¯‡æ–‡ç« å¯¹ä½ æœ‰å¸®åŠ©ï¼Œæ¬¢è¿Žåˆ°æˆ‘çš„ä¸ªäººåšå®¢ <strong><a href=\"https://bfmhno3.github.io/\" rel=\"noopener nofollow\" target=\"_blank\">Better Mistakes</a></strong> é€›é€›ã€‚</p>\n<p>åœ¨é‚£é‡Œæˆ‘å½’æ¡£äº†æ›´å¤šé«˜è´¨é‡çš„æŠ€æœ¯æ–‡ç« ï¼Œä¹Ÿæ¬¢è¿Žé€šè¿‡ RSS è®¢é˜…æˆ‘çš„æœ€æ–°åŠ¨æ€ï¼</p>\n</blockquote>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-03 23:00</span>&nbsp;\n<a href=\"https://www.cnblogs.com/bfmhno3\">ç•¥æ— æ…•è‰³æ„</a>&nbsp;\né˜…è¯»(<span id=\"post_view_count\">0</span>)&nbsp;\nè¯„è®º(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">æ”¶è—</a>&nbsp;\n<a href=\"\">ä¸¾æŠ¥</a>\n</div>"
    },
    {
      "title": "使用Vue 3 + TypeScript + Tauri实现一个即插即用的轻量级可执行程序",
      "link": "https://www.cnblogs.com/LEMONIX/p/19435059",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ning-Z/p/19435059\" id=\"cb_post_title_url\" title=\"发布于 2026-01-03 22:20\">\n    <span>使用Vue 3 + TypeScript + Tauri实现一个即插即用的轻量级可执行程序</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>在学校由于数据结构这门课的难理解性，我就想能不能实现一个演示动画放入优盘 不记得了或者忘了随时点击exe就可以查看。查阅了一些资料最后选择了Vue 3 + TypeScript + Tauri的架构，最后走出来整个数据结构核心动画才8731kb</p>\n<h1>项目采用了如下技术栈：</h1>\n<ul>\n<li>\n<p><strong>前端框架</strong>：Vue 3 + Composition API<br />\n用响应式数据驱动动画，逻辑清晰，状态可控。</p>\n\n</li>\n<li>\n<p><strong>开发语言</strong>：TypeScript<br />\n强类型约束让算法实现更严谨，也更适合教学示例。</p>\n\n</li>\n<li>\n<p><strong>桌面封装</strong>：Tauri<br />\n核心选择。相比 Electron，Tauri 基于 Rust + 系统原生 WebView，体积小、启动快，生成的 <code>.exe</code> 非常轻量。</p>\n\n</li>\n<li>\n<p><strong>图结构渲染</strong>：vis-network<br />\n适合处理树、图等复杂关系结构。</p>\n\n</li>\n<li>\n<p><strong>UI 组件库</strong>：Element Plus<br />\n保证整体界面简洁、易用，降低教学操作成本。</p>\n\n</li>\n<li></li>\n\n</ul>\n<h1>算法与动画彻底分离</h1>\n<p>传统写法中，排序或遍历算法往往直接操作 DOM 或样式，导致逻辑和视图强耦合，代码既难读也难维护。</p>\n<p>在 项目中，整体思路是：</p>\n<ul>\n<li>\n<p><strong>算法只负责计算</strong></p>\n\n</li>\n<li>\n<p><strong>动画只负责播放</strong></p>\n\n</li>\n<li>\n<p>两者通过“动画帧”进行通信</p>\n\n</li>\n\n</ul>\n<p>简单来说，流程是这样的：</p>\n<blockquote>\n<p>算法函数（纯逻辑） → 生成动画帧序列 → 播放器逐帧渲染 → UI 展示</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3058226/202601/3058226-20260103221017692-588293223.png\" /></p>\n<p>&nbsp;</p>\n<h1>&nbsp;Tauri</h1>\n<p>简单讲解一下这个:</p>\n<p>Electron打包出来的程序太大,它会把 <strong>整个 Chrome 浏览器</strong> 和 <strong>整个 Node.js 环境</strong> 都塞进你的 <code>.exe</code> 里。</p>\n<p>Tauri 的后端是用 Rust 写的。Rust 不需要打包一个虚拟机（Runtime）。它会直接调用你电脑系统自带的浏览器内核（Windows 上是 Edge WebView2 【window11,12都可】）。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3058226/202601/3058226-20260103221557607-1387745295.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3058226/202601/3058226-20260103221646295-1529611106.png\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;最后的效果看起来很不错，响应速度很快， 内存很小，对于小型项目这个方案还是很不错的。</p>\n\n</blockquote>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-03 22:20</span>&nbsp;\n<a href=\"https://www.cnblogs.com/LEMONIX\">博客101</a>&nbsp;\n阅读(<span id=\"post_view_count\">5</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "面向对象三大特点(封装、继承、多态)",
      "link": "https://www.cnblogs.com/xi-yongqi/p/19434736",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xi-yongqi/p/19434736\" id=\"cb_post_title_url\" title=\"发布于 2026-01-03 19:08\">\n    <span>面向对象三大特点(封装、继承、多态)</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p><strong>面向对象编程有三大特性：封装、继承、多态。</strong></p>\n<h4 id=\"封装\">封装</h4>\n<ol>\n<li>封装是指将对象的属性（数据，如变量）和行为（操作数据的方法，如函数）捆绑在一起，同时隐藏对象内部的实现细节。</li>\n<li>核心目的</li>\n</ol>\n<ul>\n<li>提高代码安全性：防止外部程序随意篡改对象的内部属性，避免无效数据的产生。</li>\n<li>提升代码可维护性：内部实现细节的修改不会影响外部调用者，降低代码耦合度。</li>\n<li>增强代码复用性：封装后的类可以作为独立模块被多次引用。</li>\n</ul>\n<ol start=\"3\">\n<li>具体实现：</li>\n</ol>\n<ul>\n<li>使用 private 修饰成员变量</li>\n<li>提供 public的getter/setter方法</li>\n</ul>\n<pre><code class=\"language-java\">public class User {\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\n</code></pre>\n<hr />\n<h4 id=\"继承\">继承</h4>\n<ol>\n<li>继承：子类(派生类)继承父类(基类/超类)的属性和方法，实现代码复用，并建立 is-a 关系。子类无需重新编写父类的已有代码，同时还能根据需求扩展自身的独有属性和方法，甚至重写父类的方法。</li>\n<li>核心目的</li>\n</ol>\n<ul>\n<li>最大化代码复用：减少冗余代码，提高开发效率。</li>\n<li>建立类的层次关系：清晰梳理类与类之间的逻辑关联（如“学生”是“人”的一种）。</li>\n<li>为多态提供基础支撑。</li>\n</ul>\n<ol start=\"3\">\n<li>具体实现</li>\n</ol>\n<pre><code class=\"language-java\">class Animal {\n    void eat() {}\n}\n\nclass Dog extends Animal {\n    void bark() {}\n}\n</code></pre>\n<ol start=\"4\">\n<li>注意事项：</li>\n</ol>\n<ul>\n<li>Java只支持单继承，Python支持多继承。</li>\n<li>可以多层继承</li>\n<li>可以实现多个接口</li>\n</ul>\n<hr />\n<h4 id=\"多态\">多态</h4>\n<ol>\n<li>多态：同一个方法调用，在不同对象上表现出不同的行为。</li>\n<li>多态前提(java中)</li>\n</ol>\n<ul>\n<li>有继承或接口关系</li>\n<li>方法重写</li>\n<li>父类引用指向子类对象</li>\n</ul>\n<ol start=\"3\">\n<li>目的：</li>\n</ol>\n<ul>\n<li>提高代码灵活性，降低代码耦合度</li>\n<li>增强代码可扩展性，完美契合 “开闭原则”</li>\n<li>简化代码结构，提高代码可维护性</li>\n</ul>\n<ol start=\"4\">\n<li>代码示例：</li>\n</ol>\n<pre><code class=\"language-java\">// 1. 存在继承关系（父类Person）\nclass Person {\n    // 父类方法（非private、非static、非final，可被重写）\n    public void work() {\n        System.out.println(\"普通人的工作\");\n    }\n}\n\n// 子类Student，继承Person\nclass Student extends Person {\n    // 2. 方法重写（严格遵循方法签名一致）\n    @Override\n    public void work() {\n        System.out.println(\"学生的工作：上课学习\");\n    }\n}\n\n// 子类Teacher，继承Person\nclass Teacher extends Person {\n    // 2. 方法重写\n    @Override\n    public void work() {\n        System.out.println(\"老师的工作：备课授课\");\n    }\n}\n\npublic class PolymorphismTest {\n    public static void main(String[] args) {\n        // 3. 父类引用指向子类对象（核心条件）\n        Person p1 = new Student();\n        Person p2 = new Teacher();\n        \n        // 触发多态：调用同一方法，呈现不同行为\n        p1.work(); // 输出：学生的工作：上课学习\n        p2.work(); // 输出：老师的工作：备课授课\n    }\n}\n</code></pre>\n<ol start=\"5\">\n<li>java与python多态前提条件的区别</li>\n</ol>\n<p><strong>二者的差异根源是 Java 为静态强类型语言（约束严格），Python 为动态弱类型语言（约束宽松，灵活度更高），具体前提条件对比如下：</strong></p>\n<table>\n<thead>\n<tr>\n<th>对比维度</th>\n<th>Java 多态（必背，缺一不可）</th>\n<th>Python 多态（无强制约束，灵活宽松）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>继承/接口依赖</td>\n<td>必须具备类继承关系或接口实现关系，无此关系无法实现多态</td>\n<td>无需强制依赖！① 支持继承（单 / 多继承）实现多态（与 Java 类似）；② 核心支持<a href=\"https://www.cnblogs.com/xi-yongqi/p/19167194\" target=\"_blank\">鸭子类型</a>：无任何继承 / 接口，只要对象拥有目标方法即可实现多态</td>\n</tr>\n<tr>\n<td>方法重写要求</td>\n<td>严格遵循规则：方法名、参数列表、返回值必须一致；父类方法不能是private/static/final；推荐显式标注@Override</td>\n<td>无严格规则，仅需子类与父类方法同名即可视为 “重写”；可灵活修改参数 / 返回值；无强制@Override标注</td>\n</tr>\n<tr>\n<td>对象引用绑定</td>\n<td>必须满足父类/接口引用指向子类/实现类对象（静态类型声明为父类，实际指向子类实例），这是触发多态的关键</td>\n<td>完全不需要！Python变量无固定类型声明，无需刻意绑定父类引用，直接使用子类实例或符合方法要求的对象即可触发多态</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-03 19:08</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xi-yongqi\">我会替风去</a>&nbsp;\n阅读(<span id=\"post_view_count\">40</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MCP Registry v1.4.0 最新进展",
      "link": "https://www.cnblogs.com/shanyou/p/19432926",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/shanyou/p/19432926\" id=\"cb_post_title_url\" title=\"发布于 2026-01-02 22:34\">\n    <span>MCP Registry v1.4.0 最新进展</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><font face=\"微软雅黑 Light\" size=\"3\">2025 年 12 月 16 日发布的 Registry v1.4.0 版本 ，不仅是技术规格的一次迭代，更是整个协议迈向成熟的重要里程碑。该版本引入了严格的 2025-12-11 模式定义 ，正式确立了对 streamable-http 传输层的原生支持，并重构了发布者验证流程。与此同时，MCP 的治理结构发生了历史性变革——Anthropic 将该协议捐赠给 Linux 基金会旗下新成立的 Agentic AI 基金会 (AAIF)。这一举措有效地消除了企业采用该协议的供应商锁定顾虑，促成了包括 AWS、Google Cloud、Cisco 和 Microsoft 在内的行业巨头对该标准的全面拥抱。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\">要理解 v1.4.0 版本的技术意义，必须首先审视 MCP 旨在解决的核心架构挑战。在 MCP 出现之前，将 LLM 连接到外部数据源（如 PostgreSQL 数据库、GitHub 仓库或 Notion 文档）需要针对每个模型提供商编写定制的集成代码。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\">在前 MCP 时代，开发者面临着所谓的“N x M”集成困境。假设有 N 个主流 AI 模型（如 Claude 3.5, GPT-4o, Gemini 1.5）和 M 个外部工具或数据源。若要实现互操作性，理论上需要维护 N * M 个独立的连接器。这种架构不仅脆弱，而且极难扩展。一旦数据源的 API 发生变更，或者开发者决定切换 AI 模型，所有的集成工作都需要推倒重来 。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\">MCP 通过引入标准化的中间层，将这一复杂度降低为 N + M。</font></p><ul><li><p><font face=\"微软雅黑 Light\" size=\"3\">标准化接口： MCP 定义了一套通用的 JSON-RPC 2.0 消息格式，使得任何兼容 MCP 的主机（Host）都可以直接与任何 MCP 服务器（Server）通信，而无需了解后者的底层实现细节。</font></p></li><li><p><font face=\"微软雅黑 Light\" size=\"3\"><font face=\"微软雅黑 Light\" size=\"3\">通用连接器： 这意味着一个针对 Google Drive 开发的 MCP 服务器，可以同时被 Claude Desktop、Cursor IDE、VS Code 甚至定制的企业 AI 代理所使用，真正实现了“一次编写，到处运行”的愿景。</font></font></p></li></ul><p><font face=\"微软雅黑 Light\" size=\"3\">随着 v1.4.0 的发布，MCP 的组件体系已高度成熟，形成了清晰的四层架构：</font></p><ol><li><p><font face=\"微软雅黑 Light\" size=\"3\">MCP Host（主机）：<br />这是 AI 模型的运行环境，也是集成的发起端。典型的主机包括 Claude Desktop、Cursor、Windsurf 以及各类企业级 AI 网关。主机负责管理与用户的交互上下文，并将用户的自然语言意图转化为对 MCP 工具的调用请求 。</font></p></li><li><p><font face=\"微软雅黑 Light\" size=\"3\">MCP Client（客户端）：<br />嵌入在主机内部的协议实现层。它负责与服务器建立 1:1 的连接，处理协议握手、能力协商（Capabilities Negotiation）以及消息的序列化与反序列化。在 v1.4.0 生态中，客户端承担了更多安全职责，如 OAuth 2.0 令牌管理和权限范围（Scope）控制 。</font></p></li><li><p><font face=\"微软雅黑 Light\" size=\"3\">MCP Server（服务器）：<br />这是生态系统的核心资产。服务器是一个轻量级的网关程序，它封装了特定的数据源或工具，并通过 MCP 协议暴露给外界。服务器可以极其简单（如一个只读的 SQLite 查询器），也可以极其复杂（如一个具有推理能力的 GitHub 运维代理）。v1.4.0 版本极大地增强了服务器的元数据定义能力，使其能够更精准地向注册表描述自身行为。</font></p></li><li><p><font face=\"微软雅黑 Light\" size=\"3\">Transport Layer（传输层）：<br />通信的管道。</font></p></li></ol><ul><ul><li><p><font face=\"微软雅黑 Light\" size=\"3\">Stdio（标准输入输出）： 在 MCP 早期主要用于本地开发，通过进程间通信（IPC）实现极其低延迟的交互，且天然隔离网络风险。</font></p></li><li><p><font face=\"微软雅黑 Light\" size=\"3\">SSE (Server-Sent Events) over HTTP: 随着 v1.4.0 对远程连接支持的完善，基于 HTTP 的 SSE 传输已成为主流。它允许服务器独立部署在云端（如 Docker 容器或 Serverless 函数中），并通过标准 URL 被远程客户端访问。这种模式是企业级“远程 MCP”部署的基石。</font></p></li></ul></ul><p><font face=\"微软雅黑 Light\" size=\"3\">&nbsp;&nbsp;&nbsp;&nbsp; 2025 年 12 月 16 日，modelcontextprotocol/registry 仓库发布了 v1.4.0 版本。这一版本不仅仅是代码的更新，更是对整个注册表服务（Registry Service）数据模型的一次重构，旨在适应日益复杂的分布式生态系统。</font></p><p><br /></p><p><font face=\"微软雅黑 Light\" size=\"3\">v1.4.0 最具破坏性但也最具建设性的变更是强制采用了新的 server.json 模式定义，版本号为 2025-12-11。server.json 文件是 MCP 服务器在注册表中的“身份证”，它定义了服务器的名称、描述、安装方式及版本信息。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\">在此之前的版本（如 2025-10-17）中，模式定义相对宽松，允许许多非标准字段存在，且对远程连接的定义不够严谨。新的模式带来了以下关键改进：</font></p><h6><font face=\"微软雅黑 Light\" size=\"3\" style=\"font-weight: normal;\">1 、严格的传输层定义：<font face=\"微软雅黑 Light\" size=\"3\">新模式显式地标准化了 remotes 字段中 streamable-http 的配置方式。<font face=\"微软雅黑 Light\" size=\"3\">在旧版本中，远程服务器的配置往往依赖于特定客户端的约定俗成。而在 v1.4.0 中，server.json 必须严格遵循以下结构来声明远程能力 。<font face=\"微软雅黑 Light\" size=\"3\">这种严格的类型定义（Type Safety）确保了无论是 VS Code 还是 Claude Desktop，在解析远程服务器时都能准确识别连接方式和认证需求，消除了因配置模糊导致的连接失败。</font></font></font></font></h6><h6><font face=\"微软雅黑 Light\" size=\"3\" style=\"font-weight: normal;\">2 、移除 status 字段与动态健康检查：<font face=\"微软雅黑 Light\" size=\"3\">v1.4.0 移除了 server.json 中的 status 字段 。此前，开发者需要手动在 JSON 文件中标记服务器状态（如 \"beta\", \"stable\"）。这种静态标记往往与实际运行状态脱节。<font face=\"微软雅黑 Light\" size=\"3\">新版本的设计理念是：健康状态应当是动态监测的结果，而非静态声明。 注册表服务现在通过内置的验证逻辑（Validation Logic）定期轮询服务器，根据实际响应情况决定其在索引中的可见性。这显著提高了注册表数据的可信度，防止用户安装已停摆的“僵尸服务器”。</font></font></font></h6><h6><font face=\"微软雅黑 Light\" size=\"3\" style=\"font-weight: normal;\">3、 版本一致性强制：<font face=\"微软雅黑 Light\" size=\"3\">新模式引入了严格的版本一致性检查。server.json 中的 version 字段现在必须与 Git Tag 或包管理器（NPM/PyPI）中的版本号严格匹配 。如果注册表检测到版本号不一致（例如 server.json 声明了 v2.0.0 但 Git Tag 只有 v1.9.0），发布流程将自动失败。这一机制有效地杜绝了“幽灵版本”问题，确保用户拉取的代码与注册表描述完全一致。</font></font></h6><p><font face=\"微软雅黑 Light\" size=\"3\">伴随注册表更新，官方发布工具 mcp-publisher 也同步升级至 v1.4.0 17。该 CLI 工具是开发者与 MCP 注册表交互的主要接口。</font> </p><p><font face=\"微软雅黑 Light\" size=\"3\">v1.4.0 版本的发布器深度集成了 OpenID Connect (OIDC) 协议，特别是针对 GitHub Actions 的环境。这意味着开发者不再需要生成和维护长效的 API 密钥（Long-lived Secrets）来发布更新。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\">通过配置 GitHub Action Workflow，mcp-publisher 可以利用临时的 OIDC 令牌向注册表证明身份。注册表服务端会验证该令牌是否由合法的 GitHub 仓库签发，从而授权发布。这极大地提升了供应链的安全性，因为即便发布脚本泄露，攻击者也无法在外部环境伪造有效的 OIDC 令牌 。</font></p><h6><font face=\"微软雅黑 Light\" size=\"3\">新版工具引入了更强大的 check 和 init 命令。</font></h6><ul><li><p><font face=\"微软雅黑 Light\" size=\"3\">mcp-publisher init：能够智能分析当前目录结构（识别是 Node.js 项目还是 Python 项目），自动生成符合 2025-12-11 标准的 server.json 模板。</font></p></li><li><p><font face=\"微软雅黑 Light\" size=\"3\">mcp-publisher check（或集成在发布流程中的验证）：在上传前对 JSON 文件进行本地 Schema 校验。这解决了以往提交后才发现格式错误导致发布失败的痛点，缩短了反馈循环</font> 。</p></li></ul><p><font face=\"微软雅黑 Light\" size=\"3\"><br /></font></p><p><font face=\"微软雅黑 Light\" size=\"3\">如果说 Registry v1.4.0 是技术的升级，那么 Agentic AI 基金会 (AAIF) 的成立则是 MCP 走向行业标准的政治宣言。2025 年 12 月 9 日，Anthropic 正式宣布将 MCP 项目及其相关资产捐赠给 Linux 基金会旗下新成立的 AAIF。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\">在 2024 年至 2025 年间，AI 领域被视为各大巨头（OpenAI, Google, Anthropic, Meta）争夺生态主导权的战场。如果 MCP 始终由 Anthropic 一家公司控制，其他竞争对手（尤其是 OpenAI 和 Google）将很难毫无保留地采纳这一标准，因为这涉及到生态锁定的风险。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\"><font face=\"微软雅黑 Light\" size=\"3\">通过将 MCP 移交给 Linux 基金会这一中立机构，Anthropic 效仿了 Google 捐赠 Kubernetes 给 CNCF 的成功路径。这一举措产生了立竿见影的效果：</font></font></p><ul><li><p><font face=\"微软雅黑 Light\" size=\"3\">消除信任障碍： AWS 和 Google Cloud 随即宣布加强对 MCP 的支持，因为标准不再属于某个单一竞争对手。</font></p></li><li><p><font face=\"微软雅黑 Light\" size=\"3\">统一战线： OpenAI 不仅加入了基金会，还捐赠了其 AGENTS.md 标准。这意味着行业正在走向融合——OpenAI 的代理定义规范与 MCP 的工具连接规范将在 AAIF 的框架下进行整合，形成一套完整的“代理技术栈”。</font></p></li></ul><p><font face=\"微软雅黑 Light\" size=\"3\"><br /></font></p><p><font face=\"微软雅黑 Light\" size=\"3\"><br /></font></p>\n</div>\n<div id=\"MySignature\">\n    <p>欢迎大家扫描下面二维码成为我的客户，扶你上云</p>\n<img src=\"https://images.cnblogs.com/cnblogs_com/shanyou/57459/o_220125090408_%E9%82%80%E8%AF%B7%E4%BA%8C%E7%BB%B4%E7%A0%81-258px.jpeg\" width=\"170\" />\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-02 22:34</span>&nbsp;\n<a href=\"https://www.cnblogs.com/shanyou\">张善友</a>&nbsp;\n阅读(<span id=\"post_view_count\">170</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Contrastive Learning 对比学习 | InfoNCE loss 与互信息的数学关联",
      "link": "https://www.cnblogs.com/moonout/p/19432533",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/moonout/p/19432533\" id=\"cb_post_title_url\" title=\"发布于 2026-01-02 20:07\">\n    <span>Contrastive Learning 对比学习 | InfoNCE loss 与互信息的数学关联</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        InfoNCE loss 可以表示互信息的下界：I(X;Y) ≥ log N - L_InfoNCE 。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<br />\n<p>参考博客：<a href=\"https://blog.csdn.net/iiiiii11/article/details/154584585\" rel=\"noopener nofollow\" target=\"_blank\">CSDN | 【理论推导】互信息与 InfoNCE 损失：从公式推导理解对比学习的本质</a> ，感觉是讲的最清楚的一个博客。</p>\n<hr />\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">目录</div><ul><li><a href=\"#1-infonce-loss-和互信息的数学形式\" rel=\"noopener nofollow\">1 InfoNCE loss 和互信息的数学形式</a><ul><li><a href=\"#11-互信息的数学形式\" rel=\"noopener nofollow\">1.1 互信息的数学形式</a></li><li><a href=\"#12-infonce-loss-的数学形式\" rel=\"noopener nofollow\">1.2 InfoNCE loss 的数学形式</a></li><li><a href=\"#13-为什么我们希望最大化--的互信息\" rel=\"noopener nofollow\">1.3 为什么我们希望最大化 <span class=\"math inline\">\\((X,Y)\\)</span> 的互信息</a></li></ul></li><li><a href=\"#2-infonce-loss-与互信息的数学关联\" rel=\"noopener nofollow\">2 InfoNCE loss 与互信息的数学关联</a></li><li><a href=\"#3-证明过程\" rel=\"noopener nofollow\">3 证明过程</a><ul><li><a href=\"#31-第一步证明使-infonce-loss-取值最小的-满足-\" rel=\"noopener nofollow\">3.1 第一步：证明使 InfoNCE loss 取值最小的 <span class=\"math inline\">\\(f(x,y)\\)</span>，满足 <span class=\"math inline\">\\(f(x, y) = \\log [p(y|x) / p(y)]\\)</span></a></li><li><a href=\"#32-第二步将以上--代入推导互信息下界\" rel=\"noopener nofollow\">3.2 第二步：将以上 <span class=\"math inline\">\\(f(x,y)\\)</span> 代入，推导互信息下界</a></li></ul></li></ul></div><p></p>\n<hr />\n<h2 id=\"1-infonce-loss-和互信息的数学形式\">1 InfoNCE loss 和互信息的数学形式</h2>\n<h3 id=\"11-互信息的数学形式\">1.1 互信息的数学形式</h3>\n<p>互信息 <span class=\"math inline\">\\(I(X,Y)\\)</span> 是信息论中的核心概念，用于衡量两个随机变量 <span class=\"math inline\">\\(X,Y\\)</span> 之间的依赖程度。</p>\n<p>从直观上理解，互信息回答了这样一个问题：知道一个变量 Y 后，我们对另一个变量 X 的不确定性减少了多少？如果 X 的不确定性减少较多，则代表 XY 之间的互信息较大（为正）；如果 X 的不确定性没有减少，则 XY 是相互独立的，即 <span class=\"math inline\">\\(P(X)P(Y) = P(X,Y)\\)</span>，XY 之间的互信息为 0。</p>\n<p>数学上，互信息有三种等价的定义方式：</p>\n<p>① 基于联合分布 <span class=\"math inline\">\\(p(x,y)\\)</span> 和边缘分布 <span class=\"math inline\">\\(p(x)p(y)\\)</span> 的 KL 散度的形式</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = D_{KL}\\big(p(x,y) ~\\|~ p(x)p(y)\\big) = \\mathbb{E}_{p(x,y)}\\left[\\log\\frac{p(x,y)}{p(x)p(y)}\\right]\n\\]</div><p></p><p>这个形式直接体现了互信息的本质：它衡量的是联合分布 <span class=\"math inline\">\\(p(x,y)\\)</span> 与假设 X 和 Y 独立时的分布 <span class=\"math inline\">\\(p(x)p(y)\\)</span> 之间的差异。如果 X 和 Y 独立，这个差异为 0，否则为正数，差异越大说明两个变量关联越强。</p>\n<p>② 基于熵的形式</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = H(X) - H(X|Y) = H(Y) - H(Y|X)\n\\]</div><p></p><p>这里 <span class=\"math inline\">\\(H(X)=\\int p(x)\\log p(x)\\)</span> 是 X 的熵（不确定性），<span class=\"math inline\">\\(H(X|Y)\\)</span> 是已知 Y 时 X 的条件熵，互信息则是不确定性的减少量。</p>\n<p>③ 基于条件概率的形式</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = \\mathbb{E}_{p(x,y)}\\left[\\log\\frac{p(y|x)}{p(y)}\\right]\n\\]</div><p></p><p>这个形式在对比学习中特别有用，因为它直接表达了“在给定 x 的情况下，y 的概率相对于其先验概率的变化”。</p>\n<h3 id=\"12-infonce-loss-的数学形式\">1.2 InfoNCE loss 的数学形式</h3>\n<p>InfoNCE loss 是现代对比学习（Contrastive Learning）的核心。它的设计灵感来自一个简单的直觉：从一堆样本中，找出与给定样本 x 匹配的正样本 y。</p>\n<p>具体的，假设我们有一个正样本对 <span class=\"math inline\">\\((x, y)\\)</span>，比如同一张图片的两种不同数据增强结果，同时从数据集中随机采样 <span class=\"math inline\">\\(N-1\\)</span> 个负样本 <span class=\"math inline\">\\(y_2, y_3, ..., y_N\\)</span>。我们定义一个评分函数 <span class=\"math inline\">\\(f(x, y)\\)</span>（通常是神经网络）来衡量 x 和 y 的相似度。InfoNCE loss 的形式为：</p>\n<p></p><div class=\"math display\">\\[L = -\\mathbb{E}\\left[\\log\\frac{e^{f(x,y)}}{\\sum_{j=1}^{N} e^{f(x,y_j)}}\\right]\n\\]</div><p></p><p>其中，分子 <span class=\"math inline\">\\(e^{f(x,y)}\\)</span> 是正样本的得分，而分母 <span class=\"math inline\">\\(\\sum_{j=1}^{N} e^{f(x,y_j)}\\)</span> 是所有样本（1 个正样本 + N-1 个负样本）得分的总和。整个分式表示：给定 x 和 N 个候选 y，我们正确选出正样本 y 的概率。</p>\n<p>也可将其视为交叉熵损失（cross-entropy loss）的一个变种。交叉熵损失的形式如下：</p>\n<p></p><div class=\"math display\">\\[L_\\text{CE} = \\sum p(a)\\log \\hat p(a)\n\\]</div><p></p><p>其中，<span class=\"math inline\">\\(p(a)\\)</span> 为真是概率，而 <span class=\"math inline\">\\(\\hat p(a)\\)</span> 是我们估计的概率。在 InfoNCE loss 的 setting 中，真概率 <span class=\"math inline\">\\(p(x,y) = 1\\)</span>，而 <span class=\"math inline\">\\(p(x,y_j) = 0\\)</span>。</p>\n<h3 id=\"13-为什么我们希望最大化--的互信息\">1.3 为什么我们希望最大化 <span class=\"math inline\">\\((X,Y)\\)</span> 的互信息</h3>\n<p>在对比学习中，我们希望最大化正样本对的互信息，同时最小化正负样本之间的互信息。这迫使编码器提取出两个不同视图（view）的共享信息（比如同一张图片的不同数据增强版本、语言 / 视觉等不同的模态），这些信息通常对应于数据的内在语义，例如物体的类别、场景等，而忽略无关的噪声或增强引入的变化。</p>\n<p>在 <a href=\"https://www.cnblogs.com/moonout/tag/Skill%20Discovery/\" target=\"_blank\">skill discovery</a>（强化学习的一个子领域）中，我们希望最大化 skill z 和 state s 之间的互信息。从信息理论的角度，最大化 <span class=\"math inline\">\\(I(S;Z)\\)</span> 意味着，我们希望从状态 <span class=\"math inline\">\\(s\\)</span> 中尽可能多地获取关于技能 <span class=\"math inline\">\\(z\\)</span> 的信息。这确保了技能是“有区分度的”：看到智能体的行为，我们就能推断出它使用了哪个技能。</p>\n<h2 id=\"2-infonce-loss-与互信息的数学关联\">2 InfoNCE loss 与互信息的数学关联</h2>\n<p>核心结论：最小化 InfoNCE loss，等价于最大化互信息的一个下界。</p>\n<p>（互信息下界的含义是，互信息的取值将会大于这个值。从这个角度来说，下界的值越大，互信息的值就随之变大，所以，我们最小化 InfoNCE loss，相当于在推动互信息最大化。）</p>\n<p>具体来说，对于任意评分函数 <span class=\"math inline\">\\(f\\)</span>，有以下不等式成立：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) \\geq \\log N - L\n\\]</div><p></p><p>其中，<span class=\"math inline\">\\(L\\)</span> 是我们模型的 InfoNCE loss，这个差值就是互信息的下界。</p>\n<h2 id=\"3-证明过程\">3 证明过程</h2>\n<p>证明过程可以分为两步：</p>\n<h3 id=\"31-第一步证明使-infonce-loss-取值最小的-满足-\">3.1 第一步：证明使 InfoNCE loss 取值最小的 <span class=\"math inline\">\\(f(x,y)\\)</span>，满足 <span class=\"math inline\">\\(f(x, y) = \\log [p(y|x) / p(y)]\\)</span></h3>\n<p>我们要证明：使 InfoNCE loss 最小的 <span class=\"math inline\">\\(f(x,y)\\)</span> 满足：</p>\n<p></p><div class=\"math display\">\\[f(x,y) = \\log\\frac{p(y|x)}{p(y)}\n\\]</div><p></p><p>我们考虑 InfoNCE loss 的期望形式：</p>\n<p></p><div class=\"math display\">\\[L = -\\mathbb{E}_{p(x,y)} \\left[\\log\\frac{e^{f(x,y)}}{\\sum_{j=1}^{N} e^{f(x,y_j)}}\\right]\n\\]</div><p></p><p>我们可以将这个损失看作一个分类问题：给定 x 和 N 个样本 <span class=\"math inline\">\\({y_1, y_2, \\cdots, y_N}\\)</span>，其中只有 <span class=\"math inline\">\\(y_1=y\\)</span> 是正样本，其余是负样本。模型的任务是选出正样本。</p>\n<p>对于固定的 x，最优的分类器应该给出真实的后验概率，即给定 x 后，y 为这个 x 的正样本的概率。那么，真实的后验概率是多少呢？</p>\n<p>根据贝叶斯定理，在给定 x 和 y 样本集合的情况下，第 k 个样本是正样本的概率为（这个没完全看懂）：</p>\n<p></p><div class=\"math display\">\\[p(\\text{第 k 个是正样本} | x, {y_{1\\cdots N}}) = \\frac{p(y_k|x) \\prod_{i\\neq k} p(y_i) }{ \\sum_{j=1}^{N} p(y_j|x) \\prod_{i\\neq j} p(y_i)}\n\\]</div><p></p><p>化简后得到：</p>\n<p></p><div class=\"math display\">\\[= \\frac{p(y_k|x)/p(y_k)}{\\sum_{j=1}^{N} p(y_j|x)/p(y_j)}\n\\]</div><p></p><p>关键观察：如果我们取 <span class=\"math inline\">\\(f(x,y) = \\log\\frac{p(y|x)}{p(y)} + c(x)\\)</span>，其中 <span class=\"math inline\">\\(c(x)\\)</span> 是只依赖于 x 的任意函数，那么：</p>\n<p></p><div class=\"math display\">\\[\\frac{e^{f(x,y_k)}}{\\sum_{j=1}^{N} e^{f(x,y_j)}} = \\frac{p(y_k|x)/p(y_k)}{\\sum_{j=1}^{N} p(y_j|x)/p(y_j)}\n\\]</div><p></p><p>这正是真实的后验分布。因此，这个 <span class=\"math inline\">\\(f(x,y)\\)</span> 取值使得模型的输出分布与真实分布完全一致，从而最小化 InfoNCE loss。</p>\n<p>为简便起见，我们通常取 <span class=\"math inline\">\\(c(x)=0\\)</span>，得到最优 <span class=\"math inline\">\\(f(x,y)\\)</span>：</p>\n<p></p><div class=\"math display\">\\[f^*(x,y) = \\log\\frac{p(y|x)}{p(y)}\n\\]</div><p></p><h3 id=\"32-第二步将以上--代入推导互信息下界\">3.2 第二步：将以上 <span class=\"math inline\">\\(f(x,y)\\)</span> 代入，推导互信息下界</h3>\n<p>现在我们将最优 <span class=\"math inline\">\\(f^*(x,y)\\)</span> 代入 InfoNCE loss：</p>\n<p></p><div class=\"math display\">\\[L_{\\text{min}} = -\\mathbb{E}\\left[\\log\\frac{e^{f^*(x,y)}}{\\sum_{j=1}^{N} e^{f^*(x,y_j)}}\\right]\n= -\\mathbb{E}\\left[\\log\\frac{\\frac{p(y|x)}{p(y)}}{\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}}\\right]\n\\]</div><p></p><p>考虑互信息 <span class=\"math inline\">\\(I(X;Y)\\)</span> 的以下形式：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = \\mathbb{E}\\left[\\log\\frac{p(y|x)}{p(y)}\\right]\n\\]</div><p></p><p>现在，我们想建立 <span class=\"math inline\">\\(I(X;Y)\\)</span> 和 <span class=\"math inline\">\\(L_{\\text{min}}\\)</span> 的关系。通过巧妙的代数变换，把互信息拆开：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = \\mathbb{E}\\left[\\log\\frac{p(y|x)}{p(y)}\\right]\n= \\mathbb{E}\\left[\\log\\frac{\\frac{p(y|x)}{p(y)}}{\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}}\\right] + \\mathbb{E}\\left[\\log\\left(\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right)\\right]\n\\]</div><p></p><p>第一项就是 <span class=\"math inline\">\\(-L_{\\text{min}}\\)</span> 吗？不完全是。实际上，<span class=\"math inline\">\\(-L_{\\text{min}}\\)</span> = 第一项 - log N：</p>\n<p></p><div class=\"math display\">\\[-L_{\\text{min}} = \\mathbb{E}\\left[\\log\\frac{\\frac{p(y|x)}{p(y)}}{\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}}\\right]\n= \\mathbb{E}\\left[\\log\\frac{\\frac{p(y|x)}{p(y)}}{\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}}\\right] - \\log N\n\\]</div><p></p><p>所以：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = (-L_{\\text{min}} + \\log N) + \\mathbb{E}\\left[\\log\\left(\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right)\\right]\n\\]</div><p></p><p>现在看最后一项：<span class=\"math inline\">\\(\\mathbb{E}\\left[\\log\\left(\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right)\\right]\\)</span></p>\n<p>由于对数函数是凹函数，根据琴生不等式（Jensen's Inequality）：</p>\n<p></p><div class=\"math display\">\\[\\mathbb{E}[\\log(Z)] \\leq \\log(\\mathbb{E}[Z])\n\\]</div><p></p><p>因此：</p>\n<p></p><div class=\"math display\">\\[\\mathbb{E}\\left[\\log\\left(\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right)\\right] \\leq \\log\\left(\\mathbb{E}\\left[\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right]\\right)\n\\]</div><p></p><p>我们计算这个 log 里面的期望：</p>\n<p></p><div class=\"math display\">\\[\\mathbb{E}\\left[\\frac{p(y_j|x)}{p(y_j)}\\right] = \\int p(y_j) \\cdot \\frac{p(y_j|x)}{p(y_j)} dy_j = \\int p(y_j|x) dy_j = 1\n\\]</div><p></p><p>期望 = 1。所以：</p>\n<p></p><div class=\"math display\">\\[\\log\\left(\\mathbb{E}\\left[\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right]\\right) = \\log(1) = 0\n\\]</div><p></p><p>代入上式 = 0，使用琴生不等式，因此：</p>\n<p></p><div class=\"math display\">\\[\\mathbb{E}\\left[\\log\\left(\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right)\\right] \\leq 0\n\\]</div><p></p><p>将上式 ≤ 0 代回原式：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) \\geq \\log N - L_{\\text{min}}\n\\]</div><p></p><p>由于 <span class=\"math inline\">\\(f^*\\)</span> 是最优的，所以对于任意评分函数 <span class=\"math inline\">\\(f\\)</span>，有 <span class=\"math inline\">\\(L(f) \\geq L_{\\text{min}}\\)</span>，得到：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) \\geq \\log N - L_{\\text{min}} \\geq \\log N - L(f)\n\\]</div><p></p><p>证毕：对于任意评分函数 <span class=\"math inline\">\\(f\\)</span>，<span class=\"math inline\">\\(\\log N - L(f)\\)</span> 是互信息 <span class=\"math inline\">\\(I(X;Y)\\)</span> 的一个下界。</p>\n<br />\n<br />\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-02 20:07</span>&nbsp;\n<a href=\"https://www.cnblogs.com/moonout\">MoonOut</a>&nbsp;\n阅读(<span id=\"post_view_count\">67</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "LangChain4j 工具调用实战",
      "link": "https://www.cnblogs.com/BNTang/p/19432093",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/BNTang/p/19432093\" id=\"cb_post_title_url\" title=\"发布于 2026-01-02 15:32\">\n    <span>LangChain4j 工具调用实战</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>你有没有遇到过这种场景：</p>\n<ul>\n<li>用户问 AI：\"帮我查下今天上海的天气\"</li>\n<li>AI 回答：\"抱歉，我无法获取实时信息。\"</li>\n</ul>\n<p><strong>问题的核心是：AI 没有工具。</strong>就像给你一双手脚，让你去盖房子，你也做不到。但如果给你一套工具箱，情况就完全不同了。</p>\n<p><strong>今天我们就来给 AI 装上一套工具箱</strong>，让它能够从博客园实时获取最新技术文章。</p>\n<h2 id=\"什么是工具调用\">什么是工具调用？</h2>\n<p>简单来说，工具调用就是让 AI 能够\"借用\"外部能力。</p>\n<p>这些能力包括但不限于：</p>\n<ul>\n<li>联网搜索</li>\n<li>调用第三方 API</li>\n<li>读写文件</li>\n<li>查询数据库</li>\n<li>执行代码</li>\n</ul>\n<p><strong>但有一个关键点要特别注意</strong>：</p>\n<p>工具调用 <strong>不是</strong> AI 自己去执行这些工具，而是 AI 说\"我需要调用 XX 工具\"，真正执行的是我们的应用程序。</p>\n<p>流程是这样的：</p>\n<pre><code>用户提问 → AI 分析意图 → AI 决定调用工具\n→ 我们的程序执行工具 → 把结果返回给 AI → AI 继续回答\n</code></pre>\n<h2 id=\"要实现的目标\">要实现的目标</h2>\n<p>让 AI 能够查询博客园用户的最新文章，并提取这些信息：</p>\n<ul>\n<li>文章标题</li>\n<li>文章链接</li>\n<li>发布日期</li>\n<li>摘要内容</li>\n<li>阅读数、评论数、推荐数</li>\n</ul>\n<p><strong>实现方案</strong>：用 Jsoup 抓取博客园页面，把数据整理后返回给 AI。</p>\n<h2 id=\"快速了解流程\">快速了解流程</h2>\n<p>完整流程其实很简单：</p>\n<ol>\n<li>用户提问 → 2. AI 分析意图 → 3. AI 决定调用工具 → 4. 程序执行工具 → 5. 结果返回给 AI → 6. AI 整理后回复用户</li>\n</ol>\n<p><strong>核心就是</strong>：AI 不直接调用工具，而是告诉我们的程序\"我需要调用这个工具\"，程序执行完后把结果给 AI，AI 再基于结果回答用户。</p>\n<blockquote>\n<p>想看详细的调用链路？文章最后有完整的时序图，包你一看就懂。</p>\n</blockquote>\n<h2 id=\"动手实现四步搞定\">动手实现（四步搞定）</h2>\n<h3 id=\"步骤-1引入依赖\">步骤 1：引入依赖</h3>\n<p>先在 <code>pom.xml</code> 中加入 Jsoup（网页爬虫库）：</p>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.jsoup&lt;/groupId&gt;\n    &lt;artifactId&gt;jsoup&lt;/artifactId&gt;\n    &lt;version&gt;1.20.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h3 id=\"步骤-2编写工具类\">步骤 2：编写工具类</h3>\n<p>在 <code>tools</code> 包下创建一个工具类，用 <code>@Tool</code> 注解告诉 LangChain4j：\"这是一个工具\"。</p>\n<p><strong>⚠️ 重点</strong>：工具描述一定要写清楚，AI 能否正确调用工具全看这个描述！</p>\n<pre><code class=\"language-java\">/**\n * 博客园文章搜索工具\n * 用于从博客园抓取用户的最新文章信息\n *\n * @author BNTang\n */\n@Slf4j\npublic class CnblogsArticleTool {\n\n    /**\n     * 从指定用户的博客园主页获取最新的技术文章列表。\n     * 支持提取文章标题、链接、发布日期、摘要、阅读数、评论数和推荐数等信息。\n     *\n     * @param input 博客园用户名或URL，可选地附加\"|N\"来限制结果数量\n     * @return 技术文章列表的JSON格式，包含详细信息，若失败则返回错误信息\n     */\n    @Tool(name = \"cnblogsSearch\", value = \"\"\"\n            从博客园获取最新文章。输入可以是：\n            - 博客园用户名（例如：'someUser'）\n            - 完整的个人主页URL（例如：'https://www.cnblogs.com/someUser/'）\n            可选择性地附加'|N'来限制结果数量，例如：'someUser|5'。\n            返回包含标题、链接、日期、摘要、阅读数、评论数、推荐数的JSON数组。\n            \"\"\"\n    )\n    public String searchCnblogsArticles(@P(value = \"用户名或URL（可选地附加|限制数量）\") String input) {\n        if (input == null || input.trim().isEmpty()) {\n            return \"{\\\"error\\\":\\\"Empty input\\\"}\";\n        }\n\n        String[] parts = input.trim().split(\"\\\\|\", 2);\n        String target = parts[0].trim();\n        int limit = 10;\n        if (parts.length == 2) {\n            try {\n                limit = Math.max(1, Math.min(100, Integer.parseInt(parts[1].trim())));\n            } catch (NumberFormatException ignored) { /* keep default */ }\n        }\n\n        String url;\n        if (target.startsWith(\"http://\") || target.startsWith(\"https://\")) {\n            url = target;\n        } else {\n            url = \"https://www.cnblogs.com/\" + target + \"/\";\n        }\n\n        Document doc = fetchDocumentWithRetries(url, 3, 8000);\n        if (doc == null) {\n            return \"{\\\"error\\\":\\\"Failed to fetch or parse page\\\"}\";\n        }\n\n        // 选择博客文章的主容器\n        Elements dayElements = doc.select(\".day\");\n\n        List&lt;ArticleInfo&gt; results = new ArrayList&lt;&gt;();\n\n        for (Element dayEl : dayElements) {\n            if (results.size() &gt;= limit) {\n                break;\n            }\n\n            // 提取标题和链接\n            Element titleEl = dayEl.selectFirst(\".postTitle a, .postTitle2\");\n            if (titleEl == null) {\n                continue;\n            }\n\n            String title = titleEl.text().trim();\n            // 移除\"[置顶]\"标记\n            title = title.replaceAll(\"^\\\\[置顶]\\\\s*\", \"\");\n\n            String href = titleEl.absUrl(\"href\");\n            if (href.isEmpty()) {\n                href = titleEl.attr(\"href\").trim();\n            }\n\n            // 去重检查\n            boolean seen = false;\n            for (ArticleInfo r : results) {\n                if (r.url.equals(href)) {\n                    seen = true;\n                    break;\n                }\n            }\n            if (seen) {\n                continue;\n            }\n\n            // 提取日期\n            String date = \"\";\n            Element dateEl = dayEl.selectFirst(\".dayTitle a\");\n            if (dateEl != null) {\n                date = dateEl.text().trim();\n            }\n\n            // 提取摘要\n            String summary = \"\";\n            Element summaryEl = dayEl.selectFirst(\".c_b_p_desc, .postCon\");\n            if (summaryEl != null) {\n                summary = summaryEl.text().trim();\n                // 移除\"阅读全文\"链接文本\n                summary = summary.replaceAll(\"阅读全文$\", \"\").trim();\n                // 限制摘要长度\n                if (summary.length() &gt; 200) {\n                    summary = summary.substring(0, 200) + \"...\";\n                }\n            }\n\n            // 提取统计信息\n            String viewCount = \"0\";\n            String commentCount = \"0\";\n            String diggCount = \"0\";\n\n            Element postDesc = dayEl.selectFirst(\".postDesc\");\n            if (postDesc != null) {\n                Element viewEl = postDesc.selectFirst(\".post-view-count\");\n                if (viewEl != null) {\n                    viewCount = extractNumber(viewEl.text());\n                }\n\n                Element commentEl = postDesc.selectFirst(\".post-comment-count\");\n                if (commentEl != null) {\n                    commentCount = extractNumber(commentEl.text());\n                }\n\n                Element diggEl = postDesc.selectFirst(\".post-digg-count\");\n                if (diggEl != null) {\n                    diggCount = extractNumber(diggEl.text());\n                }\n            }\n\n            if (!title.isEmpty() &amp;&amp; !href.isEmpty()) {\n                results.add(new ArticleInfo(title, href, date, summary, viewCount, commentCount, diggCount));\n            }\n        }\n\n        if (results.isEmpty()) {\n            return \"{\\\"message\\\":\\\"未找到文章。\\\"}\";\n        }\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        for (int i = 0; i &lt; results.size(); i++) {\n            ArticleInfo article = results.get(i);\n            sb.append(\"{\");\n            sb.append(\"\\\"title\\\":\").append(jsonEscape(article.title)).append(\",\");\n            sb.append(\"\\\"url\\\":\").append(jsonEscape(article.url)).append(\",\");\n            sb.append(\"\\\"date\\\":\").append(jsonEscape(article.date)).append(\",\");\n            sb.append(\"\\\"summary\\\":\").append(jsonEscape(article.summary)).append(\",\");\n            sb.append(\"\\\"viewCount\\\":\").append(article.viewCount).append(\",\");\n            sb.append(\"\\\"commentCount\\\":\").append(article.commentCount).append(\",\");\n            sb.append(\"\\\"diggCount\\\":\").append(article.diggCount);\n            sb.append(\"}\");\n            if (i &lt; results.size() - 1) {\n                sb.append(\",\");\n            }\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }\n\n    /**\n     * 带重试机制获取网页文档\n     *\n     * @param url         目标URL\n     * @param maxAttempts 最大尝试次数\n     * @param timeoutMs   超时时间（毫秒）\n     * @return Jsoup文档对象，失败返回null\n     */\n    private Document fetchDocumentWithRetries(String url, int maxAttempts, int timeoutMs) {\n        String userAgent = \"Mozilla/5.0 (compatible; Bot/1.0; +https://example.com/bot)\";\n        int attempt = 0;\n        while (attempt &lt; maxAttempts) {\n            attempt++;\n            try {\n                return Jsoup.connect(url)\n                        .userAgent(userAgent)\n                        .timeout(timeoutMs)\n                        .referrer(\"https://www.google.com\")\n                        .get();\n            } catch (IOException e) {\n                log.warn(\"第{}次尝试获取 {} 失败: {}\", attempt, url, e.getMessage());\n                try {\n                    Thread.sleep(500L * attempt);\n                } catch (InterruptedException ignored) {\n                    Thread.currentThread().interrupt();\n                    break;\n                }\n            }\n        }\n        log.error(\"所有尝试均失败，无法获取 {}\", url);\n        return null;\n    }\n\n    /**\n     * 从文本中提取数字\n     *\n     * @param text 包含数字的文本，如\"阅读(123)\"\n     * @return 提取的数字字符串\n     */\n    private String extractNumber(String text) {\n        if (text == null) {\n            return \"0\";\n        }\n        text = text.replaceAll(\"[^0-9]\", \"\");\n        return text.isEmpty() ? \"0\" : text;\n    }\n\n    /**\n     * JSON字符串转义\n     *\n     * @param s 待转义的字符串\n     * @return 转义后的JSON字符串\n     */\n    private String jsonEscape(String s) {\n        if (s == null) {\n            return \"\\\"\\\"\";\n        }\n        String escaped = s.replace(\"\\\\\", \"\\\\\\\\\")\n                .replace(\"\\\"\", \"\\\\\\\"\")\n                .replace(\"\\n\", \"\\\\n\")\n                .replace(\"\\r\", \"\\\\r\");\n        return \"\\\"\" + escaped + \"\\\"\";\n    }\n\n    /**\n     * 文章信息类\n     */\n    private static class ArticleInfo {\n        String title;\n        String url;\n        String date;\n        String summary;\n        String viewCount;\n        String commentCount;\n        String diggCount;\n\n        ArticleInfo(String title, String url, String date, String summary,\n                    String viewCount, String commentCount, String diggCount) {\n            this.title = title;\n            this.url = url;\n            this.date = date;\n            this.summary = summary;\n            this.viewCount = viewCount;\n            this.commentCount = commentCount;\n            this.diggCount = diggCount;\n        }\n    }\n}\n</code></pre>\n<p><strong>核心逻辑</strong>：</p>\n<ol>\n<li>解析用户输入（支持用户名或 URL）</li>\n<li>用 Jsoup 抓取博客园页面</li>\n<li>用 CSS 选择器提取文章信息</li>\n<li>返回 JSON 格式的结果</li>\n</ol>\n<h3 id=\"步骤-3把工具绑定到-ai-service\">步骤 3：把工具绑定到 AI Service</h3>\n<pre><code class=\"language-java\">public AiCodeHelperService aiCodeHelperService() {\n    ChatMemory chatMemory = MessageWindowChatMemory.withMaxMessages(10);\n\n    return AiServices.builder(AiCodeHelperService.class)\n            .chatModel(qwenChatModel)\n            .chatMemory(chatMemory)\n            .contentRetriever(contentRetriever)\n            .tools(new CnblogsArticleTool())  // ← 绑定工具\n            .build();\n}\n</code></pre>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2105804/202601/2105804-20260102134201705-1158921879.png\" /></p>\n<h3 id=\"步骤-4测试一下\">步骤 4：测试一下</h3>\n<p>写个单元测试：</p>\n<pre><code class=\"language-java\">@Test\nvoid chatWithTools() {\n    String result = aiCodeHelperService.chat(\n        \"帮我查下博客园用户 BNTang 的最新文章\"\n    );\n    System.out.println(result);\n}\n</code></pre>\n<p><strong>关键来了</strong>，在工具方法里打断点，Debug 运行：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2105804/202601/2105804-20260102134527464-344030566.png\" /></p>\n<p><strong>你会看到断点真的停下来了！</strong></p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2105804/202601/2105804-20260102134605221-2143614017.png\" /></p>\n<p>这说明 <strong>AI 真的调用了我们的工具</strong>！</p>\n<p>工具把数据返回给 AI 后，AI 会整理成自然语言：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2105804/202601/2105804-20260102134407815-1435969741.png\" /></p>\n<p>在 Debug 模式下，你还能看到 AI Service 加载了工具：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2105804/202601/2105804-20260102134818678-1880921390.png\" /></p>\n<p>以及工具的完整调用链路：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2105804/202601/2105804-20260102135157469-2000354683.png\" /></p>\n<p><strong>完美运行！</strong></p>\n<h2 id=\"工具定义的两种方式\">工具定义的两种方式</h2>\n<p>前面用的是声明式定义（注解），LangChain4j 也支持编程式定义：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2105804/202601/2105804-20260102135244721-1011469314.png\" /></p>\n<p><strong>简单场景用声明式，需要动态创建工具用编程式。</strong></p>\n<h2 id=\"还能做更多\">还能做更多</h2>\n<p>除了搜索，工具调用还能实现这些功能：</p>\n<ul>\n<li>读写本地文件</li>\n<li>生成 PDF 报告</li>\n<li>执行 Shell 命令</li>\n<li>生成图表</li>\n<li>调用企业内部 API</li>\n</ul>\n<p><strong>更棒的是</strong>：这些工具不一定都要自己写，可以通过 MCP（Model Context Protocol）协议直接用别人开发好的工具。</p>\n<h2 id=\"完整的调用链路\">完整的调用链路</h2>\n<p>如果想深入理解工具调用的每一步，看这个时序图就对了：</p>\n<div class=\"mermaid\">sequenceDiagram\n      autonumber\n\n      participant U2 as 🧪 Test(用户)\n      participant B1 as AiCodeHelperService\n      participant L1 as LangChain4j框架\n      participant L2 as ChatModel(LLM)\n      participant B3 as CnblogsArticleTool\n      participant T1 as Jsoup(网页抓取)\n\n      Note over U2,T1: chatWithTools() 测试流程\n\n      U2-&gt;&gt;B1: chat(\"帮我查询博客园用户 BNTang 的最新技术文章...\")\n      B1-&gt;&gt;L1: 转发请求\n      L1-&gt;&gt;L1: 加载 system-prompt.txt\n      L1-&gt;&gt;L1: 添加 ChatMemory(最近10条消息)\n      L1-&gt;&gt;L2: 发送用户消息\n\n      L2-&gt;&gt;L2: 分析意图\n      L2-&gt;&gt;L2: 识别需要调用 cnblogsSearch 工具\n\n      L2--&gt;&gt;L1: 返回工具调用请求\n      L1-&gt;&gt;B3: searchCnblogsArticles(\"BNTang\")\n\n      B3-&gt;&gt;B3: 解析输入参数\n      B3-&gt;&gt;B3: 构造URL (https://www.cnblogs.com/BNTang/)\n\n      B3-&gt;&gt;T1: fetchDocumentWithRetries(url, 3, 8000)\n      T1-&gt;&gt;T1: 发送HTTP请求\n      T1--&gt;&gt;B3: 返回HTML文档\n\n      B3-&gt;&gt;B3: 解析HTML (.day 元素)\n      B3-&gt;&gt;B3: 提取文章信息(标题、链接、日期、摘要等)\n      B3-&gt;&gt;B3: 生成JSON结果\n\n      B3--&gt;&gt;L1: 返回文章列表JSON\n      L1-&gt;&gt;L2: 发送工具结果给LLM\n\n      L2-&gt;&gt;L2: 基于工具结果生成最终回复\n      L2--&gt;&gt;L1: 返回最终答案\n      L1--&gt;&gt;B1: 返回结果\n      B1--&gt;&gt;U2: 返回 String 结果\n\n      U2-&gt;&gt;U2: System.out.println(result)\n</div><p><strong>时序图解读</strong>：</p>\n<ol>\n<li><strong>用户发起请求</strong>（步骤 1-4）：Test 调用 Service，Service 转发给 LangChain4j 框架</li>\n<li><strong>AI 分析意图</strong>（步骤 5-7）：LLM 分析用户问题，决定需要调用 <code>cnblogsSearch</code> 工具</li>\n<li><strong>工具执行</strong>（步骤 8-17）：Tool 用 Jsoup 抓取博客园页面，解析数据</li>\n<li><strong>结果返回</strong>（步骤 18-21）：工具结果返回给 LLM，LLM 生成最终答案</li>\n</ol>\n<p><strong>关键点</strong>：工具执行在应用侧（B3、T1），不在 AI 服务器（L2）。</p>\n<h2 id=\"写在最后\">写在最后</h2>\n<p>工具调用是让 AI 突破能力边界的关键技术。</p>\n<p><strong>记住三个要点</strong>：</p>\n<ol>\n<li>工具描述写清楚，AI 才能正确调用</li>\n<li>工具在应用侧执行，不在 AI 服务器</li>\n<li>声明式定义简单，编程式定义灵活</li>\n</ol>\n<p>通过 LangChain4j 的 <code>@Tool</code> 注解，只需要几行代码，就能让 AI 拥有\"超能力\"。</p>\n<hr />\n<p><strong>系列文章持续更新中，关注我不错过每一篇干货。</strong></p>\n<p><strong>这篇文章对你有用的话，点个赞、在看支持一下吧！</strong></p>\n<hr />\n<p><strong>相关文章推荐</strong>：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/XhmFIeKpJR37AqqLg46b5w\" rel=\"noopener nofollow\" target=\"_blank\">智谱 GLM-4.7 编程第一</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/8fRzTXtAJ8_IfX2OggGDsw\" rel=\"noopener nofollow\" target=\"_blank\">LangChain4j 结构化输出实战</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/KtaNzGc3wbVKPwMTVl1z4g\" rel=\"noopener nofollow\" target=\"_blank\">让 AI 不再失忆</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/pnCbt98Ob4hb8sj9WPVV3g\" rel=\"noopener nofollow\" target=\"_blank\">Claude Code 免费指南</a></li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-02 15:32</span>&nbsp;\n<a href=\"https://www.cnblogs.com/BNTang\">BNTang</a>&nbsp;\n阅读(<span id=\"post_view_count\">116</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "独立开发者的 2025：我为什么还在做一个“看起来很普通”的客服系统",
      "link": "https://www.cnblogs.com/sheng_chao/p/19431954",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sheng_chao/p/19431954\" id=\"cb_post_title_url\" title=\"发布于 2026-01-02 15:02\">\n    <span>独立开发者的 2025：我为什么还在做一个“看起来很普通”的客服系统</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        过去几年里，技术社区反复讨论同样几个话题：AI、出海、SaaS、独立开发者。热度在变，说法在升级，但真正把一个系统长期跑起来的人，感受往往更具体也更现实。这篇文章，算是一次不太宏大的回顾——记录我在 2025 年围绕一个客服系统所做的选择、踩过的坑，以及一些被现实反复校正过的认知。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>过去几年里，技术社区反复讨论同样几个话题：AI、出海、SaaS、独立开发者。<br />\n热度在变，说法在升级，但真正把一个系统长期跑起来的人，感受往往更具体也更现实。<br />\n2025 年对我来说，并不是一个有明显拐点的年份，没有爆发式增长，也没有戏剧性转向，只是持续做事、持续暴露问题、持续修正判断的一年。<br />\n这篇文章，算是一次不太宏大的回顾——记录我在 2025 年围绕一个客服系统所做的选择、踩过的坑，以及一些被现实反复校正过的认知。</p>\n<hr />\n<h2 id=\"一2025一个看似普通其实很残酷的一年\">一、2025：一个“看似普通、其实很残酷”的一年</h2>\n<p>如果只看技术社区的热词，2025 年似乎并不特别。<br />\nAI、出海、SaaS、独立开发者，这些词在过去几年里已经被反复讨论，甚至有些“疲劳”。</p>\n<p>但真正身处其中的人，大多能感受到一种很微妙的变化：</p>\n<p><strong>机会并没有消失，但容错率在急剧下降。</strong></p>\n<ul>\n<li>流量不再自然增长</li>\n<li>用户不再愿意“陪你一起成熟”</li>\n<li>技术红利逐步变成工程与耐力的比拼</li>\n</ul>\n<p>你依然可以做产品、写代码、发布版本，但<strong>每一次决策的代价都变得更真实、更不可逆</strong>。</p>\n<hr />\n<h3 id=\"表面平静底层在加速分化\">表面平静，底层在加速分化</h3>\n<p>从外部看，2025 年不像 2020 那样剧烈，也不像 2022 那样充满不确定性。<br />\n但从内部看，它更像是一个<strong>分水岭年份</strong>：</p>\n<ul>\n<li>大厂在收缩战线，只保留“确定性强”的方向</li>\n<li>中小团队开始意识到，靠融资和故事续命越来越难</li>\n<li>独立开发者要么更专业，要么更快放弃</li>\n</ul>\n<p><strong>“能跑起来”已经不算本事，“能活下去”才是。</strong></p>\n<hr />\n<h3 id=\"技术依然重要但不再是护城河本身\">技术依然重要，但不再是护城河本身</h3>\n<p>2025 年我最大的一个感受是：</p>\n<blockquote>\n<p>技术没有贬值，但“只靠技术”的路径，正在快速变窄。</p>\n</blockquote>\n<p>框架在变，模型在升级，工具链越来越完善。<br />\n一个功能，从想法到落地，前所未有地快。</p>\n<p>但这也意味着：</p>\n<ul>\n<li>同质化速度极快</li>\n<li>抄一个“能用的版本”几乎没有门槛</li>\n<li>真正拉开差距的，是长期维护、稳定性、细节和取舍</li>\n</ul>\n<p>很多项目不是死于“做不出来”，<br />\n而是死于 <strong>“做到一半，发现后面的路太长”</strong>。</p>\n<hr />\n<h3 id=\"对独立开发者而言这是清醒的一年\">对独立开发者而言，这是“清醒”的一年</h3>\n<p>如果说前几年还可以抱有某种浪漫幻想，<br />\n那么 2025 年更像是一年集体清醒期：</p>\n<ul>\n<li>你开始认真计算服务器、运维、支持成本</li>\n<li>你意识到每一个“免费用户”都在消耗注意力</li>\n<li>你必须直面一个问题：<strong>这东西有没有人愿意长期用、长期付费</strong></li>\n</ul>\n<p>对我来说，这一年并没有发生什么戏剧性的转折。<br />\n没有爆发式增长，也没有彻底放弃。</p>\n<p>只是逐渐意识到：<br />\n<strong>如果要继续做，就必须把它当成一件长期、甚至有点枯燥的事来对待。</strong></p>\n<hr />\n<h3 id=\"正是在这样的背景下我继续推进了-升讯威在线客服与营销系统\">正是在这样的背景下，我继续推进了 升讯威在线客服与营销系统</h3>\n<p>在 2025 年，我仍然选择把时间投入到一个看起来并不“性感”的方向——客服系统。</p>\n<p>不是因为它新，<br />\n而是因为它<strong>足够现实</strong>：</p>\n<ul>\n<li>足够考验工程能力</li>\n<li>足够暴露产品取舍</li>\n<li>也足够真实地反映“有没有人在用”</li>\n</ul>\n<p>后面的章节，我会具体聊聊这一年里踩过的坑、做过的取舍，以及一些被反复验证过的反直觉结论。</p>\n<p>但所有这些，都源于同一个前提：</p>\n<blockquote>\n<p><strong>2025 年，不再是“试试看”的年份了。</strong></p>\n</blockquote>\n<p>如果你还在做事，大概率和我一样，已经意识到了这一点。</p>\n<hr />\n<h2 id=\"二我为什么在-2025-年还要做一个客服系统\">二、我为什么在 2025 年还要做一个“客服系统”</h2>\n<p>如果只从“赛道选择”的角度看，<br />\n在 2025 年做客服系统，几乎是一个<strong>反直觉</strong>的决定。</p>\n<p>它不新、不酷、不在风口上。<br />\n也很难用一句话讲出“颠覆性”。</p>\n<p>但正因为如此，它反而成了一个非常诚实的选择。</p>\n<hr />\n<h3 id=\"客服系统是一面照妖镜\">客服系统是一面“照妖镜”</h3>\n<p>我一直觉得，客服系统是 SaaS 产品里非常特殊的一类：</p>\n<ul>\n<li>它不解决“增长”，而是暴露问题</li>\n<li>它不创造幻想，而是承接情绪</li>\n<li>它每天面对的，都是系统最真实、最糟糕的状态</li>\n</ul>\n<p>当一切都运转良好时，客服系统几乎是隐形的；<br />\n<strong>只有当别的地方出问题，它才会被频繁打开。</strong></p>\n<p>这意味着两件事：</p>\n<ol>\n<li>它对稳定性和实时性的要求极端苛刻</li>\n<li>它几乎无法靠“营销叙事”掩盖真实体验</li>\n</ol>\n<p><strong>好不好用，用几天就知道。</strong></p>\n<hr />\n<h3 id=\"红海并不等于没问题可解决\">“红海”并不等于“没问题可解决”</h3>\n<p>客服系统常被视为红海产品，但我在实际使用和调研中发现的却是另一种景象：</p>\n<ul>\n<li>功能很多，但长期使用体验割裂</li>\n<li>演示很好看，真实场景却频繁卡壳</li>\n<li>对销售友好，对工程师不友好</li>\n</ul>\n<p>尤其是对中小团队来说，常见的困境是：</p>\n<ul>\n<li>SaaS 版本限制多、定制难</li>\n<li>私有化版本部署复杂、维护成本高</li>\n<li>出了问题，很难快速定位到底是哪一层在出错</li>\n</ul>\n<p><strong>不是没有产品，而是“能安心长期用的产品”不多。</strong></p>\n<hr />\n<h3 id=\"我想验证一件事工程导向能不能做出好产品\">我想验证一件事：工程导向能不能做出好产品</h3>\n<p>在 2025 年继续做客服系统，对我来说更像一次验证，而不是押注。</p>\n<p>我想验证的不是“能不能做成一个大平台”，<br />\n而是一个更具体、也更残酷的问题：</p>\n<blockquote>\n<p>如果从一开始就以工程可控性、可维护性为核心，<br />\n能不能反过来，做出一个真正对用户友好的系统？</p>\n</blockquote>\n<p>这意味着很多不讨巧的选择：</p>\n<ul>\n<li>把时间花在日志、遥测、异常采集上</li>\n<li>花精力设计清晰、可预期的系统边界</li>\n<li>接受“功能慢一点，但稳定优先”的节奏</li>\n</ul>\n<p>这些东西在 Demo 里几乎看不出来，<br />\n但在第 100 次、第 1000 次使用时，会被反复感知。</p>\n<hr />\n<h3 id=\"升讯威在线客服与营销系统-只是这个验证过程的载体\">升讯威在线客服与营销系统 只是这个验证过程的载体</h3>\n<p>在这个过程中，我做了一个叫 <strong>升讯威在线客服与营销系统</strong> 的客服系统。</p>\n<p>但它并不是一个“先定产品、再找用户”的项目，<br />\n更像是一个<strong>长期承载思考和取舍的容器</strong>：</p>\n<ul>\n<li>哪些功能值得做，哪些应该克制</li>\n<li>哪些问题应该由系统解决，哪些必须交还给人</li>\n<li>在 SaaS 和私有化之间，边界应该如何划分</li>\n</ul>\n<p>很多决策，并不是“行业最佳实践”，<br />\n而是一次次被现实逼出来的选择。</p>\n<hr />\n<h3 id=\"为什么是-2025而不是更早或更晚\">为什么是 2025，而不是更早或更晚</h3>\n<p>如果是更早几年，我可能会更激进；<br />\n如果再晚几年，可能会更保守。</p>\n<p>2025 刚好处在一个微妙的位置：</p>\n<ul>\n<li>技术足够成熟，可以把基础问题解决好</li>\n<li>用户足够理性，不再被概念牵着走</li>\n<li>我自己，也已经不再执着于“做一个看起来很厉害的东西”</li>\n</ul>\n<p>而是更在意：</p>\n<blockquote>\n<p><strong>这个系统，在真实世界里，能不能被长期信任。</strong></p>\n</blockquote>\n<p>这就是我在 2025 年，仍然选择做一个客服系统的核心原因。</p>\n<hr />\n<h2 id=\"三2025-年我真正踩过的-5-个坑\">三、2025 年我真正踩过的 5 个坑</h2>\n<p>这一年里，我越来越清楚一件事：</p>\n<blockquote>\n<p>真正决定一个系统能不能“长期活着”的，<br />\n往往不是你最得意的那部分代码。</p>\n</blockquote>\n<p>下面这 5 个坑，都不是概念问题，而是<strong>上线之后、真实使用中反复出现</strong>的问题。</p>\n<hr />\n<h3 id=\"坑一把功能完整误当成系统可用\">坑一：把“功能完整”误当成“系统可用”</h3>\n<p>这是最早、也是最隐蔽的一个坑。</p>\n<p>在开发初期，很容易用 checklist 思维判断进度：</p>\n<ul>\n<li>会话有了</li>\n<li>转接有了</li>\n<li>访客追踪有了</li>\n<li>历史记录能查</li>\n</ul>\n<p><strong>看起来一切都齐了。</strong></p>\n<p>但真正上线后才发现，客服系统的“可用”，并不取决于有没有功能，而取决于：</p>\n<ul>\n<li>高峰期会不会卡</li>\n<li>网络抖动时会不会丢消息</li>\n<li>客服端卡死后能不能恢复</li>\n</ul>\n<p>这些问题，只有在<strong>真实用户、真实压力</strong>下才会暴露。</p>\n<p>后来我不得不承认：<br />\n<strong>客服系统不是功能型产品，而是稳定性型产品。</strong></p>\n<hr />\n<h3 id=\"坑二低估实时系统的复杂度\">坑二：低估“实时系统”的复杂度</h3>\n<p>理论上，一个客服系统就是：</p>\n<blockquote>\n<p>WebSocket + 消息转发 + 状态同步</p>\n</blockquote>\n<p>实际写起来，完全不是一回事。</p>\n<p>只要系统存在：</p>\n<ul>\n<li>多客服</li>\n<li>多会话</li>\n<li>多设备登录</li>\n<li>客服/访客随时上下线</li>\n</ul>\n<p>就必然会遇到这些问题：</p>\n<ul>\n<li>状态不同步</li>\n<li>幽灵会话</li>\n<li>已关闭的连接仍然被认为“在线”</li>\n<li>消息已发送，但对方并未真正接收</li>\n</ul>\n<p>最痛苦的是：<br />\n<strong>这些问题很难稳定复现。</strong></p>\n<p>后来我才真正理解，实时系统的核心不是“快”，<br />\n而是 <strong>状态一致性的收敛能力</strong>。</p>\n<hr />\n<h3 id=\"坑三把日志当成事后工具\">坑三：把日志当成“事后工具”</h3>\n<p>一开始，我也和很多人一样：</p>\n<ul>\n<li>出问题了，再加日志</li>\n<li>定位到了，再删一部分</li>\n</ul>\n<p>直到有一天我意识到：</p>\n<blockquote>\n<p>在客服系统里，如果你需要“复现问题”，<br />\n这个问题本身就已经很严重了。</p>\n</blockquote>\n<p>很多用户反馈的问题，本质是：</p>\n<ul>\n<li>“刚刚还能用，现在不行了”</li>\n<li>“有时候会断”</li>\n<li>“偶尔收不到消息”</li>\n</ul>\n<p>如果没有<strong>结构化、可关联的日志和遥测数据</strong>，<br />\n你根本无法判断问题发生在哪一层。</p>\n<p>从那之后，我开始把日志、异常、遥测当作<strong>系统的一部分</strong>，<br />\n而不是附加模块。</p>\n<hr />\n<h3 id=\"坑四以为-saas-和私有化只是部署方式不同\">坑四：以为 SaaS 和私有化只是“部署方式不同”</h3>\n<p>这是一个非常典型、也非常昂贵的认知错误。</p>\n<p>在早期，我下意识地认为：</p>\n<blockquote>\n<p>SaaS 跑得通，私有化就是“多打个包”。</p>\n</blockquote>\n<p>真正开始支持私有化之后才发现：</p>\n<ul>\n<li>网络环境完全不可控</li>\n<li>依赖服务可能被裁剪</li>\n<li>客户更关心“可诊断性”而不是“自动化”</li>\n</ul>\n<p>很多在 SaaS 下理所当然的假设，在私有化环境中都会失效。</p>\n<p><strong>它们不是同一个产品，只是共享了一部分代码。</strong></p>\n<hr />\n<h3 id=\"坑五忽视非功能需求的长期成本\">坑五：忽视“非功能需求”的长期成本</h3>\n<p>性能、稳定性、可观测性、安全性，<br />\n这些东西在需求评审时，往往排在最后。</p>\n<p>但在客服系统里，它们会以一种非常直接的方式反噬你：</p>\n<ul>\n<li>一次卡顿，就可能造成大量负面体验</li>\n<li>一次异常，客服就会怀疑“是不是系统问题”</li>\n<li>一次数据异常，信任成本要用很久才能修复</li>\n</ul>\n<p>我在 2025 年学到的最重要一课是：</p>\n<blockquote>\n<p><strong>非功能需求不是“以后再补”的东西，<br />\n它们决定了你以后还有没有机会补。</strong></p>\n</blockquote>\n<hr />\n<h2 id=\"四产品层面的-3-个反直觉认知\">四、产品层面的 3 个反直觉认知</h2>\n<p>在 2025 年之前，我对“做产品”这件事，多少还带着一点工程师式的理想主义。<br />\n但真正把一个系统放进长期、真实使用场景后，很多直觉其实是错的。</p>\n<p>下面这 3 个认知，都是踩坑之后才慢慢形成的。</p>\n<hr />\n<h3 id=\"认知一用户真正渴望的不是更多能力而是更少意外\">认知一：用户真正渴望的，不是“更多能力”，而是“更少意外”</h3>\n<p>在做客服系统之前，我也以为：</p>\n<blockquote>\n<p>功能多一点，总是好的。</p>\n</blockquote>\n<p>但真实情况恰恰相反。</p>\n<p>对客服来说，一个“好用”的系统，往往意味着：</p>\n<ul>\n<li>今天和昨天的行为是一致的</li>\n<li>高峰期不会突然变慢</li>\n<li>操作之后的结果是可预期的</li>\n</ul>\n<p>他们并不关心系统“还能不能再多做点事”，<br />\n他们更关心的是：</p>\n<blockquote>\n<p><strong>它会不会在关键时刻出问题。</strong></p>\n</blockquote>\n<p>很多功能一旦进入真实使用场景，就会暴露出维护成本、理解成本、误操作成本。<br />\n这些成本，不会出现在 PRD 里，但会长期存在于用户的心理负担中。</p>\n<hr />\n<h3 id=\"认知二真正能被长期使用的系统往往是没有存在感的\">认知二：真正能被长期使用的系统，往往是“没有存在感”的</h3>\n<p>这是一个很反产品直觉的结论。</p>\n<p>我们习惯于强调：</p>\n<ul>\n<li>易用性</li>\n<li>交互细节</li>\n<li>视觉反馈</li>\n</ul>\n<p>但在客服系统这种<strong>高频、长时间使用</strong>的产品里，<br />\n“存在感”本身，反而是一种负担。</p>\n<p>当系统足够稳定、足够顺滑时，用户甚至不会意识到它在“帮忙”。<br />\n它更像空气或地面——<br />\n<strong>只有消失或出问题时，才会被注意到。</strong></p>\n<p>我后来发现，很多所谓的“高级设计”，<br />\n在长期使用中都会被用户下意识地绕开。</p>\n<hr />\n<h3 id=\"认知三对中小团队来说可控性往往比自动化更重要\">认知三：对中小团队来说，“可控性”往往比“自动化”更重要</h3>\n<p>在产品设计层面，“自动化”听起来永远是正确方向。<br />\n但在真实环境中，它是有前提的。</p>\n<p>对中小团队而言：</p>\n<ul>\n<li>人少，但责任清晰</li>\n<li>出问题时，希望知道“哪里坏了”</li>\n<li>更愿意手动介入，而不是面对黑盒</li>\n</ul>\n<p>这意味着：</p>\n<ul>\n<li>清晰的状态</li>\n<li>可追溯的操作</li>\n<li>可解释的结果</li>\n</ul>\n<p>往往比“全自动”更有价值。</p>\n<p>我在 2025 年最大的转变之一，是开始主动压制某些看起来很“聪明”的设计，<br />\n转而强调：</p>\n<blockquote>\n<p><strong>系统是否让人安心。</strong></p>\n</blockquote>\n<hr />\n<h2 id=\"五2025-年我对-升讯威在线客服与营销系统-的几个关键取舍\">五、2025 年我对 升讯威在线客服与营销系统 的几个关键取舍</h2>\n<p>在前面的章节里，我提到过不少“坑”和认知转变。<br />\n但如果这些东西不能反映到具体决策中，它们就只是感悟。</p>\n<p>2025 年，对 升讯威在线客服与营销系统 来说，不是快速扩张的一年，<br />\n而是一年持续做选择、并且<strong>不断否定“看起来更诱人方案”</strong>的过程。</p>\n<p>下面这几个取舍，基本决定了它今天的形态。</p>\n<hr />\n<h3 id=\"取舍一同时提供-saas-和私有化而不是二选一\">取舍一：同时提供 SaaS 和私有化，而不是二选一</h3>\n<p>这是一个从一开始就很“反效率”的决定。</p>\n<p>从纯开发成本看，<br />\nSaaS + 私有化意味着：</p>\n<ul>\n<li>两套部署逻辑</li>\n<li>更多环境差异</li>\n<li>更高的维护复杂度</li>\n</ul>\n<p>但真实需求非常明确：</p>\n<ul>\n<li>有些团队需要“即开即用”</li>\n<li>有些团队必须“完全可控”</li>\n</ul>\n<p>我不想用一种模式去强迫所有人适应。</p>\n<p>最终的取舍是：<br />\n<strong>共享核心能力，但承认它们是两类不同用户。</strong></p>\n<p>这也直接影响了后面很多架构决策。</p>\n<hr />\n<h3 id=\"取舍二克制功能扩张把精力花在系统边界上\">取舍二：克制功能扩张，把精力花在“系统边界”上</h3>\n<p>在 2025 年，我刻意放慢了新增功能的节奏。</p>\n<p>不是因为没想法，<br />\n而是越来越清楚：</p>\n<blockquote>\n<p>客服系统真正的复杂度，不在功能数量，而在系统边界。</p>\n</blockquote>\n<p>比如：</p>\n<ul>\n<li>哪些状态是“强一致”的</li>\n<li>哪些问题必须在服务端解决</li>\n<li>哪些异常可以交给人工兜底</li>\n</ul>\n<p>这些决定，远比“加一个新功能”更影响长期体验。</p>\n<p>很多时候，我选择<strong>不做</strong>，<br />\n而不是做一个“可能有用”的功能。</p>\n<hr />\n<h3 id=\"取舍三优先工程可诊断性而不是全自动体验\">取舍三：优先工程可诊断性，而不是“全自动体验”</h3>\n<p>这是一个非常工程师导向的选择。</p>\n<p>在 升讯威在线客服与营销系统 中，我把相当一部分精力，<br />\n投入到了普通用户几乎看不到的地方：</p>\n<ul>\n<li>更清晰的日志结构</li>\n<li>更明确的错误分类</li>\n<li>更可追溯的会话和事件链路</li>\n</ul>\n<p>这意味着：</p>\n<ul>\n<li>短期内体验并不会“惊艳”</li>\n<li>但一旦出问题，更容易被定位和解释</li>\n</ul>\n<p>对我来说，这比“自动处理一切”更重要。</p>\n<hr />\n<h3 id=\"取舍四国际化不是加语言包而是提前约束设计\">取舍四：国际化不是“加语言包”，而是提前约束设计</h3>\n<p>在 2025 年，我开始认真推进国际化相关工作。</p>\n<p>但这个过程很快让我意识到：<br />\n国际化并不是后期优化，而是<strong>设计约束</strong>。</p>\n<ul>\n<li>文案长度</li>\n<li>时间与时区</li>\n<li>权限与角色命名</li>\n<li>默认行为假设</li>\n</ul>\n<p>这些一旦在早期写死，后期改动成本会非常高。</p>\n<p>所以在 升讯威在线客服与营销系统 中，<br />\n我宁愿慢一点，也要避免“只为单一市场优化”的捷径。</p>\n<hr />\n<h3 id=\"取舍五把-升讯威在线客服与营销系统-当成一个长期系统而不是可卖的功能集合\">取舍五：把 升讯威在线客服与营销系统 当成一个长期系统，而不是“可卖的功能集合”</h3>\n<p>这是所有取舍背后的底层判断。</p>\n<p>如果目标是尽快卖掉，<br />\n有很多更聪明、更激进的做法。</p>\n<p>但在 2025 年，我更关心的是：</p>\n<ul>\n<li>它能不能在真实环境中稳定跑几年</li>\n<li>它是否经得起不断有人接手、维护</li>\n<li>它会不会在某一天变成“没人敢动的系统”</li>\n</ul>\n<p>这决定了我对技术债、对重构、对节奏的态度。</p>\n<hr />\n<h2 id=\"六2026我打算继续做的-3-件小而确定的事\">六、2026：我打算继续做的 3 件“小而确定的事”</h2>\n<p>如果说 2025 年是一个不断做减法、校正方向的年份，<br />\n那对 2026 年，我反而没有太多宏大的规划。</p>\n<p>不是因为没有野心，<br />\n而是越来越清楚：</p>\n<blockquote>\n<p>在一个长期系统里，<br />\n<strong>真正重要的不是“下一步有多远”，而是“这一步能不能站稳”。</strong></p>\n</blockquote>\n<p>所以在 2026 年，我给自己定下的目标非常克制，只做三件“小而确定”的事。</p>\n<hr />\n<h3 id=\"第一件事把稳定从结果变成能力\">第一件事：把“稳定”从结果，变成能力</h3>\n<p>在 2025 年，稳定更多是一个结果导向的判断：<br />\n“最近没出什么大问题”。</p>\n<p>但到了 2026 年，我希望把它前移，变成一种<strong>系统能力</strong>：</p>\n<ul>\n<li>问题是否能被提前发现</li>\n<li>异常是否有明确归因</li>\n<li>在不同环境下，行为是否可预测</li>\n</ul>\n<p>这意味着我会继续投入在：</p>\n<ul>\n<li>更完整的可观测性</li>\n<li>更明确的系统状态模型</li>\n<li>更保守、但可验证的变更策略</li>\n</ul>\n<p>稳定不应该依赖“经验和小心”，<br />\n而应该来自<strong>结构本身</strong>。</p>\n<hr />\n<h3 id=\"第二件事把国际化真正跑一遍而不是支持一下\">第二件事：把国际化真正跑一遍，而不是“支持一下”</h3>\n<p>在 2025 年，国际化更多是设计层面的准备。<br />\n到了 2026 年，我希望让它进入真实运行状态。</p>\n<p>这包括：</p>\n<ul>\n<li>真正的非中文用户</li>\n<li>真正不同的使用习惯</li>\n<li>真正不同的部署环境</li>\n</ul>\n<p>而不是只停留在“可以切换语言”。</p>\n<p>这一步不一定会带来明显增长，<br />\n但它会非常清楚地暴露：</p>\n<blockquote>\n<p>升讯威在线客服与营销系统 的哪些设计是通用的，<br />\n哪些其实是隐含假设。</p>\n</blockquote>\n<hr />\n<h3 id=\"第三件事更明确地知道谁不适合用-升讯威在线客服与营销系统\">第三件事：更明确地知道“谁不适合用 升讯威在线客服与营销系统”</h3>\n<p>这是一个看起来有些反商业，但我认为非常必要的目标。</p>\n<p>在 2026 年，我希望能更清楚地回答一个问题：</p>\n<ul>\n<li><strong>什么样的团队，用 升讯威在线客服与营销系统 会很舒服</strong></li>\n<li><strong>什么样的团队，用它反而会痛苦</strong></li>\n</ul>\n<p>这包括：</p>\n<ul>\n<li>技术能力与期望的匹配</li>\n<li>对可控性 vs 自动化的偏好</li>\n<li>对私有化与合规的真实需求</li>\n</ul>\n<p>一个产品如果试图取悦所有人，<br />\n最终往往谁都留不住。</p>\n<hr />\n<h2 id=\"七结尾给同样在慢慢做事的人\">七、结尾：给同样在“慢慢做事”的人</h2>\n<p>写到这里，其实已经很清楚了。<br />\n这不是一篇“阶段性胜利”的复盘，也不是某种成功经验。</p>\n<p>它更像是一次记录：<br />\n在一个不再奖励冲动和幻想的阶段，<br />\n一个人如何选择继续把事情做好。</p>\n<hr />\n<p>在 2025 年，我越来越少问自己：</p>\n<ul>\n<li>这个方向是不是风口</li>\n<li>这个产品能不能快速放大</li>\n</ul>\n<p>而是反复确认一些更朴素的问题：</p>\n<ul>\n<li>它是不是在解决真实问题</li>\n<li>它有没有在变得更稳定</li>\n<li>如果明年继续做，我是否还能心安</li>\n</ul>\n<p>很多时候，继续做下去，并不是因为看到了希望，<br />\n而是因为<strong>已经看清了现实，仍然觉得值得</strong>。</p>\n<hr />\n<p>如果你也在做一个进展缓慢、反馈稀疏、很难被外人理解的项目，<br />\n那你大概能体会这种状态：</p>\n<ul>\n<li>每一步都很小</li>\n<li>每一次改动都要反复权衡</li>\n<li>很难兴奋，但也不再轻易动摇</li>\n</ul>\n<p>这并不浪漫，<br />\n但它可能是少数真正可持续的节奏。</p>\n<hr />\n<p>我不确定 升讯威在线客服与营销系统 会走到哪一步，<br />\n也不打算在这里承诺什么结果。</p>\n<p>我能确定的只有一件事：</p>\n<blockquote>\n<p><strong>它至少是按照我能长期负责的方式，被认真对待的。</strong></p>\n</blockquote>\n<p>如果你刚好也在寻找一个<br />\n可控、工程友好、愿意陪你走很久的客服系统，<br />\n你大概能理解我为什么会把它做成现在这个样子。</p>\n<p>项目叫 <strong>升讯威在线客服与营销系统</strong>。</p>\n<p>如果没有，也没关系。<br />\n能在这个阶段，继续慢慢把事做好，本身就已经很难得了。</p>\n<hr />\n<h2 id=\"独立者的产品成果\">独立者的产品成果</h2>\n<blockquote>\n<p><a href=\"https://kf.shengxunwei.com\" rel=\"noopener nofollow\" target=\"_blank\">https://kf.shengxunwei.com</a></p>\n</blockquote>\n<p><strong>可全天候 7 × 24 小时挂机运行，网络中断，拔掉网线，手机飞行模式，不掉线不丢消息，欢迎实测。</strong></p>\n<h3 id=\"访客端轻量直观秒级响应的沟通入口\">访客端：轻量直观、秒级响应的沟通入口</h3>\n<p>访客端是客户接触企业的第一窗口，我们精心打磨每一处交互细节，确保用户无需任何学习成本即可发起对话。无论是嵌入式聊天窗口、悬浮按钮，还是移动端自适应支持，都实现了真正的“即点即聊”。系统支持智能欢迎语、来源识别、设备类型判断，可自动记录访客路径并呈现于客服端，帮助企业更好地理解用户意图。在性能方面，访客端采用异步加载与自动重连机制，即使网络波动也能保障消息顺畅送达，真正做到——轻量不失稳定，简单不失智能。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/78019/202506/78019-20250601110426304-100322970.png\" /></p>\n<h3 id=\"客服端软件为高效率沟通而生\">客服端软件：为高效率沟通而生</h3>\n<p>客服端是客服人员的作战平台，我们构建了一个专注、高效、响应迅速的桌面级体验。系统采用多标签会话设计，让客服可同时处理多组对话；访客轨迹、历史会话、地理位置、设备信息、来源渠道等关键信息一目了然，协助客服快速做出判断。内置快捷回复、常用文件、表情支持和智能推荐功能，大幅降低重复劳动成本。同时，系统还支持智能分配、会话转接、转人工、自定义状态等多种机制，保障团队协作流畅，让客服不仅能应对高峰，更能稳定交付满意度。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/78019/202506/78019-20250601110431346-1228494411.png\" /></p>\n<h3 id=\"web-管理后台\">Web 管理后台：</h3>\n<p>Web 管理后台是企业对客服系统的“驾驶舱”，从接入配置、坐席管理，到数据统计、权限控制，一切尽在掌握。你可以灵活设置接待策略、工作时间、转接规则，支持按部门/标签/渠道精细分配访客，满足复杂业务场景。系统还内置访问监控、聊天记录检索、客服绩效统计、错失会话提醒等运营级功能，助力管理者洞察服务瓶颈，持续优化资源配置。支持私有化部署、分权限管理、日志记录与数据导出，为追求安全性与高可控性的企业，提供真正“掌握在自己手里的客服系统”。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/78019/202506/78019-20250601110403917-63642615.png\" /></p>\n<h2 id=\"希望能够打造-开放开源共享努力打造一款优秀的社区开源产品\">希望能够打造： 开放、开源、共享。努力打造一款优秀的社区开源产品。</h2>\n<p>钟意的话请给个赞支持一下吧，谢谢~</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-02 15:02</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sheng_chao\">升讯威在线客服系统</a>&nbsp;\n阅读(<span id=\"post_view_count\">385</span>)&nbsp;\n评论(<span id=\"post_comment_count\">7</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "[js速通#1]HTML Learn Data Day 5",
      "link": "https://www.cnblogs.com/Reisentyan/p/19435323",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Reisentyan/p/19435323\" id=\"cb_post_title_url\" title=\"发布于 2026-01-04 01:58\">\n    <span>[js速通#1]HTML Learn Data Day 5</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>js的基本语法和c++的很像啊，刚好我也会一点c++，准备速通js，然后入手vue3</p>\n<p>学习视频: <a href=\"https://www.bilibili.com/video/BV1iHtozkEWx\" rel=\"noopener nofollow\" target=\"_blank\">B站学习视频</a></p>\n<h2 id=\"1-基本环境与变量\">1. 基本环境与变量</h2>\n<p>JS 代码通常写在 HTML 的 <code>&lt;body&gt;</code> 标签底部，使用 <code>&lt;script&gt;</code> 包裹，以避免阻塞页面渲染。</p>\n<h3 id=\"变量声明-declaration\">变量声明 (Declaration)</h3>\n<p>JS 是弱类型动态语言。除了 <code>var</code> 和 <code>let</code>，现代开发（ES6+）中还有一个极高频使用的 <code>const</code>。</p>\n<ul>\n<li><strong><code>var</code> (老旧)</strong>：存在变量提升 (Hoisting)，且只有函数作用域，没有块级作用域。<strong>Vue3 开发中极少使用。</strong></li>\n<li><strong><code>let</code> (推荐)</strong>：块级作用域（类似 C++ 的局部变量），解决了变量提升导致的逻辑混乱。</li>\n<li><strong><code>const</code> (核心)</strong>：声明常量（引用不可变）。<strong>默认首选</strong>，只有变量确实需要修改时才退化为 <code>let</code>。</li>\n</ul>\n<p><strong>关于变量提升：</strong></p>\n<p>引擎会在<strong>执行代码前</strong>扫描变量声明，将其“提升”到作用域顶部。</p>\n<pre><code class=\"language-js\">console.log(num); // 输出 undefined，而不是报错（这就是提升的副作用）\nvar num = 10;\n\n// 相当于：\n// var num;\n// console.log(num);\n// num = 10;\n</code></pre>\n<p>数据类型：</p>\n<p>主要分为原始类型（Number, String, Boolean, Null, Undefined, Symbol）和引用类型（Object）。</p>\n<p>使用 typeof 可以在运行时检查类型：</p>\n<pre><code class=\"language-js\">console.log(typeof 10); // \"number\"\nconsole.log(typeof null); // \"object\" (这是 JS 的一个历史遗留 Bug，由于二进制前三位是0)\n</code></pre>\n<hr />\n<h2 id=\"2-输入输出-io\">2. 输入输出 (I/O)</h2>\n<table>\n<thead>\n<tr>\n<th><strong>语法</strong></th>\n<th><strong>作用</strong></th>\n<th><strong>备注</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>console.log()</code></td>\n<td>输出到控制台 (F12)</td>\n<td><strong>最常用</strong>。用于调试对象和逻辑。</td>\n</tr>\n<tr>\n<td><code>alert()</code></td>\n<td>浏览器弹窗</td>\n<td>阻塞式，影响体验，仅用于测试。</td>\n</tr>\n<tr>\n<td><code>document.write()</code></td>\n<td>写入 HTML 文档流</td>\n<td><strong>不推荐</strong>。会导致页面重绘甚至覆盖现有内容，现代开发基本废弃。</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h2 id=\"3-流程控制-control-flow\">3. 流程控制 (Control Flow)</h2>\n<p>C++ 程序员熟悉的 <code>if</code>, <code>switch</code>, <code>while</code>, <code>break</code>, <code>continue</code> 在 JS 中基本一致。</p>\n<h3 id=\"循环的坑-loop\">循环的坑 (Loop)</h3>\n<p><code>for...in</code>，在 JS 中主要用于<strong>遍历对象的键 (Key)</strong>，而不是数组的值。</p>\n<pre><code class=\"language-js\">let arr = ['a', 'b'];\n\n// ❌ 不推荐用于数组：遍历的是索引 \"0\", \"1\" (字符串类型)\nfor (let i in arr) {\n    console.log(i); \n}\n\n// ✅ 推荐 (ES6)：for...of，遍历的是值 (类似 C++11 的 range-based for)\nfor (let val of arr) {\n    console.log(val); \n}\n</code></pre>\n<h3 id=\"比较运算符\">比较运算符</h3>\n<ul>\n<li><code>==</code> (相等)：会发生<strong>隐式类型转换</strong> (例如 <code>1 == \"1\"</code> 为 <code>true</code>)。</li>\n<li><code>===</code> (全等)：值和类型都必须相同。<strong>始终使用 <code>===</code></strong>。</li>\n</ul>\n<hr />\n<h2 id=\"4-字符串-string\">4. 字符串 (String)</h2>\n<p>String 在 JS 中是原始类型，但调用方法时会临时包装成对象。</p>\n<table>\n<thead>\n<tr>\n<th><strong>语法</strong></th>\n<th><strong>示例</strong></th>\n<th><strong>作用</strong></th>\n<th><strong>备注</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>length</code></td>\n<td><code>str.length</code></td>\n<td>属性，返回长度</td>\n<td>注意不是方法，不用加 <code>()</code></td>\n</tr>\n<tr>\n<td><code>charAt()</code></td>\n<td><code>str.charAt(0)</code></td>\n<td>获取指定位置字符</td>\n<td>也可用 <code>str[0]</code></td>\n</tr>\n<tr>\n<td><code>concat()</code></td>\n<td><code>str1.concat(str2)</code></td>\n<td>拼接字符串</td>\n<td>现代常用 <code>+</code> 或模板字符串 <code>${a}${b}</code></td>\n</tr>\n<tr>\n<td><code>substring()</code></td>\n<td><code>str.substring(0, 5)</code></td>\n<td>截取 (开始, 结束)</td>\n<td>推荐使用</td>\n</tr>\n<tr>\n<td><code>slice()</code></td>\n<td><code>str.slice(0, 5)</code></td>\n<td>截取 (开始, 结束)</td>\n<td><strong>推荐</strong>，支持负数索引</td>\n</tr>\n<tr>\n<td><code>substr()</code></td>\n<td><code>str.substr(0, 5)</code></td>\n<td>截取 (开始, 长度)</td>\n<td><strong>⚠️ 已废弃</strong>，避免使用</td>\n</tr>\n<tr>\n<td><code>indexOf()</code></td>\n<td><code>str.indexOf('o')</code></td>\n<td>查找首次出现位置</td>\n<td>找不到返回 -1</td>\n</tr>\n<tr>\n<td><code>trim()</code></td>\n<td><code>str.trim()</code></td>\n<td>去除两端空格</td>\n<td>表单输入处理必备</td>\n</tr>\n<tr>\n<td><code>split()</code></td>\n<td><code>str.split(',')</code></td>\n<td>字符串 -&gt; 数组</td>\n<td>按指定分隔符切割</td>\n</tr>\n</tbody>\n</table>\n<p><strong>关于 <code>substring</code> 的容错性：</strong></p>\n<ul>\n<li>自动交换参数：<code>substring(10, 0)</code> 会自动变为 <code>substring(0, 10)</code>。</li>\n<li>负数处理：负数参数会被当作 0 处理。</li>\n</ul>\n<hr />\n<h2 id=\"5-数组-array\">5. 数组 (Array)</h2>\n<p>JS 数组是动态的、异构的（类似于 C++ 的 <code>std::vector&lt;std::any&gt;</code>）。</p>\n<p>JavaScript</p>\n<pre><code>// 数组可以包含任意类型，且大小动态\nlet arr = ['1', 2, false, {name: 'obj'}, null];\n</code></pre>\n<p><strong>常用方法：</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>语法</strong></th>\n<th><strong>作用</strong></th>\n<th><strong>备注</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Array.isArray(x)</code></td>\n<td>判断是否为数组</td>\n<td><code>typeof</code> 数组会返回 \"object\"，所以必须用这个</td>\n</tr>\n<tr>\n<td><code>push()</code> / <code>pop()</code></td>\n<td>尾部 添加/删除</td>\n<td>栈操作 (Stack)</td>\n</tr>\n<tr>\n<td><code>unshift()</code> / <code>shift()</code></td>\n<td>头部 添加/删除</td>\n<td>队列操作 (Queue)，性能较差</td>\n</tr>\n<tr>\n<td><code>join()</code></td>\n<td>数组 -&gt; 字符串</td>\n<td>默认用逗号连接</td>\n</tr>\n<tr>\n<td><code>reverse()</code></td>\n<td><strong>原地</strong>翻转数组</td>\n<td>会修改原数组</td>\n</tr>\n<tr>\n<td><code>splice()</code></td>\n<td>万能增删改</td>\n<td>极其强大，建议查阅 MDN</td>\n</tr>\n</tbody>\n</table>\n<p><strong>经典面试题：反转字符串</strong></p>\n<pre><code class=\"language-js\">// 注意：split() 必须加空引号 '' 才能按字符切割\nlet str = \"hello\";\nlet restr = str.split('').reverse().join(\"\"); \nconsole.log(restr); // \"olleh\"\n</code></pre>\n<hr />\n<h2 id=\"6-函数-function\">6. 函数 (Function)</h2>\n<h3 id=\"传统写法\">传统写法</h3>\n<p>JavaScript</p>\n<pre><code class=\"language-js\">function print(x) {\n    console.log(x);\n    // 无 return 默认返回 undefined\n}\n</code></pre>\n<h3 id=\"箭头函数-arrow-function---es6\">箭头函数 (Arrow Function) - ES6+</h3>\n<p><strong>Vue3 高频考点</strong>。语法更简洁，且不绑定 <code>this</code>。</p>\n<p>JavaScript</p>\n<pre><code>const add = (a, b) =&gt; {\n    return a + b;\n};\n\n// 简写：如果只有一行且是返回值，可省略 {} 和 return\nconst addSimple = (a, b) =&gt; a + b;\n</code></pre>\n<hr />\n<h2 id=\"7-对象-object\">7. 对象 (Object)</h2>\n<p>类似 C++ 的 <code>struct</code> 或 <code>map</code>，键值对集合。</p>\n<pre><code class=\"language-js\">let obj = {\n    name: \"Geek\",\n    age: 25,\n    // 对象方法的简写 (ES6)\n    getAge() { \n        return this.age;\n    }\n};\nconsole.log(obj.name); // 访问属性\n</code></pre>\n<h3 id=\"常用内置对象\">常用内置对象</h3>\n<ul>\n<li>\n<p><strong>Math</strong>: 静态工具类。<code>Math.max()</code>, <code>Math.floor()</code>, <code>Math.random()</code> (0-1之间)。</p>\n</li>\n<li>\n<p><strong>Date</strong>: 需要实例化。</p>\n<pre><code class=\"language-js\">let d = new Date();\nlet timestamp = d.getTime(); // 时间戳 (ms)\nconsole.log(d.toLocaleString()); // 本地时间格式\n</code></pre>\n</li>\n</ul>\n<hr />\n<h2 id=\"️-尾声--下一步\">⚠️ 尾声 &amp; 下一步</h2>\n<p>下次将更新 DOM 操作与 CSS 控制。</p>\n<p>Action Item: 建议在 Chrome 控制台 (F12 -&gt; Console) 直接输入代码运行，体验 JS 的动态特性。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-04 01:58</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Reisentyan\">粉紫系超人气月兔铃仙</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Ubuntu下编辑文本文件的方法",
      "link": "https://www.cnblogs.com/charlee44/p/19434900",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/charlee44/p/19434900\" id=\"cb_post_title_url\" title=\"发布于 2026-01-03 20:33\">\n    <span>Ubuntu下编辑文本文件的方法</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        在 Ubuntu 系统中，从 MobaXterm 的图形化编辑到终端 Vim 操作，提供了多种灵活且适应不同权限与环境的文本文件编辑方法。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"1-引言\">1. 引言</h1>\n<p>尽管已经有了不少的使用 Ubuntu 终端的经验，但笔者认为，要编辑文本文件最好的方式还是使用 GUI 。当然不是所有的情况都能使用 GUI 的，有时还是不得不使用终端编辑文本文件。</p>\n<h1 id=\"2-方法\">2. 方法</h1>\n<h2 id=\"21-mobaxterm-文件浏览器\">2.1 MobaXterm 文件浏览器</h2>\n<p>MobaXterm 是一款专为 Windows 用户设计的增强型终端工具，除了本身的 SSH 客户端之外，还集成了一个 SFTP 文件浏览器。通过这个 SFTP 文件浏览器，就可以直接进行文本文件的编辑工作。当然，它的原理还是把文件下载到 Windows 本地，修改完成后再上传，不是特别顺滑；但是一般情况下是够用了。</p>\n<p><img alt=\"使用 MobaXterm 的文件浏览器编辑文本 \" class=\"lazyload\" /></p>\n<p>不过 MobaXterm 的 SFTP 文件浏览器有个缺点，就是不能编辑具有 root 权限的文件，因为使用 MobaXterm 登录 Ubuntu 一般是普通账户， root 登录的情况比较少。</p>\n<h2 id=\"22-带-gui-的文本编辑器\">2.2 带 GUI 的文本编辑器</h2>\n<p>除了使用内置的 SFTP 文件浏览器，MobaXterm 还支持运行远程 Ubuntu 系统上的 图形界面（GUI）文本编辑器，例如 gedit、mousepad 或 kate。这一功能依赖于 MobaXterm 内置的 X11 服务器，能够将远程 Linux 主机上 GUI 程序的窗口“转发”到 Windows 桌面显示。具体步骤如下：</p>\n<ul>\n<li>确保 SSH 会话启用 X11 转发。在 MobaXterm 中新建 SSH 会话时，默认已勾选 “X11 forwarding”（可在 Advanced SSH settings 中确认）。这是实现 GUI 显示的关键。</li>\n<li>在远程 Ubuntu 上安装 GUI 编辑器。即使服务器没有完整桌面环境，也可以单独安装轻量级编辑器：<pre><code class=\"language-bash\"># 安装 gedit（GNOME 默认编辑器）\nsudo apt update &amp;&amp; sudo apt install gedit -y\n</code></pre>\n</li>\n<li>在终端中直接启动编辑器：<pre><code class=\"language-bash\">gedit ~/.bashrc\n</code></pre>\n</li>\n</ul>\n<p>如果编辑的是普通用户有写权限的文件（如 home 目录下的文件），可直接保存；若需编辑 root 权限文件，可用 sudo 启动编辑器：</p>\n<pre><code class=\"language-bash\">sudo gedit ~/.bashrc\n</code></pre>\n<p>当然这么做不是百分百可行，部分系统出于安全因素执行 <code>sudo gedit</code> 会失败。</p>\n<h2 id=\"23-备份替换大法\">2.3 备份替换大法</h2>\n<p>当面对需要 root 权限的系统文件（如 /etc/fstab、/etc/nginx/nginx.conf 等），而 MobaXterm 的 SFTP 浏览器或 GUI 编辑器又因权限问题无法直接修改时，一个简单粗暴但有效的方法就是：“先在低权限位置编辑，再用 sudo 覆盖原文件”。这种方法常被戏称为“备份替换大法”。具体操作步骤如下：</p>\n<ul>\n<li>复制目标文件到你有写权限的目录（如 home 目录）：<code>sudo cp /etc/your-config.conf ~/your-config.conf.bak</code>。</li>\n<li>在 MobaXterm 中通过 SFTP 浏览器双击该副本进行编辑。</li>\n<li>用 sudo 将修改后的文件覆盖回原位置：<code>sudo cp ~/your-config.conf.bak /etc/your-config.conf</code></li>\n</ul>\n<h2 id=\"24-终端编辑器vim\">2.4 终端编辑器Vim</h2>\n<p>当 GUI 不可用、网络延迟高、或需要快速修改系统文件时，终端内的文本编辑器就成为最可靠的选择。在 Ubuntu 系统中，vim（Vi IMproved）是最常用且功能强大的终端编辑器之一。虽然学习曲线略陡，但一旦掌握基本操作，效率极高，尤其适合远程服务器环境。</p>\n<p>Ubuntu 通常预装了 vim 的精简版（vim.tiny），建议安装完整版以获得语法高亮、撤销历史等实用功能</p>\n<pre><code class=\"language-bash\">sudo apt update &amp;&amp; sudo apt install vim -y\n</code></pre>\n<p>编辑文件只需一行命令，直接以当前用户（或 sudo 提权后）身份编辑，无权限绕弯，无文件传输延迟：</p>\n<pre><code class=\"language-bash\">vim /path/to/file\n# 例如：\nvim ~/.bashrc\nsudo vim /etc/fstab\n</code></pre>\n<p>Vim 有多种模式，初学者只需记住三个核心状态：</p>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>进入方式</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>普通模式（Normal）</strong></td>\n<td>启动即在此模式，或按 <code>Esc</code></td>\n<td>执行命令（如保存、退出、跳转）</td>\n</tr>\n<tr>\n<td><strong>插入模式（Insert）</strong></td>\n<td>按 <code>i</code></td>\n<td>输入/编辑文本</td>\n</tr>\n<tr>\n<td><strong>命令行模式</strong></td>\n<td>普通模式下按 <code>:</code></td>\n<td>执行保存、退出等指令</td>\n</tr>\n</tbody>\n</table>\n<p>最简操作流程如下：</p>\n<ol>\n<li>打开文件：<code>vim filename</code></li>\n<li>按 <code>i</code> → 进入插入模式 → 编辑内容（很多终端支持复制粘贴）</li>\n<li>按 <code>Esc</code> → 回到普通模式</li>\n<li>输入以下之一：\n<ul>\n<li><code>:wq</code> → 保存并退出</li>\n<li><code>:q!</code> → 不保存强制退出</li>\n<li><code>:x</code> → 有修改则保存退出，无修改则直接退出</li>\n</ul>\n</li>\n</ol>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-03 20:33</span>&nbsp;\n<a href=\"https://www.cnblogs.com/charlee44\">charlee44</a>&nbsp;\n阅读(<span id=\"post_view_count\">23</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}