{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "2026 年 PHP 的三大优势 这门\"老将\"为何依然重要",
      "link": "https://www.cnblogs.com/catchadmin/p/19454737",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19454737\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 08:16\">\n    <span>2026 年 PHP 的三大优势 这门\"老将\"为何依然重要</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"2026-年-php-的三大优势-这门老将为何依然重要\">2026 年 PHP 的三大优势 这门\"老将\"为何依然重要</h1>\n<p>PHP \"快死了\"这句话喊了这么多年，如果真有来世，它的简历应该已经相当可观了。</p>\n<p>你大概见过这些论调：\"PHP 过时了\"、\"现在没人用 PHP 做正经系统了\"、\"只有老项目还在用\"。这些说法也不算全错——确实有大量遗留 PHP 代码在运行。但还有另一个现实很少被提及：PHP 仍然在驱动大量生产环境的后端系统，新的 PHP 项目也在不断出现，因为团队想要的东西和五年、十年前一样：</p>\n<ul>\n<li>可预测的部署流程</li>\n<li>快速迭代</li>\n<li>成熟的生态</li>\n<li>能够经受多人协作、多年维护的可读代码</li>\n</ul>\n<p>我喜欢这类问题，因为它逼你把话说清楚。不是\"我喜欢用\"，不是\"它很流行\"，而是你在生产代码中能实际指出的工程优势。</p>\n<p>下面是我的回答，写给两类读者：</p>\n<ul>\n<li><strong>如果你刚接触后端开发</strong>：你会得到一个清晰的心智模型，理解 PHP 为何仍然适合 Web 系统。</li>\n<li><strong>如果你经验丰富</strong>：你会看到现代 PHP 实践（类型、静态分析、清晰边界、务实的 API 模式）如何把\"PHP 容易上手\"变成\"PHP 可靠\"。</li>\n</ul>\n<p>我会尽量用平实的语言，但不会回避技术细节。真实的系统本来就是技术性的。目标是让这些技术内容变得易懂且实用。</p>\n<p><a href=\"https://catchadmin.com/post/2026-01/php-3-biggest-strengths-2026\" rel=\"noopener nofollow\" target=\"_blank\">原文 2026 年 PHP 的三大优势 这门\"老将\"为何依然重要</a></p>\n<h2 id=\"什么是优势在真实后端工作中的定义\">什么是\"优势\"：在真实后端工作中的定义</h2>\n<p>开发者比较语言时，讨论经常跑偏到性能基准、语法偏好或者互联网文化。但当你在构建 API 或 Web 后端时，\"优势\"通常意味着一些更无聊——也更重要的东西：</p>\n<ul>\n<li>能否快速交付功能而不埋下维护陷阱？</li>\n<li>能否集成数据库、队列和第三方 API 而不从头造轮子？</li>\n<li>能否处理混乱的数据和边缘情况而不把代码变成鬼屋？</li>\n</ul>\n<p>这就是 PHP 最擅长的领域。不是因为它最优雅，而是因为它的形状刚好契合大多数 Web 后端。</p>\n<p>带着这个思路，来看 PHP 在 2026 年的三大优势。</p>\n<h2 id=\"优势一web-原生的生产力php-天然契合-http-世界\">优势一：Web 原生的生产力（PHP 天然契合 HTTP 世界）</h2>\n<p>大多数后端都是 HTTP 机器。这不是比喻，而是日常工作：</p>\n<ul>\n<li>请求进来</li>\n<li>校验并规范化</li>\n<li>调用服务 / 数据库 / 外部 API</li>\n<li>返回 JSON</li>\n<li>记录日志和追踪</li>\n<li>循环</li>\n</ul>\n<p>PHP 的第一个优势是它在这个循环里感觉很自然。你不需要在处理请求之前\"搭建世界\"。PHP 的默认模型就是面向 Web 的，这一点往往被低估了。</p>\n<h3 id=\"经典的-php-执行模型为何仍然有用\">经典的 PHP 执行模型为何仍然有用</h3>\n<p>PHP 传统的请求生命周期很简单：</p>\n<ol>\n<li>开始请求</li>\n<li>运行代码</li>\n<li>返回响应</li>\n<li>结束请求</li>\n</ol>\n<p>然后下一个请求从头开始。</p>\n<p>有人把这当成相对于长驻服务器的劣势，但在实践中它往往是优势：</p>\n<ul>\n<li>内存泄漏不会那么致命，因为进程会回收。</li>\n<li>每个请求天然隔离。</li>\n<li>不太可能意外依赖内存状态。</li>\n<li>调试往往更简单，因为每个请求有清晰的边界。</li>\n</ul>\n<p>你也可以用长驻模式跑 PHP（RoadRunner、Swoole 等），它们在特定场景下确实很好。但经典模型对许多 API 仍然是可靠的默认选择，因为它稳定且对运维友好。</p>\n<h3 id=\"一个纯-php的-api-入口展示基本形态\">一个\"纯 PHP\"的 API 入口（展示基本形态）</h3>\n<p>即使你在生产环境使用 Laravel 或 Symfony（大多数正经应用确实该用），看看 PHP 为何在 Web 工作中高效还是有帮助的。</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\nrequire __DIR__ . '/../vendor/autoload.php';\nheader('Content-Type: application/json; charset=utf-8');\n$method = $_SERVER['REQUEST_METHOD'] ?? 'GET';\n$path = parse_url($_SERVER['REQUEST_URI'] ?? '/', PHP_URL_PATH) ?: '/';\nfunction jsonResponse(array $payload, int $status = 200): void {\n    http_response_code($status);\n    echo json_encode($payload, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);\n    exit;\n}\nfunction readJsonBody(): array {\n    $raw = file_get_contents('php://input') ?: '';\n    $data = json_decode($raw, true);\n    return is_array($data) ? $data : [];\n}\nif ($method === 'GET' &amp;&amp; $path === '/health') {\n    jsonResponse(['ok' =&gt; true, 'time' =&gt; date(DATE_ATOM)]);\n}\nif ($method === 'POST' &amp;&amp; $path === '/users') {\n    $body = readJsonBody();\n    $email = strtolower(trim((string)($body['email'] ?? '')));\n    $name  = trim((string)($body['name'] ?? ''));\n    if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {\n        jsonResponse(['error' =&gt; 'Invalid email'], 422);\n    }\n    if ($name === '') {\n        jsonResponse(['error' =&gt; 'Name is required'], 422);\n    }\n    $id = random_int(1000, 9999);\n    jsonResponse(['id' =&gt; $id, 'email' =&gt; $email, 'name' =&gt; $name], 201);\n}\njsonResponse(['error' =&gt; 'Not found'], 404);\n</code></pre>\n<p>这不是\"最佳实践架构\"，但它演示了核心思想：PHP 的 Web 循环直接且易懂。这就是基础的生产力优势。</p>\n<h3 id=\"快与乱的区别薄-handler真服务\">\"快\"与\"乱\"的区别：薄 handler，真服务</h3>\n<p>PHP 的 Web 生产力要成为长期优势，前提是保持边界清晰。最容易失去这个优势的方式就是把所有东西都塞进控制器。</p>\n<p>一个可扩展的模式：</p>\n<ul>\n<li><strong>Handler / 控制器</strong>：解码请求、调用服务、编码响应</li>\n<li><strong>服务</strong>：业务逻辑 + 编排</li>\n<li><strong>Repository / Client</strong>：存储 + 外部 API 调用</li>\n</ul>\n<p>这是一个与框架无关的小例子：</p>\n<pre><code class=\"language-php\">final class CreateUserHandler\n{\n    public function __construct(\n        private readonly UserService $service\n    ) {}\n    public function __invoke(array $body): array\n    {\n        $input = CreateUserInput::fromArray($body);\n        $user  = $this-&gt;service-&gt;create($input);\n        return UserResource::toArray($user);\n    }\n}\n</code></pre>\n<p>Handler 读起来像一段叙述。这就对了。</p>\n<p>现在服务来做真正的决策：</p>\n<pre><code class=\"language-php\">final class UserService\n{\n    public function __construct(\n        private readonly UserRepository $users\n    ) {}\n    public function create(CreateUserInput $input): User\n    {\n        if ($this-&gt;users-&gt;existsByEmail($input-&gt;email)) {\n            throw new DomainException('Email already registered');\n        }\n        $user = User::register($input-&gt;email, $input-&gt;name);\n        $this-&gt;users-&gt;save($user);\n        return $user;\n    }\n}\n</code></pre>\n<p>这个结构并不花哨，但它能防止代码库在六个月内变成意大利面。</p>\n<h3 id=\"真实世界的-api-工作超时和重试是功能的一部分\">真实世界的 API 工作：超时和重试是功能的一部分</h3>\n<p>PHP 保持实用的一个原因是，做 PHP 后端的团队往往很早就被迫面对 Web 的现实。不是因为 PHP 特殊，而是因为 Web 本身就不宽容。</p>\n<p>如果你调用外部 API 却不设超时、不设重试策略，你就是在埋下未来的事故。</p>\n<p>下面是一个用 Guzzle 写的封装，在生产环境中能正经干活：</p>\n<pre><code class=\"language-php\">use GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\nfinal class ShippingClient\n{\n    private Client $http;\n    public function __construct(string $baseUrl, string $token)\n    {\n        $this-&gt;http = new Client([\n            'base_uri' =&gt; rtrim($baseUrl, '/') . '/',\n            'timeout' =&gt; 3.0,\n            'connect_timeout' =&gt; 1.0,\n            'headers' =&gt; [\n                'Authorization' =&gt; \"Bearer {$token}\",\n                'Accept' =&gt; 'application/json',\n            ],\n        ]);\n    }\n    public function createLabel(array $payload): array\n    {\n        $attempts = 0;\n        while (true) {\n            $attempts++;\n            try {\n                $resp = $this-&gt;http-&gt;post('labels', ['json' =&gt; $payload]);\n                $data = json_decode((string)$resp-&gt;getBody(), true);\n                return is_array($data) ? $data : [];\n            } catch (GuzzleException $e) {\n                if ($attempts &gt;= 3) {\n                    throw new RuntimeException('Shipping API failed after retries', 0, $e);\n                }\n                // small exponential backoff + jitter\n                usleep((int)(100_000 * $attempts) + random_int(0, 50_000));\n            }\n        }\n    }\n}\n</code></pre>\n<p>当互联网本身是你的依赖时，这种代码是必须的——而 PHP 很适应这个场景。</p>\n<p><strong>为什么这是优势一</strong>：PHP 契合 HTTP 工作的形状，让团队能快速构建功能而不用与平台对抗。</p>\n<h2 id=\"优势二生态成熟度composer--框架--标准降低风险\">优势二：生态成熟度（Composer + 框架 + 标准降低风险）</h2>\n<p>PHP 的第二个优势是杠杆。</p>\n<p>很多语言都能做 Web 开发。但能让\"无聊的部分\"以可复用的方式被解决、让团队能招到已经熟悉这些模式的人，这样的成熟生态并不多。</p>\n<p>当你选择 PHP，你选择的不只是语法，还有：</p>\n<ul>\n<li>Composer + Packagist</li>\n<li>Laravel / Symfony（以及其他框架）</li>\n<li>PSR 标准（互操作性）</li>\n<li>稳定的工具链（测试、静态分析、格式化、重构）</li>\n</ul>\n<p>生态的成熟度能降低风险。风险才是真正花钱的地方。</p>\n<h3 id=\"composer让结构化成为常态的安静基石\">Composer：让结构化成为常态的安静基石</h3>\n<p>Composer 不只是依赖管理——它推动你走向模块化的代码库，用自动加载和命名空间。</p>\n<p>一个最小的例子：</p>\n<pre><code class=\"language-json\">{\n  \"require\": {\n    \"php\": \"^8.2\",\n    \"monolog/monolog\": \"^3.0\",\n    \"guzzlehttp/guzzle\": \"^7.0\"\n  },\n  \"autoload\": {\n    \"psr-4\": {\n      \"App\\\\\": \"src/\"\n    }\n  }\n}\n</code></pre>\n<p>一旦你采用 PSR-4 自动加载，你的代码就不再是\"文件\"，而开始变成\"模块\"。这个转变是现代 PHP 比老刻板印象更易维护的重要原因。</p>\n<h3 id=\"框架用无聊的方案解决无聊的问题这正是重点\">框架：用无聊的方案解决无聊的问题（这正是重点）</h3>\n<p>框架可能被过度使用，但\"不用框架\"的做法在应用增长后往往更糟。</p>\n<p>Laravel 和 Symfony 为你不想重新发明的东西提供了可靠的默认方案：</p>\n<ul>\n<li>路由和中间件</li>\n<li>校验和请求处理</li>\n<li>DI 容器模式</li>\n<li>缓存和队列</li>\n<li>数据库迁移</li>\n<li>结构化的错误处理</li>\n</ul>\n<p>大多数生产事故不是来自精妙的业务逻辑，而是来自胶水代码：超时、重试、不一致的校验、部分失败、意外的 payload、不一致的错误响应。</p>\n<p>框架默认方案减少这些事故，因为你建立在已经经历过成千上万个生产系统考验的模式之上。</p>\n<h3 id=\"psr-标准让你的代码不再被锁死\">PSR 标准：让你的代码不再被锁死</h3>\n<p>标准在你集成库或者超出最初决策时最为重要。</p>\n<p>例如：PSR-3 日志。</p>\n<pre><code class=\"language-php\">use Psr\\Log\\LoggerInterface;\nfinal class BillingService\n{\n    public function __construct(private readonly LoggerInterface $logger) {}\n    public function charge(int $userId, int $amountCents): void\n    {\n        $this-&gt;logger-&gt;info('Charge request', [\n            'userId' =&gt; $userId,\n            'amountCents' =&gt; $amountCents,\n        ]);\n        // ...\n    }\n}\n</code></pre>\n<p>这个类不在乎你今天用 Monolog 还是明天换成别的日志库。这种解耦才能让系统演进。</p>\n<h3 id=\"工具链和-2015-年相比现代-php-像换了一门语言\">工具链：和 2015 年相比，现代 PHP 像换了一门语言</h3>\n<p>很多\"PHP 黑\"来自于对老代码库的体验：弱类型、不一致的模式、\"先上线再说\"的文化。</p>\n<p>现代 PHP 团队通常会用一套简单的质量工具链：</p>\n<ul>\n<li>严格类型</li>\n<li>静态分析（PHPStan / Psalm）</li>\n<li>测试（PHPUnit / Pest）</li>\n<li>格式化（PHP-CS-Fixer）</li>\n<li>自动重构（Rector）</li>\n</ul>\n<p>这套组合会改变你写代码的方式。目标不是完美，而是尽早暴露问题，让代码在迭代中保持可读。</p>\n<p>下面是一个小例子，静态分析帮你避免一个运行时 bug：</p>\n<pre><code class=\"language-php\">final class UserRepository\n{\n    public function findByEmail(string $email): User\n    {\n        // DB lookup...\n        return null; // bug\n    }\n}\n</code></pre>\n<p>配置好静态分析后，这会立即被标记出来。</p>\n<p>PHP 的测试也不必很重。一个聚焦的测试可以读起来像文档：</p>\n<pre><code class=\"language-php\">final class MoneyTest extends TestCase\n{\n    public function testItAddsMoneyInSameCurrency(): void\n    {\n        $a = Money::usd(1000);\n        $b = Money::usd(250);\n        $sum = $a-&gt;add($b);\n        $this-&gt;assertSame(1250, $sum-&gt;cents());\n        $this-&gt;assertSame('USD', $sum-&gt;currency());\n    }\n}\n</code></pre>\n<p><strong>为什么这是优势二</strong>：PHP 的生态让你能快速交付并安全构建，因为工具链和惯例都已成熟。</p>\n<h2 id=\"优势三务实的数据管道php-擅长乱进干净出\">优势三：务实的数据管道（PHP 擅长\"乱进、干净出\"）</h2>\n<p>如果你做过一段时间后端，你就知道真相：这份工作就是数据转换。</p>\n<p>请求进来格式奇怪。数据库行取出来格式奇怪。外部 API 返回的是\"差不多是你期望的\"。Webhook 在不方便的时候重试。边缘情况在周五发生。</p>\n<p>PHP 在这类工作上特别强，因为它在两种模式下都很自如：</p>\n<ul>\n<li>快速操作（字符串、数组、JSON）</li>\n<li>结构化代码（DTO、值对象、枚举、readonly 属性）</li>\n</ul>\n<p>为了说明我的意思，来构建一个现实的管道：处理来自支付提供商的 webhook。</p>\n<p>这是一个很好的测试，因为它结合了：</p>\n<ul>\n<li>安全验证</li>\n<li>幂等性（重试）</li>\n<li>载荷规范化</li>\n<li>状态变更</li>\n<li>优雅处理未知事件类型</li>\n</ul>\n<h3 id=\"步骤一保持载荷边界显式化dto-优于原始数组\">步骤一：保持载荷边界显式化（DTO 优于原始数组）</h3>\n<p>数组在边界处没问题，但在整个应用中传递原始数组会变得痛苦。所以：尽早解析，尽早结构化。</p>\n<pre><code class=\"language-php\">final class WebhookEvent\n{\n    public function __construct(\n        public readonly string $id,\n        public readonly string $type,\n        public readonly int $createdAtEpoch,\n        public readonly array $data\n    ) {}\n    public static function fromArray(array $payload): self\n    {\n        return new self(\n            id: (string)($payload['id'] ?? ''),\n            type: (string)($payload['type'] ?? ''),\n            createdAtEpoch: (int)($payload['created_at'] ?? 0),\n            data: is_array($payload['data'] ?? null) ? $payload['data'] : []\n        );\n    }\n}\n</code></pre>\n<p>这是务实的做法：我们依赖的字段用强类型，原始数据留着灵活性，新字段加进来也不会炸。</p>\n<h3 id=\"步骤二验证签名不要信任-json\">步骤二：验证签名（不要\"信任 JSON\"）</h3>\n<pre><code class=\"language-php\">final class WebhookSignatureVerifier\n{\n    public function __construct(private readonly string $secret) {}\n    public function verify(string $rawBody, string $signatureHeader): bool\n    {\n        $expected = hash_hmac('sha256', $rawBody, $this-&gt;secret);\n        return hash_equals($expected, $signatureHeader);\n    }\n}\n</code></pre>\n<p>这里 <code>hash_equals</code> 很重要，用于避免时序攻击。这是个小细节，但这类习惯正是区分业余代码和生产代码的地方。</p>\n<h3 id=\"步骤三幂等性因为-webhook-会重试\">步骤三：幂等性（因为 webhook 会重试）</h3>\n<p>如果你处理同一个事件两次，你可能会：</p>\n<ul>\n<li>重复更新订阅</li>\n<li>重复发送邮件</li>\n<li>重复给账户加款</li>\n</ul>\n<p>所以要存储已处理的事件 ID。</p>\n<pre><code class=\"language-php\">final class WebhookIdempotencyStore\n{\n    public function __construct(private readonly PDO $pdo) {}\n    public function hasProcessed(string $eventId): bool\n    {\n        $stmt = $this-&gt;pdo-&gt;prepare(\"SELECT 1 FROM processed_webhooks WHERE event_id = :id\");\n        $stmt-&gt;execute([':id' =&gt; $eventId]);\n        return (bool)$stmt-&gt;fetchColumn();\n    }\n    public function markProcessed(string $eventId): void\n    {\n        $stmt = $this-&gt;pdo-&gt;prepare(\n            \"INSERT INTO processed_webhooks (event_id, processed_at)\n             VALUES (:id, NOW())\"\n        );\n        $stmt-&gt;execute([':id' =&gt; $eventId]);\n    }\n}\n</code></pre>\n<h3 id=\"步骤四干净地映射事件类型枚举很有帮助\">步骤四：干净地映射事件类型（枚举很有帮助）</h3>\n<pre><code class=\"language-php\">enum PaymentEventType: string\n{\n    case PaymentSucceeded = 'payment.succeeded';\n    case PaymentFailed = 'payment.failed';\n}\n</code></pre>\n<h3 id=\"步骤五用事务型-handler-把它们组合起来\">步骤五：用事务型 handler 把它们组合起来</h3>\n<pre><code class=\"language-php\">final class PaymentWebhookHandler\n{\n    public function __construct(\n        private readonly WebhookSignatureVerifier $verifier,\n        private readonly WebhookIdempotencyStore $idem,\n        private readonly PaymentService $payments,\n        private readonly PDO $pdo\n    ) {}\n    public function handle(string $rawBody, string $signatureHeader): void\n    {\n        if (!$this-&gt;verifier-&gt;verify($rawBody, $signatureHeader)) {\n            throw new RuntimeException('Invalid webhook signature');\n        }\n        $payload = json_decode($rawBody, true);\n        if (!is_array($payload)) {\n            throw new RuntimeException('Invalid JSON');\n        }\n        $event = WebhookEvent::fromArray($payload);\n        if ($event-&gt;id === '' || $event-&gt;type === '') {\n            throw new RuntimeException('Missing event fields');\n        }\n        if ($this-&gt;idem-&gt;hasProcessed($event-&gt;id)) {\n            return; // safe no-op\n        }\n        $this-&gt;pdo-&gt;beginTransaction();\n        try {\n            $this-&gt;dispatch($event);\n            $this-&gt;idem-&gt;markProcessed($event-&gt;id);\n            $this-&gt;pdo-&gt;commit();\n        } catch (Throwable $e) {\n            $this-&gt;pdo-&gt;rollBack();\n            throw $e;\n        }\n    }\n    private function dispatch(WebhookEvent $event): void\n    {\n        $type = PaymentEventType::tryFrom($event-&gt;type);\n        if ($type === null) {\n            // unknown event type: ignore or log\n            return;\n        }\n        $paymentId = (string)($event-&gt;data['payment_id'] ?? '');\n        if ($paymentId === '') return;\n        match ($type) {\n            PaymentEventType::PaymentSucceeded =&gt; $this-&gt;payments-&gt;markSucceeded($paymentId),\n            PaymentEventType::PaymentFailed    =&gt; $this-&gt;payments-&gt;markFailed($paymentId),\n        };\n    }\n}\n</code></pre>\n<p>这是一个干净的管道：</p>\n<ol>\n<li>验证真实性</li>\n<li>解析载荷</li>\n<li>规范化为 DTO</li>\n<li>强制幂等性</li>\n<li>事务</li>\n<li>分发领域动作</li>\n<li>容忍未知事件</li>\n</ol>\n<p>这就是 PHP 擅长的\"Web 现实\"代码：处理那些真正重要的脏活，同时保持可读。</p>\n<p><strong>为什么这是优势三</strong>：大多数后端都是数据管道，而 PHP 在真实世界约束下构建可理解的管道方面很强。</p>\n<h2 id=\"额外内容游标分页的实践深入因为它把三个优势串在一起\">额外内容：游标分页的实践深入（因为它把三个优势串在一起）</h2>\n<p>分页是那种看起来简单、等用户翻到深页才暴露问题的功能。它也是个好例子，能说明 PHP 为何还没过时：它同时涉及 HTTP、SQL 性能和响应设计。</p>\n<h3 id=\"为什么-offset-会伤害你\">为什么 OFFSET 会伤害你</h3>\n<p>Offset 分页（<code>LIMIT 20 OFFSET 100000</code>）迫使数据库扫描并丢弃大量行。在大表上，深页会变慢。</p>\n<p>它在并发写入时也可能不一致：插入/删除可能导致\"窗口\"移动时出现跳过或重复。</p>\n<p>游标分页（keyset/seek）通过使用稳定的排序和代表\"你上次停在哪里\"的游标来避免这些问题。</p>\n<h3 id=\"规则一游标逻辑必须匹配排序方向\">规则一：游标逻辑必须匹配排序方向</h3>\n<p>如果你按最新优先排序：</p>\n<pre><code class=\"language-sql\">ORDER BY created_at DESC, id DESC\n</code></pre>\n<ul>\n<li>下一页应该获取\"更早\"的行</li>\n<li>所以条件用 <code>&lt;</code></li>\n</ul>\n<p>如果你的数据库支持元组比较：</p>\n<pre><code class=\"language-sql\">SELECT id, created_at, total_cents\nFROM orders\nWHERE (created_at, id) &lt; (?, ?)\nORDER BY created_at DESC, id DESC\nLIMIT ?\n</code></pre>\n<p>如果不支持，用显式逻辑：</p>\n<pre><code class=\"language-sql\">SELECT id, created_at, total_cents\nFROM orders\nWHERE created_at &lt; ?\n   OR (created_at = ? AND id &lt; ?)\nORDER BY created_at DESC, id DESC\nLIMIT ?\n</code></pre>\n<h3 id=\"规则二游标应该是不透明的且防篡改\">规则二：游标应该是不透明的且防篡改</h3>\n<p>游标通常是一个类似 <code>(created_at, id)</code> 的对，序列化给客户端。Base64 编码在传输时没问题——但不是安全措施。如果你想防止客户端伪造游标，就签名它。</p>\n<pre><code class=\"language-php\">final class Cursor\n{\n    public function __construct(\n        public readonly string $createdAtIso,\n        public readonly int $id\n    ) {}\n}\nfinal class CursorCodec\n{\n    public function __construct(private readonly string $secret) {}\n    public function encode(Cursor $cursor): string\n    {\n        $json = json_encode([\n            'created_at' =&gt; $cursor-&gt;createdAtIso,\n            'id' =&gt; $cursor-&gt;id\n        ], JSON_UNESCAPED_SLASHES);\n        $b64 = rtrim(strtr(base64_encode($json), '+/', '-_'), '=');\n        $sig = hash_hmac('sha256', $b64, $this-&gt;secret);\n        return $b64 . '.' . $sig;\n    }\n    public function decode(string $token): Cursor\n    {\n        $parts = explode('.', $token, 2);\n        if (count($parts) !== 2) {\n            throw new InvalidArgumentException('Invalid cursor');\n        }\n        [$b64, $sig] = $parts;\n        $expected = hash_hmac('sha256', $b64, $this-&gt;secret);\n        if (!hash_equals($expected, $sig)) {\n            throw new InvalidArgumentException('Cursor signature mismatch');\n        }\n        $json = base64_decode(strtr($b64, '-_', '+/'), true);\n        if ($json === false) {\n            throw new InvalidArgumentException('Invalid cursor encoding');\n        }\n        $data = json_decode($json, true);\n        if (!is_array($data)) {\n            throw new InvalidArgumentException('Invalid cursor payload');\n        }\n        return new Cursor(\n            createdAtIso: (string)($data['created_at'] ?? ''),\n            id: (int)($data['id'] ?? 0)\n        );\n    }\n}\n</code></pre>\n<h3 id=\"repository-方法返回条目--下一个游标\">Repository 方法：返回条目 + 下一个游标</h3>\n<pre><code class=\"language-php\">final class OrderRepository\n{\n    public function __construct(private readonly PDO $pdo) {}\n    /**\n     * @return array{items: list&lt;array&gt;, next: ?Cursor}\n     */\n    public function listPage(?Cursor $after, int $limit): array\n    {\n        $limit = max(1, min($limit, 100));\n        if ($after === null) {\n            $sql = \"SELECT id, created_at, total_cents\n                    FROM orders\n                    ORDER BY created_at DESC, id DESC\n                    LIMIT :limit\";\n            $stmt = $this-&gt;pdo-&gt;prepare($sql);\n            $stmt-&gt;bindValue(':limit', $limit, PDO::PARAM_INT);\n        } else {\n            $sql = \"SELECT id, created_at, total_cents\n                    FROM orders\n                    WHERE created_at &lt; :created_at\n                       OR (created_at = :created_at AND id &lt; :id)\n                    ORDER BY created_at DESC, id DESC\n                    LIMIT :limit\";\n            $stmt = $this-&gt;pdo-&gt;prepare($sql);\n            $stmt-&gt;bindValue(':created_at', $after-&gt;createdAtIso);\n            $stmt-&gt;bindValue(':id', $after-&gt;id, PDO::PARAM_INT);\n            $stmt-&gt;bindValue(':limit', $limit, PDO::PARAM_INT);\n        }\n        $stmt-&gt;execute();\n        $rows = $stmt-&gt;fetchAll(PDO::FETCH_ASSOC);\n        $items = array_map(fn($r) =&gt; [\n            'id' =&gt; (int)$r['id'],\n            'created_at' =&gt; (string)$r['created_at'],\n            'total_cents' =&gt; (int)$r['total_cents'],\n        ], $rows);\n        $next = null;\n        if ($items !== []) {\n            $last = $items[count($items) - 1];\n            $next = new Cursor($last['created_at'], $last['id']);\n        }\n        return ['items' =&gt; $items, 'next' =&gt; $next];\n    }\n}\n</code></pre>\n<p>现在你的 handler 可以解码 <code>after</code>、获取结果、编码 <code>next_cursor</code>——一个横跨 HTTP + SQL + JSON 响应的干净端到端管道。</p>\n<p>这就是实践中的最佳平衡点：PHP 的 Web 原生特性、生态工具和数据处理能力在这里汇合。</p>\n<h2 id=\"php-不是最佳默认选择的场景以及好团队怎么做\">PHP 不是最佳默认选择的场景（以及好团队怎么做）</h2>\n<p>PHP 不是万能的最佳工具：</p>\n<ul>\n<li>CPU 密集型工作负载（视频处理、大规模数值计算）</li>\n<li>将极高并发的 socket 服务器作为默认架构</li>\n<li>要求前后端用同一门语言共享严格类型的组织</li>\n</ul>\n<p>但大多数成功的团队不会把这当成重写一切的理由。他们做的是 Web 一直鼓励的事：组合系统。</p>\n<ul>\n<li>在 PHP 强的地方保留 API 表面。</li>\n<li>把重计算卸载给 worker 或专门的服务。</li>\n<li>用队列处理后台任务。</li>\n<li>在怪罪语言之前先优化数据库查询和缓存。</li>\n</ul>\n<p>这不是什么\"PHP 用户的自我安慰\"，这就是正常的系统设计。</p>\n<h2 id=\"结论\">结论</h2>\n<p>回到最初的问题——PHP 的三大优势：</p>\n<ul>\n<li><strong>Web 原生的生产力</strong>：PHP 天然契合 HTTP 工作，保持构建循环快速。</li>\n<li><strong>生态成熟度</strong>：Composer + 框架 + 标准 + 工具链给你杠杆并降低风险。</li>\n<li><strong>务实的数据管道</strong>：PHP 擅长把混乱的真实世界数据转换成干净、稳定的输出——同时不让代码变得不可读。</li>\n</ul>\n<p>如果你想让 PHP 感觉现代（而不是像那些刻板印象），方法始终如一：</p>\n<ul>\n<li>保持 handler/控制器薄</li>\n<li>用 DTO/值对象建模边界</li>\n<li>把超时、重试和幂等性当作一等功能</li>\n<li>按读取方式建索引（尤其是分页）</li>\n<li>用测试 + 静态分析保护重构</li>\n</ul>\n<p>PHP 不需要追热点。它只要继续做它擅长的事就够了：跑那些实用、好维护、能稳定上线的 Web 系统。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 08:16</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">211</span>)&nbsp;\n评论(<span id=\"post_comment_count\">3</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一文学习和实践 当下互联网安全的基石  -  TLS 和 SSL",
      "link": "https://www.cnblogs.com/dddy/p/19453911",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/dddy/p/19453911\" id=\"cb_post_title_url\" title=\"发布于 2026-01-07 21:18\">\n    <span>一文学习和实践 当下互联网安全的基石  -  TLS 和 SSL</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>[[N_OSI 模型.TCP 协议.封包]]<br />\n[[Java TLS Socket]]</p>\n<h1 id=\"what-is-ssltls-\">What is SSL/TLS ?</h1>\n<p>TLS（Transport Layer Security）即传输层安全协议，SSL（Secure Sockets Layer）即安全套接层协议。它们都是用于在网络通信中保障数据安全和隐私的加密协议。</p>\n<p>[[TLS&amp;SSL协议]]</p>\n<h2 id=\"tlstransport-layer-security传输层安全协议\">TLS（Transport Layer Security）传输层安全协议</h2>\n<ol>\n<li><strong>发展历程</strong></li>\n</ol>\n<ul>\n<li>TLS 是 SSL 协议的继任者。由于 SSL 协议存在一些安全漏洞，并且随着网络安全需求的不断提高，IETF（Internet Engineering Task Force）对 SSL 3.0 进行了改进，推出了 TLS 1.0 协议，于 1999 年发布。TLS 协议在后续又不断更新版本，如 TLS 1.1、TLS 1.2 和 TLS 1.3，每一个新版本都在安全性和性能等方面有所提升。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>工作原理</strong></li>\n</ol>\n<ul>\n<li>TLS 的工作原理与 SSL 类似，也包括握手阶段。在 TLS 握手过程中，客户端和服务器会协商协议版本、加密算法套件、交换密钥等。TLS 1.3 相比之前的版本，简化了握手过程，减少了握手消息的往返次数，从而提高了连接建立的速度，并且增强了安全性，如加强了密钥交换的安全性。</li>\n<li>例如，TLS 1.3 使用了更安全的密钥交换算法，如基于椭圆曲线的 Diffie - Hellman 密钥交换（ECDHE），这种算法能够有效抵抗中间人攻击等安全威胁。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>应用场景</strong></li>\n</ol>\n<ul>\n<li>TLS 的应用范围非常广泛。它不仅用于 Web 安全，还用于电子邮件安全（如 IMAP、POP3 和 SMTP 协议的安全版本）、虚拟专用网络（VPN）等众多网络通信场景。在现代互联网中，几乎所有需要安全通信的地方都会优先考虑使用 TLS 协议。</li>\n</ul>\n<h2 id=\"ssl-secure-sockets-layer安全套接层协议\">SSL （Secure Sockets Layer）安全套接层协议</h2>\n<ol>\n<li><strong>发展历程</strong></li>\n</ol>\n<ul>\n<li>SSL 最初是由网景公司（Netscape）在 1994 年开发的，目的是为了保障网络通信的安全，特别是在 Web 浏览器和服务器之间的通信安全。SSL 1.0 由于存在安全漏洞从未发布，SSL 2.0 在 1995 年发布，但也有安全问题。SSL 3.0 于 1996 年发布，它修复了许多 SSL 2.0 的问题，成为当时比较流行的安全协议。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>工作原理</strong></li>\n</ol>\n<ul>\n<li>SSL 协议在应用层和传输层之间工作。它通过使用公钥和私钥加密技术来保证通信的保密性。当客户端（如浏览器）与服务器建立连接时，首先会进行 SSL 握手过程。</li>\n<li>在握手阶段，客户端向服务器发送客户端支持的加密算法列表等信息。服务器从列表中选择一种加密算法，并将服务器的证书发送给客户端。客户端验证服务器证书的合法性，例如检查证书是否由可信任的证书颁发机构（CA）颁发，证书是否过期等。</li>\n<li>如果证书验证通过，客户端和服务器就会协商出一个对称加密密钥。之后的数据传输就使用这个对称密钥进行加密，这样可以保证数据在传输过程中的保密性，因为只有客户端和服务器知道这个对称密钥。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>应用场景</strong></li>\n</ol>\n<ul>\n<li>SSL 主要应用于 Web 安全。例如，在早期的 https（Hypertext Transfer Protocol Secure）网站访问中，就是通过 SSL 协议来加密浏览器和服务器之间的数据传输。这使得用户在网站上输入的敏感信息，如登录密码、信用卡信息等在传输过程中不会被窃取。</li>\n</ul>\n<h2 id=\"两者关系和区别\">两者关系和区别</h2>\n<ol>\n<li><strong>关系</strong></li>\n</ol>\n<ul>\n<li>TLS 可以看作是 SSL 的升级版。TLS 协议在设计上借鉴了 SSL 协议的很多理念，并且在 SSL 的基础上进行了改进和扩展，以应对不断出现的新的安全威胁和网络通信需求。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>区别</strong></li>\n</ol>\n<ul>\n<li><strong>安全性</strong>：TLS 在安全性能上比 SSL 更优越。例如，SSL 3.0 存在 POODLE（Padding Oracle On Downgraded Legacy Encryption）攻击漏洞，而 TLS 协议通过不断更新版本来修复类似的安全漏洞。TLS 1.3 更是在密钥交换等关键环节采用了更先进的加密技术，提供了更强的安全性。</li>\n<li><strong>兼容性</strong>：SSL 是比较早期的协议，在一些旧的系统和软件中有应用。但随着网络安全标准的提高，现代的应用和系统更倾向于使用 TLS 协议。TLS 在兼容性方面也在不断扩展，能够更好地与各种新的网络技术和应用场景相结合。</li>\n</ul>\n<blockquote>\n<p>目前常用的是 TLS 1.2 和 TLS 1.3;  SSL不多见了</p>\n</blockquote>\n<h2 id=\"https-工作流程\">HTTPS 工作流程</h2>\n<ol>\n<li>Client 发起请求（端口443）</li>\n<li>Server 返回公钥证书</li>\n<li>Client 验证证书</li>\n<li>Client 生成对称密钥，用公钥加密后发给Server</li>\n<li>Server使用私钥解密，得到对称密钥</li>\n<li>C/S双方使用对称密钥：\n<ul>\n<li>加密明文并发送</li>\n<li>解密密文得到明文</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"for-tls-12\">For TLS 1.2</h3>\n<p><img alt=\"Pasted image 20241218204449\" class=\"lazyload\" /><br />\n<img alt=\"Pasted image 20241218211322\" class=\"lazyload\" /></p>\n<h3 id=\"for-tls-13\">For TLS 1.3</h3>\n<p><img alt=\"Pasted image 20241218204507\" class=\"lazyload\" /></p>\n<p><img alt=\"Pasted image 20241218203919\" class=\"lazyload\" /></p>\n<h1 id=\"tls\">TLS</h1>\n<p><img alt=\"Pasted image 20231116112623\" class=\"lazyload\" /></p>\n<h2 id=\"证书签名与验证\">证书签名与验证</h2>\n<p>颁发证书的过程</p>\n<ol>\n<li>撰写<strong>证书元数据</strong>: 包括 <code>签发人(Issuer)</code>, 地址, 签发时间, 有效期 等, 还包括<code>证书持有者(Owner)</code>基本信息, 比如 DN(DNS Name, 即证书生效的域名), <strong>Owner 公钥</strong> 等信息</li>\n<li>使用通用的 Hash 算法（如SHA-256）对证书元数据计算生成<strong>数字摘要</strong></li>\n<li>使用 <strong>签发人 Issuer (CA)的私钥</strong>  对该<strong>数字摘要</strong>进行加密, 生成一个<strong>加密的数字摘要</strong>, 也就是<strong>Issuer的数字签名</strong></li>\n<li>将<strong>数字签名</strong>附加到数字证书上, 变成一个<strong>签过名的数字证书</strong><br />\n将<strong>签过名的数字证书</strong>与 <strong>Issuer (CA)的公钥</strong>, 一同发给证书使用者（注意, 将公钥主动发给使用者是一个形象的说法, 通常系统或者浏览器都内置 Issuer (CA)的公钥 为可信任的根证书）</li>\n</ol>\n<blockquote>\n<p>所以 CA的私钥是绝对不能被泄露, 它作为互联网被信任的基础</p>\n</blockquote>\n<h2 id=\"验证证书的过程\">验证证书的过程</h2>\n<ol>\n<li>证书使用者获通过某种途径（如浏览器访问）获取到该数字证书, 解压后分别获得<strong>证书元数据</strong> 和<strong>数字签名</strong>,<strong>(Owner)的公钥</strong>等</li>\n<li>使用同样的Hash算法计算证书元数据的<strong>数字摘要</strong></li>\n<li>使用 <strong>签发人 Issuer (CA)的公钥</strong> 对数字签名进行解密, 得到 解密后的数字摘要</li>\n</ol>\n<p>从第1步获得的数字摘要值,  再对比 2 和 3 两个步骤得到的数字摘要值; 如果相同, 则说明这个数字证书确实是被 签发人Issuer 验证过合法证书, 证书中的信息</p>\n<blockquote>\n<p>最主要的是确定 Owner 的公钥是可信的, 此后通信 信任使用该公钥解密对方私钥加密的数据</p>\n</blockquote>\n<p><strong>in short 握手时服务端需要提供自己的公钥 和被 ca签发过的数字摘要;  关键在与客户端需要一个可信任 Issuer(CA)</strong></p>\n<h3 id=\"证书链\">证书链</h3>\n<p>在 chrome 证书信息-&gt; 证书路径,  可以看到证书的签发链.</p>\n<p>例, 百度的网站:</p>\n<p><code>GlobalSign Root CA -&gt; GlobalSign Organization Validation CA -&gt; baidu.com</code><br />\n<img alt=\"Pasted image 20231116113047\" class=\"lazyload\" /></p>\n<p>这个路径可以抽象为三个级别:</p>\n<p><code>end-user</code>: 即 baidu.com, 该证书包含百度的公钥, 访问者就是使用该公钥将数据加密后再传输给百度, 即在 HTTPS 中使用的证书</p>\n<p><code>intermediates</code>: 即上文提到的 签发人 Issuer, 用来认证公钥持有者身份的证书, 负责确认 HTTPS 使用的 end-user 证书确实是来源于百度; 这类 intermediates 证书可以有很多级, 也就是说 签发人 Issuer 可能会有有很多级</p>\n<p><code>root</code>: 可以理解为<strong>最高级别的签发人 Issuer, 负责认证<code> intermediates 身份的</code>合法性</strong></p>\n<p><strong>in short 其实就是一个可信任的链条, 最终的目的就是为了保证 end-user 证书是可信的, 该证书的公钥也就是可信的.</strong></p>\n<blockquote>\n<p>参考: <a href=\"https://www.jianshu.com/p/fcd0572c4765\" rel=\"noopener nofollow\" target=\"_blank\">关于证书链的一点认知</a></p>\n</blockquote>\n<h2 id=\"tls-握手步骤\">TLS 握手步骤</h2>\n<p>(0) Client 与 <code>Server</code> 之间建立 (TCP 三次握手) 连接</p>\n<p>(1) Client 向 <code>Server</code> 发送 \"client hello\" 消息, 里面包含了安全相关的信息, 例如<strong>SSL/TLS 版本号</strong>, Client 支持的加密套件 (CipherSuite); \"client hello\" 消息<strong>还包含了一个随机数client random</strong>, 用于通信密钥的计算;<br />\n(可选)SSL/TLS 协议还允许 \"client hello\" 消息包含 Client 所支持的压缩算法</p>\n<p>(2) <code>Server</code> 回复一条 \"server hello\" 消息, 里面包含了加密套件<strong>(Server 从 \"client hello\" 消息的 CipherSuites 列表中选择其中一个)</strong>,<strong>session id</strong> 和 另一个随机数<strong>server random</strong>; Server 还会在消息中<strong>附带自己的数字证书</strong>;</p>\n<p>(可选)<strong>如果 Server 需要 Client 的数字证书进行客户端认证</strong>, 会向 Client 发送 \"client certificate request\" 请求消息, 里面包含了<strong>Server 所支持的证书类型</strong>和<strong>认可的证书颁发机构 CA</strong> (<strong>双向认证</strong>, 同认证客户端同理)</p>\n<p>(3) Client 收到 \"server hello\",<strong>验证 Server 端的数字证书</strong>, 并得到证书中<strong>Server 端的公钥</strong><br />\n<strong>(关键这里客户端有可信任的证书签发者<code>Issuer</code>, 验证服务端的证书)</strong></p>\n<p>(4) Client 向 <code>Server</code> 发送<strong>第三个随机数 pre-master secret</strong>; 与之前不同,<strong>这次的随机数使用了 Server 的公钥加密</strong> (非对称加密); 现在双方同时拥有这三个随机数client random,server random,premaster secret, 可以用来计算生成共同的通信密钥 master secret 用于加密后面传输的业务数据;</p>\n<p>(5 - 可选) 如果收到 <code>Server</code> 端发来的 \"client certificate request\" 请求消息, Client 会向 Server 发送一个使用 Client 自己的私钥加密过的随机数 (暂时记作 secret-A), 附带 Client 的数字证书; 或者发送一个 \"no digital certificate alert\" 无证书警告, 这种情况下基本可以认为 SSL/TLS 握手失败;</p>\n<p>(6 - 可选) <code>Server</code> 验证 Client 发送过来的数字证书, 并得到证书中公钥对 Client 进行身份认证 (通过公钥解密上面那个 secret-A);</p>\n<p>(7) Client 向 <code>Server</code> 发送 \"finished\" 消息, 使用<strong>第 4 步中计算出来的密钥进行加密传输 (对称加密)</strong>, 这表示 Client 端握手阶段已经完成;</p>\n<p>(8) <code>Server</code> 也向 Client 发送 \"finished\" 消息, 使用<strong>第 4 步中计算出来的密钥进行加密传输 (对称加密)</strong>, 这表示 Server 端握手阶段完成;</p>\n<p>(9) SSL/TLS 握手阶段完成, 接下来双方通信的消息都会使用协商出来的密钥进行加密 (对称加密)<br />\nContent Type: Handshake (22)</p>\n<p><img alt=\"SLLhandshanke\" class=\"lazyload\" /></p>\n<p><a href=\"https://www.cnblogs.com/piyeyong/archive/2010/07/02/1770208.html\" target=\"_blank\">证书的应用之一 —— TCP&amp;SSL通信实例及协议分析(中)</a></p>\n<p>每一条消息都会包含有ContentType,Version,HandshakeType等信息;</p>\n<p>ContentType 指示SSL通信处于哪个阶段, 是握手(Handshake), 开始加密传输(ChangeCipherSpec)还是正常通信(Application)等, 见下表</p>\n<p>Hex\tDec\tType<br />\n0x14\t20\tChangeCipherSpec<br />\n0x15\t21\tAlert<br />\n0x16\t22\tHandshake<br />\n0x17\t23\tApplication</p>\n<p>Handshake Type是在handshanke阶段中的具体哪一步, 见下表\t<br />\nCode\tDescription<br />\n0\tHelloRequest<br />\n1\tClientHello<br />\n2\tServerHello<br />\n11\tCertificate<br />\n12\tServerKeyExchange<br />\n13\tCertificateRequest<br />\n14\tServerHelloDone<br />\n15\tCertificateVerify<br />\n16\tClientKeyExchange<br />\n20\tFinished</p>\n<h3 id=\"关于双向认证\">关于双向认证</h3>\n<p>所有通信中，涉及两个端点，即浏览器和它所连接的网站（即客户端和服务器）。 在单向SSL身份认证过程中，仅验证一个端点（服务器）的身份。<br />\n双向认证是指在SSL握手过程中将同时验证客户端和服务器的身份，所以双向认证SSL证书至少包括两个或两个以上的证书，一个是服务器证书，另一个或多个是客户端证书（即个人认证证书）。</p>\n<h1 id=\"主流的证书格式\">主流的证书格式</h1>\n<p><strong>主流的SSL证书格式:</strong><br />\nDER、CER，文件是二进制格式，只保存证书，不保存私钥。</p>\n<p>PEM，一般是文本格式，可保存证书，可保存私钥。<br />\nPrivacy Enhanced Mail，一般为文本格式，以 -----BEGIN... 开头，以 -----END... 结尾。中间的内容是 BASE64 编码。这种格式可以保存证书和私钥，有时我们也把PEM 格式的私钥的后缀改为 .key 以区别证书与私钥</p>\n<p>CRT，可以是二进制格式，可以是文本格式，与 DER 格式相同，不保存私钥。<br />\nPFX P12，二进制格式，同时包含证书和私钥，一般有密码保护。<br />\nJKS，二进制格式，同时包含证书和私钥，一般有密码保护。</p>\n<p><strong>各服务器平台使用的证书格式:</strong><br />\nNginx：pem<br />\nApache：pem<br />\nIIS：pfx/pkcs12<br />\nTomcat：jks</p>\n<h1 id=\"netty-for-tls-实例\">Netty For TLS 实例</h1>\n<h2 id=\"证书生成\">证书生成</h2>\n<h3 id=\"ca-根证书生成\">CA 根证书生成</h3>\n<p>或者称为 Issuer , 它可以签发证书, 作为客户端和服务端共同信任者</p>\n<ol>\n<li><strong>创建一个私钥</strong><br />\n生成一个安全的私钥。这个私钥将用于签署根证书以及将来由该根CA签发的所有其他证书。为了确保安全性，使用足够长的密钥长度。</li>\n</ol>\n<pre><code class=\"language-sh\">openssl genpkey -algorithm RSA -out root_ca.key -aes256 -pkeyopt rsa_keygen_bits:4096\n# 不加密\n# openssl genpkey -algorithm RSA -out root_ca.key -pkeyopt rsa_keygen_bits:2048\n</code></pre>\n<blockquote>\n<p>输入私钥密码</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>创建自签名的根证书</strong><br />\n使用刚刚生成的私钥来创建一个自签名的根证书。这一步骤不仅会生成证书本身，还会收集有关颁发者的详细信息，这些信息将嵌入到证书中。</li>\n</ol>\n<pre><code class=\"language-sh\">openssl req -x509 -new -nodes -key root_ca.key -sha256 -days 36500 -out root_ca.crt\n</code></pre>\n<ul>\n<li><code>req</code>&nbsp;是用来处理证书请求的命令。</li>\n<li><code>-x509</code>&nbsp;表示要创建一个X.509格式的自签名证书。</li>\n<li><code>-new</code>&nbsp;表示这是一个新的证书请求。</li>\n<li><code>-nodes</code>&nbsp;表示不加密私钥（仅适用于这次命令，因为私钥已经加密）。</li>\n<li><code>-key root_ca.key</code>&nbsp;指定了用于签名的私钥。</li>\n<li><code>-sha256</code>&nbsp;指定了哈希算法。</li>\n<li><code>-days 3650</code>&nbsp;指定了证书的有效期为10年。</li>\n<li><code>-out root_ca.crt</code>&nbsp;指定了输出文件名为&nbsp;<code>root_ca.crt</code>。</li>\n</ul>\n<p>在运行该命令时，你会被要求填写一系列问题，这些问题的答案将作为证书的主题字段（Subject）的一部分。例如：</p>\n<ul>\n<li><strong>Country Name (2 letter code)</strong>: 输入国家代码，如&nbsp;<code>CN</code>。</li>\n<li><strong>State or Province Name (full name)</strong>: 输入省份或州的全名。</li>\n<li><strong>Locality Name (eg, city)</strong>: 输入城市名。</li>\n<li><strong>Organization Name (eg, company)</strong>: 输入组织名称。</li>\n<li><strong>Organizational Unit Name (eg, section)</strong>: 输入部门名称。</li>\n<li><strong>Common Name (e.g. server FQDN or YOUR name)</strong>: (注意这个) 输入通用名称，通常是组织的域名或描述性名称，对于根证书而言，可以是类似于&nbsp;<code>Root CA</code>&nbsp;的字符串。</li>\n<li><strong>Email Address</strong>: 可选，可以留空。</li>\n</ul>\n<ol start=\"3\">\n<li>验证其内容</li>\n</ol>\n<pre><code class=\"language-sh\">openssl x509 -in root_ca.crt -text -noout\n</code></pre>\n<ol start=\"4\">\n<li>客户端信任</li>\n</ol>\n<p>至此</p>\n<ul>\n<li><code>root_ca.crt</code> 是CA 自签名的带公钥的证书</li>\n<li><code>root_ca.key</code> 是CA的私钥(绝对不能泄露)</li>\n</ul>\n<p>为了让客户端信任这个新创建的根证书，需要将CA公钥安装到目标系统的受信任根证书存储中。<br />\n例如，在Windows上，你可以双击 <code>root_ca.crt</code> 文件，然后按照提示选择“安装证书”，并将安装位置设置为“受信任的根证书颁发机构</p>\n<h3 id=\"ca-签署颁发服务端证书\">CA 签署/颁发服务端证书</h3>\n<ol>\n<li>生成目标实体的私钥</li>\n</ol>\n<pre><code class=\"language-sh\">openssl genpkey -algorithm RSA -out server.key -aes256 -pkeyopt rsa_keygen_bits:2048\n</code></pre>\n<ol start=\"2\">\n<li>生成目标实体的签发请求 (CSR)<br />\n使用刚刚生成的私钥来创建一个证书签名请求（CSR）。CSR包含了申请者的公钥以及一些识别信息，如组织名称、域名等。</li>\n</ol>\n<pre><code class=\"language-sh\">openssl req -new -key server.key -out server.csr\n\n# openssl req -newkey rsa:2048 -nodes -keyout server.key -out server.csr -subj \"/C=CN/ST=State/L=City/O=Organization/CN=your.server.domain\"\n</code></pre>\n<ol start=\"3\">\n<li>使用CA根证书的<strong>私钥</strong> 签署CSR</li>\n</ol>\n<pre><code class=\"language-sh\">openssl x509 -req -in server.csr -CA root_ca.crt -CAkey root_ca.key -CAcreateserial -out server.crt -days 7300 -sha256\n# openssl x509 -req -in server.csr -CA rootCA.crt -CAkey rootCA.key -CAcreateserial -out server.crt -days 500 -sha256\n</code></pre>\n<h3 id=\"各文件说明\">各文件说明</h3>\n<p>至此有6个文件分别是:<br />\n1.&nbsp;<strong>root_ca.crt (根CA证书公钥) - 自签名 公开 双方信任</strong></p>\n<ul>\n<li><strong>描述</strong>：这是由CA自身创建并签署的自签名证书，作为信任链的起点。根证书通常包含CA的公钥、名称和其他元数据，并且是由CA私钥签名的</li>\n<li><strong>用途</strong>：根证书用于验证由该CA签发的所有下级证书的真实性。它通常被预装在操作系统、浏览器或其他应用程序的信任库中，作为受信任的根证书机构</li>\n</ul>\n<p>2.&nbsp;<strong>root_ca.key (根CA证书私钥)</strong></p>\n<ul>\n<li><strong>描述</strong>：这是与根CA证书配对的私钥，用于签署其他证书。私钥是高度敏感的信息，不应公开或共享。</li>\n<li><strong>用途</strong>：根CA私钥用于签署中间CA证书、服务器证书、客户端证书等。它是建立信任链的基础。</li>\n<li><strong>安全性</strong>：私钥应存储在安全的地方，最好是在离线环境中，只有在需要签署新证书时才连接到网络。 它一旦被攻破，所有依赖它的证书都将失去信任。</li>\n</ul>\n<p>3.&nbsp;<strong>root_ca.srl (序列号文件)</strong></p>\n<ul>\n<li><strong>描述</strong>：这是一个包含十六进制正整数的文件，用于记录已签发证书的序列号。每次签署新证书时，OpenSSL会从这个文件中读取当前的最大序列号，并为新证书分配一个递增的序列号。</li>\n</ul>\n<p>4.&nbsp;<strong>server.crt (服务器公钥)</strong></p>\n<ul>\n<li><strong>描述</strong>：这是由CA签署的服务器证书，包含服务器的公钥以及关于证书的一些信息，如版本、序列号、签名算法、颁发者、持有者、有效期等。服务器证书用于加密客户端与服务器之间的通信，确保数据传输的安全性。</li>\n<li><strong>用途</strong>：服务器证书安装在Web服务器上，用于HTTPS协议下的安全通信。客户端通过验证服务器证书的有效性来确认服务器的身份，并使用证书中的公钥进行加密通信。</li>\n<li><strong>格式</strong>：常见的格式包括PEM（以&nbsp;<code>-----BEGIN CERTIFICATE-----</code>&nbsp;开头，<code>-----END CERTIFICATE-----</code>&nbsp;结尾）和DER（二进制格式）。Linux系统通常使用&nbsp;<code>.crt</code>&nbsp;文件扩展名，而Windows系统可能使用&nbsp;<code>.cer</code></li>\n</ul>\n<p>5.&nbsp;<strong>server.csr (证书签名请求)</strong></p>\n<ul>\n<li><strong>描述</strong>：这是证书申请者在申请数字证书时生成的文件，包含了公钥和标识名称（Distinguished Name, DN），如国家、省份、城市、组织名称、通用名称（通常是域名）等。CSR是以&nbsp;<code>-----BEGIN CERTIFICATE REQUEST-----</code>&nbsp;开头，<code>-----END CERTIFICATE REQUEST-----</code>&nbsp;结尾的Base64编码格式。</li>\n<li><strong>用途</strong>：CSR文件提交给CA后，CA会使用其根证书私钥对CSR中的信息进行签名，生成正式的数字证书。CSR文件本身不是证书，而是申请证书的请求。</li>\n<li><strong>生成</strong>：CSR文件通常由服务器管理员使用OpenSSL等工具生成，同时生成相应的私钥。生成CSR时，必须确保私钥的安全性，因为CSR文件中不包含私钥</li>\n</ul>\n<p>6.&nbsp;<strong>server.key (服务器私钥)</strong></p>\n<ul>\n<li><strong>描述</strong>：这是与服务器证书配对的私钥，用于解密客户端发送的加密信息。私钥是高度敏感的信息，不应公开或共享。</li>\n<li><strong>用途</strong>：服务器私钥用于解密通过TLS/SSL协议传输的数据。在HTTPS通信中，客户端使用服务器证书中的公钥加密数据，服务器则使用私钥解密这些数据。</li>\n<li><strong>格式</strong>：常见的格式包括PEM（以&nbsp;<code>-----BEGIN RSA PRIVATE KEY-----</code>&nbsp;或&nbsp;<code>-----BEGIN PRIVATE KEY-----</code>&nbsp;开头，<code>-----END RSA PRIVATE KEY-----</code>&nbsp;或&nbsp;<code>-----END PRIVATE KEY-----</code>&nbsp;结尾）和DER（二进制格式）。Linux系统通常使用&nbsp;<code>.key</code>&nbsp;文件扩展名</li>\n</ul>\n<h4 id=\"每个角色验证需要\">每个角色验证需要</h4>\n<ol>\n<li>**客户端需要</li>\n</ol>\n<ul>\n<li><strong><code>root_ca.crt</code></strong>：根 CA 的公钥证书。客户端将使用此证书来验证服务器的证书是否由可信的 CA 签发。</li>\n</ul>\n<ol>\n<li>**服务端端需要</li>\n</ol>\n<ul>\n<li><strong><code>server.key</code></strong>：服务器的私钥。服务器将使用此私钥来解密客户端发送的加密数据，并签署响应。</li>\n<li><strong><code>server.crt</code></strong>：服务器的公钥证书，由根 CA 签发。服务器将使用此证书向客户端证明其身份。</li>\n<li><strong><code>root_ca.crt</code></strong>（可选, 双向验证必选）：如果你的服务器证书是由中间 CA 签发的，你可以将根 CA 证书或中间 CA 证书链一起加载到服务器的信任库中，以便客户端可以验证整个证书链。</li>\n</ul>\n<h2 id=\"在netty-使用\">在Netty 使用</h2>\n<h3 id=\"证书的加载\">证书的加载</h3>\n<ol>\n<li>\n<p>公钥加载  <code>.pem, .crt, .cer</code>  : 通常以&nbsp;<code>-----BEGIN CERTIFICATE-----</code>&nbsp;开头，以&nbsp;<code>-----END CERTIFICATE-----</code>&nbsp;结尾。它既可以包含公钥证书，也可以包含私钥。<strong>Java本身支持 pem</strong></p>\n</li>\n<li>\n<p>私钥加载 <code>.key</code>:  openssl 默认给私钥加密了 , 将其转为不加密的, 可使用 bouncycastle加载之</p>\n</li>\n</ol>\n<pre><code># **转换为 PKCS#8 格式 (PEM 编码)**\nopenssl pkcs8 -topk8 -inform PEM -in server.key -outform PEM -nocrypt -out server_pkcs8.key\n\n# **转换为 PKCS#8 格式 (DER 编码)** 二进制格式\nopenssl pkcs8 -topk8 -inform PEM -in server.key -outform DER -nocrypt -out server_pkcs8.der\n</code></pre>\n<ul>\n<li>使用 bouncycastle 加载 pkcs8 私钥</li>\n</ul>\n<pre><code>implementation(\"cn.hutool:hutool-all:5.8.16\")\nimplementation(\"org.bouncycastle:bcprov-jdk15on:1.70\")\nimplementation(\"org.bouncycastle:bcpkix-jdk15on:1.70\")\n</code></pre>\n<pre><code class=\"language-java\">\n\npublic static void main(String[] args) throws Exception {\n\n\tfinal String ca_cet = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\root_ca.crt\";\n\tfinal String server_crt = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\server.crt\";\n\n\tfinal String server_key = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\server.key\";\n\tfinal String server_pkcs8_key = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\server_pkcs8.key\";\n\t\n\tPublicKey root_caKey = PemUtil.readPemPublicKey(FileUtil.getInputStream(ca_cet));\n\tSystem.out.println(\"root_caKey  ==&gt; \"+root_caKey );\n\tCertificate certificate = SecureUtil.readX509Certificate(FileUtil.getInputStream(server_crt));\n\tSystem.out.println(\"X509C  ==&gt; \"+root_caKey );\n\t\n\tPublicKey server_crtKey = PemUtil.readPemPublicKey(FileUtil.getInputStream(server_crt));\n\tSystem.out.println(\"server_crtKey  ==&gt; \"+server_crtKey );\n\n\tPrivateKey privateKey = PemUtil.readPemPrivateKey(FileUtil.getInputStream(server_pkcs8_key));\n\tSystem.out.println(\"server_pkcs8  ==&gt; \"+privateKey );\n}\n</code></pre>\n<ul>\n<li>使用 bouncycastle 如何 加载默认 openssl 加密的 <code>server.key</code> ?</li>\n</ul>\n<pre><code class=\"language-java\">public static PrivateKey loadEncryptedPrivateKeyFromPem(String pemFile, char[] password) throws Exception {\n\ttry (Reader reader = new FileReader(pemFile);\n\t\t PEMParser pemParser = new PEMParser(reader)) {\n\n\t\tObject object = pemParser.readObject();\n\t\tJcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(\"BC\");\n\n\t\tif (object instanceof PEMEncryptedKeyPair) {\n\t\t\tPEMEncryptedKeyPair encryptedKeyPair = (PEMEncryptedKeyPair) object;\n\t\t\tInputDecryptorProvider decryptorProvider = new JceOpenSSLPKCS8DecryptorProviderBuilder().build(password);\n\t\t\tKeyPair kp = converter.getKeyPair(encryptedKeyPair.decryptKeyPair(decryptorProvider));\n\t\t\treturn kp.getPrivate();\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"Unsupported encrypted key type: \" + object.getClass().getName());\n\t\t}\n\t}\n}\n\n\n</code></pre>\n<h3 id=\"单向验证的tls\">单向验证的TLS</h3>\n<p>客户端单向了验证服务端</p>\n<h4 id=\"服务端\">服务端</h4>\n<pre><code class=\"language-java\">public static void main(String[] args) throws Exception {\n\n\tNioEventLoopGroup boosGroup = new NioEventLoopGroup();\n\tfinal ServerBootstrap serverBootstrap = new ServerBootstrap();\n\tint port = 19977;\n\t// 1. 加载 PEM 私钥,  2.  加载 证书\n\tfinal String server_crt = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\server.crt\";\n\tfinal String server_pkcs8_key = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\server_pkcs8.key\";\n\n\tCertificate certificate = SecureUtil.readX509Certificate(FileUtil.getInputStream(server_crt));\n\tPrivateKey privateKey = PemUtil.readPemPrivateKey(FileUtil.getInputStream(server_pkcs8_key));\n\t// 3. 创建 KeyStore 并将私钥和证书添加到其中\n\tKeyStore keyStore = KeyStore.getInstance(\"PKCS12\");\n\tkeyStore.load(null, null);\n\tkeyStore.setKeyEntry(\"alias\", privateKey, \"password\".toCharArray(), new Certificate[]{certificate});\n\n\t// 4. 创建 KeyManagerFactory 并初始化\n\tKeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n\tkmf.init(keyStore, \"password\".toCharArray());\n\n\t// 5. 构建 SslContext\n\tfinal SslContext sslContext = SslContextBuilder.forServer(kmf)\n\t\t\t.build();\n\n\tserverBootstrap\n\t\t\t.group(boosGroup)\n\t\t\t.channel(NioServerSocketChannel.class)\n\t\t\t.option(ChannelOption.SO_BACKLOG, 1024)\n\t\t\t.childOption(ChannelOption.SO_KEEPALIVE, true)\n\t\t\t.childOption(ChannelOption.TCP_NODELAY, true)\n\t\t\t.childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() {\n\t\t\t\t@Override\n\t\t\t\tprotected void initChannel(NioSocketChannel ch) {\n\t\t\t\t\t// 添加 SSL/TLS 处理器\n\t\t\t\t\tch.pipeline().addLast(sslContext.newHandler(ch.alloc()));\n\t\t\t\t\tch.pipeline().addLast(new StringDecoder())\n\t\t\t\t\t\t\t.addLast(new StringEncoder())\n\t\t\t\t\t\t\t.addLast(new ServerHandler());\n\t\t\t\t}\n\t\t\t});\n\tChannelFuture f = serverBootstrap.bind(port).addListener(future -&gt; {\n\t\tif (future.isSuccess()) {\n\t\t\tSystem.out.println(new Date() + \": 端口[\" + port + \"]绑定成功!\");\n\t\t} else {\n\t\t\tSystem.err.println(\"端口[\" + port + \"]绑定失败!\");\n\t\t}\n\t});\n\t//下面会进行阻塞, 等待服务器连接关闭之后 main 方法退出, 程序结束;\n\tf.channel().closeFuture().sync();\n}\n</code></pre>\n<h4 id=\"客户端\">客户端</h4>\n<pre><code class=\"language-java\"> public static void main(String[] args) throws Exception {\n \n\tBootstrap bootstrap = new Bootstrap();\n\tNioEventLoopGroup group = new NioEventLoopGroup();\n\n\tString host = \"192.168.20.130\";\n\tint port = 19977;\n\n\t// 1. 加载 CA 证书\n\tfinal String ca_cet = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\root_ca.crt\";\n\tCertificate certificate = SecureUtil.readX509Certificate(FileUtil.getInputStream(ca_cet));\n\n\t// 2. 创建 KeyStore 并将 CA 证书添加到信任库中\n\tKeyStore trustStore = KeyStore.getInstance(\"JKS\");\n\ttrustStore.load(null, null);\n\ttrustStore.setCertificateEntry(\"ca\", certificate);\n\n\t// 3. 创建 TrustManagerFactory 并初始化\n\tTrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n\ttmf.init(trustStore);\n\n\t// 4. 构建 SslContext\n\tSslContext build = SslContextBuilder.forClient()\n\t\t\t.trustManager(tmf)\n\t\t\t.build();\n\n\tbootstrap.group(group)\n\t\t\t.channel(NioSocketChannel.class)\n\t\t\t.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 30000)\n\t\t\t.option(ChannelOption.SO_KEEPALIVE, true)\n\t\t\t.handler( new SimpleChannelInboundHandler&lt;String&gt;() {\n\t\t\t\t@Override\n\t\t\t\tprotected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {\n\t\t\t\t\tSystem.out.println(\"客户端接收: \"+msg);\n\t\t\t\t}\n\t\t\t})\n\t\t\t.connect(host, port).addListener(new ChannelFutureListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void operationComplete(ChannelFuture future) throws Exception {\n\t\t\t\t\tfuture.channel().pipeline()\n\t\t\t\t\t\t\t.addFirst(new StringEncoder())\n\t\t\t\t\t\t\t.addFirst(new StringDecoder())\n\t\t\t\t\t\t\t.addFirst( build.newHandler(future.channel().alloc() ));\n\t\t\t\t\tfinal String helloToServer = \"珠玉买歌笑，糟糠养贤才。方知黄鹄举，千里独徘徊。\"+System.currentTimeMillis();\n\t\t\t\t\tfuture.channel().writeAndFlush(helloToServer);\n\t\t\t\t}\n\t\t\t});\n//        group.shutdownGracefully();\n    }\n\n</code></pre>\n<p>Android 上使用 java.security.KeyStore 时，可能会遇到 KeyStoreException: JKS not found 的错误。这是因为 Android 的安全框架与标准 Java 不同，Android 并不支持 JKS（Java KeyStore）格式。相反，Android 支持其他类型的密钥库，如 BKS（Bouncy Castle KeyStore）和 PKCS12。</p>\n<pre><code class=\"language-java\">private SslContext getSslContext() throws Exception {\n\tCertificate caCert = CertificateUtils.getCertificate();\n\tKeyStore trustStore = KeyStore.getInstance(\"BKS\");  // 使用 BKS 或 PKCS12\n\ttrustStore.load(null, null);\n\ttrustStore.setCertificateEntry(\"ca\", caCert);\n\n\tTrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n\ttmf.init(trustStore);\n\n\tSslContext build = SslContextBuilder.forClient()\n\t\t\t.trustManager(tmf)\n\t\t\t.build();\n\treturn build;\n}\n</code></pre>\n<p>抓包看看<br />\n![[Pasted image 20241219145126.png]]</p>\n<h3 id=\"双向验证的tls\">双向验证的TLS</h3>\n<p>其实同服务端一样的逻辑 1.生成客户端私钥, 2.生成客户端CRS, 3.用CA根证书签发客户端的公钥</p>\n<h4 id=\"客户端证书准备\">客户端证书准备</h4>\n<h5 id=\"生成客户端私钥\"><strong>生成客户端私钥</strong></h5>\n<pre><code>openssl genpkey -algorithm RSA -out client.key -aes256 -pkeyopt rsa_keygen_bits:2048\n</code></pre>\n<p>转换为pkcs#8 格式</p>\n<pre><code>openssl pkcs8 -topk8 -inform PEM -in client.key -outform PEM -nocrypt -out client_pkcs8.key\n</code></pre>\n<h5 id=\"创建客户端的证书签名请求-csr\"><strong>创建客户端的证书签名请求 (CSR)</strong></h5>\n<pre><code>openssl req -new -key client.key -out client.csr\n</code></pre>\n<h5 id=\"使用根-ca-签名客户端的-csr\"><strong>使用根 CA 签名客户端的 CSR</strong></h5>\n<pre><code>openssl x509 -req -in client.csr -CA root_ca.crt -CAkey root_ca.key -CAcreateserial -out client.crt -days 7300 -sha256\n\n</code></pre>\n<h4 id=\"服务端-1\">服务端</h4>\n<pre><code class=\"language-java\">public static void main(String[] args) throws Exception {\n        NioEventLoopGroup boosGroup = new NioEventLoopGroup();\n        final ServerBootstrap serverBootstrap = new ServerBootstrap();\n        int port = 19977;\n        // 1. 加载 PEM 私钥,  2.  加载 证书\n        final String server_crt = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\server.crt\";\n        final String server_pkcs8_key = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\server_pkcs8.key\";\n\n        Certificate certificate = SecureUtil.readX509Certificate(FileUtil.getInputStream(server_crt));\n        PrivateKey privateKey = PemUtil.readPemPrivateKey(FileUtil.getInputStream(server_pkcs8_key));\n        // 3. 创建 KeyStore 并将私钥和证书添加到其中\n        KeyStore keyStore = KeyStore.getInstance(\"PKCS12\");\n        keyStore.load(null, null);\n        keyStore.setKeyEntry(\"alias\", privateKey, \"password\".toCharArray(), new Certificate[]{certificate});\n\n        // 4. 创建 KeyManagerFactory 并初始化\n        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n        kmf.init(keyStore, \"password\".toCharArray());\n\n        //双向认证 CA根证书\n        final String root_ca = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\root_ca.crt\";\n        X509Certificate caCertificate = (X509Certificate) SecureUtil.readX509Certificate(FileUtil.getInputStream(root_ca));\n\n        // 5. 构建 SslContext\n        final SslContext sslContext = SslContextBuilder.forServer(kmf)\n                .trustManager(caCertificate)\n                .clientAuth(io.netty.handler.ssl.ClientAuth.REQUIRE)//双向认证 &gt; 配置要求客户端也认证\n                .build();\n\n        serverBootstrap\n                .group(boosGroup)\n                .channel(NioServerSocketChannel.class)\n                .option(ChannelOption.SO_BACKLOG, 1024)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() {\n                    @Override\n                    protected void initChannel(NioSocketChannel ch) {\n                        // 添加 SSL/TLS 处理器\n                        ch.pipeline().addLast(sslContext.newHandler(ch.alloc()));\n                        ch.pipeline().addLast(new StringDecoder())\n                                .addLast(new StringEncoder())\n                                .addLast(new ServerHandler());\n                    }\n                });\n        ChannelFuture f = serverBootstrap.bind(port).addListener(future -&gt; {\n            if (future.isSuccess()) {\n                System.out.println(new Date() + \": 端口[\" + port + \"]绑定成功!\");\n            } else {\n                System.err.println(\"端口[\" + port + \"]绑定失败!\");\n            }\n        });\n        //下面会进行阻塞, 等待服务器连接关闭之后 main 方法退出, 程序结束;\n        f.channel().closeFuture().sync();\n    }\n</code></pre>\n<h4 id=\"客户端-1\">客户端</h4>\n<pre><code class=\"language-java\">public static void main(String[] args) throws Exception {\n        Bootstrap bootstrap = new Bootstrap();\n        NioEventLoopGroup group = new NioEventLoopGroup();\n\n        String host = \"192.168.20.130\";\n        int port = 19977;\n\n        // 1. 加载 CA 证书\n        final String ca_cet = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\root_ca.crt\";\n        Certificate certificate = SecureUtil.readX509Certificate(FileUtil.getInputStream(ca_cet));\n\n        // 2. 创建 KeyStore 并将 CA 证书添加到信任库中\n        KeyStore trustStore = KeyStore.getInstance(\"JKS\");\n        trustStore.load(null, null);\n        trustStore.setCertificateEntry(\"ca\", certificate);\n\n        // 3. 创建 TrustManagerFactory 并初始化\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        tmf.init(trustStore);\n\n        // 双向认证 &gt; 客户端证书\n        final String client_crt = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\client.crt\";\n        final String client_pkcs8_key = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\client_pkcs8.key\";\n\n        // 4. 构建 SslContext\n        SslContext build = SslContextBuilder.forClient()\n                .keyManager(FileUtil.file(client_crt), FileUtil.file(client_pkcs8_key))\n                .trustManager(tmf)\n                .build();\n\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 30000)\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .handler( new SimpleChannelInboundHandler&lt;String&gt;() {\n                    @Override\n                    protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {\n                        System.out.println(\"客户端接收: \"+msg);\n                    }\n                })\n                .connect(host, port).addListener(new ChannelFutureListener() {\n                    @Override\n                    public void operationComplete(ChannelFuture future) throws Exception {\n                        future.channel().pipeline()\n                                .addFirst(new StringEncoder())\n                                .addFirst(new StringDecoder())\n                                .addFirst( build.newHandler(future.channel().alloc() ));\n                        final String helloToServer = \"珠玉买歌笑，糟糠养贤才。方知黄鹄举，千里独徘徊。\"+System.currentTimeMillis();\n                        future.channel().writeAndFlush(helloToServer);\n                    }\n                });\n//        group.shutdownGracefully();\n    }\n</code></pre>\n<p>最后, 抓包看看</p>\n<p><img alt=\"Pasted image 20241220115443\" class=\"lazyload\" /></p>\n\n</div>\n<div id=\"MySignature\">\n    预防老年痴呆，保持终身学习!    —— <a href=\"https://www.cnblogs.com/dddy/\" target=\"_blank\">daidaidaiyu</a>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-07 21:18</span>&nbsp;\n<a href=\"https://www.cnblogs.com/dddy\">daidaidaiyu</a>&nbsp;\n阅读(<span id=\"post_view_count\">94</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Supertonic 部署与使用全流程保姆级指南（附已部署镜像）",
      "link": "https://www.cnblogs.com/ChenAI-TGF/p/19453758",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ChenAI-TGF/p/19453758\" id=\"cb_post_title_url\" title=\"发布于 2026-01-07 19:57\">\n    <span>Supertonic 部署与使用全流程保姆级指南（附已部署镜像）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        Supertonic开源工具Python版部署与使用指南 摘要：本文详细介绍了Supertonic(一款语音处理工具)Python版本的完整部署流程，包括服务器环境准备、源码下载、依赖安装、常见报错解决方法等关键步骤。部署成功后，用户只需修改示例脚本中的文本内容，即可生成对应的音频结果文件。文章还提供了已部署镜像的获取方式，帮助用户快速上手。部署过程中需注意模型自动下载、依赖版本冲突等常见问题。通过本指南，用户可以快速完成Supertonic的环境搭建并开始使用其核心功能。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"前言\">前言</h1>\n<p>Supertonic 是一款实用的开源工具（注：可根据实际补充Supertonic的核心功能，如语音合成/处理等），本文将详细讲解其 Python 版本的完整部署流程、日常使用方法，并附上我已部署好的镜像链接，帮大家快速上手。</p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h1 id=\"一部署前准备\">一、部署前准备</h1>\n<ol>\n<li>服务器环境要求：已安装 Python 3.7+（推荐3.8-3.10）、pip 工具，确保服务器有基础的网络访问权限；</li>\n<li>工具准备：本地电脑（或服务器）可通过 <code>scp</code>/<code>rz</code>/<code>sftp</code> 等方式传输文件到服务器。<br />\n<strong>我的服务器是在星图上面租的4090，1.46元一小时，相对来说还是很便的</strong><br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></li>\n</ol>\n<h1 id=\"二完整部署步骤\">二、完整部署步骤</h1>\n<h2 id=\"步骤1从github下载源码包\">步骤1：从GitHub下载源码包</h2>\n<p>首先在本地或服务器直接下载 Supertonic 的 Python 版本源码，GitHub 地址（请替换为实际地址）：</p>\n<pre><code class=\"language-bash\"># 方式1：服务器直接git克隆（推荐）\ngit clone https://github.com/supertone-inc/supertonic\n\n# 方式2：本地下载zip包后，手动上传到服务器\n# 访问上述GitHub地址，点击「Code」→「Download ZIP」下载压缩包\n</code></pre>\n<p>github链接：<a href=\"https://github.com/supertone-inc/supertonic\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/supertone-inc/supertonic</a><br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h2 id=\"步骤2将源码包转移到服务器\">步骤2：将源码包转移到服务器</h2>\n<p>如果是本地下载的 zip 包，通过jupyter可以直接拖动上传到服务器上面<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h2 id=\"步骤3解压程序包\">步骤3：解压程序包</h2>\n<p>登录服务器，进入文件存放目录，解压源码包：<br />\n<strong>在左侧切换到压缩包所在的目录的时候，右边界面点击 Terminal</strong></p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<p><strong>输入以下命令解压包</strong></p>\n<pre><code class=\"language-bash\"># 解压zip包（如果是git克隆则无需此步骤）\nunzip supertonic-main.zip\n\n# 解压后会生成 supertonic-main 目录\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h2 id=\"步骤4进入指定路径并安装依赖\">步骤4：进入指定路径并安装依赖</h2>\n<p>进入 Supertonic Python 代码的核心路径，安装 <code>requirements.txt</code> 中的依赖：</p>\n<pre><code class=\"language-bash\"># 进入supertonic-main/py路径\ncd supertonic-main/py/\n\n# 安装依赖（建议先升级pip，避免安装失败）\npip install --upgrade pip\npip install -r requirements.txt\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h2 id=\"步骤5首次运行示例脚本并补充缺失库\">步骤5：首次运行示例脚本并补充缺失库</h2>\n<p>运行示例脚本 <code>example_pypi.py</code>，此时大概率会提示缺少某个库（如 <code>supertonic</code> 库）：</p>\n<pre><code class=\"language-bash\"># 首次运行示例脚本\npython example_pypi.py\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"常见报错示例\">常见报错示例：</h3>\n<pre><code>ModuleNotFoundError: No module named 'supertonic'\n</code></pre>\n<h4 id=\"解决方法\">解决方法：</h4>\n<p>根据报错提示，用 pip 补充安装缺失的库：</p>\n<pre><code class=\"language-bash\"># 替换xxx为实际缺失的库名，如 pip install soundfile\npip install supertonic\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h2 id=\"步骤6重新运行脚本并等待模型下载\">步骤6：重新运行脚本并等待模型下载</h2>\n<p>补充安装缺失库后，再次运行示例脚本：</p>\n<pre><code class=\"language-bash\">python example_pypi.py\n</code></pre>\n<p>⚠️ 注意：<strong>第一次运行时，脚本会自动下载所需的模型文件</strong>，下载速度取决于服务器网络，需耐心等待（通常几分钟），不要中断进程。</p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h2 id=\"步骤7验证部署成功\">步骤7：验证部署成功</h2>\n<p>运行完成后，检查 <code>supertonic-main/py/result</code> 目录，若生成了 wav 格式的结果文件，说明部署成功！</p>\n<pre><code class=\"language-bash\"># 查看result目录内容\nls result/\n</code></pre>\n<p>或者直接利用左侧文件管理系统查看<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h2 id=\"三supertonic-使用步骤\">三、Supertonic 使用步骤</h2>\n<p>部署完成或者直接使用我部署完的镜像之后，日常使用只需以下4步：</p>\n<h3 id=\"步骤1进入指定工作路径\">步骤1：进入指定工作路径</h3>\n<p>每次使用前，先登录服务器并进入核心路径：</p>\n<pre><code class=\"language-bash\">cd /supertonic-main/py/\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"步骤2修改示例脚本的文本内容\">步骤2：修改示例脚本的文本内容</h3>\n<p>编辑 <code>example_pypi.py</code> 文件，修改其中的 <code>text</code> 变量（核心输入内容，如语音合成的文本）：</p>\n<pre><code class=\"language-bash\"># 用vim编辑文件\nvim example_pypi.py\n\n# 找到类似如下的代码行，修改text的值\ntext = \"这是默认的测试文本\"  # 将此行改为你需要的内容\n</code></pre>\n<p>修改完成后，按 <code>Esc</code> → 输入 <code>:wq</code> 保存并退出 vim。</p>\n<p>或者直接用可视化界面修改内容<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"步骤3运行脚本生成结果\">步骤3：运行脚本生成结果</h3>\n<p>在当前路径下执行脚本，触发处理流程：</p>\n<pre><code class=\"language-bash\">python example_pypi.py\n</code></pre>\n<p>结果没有任何输出就是生成成功了，直接在result里面查看就可以了</p>\n<h3 id=\"步骤4查看生成的结果文件\">步骤4：查看生成的结果文件</h3>\n<p>处理完成后，所有结果会以 <code>wav</code> 音频文件格式存储在 <code>supertonic-main/py/result</code> 目录下，可通过 <code>scp</code> 下载到本地播放，或直接在服务器上用音频工具查看：</p>\n<pre><code class=\"language-bash\"># 下载结果文件到本地（示例）\nscp root@192.168.1.100:/opt/supertonic-main/py/result/xxx.wav ~/Desktop/\n</code></pre>\n<h1 id=\"四已部署好的镜像链接\">四、已部署好的镜像链接</h1>\n<p>为了方便大家快速使用，我已将部署完成的 Supertonic 环境打包为星图的社区镜像，可直接拉取使用，等待审核通过之后我会把链接搬到博客上面来。</p>\n<h1 id=\"五常见注意事项\">五、常见注意事项</h1>\n<ol>\n<li>模型下载失败：若首次运行时模型下载中断，可手动下载模型文件后放到脚本指定的缓存目录（通常在 <code>~/.cache/</code> 下）；</li>\n<li>依赖版本冲突：若安装 <code>requirements.txt</code> 时出现版本冲突，可尝试添加 <code>--force-reinstall</code> 参数重新安装，或降级对应库版本；</li>\n<li>权限问题：若运行脚本提示权限不足，执行 <code>chmod +x example_pypi.py</code> 或用 <code>sudo python example_pypi.py</code> 运行。</li>\n</ol>\n<hr />\n<h1 id=\"总结\">总结</h1>\n<ol>\n<li>Supertonic Python 版本部署核心步骤：下载源码→上传服务器→解压→安装依赖→补装缺失库→首次运行（等待模型下载）；</li>\n<li>日常使用只需修改 <code>example_pypi.py</code> 的 <code>text</code> 内容，运行脚本即可在 <code>result</code> 目录获取 wav 结果；</li>\n<li>可直接使用博主提供的已部署镜像，跳过繁琐的环境配置步骤，快速上手。</li>\n</ol>\n<p>如果部署或使用过程中遇到问题，欢迎在评论区交流～</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-07 19:57</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ChenAI-TGF\">TTGF</a>&nbsp;\n阅读(<span id=\"post_view_count\">31</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "LLM | ARC-AGI：有趣的 benchmark",
      "link": "https://www.cnblogs.com/moonout/p/19449723",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/moonout/p/19449723\" id=\"cb_post_title_url\" title=\"发布于 2026-01-07 19:57\">\n    <span>LLM | ARC-AGI：有趣的 benchmark</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        ARC-AGI benchmark 提供了基于视觉网格的谜题，它们是“对于人类简单、对于大模型困难”的问题。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<br />\n<p>ARC-AGI benchmark 提供了基于视觉网格的谜题，这些谜题是“对于人类简单、对于大模型困难”的问题。ARC-AGI 通过评测大模型解决这类问题的能力，来衡量大模型距通用智能的距离。</p>\n<p>每个谜题仅提供少量示例，大模型需要基于这些示例，通过抽象推理，理解谜题的含义。（另一方面，示例较少也意味着训练数据集较少，即，ARC-AGI benchmark 不容易通过专门训练来刷点。）该 benchmark 测试模型识别 pattern 并将其快速应用于新情况的能力。</p>\n<p>ARC-AGI 的主要评估指标是 Pass@2，它衡量模型在两次尝试内生成正确输出的能力。</p>\n<p>示例：</p>\n<p align=\"center\"><img align=\"center\" src=\"https://arcprize.org/media/images/arc-task-grids.jpg\" /></p>\n<p align=\"center\">(ARC-AGI-1)</p>\n<br />\n<p align=\"center\"><img align=\"center\" src=\"https://arcprize.org/media/images/v2-example.png\" /></p>\n<p align=\"center\">(ARC-AGI-2)</p>\n<p>如何解决 ARC-AGI 问题？ARC-AGI 团队在 Kaggle 上发布了相关竞赛，然而，由于训练数据过少，无法训出一个用于解决 ARC-AGI 问题的模型（这个思想也与考察模型通用推理能力的初衷相悖），因此在 2024 年 GPT 等模型兴起之前，基于深度学习的方法并未取得好的结果。</p>\n<p>根据 <a href=\"\" rel=\"noopener nofollow\">ARC Prize 2024: Technical Report</a>，在 2024 年度，ARC-AGI 的求解取得突破，主要使用了以下三种方法：</p>\n<ul>\n<li>深度学习引导的程序合成：利用深度学习模型，特别是专门的代码 LLMs，来生成解决任务的程序，或对搜索程序的过程进行指导。</li>\n<li>直推模型（transductive models）在测试时训练（test-time training，TTT）：在给定的 ARC-AGI 任务规范上对 LLM 进行微调，以便将 LLM 的先验知识重新组合成一个新的模型，适应当前的任务。直推模型指的是，接收输入后直接输出结果，而非输出一个程序。</li>\n<li>将程序合成与直推模型相结合：将上述两种方法合并为一个超级方法，因为据观察，这两种方法擅长解决不同类型的任务。</li>\n</ul>\n<hr />\n<p>ARC-AGI 任务的官网：<a href=\"https://arcprize.org/\" rel=\"noopener nofollow\" target=\"_blank\">https://arcprize.org/</a></p>\n<p>ARC-AGI-1/2/3 ：</p>\n<ul>\n<li><a href=\"https://arcprize.org/arc-agi/1/\" rel=\"noopener nofollow\" target=\"_blank\">https://arcprize.org/arc-agi/1/</a></li>\n<li><a href=\"https://arcprize.org/arc-agi/2/\" rel=\"noopener nofollow\" target=\"_blank\">https://arcprize.org/arc-agi/2/</a></li>\n<li><a href=\"https://arcprize.org/arc-agi/3/\" rel=\"noopener nofollow\" target=\"_blank\">https://arcprize.org/arc-agi/3/</a></li>\n</ul>\n<p>ARC-AGI-1/2 的榜单：<a href=\"https://arcprize.org/leaderboard\" rel=\"noopener nofollow\" target=\"_blank\">https://arcprize.org/leaderboard</a></p>\n<p>ARC Prize 2024: Technical Report：<a href=\"https://arxiv.org/html/2412.04604v1\" rel=\"noopener nofollow\" target=\"_blank\">https://arxiv.org/html/2412.04604v1</a></p>\n<p>相关博客：</p>\n<ul>\n<li>像 AI 写的神秘博客：<a href=\"https://labs.adaline.ai/p/what-is-the-arc-agi-benchmark-and\" rel=\"noopener nofollow\" target=\"_blank\">https://labs.adaline.ai/p/what-is-the-arc-agi-benchmark-and</a></li>\n<li>知乎 · 机器之心 |「压缩即智能」得到实验验证，无需预训练和大量数据就能解决 ARC-AGI 问题：<a href=\"https://zhuanlan.zhihu.com/p/30426666081\" rel=\"noopener nofollow\" target=\"_blank\">https://zhuanlan.zhihu.com/p/30426666081</a></li>\n<li>知乎 | ARC-AGI 测试集对人工智能来说难在哪里？<a href=\"https://www.zhihu.com/question/7955529556/answer/65269819236\" rel=\"noopener nofollow\" target=\"_blank\">https://www.zhihu.com/question/7955529556/answer/65269819236</a></li>\n</ul>\n<br />\n<br />\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-07 19:57</span>&nbsp;\n<a href=\"https://www.cnblogs.com/moonout\">MoonOut</a>&nbsp;\n阅读(<span id=\"post_view_count\">19</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "3D-AIGC 存储架构演进：从 NFS、GlusterFS 到 JuiceFS",
      "link": "https://www.cnblogs.com/JuiceData/p/19453125",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/JuiceData/p/19453125\" id=\"cb_post_title_url\" title=\"发布于 2026-01-07 16:55\">\n    <span>3D-AIGC 存储架构演进：从 NFS、GlusterFS 到 JuiceFS</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>光影焕像（Lightillusions）是一家专注于空间智能技术，结合 3D 视觉、图形学和生成模型技术，致力于打造创新的 3D 基础模型公司。公司由谭平教授领导，谭教授曾担任阿里巴巴达摩院实验室负责人，目前是香港科技大学的教授，同时担任冯诺伊曼人工智能研究室副院长，并是香港科技大学与比亚迪联合实验室的主任。</p>\n<p>区别于二维模型，三维模型单个模型的大小可达几 GB，尤其是点云数据等复杂模型。当数据量达到 PB 级别时，管理与存储成为巨大的挑战。经过尝试 NFS、GlusterFS 等方案后，我们最终选择了 JuiceFS，成功搭建了一个统一的存储平台，为多个场景服务，并支持跨平台访问，包括 Windows 和 Linux 系统。<strong>该平台目前已管理上亿文件，数据处理速度提升了 200%~250%，还实现了高效的存储扩容，同时运维管理得到了极大简化，使得团队能够更专注于核心任务的推进</strong>。</p>\n<h2 id=\"01-3d-aigc-存储需求\">01 3D-AIGC 存储需求</h2>\n<p>我们的研究主要集中在感知和生成两个方向。在三维领域，任务的复杂性与图像和文本处理有本质区别，这对我们的 AI 模型、算法以及基础设施建设都提出了更高的要求。</p>\n<p>我们通过一个 3D 数据处理流程，来展示三维数据处理的复杂性。下图左侧是一个三维模型，包含纹理（左上角的折射纹理）和几何信息（右下角的几何结构）。首先，我们生成渲染图像。每个模型还附带文本标签，描述其内容、几何特征和纹理特征，这些标签与每个模型紧密相关。此外，我们还处理几何数据，如采样点以及从数据预处理过程中得到的必要数值（如 3DS、SDF 等）。需要注意的是，三维模型的文件格式非常多样，图片格式也各不相同。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>我们的工作场景涉及语言模型、图像/视频模型到三维模型，随着数据量的增长，存储负担也在不断增加。以下是这些场景中数据使用的主要特点：</p>\n<ul>\n<li>语言模型的数据通常由大量小文件组成。尽管单个文本文件较小，但随着数据量的增加，文件数量可能达到数百万甚至数千万个，这使得管理如此庞大的文件数成为存储的一个主要难点。</li>\n<li>图像和视频数据，尤其是高分辨率图像和长时间的视频，通常较为庞大。单张图像的大小通常在几百 KB 到几 MB 之间，而视频文件可能达到 GB 级别。在预处理过程中，如数据增强、分辨率调整和帧提取等，数据量会显著增加，特别是在视频处理中，每个视频通常会被拆解为大量的图像文件，管理这些庞大的文件集，带来了更高的复杂性。</li>\n<li>三维模型，特别是点云数据等复杂模型，单个模型的大小可达几 GB。<strong>三维数据的预处理过程比其他数据更加复杂，涉及纹理映射、几何重建等多个步骤，这些处理不仅消耗大量计算资源，还可能增加数据体积</strong>。此外，三维模型通常由多个文件组成，文件数量庞大，随着数据量的增长，管理这些文件的难度也会增加。</li>\n</ul>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>由上述环节的存储特点，我们希望构建的存储平台能够满足以下几项要求：</p>\n<ul>\n<li>\n<p><strong>多样的数据格式与跨节点共享</strong>：不同模型的数据格式差异较大，特别是三维模型的格式复杂性和跨平台兼容问题，存储系统需要支持多种格式，并有效管理跨节点和跨平台的数据共享。</p>\n</li>\n<li>\n<p><strong>可以处理不同尺寸的数据模型</strong>：无论是语言模型的小文件、大规模图片/视频数据，还是三维模型的大文件，存储系统必须具备高扩展性，以应对快速增长的存储需求，并高效处理大尺寸数据的存储和访问。</p>\n</li>\n<li>\n<p><strong>跨云与集群存储的挑战</strong>：随着数据量的增加，特别是三维模型的 PB 级存储需求，跨云和集群存储问题愈加突出。存储系统需要支持跨区域、跨云的无缝数据访问和高效的集群管理。</p>\n</li>\n<li>\n<p><strong>方便扩容</strong>：无论是语言模型、图片/视频模型，还是三维模型，扩容需求始终存在，尤其是三维模型的存储和处理对扩容的需求更高。</p>\n</li>\n<li>\n<p><strong>简单的运维</strong>：存储系统应提供简便的管理界面和工具，尤其是对于三维模型的管理，运维要求更高，自动化管理和容错能力是必不可少的。</p>\n</li>\n</ul>\n<h2 id=\"02-存储方案探索从-nfsglustercephfs-到-juicefs\">02 存储方案探索：从 NFS、Gluster、CephFS 到 JuiceFS</h2>\n<h3 id=\"前期方案nfs-挂载\">前期方案：NFS 挂载</h3>\n<p>最初，我们采用了最简单的方案——使用 NFS 进行挂载。然而，在实际操作中，我们发现训练集群和渲染集群需要各自独立的集群来进行挂载操作。这种方式的维护非常繁琐，尤其是当添加新的数据时，我们需要单独为每个新数据写入挂载点。到了数据量达到约 100 万物体级别时，我们已经无法继续维持这种方案，因此在早期阶段，我们就放弃了这一方案。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h3 id=\"中期方案glusterfs\">中期方案：GlusterFS</h3>\n<p>GlusterFS 是一个相对易于上手的选择，安装配置简单，性能也能得到一定保障，且无需划分多个挂载点，只需增加新节点即可。虽然在前期使用时，GlusterFS 大大减轻了我们的工作量，但我们也发现它的生态系统存在一些问题。</p>\n<p>首先，GlusterFS 许多执行脚本和功能需要手动编写定时任务。特别是在添加新存储时，它还会有一些额外要求，例如需要按特定倍数增加节点。此外，像克隆、数据同步等操作的支持也相对较弱，导致我们在使用过程中频繁查阅文档，且许多操作并不稳定。例如，使用 FIO 等工具进行测速时，结果并不总是可靠。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p><strong>更为严重的问题是，当存储的小文件数量达到一定规模时，GlusterFS 的性能会急剧下降</strong>。举个例子，一个模型可能会生成 100 张图片，若有 1000 万个模型，就会产生 10 亿张图片。GlusterFS 在后期的寻址变得极为困难，尤其是小文件过多时，性能会显著下降，导致系统崩溃。</p>\n<h3 id=\"最终选型cephfs-vs-juicefs\">最终选型：CephFS vs JuiceFS</h3>\n<p>随着存储需求的增加，我们决定转向可持续性更好的方案。在评估了多种方案后，我们主要对比了 CephFS 和 JuiceFS。虽然 Ceph 被广泛使用，但通过自己的实践和对比文档，我们发现 Ceph 的运维和管理成本非常高，尤其对于我们这样的小团队来说，处理这些复杂的运维任务显得尤为困难。</p>\n<p>JuiceFS 有两个原生自带的特性非常符合我们的需求。<strong>首先是客户端数据缓存功能</strong>。对于我们的模型训练集群，通常会配备高性能的 NVMe 存储。如果能够充分利用客户端的缓存，便能显著加速模型训练，并减少对 JuiceFS 存储的压力。</p>\n<p><strong>其次，JuiceFS 对 S3 的兼容性对我们也至关重要</strong>。由于我们基于存储开发了一些可视化平台用于数据标注、整理和统计，S3 兼容性使得我们能够快速进行网页开发，支持可视化和数据统计操作等功能。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h2 id=\"03-基于-juicefs-的存储平台实践\">03 基于 JuiceFS 的存储平台实践</h2>\n<h3 id=\"元数据引擎选择与拓扑\">元数据引擎选择与拓扑</h3>\n<p>JuiceFS 采用的是元数据与数据分离的架构，有多种元数据引擎可供选择。我们首先快速验证了 Redis 存储方案，官方提供了详细的文档支持。Redis 的优势在于其轻量化，配置过程通常只需一天或半天时间，数据迁移也相对顺利。<strong>然而，当小文件数量超过 1 亿时，Redis 的速度和性能会显著下降</strong>。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>正如之前提到的，每个模型可能会渲染出 100 张图片，再加上其他杂项文件，导致小文件的数量急剧增加。虽然我们可以通过打包小文件来减轻问题，但一旦打包后进行修改或可视化操作，复杂性就大大增加。因此，我们希望能够保留原始的小图片文件，以便后续处理。</p>\n<p>随着文件数量的增加，很快超出 Redis 的处理能力，我们决定将存储系统迁移到 TiKV 和 Kubernetes 组合上。TiKV 与 K8s 的组合能够为我们提供更高可用的元数据存储方案。此外，通过基准测试我们发现，尽管 TiKV 的性能稍逊一筹，但差距并不显著，且相较于 Redis，它对小文件的支持更好。我们也咨询过 JuiceFS 的工程师，了解到 Redis 在集群模式下的扩展性较差，于是我们准备切换到 TiKV。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h3 id=\"最新架构juicefs--tikv--seaweedfs\">最新架构：JuiceFS + TiKV + SeaweedFS</h3>\n<p>我们使用了 JuiceFS 来管理对象存储。TiKV 和 K8s 来搭建元数据存储系统。对象存储部分使用了 SeaweedFS，这使得我们能够快速扩展存储规模，且无论是小数据还是大数据，访问速度都很快。此外，我们的对象存储分布在多个平台：包括本地存储、阿里云存储以及国外的 R2 和 Amazon 对象存储。通过 JuiceFS，我们能够将这些不同存储系统集成起来，并提供一个统一的接口。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>为了更好地管理系统资源，我们在 K8s 上搭建了资源监控平台。当前系统由大约 60 台 Linux 机器和若干 Windows 机器组成，负责渲染和数据处理任务。我们对读取稳定性进行了监控，结果显示，即使是多台异构服务器同时进行读取操作，整个系统的 I/O 性能依然非常稳定，基本能够充分利用带宽资源。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h3 id=\"实践中遇到的问题\">实践中遇到的问题</h3>\n<p>在优化存储方案的过程中，我们最初尝试了 EC（纠删码） 存储方案，旨在减少存储需求并提升效率。然而，在大规模数据迁移中，EC 存储的计算速度较慢，并且在高吞吐量和频繁数据变化的场景下，性能表现不佳，尤其与 SeaweedFS 结合时，存在性能瓶颈。基于这些问题，我们决定放弃 EC 存储，转而采用副本存储方案。</p>\n<p>我们设置了独立服务器并配置了定时任务，以进行大数据量的元数据备份。在 TiKV 中，我们实现了冗余副本机制，采用了多个副本方案来确保数据的完整性。同时，在对象存储方面，我们采用了双副本编码来进一步提高数据可靠性。虽然副本存储能够有效保证数据冗余和高可用性，但由于处理 PB 级数据和大量增量数据，存储成本依然较高。未来，我们可能会考虑进一步优化存储方案，以降低存储成本。</p>\n<p>另外，我们也发现当使用全闪存服务器 + JuiceFS 并未带来显著的性能提升。瓶颈主要出现在网络带宽和延迟上。因此，我们计划在后期考虑使用 InfiniBand（IB）连接存储服务器和训练服务器，以最大化资源利用效率。</p>\n<h2 id=\"04-小结\">04 小结</h2>\n<p>在使用 GlusterFS 时，我们每天最多只能处理 20 万个模型；<strong>而切换到 JuiceFS 后，处理能力大幅提升，日均数据处理能力增加了 2.5 倍，小文件吞吐能力也显著提高，特别是在存储量达到 70% 后，系统仍能保持稳定运行</strong>。此外，扩容也非常便捷，而之前的架构，扩容过程非常繁琐，操作起来比较麻烦。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>最后再总结一下 JuiceFS 在三维生成任务中表现出来的优势：</p>\n<ul>\n<li>\n<p><strong>小文件性能</strong>： 小文件处理能力是一个关键点，JuiceFS 依然提供了一个较好的解决方案。</p>\n</li>\n<li>\n<p><strong>跨平台特性</strong>： 跨平台支持非常重要。我们发现有些数据只能在 Windows 软件中打开，因此需要同时在 Windows 和 Linux 系统上处理相同的数据，并在同一个挂载节点上进行读写。这种需求使得跨平台的特性尤为关键，JuiceFS 的设计很好地解决了这一问题。</p>\n</li>\n<li>\n<p><strong>低运维成本</strong>： JuiceFS 的运维成本极低。配置完成后，只需要进行一些简单的测试和节点的管理（例如，丢弃某些节点并监控鲁棒性）。我们在迁移数据时花费了大约半年的时间，到目前为止并未遇到太大的问题。</p>\n</li>\n<li>\n<p><strong>本地缓存机制</strong>： 之前，如果想使用本地缓存，我们需要手动在代码中实现本地缓存逻辑，但 JuiceFS 提供了非常方便的本地缓存机制，通过设置挂载参数来优化训练场景的性能。</p>\n</li>\n<li>\n<p><strong>迁移成本低</strong>： 尤其是在迁移小文件时，我们发现使用 JuiceFS 进行元数据和对象存储的迁移非常方便，节省了我们大量时间和精力。相比之下，之前使用其他存储系统迁移时，过程非常痛苦。</p>\n</li>\n</ul>\n<p>综上所述，JuiceFS 在大规模数据处理中的表现非常出色，提供了高效、稳定的存储解决方案。它不仅简化了存储管理和扩容过程，还大大提升了系统性能，让我们能够更加专注于核心任务的推进。</p>\n<p>此外，官方提供一些工具也非常便捷，例如我们使用 Sync 在处理小文件迁移时，效率极高。在没有额外性能优化的情况下，我们成功迁移了 500TB 的数据，其中包含大量的小数据和图片文件，迁移时间不到 5 天，结果超出我们的预期。</p>\n<p>我们希望本文中的一些实践经验，能为正在面临类似问题的开发者提供参考，如果有其他疑问欢迎加入&nbsp;<a href=\"https://juicefs.com/zh-cn/\" rel=\"noopener nofollow\" target=\"_blank\">JuiceFS 社区</a>与大家共同交流。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-07 16:55</span>&nbsp;\n<a href=\"https://www.cnblogs.com/JuiceData\">JuiceFS</a>&nbsp;\n阅读(<span id=\"post_view_count\">57</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "51单片机__LED相关",
      "link": "https://www.cnblogs.com/WIRO/p/19452806",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/WIRO/p/19452806\" id=\"cb_post_title_url\" title=\"发布于 2026-01-07 16:06\">\n    <span>51单片机__LED相关</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"51单片机__led相关\">51单片机__LED相关</h1>\n<h2 id=\"单片机介绍\">单片机介绍</h2>\n<p>单片机，英文Micro Controller Unit，简称MCU<br />\n内部集成了CPU、RAM、ROM、定时器、中断系统、通讯接口等一系列电脑的常用硬件功能<br />\n单片机的任务是信息采集（依靠传感器）、处理（依靠CPU）和硬件设备（例如电机，LED等）的控制<br />\n单片机跟计算机相比，单片机算是一个袖珍版计算机，一个芯片就能构成完整的计算机系统。但在性能上，与计算机相差甚远，但单片机成本低、体积小、结构简单，在生活和工业控制领域大有所用<br />\n同时，学习使用单片机是了解计算机原理与结构的最佳选择</p>\n<h2 id=\"单片机应用\">单片机应用</h2>\n<p>单片机的使用领域已十分广泛，如智能仪表、实时工控、通讯设备、导航系统、家用电器等。各种产品一旦用上了单片机，就能起到使产品升级换代的功效，常在产品名称前冠以形容词——“智能型”，如智能型洗衣机等。</p>\n<p><img alt=\"image-20260107113142288\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260107160519528-2082922721.png\" /></p>\n<h2 id=\"stc89c52单片机\">STC89C52单片机</h2>\n<p><img alt=\"image-20260107113244328\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260107160519123-1391531477.png\" /></p>\n<p><img alt=\"image-20260107113324739\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260107160519527-1511351430.png\" /></p>\n<p><img alt=\"image-20260107113519962\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260107160519188-402559776.png\" /></p>\n<p><img alt=\"image-20260107113540042\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260107160519297-1849899687.png\" /></p>\n<p><img alt=\"image-20260107113612706\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260107160519274-1889121421.png\" /></p>\n<h2 id=\"开发板原理图和复位单路\">开发板原理图和复位单路</h2>\n<p><img alt=\"image-20260107113715018\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260107160519312-2037859992.png\" /></p>\n<p><img alt=\"image-20260107114043371\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260107160519369-1523164322.png\" /></p>\n<p><img alt=\"image-20260107114127756\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260107160519480-912853277.png\" /></p>\n<h1 id=\"创建工程并实现led控制\">创建工程并实现LED控制</h1>\n<h2 id=\"1点亮led灯\">1）点亮LED灯</h2>\n<p><img alt=\"image-20260107115032547\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260107160519089-1326428079.png\" /></p>\n<p>观察原理图，LED灯低电平点亮，下面开始编写代码：</p>\n<pre><code class=\"language-c\">#include &lt;REGX52.H&gt;\n\nvoid main()\n{\n\tP2 = 0;\n}\n\n// 现象:所有LED灯均被点亮\n</code></pre>\n<h2 id=\"2实现led_1灯闪烁\">2）实现LED_1灯闪烁</h2>\n<p><strong>延时方法与实现：</strong></p>\n<p>通过单片机驱动外围显示电路，为了能够让人眼识别到所显示内容的变化，需要保证所显示的内容有所停留。在单片机中，实现这一效果有两种方式，一种是通过C语言编写一段延时效果的程序或者子程序，实现该目的。另一种是调用单片机自带的定式/计数器，这里暂时使用第一种方式。</p>\n<p>使用单片机烧录软件AiCube-ISP-v6.96A，生成一段500ms的延时函数。</p>\n<pre><code class=\"language-c\">// 延时500ms\nvoid Delay500ms(void)\t//@11.0592MHz\n{\n\tunsigned char data i, j, k;\n\n\t_nop_();\n\ti = 4;\n\tj = 129;\n\tk = 119;\n\tdo\n\t{\n\t\tdo\n\t\t{\n\t\t\twhile (--k);\n\t\t} while (--j);\n\t} while (--i);\n}\n</code></pre>\n<p><img alt=\"image-20260107120433086\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260107160519161-1654264043.png\" /></p>\n<pre><code class=\"language-c\">#include &lt;REGX52.H&gt;\n#include &lt;INTRINS.H&gt;  // 解决 _nop_ 报错\n\n// 延时500ms\nvoid Delay500ms(void)\t//@11.0592MHz\n{\n\tunsigned char data i, j, k;\n\n\t_nop_();\n\ti = 4;\n\tj = 129;\n\tk = 119;\n\tdo\n\t{\n\t\tdo\n\t\t{\n\t\t\twhile (--k);\n\t\t} while (--j);\n\t} while (--i);\n}\n\nvoid main()\n{\n\twhile(1)\n\t{\t\n\t\tP2 = 0xFE;     // 1111 1110\n\t\tDelay500ms();  // 延时0.5s\n\t\tP2 = 0xFF;     // 1111 1111\n\t\tDelay500ms();  // 延时0.5s\n\t}\n}\n\n// 现象: LED_1 闪烁，其他LED灯不亮\n</code></pre>\n<h2 id=\"3实现led流水灯\">3）实现LED流水灯</h2>\n<h3 id=\"第一种方式使用数组实现流水灯效果\"><strong>第一种方式：使用数组实现流水灯效果</strong></h3>\n<pre><code class=\"language-c\">#include &lt;REGX52.H&gt;\n#include &lt;INTRINS.H&gt;  // 解决 _nop_ 报错\n\n\n// 延时500ms\nvoid Delay500ms(void)\t//@11.0592MHz\n{\n\tunsigned char data i, j, k;\n\n\t_nop_();\n\ti = 4;\n\tj = 129;\n\tk = 119;\n\tdo\n\t{\n\t\tdo\n\t\t{\n\t\t\twhile (--k);\n\t\t} while (--j);\n\t} while (--i);\n}\n\n// 定义流水灯数组\nunsigned char LedCode[] = {0xFE,0xFD,0xFB,0xF7,0Xef,0xDF,0xBF,0x7F};\n\nvoid main()\n{\n\tunsigned char i;\n\twhile(1)\n\t{\t\n\t\tfor(i = 0;i &lt; 8;i ++)\n\t\t{\n\t\t\tP2 = LedCode[i];\n\t\t\tDelay500ms();\n\t\t}\n\t}\n}\n\n// 现象：LED灯从低到高依次点亮\n\n//附加内容：\n//0xFE  1111 1110\n//0xFD  1111 1101\n//0xFB  1111 1011\n//0xF7  1111 0111\n//0Xef  1110 1111\n//0xDF  1101 1111\n//0xBF  1011 1111\n//0x7F  0111 1111\n</code></pre>\n<h3 id=\"第二种方式左右移运算符实现\"><strong>第二种方式：左右移运算符实现</strong></h3>\n<pre><code class=\"language-c\">#include &lt;REGX52.H&gt;\n#include &lt;INTRINS.H&gt;  // 解决 _nop_ 报错\n\n\n// 延时500ms\nvoid Delay500ms(void)\t//@11.0592MHz\n{\n\tunsigned char data i, j, k;\n\n\t_nop_();\n\ti = 4;\n\tj = 129;\n\tk = 119;\n\tdo\n\t{\n\t\tdo\n\t\t{\n\t\t\twhile (--k);\n\t\t} while (--j);\n\t} while (--i);\n}\n\n\nvoid main() {\n    unsigned char Led = 0x01; // 0000 0001\n    \n    while(1) {\n        P2 = ~Led;      // 取反，输出到P2端口\n        Delay500ms();   // 延时500ms\n        \n        // 使用左移运算符\n        Led = Led &lt;&lt; 1;\n        \n        // 如果移到最右边，重新从最左边开始\n        if(Led == 0x00) {\n            Led = 0x01;\n        }\n    }\n}\n\n// 现象：LED灯从低到高依次点亮\n</code></pre>\n<h3 id=\"第三种方式循环左右移函数的调用\"><strong>第三种方式：循环左右移函数的调用</strong></h3>\n<h3 id=\"1-cror---循环右移函数\">1. <strong><em>cror</em>() - 循环右移函数</strong></h3>\n<p><strong>头文件：</strong> <code>#include &lt;intrins.h&gt;</code><br />\n<strong>原型：</strong> <code>unsigned char _cror_(unsigned char val, unsigned char n);</code></p>\n<p><strong>功能：</strong> 将 8 位数据循环右移 n 位，移出的位从左边补入</p>\n<p><strong>示例：</strong></p>\n<pre><code class=\"language-c\">unsigned char data = 0x81;  // 二进制：10000001\ndata = _cror_(data, 1);     // 结果：0xC0 (11000000)\n// 原：10000001 → 右移1位 → 11000000\n</code></pre>\n<p><img alt=\"image-20260107153044727\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260107160519436-108965670.png\" /></p>\n<h3 id=\"2-crol---循环左移函数\">2. <strong><em>crol</em>() - 循环左移函数</strong></h3>\n<p><strong>头文件：</strong> <code>#include &lt;intrins.h&gt;</code><br />\n<strong>原型：</strong> <code>unsigned char _crol_(unsigned char val, unsigned char n);</code></p>\n<p><strong>功能：</strong> 将 8 位数据循环左移 n 位，移出的位从右边补入</p>\n<p><strong>示例：</strong></p>\n<pre><code class=\"language-c\">unsigned char data = 0x81;  // 二进制：10000001\ndata = _crol_(data, 1);     // 结果：0x03 (00000011)\n// 原：10000001 → 左移1位 → 00000011\n</code></pre>\n<p><img alt=\"image-20260107153844168\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260107160519302-1190082079.png\" /></p>\n<p>流水灯应用示例：</p>\n<pre><code class=\"language-c\">#include &lt;REGX52.H&gt;\n#include &lt;INTRINS.H&gt;  // 解决 _nop_ 报错\n\n\n// 延时500ms\nvoid Delay500ms(void)\t//@11.0592MHz\n{\n\tunsigned char data i, j, k;\n\n\t_nop_();\n\ti = 4;\n\tj = 129;\n\tk = 119;\n\tdo\n\t{\n\t\tdo\n\t\t{\n\t\t\twhile (--k);\n\t\t} while (--j);\n\t} while (--i);\n}\n\n\nvoid main() \n\t{\n\t\tunsigned char aa;\n\t\taa = 0xFE;  // 1111 1110\n\t\t\n\t\twhile(1)\n\t\t{\n\t\t\tP2 = aa;\n\t\t\tDelay500ms();\n\t\t\taa = _crol_(aa,1);  // 循环左移函数\n\t\t}\n\n\t}\n\n// 现象：LED灯从低到高依次点亮\n</code></pre>\n<p><strong>注意：</strong> 这两个函数是 C51 编译器特有，仅适用于 51 单片机开发。</p>\n<h2 id=\"综合练习双向流水灯\">综合练习：双向流水灯</h2>\n<pre><code class=\"language-c\">#include &lt;REGX52.H&gt;\n#include &lt;INTRINS.H&gt;  // 包含移位函数头文件\n\n// 延时500ms\nvoid Delay500ms(void)\t//@11.0592MHz\n{\n\tunsigned char data i, j, k;\n\n\t_nop_();\n\ti = 4;\n\tj = 129;\n\tk = 119;\n\tdo\n\t{\n\t\tdo\n\t\t{\n\t\t\twhile (--k);\n\t\t} while (--j);\n\t} while (--i);\n}\n\nvoid main() \n{\n    unsigned char aa;\n    unsigned char direction = 0;  // 0:左移, 1:右移\n    unsigned char counter = 0;    // 计数左移/右移的次数\n    \n    aa = 0xFE;  // 1111 1110，第一个灯亮\n    \n    while(1)\n    {\n        P2 = aa;\n        Delay500ms();\n        \n        // 左移8次后改为右移\n        if(direction == 0)\n        {\n            aa = _crol_(aa, 1);  // 循环左移\n            counter++;\n            \n            if(counter &gt;= 7)  // 左移7次后（共8个状态）\n            {\n                direction = 1;  // 改为右移方向\n                counter = 0;    // 计数器清零\n            }\n        }\n        // 右移8次后改为左移\n        else\n        {\n            aa = _cror_(aa, 1);  // 循环右移\n            counter++;\n            \n            if(counter &gt;= 7)  // 右移7次后（共8个状态）\n            {\n                direction = 0;  // 改为左移方向\n                counter = 0;    // 计数器清零\n            }\n        }\n    }\n}\n\n// 现象：LED左右依次点亮\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-07 16:06</span>&nbsp;\n<a href=\"https://www.cnblogs.com/WIRO\">Q&amp;25</a>&nbsp;\n阅读(<span id=\"post_view_count\">132</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "XAML Studio 已正式开源",
      "link": "https://www.cnblogs.com/shanyou/p/19452660",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/shanyou/p/19452660\" id=\"cb_post_title_url\" title=\"发布于 2026-01-07 15:47\">\n    <span>XAML Studio 已正式开源</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>微软开发者博客于 2026 年 1 月 6 日正式宣布(<a href=\"https://devblogs.microsoft.com/ifdef-windows/xaml-studio-is-now-open-sourced/\" rel=\"noopener nofollow\" title=\"https://devblogs.microsoft.com/ifdef-windows/xaml-studio-is-now-open-sourced/\">https://devblogs.microsoft.com/ifdef-windows/xaml-studio-is-now-open-sourced/</a>)，<strong>XAML Studio 已正式开源</strong>，并成为了 .NET 基金会（.NET Foundation）旗下的一个种子项目。</p>\n<h5><span>1. 什么是 XAML Studio？</span></h5>\n<p><span>XAML Studio 是一款专为 <strong>WinUI</strong> 开发者打造的辅助工具，最初是 Microsoft Garage（微软车库）的一个项目。它允许开发者在不创建完整工程的情况下，快速进行 XAML 界面原型设计和交互调试。</span></p>\n<p><span>其核心功能包括：</span></p>\n<ul>\n<li>\n<p><span><span style=\"font-size: medium;\"><strong>实时编辑与预览</strong>：即时查看 XAML 代码的效果。</span></span></p>\n</li>\n<li>\n<p><span><span style=\"font-size: medium;\"><strong>绑定调试器 (Binding Debugger)</strong>：直观排查数据绑定问题。</span></span></p>\n</li>\n<li>\n<p><span><span style=\"font-size: medium;\"><strong>数据上下文编辑器</strong>：快速模拟测试数据。</span></span></p>\n</li>\n<li>\n<p><span><span style=\"font-size: medium;\"><strong>IntelliSense 与文档工具箱</strong>：提供代码补全和控件查阅。</span></span></p>\n</li>\n</ul>\n<h5><span>2. 开源背景与现状</span></h5>\n<ul>\n<li>\n<p><span><span style=\"font-size: medium;\"><strong>项目历程</strong>：该项目始于 8 年前，一直计划开源，如今终于实现。</span></span></p>\n</li>\n<li>\n<p><span><span style=\"font-size: medium;\"><strong>V2 版本</strong>：目前开源的是正在开发中的 <strong>XAML Studio v2</strong>。相比商店里的 1.1 版本，v2 采用了全新的界面，并针对 WinUI 3 进行了优化。</span></span></p>\n</li>\n<li>\n<p><span><span style=\"font-size: medium;\"><strong>社区贡献</strong>：XAML Studio 的许多核心组件早已回馈给社区，例如 <strong>Windows Community Toolkit (WCT)</strong> 中的 <code>SwitchPresenter</code>、<code>Sizer</code> 控件（如 <code>GridSplitter</code> 的改进版）以及实验性的 <strong>Adorners（装饰器）</strong> 功能，最初都源于 XAML Studio。</span></span></p>\n</li>\n</ul>\n<h5><span>3. 未来计划</span></h5>\n<ul>\n<li>\n<p><span><span style=\"font-size: medium;\"><strong>开发分支</strong>：开发者目前可以从 GitHub 的 <code>dev</code> 分支获取 v2 版本的源代码并自行构建。</span></span></p>\n</li>\n<li>\n<p><span><span style=\"font-size: medium;\"><strong>正式发布</strong>：开发团队计划在 2026 年晚些时候在 Microsoft Store 发布 v2 的正式稳定版。</span></span></p>\n</li>\n<li>\n<p><span><span style=\"font-size: medium;\"><strong>参与方式</strong>：微软鼓励开发者通过 GitHub 提交反馈、建议或直接贡献代码。</span></span></p>\n</li>\n</ul>\n<p><strong><span>相关资源：</span></strong></p>\n<ul>\n<li>\n<p><span><span style=\"font-size: medium;\"><strong>GitHub 仓库</strong>：</span></span><a href=\"https://github.com/dotnet/XAMLStudio\" rel=\"noopener nofollow\"><span>dotnet/XamlStudio</span></a>&nbsp;<span>。</span></p>\n</li>\n<li>\n<p><span><span style=\"font-size: medium;\"><strong>官方博客全文</strong>：</span></span><a href=\"https://devblogs.microsoft.com/ifdef-windows/xaml-studio-is-now-open-sourced/\" rel=\"noopener nofollow\"><span>XAML Studio is now Open Sourced</span></a></p>\n</li>\n</ul>\n<p>这对 WinUI 开发者来说是一个重要的里程碑，不仅工具本身变得透明、可定制，也预示着 WinUI 生态系统的进一步开放。</p>\n</div>\n<div id=\"MySignature\">\n    <p>欢迎大家扫描下面二维码成为我的客户，扶你上云</p>\n<img src=\"https://images.cnblogs.com/cnblogs_com/shanyou/57459/o_220125090408_%E9%82%80%E8%AF%B7%E4%BA%8C%E7%BB%B4%E7%A0%81-258px.jpeg\" width=\"170\" />\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-07 15:47</span>&nbsp;\n<a href=\"https://www.cnblogs.com/shanyou\">张善友</a>&nbsp;\n阅读(<span id=\"post_view_count\">681</span>)&nbsp;\n评论(<span id=\"post_comment_count\">4</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【终极踩坑指南】Windows 10上MsQuic证书加载失败？坑不在证书，而在Schannel！",
      "link": "https://www.cnblogs.com/haibindev/p/19452652",
      "published": "",
      "description": "<div class=\"postTitle\">\n\t\t<h1><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/haibindev/p/19452652\" id=\"cb_post_title_url\" title=\"发布于 2026-01-07 15:45\">\n    <span>【终极踩坑指南】Windows 10上MsQuic证书加载失败？坑不在证书，而在Schannel！</span>\n    \n\n</a>\n</h1>\n\t</div>\n\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        摘要：如果你在Windows 10上被 ConfigurationLoadCredential failed, 0x80070490 或 E_NOINTERFACE 错误折磨良久，试遍所有证书方案仍无解，那么恭喜，本文就是你的终点站。真正原因极可能是：新版MsQuic已默认放弃对Windows 10上Schannel的支持。无需再折腾证书，切换至OpenSSL后端即可一键解决。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"终极踩坑指南windows-10上msquic证书加载失败坑不在证书而在schannel\">【终极踩坑指南】Windows 10上MsQuic证书加载失败？坑不在证书，而在Schannel！</h1>\n<blockquote>\n<p><strong>摘要</strong>：如果你在Windows 10上被 <code>ConfigurationLoadCredential failed, 0x80070490</code> 或 <code>E_NOINTERFACE</code> 错误折磨良久，试遍所有证书方案仍无解，那么恭喜，本文就是你的终点站。真正原因极可能是：<strong>新版MsQuic已默认放弃对Windows 10上Schannel的支持</strong>。无需再折腾证书，切换至OpenSSL后端即可一键解决。</p>\n</blockquote>\n<h3 id=\"一问题现象一个极具迷惑性的错误\"><strong>一、问题现象：一个极具迷惑性的错误</strong></h3>\n<p>环境：Windows 10 22H2，使用GitHub主线版本MsQuic编译QUIC Server。</p>\n<p>在调用 <code>MsQuic-&gt;ConfigurationLoadCredential(...)</code> 时，稳定失败，返回错误：</p>\n<pre><code>ConfigurationLoadCredential failed, 0x80070490\n</code></pre>\n<p>或者：</p>\n<pre><code>E_NOINTERFACE\n</code></pre>\n<p><strong>所有迹象都指向证书问题</strong>，于是开始了漫长的“踩坑”之旅。</p>\n<h3 id=\"二排查弯路我被证书问题带偏的全过程\"><strong>二、排查弯路：我被“证书问题”带偏的全过程</strong></h3>\n<p>以下是我的排查流水账，几乎试遍了Windows下所有证书方案：</p>\n<ol>\n<li>\n<p><strong>证书哈希（官方推荐）</strong></p>\n<pre><code class=\"language-cpp\">QUIC_CERTIFICATE_HASH CertHash{};\nmemcpy(CertHash.ShaHash, hashbuf_.data(), 20);\nCredConfig.Type = QUIC_CREDENTIAL_TYPE_CERTIFICATE_HASH;\n</code></pre>\n<p><strong>结果</strong>：<code>HRESULT_FROM_WIN32(ERROR_NOT_FOUND)</code>。确认证书在本地计算机存储、有私钥、验证通过，但就是不行。</p>\n</li>\n<li>\n<p><strong>哈希存储（显式指定仓库）</strong></p>\n<pre><code class=\"language-cpp\">strcpy_s(CertHashStore.StoreName, \"LocalMachine\\\\My\");\nCredConfig.Type = QUIC_CREDENTIAL_TYPE_CERTIFICATE_HASH_STORE;\n</code></pre>\n<p><strong>结果</strong>：<code>E_INVALIDARG</code>。</p>\n</li>\n<li>\n<p><strong>怀疑证书生成方式</strong><br />\n怀疑OpenSSL生成的证书不行，换用PowerShell生成“纯正”的CNG证书：</p>\n<pre><code class=\"language-powershell\">New-SelfSignedCertificate -Provider \"Microsoft Software Key Storage Provider\" ...\n</code></pre>\n<p><strong>结果</strong>：失败依旧。</p>\n</li>\n<li>\n<p><strong>终极尝试：PFX文件</strong></p>\n<pre><code class=\"language-cpp\">CredConfig.Type = QUIC_CREDENTIAL_TYPE_CERTIFICATE_FILE_PROTECTED;\n</code></pre>\n<p><strong>结果</strong>：熟悉的 <code>E_NOINTERFACE</code>。</p>\n</li>\n<li>\n<p><strong>关键转折点：官方示例也挂了</strong><br />\n当怀疑人生时，直接测试MsQuic自带的 <code>quicsample.exe</code>：</p>\n<pre><code class=\"language-bash\">quicsample.exe -server -cert_hash:&lt;your_thumbprint&gt;\n</code></pre>\n<p><strong>同样失败！</strong> 这证明问题与我的代码无关，是<strong>环境或库本身的问题</strong>。</p>\n</li>\n</ol>\n<h3 id=\"三真相揭露不是证书的锅是schannel掉了链子\"><strong>三、真相揭露：不是证书的锅，是Schannel掉了链子</strong></h3>\n<p>所有排查都失效后，我将目光从证书移开，最终锁定核心矛盾：</p>\n<blockquote>\n<p><strong>当前较新版本的MsQuic，在Windows 10系统上，其默认的Schannel TLS后端可能已无法正常加载服务器证书。</strong></p>\n</blockquote>\n<p>这是一个<strong>官方文档未明确标注、但实际存在的兼容性断点</strong>。错误 <code>0x80070490</code> (找不到元素) 和 <code>E_NOINTERFACE</code> 极具误导性，让你在证书的迷宫里无限打转，而真正的出口是：<strong>更换TLS后端</strong>。</p>\n<h3 id=\"四一行命令解决切换到openssl后端\"><strong>四、一行命令解决：切换到OpenSSL后端</strong></h3>\n<p><strong>解决方案简单到令人发指：</strong></p>\n<ol>\n<li>\n<p><strong>使用OpenSSL后端重新编译MsQuic</strong>：</p>\n<pre><code class=\"language-bash\"># 在MsQuic仓库目录下执行\n.\\scripts\\build.ps1 -Config Debug -Arch x64 -Tls openssl\n</code></pre>\n</li>\n<li>\n<p><strong>使用OpenSSL生成的证书</strong>（如PEM或PFX格式）。</p>\n</li>\n<li>\n<p>再次运行你的程序或 <code>quicsample</code>：</p>\n<pre><code class=\"language-bash\">quicsample.exe -server -cert_file:server.pfx -key_file:key.pem\n</code></pre>\n<p><strong>✅ 服务器顺利启动，问题解决。</strong></p>\n</li>\n</ol>\n<h3 id=\"五为什么会有这个坑深度分析\"><strong>五、为什么会有这个坑？（深度分析）</strong></h3>\n<p>这个问题在 <strong>Windows 11 或 Windows Server 2022</strong> 上通常不会出现，因为它们内置了完整的、支持最新QUIC规范的Schannel实现。</p>\n<p>而 <strong>Windows 10</strong>（尤其是某些版本）的Schannel对MsQuic新版本所需功能的支持可能不完整或存在缺陷。MsQuic在更新过程中，可能默认启用了某些Windows 10上Schannel无法满足的特性或API，导致证书加载路径从根源上失败。</p>\n<p><strong>因此，这本质上是一个平台兼容性断档问题。</strong> 对于开发者而言，表象是证书错误，根因是系统组件落后于开发库的演进。</p>\n<h3 id=\"六总结与建议\"><strong>六、总结与建议</strong></h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">场景</th>\n<th style=\"text-align: left;\">推荐动作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>在Windows 10上开发/部署MsQuic</strong></td>\n<td style=\"text-align: left;\"><strong>直接使用OpenSSL后端</strong>，一劳永逸。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">遇到<code>0x80070490</code>或<code>E_NOINTERFACE</code>错误</td>\n<td style=\"text-align: left;\">首要怀疑<strong>TLS后端兼容性</strong>，而非证书本身。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">需要跨平台（Windows/Linux）一致性</td>\n<td style=\"text-align: left;\">选择OpenSSL后端更能保证行为一致。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>目标环境为Windows 11/Server 2022+</strong></td>\n<td style=\"text-align: left;\">可放心使用默认Schannel，性能更佳。</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<p><strong>拓展思考</strong>：对于从事<strong>视频流传输</strong>（如基于QUIC优化RTMP、HLS延迟）的开发者来说，理解底层网络库的这些平台细微差别至关重要。一次成功的协议升级，往往从顺利编译和部署开始。希望这篇踩坑记录能助你畅通无阻。</p>\n<p>（本文基于Windows 10 22H2家庭中文版、x64架构、MsQuic GitHub主线版本测试验证）</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/254714/202307/254714-20230701143418754-1351786962.jpg\" /></p>\n<p><strong>合作请加WX：hbstream</strong><br />\n<strong>合作请加作者hbstream（<a href=\"http://haibindev.cnblogs.com\" target=\"_blank\">http://haibindev.cnblogs.com</a>），转载请注明作者和出处</strong></p>\n\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-01-07 15:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/haibindev\">haibindev</a>&nbsp;\n阅读(<span id=\"post_view_count\">46</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "NIVIDIA高性能计算CUDA笔记（三） cuFFT的简介及实现案例",
      "link": "https://www.cnblogs.com/GeophysicsWorker/p/19452487",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/GeophysicsWorker/p/19452487\" id=\"cb_post_title_url\" title=\"发布于 2026-01-07 15:21\">\n    <span>NIVIDIA高性能计算CUDA笔记（三） cuFFT的简介及实现案例</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        cuFFT是NVIDIA提供的GPU加速的Fourier变换FFT库，能极大提升涉及FFT计算的科学计算、信号处理和深度学习等任务的速度。本笔记就cufft进行简单介绍并给出一个一维信号的fft变换示例\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"nividia高性能计算cuda笔记三-cufft的简介及实现案例\">NIVIDIA高性能计算CUDA笔记（三） cuFFT的简介及实现案例</h1>\n<h2 id=\"1-cufft库的简介introduction-of-cufft-libaray\">1. cuFFT库的简介（Introduction of cuFFT libaray）</h2>\n<p>​      Fourier变换是数字信号处理领域一个很重要的数学变换，它用来实现将信号实现将信号从时域到频域的变换，在物理学、数论、组合数学、信号处理、概率、统计、密码学、声学、光学等领域有广泛的应用。离散傅里叶变换(Discrete Fourier Transform，DFT)是连续傅里叶变换在离散系统中的表示形式，由于DFT的计算量很大，因此在很长一段时间内其应用受到了很大的限制。20世纪60年代（1965年）由Cooley和Tukey提出了快速傅里叶变换(Fast Fourier Transform，FFT)算法，它是DFT的快速算法，使得离散傅里叶变换和卷积这类难度很大的计算工作的复杂度从N2量级降到了Nlog2N量级，大大提高了DFT的运算速度，从而使DFT在实际应用中得到了广泛的应用。</p>\n<p>​       cuFFT是NVIDIA提供的GPU加速的Fourier变换FFT库，能极大提升涉及FFT计算的科学计算、信号处理和深度学习等任务的速度。下表概括了器主要特征和应用场景：</p>\n<table>\n<thead>\n<tr>\n<th>cuFFT的特征</th>\n<th>具体描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>基本功能</td>\n<td>提供GPU加速的1D、2D、3D复数/实数FFT计算</td>\n</tr>\n<tr>\n<td>核心优势</td>\n<td>相比CPU实现，利用GPU并行性可获得显著加速</td>\n</tr>\n<tr>\n<td>编程接口</td>\n<td>提供类似的FFTW的API，便于熟悉CPU FFT的用户迁移</td>\n</tr>\n<tr>\n<td>高级功能</td>\n<td>支持批量执行、流异步、半/单/双精度、多GPU计算</td>\n</tr>\n<tr>\n<td>主要应用领域</td>\n<td>深度学习、计算物理学、医学成像、信号处理等</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-基于cufft库的fourier变换步骤workflow-of-fourier-transform-based-cufft\">2. 基于cuFFT库的Fourier变换步骤（workflow of Fourier Transform based cuFFT）</h2>\n<p>在CUDA上进行傅里叶变换一般需要做以下几步工作：</p>\n<ol>\n<li>在主机端，准备输入数据；</li>\n<li>在GPU设备端上分配内存，并将数据从主机复制到设备；（<code>cudaMalloc</code>,<code>cudaMemcpy</code>的接口 ）</li>\n<li>创建一个<span class=\"math inline\">\\(plan\\)</span>, 调用函数<span class=\"math inline\">\\(cufftPlane1D/cufftPlane2D/cufftPlan3D\\)</span> 可以创建一个简单的Fourier变换。调用函数<span class=\"math inline\">\\(cufftPlanMany\\)</span> 则可以创建支持更多配置操作的变换计划。\n<ul>\n<li><span class=\"math inline\">\\(cufftPlan1d()\\)</span>: 针对单个1维信号</li>\n<li><span class=\"math inline\">\\(cufftPlan2d()\\)</span>:针对单个2维信号</li>\n<li><span class=\"math inline\">\\(cufftPlan3d()\\)</span>:针对单个3维信号</li>\n</ul>\n</li>\n<li>执行<span class=\"math inline\">\\(plane\\)</span>。这一步可以使用<span class=\"math inline\">\\(cufftExecC2C()\\)</span>、<span class=\"math inline\">\\(cufftExecR2C()\\)</span>或<span class=\"math inline\">\\(cufftExecC2R()\\)</span>等函数完成上一步完成<span class=\"math inline\">\\(plane\\)</span>的计算任务。</li>\n<li>执行完成以下若不再需要该<span class=\"math inline\">\\(plan\\)</span>，则调用<span class=\"math inline\">\\(cufftDestroy()\\)</span>函数销毁该<span class=\"math inline\">\\(plan\\)</span> 及为其分配的计算资源。</li>\n</ol>\n<h2 id=\"3-cufft的傅里叶变换api接口类型fourier-transform-types\">3. cuFFT的傅里叶变换API接口类型（Fourier Transform Types）</h2>\n<p>​        <span class=\"math inline\">\\(cuFFT\\)</span> 库实现了三种不同类型的Fourier变换接口分为：<span class=\"math inline\">\\(C2C\\)</span>(复数变换到复数)，<span class=\"math inline\">\\(C2R\\)</span>(复数到实数),  <span class=\"math inline\">\\(R2C\\)</span> (实数到复数)。本质上，这三种转换都可以被看做是复数域到复数域的变换，之所以这样划分，其最主要的考量是性能因素。例如，在一般的数字信号处理中，输入数据是一些离散的实数域上的采样点，这时候对它们做Fourier变换实际上就是<span class=\"math inline\">\\(R2C\\)</span>，根据埃尔米特对称性（Hermitian symmetry)，变换<span class=\"math inline\">\\(X_k=X_{N-k}^{*}\\)</span>, <span class=\"math inline\">\\(*\\)</span> 代表共轭复数。<span class=\"math inline\">\\(cuFFT\\)</span> 的傅里叶变换则利用了这些冗余，将计算量降到最低。</p>\n<p>​       变换执行函数的单精度和双精度版本分别定义如下：</p>\n<table>\n<thead>\n<tr>\n<th>API</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span class=\"math inline\">\\(cufftExecC2C()/cufftExecZ2Z()\\)</span></td>\n<td>单精度/双精度浮点数复数域到复数域的傅里叶变换</td>\n</tr>\n<tr>\n<td><span class=\"math inline\">\\(cufftExecR2C()/cufftExecD2Z()\\)</span></td>\n<td>单精度/双精度浮点数实数域到复数域的傅里叶变换（正变换）</td>\n</tr>\n<tr>\n<td><span class=\"math inline\">\\(cufftExecC2R()/cufftExecZ2D()\\)</span></td>\n<td>单精度/双精度浮点数复数域到实数域的傅里叶变换（逆变换）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"4-数据布局data-layout\">4. 数据布局(Data Layout)</h2>\n<p>​       <span class=\"math inline\">\\(CUFFT\\)</span>库保含若干种数据类型，对于复数有<span class=\"math inline\">\\(cufftComplex/cufftDoubleComplex\\)</span> 两种数据类型，对于实数则分别有<span class=\"math inline\">\\(cufftReal/cufftDouble\\)</span> 两种数据类型 。</p>\n<p>​         根据转换结果的存储位置不同，<span class=\"math inline\">\\(FFT\\)</span>变换可分为就地变换(<span class=\"math inline\">\\(in-place\\)</span>)和外部变换（<span class=\"math inline\">\\(out-place\\)</span>)，前者直接在输入数据进行变换，而后者则会将变换后结果存入新的存储器地址。</p>\n<p>​         就地转换(<span class=\"math inline\">\\(in-place\\)</span>) 支持数据的两种布局：<span class=\"math inline\">\\(native\\)</span> 和 <span class=\"math inline\">\\(padded\\)</span>，前者用于获取最佳性能，而后者则用于与FFTW兼容。</p>\n<p>​         在<span class=\"math inline\">\\(padded\\)</span>布局中输出信号的开始地址与输入信号一样，换句话说，实数域到复数域变换的输入数据和复数域到实数域的输出数据必须被填充。在native布局中则没有填入要求。</p>\n<p>​         输入数据和输出数据的尺寸总结如下：</p>\n<table>\n<thead>\n<tr>\n<th>FFT type</th>\n<th>input data size</th>\n<th>output data size</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span class=\"math inline\">\\(C2C\\)</span></td>\n<td><span class=\"math inline\">\\(X \\space cufftComplex\\)</span></td>\n<td><span class=\"math inline\">\\(X \\space cufftComplex\\)</span></td>\n</tr>\n<tr>\n<td><span class=\"math inline\">\\(C2R\\)</span></td>\n<td><span class=\"math inline\">\\([\\frac{X}{2}]+1 \\space cufftComplex\\)</span></td>\n<td><span class=\"math inline\">\\(X\\)</span> <span class=\"math inline\">\\(cufftReal\\)</span></td>\n</tr>\n<tr>\n<td><span class=\"math inline\">\\(R2C^{*}\\)</span></td>\n<td><span class=\"math inline\">\\(X\\)</span> <span class=\"math inline\">\\(cufftReal\\)</span></td>\n<td><span class=\"math inline\">\\([\\frac{X}{2}]+1 \\space cufftComplex\\)</span></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"5-单个一维信号的fft变换代码实现one-dimension-signal-fft-transfrom\">5. 单个一维信号的FFT变换代码实现（One Dimension SIgnal FFT Transfrom）</h2>\n<p>在本次测试代码中：首先生成一维的随机信号，利用cufft 先进行正变换，然后逆变换，并判定逆变换后结果与原输入信号判断是否相等。</p>\n<pre><code class=\"language-C\">#include &lt;iostream&gt;\n#include &lt;time.h&gt;\n#include \"cuda_runtime.h\"\n#include \"device_launch_parameters.h\"\n#include &lt;cufft.h&gt;\n\n#define NX 3335 // 有效数据个数\n#define N 5335 // 补0之后的数据长度\n#define BATCH 1\n#define BLOCK_SIZE 1024\nusing std::cout;\nusing std::endl;\n\n\n/**\n* 功能：判断两个 cufftComplex 数组的是否相等\n* 输入：idataA 输入数组A的头指针\n* 输入：idataB 输出数组B的头指针\n* 输入：size 数组的元素个数\n* 返回：true | false\n*/\nbool IsEqual(cufftComplex *idataA, cufftComplex *idataB, const int size)\n{\n    for (int i = 0; i &lt; size; i++)\n    {\n        if (abs(idataA[i].x - idataB[i].x) &gt; 0.000001 || abs(idataA[i].y - idataB[i].y) &gt; 0.000001)\n            return false;\n    }\n\n    return true;\n}\n\n\n\n/**\n* 功能：实现 cufftComplex 数组的尺度缩放，也就是乘以一个数\n* 输入：idata 输入数组的头指针\n* 输出：odata 输出数组的头指针\n* 输入：size 数组的元素个数\n* 输入：scale 缩放尺度\n*/\nstatic __global__ void cufftComplexScale(cufftComplex *idata, cufftComplex *odata, const int size, float scale)\n{\n    const int threadID = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (threadID &lt; size)\n    {\n        odata[threadID].x = idata[threadID].x * scale;\n        odata[threadID].y = idata[threadID].y * scale;\n    }\n}\n\nint main()\n{\n    cufftComplex *data_dev; // 设备端数据头指针\n    cufftComplex *data_Host = (cufftComplex*)malloc(NX*BATCH * sizeof(cufftComplex)); // 主机端数据头指针\n    cufftComplex *resultFFT = (cufftComplex*)malloc(N*BATCH * sizeof(cufftComplex)); // 正变换的结果\n    cufftComplex *resultIFFT = (cufftComplex*)malloc(NX*BATCH * sizeof(cufftComplex)); // 先正变换后逆变换的结果\n\n    // 初始数据\n    for (int i = 0; i &lt; NX; i++)\n    {\n        data_Host[i].x = float((rand() * rand()) % NX) / NX;\n        data_Host[i].y = float((rand() * rand()) % NX) / NX;\n    }\n\n\n    dim3 dimBlock(BLOCK_SIZE); // 线程块\n    dim3 dimGrid((NX + BLOCK_SIZE - 1) / dimBlock.x); // 线程格\n\n    cufftHandle plan; // 创建cuFFT句柄\n    cufftPlan1d(&amp;plan, N, CUFFT_C2C, BATCH);\n\n    // 计时\n    clock_t start, stop;\n    double duration;\n    start = clock();\n\n    cudaMalloc((void**)&amp;data_dev, sizeof(cufftComplex)*N*BATCH); // 开辟设备内存\n    cudaMemset(data_dev, 0, sizeof(cufftComplex)*N*BATCH); // 初始为0\n    cudaMemcpy(data_dev, data_Host, NX * sizeof(cufftComplex), cudaMemcpyHostToDevice); // 从主机内存拷贝到设备内存\n\n    cufftExecC2C(plan, data_dev, data_dev, CUFFT_FORWARD); // 执行 cuFFT，正变换\n    cudaMemcpy(resultFFT, data_dev, N * sizeof(cufftComplex), cudaMemcpyDeviceToHost); // 从设备内存拷贝到主机内存\n\n    cufftExecC2C(plan, data_dev, data_dev, CUFFT_INVERSE); // 执行 cuFFT，逆变换\n    cufftComplexScale &lt;&lt; &lt;dimGrid, dimBlock &gt;&gt; &gt; (data_dev, data_dev, N, 1.0f / N); // 乘以系数\n    cudaMemcpy(resultIFFT, data_dev, NX * sizeof(cufftComplex), cudaMemcpyDeviceToHost); // 从设备内存拷贝到主机内存\n\n    stop = clock();\n    duration = (double)(stop - start) * 1000 / CLOCKS_PER_SEC;\n    cout &lt;&lt; \"时间为 \" &lt;&lt; duration &lt;&lt; \" ms\" &lt;&lt; endl;\n\n    cufftDestroy(plan); // 销毁句柄\n    cudaFree(data_dev); // 释放空间\n\n    cout &lt;&lt; IsEqual(data_Host, resultIFFT, NX) &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>其中<code>cufftPlan1d()</code> :</p>\n<ul>\n<li>第一个参数就是要配置的<span class=\"math inline\">\\(cuFFT\\)</span>句柄；</li>\n<li>第二个参数就是要进行fft的信号的长度；</li>\n<li>第三个<code>CUFFT_C2C</code> 为要执行<span class=\"math inline\">\\(fft\\)</span> 的信号输入类型及输出类型复数；<code>CUFFT_C2R</code>表示输入复数，输出实数；<code>CUFFT_R2C</code>表示输入实数，输出复数；<code>CUFFT_R2R</code> 表示输入实数，输出实数；</li>\n<li>第四个参数<code>BATCH</code>表示要执行fft的信号的个数，新版的已经使用<code>cufftPlanMany()</code>来同时完成多个信号的fft；</li>\n</ul>\n<p><code>cufftExecC2C()</code>:</p>\n<ul>\n<li>第一个参数就是配置好的 cuFFT 句柄；</li>\n<li>第二个参数为输入信号的首地址；</li>\n<li>第三个参数为输出信号的首地址；</li>\n<li>第四个参数为<code>CUFFT_FORWARD</code>表示执行的是<span class=\"math inline\">\\(fft\\)</span>正变换；<code>CUFFT_INVERSE</code>表示执行<span class=\"math inline\">\\(fft\\)</span>逆变换</li>\n</ul>\n<p>需要注意的是，执行完<span class=\"math inline\">\\(fft\\)</span>之后，要对信号中的每个值乘以<span class=\"math inline\">\\(1/N\\)</span>;</p>\n<p>输出结果：</p>\n<p><img alt=\"cufft\" class=\"lazyload\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-07 15:21</span>&nbsp;\n<a href=\"https://www.cnblogs.com/GeophysicsWorker\">GeoFXR</a>&nbsp;\n阅读(<span id=\"post_view_count\">77</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "IQR四分位数法是什么？",
      "link": "https://www.cnblogs.com/sun-10387834/p/19386427",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sun-10387834/p/19386427\" id=\"cb_post_title_url\" title=\"发布于 2026-01-07 15:06\">\n    <span>IQR四分位数法是什么？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>IQR（Interquartile Range，四分位距）四分位数法是一种统计学中用于描述数据离散程度、识别异常值的重要工具。它通过数据的四分位数（Quartiles）来刻画数据的分布特征，尤其适用于非正态分布或存在离群点的场景。以下从核心概念、计算方法、应用场景和理解要点展开说明：</p>\n<h3 id=\"一核心概念四分位数与iqr\"><strong>一、核心概念：四分位数与IQR</strong></h3>\n<h4 id=\"1-四分位数quartiles\">1. 四分位数（Quartiles）</h4>\n<p>将一组有序数据（从小到大排列）划分为4个相等部分的三个关键分割点，分别记为：</p>\n<ul>\n<li><strong>Q1（第一四分位数，25%分位数）</strong>：数据中25%的数值小于或等于它（即第25百分位数）。</li>\n<li><strong>Q2（第二四分位数，中位数）</strong>：数据中50%的数值小于或等于它（即第50百分位数，Median）。</li>\n<li><strong>Q3（第三四分位数，75%分位数）</strong>：数据中75%的数值小于或等于它（即第75百分位数）。</li>\n</ul>\n<p>例如，数据集 [1, 3, 5, 7, 9, 11, 13] 的中位数是7（Q2）；前半部分 [1,3,5] 的中位数是3（Q1），后半部分 [9,11,13] 的中位数是11（Q3）。</p>\n<h4 id=\"2-iqr四分位距\">2. IQR（四分位距）</h4>\n<p><strong>IQR = Q3 - Q1</strong>，表示中间50%数据的分布范围（即数据在Q1到Q3之间的“宽度”）。它是衡量数据离散程度的稳健指标（不受极端值影响）。</p>\n<h3 id=\"二iqr四分位数法的核心作用识别异常值\"><strong>二、IQR四分位数法的核心作用：识别异常值</strong></h3>\n<p>IQR法最常用的是通过“箱线图（Box Plot）”或“Tukey’s Fences”规则识别异常值（Outliers）。具体步骤如下：</p>\n<h4 id=\"1-计算上下边界\">1. 计算上下边界</h4>\n<p>以IQR为基准，定义数据的“正常范围”：</p>\n<ul>\n<li><strong>下边界（Lower Bound）</strong>：Q1 - 1.5×IQR</li>\n<li><strong>上边界（Upper Bound）</strong>：Q3 + 1.5×IQR</li>\n</ul>\n<h4 id=\"2-判定异常值\">2. 判定异常值</h4>\n<ul>\n<li><strong>温和异常值（Mild Outliers）</strong>：小于下边界或大于上边界的数据点（通常用1.5×IQR界定）。</li>\n<li><strong>极端异常值（Extreme Outliers）</strong>：小于Q1 - 3×IQR 或大于Q3 + 3×IQR 的数据点（更严格的阈值）。</li>\n</ul>\n<p><strong>逻辑</strong>：正常数据应集中在中间50%（Q1到Q3），而超出1.5倍IQR的点被视为“偏离较远的异常”。1.5倍的选择是经验性的（基于正态分布假设下约覆盖99.3%的数据，剩余0.7%视为异常）。</p>\n<h3 id=\"三应用场景\"><strong>三、应用场景</strong></h3>\n<ol>\n<li><strong>数据清洗</strong>：识别并验证离群点（如传感器误差、输入错误）。</li>\n<li><strong>可视化分析</strong>：箱线图的核心组件（箱体表示Q1到Q3，触须延伸至非异常值的最远点，异常值单独标记）。</li>\n<li><strong>统计描述</strong>：替代标准差（SD）衡量离散程度（尤其当数据非正态时，IQR更稳健）。</li>\n</ol>\n<h3 id=\"四如何理解iqr法的优势与局限\"><strong>四、如何理解IQR法的优势与局限</strong></h3>\n<h4 id=\"优势\">优势：</h4>\n<ul>\n<li><strong>稳健性</strong>：仅依赖中间50%的数据，不受极端值干扰（标准差易受异常值影响）。</li>\n<li><strong>普适性</strong>：适用于任何分布（无需假设数据正态）。</li>\n<li><strong>直观性</strong>：通过四分位数直接反映数据的集中与分散趋势。</li>\n</ul>\n<h4 id=\"局限\">局限：</h4>\n<ul>\n<li><strong>主观性</strong>：1.5倍IQR是经验阈值，不同领域可能调整（如金融风控可能用3倍）。</li>\n<li><strong>小样本偏差</strong>：样本量过小时（如n&lt;10），四分位数估计可能不稳定。</li>\n<li><strong>无法反映分布形态</strong>：仅描述离散程度，不体现数据的对称性或峰度。</li>\n</ul>\n<h3 id=\"五示例说明\"><strong>五、示例说明</strong></h3>\n<p>假设数据集：[12, 15, 17, 19, 20, 22, 24, 28, 30, 35, 40, 100]（已排序）。</p>\n<ol>\n<li>\n<p>计算四分位数：</p>\n<ul>\n<li>n=12，中位数Q2是第6和第7个数的平均：(22+24)/2=23。</li>\n<li>Q1是前6个数的中位数：(17+19)/2=18（前6数：12,15,17,19,20,22）。</li>\n<li>Q3是后6个数的中位数：(30+35)/2=32.5（后6数：24,28,30,35,40,100）。</li>\n</ul>\n</li>\n<li>\n<p>计算IQR：IQR=Q3-Q1=32.5-18=14.5。</p>\n</li>\n<li>\n<p>确定边界：</p>\n<ul>\n<li>下边界=18 - 1.5×14.5=18-21.75=-3.75</li>\n<li>上边界=32.5 + 1.5×14.5=32.5+21.75=54.25</li>\n</ul>\n</li>\n<li>\n<p>识别异常值：数据中100&gt;54.25，因此100是异常值；其他数据点均在[-3.75, 54.25]范围内。</p>\n</li>\n</ol>\n<h3 id=\"总结\"><strong>总结</strong></h3>\n<p>IQR四分位数法通过“中间50%数据的范围”（IQR）量化离散程度，并通过1.5倍IQR的边界识别异常值。它的核心是<strong>关注数据的主体分布，忽略极端干扰</strong>，是探索性数据分析（EDA）中简单却强大的工具。理解其逻辑的关键在于把握“四分位数划分数据、IQR衡量主体波动、边界外视为异常”这一链条。</p>\n\n</div>\n<div id=\"MySignature\">\n    \n<p>❤️ 如果你喜欢这篇文章，请点赞支持！ 👍 同时欢迎关注我的博客，获取更多精彩内容！</p>\n\n<p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/sun-10387834/\" target=\"_blank\">佛祖让我来巡山</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/sun-10387834/p/19386427\" target=\"_blank\">https://www.cnblogs.com/sun-10387834/p/19386427</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-07 15:06</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sun-10387834\">佛祖让我来巡山</a>&nbsp;\n阅读(<span id=\"post_view_count\">53</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}