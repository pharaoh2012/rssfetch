{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "从Prompt工程到Skill工程：Agent Skills开放标准彻底改变了AI协作方式",
      "link": "https://www.cnblogs.com/zlt2000/p/19577443",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zlt2000/p/19577443\" id=\"cb_post_title_url\" title=\"发布于 2026-02-05 09:20\">\n    <span>从Prompt工程到Skill工程：Agent Skills开放标准彻底改变了AI协作方式</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p><img alt=\"0-封面\" class=\"lazyload\" /></p>\n<h2 id=\"一为什么-agent-skill-突然火了\">一、为什么 Agent Skill 突然火了？</h2>\n<p>你是不是也有过这样的崩溃时刻？</p>\n<ul>\n<li>每次让 <code>Claude</code> 写代码，都要重复粘贴 <strong>请使用我们的代码规范：驼峰命名、2空格缩进、必须写单元测试</strong> ——像极了每天入职新公司；</li>\n<li>好不容易调教好的 <code>Prompt</code> 换个项目就完全失效，之前的调教经验归零；</li>\n<li>团队里每个人给 AI 的指令不一样，导致输出的内容一会儿像资深架构师，一会儿像刚毕业的新手。</li>\n</ul>\n<p>这些问题的根源，其实是 <code>AI</code> 的 <strong>专业能力无法沉淀</strong>。直到 2025 年 10 月 <code>Anthropic</code> 推出 <code>Agent Skill</code>（又名 Claude Code Skill）正是为解决这些问题而生。这不仅是 <code>Claude</code> 的新功能，更是一个 <strong>开放的跨平台标准</strong>，目前已被 <code>OpenAI</code>、<code>Cursor</code>、<code>Trae</code> 等主流工具跟进支持。</p>\n<p>本文将带你从 <strong>是什么</strong> 到 <strong>怎么用在实际工作中</strong>，彻底掌握这个比 <code>Prompt</code> 更高级、比 <code>MCP</code> 更易用的 <code>AI</code> 编程神器。</p>\n<p>&nbsp;</p>\n<h2 id=\"二到底什么是-agent-skill\">二、到底什么是 Agent Skill？</h2>\n<p>用最通俗的比喻：<code>Agent Skill</code> 是 <code>AI</code> 的 <strong>入职手册 + 工具箱</strong>。</p>\n<p>想象你招了一位天才实习生 <code>Claude</code> 他智商极高但不懂你们公司的业务。传统的做法是每次布置任务都口头交代一遍 <code>Prompt</code> 而 <code>Agent Skill</code> 则是给他一本完整的标准作业程序 <code>SOP</code>：</p>\n<ul>\n<li>📋 入职手册（SKILL.md）：包含岗位描述、工作流程、注意事项</li>\n<li>🧰 工具箱（Scripts）：处理特定任务的脚本和代码</li>\n<li>📚 参考资料（References）：行业规范、模板素材、API文档</li>\n</ul>\n<p>技术本质：<code>Agent Skill</code> 是一个标准化的文件夹结构，核心必须包含 <code>SKILL.md</code> 文件（YAML元数据 + Markdown说明），可选包含脚本、模板等资源文件。</p>\n<pre><code>my-skill/            # 技能包根目录\n├── SKILL.md         # 📄 核心文件：元数据 + 工作流指令（必须）\n├── scripts/         # 🔧 可选：自动化脚本（Python/Bash）\n├── references/      # 📖 可选：专业文档、API手册、FAQ\n└── assets/          # 🎨 可选：模板、示例、静态资源\n</code></pre>\n<p>当 <code>AI</code> 检测到相关任务时，会自动 <strong>翻开</strong> 对应的手册，严格按照既定流程执行，无需你每次都重复交代。</p>\n<p>&nbsp;</p>\n<h2 id=\"三skill工作原理\">三、Skill工作原理</h2>\n<p><code>Skill</code> 最精妙的设计，是它的 <strong>渐进式加载机制</strong> —— 就像你查字典，先看目录，再翻对应章节，最后查附录，不会一上来就把整本书塞进脑子里。</p>\n<h3 id=\"31-三层加载用最少的-token-做最多的事\">3.1. 三层加载：用最少的 Token 做最多的事</h3>\n<p><img alt=\"1-核心机制\" class=\"lazyload\" /></p>\n<table>\n<thead>\n<tr>\n<th>加载层级</th>\n<th>内容类型</th>\n<th>加载时机</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>L1</td>\n<td>元数据（名片）</td>\n<td>Agent 启动时自动加载</td>\n<td>让AI知道“有什么技能可用”</td>\n</tr>\n<tr>\n<td>L2</td>\n<td>说明文档（正文）</td>\n<td>匹配用户需求时加载</td>\n<td>教AI“具体怎么做”</td>\n</tr>\n<tr>\n<td>L3</td>\n<td>资源文件（脚本 / 模板）</td>\n<td>执行中按需加载</td>\n<td>提供“工具/素材支持”</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"32-四步执行流程\">3.2. 四步执行流程</h3>\n<p><img alt=\"2-执行流程\" class=\"lazyload\" /></p>\n<ol>\n<li>🎯 意图匹配：AI 扫描所有 Skill 的元数据，找到最匹配当前任务的技能</li>\n<li>📖 读取指南：加载对应 SKILL.md，掌握执行步骤、检查点、输出规范</li>\n<li>🔧 按需执行：调用 scripts/ 中的脚本，查询 references/ 中的资料</li>\n<li>✅ 反馈结果：按模板输出成果，或询问缺失信息</li>\n</ol>\n<p>&nbsp;</p>\n<h2 id=\"四现有技术的对比\">四、现有技术的对比</h2>\n<h3 id=\"41-agent-skill-vs-prompt\">4.1. Agent Skill vs Prompt</h3>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>普通 Prompt</th>\n<th>Agent Skill</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>性质</strong></td>\n<td>临时指令，用完即走</td>\n<td>标准化流程，永久复用</td>\n</tr>\n<tr>\n<td><strong>加载方式</strong></td>\n<td>每次全量输入</td>\n<td>按需渐进加载</td>\n</tr>\n<tr>\n<td><strong>稳定性</strong></td>\n<td>依赖模型\"记忆\"，易漂移</td>\n<td>固化检查点，强制执行</td>\n</tr>\n<tr>\n<td><strong>管理</strong></td>\n<td>分散在聊天记录里</td>\n<td>文件化、版本可控</td>\n</tr>\n<tr>\n<td><strong>共享</strong></td>\n<td>复制粘贴，易丢失格式</td>\n<td>整包分享，开箱即用</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>一句话总结：Prompt 是 <strong>口头交代</strong>，Skills 是<strong>书面 SOP + 工具箱</strong>。</p>\n</blockquote>\n<h3 id=\"42-agent-skill-vs-多-agent-架构\">4.2. Agent Skill vs 多 Agent 架构</h3>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>多 Agent 架构</th>\n<th>Agent Skill</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>复杂度</strong></td>\n<td>重量级，需要架构设计</td>\n<td>轻量级，单个文件夹即可</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>复杂并行任务（如研究+写作+审核同时进行）</td>\n<td>单领域深度任务（如专业代码审查）</td>\n</tr>\n<tr>\n<td><strong>资源消耗</strong></td>\n<td>高，需调度多个 Agent 实例</td>\n<td>低，单 Agent 内能力切换</td>\n</tr>\n<tr>\n<td><strong>启动成本</strong></td>\n<td>需要搭建 Agent 框架</td>\n<td>零成本，复制文件夹即可</td>\n</tr>\n<tr>\n<td><strong>关系</strong></td>\n<td>体系级解决方案</td>\n<td>单元级能力模块，可被多 Agent 调用</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"43-agent-skill-vs-mcp\">4.3. Agent Skill vs MCP</h3>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>MCP</th>\n<th>Agent Skill</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>定位</strong></td>\n<td>连接协议：AI 与外部系统的\"USB 接口\"</td>\n<td>执行标准：AI 做事的\"操作手册\"</td>\n</tr>\n<tr>\n<td><strong>解决的问题</strong></td>\n<td><strong>能不能连</strong>（访问数据库、API、文件系统）</td>\n<td><strong>怎么做</strong>（流程、规范、最佳实践）</td>\n</tr>\n<tr>\n<td><strong>技术形态</strong></td>\n<td>需要运行 MCP Server（TypeScript/Python）</td>\n<td>静态文件夹（Markdown + 脚本）</td>\n</tr>\n<tr>\n<td><strong>加载时机</strong></td>\n<td>启动时建立连接</td>\n<td>按需渐进加载</td>\n</tr>\n<tr>\n<td><strong>关系</strong></td>\n<td><strong>互补</strong>：MCP 提供“工具”</td>\n<td>Skills 提供“使用指南”</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>MCP 让 AI 能连上数据库，Skill 教 AI 怎么按你们公司的规范查数据、生成报表、处理异常。两者配合，AI 才能真正成为\"懂行的专家\"。</p>\n</blockquote>\n<p>&nbsp;</p>\n<h2 id=\"五创建你的第一个-agent-skill\">五、创建你的第一个 Agent Skill</h2>\n<p>下面用 <code>会议纪要整理助手</code> 为例，从零创建一个 Skill</p>\n<p><strong>场景</strong>：开会录音转文字后，需要整理成结构化会议纪要。不同会议类型（周会/项目复盘/客户沟通）需要不同的整理模板。</p>\n<h3 id=\"51-创建-skill-文件夹结构\">5.1. 创建 Skill 文件夹结构</h3>\n<p>新建一个名为 <code>meeting-minutes</code> 的文件夹，总体的文件结构如下：</p>\n<pre><code>/meeting-minutes/\n├── SKILL.md                    # L1：技能元数据，L2：内容\n├── references/                 # L3：按会议类型按需加载\n│   ├── weekly-rule.md          # 周会模板\n│   ├── retro-rule.md           # 复盘模板\n│   └── client-rule.md          # 客户沟通模板\n</code></pre>\n<h3 id=\"52-skillmd核心文件\">5.2. SKILL.md（核心文件）</h3>\n<h4 id=\"521-元数据\">5.2.1. 元数据</h4>\n<p>在 <code>SKILL.md</code> 文件最开头以上下两个 <code>---</code> 作为元数据标识</p>\n<pre><code class=\"language-markdown\">---\nname: meeting-minutes\ndescription: 办公室通用会议纪要整理助手，支持周会/项目复盘会/客户沟通会三类场景，自动识别会议类型，按需加载对应会议规则，智能提取关键信息，输出结构化纪要。\n---\n</code></pre>\n<h4 id=\"522-skill内容\">5.2.2. SKILL内容</h4>\n<p><img alt=\"3-编写SKILL\" class=\"lazyload\" /></p>\n<h3 id=\"53-编写模块化配置references\">5.3. 编写模块化配置references</h3>\n<p><img alt=\"4-编写模块化配置references\" class=\"lazyload\" /></p>\n<blockquote>\n<p>通过文件分离，AI每次只读取当前任务所需的规则，避免 Context 污染</p>\n</blockquote>\n<h3 id=\"54-测试你的-skill以-trae-为例\">5.4. 测试你的 Skill（以 Trae 为例）</h3>\n<p><code>Trae</code> 作为国内的 <code>AI IDE</code> 已原生支持 <code>Agent Skills</code></p>\n<ul>\n<li>\n<p>官网：<code>https://www.trae.cn/</code></p>\n</li>\n<li>\n<p>下载并安装 <code>TRAE IDE</code></p>\n</li>\n</ul>\n<h4 id=\"541-导入skill\">5.4.1. 导入Skill</h4>\n<ol>\n<li>创建一个文件夹，例如 <code>my_skills</code></li>\n<li>使用 <code>TRAE IDE</code> 打开这个文件夹</li>\n<li>将 <code>meeting-minutes</code> 文件夹复制到 my_skills/.trae/skills/ 目录下</li>\n</ol>\n<h4 id=\"542-输入提示词\">5.4.2. 输入提示词</h4>\n<p>需要切换为 <code>SOLO</code> 模式，然后在对话框输入以下提示词：</p>\n<pre><code class=\"language-bash\">帮我生成周会会议纪要\n\n原始文本：\n小明：用户模块我搞完了，已经提测。\n小红：接口文档我还没弄，我负责写，周五前给出来。\n张三：测试环境那个问题搞不定，需要运维老陈帮忙看看。\n李四：下周我打算开始订单模块，周三前出个技术方案看看。\n王五：数据库设计谁review一下？\n小明：我来吧，不过得明天才有空。\n</code></pre>\n<h4 id=\"543-执行skill\">5.4.3. 执行Skill</h4>\n<p><img alt=\"5-trae执行过程\" class=\"lazyload\" /></p>\n<h4 id=\"544-最终输出以下内容\">5.4.4. 最终输出以下内容</h4>\n<p><img alt=\"6-执行效果\" class=\"lazyload\" /></p>\n<p>&nbsp;</p>\n<h2 id=\"六本文skill下载地址\">六、本文Skill下载地址</h2>\n<p>本文案例 <code>会议纪要整理助手</code> Skill 的下载地址如下：</p>\n<ul>\n<li>Gitee地址：</li>\n</ul>\n<p><a href=\"https://gitee.com/zlt2000/my-agent-skill/tree/master/meeting-minutes\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/zlt2000/my-agent-skill/tree/master/meeting-minutes</a></p>\n<ul>\n<li>Github地址：</li>\n</ul>\n<p><a href=\"https://github.com/zlt2000/my-agent-skill/tree/master/meeting-minutes\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/zlt2000/my-agent-skill/tree/master/meeting-minutes</a></p>\n<blockquote>\n<p>在实际使用过程中本文 Skill 还可以进行以下迭代优化：</p>\n<ol>\n<li>在 <code>references</code> 里扩展更多的 <strong>会议类型</strong> 模板；</li>\n<li>在 <code>script</code> 文件夹写 <code>Python</code> 脚本，实现输出内容 <strong>导出word文档</strong> 或者 <strong>同步给飞书</strong>。</li>\n</ol>\n</blockquote>\n<p>&nbsp;</p>\n<h2 id=\"七总结\">七、总结</h2>\n<p><code>Agent Skills</code> 的正式发布，标志着 AI 协作从 <strong>提示词工程</strong> 正式迈入 <strong>技能工程</strong> 的全新范式。它将人类专家的经验、标准化流程与行业最佳实践，封装成 <code>AI</code> 可理解、可执行、可复用的数字资产。</p>\n<p>核心价值优势：</p>\n<ol>\n<li><strong>降本增效：</strong> 通过渐进式披露、按需加载机制，大幅减少 Token 消耗，同时让 AI 聚焦核心任务，推理效率与执行稳定性同步提升；</li>\n<li><strong>跨平台互通：</strong> 作为开放标准，实现 “一次构建、多端复用”，Skill 可无缝适配 Claude、Cursor、Trae、Copilot 等主流平台，打破工具壁垒；</li>\n<li><strong>Skill 市场：</strong> 构建起类似 VS Code 插件市场的 Skill 生态，官方与社区共同打造技能商店，让专业能力可分享、可迭代、可规模化应用。</li>\n</ol>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-05 09:20</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zlt2000\">zlt2000</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Obsidian × Claudian × Skills：打造真正会“思考”的个人知识库",
      "link": "https://www.cnblogs.com/bugshare/p/19577439",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/bugshare/p/19577439\" id=\"cb_post_title_url\" title=\"发布于 2026-02-05 09:19\">\n    <span>Obsidian × Claudian × Skills：打造真正会“思考”的个人知识库</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在上一篇文章 <strong>《Obsidian 使用指南：从零开始搭建你的个人知识库》</strong> 中，我们介绍了 Obsidian 的基础使用方式：<br />\n如何用 Markdown 记录知识、用双链组织思路、逐步搭建属于自己的知识体系。</p>\n<p>但问题也随之而来：</p>\n<blockquote>\n<p><strong>当笔记越来越多，它们真的“活”起来了吗？</strong></p>\n</blockquote>\n<p>最近一段时间，<strong>Claude Code + Skills</strong> 在开发者圈子里非常火🔥<br />\n它不仅是一个 AI 聊天工具，而是一个<strong>可以理解上下文、执行技能、参与协作的 AI 编程与思考助手</strong>。</p>\n<p>那么问题来了：</p>\n<blockquote>\n<p><strong>Obsidian 能不能接入 Claude Code？<br />\n让 AI 不只是“帮你写”，而是真正参与“思考”和“整理知识”？</strong></p>\n</blockquote>\n<p>答案是：<strong>可以，而且体验非常好。</strong></p>\n<p>本文将带你一步步完成：</p>\n<ul>\n<li>在 Obsidian 中接入 <strong>Claude Code</strong></li>\n<li>通过 <strong>Claudian 插件</strong>，把 Claude 变成你的<strong>AI 协作助手</strong></li>\n<li>利用 <strong>Skills</strong>，让 AI 直接参与笔记编辑、重构与思考</li>\n</ul>\n<hr />\n<h1 id=\"为什么要把-claude-接入-obsidian\">为什么要把 Claude 接入 Obsidian？</h1>\n<p>在开始之前，先说清楚<strong>这套组合解决什么问题</strong>。</p>\n<p>传统 AI + 笔记的方式，通常是：</p>\n<ul>\n<li>复制一段内容</li>\n<li>打开网页 / Chat 客户端</li>\n<li>让 AI 帮你改写 / 总结</li>\n<li>再粘贴回来</li>\n</ul>\n<p>而 <strong>Obsidian × Claude Code × Skills</strong> 的核心价值在于：</p>\n<h2 id=\"-ai-就在你的知识库里工作\">✅ AI 就在你的知识库里工作</h2>\n<ul>\n<li>不需要来回切换窗口</li>\n<li>直接理解你当前笔记内容</li>\n<li>在<strong>原地进行内联编辑</strong></li>\n</ul>\n<h2 id=\"-claude-code--skills--普通聊天\">✅ Claude Code + Skills ≠ 普通聊天</h2>\n<ul>\n<li>能调用 <strong>Skill（技能）</strong></li>\n<li>能执行复杂指令（重写、拆解、结构化、补充）</li>\n<li>更像一个「<strong>协作伙伴</strong>」，而不是问答机器人</li>\n</ul>\n<h2 id=\"-非侵入式完全本地友好\">✅ 非侵入式、完全本地友好</h2>\n<ul>\n<li>Obsidian 仍然是你的本地 Markdown</li>\n<li>Claude 只是“参与编辑”，不劫持你的数据结构</li>\n</ul>\n<hr />\n<h1 id=\"claudian-插件介绍\">Claudian 插件介绍</h1>\n<p>实现这一切的关键，就是 <strong>Claudian 插件</strong>。</p>\n<blockquote>\n<p>GitHub：<br />\n<a href=\"https://github.com/YishenTu/claudian\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/YishenTu/claudian</a></p>\n</blockquote>\n<p><strong>Claudian 是什么？</strong></p>\n<ul>\n<li>一个 Obsidian 桌面端插件</li>\n<li>用于连接 <strong>Claude Code CLI</strong></li>\n<li>支持 <strong>Claude Code 的 Skills 体系</strong></li>\n<li>可在 Obsidian 内直接与 Claude 交互、编辑文本</li>\n</ul>\n<p>一句话总结：</p>\n<blockquote>\n<p><strong>Claudian = 把 Claude Code 搬进 Obsidian。</strong></p>\n</blockquote>\n<hr />\n<h1 id=\"使用前的要求\">使用前的要求</h1>\n<p>在安装前，请确保你的环境满足以下条件：</p>\n<ul>\n<li>\n<p>✅ 已安装 <a href=\"https://code.claude.com/docs/en/overview\" rel=\"noopener nofollow\" target=\"_blank\">Claude Code CLI</a><br />\n👉 <strong>强烈建议使用 Native Install</strong></p>\n</li>\n<li>\n<p>✅ Obsidian <strong>v1.8.9+</strong></p>\n</li>\n<li>\n<p>✅ 拥有支持 <strong>Anthropic API 格式</strong> 的 Claude 订阅 / API Key<br />\n或使用以下兼容平台之一：</p>\n<ul>\n<li><a href=\"https://openrouter.ai/docs/guides/guides/claude-code-integration\" rel=\"noopener nofollow\" target=\"_blank\">OpenRouter</a></li>\n<li><a href=\"https://platform.moonshot.ai/docs/guide/agent-support\" rel=\"noopener nofollow\" target=\"_blank\">Kimi（月之暗面）</a></li>\n<li><a href=\"https://docs.z.ai/devpack/tool/claude\" rel=\"noopener nofollow\" target=\"_blank\">GLM（智谱 BigModel）</a></li>\n<li><a href=\"https://api-docs.deepseek.com/guides/anthropic_api\" rel=\"noopener nofollow\" target=\"_blank\">DeepSeek</a></li>\n</ul>\n</li>\n<li>\n<p>✅ <strong>仅支持桌面端</strong>（macOS / Linux / Windows）</p>\n</li>\n</ul>\n<blockquote>\n<p>如果你对 Claude Code、Skills、或智谱模型的接入还不熟悉，可以先参考我之前的两篇文章：</p>\n<ul>\n<li>《Claude Code × 智谱 BigModel 实战集成指南》</li>\n<li>《Claude Code 支持重磅扩展 Skills》</li>\n</ul>\n</blockquote>\n<hr />\n<h1 id=\"claudian-插件安装手动\">Claudian 插件安装（手动）</h1>\n<p>目前 Claudian <strong>尚未上架 Obsidian 社区市场</strong>，需要手动安装。</p>\n<h2 id=\"1️⃣-下载插件文件\">1️⃣ 下载插件文件</h2>\n<p>前往 GitHub Releases 页面，下载最新版本：</p>\n<p>👉 <a href=\"https://github.com/YishenTu/claudian/releases/latest\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/YishenTu/claudian/releases/latest</a></p>\n<p>需要以下三个文件：</p>\n<ul>\n<li><code>main.js</code></li>\n<li><code>manifest.json</code></li>\n<li><code>styles.css</code></li>\n</ul>\n<hr />\n<h2 id=\"2️⃣-创建插件目录\">2️⃣ 创建插件目录</h2>\n<p>在你的 Obsidian Vault 中，创建插件目录：</p>\n<pre><code class=\"language-text\">/path/to/vault/.obsidian/plugins/claudian/\n</code></pre>\n<hr />\n<h2 id=\"3️⃣-拷贝文件\">3️⃣ 拷贝文件</h2>\n<p>将下载的三个文件复制到 <code>claudian</code> 文件夹中。</p>\n<hr />\n<h2 id=\"4️⃣-在-obsidian-中启用插件\">4️⃣ 在 Obsidian 中启用插件</h2>\n<p>路径如下：</p>\n<ul>\n<li><strong>设置 → 社区插件</strong></li>\n<li>启用 <strong>Claudian</strong></li>\n</ul>\n<p><img alt=\"PixPin_2026-02-01_18-40-08.png\" class=\"lazyload\" /></p>\n<hr />\n<h1 id=\"启用-claudian-插件\">启用 Claudian 插件</h1>\n<p>如果插件没有立刻显示，可以：</p>\n<ul>\n<li>设置 → 第三方插件</li>\n<li>点击 <strong>刷新</strong></li>\n<li>启用 <strong>Claudian</strong></li>\n</ul>\n<p><img alt=\"PixPin_2026-02-01_18-41-08.png\" class=\"lazyload\" /></p>\n<hr />\n<h1 id=\"配置-claude--模型环境\">配置 Claude / 模型环境</h1>\n<p>进入插件设置：</p>\n<p><strong>设置 → Claudian → Environment（环境）</strong></p>\n<p>这里可以配置 Claude API，也可以配置你在前文中使用过的 <strong>智谱 BigModel（GLM）</strong>。</p>\n<p>示例配置如下：</p>\n<pre><code class=\"language-conf\">ANTHROPIC_API_KEY=your api key\nANTHROPIC_BASE_URL=https://open.bigmodel.cn/api/anthropic\nANTHROPIC_MODEL=glm-4.7\n</code></pre>\n<p><img alt=\"PixPin_2026-02-01_19-14-11.png\" class=\"lazyload\" /></p>\n<blockquote>\n<p>💡 Claudian 的优势之一就在于：<br />\n<strong>它不限定官方 Claude，只要兼容 Anthropic API 即可。</strong></p>\n</blockquote>\n<hr />\n<h1 id=\"在-obsidian-中使用-claude\">在 Obsidian 中使用 Claude</h1>\n<p>完成配置后，就可以正式开始使用了。</p>\n<h2 id=\"基础使用方式\">基础使用方式</h2>\n<ol>\n<li>点击 Obsidian 左侧功能区的 🤖 机器人图标<br />\n或使用 <strong>命令面板</strong> 打开 Claude 聊天窗口</li>\n<li>在笔记中 <strong>选中一段文本</strong></li>\n<li>使用快捷键，让 Claude <strong>直接进行内联编辑</strong></li>\n</ol>\n<p><img alt=\"PixPin_2026-02-01_19-18-15.png\" class=\"lazyload\" /></p>\n<p>这一步的体验非常关键：</p>\n<blockquote>\n<p><strong>AI 不再是“给你建议”，而是“直接帮你改文档”。</strong></p>\n</blockquote>\n<hr />\n<h1 id=\"skills让-claude-真正会干活\">Skills：让 Claude 真正“会干活”</h1>\n<p>Claudian 最大的亮点之一，就是 <strong>完整支持 Claude Code 的 Skills</strong>。</p>\n<p>在输入框中输入 <code>/</code>，即可弹出：</p>\n<ul>\n<li>可用命令</li>\n<li>已注册的 Skills</li>\n</ul>\n<p><img alt=\"PixPin_2026-02-01_19-28-15.png\" class=\"lazyload\" /></p>\n<p>这意味着什么？</p>\n<p>你可以在 Obsidian 里直接让 Claude：</p>\n<ul>\n<li>重构一篇技术文章</li>\n<li>拆解复杂概念</li>\n<li>生成大纲 / TODO / 知识卡片</li>\n<li>统一文档风格</li>\n<li>把“零散笔记”整理成“系统知识”</li>\n</ul>\n<p><strong>这已经不是简单的 AI 辅助写作，而是 AI 协作编辑。</strong></p>\n<hr />\n<h1 id=\"写在最后\">写在最后</h1>\n<p>如果说：</p>\n<ul>\n<li><strong>Obsidian</strong> 解决的是「<strong>知识如何存储与连接</strong>」</li>\n<li>那么 <strong>Claude Code + Skills</strong> 解决的就是「<strong>知识如何被持续加工与进化</strong>」</li>\n</ul>\n<p>而 <strong>Claudian 插件</strong>，正好把这两件事无缝连接在一起。</p>\n<blockquote>\n<p>从此你的 Obsidian 不只是笔记库，而是一个<br />\n<strong>可以被 AI 参与思考、不断演化的个人知识系统。</strong></p>\n</blockquote>\n<p>如果你觉得这篇文章有帮助，欢迎 <strong>点赞 / 转发 / 收藏</strong>。<br />\n我们下篇见。 👋</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-05 09:19</span>&nbsp;\n<a href=\"https://www.cnblogs.com/bugshare\">BugShare</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "基于 Starlight 文档站点接入 Microsoft Clarity 的完整实践指南",
      "link": "https://www.cnblogs.com/newbe36524/p/19577415",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/newbe36524/p/19577415\" id=\"cb_post_title_url\" title=\"发布于 2026-02-05 09:13\">\n    <span>基于 Starlight 文档站点接入 Microsoft Clarity 的完整实践指南</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"从数据洞察到用户增长hagicode-博客接入-clarity-analytics-的完整指南\">从数据洞察到用户增长：HagiCode 博客接入 Clarity Analytics 的完整指南</h1>\n<blockquote>\n<p>本文将分享如何在 Starlight 文档站点中优雅地接入 Microsoft Clarity，不仅能看清用户行为，还能确保隐私合规。这套方案是我们在 HagiCode 项目中实践总结出来的，希望能给同样在折腾数据统计的你一点参考。</p>\n</blockquote>\n\n<h2 id=\"背景为什么我们需要-clarity\">背景：为什么我们需要 Clarity？</h2>\n<p>以下代码展示了如何在 Astro 集成中根据环境变量动态注入 Microsoft Clarity 脚本，仅在生效时进行生产环境加载。</p>\n\n<pre><code class=\"language-markdown\">105 | interface Props {\n106 |   // 未来可扩展: 允许手动覆盖 Project ID\n107 |   projectId?: string;\n108 | }\n109 | \n110 | const {\n111 |   projectId = import.meta.env.CLARITY_PROJECT_ID,\n112 | } = Astro.props;\n113 | \n114 | const isProduction = import.meta.env.PROD;\n115 | ---\n116 | \n117 | {isProduction &amp;&amp; projectId &amp;&amp; (\n118 |   &lt;script is:inline define:vars={{projectId}}&gt;\n119 |     (function(c,l,a,r,i,t,y){\n</code></pre>\n<p><em>文件：<code>openspec/changes/archive/2026-01-30-microsoft-clarity-integration/design.md</code></em></p>\n<p>在运营 <strong>HagiCode</strong> 的过程中，我们一直面临一个\"盲盒\"问题：我们产出内容，但不清楚用户是如何阅读的。虽然 GitHub 能看到 Star 数，但这太滞后了。我们需要知道：</p>\n<ul>\n<li>用户到底有没有看完我们的教程？</li>\n<li>那些复杂的配置文档，是在哪一步劝退了用户的？</li>\n<li>我们的 SEO 优化是否真的带来了有效流量？</li>\n</ul>\n<p>市面上有很多分析工具，比如 Google Analytics（GA）和 Microsoft Clarity。GA 功能强大但配置复杂，且受到隐私法规（如 GDPR）的严格限制。而 Clarity 作为微软推出的免费热力图工具，不仅功能直观，而且在隐私合规上相对宽松，非常适合技术文档站点。</p>\n<p><strong>我们的目标很明确</strong>：在 <strong>HagiCode</strong> 的文档站点中无缝集成 Clarity，既要在所有页面生效，又要给用户留有\"退出\"的权利（隐私合规）。</p>\n<h2 id=\"关于-hagicode\">关于 HagiCode</h2>\n<p>HagiCode 主题初始化逻辑：优先读取本地存储，回退至系统偏好，默认暗色。</p>\n\n<pre><code class=\"language-markdown\">67 | function getInitialTheme(): Theme {\n68 |   // 1. 检查 localStorage\n69 |   const stored = localStorage.getItem('hagicode-theme');\n70 |   if (stored) return stored as Theme;\n71 | \n72 |   // 2. 检测系统偏好\n73 |   const systemDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\n74 |   if (systemDark) return 'dark';\n75 | \n76 |   // 3. 默认暗色\n77 |   return 'dark';\n78 | }\n79 | ```\n80 | \n81 | ### 决策 3：主题应用方式\n82 | \n83 | **选择**：在 `&lt;html&gt;` 根元素设置 `data-theme` 属性\n84 | \n85 | **对比方案**：\n86 | \n</code></pre>\n<p><em>文件：<code>openspec/changes/archive/2026-01-29-theme-toggle-implementation/design.md</code></em></p>\n<p>本文分享的方案来自我们在 <a href=\"https://github.com/HagiCode-org/site\" rel=\"noopener nofollow\" target=\"_blank\">HagiCode</a> 项目中的实践经验。HagiCode 是一个基于 AI 的代码辅助工具，在开发过程中，我们需要维护大量的技术文档和博客。为了更好地理解用户需求，我们探索并实施了这套数据接入方案。</p>\n<h2 id=\"技术选型与探索\">技术选型与探索</h2>\n<p>起初，我们在 Proposal 阶段讨论了多种集成方式。既然我们使用的是 Starlight（基于 Astro 的文档框架），最直观的想法是利用 Astro 的 Hooks。</p>\n<p>我们首先尝试了修改 <code>astro.config.mjs</code>，计划在构建时注入 Clarity 脚本。虽然这种方式能保证全局覆盖，但缺乏灵活性——我们无法根据用户的偏好动态加载或卸载脚本。</p>\n<p>考虑到用户体验和隐私控制，我们最终决定采用 <strong>组件覆盖</strong> 的方案。Starlight 允许开发者覆盖其内部组件，这意味着我们可以接管 <code>&lt;footer&gt;</code> 或 <code>&lt;head&gt;</code> 的渲染逻辑，从而精细控制 Clarity 的加载时机。</p>\n<p>这里有一个小插曲：原本我们想创建一个名为 <code>StarlightWrapper.astro</code> 的布局包装器。但在实际调试中发现，Starlight 的路由机制并不会自动调用这个自定义 Wrapper，这导致脚本在部分页面失效。这算是一个典型的\"想当然\"踩坑经历，提醒我们<strong>必须深入理解框架的渲染流程，而不是盲目套用通用框架模式</strong>。</p>\n<h2 id=\"核心方案footer-组件覆盖\">核心方案：Footer 组件覆盖</h2>\n<p>为了确保 Clarity 脚本在所有页面（包括文档和博客）加载，并且不破坏原有的页面结构，我们选择了覆盖 Starlight 的 <code>Footer</code> 组件。</p>\n<h3 id=\"为什么是-footer\">为什么是 Footer？</h3>\n<ol>\n<li><strong>全局性</strong>：Footer 几乎在所有标准页面都会出现。</li>\n<li><strong>非侵入性</strong>：将脚本放在 Footer 区域（实际渲染在 body 底部）不会阻塞页面的关键渲染路径（LCP），对性能影响最小。</li>\n<li><strong>逻辑集中</strong>：可以在组件内部统一处理 Cookie 同意逻辑。</li>\n</ol>\n<h3 id=\"实施步骤\">实施步骤</h3>\n<h4 id=\"1-准备-clarity-项目\">1. 准备 Clarity 项目</h4>\n<p>首先，你需要在 <a href=\"https://clarity.microsoft.com/\" rel=\"noopener nofollow\" target=\"_blank\">Microsoft Clarity</a> 注册并创建一个新项目。获取你的 Project ID（类似 <code>k8z2ab3xxx</code> 这样的字符串）。</p>\n<h4 id=\"2-环境变量配置\">2. 环境变量配置</h4>\n<p>下面通过环境变量配置与日期判断代码，实现新年期间的逻辑控制，请参考具体实现。</p>\n\n<pre><code class=\"language-text\">46 |         function isLunarNewYearPeriod() {\n47 |           const now = new Date();\n48 |           const year = now.getFullYear();\n49 |           const month = now.getMonth() + 1; // 1-12\n50 |           const day = now.getDate();\n51 | \n52 |           // 2025年蛇年新年期间 (1月29日 - 2月12日)\n53 |           if (year === 2025) {\n54 |             if (month === 1 &amp;&amp; day &gt;= 29) return true;\n55 |             if (month === 2 &amp;&amp; day &lt;= 12) return true;\n56 |           }\n57 |           // 2026年马年新年期间 (2月17日 - 3月3日)\n58 |           if (year === 2026) {\n59 |             if (month === 2 &amp;&amp; day &gt;= 17) return true;\n60 |             if (month === 3 &amp;&amp; day &lt;= 3) return true;\n61 |           }\n62 |           return false;\n63 |         }\n64 | \n65 |         const stored = localStorage.getItem('starlight-theme');\n</code></pre>\n<p><em>文件：<code>src/pages/index.astro</code></em></p>\n<p>为了安全起见，不要硬编码 ID。建议将 ID 存入环境变量。</p>\n<p>在项目根目录创建 <code>.env</code> 文件：</p>\n<pre><code class=\"language-bash\"># Microsoft Clarity ID\nPUBLIC_CLARITY_ID=\"你的_Clarity_ID\"\n</code></pre>\n<h4 id=\"3-创建覆盖组件\">3. 创建覆盖组件</h4>\n<p>以下是监听系统主题变化的实现代码，展示了如何仅在未手动设置时跟随系统切换主题。</p>\n\n<pre><code class=\"language-markdown\">445 |     const handleChange = (e: MediaQueryListEvent) =&gt; {\n446 |       // 仅在用户未手动设置时跟随系统\n447 |       if (!localStorage.getItem(THEME_KEY)) {\n448 |         setThemeState(e.matches ? 'dark' : 'light');\n449 |       }\n450 |     };\n451 | \n452 |     mediaQuery.addEventListener('change', handleChange);\n453 |     return () =&gt; mediaQuery.removeEventListener('change', handleChange);\n454 |   }, []);\n455 | \n456 |   return { theme, toggleTheme, setTheme: manuallySetTheme };\n457 | }\n458 | ```\n459 | \n460 | #### 3. `src/components/ThemeButton.tsx` - 按钮组件\n461 | \n462 | **职责**：渲染主题切换按钮，处理用户交互\n463 | \n464 | **组件接口**：\n</code></pre>\n<p><em>文件：<code>openspec/changes/archive/2026-01-29-theme-toggle-implementation/design.md</code></em></p>\n<p>在 <code>src/components/</code> 目录下创建文件 <code>StarlightFooter.astro</code>。Starlight 会自动识别这个文件并覆盖默认的 Footer。</p>\n<p>核心代码逻辑如下：</p>\n<pre><code class=\"language-astro\">---\n// src/components/StarlightFooter.astro\n// 1. 引入原始组件以保留其默认功能\nimport DefaultFooter from '@astrojs/starlight/components/StarlightFooter.astro';\n\n// 2. 获取环境变量\nconst clarityId = import.meta.env.PUBLIC_CLARITY_ID;\n\n// 3. 定义简单的注入脚本（内联方式）\n// 注意：生产环境建议将此逻辑抽离到单独的 .js 文件中以利用缓存\nconst initScript = `\n(function(c,l,a,r,i,t,y){\n    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};\n    t=l.createElement(r);t.async=1;t.src=\"https://www.clarity.ms/tag/\"+i;\n    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);\n})(window, document, \"clarity\", \"script\", \"${clarityId}\");\n`;\n---\n\n&lt;DefaultFooter {...Astro.props} /&gt;\n\n{/* 仅在生产环境且 ID 存在时注入脚本 */}\n{import.meta.env.PROD &amp;&amp; clarityId &amp;&amp; (\n  &lt;script is:inline define:vars={{ clarityId }}&gt;\n    {initScript}\n  &lt;/script&gt;\n)}\n</code></pre>\n<p><strong>关键点解析</strong>：</p>\n<ul>\n<li><code>is:inline</code>：告诉 Astro 不要处理这个 script 标签内的内容，直接输出到 HTML。这对第三方统计脚本至关重要，否则 Astro 的打包优化可能会导致脚本失效。</li>\n<li><code>define:vars</code>：这是 Astro 3+ 的特性，允许在作用域内安全地注入变量。</li>\n<li><code>import.meta.env.PROD</code>：确保在本地开发时（除非为了调试）不产生无效统计，保持数据纯净。</li>\n</ul>\n<h3 id=\"进阶隐私合规与-cookie-控制\">进阶：隐私合规与 Cookie 控制</h3>\n<p>仅仅加上代码是不够的，特别是在 GDPR 管辖区域。我们需要尊重用户的选择。</p>\n<p>HagiCode 的做法是提供一个简单的开关。虽然这不是全功能的 Cookie Banner，但对于纯展示的技术文档站点来说，通常属于\"必要\"或\"统计\"类 Cookie，可以通过隐私声明告知并默认开启，或者在 Footer 链接到隐私设置页面。</p>\n<p>如果需要更严谨的控制，你可以结合 <code>localStorage</code> 来记录用户的选择：</p>\n<p>本文将介绍用于主题切换与持久化的 TypeScript 工具函数，通过类型安全与环境检测实现严谨控制。</p>\n\n<pre><code class=\"language-markdown\">367 | export function getInitialTheme(): Theme;\n368 | export function getSystemTheme(): Theme;\n369 | export function setTheme(theme: Theme): void;\n370 | export function applyTheme(theme: Theme): void;\n371 | ```\n372 | \n373 | **设计原则**：\n374 | - **纯函数**：无副作用（除了 `setTheme` 和 `applyTheme`）\n375 | - **类型安全**：完整的 TypeScript 类型推导\n376 | - **环境检测**：SSR 安全（`typeof window` 检查）\n377 | - **单一职责**：每个函数只做一件事\n378 | \n379 | **关键实现**：\n380 | ```typescript\n381 | export function getInitialTheme(): Theme {\n382 |   if (typeof window === 'undefined') return 'dark';\n383 | \n384 |   const stored = localStorage.getItem(THEME_KEY);\n385 |   if (stored === 'light' || stored === 'dark') return stored;\n386 | \n</code></pre>\n<p><em>文件：<code>openspec/changes/archive/2026-01-29-theme-toggle-implementation/design.md</code></em></p>\n<pre><code class=\"language-javascript\">// 简单示例：检查用户是否拒绝统计\nconst consent = localStorage.getItem('clarity_consent');\nif (consent !== 'denied') {\n    // 执行上面的 Clarity 初始化代码\n    window.clarity('start', clarityId);\n}\n</code></pre>\n<h2 id=\"经验总结与坑点\">经验总结与坑点</h2>\n<p>在将这套方案落地到 HagiCode 的过程中，我们总结了几个容易被忽视的细节：</p>\n<ol>\n<li>\n<p><strong><code>StarlightWrapper.astro</code> 是个陷阱</strong>：<br />\n如前所述，不要试图去创建一个全局 Wrapper 来注入脚本，这在 Starlight 中行不通。老老实实覆盖特定组件（如 <code>StarlightFooter.astro</code> 或 <code>StarlightHead.astro</code>）才是正解。</p>\n</li>\n<li>\n<p><strong>脚本位置的性能考量</strong>：<br />\n虽然 Clarity 建议放在 <code>&lt;head&gt;</code> 中以确保数据准确性，但对于文档站点，首屏加载速度（LCP）直接影响了 SEO 和用户留存。我们选择了放在 Footer（Body 底部），这会轻微丢失极少量\"秒退\"用户的数据，但换来了更快的页面加载体验，这是一个值得的权衡。</p>\n</li>\n<li>\n<p><strong>开发环境的干扰</strong>：<br />\n一定要加上 <code>import.meta.env.PROD</code> 判断。在开发模式下，你会频繁刷新页面，这会产生大量无意义的测试数据，污染你的 Clarity 仪表盘。</p>\n</li>\n</ol>\n<h2 id=\"效果验证\">效果验证</h2>\n<p>部署完成后，你可以在 Clarity 控制台查看实时数据。通常在几分钟内，你就能看到用户的heatmap（热力图）和 recordings（录屏）。</p>\n<p>对于 HagiCode 来说，通过这些数据我们发现：</p>\n<ul>\n<li>很多用户会反复查看\"快速开始\"章节，说明我们的安装指引可能还不够直观。</li>\n<li>\"API 参考\"页面的停留时间最长，证实了我们核心用户群体的需求。</li>\n</ul>\n<h2 id=\"总结\">总结</h2>\n<p>接入 Microsoft Clarity 并不需要复杂的服务端改造，也不需要引入沉重的 SDK。</p>\n<p>利用 Starlight 的组件覆盖机制，我们仅通过一个轻量级的 <code>StarlightFooter.astro</code> 组件，就实现了全局数据统计。这种\"微集成\"的方式，既保证了代码的整洁，又赋予了我们洞察用户行为的能力。</p>\n<p>如果你也在运营技术类项目，特别是像 <strong>HagiCode</strong> 这样需要不断迭代文档的项目，强烈建议尝试接入 Clarity。数据会告诉你，用户真正的痛点在哪里。</p>\n<h2 id=\"参考资料\">参考资料</h2>\n<ul>\n<li><a href=\"https://github.com/HagiCode-org/site\" rel=\"noopener nofollow\" target=\"_blank\">HagiCode GitHub 仓库</a> - 查看我们在实际项目中的配置文件</li>\n<li><a href=\"https://learn.microsoft.com/en-us/clarity/\" rel=\"noopener nofollow\" target=\"_blank\">Microsoft Clarity 官方文档</a></li>\n<li><a href=\"https://starlight.astro.build/guides/overriding-components/\" rel=\"noopener nofollow\" target=\"_blank\">Starlight 组件覆盖指南</a></li>\n</ul>\n<hr />\n<p>感谢您的阅读,如果您觉得本文有用,快点击下方点赞按钮👍,让更多的人看到本文。</p>\n<p>本内容采用人工智能辅助协作,经本人审核,符合本人观点与立场。</p>\n<ul>\n<li><strong>本文作者:</strong> <a href=\"https://www.newbe.pro\" rel=\"noopener nofollow\" target=\"_blank\">newbe36524</a></li>\n<li><strong>本文链接:</strong> <a href=\"https://hagicode-org.github.io/site/blog/2026-02-04-starlight-docs-integration-microsoft-clarity/\" rel=\"noopener nofollow\" target=\"_blank\">https://hagicode-org.github.io/site/blog/2026-02-04-starlight-docs-integration-microsoft-clarity/</a></li>\n<li><strong>版权声明:</strong> 本博客所有文章除特别声明外,均采用 BY-NC-SA 许可协议。转载请注明出处!</li>\n</ul>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-05 09:13</span>&nbsp;\n<a href=\"https://www.cnblogs.com/newbe36524\">Newbe36524</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "基于Ai Coding,20天完成一个基于大模型的医学分析系统：Ai体征分析助手",
      "link": "https://www.cnblogs.com/lsjwq/p/19577341",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lsjwq/p/19577341\" id=\"cb_post_title_url\" title=\"发布于 2026-02-05 08:52\">\n    <span>基于Ai Coding,20天完成一个基于大模型的医学分析系统：Ai体征分析助手</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        我是一名长期使用C#开发后台服务与数据库的开发者，在短短20天内，独立完成一个跨前后端、贴合医疗健康场景分析的完整系统（Ai体征分析助手）是未曾想过的。得益于AI Coding工具的深度实践与应用和医疗领域大模型的应用，让我对AI时代的软件开发有了全新的认知。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>目录</p>\n<p><strong>1.Ai Copilot</strong><strong>实践与应用</strong>... 1</p>\n<p><strong>2.Ai Coding</strong><strong>带来的好处与挑战</strong>... 1</p>\n<p><strong>2.1 </strong><strong>带来的好处</strong>... 2</p>\n<p><strong>2.2 </strong><strong>面临的挑战</strong>... 2</p>\n<p><strong>3.Ai</strong><strong>体征分析助手项目介绍</strong>... 2</p>\n<p><strong>3.1</strong><strong>业务介绍</strong>... 2</p>\n<p><strong>3.2</strong><strong>技术体系</strong>... 7</p>\n<p><strong>4.</strong><strong>总结</strong>... 8</p>\n<hr />\n<p style=\"text-align: center;\">&nbsp;<strong>基于</strong><strong>Ai Coding</strong><strong>，</strong><strong>20</strong><strong>天完成一个基于大模型的医学分析系统：</strong><strong>Ai</strong><strong>体征分析助手</strong>&nbsp;</p>\n<p><span style=\"font-size: 16px;\">　　我是一名长期使用C#开发后台服务与数据库的开发者，在短短20天内，独立完成一个跨前后端、贴合医疗健康场景分析的完整系统（<a href=\"https://www.aineuos.net/\" rel=\"noopener nofollow\">Ai体征分析助手</a>）是未曾想过的。得益于AI Coding工具的深度实践与应用和医疗领域大模型的应用，让我对AI时代的软件开发有了全新的认知。</span></p>\n<p><span style=\"font-size: 16px;\"><img alt=\"Snipaste_2026-02-04_14-30-34\" src=\"https://img2024.cnblogs.com/blog/279374/202602/279374-20260205085311503-166624795.jpg\" /></span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-size: 18px;\"><strong>1.Ai Copilot</strong><strong>实践与应用</strong></span></p>\n<p><span style=\"font-size: 16px;\">　　在本次Ai体征分析助手的开发过程中，我全程以VSCode+AI Copilot为核心开发工具，前期自己写了一个简单的想法和需求，但是需求变更很大。AI Copilot全程参与了其他环节：界面生成、代码开发、前后端测试、合理化建议等，需要开发者与工具形成高效配合。有三个实践感悟：</span></p>\n<p><span style=\"font-size: 16px;\"><strong>　　首先，</strong><strong>AI Copilot</strong><strong>的付费模式性价比高</strong>，我只是个人付费版本，不是专业版本，相较于聘请专业的前后端开发人员，付费工具的成本几乎可以忽略不计，无需担心沟通成本、时间协调等问题，一般干到晚上10点，有时候早上5点起来接着干。</span></p>\n<p><span style=\"font-size: 16px;\"><strong>　　其次，</strong><strong>AI Copilot</strong><strong>能够实现前后端代码的协同生成</strong>，大幅缩短开发周期。以往前端、后端分开编写代码，花费大量时间。本次开发中，我只需明确需求（例如“开发一个医学影像上传接口，对接后端PostgreSQL数据库”、“开发前端影像上传组件，适配电脑端和手机端浏览器”等），AI Copilot就能生成对应的后端Flask接口代码、前端Vue组件代码，甚至自动生成接口调用示例和调试代码。当然，还有其他代码提示、合理化建议等方面的优势 。</span></p>\n<p><span style=\"font-size: 16px;\"><strong>　　最后，</strong><strong>AI</strong><strong>生成代码逻辑需要开发者亲自</strong><strong>review</strong><strong>验证</strong>。AI Copilot虽然能快速生成代码，但是无法完全理解项目的整体架构逻辑和业务细节，偶尔会出现代码逻辑不严谨、参数缺失、安全漏洞（例如用户认证逻辑不完善、支付接口签名错误）等问题。因此，结合项目需求调整逻辑、补充细节、修复漏洞等。</span></p>\n<p><span style=\"font-size: 18px;\"><strong>2.Ai Coding</strong><strong>带来的好处与挑战</strong></span></p>\n<p><span style=\"font-size: 16px;\">　　20天的开发历程，从全新的医疗场景需求，到可正常运行的跨端系统，AI Coding给我带来的不仅是开发效率的提升，更有对职业发展、工作生活方式的深刻影响。</span></p>\n<p><span style=\"font-size: 18px;\"><strong>2.1 </strong><strong>带来的好处</strong></span></p>\n<p><span style=\"font-size: 16px;\">　　（1）<strong>大幅提升开发效率，降低小团体与个人创业的门槛</strong>。我原本只擅长C#后端开发，对Python、Vue、TypeScript等技术并不熟悉，但是借助AI Coding，顺利完成接口开发、前端页面、跨端适配等，20天开发周期，相较于传统开发模式大幅缩减开发周期，全程无需依赖其他开发者，让个人创业的门槛大幅降低。</span></p>\n<p><span style=\"font-size: 16px;\">　　（2）<strong>改变工作与生活的模式，让零碎时间发挥更大价值</strong>。以往开发一个完整的项目，往往需要集中大量的整块时间。这种开发模式无需集中整块时间，既能兼顾全职工作，又能利用零碎时间做自己喜欢的事情。但是，在“高效利用时间”的同时，也会促使人更加有压迫感，所以需要个人来调节状态。</span></p>\n<p><span style=\"font-size: 16px;\">　　（3）<strong>打破技术壁垒，为跨界开发提供了更大可能</strong>。跨界开发需要花费大量时间学习新的技术栈，我原本专注于C#后端服务与数据库开发，但在本次项目开发中，短短20天，打破技术边界，一个人使用AI Coding完成python、vue、数据库、大模型等整合。</span></p>\n<p><span style=\"font-size: 18px;\"><strong>2.2 </strong><strong>面临的挑战</strong></span></p>\n<p><span style=\"font-size: 16px;\"><strong>　　（</strong><strong>1</strong><strong>）普通工程师面临失业风险，技术门槛重新定义</strong>。AI Coding能够快速生成基础代码、完成重复性开发工作，这对于从事基础代码编写的普通工程师而言，未来面临很大失业风险。</span></p>\n<p><span style=\"font-size: 16px;\"><strong>　　（</strong><strong>2</strong><strong>）行业对创新与设计人才的需求大幅提升</strong>。AI Coding解决“怎么写代码”的问题，但无法解决“写什么代码”“为什么要这么写”的问题，这意味着，不再是会写代码就能立足，更需要具备需求梳理、架构设计、产品创新能力的人。</span></p>\n<p><span style=\"font-size: 16px;\"><strong>　　（</strong><strong>3</strong><strong>）</strong><strong>AI Coding</strong><strong>并非</strong><strong>“</strong><strong>零门槛</strong><strong>”</strong><strong>，不懂编程的人难以独立完成工程项目</strong>。AI Coding的核心价值是“辅助”，而非“替代”——它需要开发者具备基本的编程知识、逻辑思维能力，能够明确需求、梳理逻辑、review代码等。AI Coding降低了软件开发“技术门槛”，但并未消除门槛，它更适合有一定编程基础、能够与AI高效配合的开发者，而非完全不懂编程的“小白”。</span></p>\n<p><span style=\"font-size: 18px;\"><strong>3.Ai</strong><strong>体征分析助手项目介绍</strong></span></p>\n<p><span style=\"font-size: 18px;\"><strong>3.1</strong><strong>业务</strong><strong>介绍</strong></span></p>\n<p><span style=\"font-size: 16px;\">　　Ai体征分析助手的口号：“<strong>让医疗更智慧，让健康更普惠</strong>”。</span></p>\n<p><span style=\"font-size: 16px;\">　　Ai体征分析助手依托先进的人工智能专业模型，能够精准解读和分析各类医学影像与健康数据，全面覆盖普通大众的基础健康筛查需求。</span></p>\n<p><span style=\"font-size: 16px;\"><strong>　　- **</strong><strong>医学影像</strong><strong>**</strong><strong>：</strong><strong>CT</strong><strong>扫描、核磁共振</strong><strong>(MRI)</strong><strong>影像、组织病理成像等</strong></span></p>\n<p><span style=\"font-size: 16px;\"><strong>　　- **</strong><strong>临床影像</strong><strong>**</strong><strong>：胸部</strong><strong>X</strong><strong>光片、皮肤科图像、眼科图像等</strong></span></p>\n<p><span style=\"font-size: 16px;\"><strong>　　- **</strong><strong>医疗数据</strong><strong>**</strong><strong>：医生诊断病历、电子健康记录</strong><strong>(EHR)</strong><strong>、解剖特征数据</strong></span></p>\n<p><span style=\"font-size: 16px;\">　　后台人工智能医学模型，已经在多项临床相关基准评估中展现出稳定、可靠的基础性能，能够为分析结果提供有力的技术保障，确保分析建议的科学性、参考性。</span></p>\n<p><span style=\"font-size: 16px;\">　　Ai体征分析助手有<strong>四大核心优势</strong>，能够切实解决大家在健康筛查、就医过程中遇到的痛点问题：</span></p>\n<p><span style=\"font-size: 16px;\"><strong>　　（1）居家提早筛查</strong>：在家即可完成初步健康筛查，主动预防疾病，守护普通大众的健康。</span></p>\n<p><span style=\"font-size: 16px;\"><strong>　　（2）高效便捷</strong>：快速分析影像与病历，缩短就医等待时间，缓解就医焦虑。</span></p>\n<p><span style=\"font-size: 16px;\"><strong>　　（3）打破地域和资源壁垒</strong>：让优质医疗AI资源跨越地域，特别是让偏远地区的普通大众也能享受到优质的AI医疗服务。</span></p>\n<p><span style=\"font-size: 16px;\"><strong>　　（4）经济实惠</strong>：辅助分析验证信息，有效降低医疗成本，让普惠医疗真正落地。</span></p>\n<p><span style=\"font-size: 16px;\">　　Ai体征分析助手的核心目标，让人工智能走进千家万户，让普通大众在家就能完成初步健康筛查，不用再为了简单的健康咨询奔波往返医院，轻松实现疾病早发现、早预防，大大提升大家疾病预防的主动性。</span></p>\n<p><span style=\"font-size: 16px;\">　　特别提醒大家：<strong>AI</strong><strong>体征分析助手仅为人工智能模型分析得出的参考结果，不能替代正规医院的专业诊断，若有健康疑虑，请务必咨询专业医疗机构和医生</strong>。</span></p>\n<p><span style=\"font-size: 16px;\">　　（1）&nbsp;&nbsp;&nbsp; <strong>电脑端浏览器应用</strong>：医学分析、历史分析、邀请记录、赞助记录、提现记录、我的信息、邀请好友等。</span></p>\n<p><span style=\"font-size: 16px;\"><img alt=\"1\" src=\"https://img2024.cnblogs.com/blog/279374/202602/279374-20260205085043467-1636338170.jpg\" /></span></p>\n<p><img alt=\"2\" src=\"https://img2024.cnblogs.com/blog/279374/202602/279374-20260205085055078-1972974666.jpg\" /></p>\n<p><img alt=\"3\" src=\"https://img2024.cnblogs.com/blog/279374/202602/279374-20260205085101120-1634808551.jpg\" /></p>\n<p><img alt=\"4\" src=\"https://img2024.cnblogs.com/blog/279374/202602/279374-20260205085109946-801721347.jpg\" /></p>\n<p><img alt=\"5\" src=\"https://img2024.cnblogs.com/blog/279374/202602/279374-20260205085115893-1478473000.jpg\" /></p>\n<p><img alt=\"6\" src=\"https://img2024.cnblogs.com/blog/279374/202602/279374-20260205085122155-1181622956.jpg\" /></p>\n<p><img alt=\"7\" src=\"https://img2024.cnblogs.com/blog/279374/202602/279374-20260205085127663-613759521.jpg\" /></p>\n<p><span style=\"font-size: 16px;\">　　</span><span style=\"font-size: 16px;\">（2）&nbsp;&nbsp;&nbsp; </span><strong style=\"font-size: 16px;\">手机端浏览器应用</strong><span style=\"font-size: 16px;\">：医学分析、历史分析、邀请记录、赞助记录、提现记录、我的信息、邀请好友等。</span></p>\n<p><span style=\"font-size: 16px;\"><img alt=\"全部\" src=\"https://img2024.cnblogs.com/blog/279374/202602/279374-20260205085141446-1921050907.png\" /></span></p>\n<p><strong style=\"font-size: 18px;\">3.2</strong><strong style=\"font-size: 18px;\">技术体系</strong></p>\n<p>&nbsp;</p>\n<p><span style=\"font-size: 16px;\"><strong>## 后端技术栈</strong></span></p>\n<p><span style=\"font-size: 16px;\">- **框架**：Flask 3.x</span></p>\n<p><span style=\"font-size: 16px;\">- **数据库**：PostgreSQL + SQLAlchemy ORM</span></p>\n<p><span style=\"font-size: 16px;\">- **鉴权**：JWT Token</span></p>\n<p><span style=\"font-size: 16px;\">- **支付**：微信支付 V3（Native/JSAPI）</span></p>\n<p><span style=\"font-size: 16px;\">- **短信**：阿里云短信</span></p>\n<p><span style=\"font-size: 16px;\">- **模型**：PyTorch + Transformers（医学诊断模型）</span></p>\n<p><span style=\"font-size: 16px;\">- **API**：RESTful API设计</span></p>\n<p><span style=\"font-size: 16px;\"><strong>## 前端技术栈</strong></span></p>\n<p><span style=\"font-size: 16px;\">- **框架**：Vue 3 + TypeScript</span></p>\n<p><span style=\"font-size: 16px;\">- **构建工具**：Vite</span></p>\n<p><span style=\"font-size: 16px;\">- **路由**：Vue Router</span></p>\n<p><span style=\"font-size: 16px;\">- **样式**：Scoped CSS</span></p>\n<p><span style=\"font-size: 16px;\">- **文档渲染**：@kangc/v-md-editor / Marked</span></p>\n<p><span style=\"font-size: 16px;\">- **导出**：HTML2Canvas + HTML2PDF</span></p>\n<p><span style=\"font-size: 16px;\">- **其他**：QRCode</span></p>\n<p><span style=\"font-size: 16px;\"><strong>## 核心模块</strong></span></p>\n<p><span style=\"font-size: 16px;\">| 模块 | 功能 | 说明 |</span></p>\n<p><span style=\"font-size: 16px;\">|------|------|------|</span></p>\n<p><span style=\"font-size: 16px;\">| 用户认证 | 注册、登录、信息管理 | 安全的身份验证 |</span></p>\n<p><span style=\"font-size: 16px;\">| 医学诊断 | 影像上传、分析、结果展示 | AI诊断核心模块 |</span></p>\n<p><span style=\"font-size: 16px;\">| 分析历史 | 记录查询、删除、PDF下载 | 完整的数据管理 |</span></p>\n<p><span style=\"font-size: 16px;\">| 个人中心 | 用户信息修改、密码修改 | 用户自助管理 |</span></p>\n<p><span style=\"font-size: 16px;\">| 支付与提现 | 微信支付、提现、支付记录、提现记录 | 资金相关能力 |</span></p>\n<p><span style=\"font-size: 16px;\">| 邀请好友 | 邀请码生成、邀请记录 | 用户增长与奖励 |</span></p>\n<p><span style=\"font-size: 16px;\"><strong>## 使用说明</strong></span></p>\n<p><span style=\"font-size: 16px;\">1. **注册登录** - 创建账户或使用现有账户登录</span></p>\n<p><span style=\"font-size: 16px;\">2. **提交诊断** - 上传医学影像和必要的医学描述</span></p>\n<p><span style=\"font-size: 16px;\">3. **等待分析** - 系统进行AI分析（显示分析状态）</span></p>\n<p><span style=\"font-size: 16px;\">4. **查看结果** - 查看详细的分析结果和建议</span></p>\n<p><span style=\"font-size: 16px;\">5. **管理记录** - 查看历史记录、下载报告、删除数据</span></p>\n<p><span style=\"font-size: 18px;\"><strong>4.</strong><strong>总结</strong></span></p>\n<p><span style=\"font-size: 16px;\">　　从需求梳理到代码落地，从功能调试到最终上线，20天的开发历程，这是碳基生命+硅基生命的完美协作，让我对软件开发的未来有了全新的认知。AI不会替代开发者，但会淘汰不懂得利用AI、不懂得提升自己的开发者。让我们利用AI技术做一些更有意义的事。</span></p>\n<p><span style=\"font-size: 16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>Github</strong>: <a href=\"https://github.com/wxzz/\" rel=\"noopener nofollow\">https://github.com/wxzz/</a>。</span></p>\n<p><span style=\"font-size: 16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>博客</strong>：<a href=\"https://www.cnblogs.com/lsjwq\">https://www.cnblogs.com/lsjwq</a>。</span></p>\n<p><span style=\"font-size: 16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>Ai</strong><strong>体征分析助手试用</strong>：<a href=\"https://www.aineuos.net/\" rel=\"noopener nofollow\">https://www.aineuos.net/</a>。</span></p>\n<hr />\n<p>物联网&amp;大数据技术 QQ群：54256083</p>\n<p>物联网&amp;大数据项目 QQ群：727664080</p>\n<p>QQ：504547114</p>\n<p><img alt=\"image\" height=\"121\" src=\"https://img2024.cnblogs.com/blog/279374/202509/279374-20250924180005285-1427975355.png\" width=\"243\" /></p>\n<p>&nbsp;</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-05 08:52</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lsjwq\">iNeuOS工业互联网系统</a>&nbsp;\n阅读(<span id=\"post_view_count\">66</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "[开源分享] ChatGPT 浏览器效率插件：对话可视化为图谱及时间线，快速定位消息，把握对话脉络",
      "link": "https://www.cnblogs.com/roberick/p/19577242",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/roberick/p/19577242\" id=\"cb_post_title_url\" title=\"发布于 2026-02-05 08:28\">\n    <span>[开源分享] ChatGPT 浏览器效率插件：对话可视化为图谱及时间线，快速定位消息，把握对话脉络</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"[开源分享] ChatGPT 浏览器效率插件：对话可视化为图谱及时间线，快速定位消息，把握对话脉络\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/2733976/202602/2733976-20260205082744246-958830395.png\" />\n        将 ChatGPT 转化为可导航的知识图谱。利用图谱视图可视化复杂分支，通过 Git 风格的时间线树管理历史记录，并将不断实现丰富的实用功能。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<div align=\"center\">\n<img alt=\"ChatGPT Graph\" class=\"lazyload\" width=\"128\" />\n<h1>ChatGPT Graph Navigator</h1>\n<table>\n<tbody><tr>\n<td align=\"center\" width=\"200\">\n<img alt=\"Graph View Icon\" class=\"lazyload\" height=\"45\" width=\"45\" />\n</td>\n<td align=\"center\" width=\"200\">\n<img alt=\"Timeline Tree Icon\" class=\"lazyload\" height=\"45\" width=\"45\" />\n</td>\n<td align=\"center\" width=\"200\">\n<img alt=\"Workflow Utils Icon\" class=\"lazyload\" height=\"45\" width=\"45\" />\n</td>\n</tr>\n<tr>\n<td align=\"center\">\n<strong>图谱视图</strong>\n</td>\n<td align=\"center\">\n<strong>时间线树</strong>\n</td>\n<td align=\"center\">\n<strong>实用工具</strong>\n</td>\n</tr>\n<tr>\n<td align=\"center\">\n<sub>空间可视化<br />逻辑全景概览</sub>\n</td>\n<td align=\"center\">\n<sub>分支快速导航<br />Git 风格历史记录</sub>\n</td>\n<td align=\"center\">\n<sub>消息折叠<br />及未来更多功能</sub>\n</td>\n</tr>\n</tbody></table>\n<h4>\n✨ 将聊天记录转化为交互式树状图。<br />\n专为 ChatGPT 对话打造的高效思维导图UI。\n</h4></div>\n\n<hr />\n<div align=\"center\">\n仓库链接：<a href=\"https://github.com/Robbings/chatgpt-graph-navigator\" rel=\"noopener nofollow\" style=\"display: inline-block; padding: 10px 20px; background-color: rgba(36, 41, 46, 1); color: rgba(255, 255, 255, 1); text-decoration: none; border-radius: 6px; font-weight: bold;\" target=\"_blank\"> https://github.com/Robbings/chatgpt-graph-navigator </a>\n</div>\n<hr />\n<h2 id=\"一为什么我们需要非线性对话\">一、为什么我们需要非线性对话？</h2>\n<p>相比于Gemini，ChatGPT支持通过修改提问或者回答，产生新的对话分支，并且每一个分支都可以被保存和重新访问。</p>\n<p><img alt=\"intro1\" class=\"lazyload\" /></p>\n<p>我个人非常喜欢这个功能。因为<strong>复杂问题的解决包含了不断地假设，试错和分支探索</strong> ，而这个功能让多分支的图谱式对话成为可能。</p>\n<p>举个栗子，比如搞科研或者开发一个项目的时候让GPT生成方案，它会提供多个选择，针对每一个方案我需要并行地讨论，然后确认如何选择。如果纯线性对话，一方面后续很难定位和复盘，另一方面，假设我最终选定一套方案，其他方案的大量对话就会变成无用的上下文，干扰模型思考和后续的复盘。而方案开始实施后我也会遇到很多问题需要处理，这些问题有些彼此相关，有些彼此无关，这时我也会使用分支功能，每个分支解决一个独立的问题。</p>\n<p>所以在进行复杂对话的时候，如果采用线性对话，会有诸多弊端，比如：</p>\n<ul>\n<li><strong>📉 “上下文污染”问题：</strong>  当你在同一个对话流中按顺序尝试不同方案时，无关的上下文和失败的尝试会不断堆积。这种“噪音”不仅消耗 Token 配额，还会干扰模型的注意力，使其难以针对你当前的策略提供最精准的分析。</li>\n<li><strong>🔀 “并行探索”的刚需：</strong>  为了获取最佳结果，你往往需要对对话进行“分叉”——通过修改 Prompt 或重新生成回复来测试不同的路径。在线性界面中，管理这些“平行宇宙”简直是一场灾难。你很容易忘记思路是在哪里分岔的，也记不清哪个分支产出了最佳结果。</li>\n<li><strong>🧠 逻辑混乱，定位困难：</strong>  试图在脑海中复盘 20 分钟前的 Prompt 与刚刚写好的新变体之间的逻辑关系，是一件极度消耗精力的事情。</li>\n</ul>\n<p><strong>ChatGPT Graph Navigator 专为解决此问题而生。</strong>  我们将你的分支可视化，帮助你<strong>隔离上下文</strong>以获取更纯净的模型输出，同时让你原本复杂的推理结构变得井井有条。</p>\n<h2 id=\"二功能介绍\">二、功能介绍</h2>\n<p><img alt=\"main_feature\" class=\"lazyload\" /></p>\n<h3 id=\"核心能力一览\">核心能力一览：</h3>\n<ul>\n<li><strong>🎨 两种界面：</strong> 选择 <strong>侧边栏 (Sidebar)</strong> 享受常驻的沉浸式工作流，或使用 <strong>悬浮窗 (Floating Window)</strong> 进行随叫随到的轻量化查看。</li>\n<li><strong>👁️ 两个可视化视图：</strong></li>\n<li><strong>图谱视图 (Graph View)：</strong> 采用思维导图结构，助你一眼掌握对话“全局”与逻辑脉络。</li>\n<li><strong>时间线树 (Timeline Tree)：</strong> 采用 Git 风格的垂直树状图，精准追踪每一次细微的修改与分支。</li>\n<li><strong>⚡ 导航：</strong> 点击任意节点即可 <strong>直接跳转</strong> 至对应分支的具体消息，瞬间还原历史上下文。</li>\n<li><strong>🔍 搜索：</strong> 在整个对话树中快速定位特定的 Prompt 或 AI 回复，不再迷失在长对话中。</li>\n<li><strong>🛠️ 实用工具：</strong> 内置长消息自动折叠功能，并计划持续集成更多效率工具（如导出、格式化等）。</li>\n</ul>\n<h3 id=\"更多功能展示\">更多功能展示</h3>\n<h4 id=\"1-侧边栏\">1. 侧边栏</h4>\n<p><img alt=\"sidepanel\" class=\"lazyload\" /></p>\n<p>侧边栏专为提升效率而生，提供两种模式以契合您的工作流：</p>\n<h4 id=\"a-图谱模式-graph-mode\">a. 图谱模式 (Graph Mode)</h4>\n<p><em>掌控结构与上下文跳转的最佳选择。</em></p>\n<ul>\n<li><strong>空间掌控：</strong> 支持自由缩放与平移，瞬间掌握对话主题的完整拓扑结构。</li>\n<li><strong>一键跳转：</strong> 点击图谱中的任意消息节点，即可 <strong>瞬间跳转</strong> 到任意分支的任意对话，并立即恢复当时的上下文环境。</li>\n</ul>\n<h4 id=\"b-时间线模式-timeline-mode\">b. 时间线模式 (Timeline Mode)</h4>\n<p><em>精准定位与内容检索的利器。</em></p>\n<ul>\n<li><strong>专注筛选：</strong> 信息噪音太多？切换过滤器以显示 <strong>全部问答</strong>、<strong>仅问题 (Prompts)</strong> 或 **仅回答 **。非常适合快速回顾您的 Prompt 迭代历史。同时也支持点击跳转。</li>\n<li><strong>即时搜索：</strong> 使用内置搜索栏快速定位关键词，快速定位消息，回车直接跳转。</li>\n</ul>\n<h4 id=\"2-悬浮窗\">2. 悬浮窗</h4>\n<p><img alt=\"float_main\" class=\"lazyload\" /></p>\n<ul>\n<li>🚀 <strong>拖拽与缩放：</strong> 在屏幕任意位置访问完整的图谱/时间线视图。</li>\n<li>👻 <strong>穿透模式：</strong> 点击穿透按钮，直接与悬浮窗背后的页面进行交互，互不干扰。</li>\n<li>📌 <strong>固定与融合：</strong> 支持窗口 <strong>置顶</strong> 并自由调节 <strong>透明度</strong>。</li>\n</ul>\n<h4 id=\"3-长消息折叠\">3. 长消息折叠</h4>\n<p><img alt=\"fold\" class=\"lazyload\" /></p>\n<ul>\n<li><strong>📂 消息自动折叠</strong>：长回复/代码块可自动或手动折叠，界面更清爽。</li>\n<li>支持自定义折叠提问或回答，可以设置折叠阈值，也可以手动折叠。</li>\n</ul>\n<h2 id=\"三后续计划\">三、后续计划</h2>\n<p>现在插件还在快速开发迭代的阶段，后续的计划主要包括：</p>\n<ol>\n<li>节点和分支的高亮，收藏，分类等功能。</li>\n<li>更多工具的集成，目前计划添加：对话或者消息级别的导出，其他功能如果需要欢迎issue。</li>\n<li><strong>图谱编辑：</strong> 删除不需要的分支或节点，以及手动编辑图谱结构，比如删除，添加节点间的连线，从而令图谱不再局限于消息结构，让逻辑更加清晰。</li>\n<li><strong>全局知识图谱：</strong> 实现针对项目或者自定义跨对话的更复杂的知识图谱构建和管理。</li>\n<li><strong>个人知识库的管理：</strong> 基于图谱构建个人的知识库，并支持知识库的管理，检索，导出，在对话中导入等功能。</li>\n</ol>\n<h3 id=\"四写在最后\">四、写在最后</h3>\n<p>最后的最后，非常欢迎感兴趣的朋友们试用本插件！ 目前项目还处于早期阶段，还有诸多 Bug 和不足，非常欢迎大家在 Issues 里反馈。如果觉得这个小工具对你有帮助，<strong>十分希望能得到您的一个 Star</strong>，这对我是莫大的鼓励。</p>\n<p>如果您有新的想法非常欢迎Fork我们的项目，并提交PR！</p>\n<p>最后最后的最后，再贴一下项目中文README的链接，项目和完整的介绍请参见：<a href=\"https://github.com/Robbings/chatgpt-graph-navigator/blob/master/README_ZH.md\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/Robbings/chatgpt-graph-navigator/blob/master/README_ZH.md</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-05 08:28</span>&nbsp;\n<a href=\"https://www.cnblogs.com/roberick\">Roberick</a>&nbsp;\n阅读(<span id=\"post_view_count\">42</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "[大模型实战 03预备] 云端炼丹房 2：Kaggle 上手指南",
      "link": "https://www.cnblogs.com/algieba/p/19576331",
      "published": "",
      "description": "<div class=\"postcontent\">\n\t\t\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"[大模型实战 03预备] 云端炼丹房 2：Kaggle 上手指南\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3169973/202602/3169973-20260204195327324-384345256.png\" />\n        Colab 额度用完了？Kaggle 带着两张 T4 显卡来了！本文详解 Kaggle 账号手机验证、开启 Internet 联网、配置双 T4 GPU 环境，以及如何利用 Kaggle 特有的 Dataset 机制持久化保存 HuggingFace 模型。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"大模型实战-03预备-云端炼丹房-2kaggle-上手指南\">[大模型实战 03预备] 云端炼丹房 2：Kaggle 上手指南</h1>\n<blockquote>\n<p><strong>核心摘要 (TL;DR)</strong></p>\n<ul>\n<li><strong>痛点</strong>：Colab 免费额度耗尽，或者单张 T4 显存（16GB）无法满足更大参数模型的微调需求。</li>\n<li><strong>方案</strong>：利用 <strong>Kaggle</strong> 提供的 <strong>每周 30 小时免费双路 T4 GPU (T4 x2)</strong> 算力。</li>\n<li><strong>技巧</strong>：通过 <strong>手机号验证</strong> 解锁联网权限，利用 <strong>Kaggle Datasets</strong> 实现模型的持久化存储。</li>\n<li><strong>目标</strong>：作为 Colab 的强力替补（甚至上位），搭建备用云端炼丹环境。</li>\n</ul>\n</blockquote>\n<h2 id=\"前言\">前言</h2>\n<p>上一篇中，本来想直接写到Google Colab的大模型推理脚本，让各位友人们感受一下在全参数7B模型的能力，但是折腾了很久，Colab读driver老是失败，当我想直接下载到云端主机而不是driver的时候，GPU的额度已经耗尽。索性今天在Kaggle的这篇博文中来讲，应该之后也主要用Kaggle来进行云端开发，毕竟Colab额度少，还得盯着，长时间不看会断掉连接。</p>\n<p>好，我们来先介绍一下今天的主角，Google 旗下的另一个神器：<a href=\"https://www.kaggle.com/\" rel=\"noopener nofollow\" target=\"_blank\"><strong>Kaggle</strong></a>。Colab如果说其本职就是模型训练，那<strong>Kaggle</strong>本身其实是一个数据科学的竞赛平台，毕竟是数据科学竞赛嘛，那自然得需要算力资源，<strong>Kaggle</strong>为了方便，也发挥了谷歌大善人的优良品质，免费提供了大方的计算资源。跟Colab对比起来，Kaggle的优势就是，更稳定，更方便，资源给的额度更多。</p>\n<h2 id=\"1-kaggle-notebooks-核心概念\">1. Kaggle Notebooks 核心概念</h2>\n<p>Kaggle 的核心编程环境叫 <strong>Kernels (现在统称 Notebooks)</strong>,不用害怕，诶，它就是我们昨儿刚认识的熟人<strong>云端服务器版</strong>的<strong>Jupyter Notebook</strong>,但是和Colab不太相同的是Kaggle的文件结构，它明显得区分了输入区域，输出区域，暂存区域, 这是也我们刚上手容易懵的地方:</p>\n<ul>\n<li><strong>Input (<code>/kaggle/input</code>)</strong>：<strong>只读区域</strong>。这里存放你上传的数据集或挂载的模型。读取速度极快，但无法写入。</li>\n<li><strong>Output (<code>/kaggle/working</code>)</strong>：<strong>可读写区域</strong>。这是你的主工作区，代码运行结果、下载的模型必须存在这里。但注意，重启 Session 后，这里的内容如果不保存为 Dataset 也会消失。</li>\n<li><strong>Temp (<code>/kaggle/temp</code>)</strong>：<strong>临时暂存区</strong>。空间较大（只有当前会话有效），适合下载解压临时的大文件。</li>\n</ul>\n<p><img alt=\"Kaggle notebook 文件系统结构图，展示 input/working/temp 的区别的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/kaggle_input_working_temp.png\" /></p>\n<h2 id=\"2-快速上手注册与解锁\">2. 快速上手：注册与“解锁”</h2>\n<h3 id=\"21-注册与关键验证-必做\">2.1 注册与关键验证 (必做)</h3>\n<p>我们新用户登录创建notebook后会发现，我们没有硬件加速设备可选。<br />\n<img alt=\"新用户的accelerator部分是灰色的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/no_gpu.png\" /><br />\n根本原因就是咱们没有进行手机验证，哈哈哈，可以理解，毕竟本身kaggle就不用绑卡，加上手机验证可能会杜绝掉一大部分计算资源滥用。</p>\n<ol>\n<li>访问 <a href=\"https://www.kaggle.com/\" rel=\"noopener nofollow\" target=\"_blank\">Kaggle 官网</a> 并注册账号。</li>\n<li><strong>关键步骤</strong>：点击右上角头像 -&gt; <strong>Settings</strong>。</li>\n<li>找到 <strong>Phone Verification</strong>（手机验证）。<strong>必须完成这一步</strong>，否则无法开启 GPU 和 Internet（联网）功能。<br />\n<img alt=\"Kaggle 账户设置页面的截图，高亮 Phone Verification 区域\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/phone_verification.png\" /></li>\n</ol>\n<p>认证完毕就可以使用GPU资源了<br />\n<img alt=\"当认证了手机号之后显示accelerator中有可用的GPU资源的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/gpu_access.png\" /><br />\n如果继续做了<strong>Identity verification</strong>之后，可以使用TPU资源，不过我们暂时用不到，目前的GPU资源已经够咱们大玩一场了。</p>\n<h3 id=\"22-创建笔记本\">2.2 创建笔记本</h3>\n<ol>\n<li>点击左侧菜单栏的 <strong>Create</strong> -&gt; <strong>New Notebook</strong>。</li>\n<li>进入编辑器界面，你会发现界面布局比 Colab 更加紧凑且功能分区明确。<br />\n<img alt=\"kaggle的编辑器页面布局的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/the_whole_UI.png\" /></li>\n</ol>\n<h3 id=\"23-界面布局速览\">2.3 界面布局速览</h3>\n<ul>\n<li><strong>工作区</strong>：位于右侧，显示了Input-&gt;我们的挂载资源，上传的数据集和模型等等，Output-&gt;我们输出的结果资源。notebook内容速览,以及下面的session options环境快捷配置等等<br />\n<img alt=\"编辑器右侧的工作区，包含Input区和output区的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/workspace.png\" /><br />\n<img alt=\"编辑器右侧工作区剩余部分，报班session options的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/session_options.png\" /></li>\n<li><strong>快捷操作栏</strong>： 在代码区上方，和Colab差别不大，可以快速运行，插入单元格，复制粘贴等等<br />\n<img alt=\"在编辑器上方的快捷操作栏的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/quick_action.png\" /></li>\n<li><strong>代码区</strong>：和Colab一样, 标准的 Jupyter 单元格。</li>\n</ul>\n<p>注意，</p>\n<ol>\n<li>和Colab不一样的是，Kaggle的文件名没有后缀，不用加ipynb后缀</li>\n<li>咱们的硬件加速（GPU/TPU计算资源）被放到了顶部菜单栏的<strong>Settings</strong>中的<strong>accelerator</strong>中了</li>\n<li>和Colab不同，因为Kaggle是为竞赛服务，很多竞赛是要求模型不联网的，所以我们在训练模型的时候，需要手动开启网络，也在顶部菜单栏的<strong>Settings</strong>中，点击<strong>Turn On Internet</strong>打开即可联网下载模型或者数据集。<br />\n<img alt=\"Kaggle Notebook的Settings下拉菜单，包含硬件加速设备和开启联网选项的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/settings.png\" /></li>\n<li>密钥管理被放到了顶部菜单栏的<strong>Add-ons</strong>下了<br />\n<img alt=\"Kaggle Notebook的Add-on下来菜单，包含密钥管理选项的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/add-on.png\" /></li>\n</ol>\n<h2 id=\"3-环境配置开启双显卡与联网\">3. 环境配置：开启双显卡与联网</h2>\n<p>Kaggle 默认环境是 <strong>CPU</strong> 且 <strong>断网</strong> 的。我们需要手动“解除封印”。</p>\n<h3 id=\"31-开启联网-internet-on\">3.1 开启联网 (Internet On)</h3>\n<p>可以按照刚才说的在顶部菜单栏打开，也可以在右侧边栏的 <strong>Session Options</strong> 中，找到 <strong>Internet</strong> 选项。将开关拨到 <strong>On</strong>。<br />\n<em>注意：如果没有手机验证，此选项为灰色不可用。</em></p>\n<h3 id=\"32-开启-gpu-加速-t4-x2\">3.2 开启 GPU 加速 (T4 x2)</h3>\n<ol>\n<li>\n<p>在右侧边栏找到 <strong>Accelerator</strong>。</p>\n</li>\n<li>\n<p>下拉选择 <strong>GPU T4 x2</strong>。</p>\n<ul>\n<li><strong>GPU T4 x2</strong>：两张显卡，约 30GB 显存，适合大模型推理和微调。</li>\n<li><strong>GPU P100</strong>：单张旧架构卡，虽然速度快但显存仅 16GB，通常不推荐。</li>\n</ul>\n</li>\n<li>\n<p>开启后，顶部会显示 <strong>Session Storage</strong> 和 <strong>GPU Quota</strong>（每周 30 小时额度，通常周六刷新）。<br />\n点击自己的头像，可以看见自己的额度<strong>GPU Quata</strong><br />\n<img alt=\"点击自己的头像，可以看见自己的额度的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/GPU_Quata.png\" /></p>\n</li>\n</ol>\n<h3 id=\"33-验证双卡环境\">3.3 验证双卡环境</h3>\n<p>输入并运行以下代码，确认我们是否真的拥有了两张显卡：</p>\n<pre><code class=\"language-python\">!nvidia-smi\n</code></pre>\n<p>你应当能看到 <strong>两张</strong> Tesla T4 显卡的列表 (GPU 0 和 GPU 1)。<br />\n<img alt=\"nvidia-smi的运行结果，显示两张Tesla T4卡\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/nvidia-smi.png\" /></p>\n<h2 id=\"4-实战下载并运行大模型\">4. 实战：下载并运行大模型</h2>\n<p>在 Kaggle 上使用模型主要有两种“流派”：<strong>代码下载派</strong> 和 <strong>原生挂载派</strong>。</p>\n<h3 id=\"方式一利用-huggingface-cli-下载-工程化推荐\">方式一：利用 HuggingFace CLI 下载 (工程化推荐)</h3>\n<p>这种方式最灵活，适合需要精确控制模型版本的情况。由于 Kaggle 没有 Google Drive，我们将模型下载到 <code>/kaggle/working/</code> 目录。</p>\n<p><strong>步骤 1：安装与配置</strong></p>\n<pre><code class=\"language-python\"># Kaggle 预装库很多，但 transformers 版本可能滞后，建议更新\n!pip install -U transformers huggingface_hub accelerate bitsandbytes\n</code></pre>\n<p>点击顶部菜单 <strong>Add-ons</strong> -&gt; <strong>Secrets</strong>，添加 <code>HF_TOKEN</code>（你的 HuggingFace 访问令牌）。</p>\n<p><strong>步骤 2：下载脚本</strong></p>\n<pre><code class=\"language-python\">import os\nfrom huggingface_hub import login, snapshot_download\nfrom kaggle_secrets import UserSecretsClient\n\n# 1. 登录 (自动读取 Secrets)\nuser_secrets = UserSecretsClient()\nhf_token = user_secrets.get_secret(\"HF_TOKEN\")\nlogin(token=hf_token)\n\n# 2. 定义下载路径 (注意：必须在 /kaggle/working 下)\nmodel_dir = \"/kaggle/working/model_cache\"\nos.makedirs(model_dir, exist_ok=True)\n\n# 3. 下载模型\nmodel_id = \"Qwen/Qwen2.5-7B-Instruct\"\nprint(f\"开始下载 {model_id} ...\")\n\n# Kaggle 建议下载实文件 (local_dir_use_symlinks=False)\nsnapshot_download(\n    repo_id=model_id,\n    local_dir=model_dir,\n    local_dir_use_symlinks=False,\n    token=hf_token\n)\n\nprint(\"下载完成！\")\n</code></pre>\n<p><img alt=\"下载完成的结果截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/download_model.png\" /></p>\n<h3 id=\"方式二add-input-kaggle-原生方式\">方式二：Add Input (Kaggle 原生方式)</h3>\n<p>这是 Kaggle 最强大的功能。你可以直接在网页端搜索现成的模型，像挂载 U 盘一样挂载进来，<strong>不消耗下载流量和时间</strong>。</p>\n<ol>\n<li>点击右侧边栏的 <strong>Add Input</strong>。</li>\n<li>选择 <strong>Models</strong> 标签页。</li>\n<li>搜索 <code>Qwen2.5</code>。</li>\n<li>点击 <strong>+</strong> 号添加。<br />\n<img alt=\"Kaggle Add Input 搜索模型的弹窗截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/qwen_downloading.png\" /></li>\n<li>选择FRAMEWORK选择<strong>Transformers</strong>架构, VARIATION选择<strong>7b-instruct</strong>, 之后的博文会跟各位友人解释这些参数的差别<br />\n<img alt=\"下载Qwen2.5模型需要填写的架构和参数示意截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/qwen2_5_params.png\" /></li>\n<li>模型会直接出现在 <code>/kaggle/input/</code> 目录下（只读），路径通常长得像 <code>/kaggle/input/qwen2.5/transformers/7b-instruct/1</code>。</li>\n</ol>\n<h2 id=\"5-加载模型与双卡推理\">5. 加载模型与双卡推理</h2>\n<p>拥有双卡 T4 后，加载模型时有一个关键参数：<code>device_map=\"auto\"</code>。它会自动将模型切分到两张显卡上，从而让我们能运行更大的模型。</p>\n<pre><code class=\"language-python\">import torch\nfrom transformers import AutoTokenizer, AutoModelForCausalLM\n\n# 路径根据你的下载方式调整\n# 方式一路径: \"/kaggle/working/model_cache\"\n# 方式二路径: \"/kaggle/input/qwen2.5/transformers/7b-instruct/1/\" (具体可以运行默认创建的第一个单元格，查看input目录结构,到能看见config.json的目录即可)\nmodel_path = \"/kaggle/working/model_cache\"\n\nprint(\"正在加载模型 (双卡模式)...\")\n\ntokenizer = AutoTokenizer.from_pretrained(model_path, trust_remote_code=True)\n\n# 关键：device_map=\"auto\" 会自动利用两张 T4\nmodel = AutoModelForCausalLM.from_pretrained(\n    model_path,\n    device_map=\"auto\",\n    torch_dtype=torch.float16,\n    trust_remote_code=True\n)\n\nprint(f\"模型加载成功！显存分布: {model.hf_device_map}\")\n\n# 测试对话\nprompt = \"你好，请用一句话形容 Kaggle 的双 T4 显卡有多香？\"\nmessages = [{\"role\": \"user\", \"content\": prompt}]\ntext = tokenizer.apply_chat_template(messages, tokenize=False, add_generation_prompt=True)\ninputs = tokenizer([text], return_tensors=\"pt\").to(model.device)\n\nwith torch.no_grad():\n    generated_ids = model.generate(**inputs, max_new_tokens=200)\n\nresponse = tokenizer.batch_decode(generated_ids, skip_special_tokens=True)[0]\nprint(f\"Qwen: {response.split('assistant')[-1].strip()}\")\n</code></pre>\n<h2 id=\"6-进阶如何持久化保存save-version\">6. 进阶：如何持久化保存？(Save Version)</h2>\n<p>Kaggle 没有 Google Drive，那怎么保存下载好的模型或训练结果呢？</p>\n<p><strong>答案：把 Output 变成 Dataset。</strong></p>\n<ol>\n<li>当你的代码运行完毕，模型保存在 <code>/kaggle/working</code> 后。</li>\n<li>点击右上角的 <strong>Save Version</strong> 按钮。</li>\n<li>选择 <strong>Save &amp; Run All</strong> (重新跑一遍),必须等到下方弹出的保存任务完成。<br />\n<img alt=\"保存任务完成的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/job_running_done.png\" /></li>\n<li>保存成功后，你可以去主页的<strong>Your Work</strong>点击刚才的Notebook,进入<strong>Output</strong> 标签页里，点击最右边的Output的三个点，然后点击 <strong>New Dataset</strong>。<br />\n<img alt=\"在Output标签页的New Dataset示意图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/new_data.png\" /></li>\n<li>这样，我们刚才的模型就变成了一个可以在其他 Notebook 里直接 <strong>Add Input</strong> 的数据集了！</li>\n</ol>\n<p><strong>PS:除开自训练的特殊模型和一些在Input找不到的模型，最好都直接使用Input导入更为快捷</strong></p>\n<h2 id=\"7-常见问题-qa\">7. 常见问题 (Q&amp;A)</h2>\n<p><strong>Q: Colab 和 Kaggle 我该选谁？</strong><br />\n<strong>A:</strong></p>\n<ul>\n<li><strong>Colab</strong>: 适合快速实验、挂载 Google Drive 方便。但 T4 只有一张，且最近封号较严。</li>\n<li><strong>Kaggle</strong>: 适合需要大显存（T4 x2）的任务。环境更稳定，且有 30 小时/周的明确额度，不用担心用到一半被踢下线。</li>\n</ul>\n<p><strong>Q: 为什么我的代码报错 <code>Internet connection is closed</code>？</strong><br />\n<strong>A:</strong> 这是一个经典错误。请检查右侧边栏的 <strong>Internet</strong> 开关是否为 On。如果开关是灰色的，请检查是否完成了账号的 <strong>手机号验证</strong>。</p>\n<p><strong>Q: <code>/kaggle/working</code> 里的文件重启后还有吗？</strong><br />\n<strong>A:</strong> 没有了。Kaggle 的 Session 也是临时的。如果需要持久化，请务必使用 <strong>Save Version</strong> 功能将其保存为 Dataset，或者在代码最后加一段上传到 HuggingFace Hub 的代码。</p>\n<hr />\n<p><strong>本文作者：</strong> Algieba<br />\n<strong>本文链接：</strong> <a href=\"https://blog.algieba12.cn/llm02-2-online-environment-kaggle/\" rel=\"noopener nofollow\" target=\"_blank\">https://blog.algieba12.cn/llm02-2-online-environment-kaggle/</a><br />\n<strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</p>\n<pre><code>\n</code></pre>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"itemdesc\">\n\t\t\t发表于 \n<span id=\"post-date\">2026-02-04 19:53</span>&nbsp;\n<a href=\"https://www.cnblogs.com/algieba\">阿尔的代码屋</a>&nbsp;\n阅读(<span id=\"post_view_count\">34</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</div>"
    },
    {
      "title": "V8引擎 精品漫游指南--Ignition篇(上) 指令 栈帧 槽位 调用约定 内存布局 基础内容",
      "link": "https://www.cnblogs.com/f20171110/p/19576264",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/f20171110/p/19576264\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 19:19\">\n    <span>V8引擎 精品漫游指南--Ignition篇(上) 指令 栈帧 槽位 调用约定 内存布局 基础内容</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        这是第二篇的上半部分，我们主要学习ignition V8的解释器的一些基础和前置知识。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"二-ignition解释器上\">二. Ignition解释器(上)</h1>\n<p>这是第二篇的上半部分，我们主要学习ignition V8的解释器的一些基础和前置知识。</p>\n<p>这部分内容，主要是以了解为主，所以在学习的时候，除了第一篇中说的 有些细节做了省略  有些边界情况做了简化表述以外，也不需要过多的深入。 读完了就好。 目的就是对于ignition解释器的一个祛魅。</p>\n<p>当然，感兴趣的朋友也可以认真阅读，本文内容依旧保持一定的深度，依旧是力求高准确性，符合规范，贴合实现。 但需注意的是，为了文章的可读性，有可能<strong>在前面</strong>仅做简化的通俗的描述，<strong>在后面</strong>做了详细的讲解描述，所以，可能的情况下，请尽量阅读全文。</p>\n<p>通过上一篇的解析，我们手里已经拿到了一份完整的AST抽象语法树。 但是对于cpu来说，它只认指令。</p>\n<p>在早期版本的 V8 中，JavaScript 代码在解析完成后，会直接被编译成本机机器码执行。这种方式运行得很快，但机器码体积通常比较大，也不够灵活。</p>\n<p>在后来，直到现在，V8不再直接生成庞大复杂的机器码，而是生成了一种非常紧凑 小巧的中间代码，就是 字节码 bytecode。</p>\n<p>但是cpu也不认识字节码，V8使用 ignition 模拟了一个可以运行字节码的环境，相当于一个极其轻量的虚拟机。</p>\n<h2 id=\"1--ignition是什么\">1 . ignition是什么</h2>\n<p>Ignition 是 V8 引擎里的<strong>字节码解释器</strong>，它把 JavaScript 的 AST 编成紧凑的字节码，然后在虚拟机里解释执行，同时收集各种信息，供优化器生成更快的机器码。</p>\n<p>ignition的工作  最主要是下面三个：</p>\n<p><strong>翻译</strong>：把 AST 翻译成字节码。</p>\n<p><strong>执行</strong>：在一个虚拟的寄存器机里执行这些字节码。</p>\n<p><strong>收集情报</strong>：在执行过程中，偷偷记录类型信息，为后续的优化做准备。</p>\n<p>Ignition 在软件层面模拟了一套  <strong>类 CPU</strong> 的工作模式：<br />\n它不是只用栈，也不是纯寄存器机，而是采用“<strong>虚拟寄存器 + 累加器（Accumulator）</strong>”的模式。</p>\n<p>这里的寄存器并不是 CPU 里的硬件寄存器，而是函数栈帧里的一些槽位（slots），只是把它抽象成寄存器来使用，看起来更像 CPU 工作方式，但成本非常低。</p>\n<p>Ignition 还设计了一个<strong>解释器独占的累加器 acc</strong>。大多数运算的中间结果都会临时存放在 acc 里，这样指令只需要携带一个参数，就不用全部写出所有的目的寄存器，字节码就会变得非常短小。</p>\n<p>当一个函数开始执行时，Ignition 会在内存的 栈 (Stack) 上划出一块地盘， 跑起来的时候，本质上就是在那块栈内存上，不停地把数据从一个位置搬到另一个位置，计算，然后再搬回另一个位置，就是这样搬来搬去。ignition操作的并不是真正的cpu内的寄存器，它操作的是内存位置/槽位。</p>\n<h2 id=\"2--几个简单的指令\">2 . 几个简单的指令</h2>\n<p>ignition就像一个勤劳干活的老师傅，他有一个随身腰包，他不管干什么活，不管需要用什么工具，都是优先用随身腰包里的东西， 干完活得到的结果，也顺手塞回自己的随身腰包里。</p>\n<p><strong>老师傅有个随身腰包， 不管干什么，都优先使用随身腰包。</strong></p>\n<p><strong>摆放各种材料的原料架，一格一格的， r0 ，r1，r2.。。。编着号，上面摆满了原材料。</strong></p>\n<p>好了，这就是ignition的架构。就是这么简单。</p>\n<p>这个随身腰包，就是老师傅最重要的东西了。师傅偷懒全靠它了。</p>\n<p>假如没有这个随身包，想象一下，老板下达指令非常啰嗦麻烦：</p>\n<p>把 r1原料架 的东西 和 r2原料架 的东西拿下来，拼装好，然后再放回 r3原料架 去</p>\n<p>(类似于指令：ADD r1, r2, r3)</p>\n<p>​     而老师傅有了随身包，就简单了，老板只需要喊一声：</p>\n<p>“去把 r2 原料架的东西拼进来！”</p>\n<p>(指令：Add r2)</p>\n<p>老板完全不需要废话“跟谁拼”（默认跟包里的东西拼），也不需要废话“拼完放哪”（默认拼完还放在包里）。</p>\n<p>这就是 Ignition 的核心节省秘籍。通过强行规定“随身包优先”，每一条指令都能省掉好几个参数的位置。成千上万行代码跑下来，省下的内存就是一个天文数字。</p>\n<p>这个老师傅的<strong>随身包 就是累加器</strong>，原料架 就是内存位置/槽位</p>\n<ul>\n<li>\n<p><code>Lda</code> (Load Accumulator) ---Lda 是个前缀，实际使用时，后面可跟很多合法的数据来源，比如 LdaSmi<code>、</code>LdaConstant<code>、</code>LdaUndefined、Ldar 等等。。。</p>\n<p>这是使用最高频的指令，因为所有的活 都得在随身包里干，所以第一步，基本上都是把东西装进包里。</p>\n<ul>\n<li><strong>指令</strong>：<code>Ldar r1</code> (Load Accumulator from Register r1)</li>\n<li><strong>动作</strong>：老师傅走到 r1 原料架，把那里的材料拿下来，<strong>塞进随身包里</strong>。</li>\n<li><strong>状态</strong>：此时，随身包里的东西 = r1 的东西。</li>\n<li>Ldar 这个指令  很好记忆，ld是装载，a是累加器，r是寄存器，ldar就是装载累加器from寄存器，  <strong>把寄存器的内容装进累加器</strong>。</li>\n<li>Ldar r1  就是把寄存器r1里的东西 装进累加器。</li>\n<li>老师傅把r1的原料装进随身包里。</li>\n</ul>\n</li>\n<li>\n<p><code>Star</code> (Store Accumulator)</p>\n<p>活干完了，结果总不能一直烂在包里，得腾出地方干下一票，或者把结果存起来。</p>\n<ul>\n<li><strong>指令</strong>：<code>Star r2</code> (Store Accumulator to Register r2)</li>\n<li><strong>动作</strong>：老师傅把<strong>随身包里</strong>刚刚加工好的成品掏出来，放到 r2 原料架上去。</li>\n<li><strong>状态</strong>：此时，r2 原料架的东西 = 随身包里的东西。</li>\n<li>star 这个指令，也很好记忆，st是储存，a是累加器，r是寄存器，star就是存储累加器里的东西到寄存器。</li>\n</ul>\n</li>\n<li>\n<p><code>Add</code> / <code>Sub</code> ...</p>\n<p>这是真正的关键步骤。</p>\n<ul>\n<li><strong>指令</strong>：<code>Add r0</code></li>\n<li><strong>动作</strong>：老师傅走到 r0 原料架，拿个东西，直接跟<strong>随身包里</strong>原本的东西进行合体（相加）。</li>\n<li><strong>状态</strong>：随身包里的东西 = 原包里的值 + r0 的值。</li>\n<li><strong>重点</strong>：注意 <strong>结果依然留在包里</strong>，老师傅并没有急着去储存结果。</li>\n</ul>\n<p>指令都很简单，<strong>ld</strong>  <em>load</em>，<strong>st</strong>  <em>store</em>，<strong>a</strong>  <em>accumulator</em>，<strong>r</strong>  <em>register</em></p>\n<p>类似的  ldglobal  stglobal ldarg0  ldcurrentcontext  也都差不多，</p>\n<p>基本上都是  动作+对象  的模式。</p>\n<p>另外需要注意的是，累加器 Accumulator 通常会写作 acc。虽然它叫“累加器”，但千万不要理解成它只能做加法运算。<strong>从本质上讲，acc 就是解释器里唯一的“通用临时寄存器”</strong>：当前这条字节码要处理的值，或者运算后的中间结果，几乎都会暂时放在这里。</p>\n<p>acc 里可以装任何 JavaScript 的值，比如常量、小整数、字符串、对象引用、<code>undefined</code> 等。之所以要设计这么一个“统一的临时位置”，就是为了让大多数字节码只需要写明“另一个参与运算的对象是谁”，而不用每次都额外声明多个寄存器参数，从而<strong>让字节码更短、更规整，也让解释器实现更简单</strong>。</p>\n</li>\n</ul>\n<pre><code>  Ldar r1   ; acc = r1\n  Add r0    ; acc = acc + r0\n  Star r2   ; r2 = acc\n  \n  累加器acc的变化。    是不是非常简单。\n</code></pre>\n<h2 id=\"3--栈帧和槽位\">3 . 栈帧和槽位</h2>\n<p>在第一部分解析篇里  我们也提到过 槽位 这个术语， 上面又提到了，那么，槽位到底是什么呢？</p>\n<p><strong>槽位（slot）就是栈帧里一格一格固定大小的“存储单元”或“格子”，用于按索引存放函数的参数、局部变量、临时值、以及其它元数据。</strong> 它不仅是“位置”，还隐含了大小、类型（通常是指针/Tagged 值）、地址计算规则和生命周期语义。</p>\n<p>内存可寻址的最小单位是 8bit 即一字节， 虽然最小使用单位是8bit 即一字节。但是，因为需要字节对齐 和 机器指针大小的要求，所以 在32位系统上，  需要4字节表示指针， 64位系统上  需要8字节表示指针。 每个槽位的大小，也是按照操作系统机器指针的大小来划分的。 即   64位系统，一个槽位  占 8个字节 。 只有这样，<strong>64位系统</strong>使用指针寻址时，8字节，即64bit，才能够装得下一个指针。</p>\n<p>所以，每个槽位（slot）占 8个字节大小。</p>\n<p>当函数开始执行时，运行时runtime在栈上为它分配一段连续内存作为<strong>栈帧</strong>。在 Ignition 中，栈帧大致分为三部分：<strong>参数区</strong>、<strong>固定头部</strong>，  <strong>工作区</strong> 。栈帧里的每个“格子”称为<strong>槽位（slot）</strong>，按索引存放局部变量和临时值，槽位的大小通常等于机器指针大小， <strong>64 位</strong>下为 8 字节。</p>\n<p><strong>特别注意</strong>：前面我们一般并没有明确的区分栈帧里槽位和字段，现在明确一下，我们<strong>仅仅是把工作区中</strong>按索引的格子（<code>r0, r1, r2…</code>）称为<strong>槽位（frame slots）</strong>。固定头部里的字段（返回地址、saved FP、Context、BytecodeArray 等）我们<strong>不</strong>把它们称为槽位；参数一般称为 argument slots（<code>a0,a1</code>）或单独描述。</p>\n<p>严格从 V8 内存视角来看，栈帧中的每一个 8 字节存储单元（无论是 Context、返回地址还是局部变量）在源码中都统称为 <strong>Slot</strong>。</p>\n<p>但在解释器字节码的语句环境中，为了<strong>区分功能</strong>：</p>\n<ul>\n<li>我们将固定位置、用途单一的区域称为 <strong>“固定头部字段”</strong>（如 Function, Context）。</li>\n<li>我们将用于存储局部变量和临时结果、通过索引动态访问的区域特称为 <strong>“寄存器槽位”</strong> 或 <strong>“局部变量槽位”</strong> 或简称为 <strong>槽位</strong> 。</li>\n<li><strong>有时候可能会有混用，将栈上某字段也称为槽位，从规范从v8源码上来说，完全没有错误，只是因为手抖或者写快了，没有按照我们通常的按功能区分的约定称呼。</strong></li>\n<li>当然，你可以按照自己的意愿，区分或者不区分，<strong>都是正确的</strong>。前提是  你要知道观察的视角的不同。</li>\n</ul>\n<p>下面我们详细介绍一下栈帧的结构。</p>\n<p>栈的生长顺序，是<strong>从高地址到低地址</strong>，即入栈早的在高地址， 最后入栈的处于栈顶 在低地址。</p>\n<p>我们首先介绍个术语：Tagged Pointer</p>\n<blockquote>\n<h4 id=\"tagged-pointer--标签指针\">Tagged Pointer  标签指针</h4>\n<p>64位系统中，每个槽位都是 8 字节（64 位），V8 在这里面存数据时，使用了一个编码技巧，叫做 <strong>Tagged Pointer (带标签的指针)</strong>。</p>\n<p>在静态语言立，比如 C++ 这种静态语言，编译器知道变量是 <code>int</code> 还是 <code>Object*</code>。但在 JavaScript 中，类型是动态的。如果 V8 为每个变量额外存一个“类型字段”，内存消耗会翻倍。 V8 的做法是：<strong>把类型信息直接编码进这 64 位数据本身。</strong></p>\n<p><strong>方法就是复用“对齐留下的低位”</strong> 在 64 位平台上，内存地址通常是 <strong>8 字节对齐</strong> 的。合法地址的二进制形式，<strong>最低的几位通常都是 0</strong>。 V8 就是使用了这些闲置的低位，用来打上类型标签Tag。</p>\n<p><strong>Tagged Value 的分类：</strong> V8 把槽位里的机器字统称为 <strong>Tagged Value</strong>，根据低位标签不同，分为两类：</p>\n<p><strong>Smi (Small Integer，标签立即量)</strong></p>\n<ul>\n<li><strong>特征</strong>：最低位通常为 <code>0</code>。</li>\n<li><strong>含义</strong>：这 <strong>不是</strong> 指针，这 64 位数据本身就存着一个整数。</li>\n<li><strong>优势</strong>：整数直接住在栈上，不需要去堆里申请内存，速度极快。</li>\n<li><strong>还原</strong>：使用时，通过<strong>右移 (Shift)</strong> 运算去掉标签，就能得到整数值。</li>\n</ul>\n<p><strong>Tagged Pointer (堆对象引用)</strong></p>\n<ul>\n<li><strong>特征</strong>：最低位通常为 <code>1</code>。</li>\n<li><strong>含义</strong>：这是一个指向堆内存中对象（HeapObject）的 <strong>强引用</strong>。</li>\n<li><strong>注意</strong>：它不能直接当做物理地址用。</li>\n<li><strong>还原</strong>：使用时，必须通过<strong>位掩码 (Mask)</strong> 运算去掉标签（Untag），还原成纯净的内存地址，才能去访问堆里的对象。</li>\n</ul>\n<p>这样使用Tag以后， Tagged value 就像给数据穿了一件“马甲”。Ignition 看一眼马甲（标签位），就知道是整数还是对象。虽然使用前必须“脱马甲”（Untag），但这带来的性能提升和内存节省是巨大的。</p>\n<p>另外需要注意，使用tag标记，  能直接判定的类型集合很小（主要是 Smi 或HeapObject），更细的类型，需要读取对象头来获取。</p>\n</blockquote>\n<p>那么 ，栈帧的结构是怎样的呢？它的组成如下：</p>\n<ul>\n<li>\n<p>第一层  参数区 Arguments</p>\n<p>当调用一个函数时，调用者Caller需要给它传实参，同时还有个隐形参数this，这些内容，都在栈帧的第一层参数区。</p>\n<ul>\n<li><strong>Receiver (this)</strong>：\n<ul>\n<li>这是个隐形参数。当你写 <code>obj.func()</code> 时，<code>obj</code> 就是 Receiver。它是参数列表里的隐形老大哥。</li>\n</ul>\n</li>\n<li><strong>Arguments (<code>a0</code>, <code>a1</code>...)</strong>：\n<ul>\n<li>这就是 <code>function foo(x, y)</code> 里的 <code>x</code> 和 <code>y</code>。</li>\n<li>Ignition 给它们编的号是 <code>a0</code>, <code>a1</code>...</li>\n<li>要注意的是，这里的 <code>a</code> 代表 Argument，不要和 Accumulator 搞混了。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>第二层  固定头部  Fixed header / fixed frame part</p>\n<p>这是整个栈帧中最重要、最关键的区域。</p>\n<p>既然 Ignition 是个软件模拟的 CPU，那 CPU 运行时需要的那些状态  比如“我现在运行到哪一行了？”、“我的环境是谁？”  。。。等等信息， 都是存在哪的？</p>\n<p>没错，就存在这儿，固定头部。</p>\n<p>每个函数栈帧的中间，都夹着这么一块雷打不动的区域，保存着维持虚拟机运行的<strong>元数据</strong></p>\n<p>它里面的主要内容：</p>\n<ol>\n<li>\n<p><strong>Return Address (返回地址)</strong>：</p>\n<ul>\n<li><em>作用</em>：等这个函数执行完，底层调用栈就会根据这个返回地址，跳回调用处继续执行。</li>\n<li>这里腰注意，返回地址， 是控制流，是返回的应该到代码的哪个位置去继续执行。</li>\n</ul>\n</li>\n<li>\n<p><strong>Caller's Frame Pointer (上一层栈帧指针)</strong>：</p>\n<ul>\n<li>\n<p><em>作用</em>：链表指针。当前函数执行完、调用者的栈帧在哪里？</p>\n</li>\n<li>\n<p>这样依旧要注意，这个指针，指的是数据，上个字段返回地址，是控制流的返回，这里</p>\n</li>\n<li>\n<p>的上层栈帧指针，是控制流返回以后，继续执行， 应该从哪里去找变量，返回的是那个</p>\n</li>\n<li>\n<p>栈帧，可以理解为数据。</p>\n</li>\n<li>\n<p>在理解上，还可以大致认为，</p>\n</li>\n<li>\n<p>返回地址是等这个函数执行完，要回到哪一行继续执行代码，也就是<strong>控制流</strong>该跳回哪里。这是时间上的返回 ，代码继续从哪里跑。</p>\n<p>上一层栈帧指针是调用我的那个函数，它的栈帧从哪里开始？<br />\n这是空间上的返回 ，要去哪一块内存里继续访问局部变量和作用域数据。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Context (上下文指针)</strong></p>\n<ul>\n<li>\n<p><em>这是什么</em>：它指向 <strong>堆内存 (Heap)</strong> 中一个叫做 <code>Context</code> 的对象。</p>\n</li>\n<li>\n<p>为什么要它：</p>\n<p>如果函数里用到的变量是自己的 let a，直接去栈上找（r0）。</p>\n<p>但如果用到了闭包变量（外层函数的变量），Ignition 必须拿着这个 Context 指针，去堆里的上下文链表上一层层找。</p>\n</li>\n<li>\n<p><em>地位</em>：它是连接 <strong>“栈世界（临时数据）”</strong> 和 <strong>“堆世界（持久数据）”</strong> 的唯一桥梁。</p>\n</li>\n<li>\n<p>这个概念非常重要，值得我们深入了解。另外插一句，虽然说  这整个部分都可以了解为主，但是如果认真学习，能够掌握，还是有很大的用处。比如这个栈帧，对于js开发还是很重要的。</p>\n</li>\n<li>\n<p>上面有个上一层栈帧指针，这里又有个上下文指针，怎么正确而深入的理解他们呢？</p>\n</li>\n<li>\n<p>**上一层栈帧指针是“动态调用链” **</p>\n<ul>\n<li><strong>回答的问题：</strong> “我是被谁调用的？”</li>\n<li><strong>指向哪里：</strong> 指向<strong>栈（Stack）</strong>上的上一级栈帧。</li>\n<li><strong>作用：</strong> 函数执行完（return）后，底层会根据返回地址跳回调用者继续执行，而上一层栈帧指针则用来恢复调用者的栈帧布局，用于继续访问它的局部变量等数据。</li>\n</ul>\n<p>**Context 是“静态作用域链” **</p>\n<ul>\n<li><strong>回答的问题：</strong> “我是被定义在哪里的？”</li>\n<li><strong>指向哪里：</strong> 指向<strong>堆（Heap）</strong>上的 Context 对象。</li>\n<li><strong>作用：</strong> 它是<strong>数据流</strong>的查找路线。当函数访问一个不在自己内部的变量（自由变量）时，V8 会顺着这条链去查找。</li>\n</ul>\n</li>\n<li>\n<p>理解的关键点</p>\n</li>\n<li>\n<p><strong>上一层栈帧指向的是栈内存</strong>：栈帧是临时的，函数一返回，栈帧就销毁了。</p>\n<p><strong>Context 指向的是堆内存</strong>：这是为了实现 JavaScript 的<strong>闭包</strong>特性。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Function / Frame Marker (函数/帧类型标记)</strong>：</p>\n<ul>\n<li>\n<p>这个字段的<strong>位置</strong>在<code>[FP - 16]</code>  <strong>请注意</strong>  这里的偏移值 16 仅是<strong>示意</strong>。  这种表示方法，后面会详细介绍。</p>\n</li>\n<li>\n<p>这是一个具有<strong>多态性 (Polymorphic)</strong> 的关键槽位。它用于当前栈帧的身份识别。V8 引擎利用这个槽位来区分当前栈帧是属于标准的 JavaScript 函数调用，还是属于引擎内部的 C++ 调用。</p>\n</li>\n<li>\n<p>V8 的栈遍历器（Stack Walker）在扫描堆栈时（例如进行 GC 标记、生成错误堆栈或反优化时），会读取该槽位的值，并根据 <strong>指针标记位 (Tag Bit)</strong> 进行判断：</p>\n<ul>\n<li><strong>如果是对象指针（Heap Object）</strong>：判定为 <strong>Interpreted Frame</strong>（解释器帧）。</li>\n<li><strong>如果是小整数（Smi）</strong>：判定为 <strong>Internal Frame</strong>（内部帧）。</li>\n</ul>\n</li>\n<li>\n<p>具有两种可能的状态：</p>\n</li>\n<li>\n<p>状态 A：存放 <code>JSFunction</code> (Closure)</p>\n<ul>\n<li><strong>场景</strong>：当执行常规 JavaScript 代码时。</li>\n<li><strong>内容</strong>：指向当前正在执行的函数对象（闭包）的指针。</li>\n<li><strong>作用</strong>：\n<ol>\n<li>作为<strong>资源入口</strong>：解释器通过它访问 <code>SharedFunctionInfo</code>（获取字节码）和 <code>FeedbackVector</code>（获取优化反馈）。</li>\n<li>连接<strong>堆与栈</strong>：保持对堆上函数对象的强引用，防止被 GC 回收。</li>\n</ol>\n</li>\n</ul>\n<p><strong>状态 B：存放 <code>StackFrame::Type</code> (Marker)</strong></p>\n<ul>\n<li><strong>场景</strong>：当执行 V8 内部代码（如 <code>EntryFrame</code>, <code>ConstructFrame</code>, <code>BuiltinFrame</code>）时。</li>\n<li><strong>内容</strong>：一个枚举值（Smi），标识具体的帧类型。</li>\n<li><strong>作用</strong>：\n<ol>\n<li><strong>路标作用</strong>：告诉栈遍历器如何解析当前帧的其余部分（不同类型的内部帧，布局可能不同）。</li>\n<li><strong>边界界定</strong>：标记 JS 代码与 C++ 代码的转换边界</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Bytecode Array (字节码数组指针)</strong>：</p>\n<ul>\n<li>\n<p><strong>这个字段的位置：</strong> <code>[FP - 24]</code>   依旧请注意，偏移值 24 仅是示意。</p>\n</li>\n<li>\n<p><strong>这个字段的内容：</strong> 一个指向堆内存中 <code>BytecodeArray</code> 对象的 <strong>Tagged Pointer</strong>。</p>\n</li>\n<li>\n<p><strong>定义：</strong> 它是解释器 Ignition 真正“读取”和“执行”的指令序列源头。</p>\n</li>\n<li>\n<p>这个字段是一个指针，指向堆（Heap）上的一个<code>BytecodeArray</code> 对象。</p>\n<p>之所以叫 <code>Array</code>，是因为它的<strong>主体部分</strong>确实是一串连续的、变长的字节序列。</p>\n<p>在 V8 的底层 C++ 定义中，凡是符合 <strong>“定长头部 + 变长尾部”</strong> 结构的对象，通常都以此命名。</p>\n<ul>\n<li><strong>普通对象 (<code>JSObject</code>)</strong>：大小通常是固定的（或者由 Map 描述）。</li>\n<li><strong>数组类对象 (<code>FixedArray</code>, <code>ByteArray</code>)</strong>：\n<ol>\n<li>它是<strong>变长</strong>的（在分配时决定大小）。</li>\n<li>它的<strong>主要内容</strong>是可以通过索引（Index）访问的序列。</li>\n</ol>\n</li>\n</ul>\n<p>之所以叫 <code>BytecodeArray</code> 是为了强调它的<strong>存储形态</strong>是线性的字节序列。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Bytecode Offset (字节码偏移量 / PC)</strong>：</p>\n<ul>\n<li><em>作用</em>：<strong>程序计数器</strong>。记录当前执行到第几条指令了。</li>\n<li><strong>位置：</strong> <code>[FP - 32]</code> (即 <code>StandardFrameConstants::kBytecodeOffset</code>)  ，偏移值32，仅为示意，并非确定值。</li>\n<li><strong>形式：</strong> <strong>Smi (小整数)</strong>。</li>\n<li><strong>含义：</strong> 它记录了当前执行到了 <code>BytecodeArray</code> 中的<strong>第几个字节</strong>。</li>\n<li><em>细节</em>：在正常解释执行期间，PC 状态常驻在<strong>真实的物理寄存器</strong>，在之中不停的变动，只有在需要外部可见或恢复时（GC/中断/断点/反优化/进入 runtime 等），解释器会把寄存器的值写回栈帧 BytecodeOffset 字段）。恢复时会把它再装回物理寄存器。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>第三层   工作区  Work Area / Virtual Registers</p>\n<p>这是栈帧中位于固定头部后面、向低地址延伸的区域。</p>\n<p>Ignition 将这段连续的内存槽位，给它们编上号：<code>r0</code>, <code>r1</code>, <code>r2</code>...</p>\n<p>虽然它们在物理上只是连续的 8 字节内存格子，但在逻辑上，它们通常划分成了三种截然不同的用途。</p>\n<h4 id=\"1-显式局部变量-explicit-locals\">1. 显式局部变量 (Explicit Locals)</h4>\n<p>这是最好理解的部分。它们直接对应你在 JavaScript 代码中声明的局部变量。</p>\n<p>生成器（BytecodeGenerator）会按照特定算法（通常与声明顺序相关）为这些变量分配槽位。</p>\n<ul>\n<li>示例</li>\n</ul>\n<p>function demo() {<br />\nvar name = 'v8';  // 编译器决定：分配给 r0<br />\nlet age = 10;     // 编译器决定：分配给 r1<br />\n}</p>\n<p>当代码执行到这里时，<code>r0</code> 槽位里就填入了 <code>\"v8\"</code> 的指针，<code>r1</code> 槽位里填入了 <code>10</code> 的 Smi 值。</p>\n<ul>\n<li>\n<p><strong>关键点：作用域分析 (Scope Analysis)</strong></p>\n<p><strong>要注意</strong>  并不是你写的所有局部变量都能住在这个“栈上的工作区”。</p>\n<p>在生成字节码之前，V8 会先进行一次 <strong>作用域分析</strong>。</p>\n<ul>\n<li><strong>判断标准</strong>：如果一个变量被内部函数（闭包）<strong>捕获 (Captured)</strong> 了，它就不能住在栈上</li>\n<li><strong>原因</strong>：栈帧生命是有限的，函数执行完就销毁了。但闭包可能在函数执行完后还需要访问这个变量。</li>\n<li><strong>结果</strong>：被捕获的变量会被请到堆内存的 <strong>Context 对象</strong> 中。</li>\n<li><strong>结论</strong>：所以，能安稳住在 <code>r0, r1</code> 里的，都是身家清白的、<strong>未被捕获</strong>的局部变量。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-隐式临时变量-implicit-temporaries\">2. 隐式临时变量 (Implicit Temporaries)</h4>\n<p>这是在源代码里完全看不到，但机器执行时必须存在的变量。这也是 <strong>寄存器分配 (Register Allocation)</strong> 算法大显身手的地方。</p>\n<ul>\n<li>\n<p><strong>为什么要临时变量？</strong></p>\n<p>想象一下计算 <code>var x = a + b + c;</code></p>\n<p>Ignition 的累加器（老师傅的随身包）只有一个。</p>\n<ol>\n<li>先把 <code>a</code> 拿进包，把 <code>b</code> 加进来。包里现在是 <code>(a+b)</code>。</li>\n<li>下一步要加 <code>c</code>。指令要求 <code>Add c</code>。</li>\n<li><strong>发生冲突</strong>：如果 <code>c</code> 的获取过程很复杂（比如 <code>c</code> 是个函数调用 <code>getC()</code>），那么在执行 <code>getC()</code> 的过程中，累加器会被反复使用、覆盖。</li>\n<li><strong>如何解决</strong>：必须先把 <code>(a+b)</code> 的结果找个格子 <strong>暂存 Spill</strong> 起来。</li>\n</ol>\n</li>\n<li>\n<p><strong>物理存在</strong>：</p>\n<p>Ignition 会在局部变量后面，划出一些格子作为 <strong>临时寄存器</strong>。</p>\n<p>这些格子就像老师傅手边的“小黑板”。</p>\n<ul>\n<li><strong>复用性</strong>：这行代码算完了，这张“小黑板”擦干净，立刻给下一行代码复用。所以即使代码很长，只要不同时通过大量中间结果，Frame Size 也不会很大。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-神秘的洞-the-hole\">3. 神秘的洞 (The Hole)</h4>\n<p>这是 ES6 引入 <code>let/const</code> 后，V8 在底层实现 <strong>TDZ (暂时性死区)</strong> 的最硬核手段。</p>\n<p>在第一部分解析篇中，我们已经详细学习了这个 会吹哨子的警卫thehole，忘记了的朋友，可以复习一下第一篇中的相关内容。这里我们略微的再讲一下。</p>\n<p>在栈帧刚刚被创建，但代码还没执行到 <code>let a = ...</code> 这一行时，<code>rX</code> 槽位里放的是什么？</p>\n<ul>\n<li>\n<p><strong>对于 <code>var</code></strong>：</p>\n<p>V8 会把对应的槽位初始化为 <code>undefined</code>。所以在赋值前访问它，拿到的就是 <code>undefined</code>（变量提升）。</p>\n</li>\n<li>\n<p><strong>对于 <code>let / const</code></strong>：</p>\n<p>V8 会把对应的槽位填入一个特殊的 <strong>会吹哨子的警卫</strong>，在内部被称为 <strong><code>The Hole</code></strong>。</p>\n</li>\n<li>\n<p><strong>执行时的检查机制</strong>：</p>\n<p>Ignition 在执行读取变量的指令（如 <code>LdaRep</code>）时，内置了一段小逻辑：</p>\n<p>// 伪代码<br />\nvalue = load(r1);<br />\nif (value == The_Hole_Value) {<br />\nthrow ReferenceError(\"Cannot access before initialization\");<br />\n}</p>\n<p>TDZ 并不难理解，它在物理层面上，就是一个槽位里放着 <code>The Hole</code>，而解释器在读取时不仅读数据，还顺手做了一次安全检查，如果摸到的是警卫，哨子就响。</p>\n</li>\n</ul>\n<h4 id=\"4-寻址机制如何找到-r5\">4. 寻址机制：如何找到 <code>r5</code>？</h4>\n<p>工作区只是一段连续的内存，Ignition 怎么知道 <code>r5</code> 在哪？</p>\n<p>这就要用到汇编里的 <strong>基址寻址</strong> 了。</p>\n<ul>\n<li>\n<p><strong>基准点</strong>：<strong>FP (Frame Pointer)</strong>，指向固定头部的特定位置。</p>\n</li>\n<li>\n<p>有朋友可能会有疑问了，前面说栈帧有3部分，第一部分是参数区，可是为什么FP基准点指向固定头部 ，而不是指向参数部分。</p>\n</li>\n<li>\n<p>参数空间是<strong>调用者</strong>的区域，因此在语义上它属于caller 的部分 ，而不是 callee 用来分配本地变量/临时的 workspace。FP 作为被调用者的栈帧基准点，通常是不包括参数区的。</p>\n</li>\n<li>\n<p><strong>计算公式</strong>：</p>\n<p>由于栈是向低地址增长的，所以寄存器的地址是 FP 减去一个偏移量。</p>\n<p>Address(rn) = FP - fixed_header_size - (n * slot_size)</p>\n<p>其中 <code>fixed_header_size</code> 是固定头部的字节长度，<code>slot_size</code> 通常等于机器指针大小（在 64 位系统下常为 8 字节）</p>\n</li>\n<li>\n<p><strong>示例：</strong></p>\n<ul>\n<li><code>FP</code> 指向这里。</li>\n<li>往下走 8 字节... 是 <code>Context</code> <code>[FP-8]</code>。</li>\n<li>再往下... 是 <code>Function</code> <code>[FP-16]</code>。</li>\n<li>再往下... 是 <code>BytecodeArray</code> <code>[FP-24]</code>。</li>\n<li>再往下... 是 <code>BytecodeOffset</code> <code>[FP-32]</code>。<strong>(固定头部结束)</strong></li>\n<li><strong>再往下... 终于到了工作区的 r0</strong> <code>[FP-40]</code>。</li>\n<li><code>r0</code> 再往下 8 字节是 <code>r1</code>。</li>\n</ul>\n<p>所以，字节码里的简单指令 <code>Ldar r5</code>，翻译到底层 CPU 动作，就是去读更深处的内存地址。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4--调用约定和内存布局\">4 . 调用约定和内存布局</h2>\n<p>通过前面的学习，我们已经大致了解了栈帧的内容，现在我们就需要在脑子中建立起动态的栈帧模型。</p>\n<ul>\n<li>\n<p>建立我们自己的心智模型，内存的想象图</p>\n<p>那么 我们怎么想象内存呢？ 梯子，高耸入云的梯子，一格一格的代表内存单元。</p>\n<p><strong>地面（最底下）</strong>：是 <strong>高地址</strong>（比如 <code>0xFF...</code>）。对于栈帧来讲，这是稳固的地基。</p>\n<p><strong>天空（往上看）</strong>：是 <strong>低地址</strong>（比如 <code>0x00...</code>）。这是延伸空间。</p>\n<p>最底下是高地址，越往上，地址越低。</p>\n<p>有朋友可能会问：“书上或者 V8 源码注释里，通常都是画‘高地址在上，低地址在下’，栈是‘向下生长’的，为什么我们要反着来？”</p>\n<p>这其实是为了贴合<strong>直觉</strong>。 如果你使用过 OllyDbg、x64dbg 或 IDA 等调试工具，你会发现它们的内存视图通常是这样的：</p>\n<ul>\n<li><strong>上面</strong> 显示的是 <strong>低地址</strong>。</li>\n<li><strong>下面</strong> 显示的是 <strong>高地址</strong>。</li>\n</ul>\n<p><strong>这种视角的好处极其直观：</strong></p>\n<ul>\n<li><strong>入栈 Push</strong>：就像盖楼一样，在现有的楼顶上，<strong>往上</strong> 再盖一层（地址变低/变小）。</li>\n<li><strong>出栈 Pop</strong>：就像拆楼一样，把最上面的一层拆掉（地址变回高/变大）。</li>\n<li><strong>栈底</strong>：在最下面（高地址），通常存放着调用者的环境，在一个栈帧中，很少变动。</li>\n<li><strong>栈顶</strong>：在最上面（低地址），数据频繁进进出出出栈入栈，变动剧烈。</li>\n</ul>\n<p>所以，为了理解起来更顺畅，建议我们在脑海中建立的模型如下：</p>\n<ul>\n<li><strong>高地址在下</strong>（地基）。</li>\n<li><strong>低地址在上</strong>（天空）。</li>\n<li><strong>栈帧的生长方向</strong>：从下往上，<strong>向低地址生长</strong>。</li>\n</ul>\n</li>\n<li>\n<p>指针和内存单元</p>\n<p><strong>最小刻度：字节 (Byte)</strong> 在计算机里，<strong>8 bit (1字节)</strong> 是内存可寻址的最小单位。</p>\n<p><strong>实际步长：</strong>    虽然刻度是按 字节 画的，但在 64 位系统里，Ignition 这个老师傅手很大。 他干活时，<strong>不会像学友哥那样捏着兰花指去抓 1 个字节。</strong>   他<strong>每一次伸手，都要抓走 8 个字节</strong>（64 bit）。这 8 个字节合起来，才构成了一个完整的 <strong>槽位 (Slot)</strong>。</p>\n<p><strong>内存对齐：</strong> 每一次都要操作 8 个字节，所以，所操作的地址，都是8的倍数：</p>\n<p>0  8  16  24 。。。（这些数字仅仅是示意地址是8的倍数）</p>\n<p>这就是 <strong>内存对齐</strong>。</p>\n<p><strong>注意：</strong> 这并不代表地址 <code>1, 2, 3...7</code> 是“空闲”或者“没用”的。 当你向地址 <code>0</code> 写入一个 64 位指针或者数据时，这个指针或数据用64bit的庞大的身躯<strong>填满</strong>了从 <code>0</code> 到 <code>7</code> 的所有空间。 只不过，当我们想<strong>找到</strong>这个数据时，我们只在这个数据的<strong>头部（首地址）</strong> 找起。</p>\n<p><strong>地址 0</strong>：是第一个槽位的<strong>门口</strong>。<strong>地址 8</strong>：是第二个槽位的<strong>门口</strong>。</p>\n<p>这就解释了我们在前面内容中提到的 <strong>Tagged Pointer</strong> 原理： 因为地址只在 <code>0, 8, 16</code> 这些 <code>8</code> 的倍数上，所以这些地址的二进制表示，<strong>最后 3 位通常是 0</strong>。 V8 也是看准了这一点，才敢把这 3 位挪作他用（存类型 Tag）。</p>\n<p><strong>指针</strong>   如何理解？</p>\n<p>指针就是地址，之所以说是指针 而不是直接说地址，是因为 指针收紧了地址的概念。</p>\n<p>“地址”是物理层面的客观存在，而“指针”是软件层面的主观定义。指针对地址具有收紧和约束作用。</p>\n<p>准确的说  <strong>指针是对地址概念的一次“收紧”和“赋予语义”</strong>。</p>\n<ul>\n<li>\n<p><strong>地址</strong></p>\n</li>\n<li>\n<p><strong>本质</strong>：它只是一个冷冰冰的数字编号（比如 <code>0x0000FFFF</code>）。</p>\n</li>\n<li>\n<p><strong>缺陷</strong>：它没有任何约束。给你一个地址，你根本不知道那里住的是什么。</p>\n<ul>\n<li>是 4 个字节的整数？</li>\n<li>还是 1 个字节的字符？</li>\n<li>或者是一段可执行的代码？</li>\n<li>甚至可能是一个无效的垃圾值？</li>\n</ul>\n</li>\n<li>\n<p><strong>状态</strong>：如果你只拿到了一个地址，你面对的是未知的、混乱的内存空间。</p>\n</li>\n<li>\n<p>**指针 **</p>\n</li>\n<li>\n<p><strong>本质</strong>：<strong>指针 = 地址 + 类型约束（解释方式）</strong>。</p>\n</li>\n<li>\n<p><strong>收紧的概念</strong>：</p>\n<p>当我们定义一个指针（比如 C++ 里的 <code>int* p</code> 或 V8 里的 <code>Tagged Pointer</code>）时，我们实际上是<strong>收紧</strong>了对那个内存地址的操作权限和理解方式。</p>\n<ul>\n<li>它告诉 CPU：“别乱猜了，这个地址里存的一定是 <strong>对象</strong>，而不是整数。”</li>\n<li>它告诉编译器：“当你去读这个地址时，请按照 <strong>8 字节</strong> 为单位去读，不要只读 1 个字节。”</li>\n</ul>\n</li>\n</ul>\n<p>在 V8 的 Ignition 中，这种“收紧”体现得更全面：</p>\n<ol>\n<li>\n<p><strong>标签 (Tagging)</strong>：</p>\n<p>V8 的指针（Tagged Pointer）利用最低位（Tag Bit）强行规定了语义。</p>\n<ul>\n<li>如果最后一位是 <code>0</code>：<strong>收紧为“立即数”</strong>（Smi）。不需要去内存里找，它自己就是值。</li>\n<li>如果最后一位是 <code>1</code>：<strong>收紧为“堆指针”</strong>（HeapObject）。必须去堆里找。</li>\n</ul>\n</li>\n<li>\n<p><strong>隐藏类 (Map/Hidden Class)</strong>：</p>\n<p>当你顺着 V8 的指针找到堆里的对象时，对象的第一个属性通常是 <strong>Map</strong>（隐藏类）。</p>\n<p>这实际上是进一步的“收紧”：</p>\n<ul>\n<li>“这个地址不仅是个对象，而且它是一个 <strong>数组</strong>，长度是 10，元素类型是...”。</li>\n</ul>\n</li>\n</ol>\n<p>最后需要注意，越往底层，比如到了汇编  到了代码调试 ，对于指针和地址的区分，就越趋近于无，很多时候，都是混着叫的，基本上都是使用指针就是地址 这个本质概念了。因为约束已经剥离，只剩本质了。</p>\n<p><strong>调用约定</strong></p>\n<p>我们在前面学习了栈帧的物理结构：参数在高地址，返回地址在中间，变量在低地址。</p>\n<p>这时候，无中生友的朋友又出现了：为什么要这么放？我倒过来放不行吗  我混着放不行吗？</p>\n<p>这就引出了一个重要的概念 调用约定。</p>\n<ul>\n<li>\n<p>简单来说，调用约定就是 <strong>调用者 (Caller)</strong> 和 <strong>被调用者 (Callee)</strong> 之间达成的一份 <strong>“协议”</strong> 或 <strong>“合同”</strong>。</p>\n<p>想象一下两个人在玩球球：</p>\n<ul>\n<li>\n<p><strong>Caller</strong> 说：“我会把球抛到<strong>你的左手边</strong>。”</p>\n</li>\n<li>\n<p><strong>Callee</strong> 说：“好的，我会跑到<strong>左手边</strong>去接球。”</p>\n<p>这就是约定。如果 Caller 抛向左边，而 Callee 跑去右边接，球就掉了（程序崩溃）。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>在 V8 里，这份 协议/合同 规定了三个最核心的问题：</p>\n<ol>\n<li><strong>参数放哪？</strong> (传递方式)\n<ul>\n<li>是放在 CPU 寄存器里？还是压到栈内存里？</li>\n<li>如果是压栈，是从左往右压，还是从右往左压？</li>\n</ul>\n</li>\n<li><strong>结果放哪？</strong> (返回方式)\n<ul>\n<li>函数算完了，结果放在哪个寄存器里带回去？（通常是累加器/rax）。</li>\n</ul>\n</li>\n<li><strong>谁来打扫卫生？</strong> (堆栈平衡)\n<ul>\n<li>参数占用的栈空间，是 Caller 负责回收，还是 Callee 负责回收？</li>\n</ul>\n</li>\n</ol>\n<p><strong>V8的特殊之处：垃圾回收</strong></p>\n<p>在c / c++ 中， 标准约定通常会优先把前几个参数放在 <strong>物理寄存器</strong> 里传递，这样速度会达到极致。</p>\n<p>但是在V8的 Ignition 解释器里，我们看到参数几乎都是乖巧的排列在栈上。这是为什么？</p>\n<p>因为 V8 有一个幽灵暗卫 ，这就是 <strong>垃圾回收器 (GC)</strong>。</p>\n<ul>\n<li><strong>GC 的全年无休</strong>：GC 需要时刻扫描内存，看看哪些对象还活着（有指针指向它）。</li>\n<li><strong>寄存器无法跟踪</strong>：如果参数散落在各种物理寄存器里，这就很难追踪。</li>\n<li><strong>V8 的折中拖鞋</strong>：<strong>确保栈上有一份“可扫描”的备份。</strong></li>\n</ul>\n<p>即使某些参数是通过寄存器传进来的，为了方便 GC 撸羊肉串式的扫描，V8 通常也会保证这些参数在栈上有一个确定的位置（或者把寄存器的值“抄写”到栈上）。记得前面说PC的时候，提过一次。</p>\n<p>so  这就形成了我们在栈帧图中看到的那样,参数在内存里连续排列，GC 扫起来非常舒服。</p>\n<p><strong>再说栈帧的内存布局</strong></p>\n<p>在前面我们讲栈帧的结构时，从高地址到低地址，依次是  参数区--固定头部区--工作区，但是</p>\n<p>对于栈帧的分界和字段的所有者，并没有详细的说明。 现在我们有了足够的铺垫，可以详细了解了。</p>\n<p>我们需要按<strong>时间顺序</strong>走一遍流程。</p>\n<p>这对于理解 FP（栈帧指针）这个“界碑”至关重要。</p>\n<p><strong>第一阶段：调用者准备工作</strong></p>\n<p>调用者在执行 <code>CALL</code> 指令之前，需要先准备好贡品：</p>\n<ol>\n<li>\n<p><strong>Push 参数</strong>：调用者把参数（Receiver, a0, a1...）按顺序压入栈。</p>\n<ul>\n<li><em>(这是 Caller 划拨的内存，属于 Caller 的栈帧范围，但供 Callee 使用)</em></li>\n</ul>\n</li>\n<li>\n<p><strong>执行 CALL 指令</strong>：CPU 自动将 <strong>返回地址 (Return Address)</strong> 压入栈顶，并跳转到 Callee 的代码处。</p>\n<ul>\n<li><em>(此时，FP 指针依然指向 Caller 的老基准点)</em></li>\n</ul>\n</li>\n</ol>\n<p><strong>第二阶段：被调用者接手</strong></p>\n<p>控制权来到了 Ignition（被调用者）手中，它进门后的<strong>头等大事</strong>就是建立自己的宗门（栈帧）：</p>\n<ol>\n<li><strong>Push Caller's FP</strong>：Ignition 做的第一件事，就是把旧的 FP（上一层的基准点）压入栈中保存起来。\n<ul>\n<li><em>(这一步形成了 Saved FP，也就是栈帧中间的那个连接点)</em></li>\n</ul>\n</li>\n<li><strong>Set New FP</strong>：Ignition 把当前的栈顶指针 (SP) 赋值给 FP。\n<ul>\n<li><em>(从此，FP 指向了 Saved FP。新的栈帧基准点正式建立)</em></li>\n</ul>\n</li>\n<li><strong>Push Fixed Header</strong>：接着，Ignition 依次压入 Context、Function、BytecodeArray、BytecodeOffset 等固定字段。</li>\n<li><strong>Allocate Locals</strong>：最后，根据 Frame Size，一次性把栈顶指针 (SP) 往下移，为局部变量（r0, r1...）留出空间，并初始化为 <code>undefined</code> 或 <code>The Hole</code>。</li>\n</ol>\n<h3 id=\"_\"></h3>\n<p>有了这个流程，我们再看“户口归属”就非常清晰了：</p>\n<ul>\n<li>\n<p><strong>FP 及其上方 (参数、返回地址)</strong>： 虽然物理上和 FP 连在一起，但它们是 <strong>Caller</strong> 在第一阶段留下的“遗产”。</p>\n<ul>\n<li>参数是 Caller 带来的。</li>\n<li>返回地址是 Caller 带来的。</li>\n<li>Saved FP 是 Callee 为了保护 Caller 而存的。</li>\n</ul>\n</li>\n<li>\n<p><strong>FP 下方 (固定头部、工作区)</strong>： 这是 <strong>Callee</strong> 在第二阶段亲手创建的“资产”。</p>\n<ul>\n<li>Context 是 Callee 找来的。</li>\n<li>局部变量是 Callee 分配的。</li>\n</ul>\n</li>\n</ul>\n<p>这样，我们再来看栈帧的结构，理解上的逻辑就完全闭环了： <strong>Caller 给资源（参数） --- 硬件给退路（返回地址） ---  Callee 建地基（保存旧FP） ---  Callee 建房子（头部和变量）。</strong></p>\n<p><strong>FP和偏移量</strong></p>\n<p>在前面我们学习栈帧的固定头部中的字段时，我们使用了 FP加偏移值 的表示方式。</p>\n<p>爱琢磨的朋友肯定会有疑问：<strong>为什么所有东西都要盯着 FP 看？为什么是这些特定的数字？FP 里面到底装了什么？</strong></p>\n<ol>\n<li><strong>为什么选 FP (Frame Pointer) 做基准？</strong></li>\n</ol>\n<p>你可能会问：“栈顶指针 <strong>SP (Stack Pointer)</strong> 也是个指针，而且它就在栈顶，为什么不用 SP 来找数据，非要专门维护一个 FP 呢？”</p>\n<p><strong>原因就是：SP 是“动”的，FP 是“静”的。</strong></p>\n<ul>\n<li>\n<p><strong>SP 的动如脱兔</strong>：</p>\n<p>在函数执行过程中，Ignition 可能会频繁地入栈、出栈（比如压入临时变量、准备子函数参数）。</p>\n<p>这就导致 SP 的位置一直在变。</p>\n<p>如果用 SP 做基准，当你找 <code>变量 a</code> 时，上一行代码可能是 <code>[SP + 8]</code>，下一行代码因为压了个临时值，就变成 <code>[SP + 16]</code> 了。编译器计算起来会疯掉。</p>\n</li>\n<li>\n<p><strong>FP 的静如瘫痪</strong>：</p>\n<p>一旦栈帧建立完毕（Prologue 结束），在整个函数执行期间，<strong>FP 指针就是钉在栈帧的固定位置（Saved FP 那个槽位），雷打不动。</strong></p>\n<p>此时，我们以 FP 为原点，向上下看：</p>\n<p><strong>往下看（向地基/高地址）</strong>：不管栈顶怎么变，参数 <code>a0</code> 永远在 FP <strong>往下数</strong> 第 2 格的位置（偏移量是正数，如 <code>FP + 16</code>）。</p>\n<p><strong>往上看（向天空/低地址）</strong>：不管栈顶怎么变，变量 <code>r0</code> 永远在 FP <strong>往上数</strong> 第 5 格的位置（偏移量是负数，如 <code>FP - 40</code>）。</p>\n</li>\n</ul>\n<p><strong>所以</strong>：FP 提供了一个<strong>静态的、绝对的</strong>参考坐标系。</p>\n<ol start=\"2\">\n<li>**FP和地址和内容 **</li>\n</ol>\n<p>这是初接触的朋友，理解栈帧链表最容易迷糊的地方。</p>\n<p>我们要区分三个概念：</p>\n<ul>\n<li><strong>FP 寄存器</strong>：</li>\n</ul>\n<p>可以简化理解为，这是 CPU 里的一个物理部件（或 Ignition 的虚拟指针）。</p>\n<ul>\n<li><strong>FP 中的内容</strong>：</li>\n</ul>\n<p>FP中的内容就是 一个内存地址。</p>\n<p>这个内存地址是个指针，指向当前栈帧中的一个字段，</p>\n<p>同时，这个内存地址/指针，也是当前栈帧的 <strong>“零点”</strong>。即 <code>Offset = 0</code>。</p>\n<ul>\n<li><strong>FP 指向的内存地址里存的内容</strong>：</li>\n</ul>\n<p>那么 这个栈帧中的字段，里面的内容是什么？</p>\n<p><strong>答案是：Caller's FP (调用者的 FP)。</strong></p>\n<p>即：上一层栈帧的基准地址。</p>\n<p><strong>这同时也是“栈回溯”的原理：</strong></p>\n<ul>\n<li>当前 FP 指向 <code>Saved FP</code>。</li>\n<li><code>Saved FP</code> 里存着 <code>上一层 FP</code>。</li>\n<li><code>上一层 FP</code> 里存着 <code>上上层 FP</code>。</li>\n<li>...</li>\n<li>这就形成了一条<strong>链表</strong>。调试器（Debugger）就是顺着这条链子，一层层往上爬，才打印出了完整的调用栈。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>偏移量 (Offset) 是怎么确定的？</strong></li>\n</ol>\n<p>搞懂了 FP 是零点，那么，对于参数和变量的寻址，就非常容易理解了。</p>\n<p>让我们站在 FP 这个零点，开始巡视：</p>\n<p><strong>A. 往下看：Caller 留下的遗产 (因为我们使用高地址在下，低地址在上的模式)</strong></p>\n<p>这里是地址 <strong>增加</strong> 的方向（Offset 是 <strong>正数 +</strong>），因为我们在往高地址走。</p>\n<ul>\n<li><strong>Offset     +0 (<code>[FP + 0]</code>)</strong>： 就是脚下。这里存的是 <strong>Saved FP</strong>。</li>\n<li><strong>Offset     +8 (<code>[FP + 8]</code>)</strong>： <strong>往下</strong> 走 1 格。 这里是 <strong>Return Address</strong>。 <em>(为什么是 +8？因为往高地址走了 8 字节。)</em></li>\n<li><strong>Offset     +16 (<code>[FP + 16]</code>)</strong>： <strong>再往下</strong> 走 1 格。 这里是 <strong>Receiver (this)</strong>。 <em>(注：这是雷打不动的专座，离 FP 最近的参数。)</em></li>\n<li><strong>Offset     +24 (<code>[FP + 24]</code>)</strong>： <strong>再往下</strong> 走 1 格。 这里是 <strong>第一个显式参数 (Arguments a0)</strong>。 <em>(注：如果有更多参数 a1, a2... 会继续往下排在 +32, +40...)</em></li>\n</ul>\n<p><strong>B. 往上看：Callee 自己的资产 (低地址区)</strong></p>\n<p>关于偏移量的具体值，在前面，特别说明是用于  <strong>示意</strong>  ，  V8源码中的偏移如下，暂时可以作为确定值，但是以后很有<strong>可能会更改</strong>。</p>\n<blockquote>\n<p><strong>FP (基准)</strong></p>\n<p><strong>[FP - 8]</strong>: <code>StandardFrameConstants::kContextOffset</code> -&gt; <strong>Context</strong></p>\n<p><strong>[FP - 16]</strong>: <code>StandardFrameConstants::kFunctionOffset</code> -&gt; <strong>Function</strong></p>\n<p><strong>[FP - 24]</strong>: <code>InterpretedFrameConstants::kBytecodeArrayFromFp</code> -&gt; <strong>BytecodeArray</strong> (解释器特有)</p>\n<p><strong>[FP - 32]</strong>: <code>InterpretedFrameConstants::kBytecodeOffsetFromFp</code> -&gt; <strong>BytecodeOffset (PC)</strong></p>\n<p><strong>[FP - 40]</strong>: <code>InterpretedFrameConstants::kRegisterFileFromFp</code> -&gt; <strong>r0 (Register 0)</strong> (工作区起点)</p>\n</blockquote>\n<p>这里也需要加一个限定：</p>\n<p><strong>在 64 位系统下，Ignition 解释器栈帧的固定头部布局通常如下：</strong></p>\n<p>这里是地址 <strong>减小</strong> 的方向（Offset 是 <strong>负数 -</strong>），因为我们在往低地址（栈顶）方向爬。</p>\n<ul>\n<li><strong>Offset     -8 (<code>[FP - 8]</code>)</strong>： <strong>往上</strong> 爬 1 格。 这里是 <strong>Context</strong>。 <em>(为什么是负数？因为离天空更近了，地址变小了。)</em></li>\n<li><strong>Offset    -16 (<code>[FP - 16]</code>)</strong>： <strong>再往上</strong> 爬 1 格。 这里是 <strong>Function</strong>。</li>\n<li><strong>Offset    -24 (<code>[FP - 24]</code>)</strong>： <strong>再往上</strong> 爬 1 格。 这里是 <strong>BytecodeArray</strong>。</li>\n<li><strong>Offset    -32 (<code>[FP - 32]</code>)</strong>： <strong>再往上</strong> 爬 1 格。 这里是 <strong>BytecodeOffset (PC)</strong>。 <em>(注：到这里，固定头部结束)</em></li>\n<li><strong>Offset     -40 (<code>[FP - 40]</code>)</strong>： <strong>再往上</strong> 爬 1 格。 终于到了 <strong>工作区</strong>。这里是 <strong>r0</strong>。</li>\n</ul>\n</li>\n</ul>\n<hr />\n<p>ignition解释器的第一部分，已经完成了，后面将是ignition篇的第二部分BytecodeGenerator。</p>\n<p>本想控制篇幅，但是依旧是到了一万一千多字，这部分内容，难度不大，深度不深，主要都是一些前置和基础知识。感兴趣的朋友，多读几遍，都可以理解的。 我觉得  起码比解析篇容易理解多了。</p>\n<p>本文首发于： <a href=\"https://juejin.cn/user/565561530002222/posts\" rel=\"noopener nofollow\" target=\"_blank\">掘金社区</a></p>\n<p>同步发表于： <a href=\"https://blog.csdn.net/f20171110?type=blog\" rel=\"noopener nofollow\" target=\"_blank\">csdn</a></p>\n<p><a href=\"https://www.cnblogs.com/f20171110\" target=\"_blank\">博客园</a></p>\n<p><strong>码字虽不易 知识脉络的梳理更是不易 ，但是知识的传播更重要，</strong></p>\n<p><strong>欢迎转载，请保持全文完整。</strong></p>\n<p><strong>谢绝片段摘录。</strong></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 19:19</span>&nbsp;\n<a href=\"https://www.cnblogs.com/f20171110\">用户新</a>&nbsp;\n阅读(<span id=\"post_view_count\">36</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "LLVM Pass快速入门(四)：代码插桩",
      "link": "https://www.cnblogs.com/ClownLMe/p/19575719",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ClownLMe/p/19575719\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 17:49\">\n    <span>LLVM Pass快速入门(四)：代码插桩</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        从0到1，快速入门 LLVM pass 编写\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"代码插桩\">代码插桩</h1>\n<p>项目需求：在函数运行时打印出运行的函数名</p>\n<h1 id=\"项目目录如下\">项目目录如下</h1>\n<pre><code>/MyProject\n├── CMakeLists.txt # CMake 配置文件\n├── build/ #构建目录\n│   └── test.c #测试编译代码\n└── mypass3.cpp # pass 项目代码\n</code></pre>\n<h3 id=\"一测试代码示例\">一，测试代码示例</h3>\n<p><strong>test.c</strong></p>\n<pre><code class=\"language-c\">#include &lt;stdio.h&gt;\n\nvoid func_A() {\n    int a = 1;\n}\n\nvoid func_B() {\n    func_A();\n}\n\nint main() {\n    printf(\"hello world!\\n\");\n    func_A();\n    func_B();\n    return 0;\n}\n</code></pre>\n<h3 id=\"二编写pass\">二，编写Pass</h3>\n<p>其他的固定的模板之前文章注释有，这里我只注释当前项目重要的部分<br />\n<strong>代码流程：</strong> 遍历指令并匹配<code>ADD</code>指令-&gt;替换为<code>sub</code>指令</p>\n<pre><code class=\"language-cpp\">#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Passes/PassBuilder.h\"\n#include \"llvm/Passes/PassPlugin.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/IRBuilder.h\" \n\nusing namespace llvm;\n\nnamespace {\n\nstruct mypass3 : public PassInfoMixin&lt;mypass3&gt; {\n    \n    PreservedAnalyses run(Function &amp;F, FunctionAnalysisManager &amp;) {\n        //过滤函数\n        //过滤掉printf和printf有关的函数，防止在printf中插入printf造成递归（死循环）\n        if(F.isDeclaration() || F.getName().starts_with(\"_\") || F.getName().contains(\"printf\")){\n            return PreservedAnalyses::all();\n        }\n        errs() &lt;&lt; \"handle func:\" &lt;&lt; F.getName() &lt;&lt; \"\\n\";\n\t\t\n\t\t//获取模块\n        Module *M = F.getParent();\n        //获取模块上下文\n        //上下文中包含了数据的类型\n        LLVMContext &amp;Ctx = M-&gt;getContext();\n        \n        //下面是创建函数，类比java反射，或者frida的hook\n        //定义printf的参数类型，相当于函数括号中的内容，这里的PointerType是指针类型\n        std::vector&lt;Type*&gt; printfArgs = {PointerType::getUnqual(Ctx)};\n\t\t//定义函数类型，这里相当于定义：int (void*, ...)\n        FunctionType *printfType = FunctionType::get(\n            Type::getInt32Ty(Ctx),//函数返回值类型\n            printfArgs,//函数的参数类型(vector)\n            true//是否是可变参数\n        );\n\t\t//如果printf存在则引用，如果不存在，则创建一个新的printf\n        FunctionCallee printfFunc = M-&gt;getOrInsertFunction(\"printf\", printfType);\n\t\t\n\t\t//下面是插入函数\n\t\t//将修改的位置定位到要插桩函数的头部\n        IRBuilder&lt;&gt; builder(&amp;F.getEntryBlock().front());\n        //声明全局变量（这里是要传给printf的格式化字符串）\n        Value* formatStr = builder.CreateGlobalStringPtr(\"&gt;&gt; enter function %s &lt;&lt;\\n\", \"my_format\");\n        //声明全局变量，这里定义了函数名称的字符串变量\n        Value* funcName = builder.CreateGlobalStringPtr(F.getName(), \"my_func_name\");\n        //将上面定义的实际参数传入\n        std::vector&lt;Value*&gt; printfArgsVec = {formatStr, funcName};\n        //创建函数调用\n        builder.CreateCall(printfFunc, printfArgsVec);\n        \n        return PreservedAnalyses::none();\n    }\n};\n\n} \n\nextern \"C\" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo\nllvmGetPassPluginInfo() {\n    return {\n        LLVM_PLUGIN_API_VERSION,\n        \"mypass3\",\n        \"v0.1\",\n        [](PassBuilder &amp;PB) {\n            PB.registerPipelineParsingCallback(\n                [](StringRef Name, FunctionPassManager &amp;FPM,\n                   ArrayRef&lt;PassBuilder::PipelineElement&gt;) {\n                    if (Name == \"mypass3\") {\n                        FPM.addPass(mypass3());\n                        return true;\n                    }\n                    return false;\n                });\n        }};\n}\n</code></pre>\n<h3 id=\"三pass的构建\">三，Pass的构建</h3>\n<p><strong>下面引用的是之前文章的内容</strong><br />\n构建LLVM Pass需要写<code>CMakeLists.txt</code>构建声明</p>\n<h5 id=\"1-配置cmake配置文件\">1. 配置CMake配置文件</h5>\n<p><strong>CMakeLists.txt</strong><br />\n下面的<code>cmake</code>配置可以直接拿去用，我已经标注好需要修改的位置</p>\n<pre><code class=\"language-python\">#cmake 版本，可通过 cmake --version 判断\ncmake_minimum_required(VERSION 4.1.1) #----&gt;修改 cmake版本号\n#项目名字\nproject(mypass3) #----&gt;修改 项目名称\n\n#导入项目的 LLVM cmake 配置文件路径(如果根据我之前文章安装这里就相同)\nset(LLVM_DIR \"D:/LLVM/llvm-project/build/lib/cmake/llvm\")#----&gt;修改 llvm cmake配置路径\n#寻找 LLVM 的包文件\n#REQUIRED 找不到 LLVM 则停止构建\n#强制使用 LLVM 安装时生成的配置文件进行定位\nfind_package(LLVM REQUIRED CONFIG)\n#将 LLVM 的 CMake 模块路径添加到当前 CMake 搜索路径中，以便后续使用 include(AddLLVM)。\nlist(APPEND CMAKE_MODULE_PATH \"${LLVM_CMAKE_DIR}\")\n\n#引入 LLVM 提供的专用 CMake 宏\ninclude(AddLLVM)\n#将 LLVM 的头文件目录（如 llvm/IR/Function.h）加入编译器的搜索路径\ninclude_directories(${LLVM_INCLUDE_DIRS})\n#导入 LLVM 编译时使用的宏定义\nadd_definitions(${LLVM_DEFINITIONS})\n#设置 C++ 标准为 C++17。(这里如果不用17编译会报错)\nset(CMAKE_CXX_STANDARD 17)\n#强制要求必须支持 C++17，如果编译器不支持则失败。\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n#创建一个模块化的库(.dll)\nadd_library(mypass3 MODULE mypass3.cpp) #----&gt;修改 项目名称，文件名\n#windows不用会报错：导出符号\n#LLVM Pass 需要暴露一些特定的入口点（如 getAnalysisUsage）给 opt 工具调用。\nset_target_properties(mypass3 PROPERTIES WINDOWS_EXPORT_ALL_SYMBOLS ON) #----&gt;修改 项目名称\n# 指定该 Pass 需要链接的 LLVM 核心组件。 \n# LLVMCore: 提供 IR、Function、Module 等核心类。 \n# LLVMSupport: 提供各种辅助工具类（如 errs() 输出）。\ntarget_link_libraries(mypass3 LLVMCore LLVMSupport) #----&gt;修改 项目名称，文件名  \n# 为该目标设置特定的编译器选项。 \n# /utf-8: 告诉 MSVC 编译器使用 UTF-8 编码处理源代码，防止中文注释引起的乱码或编译错误。  \ntarget_compile_options(mypass3 PRIVATE /utf-8)#----&gt;修改 项目名称，文件名\n</code></pre>\n<h5 id=\"2编译并构建pass\">2.编译并构建Pass</h5>\n<p><strong>打开visual studio<code>的工作台，我这里是</code>x64 Native Tools Command Prompt for VS 2022`</strong></p>\n<p>进到<code>build</code>目录</p>\n<pre><code class=\"language-bash\">#构建项目\n#其中-DCMAKE_BUILD_TYPE=RelWithDebInfo不选会报错，由于我之前编译的是带符号的relase版本\ncmake -G \"Ninja\"  -DCMAKE_BUILD_TYPE=RelWithDebInfo ..\n#编译\nninja\n</code></pre>\n<p>最后出现下面提示，即为编译成功</p>\n<pre><code class=\"language-bash\">[2/2] Linking CXX shared module mypass3.dll\n</code></pre>\n<h3 id=\"四使用插桩pass对源码进行插桩\">四，使用插桩Pass对源码进行插桩</h3>\n<p>进到<code>build</code>目录</p>\n<pre><code class=\"language-bash\">#把.c文件编译为.ll\n#-O1 使用O1优化（这里我尝试-O0不优化，会导致我的pass无法应用）\n#-Xclang -disable-llvm-passes 不使用默认的pass优化\nclang -S -emit-llvm -O1 -Xclang -disable-llvm-passes test.c -S -o test.ll\n\n#使用pass\nopt -load-pass-plugin=mypass3.dll -passes=mypass3  test.ll -S -o test_opt.ll\n\n#编译使用pass后的exe\nclang test_opt.ll -o test_opt.exe\n#编译使用pass前的exe\nclang test.ll -o test.exe\n</code></pre>\n<p><strong>输出结果</strong><br />\n<code>运行test.exe</code>：<strong>不使用</strong>pass，输出结果如下：</p>\n<pre><code>hello world!\n</code></pre>\n<p><code>运行test_opt.exe</code>：<strong>使用</strong>pass后，输出结果如下：</p>\n<pre><code>&gt;&gt; enter function main &lt;&lt;\nhello world!\n&gt;&gt; enter function func_A &lt;&lt;\n&gt;&gt; enter function func_B &lt;&lt;\n&gt;&gt; enter function func_A &lt;&lt;\n</code></pre>\n<p><strong>我们成功在我们调用函数之前插桩，打印出调用的函数</strong></p>\n<p><strong>如果❤喜欢❤本系列教程，就点个关注吧，后续不定期更新~</strong></p>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/ClownLMe/\" target=\"_blank\">ClownLMe</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/ClownLMe/p/19575719\" target=\"_blank\">https://www.cnblogs.com/ClownLMe/p/19575719</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 17:49</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ClownLMe\">ClownLMe</a>&nbsp;\n阅读(<span id=\"post_view_count\">40</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "鸿蒙应用开发UI基础第二节：鸿蒙应用程序框架核心解析与实操",
      "link": "https://www.cnblogs.com/san-xiu/p/19575201",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/san-xiu/p/19575201\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 16:36\">\n    <span>鸿蒙应用开发UI基础第二节：鸿蒙应用程序框架核心解析与实操</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"学习目标\">学习目标</h2>\n<ol>\n<li>建立鸿蒙应用“宏观-微观”完整认知：明确应用、应用程序包、HAP/HSP、组件、页面的层级关系，理解 Stage 模型编译期与运行期概念的对应逻辑；</li>\n<li>清晰区分 Stage 模型与 FA 模型的核心差异，理解 Stage 模型在资源利用、配置管理、跨端适配等实际开发场景中的核心优势；</li>\n<li>掌握 Stage 模型进程/线程管理机制，理解 UIAbility 与 ExtensionAbility 的线程隔离特性，以及多线程开发的核心思路；</li>\n<li>熟练掌握 UIAbility 在 module.json5 中的核心配置项及规则，精准定位 Stage 工程核心文件并理清依赖链路；</li>\n<li>能独立完成应用名称/图标修改、UIAbility 配置调整、页面加载路径切换等实操，结合工程编译机制验证效果并排查基础配置与编译错误。</li>\n</ol>\n<p>上一节我们掌握了应用配置签名真机调试，本节开始从“应用整体架构”切入，聚焦 Stage 模型核心交互组件 UIAbility 核心能力展开，结合工程编译机制，帮助构建鸿蒙应用开发基础认知体系，为后续应用生命周期、Context 上下文、进程通信等进阶内容学习打下基础。</p>\n<h2 id=\"一回顾鸿蒙系统架构\">一、回顾鸿蒙系统架构</h2>\n<p>鸿蒙系统采用分层架构，共四层，开发者核心工作集中在顶层两层：</p>\n<ol>\n<li><strong>应用层</strong>：面向用户的应用载体，包含两种形态\n<ul>\n<li>原生应用：基于 ArkTS 开发，性能最优，能深度调用分布式能力，是鸿蒙生态核心；</li>\n<li>元服务：免安装、轻量便捷，适合高频次、低留存场景（如扫码支付）；</li>\n</ul>\n</li>\n<li><strong>框架层</strong>：开发聚焦在框架层，提供 ArkUI 组件、状态管理、路由/导航跳转等核心能力，后续组件开发、布局设计均依赖此层；</li>\n<li><strong>系统服务层</strong>：封装分布式能力、设备管理等基础服务，开发者通过 API 调用即可，无需关注底层实现；</li>\n<li><strong>内核层</strong>：负责进程调度、内存管理等底层操作，开发者无需深入接触。</li>\n</ol>\n<p><strong>图 1：鸿蒙系统架构图</strong> - 展示四层架构层级关系，标注开发者核心关注的应用层与框架层。</p>\n<p><img alt=\"鸿蒙系统架构教学版本\" class=\"lazyload\" /></p>\n<blockquote>\n<p>HarmonyOS 5.0 开始彻底完成 Linux 内核和安卓开放源代码项目（AOSP）的全面替换，采用纯鸿蒙内核（HarmonyOS Kernel），实现全栈自研。本阶段所有内容均基于鸿蒙 5.0~6.0 版本进行应用开发讲解。</p>\n</blockquote>\n<h2 id=\"二程序框架服务ability-kit\">二、程序框架服务（Ability Kit）</h2>\n<h3 id=\"一核心定义\">（一）核心定义</h3>\n<p>Ability Kit（程序框架服务）是鸿蒙系统为应用提供的核心运行时基础框架，抽象提炼应用开发所需核心能力，提供标准化组件体系和运行机制。<strong>核心价值是让开发者基于统一模型开发应用，同时保障应用在多设备、多场景下的兼容性与性能</strong>。</p>\n<h3 id=\"二核心能力与使用场景\">（二）核心能力与使用场景</h3>\n<table>\n<thead>\n<tr>\n<th>能力范围</th>\n<th>具体内容</th>\n<th>典型使用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>生命周期与进程管理</td>\n<td>应用/组件进程创建销毁、生命周期调度</td>\n<td>多 Module 应用开发，HAP/HSP 分工实现功能</td>\n</tr>\n<tr>\n<td>组件交互能力</td>\n<td>组件间/应用间跳转、跨设备流转</td>\n<td>办公应用内启动视频会议组件、购物应用跳转支付应用、视频跨设备流转</td>\n</tr>\n<tr>\n<td>基础支撑能力</td>\n<td>上下文环境、系统事件监听、启动框架、意图框架等</td>\n<td>应用快捷方式配置、程序访问控制、密码自动填充</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"三核心特征\">（三）核心特征</h3>\n<ol>\n<li><strong>标准化开发范式</strong>：抽象应用开发通用能力，提供统一的组件体系、生命周期规则，降低跨设备/跨版本适配成本；</li>\n<li><strong>高效资源调度</strong>：统一管理应用进程/线程，优化组件启动、内存占用等性能指标；</li>\n<li><strong>系统能力封装</strong>：内置意图框架、启动框架、流转能力等，无需开发者手动对接底层系统 API；</li>\n<li><strong>多场景支撑</strong>：通过 ExtensionAbility 覆盖备份、输入法、卡片等无 UI/轻 UI 场景，平衡功能扩展与系统管控。</li>\n</ol>\n<h3 id=\"四核心关联\">（四）核心关联</h3>\n<ul>\n<li><strong>ArkUI</strong>：UIAbility 组件中可使用 ArkUI 的组件、事件、动效、状态管理等能力实现界面开发；</li>\n<li><strong>ArkTS</strong>：提供语言运行时能力，支撑 Ability Kit 的代码执行；</li>\n<li><strong>Hvigor</strong>：鸿蒙官方构建工具，为 Ability Kit 相关组件与配置提供编译构建能力，实现代码与配置的工程化落地。</li>\n</ul>\n<h2 id=\"三鸿蒙应用模型\">三、鸿蒙应用模型</h2>\n<h3 id=\"一核心定义与构成要素\">（一）核心定义与构成要素</h3>\n<p>应用模型是 Ability Kit 对应用开发能力的抽象封装，定义应用的组件体系、运行机制、配置规范等核心规则，核心构成要素如下：</p>\n<table>\n<thead>\n<tr>\n<th>构成要素</th>\n<th>核心作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>应用组件</td>\n<td>应用运行入口，通过生命周期回调感知状态变化</td>\n</tr>\n<tr>\n<td>进程/线程模型</td>\n<td>定义进程/线程的创建、销毁及通信方式</td>\n</tr>\n<tr>\n<td>任务管理模型</td>\n<td>定义任务创建、销毁及与组件的关联（仅系统应用）</td>\n</tr>\n<tr>\n<td>应用配置文件</td>\n<td>存储应用/组件配置、权限等信息，供编译/运行阶段使用</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"二演进历程fa-模型--stage-模型\">（二）演进历程：FA 模型 → Stage 模型</h3>\n<table>\n<thead>\n<tr>\n<th>模型类型</th>\n<th>适配版本</th>\n<th>核心状态</th>\n<th>官方开发优势</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>FA 模型</td>\n<td>API 7~8</td>\n<td>已停止更新</td>\n<td>-</td>\n</tr>\n<tr>\n<td>Stage 模型</td>\n<td>API 9+</td>\n<td>主推且长期演进</td>\n<td>1. 组件职责清晰，开发效率更高；2. 资源占用更低，启动速度更快；3. 跨端适配更便捷；4. 系统能力集成更简单；5. 编译分层设计，支持模块按需编译，提升开发效率</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"三fa-模型与-stage-模型核心差异\">（三）FA 模型与 Stage 模型核心差异</h3>\n<table>\n<thead>\n<tr>\n<th>对比维度</th>\n<th>FA 模型</th>\n<th>Stage 模型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>组件体系</td>\n<td>Page/Service/DataAbility（匿名对象）</td>\n<td>UIAbility+ExtensionAbility（类继承）</td>\n</tr>\n<tr>\n<td>引擎机制</td>\n<td>每个组件独享 ArkTS 引擎实例</td>\n<td>所有组件共享一个 ArkTS 引擎实例</td>\n</tr>\n<tr>\n<td>进程模型</td>\n<td>主进程+渲染进程</td>\n<td>主进程+可配置独立进程（ExtensionAbility支持进程自定义）</td>\n</tr>\n<tr>\n<td>线程模型</td>\n<td>引擎实例在非主线程创建，不支持进程内对象共享</td>\n<td>引擎实例在主线程创建，支持进程内对象共享</td>\n</tr>\n<tr>\n<td>配置文件</td>\n<td>单一 config.json（混编全局/模块配置）</td>\n<td>app.json5（应用级）+ module.json5（模块级）</td>\n</tr>\n<tr>\n<td>编译机制</td>\n<td>整体工程编译，修改局部需重新编译全部</td>\n<td>分层编译，支持模块/全局编译，按需编译修改部分，效率更高</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"四stage-模型核心架构与组成\">（四）Stage 模型核心架构与组成</h3>\n<h4 id=\"1-stage-模型核心架构图\">1. Stage 模型核心架构图</h4>\n<p><strong>图 2：Stage 模型编译期-运行期架构图</strong> - 左侧为运行期概念（应用实例化流程），右侧为编译期概念（开发打包流程），展示“模块→组件→页面”的打包与实例化对应关系。</p>\n<p><img alt=\"Stage模型开发概述\" class=\"lazyload\" /></p>\n<h4 id=\"2-核心组成单元\">2. 核心组成单元</h4>\n<ol>\n<li><strong>AbilityStage</strong>：可选实现（若不实现，系统默认创建）；Entry/Feature 类型 HAP 的运行时载体，<strong>一个 HAP 对应一个 AbilityStage 实例</strong>，负责 HAP 的初始化、组件创建分发、模块级生命周期管理；</li>\n<li><strong>UIAbility</strong>：带 UI 的核心交互组件，通过 WindowStage 管理窗口，实现用户交互；</li>\n<li><strong>ExtensionAbility</strong>：面向特定场景的扩展组件（如 EntryBackupAbility、InputMethodExtensionAbility），是 UIAbility 的扩展，用于无界面的后台能力（如备份、输入法）；</li>\n<li><strong>WindowStage</strong>：与 UIAbility 实例绑定的窗口管理器，负责窗口创建、销毁，为 ArkUI 提供绘制区域；</li>\n<li><strong>Context</strong>：派生类（ApplicationContext/AbilityStageContext/UIAbilityContext）为不同层级提供运行期资源调用、权限管理等能力；</li>\n<li><strong>三级生命周期</strong>：Application（应用级）→ AbilityStage（模块级）→ UIAbility/ExtensionAbility（组件级），由 Ability Kit 统一调度，实现资源精细化管理。</li>\n</ol>\n<h4 id=\"3-核心层级关系说明\">3. 核心层级关系说明</h4>\n<ol>\n<li>层级关联：Application（应用全局）→ AbilityStage（HAP 模块）→ UIAbility/ExtensionAbility（组件），依次依赖创建；</li>\n<li>持有关系：UIAbility→WindowStage→Window→ArkUI Page，且各层级均持有对应 Context；</li>\n<li>对应关系：Application ↔ Bundle，AbilityStage ↔ HAP（1:1 绑定）。</li>\n</ol>\n<pre><code># 编译期（开发/打包）\n应用程序包（Bundle） → 模块（HAP/HSP） → 组件（UIAbility/ExtensionAbility） → 页面（Page）\n\n# 运行期（安装/启动）\nApplication（应用全局实例） → AbilityStage（HAP 模块实例） → 组件实例 → 页面渲染\n</code></pre>\n<h3 id=\"五stage-模型开发与运行全流程\">（五）Stage 模型开发与运行全流程</h3>\n<h4 id=\"1-开发阶段\">1. 开发阶段</h4>\n<p>开发者基于 Stage 模型完成应用功能开发与配置，核心工作包括：</p>\n<ul>\n<li><strong>应用组件开发</strong>：通过 UIAbility 组件开发带界面的用户交互模块（如应用主界面），通过 ExtensionAbility 等组件开发各类扩展功能模块；</li>\n<li><strong>模块解耦设计</strong>：为减少不同功能模块间的依赖和耦合，可将 UIAbility 和各类 ExtensionAbility 的实现分别放在不同的 HAP 包中，同时将两者共同依赖的通用功能放在 HSP 包中；</li>\n<li><strong>配置文件编写</strong>：在 app.json5 中配置应用名称、版本号、应用图标等全局信息，在 module.json5 中配置对应 HAP 包下的组件清单、组件权限、进程归属等模块级信息；配置信息会在应用编译、安装时被系统解析，便于系统和其他模块识别、交互。</li>\n</ul>\n<h4 id=\"2-运行阶段\">2. 运行阶段</h4>\n<p>当应用安装到设备运行时，系统通过一套应用进程和线程的管理机制，确保功能的有序运行：</p>\n<ul>\n<li>进程是应用运行的基础单元，负责资源分配和隔离；</li>\n<li>线程是进程内的执行单元，负责具体代码逻辑的执行；</li>\n<li>Ability Kit 统一管控进程/线程的创建、销毁和调度，保障应用稳定运行。</li>\n</ul>\n<h4 id=\"3-进程模型\">3. 进程模型</h4>\n<ul>\n<li>基础规则：UIAbility 组件默认运行在应用主进程中； ExtensionAbility 组件<strong>进程行为可配置</strong>，可通过<code>module.json5</code>中的<code>process</code>字段进行配置；</li>\n<li>配置方式：在 ExtensionAbility 组件的配置节点中添加<code>process</code>字段，值以<code>:</code>开头表示配置为独立进程运行，未配置则默认与 UIAbility 同进程运行；</li>\n<li>通信规则：ExtensionAbility 与 UIAbility 同进程时为线程隔离状态，数据和资源不直接互通；独立进程时需通过跨进程通信机制实现数据交互；</li>\n<li>核心价值：进程可配置性兼顾了应用性能和稳定性——轻量扩展组件与主进程共享资源，减少进程开销；核心/高隔离性扩展组件独立进程运行，避免单一组件异常影响整个应用。</li>\n</ul>\n<h4 id=\"4-组件通信机制\">4. 组件通信机制</h4>\n<p>鸿蒙提供多套通信机制，适配不同组件类型、不同进程归属的通信场景，核心分类如下：</p>\n<ul>\n<li><strong>进程内通信</strong>：适用于同一进程内的 UIAbility 与 ExtensionAbility、UIAbility 与页面间，优先使用<strong>EventHub</strong>，轻量高效、无需复杂配置；</li>\n<li><strong>跨进程通信</strong>：适用于跨应用、独立进程的 HAP 之间、独立进程 ExtensionAbility 与 UIAbility 之间，使用<strong>IPC</strong>基础通信机制；</li>\n<li><strong>ExtensionAbility 专属通信</strong>：不同类型的 ExtensionAbility 提供专属通信接口，适配自身业务场景，核心接口如下：\n<ul>\n<li>ServiceExtensionAbility：通过<code>connectServiceExtensionAbility()</code>建立连接，实现主从组件的双向通信；</li>\n<li>DataShareExtensionAbility：通过<code>createDataShareHelper()</code>创建助手实例，实现数据的增删改查共享。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>纯 ArkTS 单进程应用，优先使用 EventHub 实现组件/线程间通信；涉及独立进程或跨应用交互时，根据组件类型选择对应专属通信接口或基础 IPC 机制。</p>\n</blockquote>\n<h4 id=\"5-线程模型\">5. 线程模型</h4>\n<ul>\n<li>基础支撑：Stage 模型提供 worker、taskpool 等机制支撑应用多线程开发场景；</li>\n<li>开发建议：应用若有复杂的耗时逻辑（如大数据处理、网络请求、复杂计算），建议通过创建 worker 线程的方式处理，避免阻塞主线程（UI 线程），保障应用界面流畅性；</li>\n<li>线程隔离：无论 ExtensionAbility 与 UIAbility 同进程还是独立进程，其内部均为线程隔离设计，耗时逻辑均需放在子线程执行，不可直接在组件主线程处理。</li>\n</ul>\n<h3 id=\"六stage-模型开发流程\">（六）Stage 模型开发流程</h3>\n<table>\n<thead>\n<tr>\n<th>核心任务</th>\n<th>关键内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>应用组件开发</td>\n<td>开发 UIAbility/ExtensionAbility，按功能拆分到不同 HAP，通用能力抽离到 HSP</td>\n</tr>\n<tr>\n<td>进程/线程模型适配</td>\n<td>基于业务需求配置 ExtensionAbility 进程归属，耗时逻辑通过 worker 处理，遵循线程隔离规则</td>\n</tr>\n<tr>\n<td>配置文件编写</td>\n<td>配置 app.json5（全局）/module.json5（模块）的应用/组件/进程信息，保证路径与语法合规</td>\n</tr>\n<tr>\n<td>通信机制实现</td>\n<td>按进程归属和组件类型选择 EventHub、专属接口或 IPC 实现通信</td>\n</tr>\n<tr>\n<td>效果验证</td>\n<td>基于模块编译验证局部修改效果，全局编译生成完整应用包</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"四鸿蒙应用组成结构\">四、鸿蒙应用组成结构</h2>\n<h3 id=\"一应用程序包bundle\">（一）应用程序包（Bundle）</h3>\n<ul>\n<li>定义：鸿蒙应用分发、安装的最小单位（后缀<code>.app</code>），由全局编译整合所有 HAP/HSP 模块编译产物生成；</li>\n<li>构成：Entry HAP（必选，应用启动入口）、Feature HAP（可选，扩展功能）、HSP（可选，代码/资源共享）；</li>\n<li>多包机制：1 个 Bundle 可包含多个 HAP（Entry HAP 最多 1 个，Feature HAP 不限），HAP 之间通过 HSP 共享代码/资源，各模块可独立编译，最终整合至 Bundle。</li>\n</ul>\n<h3 id=\"二模块haphsp\">（二）模块（HAP/HSP）</h3>\n<table>\n<thead>\n<tr>\n<th>模块类型</th>\n<th>核心作用</th>\n<th>关键特征</th>\n<th>运行期关联实例</th>\n<th>典型使用场景</th>\n<th>编译特性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Entry HAP</td>\n<td>应用主模块，提供启动入口</td>\n<td>必选，包含主 UIAbility，可单独安装运行</td>\n<td>对应 1 个 AbilityStage 实例</td>\n<td>应用主界面、核心交互功能</td>\n<td>可独立编译为 HAP 包，支持单独运行验证</td>\n</tr>\n<tr>\n<td>Feature HAP</td>\n<td>扩展功能模块</td>\n<td>可选，依赖 Entry HAP 运行，支持按需加载</td>\n<td>对应 1 个 AbilityStage 实例</td>\n<td>备份、输入法等扩展功能</td>\n<td>可独立编译，需结合 Entry HAP 运行</td>\n</tr>\n<tr>\n<td>HSP</td>\n<td>代码/资源共享包</td>\n<td>可选，无独立运行组件，仅用于模块间复用</td>\n<td>无对应的 AbilityStage 实例</td>\n<td>通用工具类、常量定义、公共资源</td>\n<td>编译为共享包，被其他 HAP 依赖调用</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>关于包的类型以及使用创建方法，我们会在项目阶段学习掌握。</p>\n</blockquote>\n<h3 id=\"三核心组件stage-模型两类组件\">（三）核心组件（Stage 模型两类组件）</h3>\n<table>\n<thead>\n<tr>\n<th>组件类型</th>\n<th>核心作用</th>\n<th>交互方式</th>\n<th>开发方式</th>\n<th>进程默认配置</th>\n<th>细分类型/示例文件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>UIAbility</td>\n<td>应用入口+窗口管理，实现用户交互</td>\n<td>桌面启动、可视化交互</td>\n<td>面向对象开发（类继承）</td>\n<td>应用主进程</td>\n<td>EntryAbility.ets（应用主界面）</td>\n</tr>\n<tr>\n<td>ExtensionAbility</td>\n<td>备份/输入法等无 UI/轻 UI 场景</td>\n<td>系统/事件触发</td>\n<td>面向对象开发（派生类实现）</td>\n<td>应用主进程</td>\n<td>EntryBackupAbility.ets（备份）、DataShareExtensionAbility.ets（数据共享）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"五工程结构\">五、工程结构</h2>\n<p>延用上一节创建的项目<code>FirstApplication</code>（基于鸿蒙 5.0 API 12 + DevEco Studio 6.0+），工程核心结构如下，其中<code>build</code>目录为编译后自动生成，<code>build-profile.json5</code>和<code>hvigorfile.ts</code>为鸿蒙 Hvigor 构建工具的核心编译配置文件，实现工程与模块的分层编译管理：</p>\n<pre><code>FirstApplication                    \n├── AppScope/                # 应用全局配置目录\n│   ├── resources/           # 应用全局资源目录\n│   │   ├── base/            # 全局基础资源目录\n│   │   │   ├── element/     # 全局字符串、颜色等配置\n│   │   │   │   └── string.json\n│   │   │   ├── media/       # 全局媒体资源（层叠图标配置、兜底图标）\n│   │   │   │   ├── app_icon.png // 自定义的应用图标\n│   │   │   │   ├── background.png\n│   │   │   │   ├── foreground.png\n│   │   │   │   └── layered_image.json\n│   │   │   └── profile/     # 全局配置文件（如页面路由、备份配置等）\n│   └── app.json5            # 全局配置文件（包名、版本、图标、名称等，供全局编译解析）\n├── entry/                   # Entry HAP主模块（核心开发目录）\n│   ├── build/               # 模块编译产物目录（编译后自动生成，存放entry模块HAP包）\n│   ├── src/\n│   │   ├── main/            # entry模块核心源码目录\n│   │   │   ├── ets/         # ArkTS代码目录\n│   │   │   │   ├── entryability/ # UIAbility核心组件目录\n│   │   │   │   │   └── EntryAbility.ets\n│   │   │   │   ├── entrybackupability/ # 备份扩展组件目录\n│   │   │   │   │   └── EntryBackupAbility.ets\n│   │   │   │   └── pages/   # 页面目录\n│   │   │   │       ├── Index.ets\n│   │   │   │       └── Home.ets\n│   │   │   ├── resources/   # 模块级静态资源目录（编译时自动打包优化）\n│   │   │   │   ├── base/    # 基础资源目录（默认主题）\n│   │   │   │   │   ├── element/ # 模块级元素配置\n│   │   │   │   │   ├── media/   # 模块级媒体资源\n│   │   │   │   │   │   ├── background.png\n│   │   │   │   │   │   ├── foreground.png\n│   │   │   │   │   │   ├── startIcon.png // 默认的窗口图标\n│   │   │   │   │   │   └── layered_image.json\n│   │   │   │   ├── dark/    # 深色模式资源目录\n│   │   │   │   └── rawfile/ # 原生文件目录（无需编译的静态文件）\n│   │   │   └── module.json5 # Entry HAP模块配置文件（组件、权限、进程等，供模块编译解析）\n│   ├── mock/                # 模拟数据目录（测试用）\n│   ├── ohosTest/            # OpenHarmony测试目录\n│   ├── test/                # 本地测试目录\n│   ├── .gitignore           # Git忽略文件配置\n│   ├── build-profile.json5  # 模块编译配置文件（指定SDK版本、签名关联等编译规则）\n│   └── hvigorfile.ts        # 模块编译脚本（Hvigor构建工具模块级执行入口）\n├── build/                   # 工程全局编译产物目录（编译后自动生成，存放全局整合的HAP/APP包）\n├── build-profile.json5      # 工程全局编译配置文件（统一管理所有模块编译规则、编译模式）\n├── hvigorfile.ts            # 工程全局编译脚本（Hvigor构建工具全局执行入口，触发所有模块编译）\n├── oh-package.json5         # ohpm依赖配置文件（编译前自动解析下载依赖）\n└── oh-package-lock.json5    # ohpm依赖版本锁定文件\n</code></pre>\n<blockquote>\n<p>说明：鸿蒙工程基于<strong>Hvigor</strong>（鸿蒙官方自研构建工具）实现编译，采用<strong>按需编译</strong>原则，仅修改过的模块/文件会重新编译，未修改部分复用原有编译产物，提升开发效率；<code>build</code>目录删除后可通过重新编译生成，不影响工程源码。</p>\n</blockquote>\n<h2 id=\"六uiability-核心实操\">六、UIAbility 核心实操</h2>\n<h3 id=\"一核心定位\">（一）核心定位</h3>\n<ol>\n<li><strong>应用入口</strong>：用户点击应用图标后，系统首先创建并启动 UIAbility 实例；</li>\n<li><strong>窗口管理载体</strong>：每个 UIAbility 实例启动后会创建一个 WindowStage（窗口管理器），负责窗口的创建、销毁，并<strong>通过 WindowStage 加载 ArkUI 页面</strong>；</li>\n<li><strong>实例模式</strong>：支持单实例、多实例、指定实例等配置（通过 module.json5 的<code>launchType</code>字段），满足不同业务场景需求；</li>\n<li><strong>编译关联</strong>：UIAbility 的类名、文件路径需与 module.json5 中<code>name</code>、<code>srcEntry</code>配置完全一致，否则会导致模块编译失败，无法生成 HAP 包；</li>\n<li><strong>权限核心</strong>：作为应用核心交互组件，UIAbility 是应用权限申请和校验的核心载体，后台启动其他组件需依赖专属系统权限。</li>\n</ol>\n<h3 id=\"二核心配置\">（二）核心配置</h3>\n<h4 id=\"1-模块级配置modulejson5\">1. 模块级配置（module.json5）</h4>\n<pre><code class=\"language-json\">{\n  \"module\": {\n    \"name\": \"entry\", // 模块名称\n    \"type\": \"entry\", // 模块类型：entry/feature/har/hsp\n    \"description\": \"$string:module_desc\", // 模块描述\n    \"mainElement\": \"EntryAbility\", // 默认启动组件\n    \"deviceTypes\": [ // 支持的设备类型\n      \"phone\"\n    ],\n    \"deliveryWithInstall\": true, // 是否随应用安装交付\n    \"installationFree\": false, // 是否免安装\n    \"pages\": \"$profile:main_pages\", // 页面路由配置\n    \"abilities\": [ // UIAbility组件配置\n      {\n        \"name\": \"EntryAbility\", // 组件名称（与代码类名一致，编译校验关键）\n        \"srcEntry\": \"./src/main/ets/entryability/EntryAbility.ets\", // 入口路径（必须./开头，编译校验关键）\n        \"description\": \"$string:EntryAbility_desc\", // 组件描述\n        \"icon\": \"$media:layered_image\", // 组件图标（模块级，不重名的情况下优先生效）\n        \"label\": \"$string:EntryAbility_label\", // 组件显示名称（模块级，优先级更高）\n        \"startWindowIcon\": \"$media:startIcon\", // 启动窗口图标\n        \"startWindowBackground\": \"$color:start_window_background\", // 启动窗口背景\n        \"exported\": true, // 是否允许跨应用调用\n        \"launchType\": \"singleton\", // 默认的启动模式，可以不写\n        \"skills\": [ // 桌面图标必配：缺少则桌面无应用图标\n          {\n            \"entities\": [\n              \"entity.system.home\" // 桌面入口标识\n            ],\n            \"actions\": [\n              \"ohos.want.action.home\" // 桌面启动动作\n            ]\n          }\n        ]\n      }\n    ],\n    \"extensionAbilities\": [ // 扩展组件配置\n      {\n        \"name\": \"EntryBackupAbility\", // 备份扩展组件名称\n        \"srcEntry\": \"./src/main/ets/entrybackupability/EntryBackupAbility.ets\", \n        \"type\": \"backup\", // 扩展类型（backup/dataShare/inputMethod等）\n        \"exported\": false, // 仅内部使用\n        \"metadata\": [ // 扩展元数据\n          {\n            \"name\": \"ohos.extension.backup\", // 元数据名称\n            \"resource\": \"$profile:backup_config\" // 元数据配置文件\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre>\n<h4 id=\"2-配置关键规则\">2. 配置关键规则</h4>\n<ul>\n<li><code>mainElement</code>：Entry HAP 必须配置为 UIAbility，Feature HAP 无默认启动组件；</li>\n<li><code>name</code>：组件名称必须与代码中导出的类名一致，不可随意修改，编译时会严格校验；</li>\n<li><code>srcEntry</code>：路径需以<code>./</code>开头，严格匹配文件的目录/文件名（区分大小写），路径错误会直接导致编译失败；</li>\n<li><code>exported</code>：跨应用调用的组件需设为 true，仅内部使用的组件设为 false 即可；</li>\n<li><code>skills</code>：仅 UIAbility 需配置（桌面图标展示），ExtensionAbility 无需配置；缺失或配置不全则桌面无图标，点击图标进入应用详情页；</li>\n<li><code>type</code>：ExtensionAbility 必选字段，需与扩展类型匹配（如 backup、dataShare、inputMethod 等）；</li>\n<li><code>process</code>：ExtensionAbility 可选配置字段，用于设置进程归属，值以<code>:</code>开头表示独立进程，未配置则默认与主进程同进程；</li>\n<li>JSON 语法：禁止末尾多余逗号，配置项、文件/目录名称均区分大小写，语法错误会导致编译解析失败。</li>\n</ul>\n<h4 id=\"3-全局配置appjson5\">3. 全局配置（app.json5）</h4>\n<pre><code class=\"language-json\">{\n  \"app\": {\n    \"bundleName\": \"com.sanxiu.firstapp\",\n    \"vendor\": \"example\",\n    \"versionCode\": 1000000,\n    \"versionName\": \"1.0.0\",\n    \"icon\": \"$media:layered_image\", // 全局应用图标\n    \"label\": \"$string:app_name\" // 全局应用名称\n  }\n}\n</code></pre>\n<h4 id=\"4-层叠图标配置layered_imagejson\">4. 层叠图标配置（layered_image.json）</h4>\n<p><strong>路径</strong>：</p>\n<ul>\n<li>全局：AppScope/resources/base/media/layered_image.json</li>\n<li>模块级：entry/src/main/resources/base/media/layered_image.json</li>\n</ul>\n<pre><code class=\"language-json\">{\n  \"layered-image\": {\n    \"background\": \"$media:background\",\n    \"foreground\": \"$media:foreground\"\n  }\n}\n</code></pre>\n<p><strong>核心规则</strong>：</p>\n<ul>\n<li>资源覆盖：编译期 AppScope 和模块内重名资源，AppScope 资源优先级更高；</li>\n<li>模块级 icon 生效前提：UIAbility 的 <code>skills</code> 字段必须包含<code>entity.system.home</code>和<code>ohos.want.action.home</code>；多 Ability 时取<code>mainElement</code>对应配置；</li>\n<li>图标尺寸规范：鸿蒙层叠图标推荐基础尺寸：foreground/background 均为<strong>1024×1024</strong>（png 格式，透明背景），编译时系统会自动适配不同设备的图标尺寸，无需手动制作多尺寸版本。</li>\n</ul>\n<h4 id=\"5-页面路由配置main_pagesjson\">5. 页面路由配置（main_pages.json）</h4>\n<p>通过 <code>New -&gt; Page -&gt; Empty Page</code> 创建的页面会自动导入<code>main_pages.json</code>，其他方法创建的页面需要手动管理路由配置。</p>\n<pre><code class=\"language-json\">{\n  \"src\": [\n    \"pages/Index\",\n    \"pages/Home\" // 新增Home页面路径\n  ]\n}\n</code></pre>\n<h3 id=\"三页面加载核心逻辑entryabilityets\">（三）页面加载核心逻辑（EntryAbility.ets）</h3>\n<pre><code class=\"language-typescript\">import UIAbility from '@ohos.app.ability.UIAbility';\nimport window from '@ohos.window';\nimport hilog from '@ohos.hilog';\nimport { AbilityConstant, Want } from '@kit.AbilityKit';\nimport { BusinessError } from '@ohos.base'; \n\nconst DOMAIN: number = 0x0000;\nconst TAG: string = 'EntryAbility';\n\nexport default class EntryAbility extends UIAbility {\n  // 组件创建时触发，可初始化资源\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    hilog.info(DOMAIN, TAG, 'EntryAbility onCreate called');\n  }\n\n  // 组件销毁时触发，可释放资源\n  onDestroy() {\n    hilog.info(DOMAIN, TAG, 'EntryAbility onDestroy called');\n  }\n\n  // 窗口创建后触发，仅此处可加载页面\n  onWindowStageCreate(windowStage: window.WindowStage): void {\n    hilog.info(DOMAIN, TAG, '--- onWindowStageCreate 触发（加载页面）---');\n    // 加载页面\n    windowStage.loadContent('pages/Index', (err) =&gt; {\n      if (err.code) {\n        hilog.error(DOMAIN, TAG, `页面加载失败：code=${err.code}, message=${err.message}`);\n        return;\n      }\n      hilog.info(DOMAIN, TAG, 'Index页面加载成功');\n    });\n  }\n\n  onWindowStageDestroy(): void {\n    // Main window is destroyed, release UI related resources\n    hilog.info(DOMAIN, TAG, '%{public}s', '主窗口即将销毁，释放UI相关资源');\n  }\n\n  onForeground(): void {\n    // Ability has brought to foreground\n    hilog.info(DOMAIN, TAG, '%{public}s', '应用切换至前台，恢复业务逻辑');\n  }\n\n  onBackground(): void {\n    // Ability has back to background\n    hilog.info(DOMAIN, TAG, '%{public}s', '应用切换至后台，暂停业务逻辑，不可启动其他组件');\n  }\n}\n</code></pre>\n<h4 id=\"页面加载规则\">页面加载规则</h4>\n<ol>\n<li>仅能通过<code>WindowStage.loadContent()</code>加载页面；</li>\n<li>该方法仅可在<code>onWindowStageCreate</code>生命周期中调用；</li>\n<li>路径需严格遵循“无.ets后缀、区分大小写、基于pages根目录的相对路径”，且需与<code>main_pages.json</code>中注册的路径完全一致，否则编译通过但运行时页面加载失败；</li>\n<li>页面文件命名、路径错误会导致编译时资源打包失败，或运行时页面空白。</li>\n</ol>\n<h3 id=\"四自定义首页开发\">（四）自定义首页开发</h3>\n<h4 id=\"步骤-1创建-home-页面pageshomeets\">步骤 1：创建 Home 页面（pages/Home.ets）</h4>\n<pre><code class=\"language-typescript\">@Entry\n@Component\nstruct Home {\n  build() {\n    Column({ space: 20 }) {\n      Text('我的Stage应用首页')\n        .fontSize(30)\n        .fontWeight(FontWeight.Bold);\n    }\n    .width('100%')\n    .height('100%')\n    .justifyContent(FlexAlign.Center);\n  }\n}\n</code></pre>\n<h4 id=\"步骤-2注册-home-页面到路由配置main_pagesjson\">步骤 2：注册 Home 页面到路由配置（main_pages.json）</h4>\n<p>打开路径：<code>entry/src/main/resources/base/profile/main_pages.json</code>，在<code>src</code>数组中新增 Home 页面路径，确保与实际文件路径一致：</p>\n<pre><code class=\"language-json\">{\n  \"src\": [\n    \"pages/Index\",\n    \"pages/Home\" // 必须注册，否则运行时页面加载失败\n  ]\n}\n</code></pre>\n<h4 id=\"步骤-3修改页面加载路径entryabilityets\">步骤 3：修改页面加载路径（EntryAbility.ets）</h4>\n<p>将<code>windowStage.loadContent('pages/Index', ...)</code>修改为：</p>\n<pre><code class=\"language-typescript\">// 加载页面\nwindowStage.loadContent('pages/Home').then(()=&gt;{\n  hilog.info(DOMAIN, TAG, 'Home页面加载成功');\n}).catch((err: BusinessError)=&gt;{\n  hilog.error(DOMAIN, TAG, `页面加载失败：code=${err.code}, message=${err.message}`);\n})\n</code></pre>\n<h4 id=\"效果验证\">效果验证</h4>\n<p><img alt=\"修改加载页面.png\" class=\"lazyload\" /></p>\n<ol>\n<li><strong>应用内验证</strong>：正常展示<code>我的Stage应用首页</code>，无空白、无报错；</li>\n<li><strong>日志端验证</strong>：Logcat 中筛选<code>TAG:EntryAbility</code>，可看到“Home页面加载成功”相关日志。</li>\n</ol>\n<h3 id=\"五配置应用名称和图标\">（五）配置应用名称和图标</h3>\n<h4 id=\"1-层叠图标方案-模块级配置\">1. 层叠图标方案-模块级配置</h4>\n<p>默认工程中，全局应用图标、模块级图标、layered-image 及前后背景图的命名均一致。<br />\n若需让模块级应用图标生效，需删除<strong>AppScope/resources/base/media/</strong> 目录下的 layered-image 相关文件（含<code>layered_image.json</code>、<code>background.png</code>、<code>foreground.png</code>），避免全局重名资源覆盖（不推荐）。</p>\n<p><strong>推荐方案</strong>：确保资源不重名，使用自定义图标名称，同时保证<code>module.json5</code> 中配置了<code>skills</code>字段（桌面图标正常显示前提）：</p>\n<ul>\n<li>确认 entry 模块<code>layered_image.json</code>配置（路径：entry/src/main/resources/base/media/layered_image.json）；</li>\n<li>确保 module.json5 中 UIAbility 配置<code>\"icon\": \"$media:layered_image\"</code>。</li>\n</ul>\n<h4 id=\"2-层叠图标方案-全局级配置\">2. 层叠图标方案-全局级配置</h4>\n<p>直接将应用图标图片命名为<code>foreground</code>，或自定义 layered_image.json 中<code>foreground</code>的资源引用为<code>\"foreground\": \"$media:app_icon\"</code>：</p>\n<ol>\n<li>配置 AppScope 下<code>layered_image.json</code>（路径：AppScope/resources/base/media/layered_image.json）；</li>\n<li>在<code>AppScope/app.json5</code>中配置全局图标：<code>\"icon\": \"$media:layered_image\"</code>。</li>\n</ol>\n<h4 id=\"3-应用名称配置\">3. 应用名称配置</h4>\n<p>应用名称的配置优先级：<strong>模块级别 &gt; 全局级别</strong>。若需让全局资源配置的应用名称生效，需在 module.json5 中注释/删除 UIAbility 的 label 配置：<code>\"label\": \"$string:EntryAbility_label\"</code>。</p>\n<ul>\n<li>名称修改后需检查<code>string.json</code>中对应字符是否存在，字符缺失会导致编译时资源解析错误；</li>\n<li>配置完成后执行模块编译，验证桌面应用名称是否更新；</li>\n<li>全局名称路径：<code>AppScope/resources/base/element/string.json</code><pre><code class=\"language-json\">{\n  \"string\": [\n    {\n      \"name\": \"app_name\",\n      \"value\": \"第一个应用\"\n    }\n  ]\n}\n</code></pre>\n</li>\n</ul>\n<h4 id=\"运行验证\">运行验证</h4>\n<p>将应用运行至真机/模拟器，桌面端应用名称显示为<code>第一个应用</code>，图标为全局配置的层叠样式。</p>\n<p><img alt=\"修改应用名称和图标\" class=\"lazyload\" /></p>\n<h2 id=\"七清理构建hapapp包\">七、清理、构建HAP/APP包</h2>\n<p>鸿蒙工程基于Hvigor构建工具实现模块级编译和全局级构建，<strong>顶部菜单栏Build</strong>为核心操作入口，覆盖「清理-编译-构建-发布」全流程，以下为精准实操和工具说明：</p>\n<h3 id=\"1-清理操作\">1. 清理操作</h3>\n<ul>\n<li>操作：顶部菜单栏<code>Build &gt; Clean Project</code></li>\n<li>功能：删除全工程所有编译相关文件（缓存、临时产物、已生成的包文件等），仅保留源码、配置和资源文件</li>\n<li>作用：解决编译异常、缓存冲突、配置修改不生效等问题，清理完成控制台显示<code>BUILD SUCCESSFUL</code></li>\n</ul>\n<h3 id=\"2-模块编译\">2. 模块编译</h3>\n<p>适用于修改entry模块后快速验证局部效果，仅生成单模块HAP包：</p>\n<ol>\n<li>操作：选中<code>entry</code>文件，点击顶部菜单栏<code>Build &gt; Make Module 'entry'</code></li>\n<li>结果：控制台显示<code>BUILD SUCCESSFUL</code>即为成功，HAP包存放于<code>entry/build/outputs/hap/</code></li>\n<li>作用：快速验证entry模块代码/配置修改效果</li>\n</ol>\n<p><img alt=\"编译entry模块_20260203211239_98_1340\" class=\"lazyload\" /></p>\n<h3 id=\"3-构建完整应用包用于安装分发上架\">3. 构建完整应用包（用于安装/分发/上架）</h3>\n<p>适用于真机/模拟器部署、应用发布上架，整合全模块生成完整.app包：</p>\n<ol>\n<li>操作：顶部菜单栏<code>Build &gt; Build Hap(s)/APP(s) &gt; Build App(s)</code></li>\n<li>结果：控制台显示<code>BUILD SUCCESSFUL</code>即为成功，.app包存放于<code>build/outputs/app/</code>，主模块entry打包产出.hap包</li>\n<li>作用：生成可部署/发布的完整Bundle应用包</li>\n</ol>\n<p><img alt=\"构建应用程序包_20260203211834_100_1340\" class=\"lazyload\" /></p>\n<h3 id=\"4-build菜单核心工具选项全解\">4. Build菜单核心工具选项全解</h3>\n<table>\n<thead>\n<tr>\n<th>选项名称</th>\n<th>核心作用</th>\n<th>典型使用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Make Module 'entry'</td>\n<td>编译entry模块，生成单模块HAP包</td>\n<td>验证entry模块局部修改效果</td>\n</tr>\n<tr>\n<td>Build Hap(s)/APP(s)</td>\n<td>Build Hap(s)：编译单/多模块生成HAP包；Build App(s)：整合全模块生成.app包</td>\n<td>局部调试用Hap(s)；部署/发布用App(s)</td>\n</tr>\n<tr>\n<td>Generate Build Profile 'entry'</td>\n<td>生成entry模块专属编译配置文件</td>\n<td>自定义entry模块编译规则</td>\n</tr>\n<tr>\n<td>Clean Project</td>\n<td>删除全工程所有编译文件，彻底清理缓存</td>\n<td>编译异常、缓存冲突、配置修改不生效</td>\n</tr>\n<tr>\n<td>Rebuild Project</td>\n<td>先执行Clean Project，再全工程重新编译</td>\n<td>清理后仍编译失败、工程长期未编译</td>\n</tr>\n<tr>\n<td>Generate Key and CSR</td>\n<td>生成.p12密钥+CSR文件，用于申请官方发布签名</td>\n<td>应用正式发布上架</td>\n</tr>\n<tr>\n<td>Upload Product</td>\n<td>将正式版.app包上传至华为应用市场后台</td>\n<td>应用提交上架提审</td>\n</tr>\n<tr>\n<td>Build Analyzer</td>\n<td>分析构建耗时、资源占用，定位构建失败原因</td>\n<td>构建速度慢、排查构建失败问题</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"八代码仓库\">八、代码仓库</h2>\n<ul>\n<li>工程名称：FirstApplication</li>\n<li>仓库地址：<a href=\"https://gitee.com/HarmonyOS-UI-Basics/harmony-os-ui-basics.git\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/HarmonyOS-UI-Basics/harmony-os-ui-basics.git</a></li>\n</ul>\n<h2 id=\"九下节预告\">九、下节预告</h2>\n<p>下一节将深入学习 UIAbility 生命周期全解析，核心内容包括：</p>\n<ol>\n<li>UIAbility 全生命周期核心方法的触发时机、核心作用及执行次数约束；</li>\n<li>WindowStage 事件体系与生命周期的联动逻辑，掌握窗口状态（获焦/失焦、前台/后台）的合法监听方式；</li>\n<li><code>onDestroy</code> 方法的特殊触发规则（API 13+一键清理、调试模式、手动调用API等不同场景）；</li>\n<li>页面仅能在 <code>onWindowStageCreate</code> 加载的底层原因及生命周期相关开发避坑要点；</li>\n<li>实操验证启动/前后台切换/关闭等场景下的生命周期执行顺序，掌握关键数据的安全保存策略。</li>\n</ol>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 16:36</span>&nbsp;\n<a href=\"https://www.cnblogs.com/san-xiu\">鸿蒙-散修</a>&nbsp;\n阅读(<span id=\"post_view_count\">89</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MAF快速入门（14）快速集成A2A Agent",
      "link": "https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper14",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper14\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 22:17\">\n    <span>MAF快速入门（14）快速集成A2A Agent</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"MAF快速入门（14）快速集成A2A Agent\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/381412/202602/381412-20260204221255430-336185513.png\" />\n        A2A 即 Agent-to-Agent，翻译过来就是“智能代理之间的协议”，我们可以理解为它就是一个大模型Agent们用来“聊天”的“通用语言”。本文介绍了MAF中集成A2A Agent的核心操作：将A2A Agent转换为AIFunction工具，然后由主Agent自主选择调用一个或多个A2A Agent获取信息整合后最终生成回答。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>大家好，我是Edison。</p>\n<p>最近我一直在跟着圣杰的《<a class=\"normal_text_link mp_article_text_link\" href=\"https://mp.weixin.qq.com/s?__biz=MzA4NzQzNTg4Ng==&amp;mid=2651744458&amp;idx=1&amp;sn=139f7584e81aeecd0945133bdc2b4791&amp;scene=21#wechat_redirect\" rel=\"noopener nofollow\" target=\"_blank\">.NET+AI智能体开发进阶</a>》课程学习MAF开发多智能体工作流，我强烈推荐你也上车跟我一起出发！</p>\n<p><a class=\"normal_text_link mp_article_text_link\" href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper13\" target=\"_blank\"><span>上一篇</span></a><span>，我们学习了MAF中常见的多智能体编排模式<span>。本篇，我们来了解下在MAF中如何快速集成A2A (Agent to Agent)。</span></span></p>\n<h1>1 A2A协议介绍</h1>\n<p>在之前的系列文章中我们其实已经介绍过A2A协议了，这里我们快速温习一下。A2A 即 Agent-to-Agent，翻译过来就是“智能代理之间的协议”，我们可以理解为它就是一个大模型Agent们用来“聊天”的“通用语言”。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202602/381412-20260204220340896-177118451.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>A2A定义了一套清晰、标准的沟通方式，让Agent们可以顺畅地交流，让不同平台和框架下的Agent都能够说“同一种话”，实现无障碍的信息交换和协作。</p>\n<p>更多关于A2A协议的内容：</p>\n<ul>\n<li><strong><strong><span><a class=\"normal_text_link mp_article_text_link\" href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-agent-to-agent-part01\" target=\"_blank\"><span>多Agent协作入门：基于A2A协议的Agent通信（上）</span></a></span></strong></strong></li>\n<li><strong><strong><span><a class=\"normal_text_link mp_article_text_link\" href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-agent-to-agent-part02\" target=\"_blank\"><span>多Agent协作入门：基于A2A协议的Agent通信（中）</span></a></span></strong></strong></li>\n</ul>\n<h1><strong><span>2 将A2A Agent封装为Tool<strong><span><br /></span></strong></span></strong></h1>\n<p>在MAF集成A2A Agent，最主要的操作就是：<strong>将A2A Agent封装为一个Tool</strong>，这个Tool对应到MAF中就是一个<strong>AIFunction</strong>对象。</p>\n<p>前面我们提到可以将MCP服务也封装为一个Tool（AIFunction）让Agent调用，这里A2A Agent也是一样的道理。</p>\n<p>这样做的好处是：<strong>让MAF中的Agent像调用本地函数一样调用远程A2A Agent&nbsp;或 MCP Server</strong>。</p>\n<p>下面的代码展示了在MAF中将A2A Card转换为Agent，然后再将Agent转换为AIFunction：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">......\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> functionTools = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> List&lt;AIFunction&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n</span><span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> endpoint <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> agentEndpoints)\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> resolver = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> A2ACardResolver(<span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> Uri(endpoint));\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> card = <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> resolver.GetAgentCardAsync();\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> agent = card.AsAIAgent(); <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Convert A2A Agent to AIAgent instance</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">\n    functionTools.AddRange(AgentFunctionHelper.CreateFunctionTools(agent, card));\n}\n......</span></pre>\n</div>\n<p>下面是AgentFunctionHelper类的代码实现：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentFunctionHelper\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> IEnumerable&lt;AIFunction&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> CreateFunctionTools(AIAgent a2aAgent, AgentCard agentCard)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> skill <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> agentCard.Skills)\n        {\n            AIFunctionFactoryOptions options </span>= <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\">()\n            {\n                Name </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> Sanitize(skill.Id),\n                Description </span>= $$<span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"\n</span><span style=\"color: rgba(0, 0, 0, 1);\">                {\n                    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">description</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">{{skill.Description}}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">tags</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">[{{string.Join(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">, skill.Tags ?? [])}}]</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">examples</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">[{{string.Join(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">, skill.Examples ?? [])}}]</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">inputModes</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">[{{string.Join(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">, skill.InputModes ?? [])}}]</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">outputModes</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">[{{string.Join(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">, skill.OutputModes ?? [])}}]</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n                }\n                </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">,</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">            };\n\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">yield</span> <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> AIFunctionFactory.Create(RunAgentAsync, options);\n        }\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">async</span> Task&lt;<span style=\"color: rgba(0, 0, 255, 1);\">string</span>&gt; RunAgentAsync(<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> input, CancellationToken cancellationToken)\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> response = <span style=\"color: rgba(0, 0, 255, 1);\">await</span> a2aAgent.RunAsync(input, cancellationToken: cancellationToken).ConfigureAwait(<span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> response.Text;\n        }\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span> Regex InvalidNameCharsRegex = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> Regex(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">[^0-9A-Za-z]+</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, RegexOptions.Compiled);\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> staticstringSanitize(<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> name)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> InvalidNameCharsRegex.Replace(name, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">_</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    }\n}</span></pre>\n</div>\n<p>其中的CreateFunctionTools方法实现了将A2A Agent的所有公开技能转换为AIFunction工具。</p>\n<p><span>而Sanitize方法则实现了函数名称的规范化，因为AIFunction的名称必须符合一定规范（仅限字母、数字和下划线），因此需要主动对技能名称进行规范化。</span></p>\n<h1><strong><strong><span><span>3 完整集成示例</span></span></strong></strong></h1>\n<p><span>这次我们还是使用上次文章中的案例，即一个旅游助手，它可以通过A2A协议调用多个Agent的技能。</span></p>\n<p><img alt=\"image\" height=\"550\" src=\"https://img2024.cnblogs.com/blog/381412/202602/381412-20260204220618986-812169228.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"912\" /></p>\n<p><span><span>我们需要创建四个.NET项目，其中：</span></span></p>\n<ul class=\"list-paddingleft-1\">\n<li>\n<p><span><span>1个.NET控制台项目：主助手</span></span></p>\n</li>\n<li>\n<p><span><span>3个ASP.NET Web项目：天气智能体、酒店智能体、路线智能体</span></span></p>\n</li>\n</ul>\n<p><span>在VS中的项目结构如下：</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202602/381412-20260204220634044-600923620.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>本次案例我们希望实现主助手可以回答用户关于不同主题（景点，酒店，天气）的问题，它可以根据问题自主选择需要调用一个或多个Agent去获取必要的信息后进行整合优化后再回复用户。</p>\n<h3><span><span>3.1 天气Agent</span></span></h3>\n<p><span><span>添加NuGet包，后续A2A Agent项目都需要安装此包，不再赘述：</span></span></p>\n<div class=\"cnblogs_code\">\n<pre>A2A.AspNetCore</pre>\n</div>\n<p>创建一个 WeatherAgent类，定义其能力 和 AgentCard，这里我们需要公开一个AgentSkill即天气查询的能力：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> WeatherAgent\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> Attach(ITaskManager taskManager)\n    {\n        taskManager.OnMessageReceived </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> QueryWeatherAsync;\n        taskManager.OnAgentCardQuery </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> GetAgentCardAsync;\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> Task&lt;A2AResponse&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> QueryWeatherAsync(MessageSendParams messageSendParams, CancellationToken cancellationToken)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (cancellationToken.IsCancellationRequested)\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> Task.FromCanceled&lt;A2AResponse&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(cancellationToken);\n        }\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Process the message</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> messageText = messageSendParams.Message.Parts.OfType&lt;TextPart&gt;<span style=\"color: rgba(0, 0, 0, 1);\">().First().Text;\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Create and return an artifact</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> message = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentMessage()\n        {\n            Role </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> MessageRole.Agent,\n            MessageId </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> Guid.NewGuid().ToString(),\n            ContextId </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> messageSendParams.Message.ContextId,\n            Parts </span>= [<span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> TextPart() {\n                Text </span>= $<span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"\n</span>                    🌤️ **天气查询结果**<span style=\"color: rgba(0, 0, 0, 1);\">\n\n                    查询时间：{DateTime.Now:yyyy</span>-MM-<span style=\"color: rgba(0, 0, 0, 1);\">dd HH:mm}\n\n                    </span>**北京天气**\n                    - 今日：晴转多云，气温 -<span style=\"color: rgba(128, 0, 128, 1);\">2</span>°C ~ <span style=\"color: rgba(128, 0, 128, 1);\">8</span><span style=\"color: rgba(0, 0, 0, 1);\">°C\n                    </span>- 明日：多云，气温 <span style=\"color: rgba(128, 0, 128, 1);\">0</span>°C ~ <span style=\"color: rgba(128, 0, 128, 1);\">10</span><span style=\"color: rgba(0, 0, 0, 1);\">°C\n                    </span>- 后日：阴，气温 <span style=\"color: rgba(128, 0, 128, 1);\">2</span>°C ~ <span style=\"color: rgba(128, 0, 128, 1);\">9</span><span style=\"color: rgba(0, 0, 0, 1);\">°C\n\n                    </span>**上海天气**\n                    - 今日：多云，气温 <span style=\"color: rgba(128, 0, 128, 1);\">5</span>°C ~ <span style=\"color: rgba(128, 0, 128, 1);\">12</span><span style=\"color: rgba(0, 0, 0, 1);\">°C\n                    </span>- 明日：小雨，气温 <span style=\"color: rgba(128, 0, 128, 1);\">6</span>°C ~ <span style=\"color: rgba(128, 0, 128, 1);\">10</span><span style=\"color: rgba(0, 0, 0, 1);\">°C\n                    </span>- 后日：阴转晴，气温 <span style=\"color: rgba(128, 0, 128, 1);\">4</span>°C ~ <span style=\"color: rgba(128, 0, 128, 1);\">11</span><span style=\"color: rgba(0, 0, 0, 1);\">°C\n\n                    👔 穿衣建议：北京较冷，建议穿羽绒服；上海温和，建议穿夹克外套，带好雨具。\n                    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"\n</span><span style=\"color: rgba(0, 0, 0, 1);\">            }]\n        };\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> Task.FromResult&lt;A2AResponse&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(message);\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> Task&lt;AgentCard&gt; GetAgentCardAsync(<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> agentUrl, CancellationToken cancellationToken)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (cancellationToken.IsCancellationRequested)\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> Task.FromCanceled&lt;AgentCard&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(cancellationToken);\n        }\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> capabilities = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentCapabilities()\n        {\n            Streaming </span>= <span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            PushNotifications </span>= <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n        };\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> Task.FromResult(<span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentCard()\n        {\n            Name </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">weather agent</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            Description </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">weather information agent</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            Url </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> agentUrl,\n            Version </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">1.0.0</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            DefaultInputModes </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">text</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n            DefaultOutputModes </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">text</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n            Capabilities </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> capabilities,\n            Skills </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> [\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentSkill\n                {\n                    Id </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">weather-query</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                    Name </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">天气查询</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                    Description </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">查询指定城市的天气预报，包括温度、降水概率、穿衣建议等</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                    Tags </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">weather</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">forecast</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">climate</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n                    Examples </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">上海明天天气怎么样</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">成都这周的天气预报</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">杭州下雨吗</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n                    InputModes </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">text</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n                    OutputModes </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">text</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">]\n                }],\n        });\n    }\n}</span></pre>\n</div>\n<p>这里说明一下，这里为了方便是直接返回了一个固定的天气信息输出内容，但在实际应用中往往需要进行具体的<strong>业务逻辑处理</strong>&nbsp;或&nbsp;<strong>调用大模型</strong>进行处理。</p>\n<p>下面的几个Agent也是类似的情况，就不再赘述。<span>然后，在Program.cs中进行注册，完成端口映射：</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">using</span><span style=\"color: rgba(0, 0, 0, 1);\"> A2A;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">using</span><span style=\"color: rgba(0, 0, 0, 1);\"> A2A.AspNetCore;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">using</span><span style=\"color: rgba(0, 0, 0, 1);\"> WeatherAgentServer;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> builder =<span style=\"color: rgba(0, 0, 0, 1);\"> WebApplication.CreateBuilder(args);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> app =<span style=\"color: rgba(0, 0, 0, 1);\"> builder.Build();\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> taskManager = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> TaskManager();\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> agent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> WeatherAgent();\nagent.Attach(taskManager);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Add JSON-RPC endpoint for A2A</span>\napp.MapA2A(taskManager, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">/weather</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Add well-known agent card endpoint for A2A</span>\napp.MapWellKnownAgentCard(taskManager, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">/weather</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Add HTTP endpoint for A2A</span>\napp.MapHttpA2A(taskManager, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">/weather</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\napp.Run();</span></pre>\n</div>\n<h3><span><span>3.2 酒店Agent</span></span></h3>\n<p><span>创建一个HotelAgent类，定义其能力 和 AgentCard：</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> HotelAgent\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> Attach(ITaskManager taskManager)\n    {\n        taskManager.OnMessageReceived </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> QueryHotelsAsync;\n        taskManager.OnAgentCardQuery </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> GetAgentCardAsync;\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> Task&lt;A2AResponse&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> QueryHotelsAsync(MessageSendParams messageSendParams, CancellationToken cancellationToken)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (cancellationToken.IsCancellationRequested)\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> Task.FromCanceled&lt;A2AResponse&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(cancellationToken);\n        }\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Process the message</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> messageText = messageSendParams.Message.Parts.OfType&lt;TextPart&gt;<span style=\"color: rgba(0, 0, 0, 1);\">().First().Text;\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Create and return an artifact</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> message = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentMessage()\n        {\n            Role </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> MessageRole.Agent,\n            MessageId </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> Guid.NewGuid().ToString(),\n            ContextId </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> messageSendParams.Message.ContextId,\n            Parts </span>= [<span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> TextPart() {\n                Text </span>= $<span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"\n</span>                    🏨 **酒店推荐**<span style=\"color: rgba(0, 0, 0, 1);\">\n\n                    根据您的需求，为您推荐以下酒店：\n\n                    </span>**豪华型 ⭐⭐⭐⭐⭐**\n                    <span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">. 上海外滩华尔道夫酒店\n                       </span>-<span style=\"color: rgba(0, 0, 0, 1);\"> 📍 外滩核心位置，江景房\n                       </span>- 💰 ¥<span style=\"color: rgba(128, 0, 128, 1);\">2</span>,<span style=\"color: rgba(128, 0, 128, 1);\">500</span>/<span style=\"color: rgba(0, 0, 0, 1);\">晚起\n                       </span>- ⭐ 评分 <span style=\"color: rgba(128, 0, 128, 1);\">4.9</span>/<span style=\"color: rgba(128, 0, 128, 1);\">5.0</span>\n\n                    **舒适型 ⭐⭐⭐⭐**\n                    <span style=\"color: rgba(128, 0, 128, 1);\">2</span><span style=\"color: rgba(0, 0, 0, 1);\">. 上海静安香格里拉大酒店\n                       </span>-<span style=\"color: rgba(0, 0, 0, 1);\"> 📍 静安寺商圈，交通便利\n                       </span>- 💰 ¥<span style=\"color: rgba(128, 0, 128, 1);\">1</span>,<span style=\"color: rgba(128, 0, 128, 1);\">200</span>/<span style=\"color: rgba(0, 0, 0, 1);\">晚起\n                       </span>- ⭐ 评分 <span style=\"color: rgba(128, 0, 128, 1);\">4.7</span>/<span style=\"color: rgba(128, 0, 128, 1);\">5.0</span>\n\n                    **经济型 ⭐⭐⭐**\n                    <span style=\"color: rgba(128, 0, 128, 1);\">3</span><span style=\"color: rgba(0, 0, 0, 1);\">. 全季酒店（上海南京路店）\n                       </span>-<span style=\"color: rgba(0, 0, 0, 1);\"> 📍 南京路步行街旁\n                       </span>- 💰 ¥<span style=\"color: rgba(128, 0, 128, 1);\">380</span>/<span style=\"color: rgba(0, 0, 0, 1);\">晚起\n                       </span>- ⭐ 评分 <span style=\"color: rgba(128, 0, 128, 1);\">4.5</span>/<span style=\"color: rgba(128, 0, 128, 1);\">5.0</span><span style=\"color: rgba(0, 0, 0, 1);\">\n\n                    💡 提示：建议提前预订，周末和节假日价格可能上涨 </span><span style=\"color: rgba(128, 0, 128, 1);\">20</span>-<span style=\"color: rgba(128, 0, 128, 1);\">50</span>%<span style=\"color: rgba(0, 0, 0, 1);\">。\n                    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"\n</span><span style=\"color: rgba(0, 0, 0, 1);\">            }]\n        };\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> Task.FromResult&lt;A2AResponse&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(message);\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> Task&lt;AgentCard&gt; GetAgentCardAsync(<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> agentUrl, CancellationToken cancellationToken)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (cancellationToken.IsCancellationRequested)\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> Task.FromCanceled&lt;AgentCard&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(cancellationToken);\n        }\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> capabilities = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentCapabilities()\n        {\n            Streaming </span>= <span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            PushNotifications </span>= <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n        };\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> Task.FromResult(<span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentCard()\n        {\n            Name </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">hotel-a2a-agent</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            Description </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">hotel information agent</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            Url </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> agentUrl,\n            Version </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">1.0.0</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            DefaultInputModes </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">text</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n            DefaultOutputModes </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">text</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n            Capabilities </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> capabilities,\n            Skills </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> [\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentSkill\n                {\n                    Id </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">hotel-recommendation</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                    Name </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">酒店推荐</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                    Description </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">根据目的地和预算推荐合适的酒店，包括豪华型、舒适型、经济型</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                    Tags </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">hotel</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">accommodation</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">booking</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">travel</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n                    Examples </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">推荐上海的酒店</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">上海外滩附近有什么好酒店</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">预算500以内的北京酒店</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n                    InputModes </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">text</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n                    OutputModes </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">text</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">]\n                }\n                ],\n        });\n    }\n}</span></pre>\n</div>\n<p>同样，请参考天气Agent完成Program.cs中的注册。</p>\n<h3><span><span>3.3 景点Agent</span></span></h3>\n<p><span>创建一个PlanAgent类，定义其能力 和 AgentCard：</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> PlanAgent\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> Attach(ITaskManager taskManager)\n    {\n        taskManager.OnMessageReceived </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> QueryPlansAsync;\n        taskManager.OnAgentCardQuery </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> GetAgentCardAsync;\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> Task&lt;A2AResponse&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> QueryPlansAsync(MessageSendParams messageSendParams, CancellationToken cancellationToken)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (cancellationToken.IsCancellationRequested)\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> Task.FromCanceled&lt;A2AResponse&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(cancellationToken);\n        }\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Process the message</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> messageText = messageSendParams.Message.Parts.OfType&lt;TextPart&gt;<span style=\"color: rgba(0, 0, 0, 1);\">().First().Text;\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Create and return an artifact</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> message = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentMessage()\n        {\n            Role </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> MessageRole.Agent,\n            MessageId </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> Guid.NewGuid().ToString(),\n            ContextId </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> messageSendParams.Message.ContextId,\n            Parts </span>= [<span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> TextPart() {\n                Text </span>= $<span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"\n</span>                    🎡 **景点推荐**<span style=\"color: rgba(0, 0, 0, 1);\">\n\n                    为您推荐上海必游景点：\n\n                    </span>**历史文化类**\n                    <span style=\"color: rgba(128, 0, 128, 1);\">1</span>. 🏛️ 外滩 -<span style=\"color: rgba(0, 0, 0, 1);\"> 欣赏万国建筑博览群\n                    </span><span style=\"color: rgba(128, 0, 128, 1);\">2</span>. 🏯 豫园 -<span style=\"color: rgba(0, 0, 0, 1);\"> 江南古典园林代表\n                    </span><span style=\"color: rgba(128, 0, 128, 1);\">3</span>. 🕌 城隍庙 -<span style=\"color: rgba(0, 0, 0, 1);\"> 品尝地道上海小吃\n\n                    </span>**现代都市类**\n                    <span style=\"color: rgba(128, 0, 128, 1);\">4</span>. 🗼 东方明珠塔 -<span style=\"color: rgba(0, 0, 0, 1);\"> 上海地标，俯瞰浦江两岸\n                    </span><span style=\"color: rgba(128, 0, 128, 1);\">5</span>. 🌆 陆家嘴 -<span style=\"color: rgba(0, 0, 0, 1);\"> 金融中心，上海之巅\n                    </span><span style=\"color: rgba(128, 0, 128, 1);\">6</span>. 🛍️ 南京路步行街 -<span style=\"color: rgba(0, 0, 0, 1);\"> 购物天堂\n\n                    </span>**文艺休闲类**\n                    <span style=\"color: rgba(128, 0, 128, 1);\">7</span>. 🎨 田子坊 -<span style=\"color: rgba(0, 0, 0, 1);\"> 文艺小店聚集地\n                    </span><span style=\"color: rgba(128, 0, 128, 1);\">8</span>. 📚 武康路 -<span style=\"color: rgba(0, 0, 0, 1);\"> 梧桐树下的法式风情\n                    </span><span style=\"color: rgba(128, 0, 128, 1);\">9</span>. 🌳 世纪公园 -<span style=\"color: rgba(0, 0, 0, 1);\"> 城市绿肺，亲子游首选\n\n                    📅 建议游玩时间：</span><span style=\"color: rgba(128, 0, 128, 1);\">3</span>-<span style=\"color: rgba(128, 0, 128, 1);\">4</span><span style=\"color: rgba(0, 0, 0, 1);\"> 天可覆盖主要景点\n                    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"\n</span><span style=\"color: rgba(0, 0, 0, 1);\">            }]\n        };\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> Task.FromResult&lt;A2AResponse&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(message);\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> Task&lt;AgentCard&gt; GetAgentCardAsync(<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> agentUrl, CancellationToken cancellationToken)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (cancellationToken.IsCancellationRequested)\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> Task.FromCanceled&lt;AgentCard&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(cancellationToken);\n        }\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> capabilities = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentCapabilities()\n        {\n            Streaming </span>= <span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            PushNotifications </span>= <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n        };\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> Task.FromResult(<span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentCard()\n        {\n            Name </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">plan agent</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            Description </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">travel plan &amp; attraction agent</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            Url </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> agentUrl,\n            Version </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">1.0.0</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            DefaultInputModes </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">text</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n            DefaultOutputModes </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">text</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n            Capabilities </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> capabilities,\n            Skills </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> [\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentSkill\n                {\n                    Id </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">attraction-recommendation</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                    Name </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">景点推荐</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                    Description </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">推荐目的地的热门景点和游玩路线，包括历史文化、现代都市、文艺休闲等类型</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                    Tags </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">attraction</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">sightseeing</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">tourism</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">travel</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n                    Examples </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">上海有什么好玩的</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">北京必去的景点</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">杭州西湖怎么玩</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n                    InputModes </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">text</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">],\n                    OutputModes </span>= [<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">text</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">]\n                }\n                ],\n        });\n    }\n}</span></pre>\n</div>\n<p>同样，请参考天气Agent完成Program.cs中的注册。</p>\n<h3><span><span>3.4 主助手</span></span></h3>\n<p><span><span><span>这里我们暂且命名为TravelPlannerClient，在该项目中我们需要用到<span>MAF<span>，因此我们先安装一下相关NuGet包：</span></span></span></span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">Microsoft.Extensions.AI.OpenAI\nMicrosoft.Agents.AI.A2A\nMicrosoft.Agents.AI.Abstractions\nMicrosoft.Extensions.AI.Abstractions</span></pre>\n</div>\n<p>首先，创建一个ChatClient供主助手使用：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> chatClient = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> OpenAIClient(\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ApiKeyCredential(openAIProvider.ApiKey),\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> OpenAIClientOptions { Endpoint = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> Uri(openAIProvider.Endpoint) })\n    .GetChatClient(openAIProvider.ModelId)\n    .AsIChatClient();</span></pre>\n</div>\n<p>其次，将远程A2A Agents转换为AIFunction Tools：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> agentEndpoints = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\">[]\n{\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">https://localhost:7021/a2a</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> hotel agent </span>\n    <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">https://localhost:7011/a2a</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> weather agent</span>\n    <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">https://localhost:7031/a2a</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> plan agent</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">};\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Collecting all AI Tools</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> functionTools = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> List&lt;AIFunction&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n</span><span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> endpoint <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> agentEndpoints)\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> resolver = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> A2ACardResolver(<span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> Uri(endpoint));\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> card = <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> resolver.GetAgentCardAsync();\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> agent = card.AsAIAgent(); <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Convert A2A Agent to AIAgent instance</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">\n    functionTools.AddRange(AgentFunctionHelper.CreateFunctionTools(agent, card));\n}</span></pre>\n</div>\n<p>然后，创建一个可以调用A2A Agents的主Agent，这一步是核心所在：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> mainAgent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(\n    chatClient: chatClient,\n    instructions: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"\n</span><span style=\"color: rgba(0, 0, 0, 1);\">    你是一个智能旅行规划助手。你可以利用可用的工具来帮助用户完成任务。\n    当用户询问时，请使用合适的工具获取信息，然后回复用户。\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">,</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    tools: [.. functionTools]\n   );</span></pre>\n</div>\n<p>最后，我们可以做下测试：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 用户请求 - 测试不同的技能调用</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> userRequests = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\">[]\n{\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">查询一下上海的天气情况</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">推荐一下上海的酒店</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">帮我规划一下今日上海的一日游景点，并告诉我该如何穿衣服</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n};\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> userRequest <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> userRequests)\n{\n    Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">👤 用户请求: {userRequest}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 执行 Agent</span>\n    Console.WriteLine(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">⏱️ 主 Agent 处理中...</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> response = <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> mainAgent.RunAsync(userRequest);\n    Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">💬 回答:\\n{response.Text}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    Console.WriteLine();\n}</span></pre>\n</div>\n<p>现在，我们来看看测试结果：</p>\n<p><strong><strong><strong><span><span>case1：<span><span>查询一下上海的天气情况（<strong><strong><strong><span><span>简单任务</span></span></strong></strong></strong><span><span>）</span></span></span></span></span></span></strong></strong></strong></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202602/381412-20260204221026757-365275321.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>可以看到，主助手通过调用天气Agent获取天气信息完成了回答。</p>\n<p><span><span><strong><strong><span><span>case2：<span>推荐上海的酒店（简单任务）</span></span></span></strong></strong></span></span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202602/381412-20260204221108758-778672394.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>&nbsp;</p>\n<p><span>可以看到，主助手通过调用酒店Agent获取酒店信息完成了回答</span></p>\n<p><strong><strong><strong><strong><strong><span><span>case3：帮我规划一下今日上海的一日游景点，并告诉我该如何穿衣服<span><span>（复杂任务）</span></span></span></span></strong></strong></strong></strong></strong></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202602/381412-20260204221128267-114288133.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>可以看到，主助手调用了多个Agent（景点Agent 和 天气Agent）获取信息，还在此之上进行了整合优化，最后输出了完善的回复。</p>\n<h1>4 小结</h1>\n<p>本文介绍了MAF中集成A2A Agent的核心操作：将A2A Agent转换为AIFunction工具，然后由主Agent自主选择调用最终生成回答，希望本文的案例对你有所帮助。</p>\n<h1>示例源码</h1>\n<p>GitHub:&nbsp;<a href=\"https://github.com/EdisonTalk/MAFD\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/EdisonTalk/MAFD</a></p>\n<h1>参考资料</h1>\n<p><span><span>圣杰，《<a href=\"https://www.cnblogs.com/sheng-jie/p/19200934\" target=\"_blank\">.NET + AI 智能体开发进阶</a>》（推荐指数：★★★★★）</span></span></p>\n<p><span><span>Microsoft Learn，<span>《<a href=\"https://learn.microsoft.com/en-us/agent-framework/overview/agent-framework-overview?wt.mc_id=MVP_397012\" rel=\"noopener nofollow\" target=\"_blank\">Agent Framework Tutorials</a>》</span></span></span></p>\n<div><span><span>&nbsp;</span></span></div>\n<p style=\"text-align: center;\"><img alt=\"\" src=\"https://images.cnblogs.com/cnblogs_com/edisonchou/1647700/o_200902144330EdisonTalk-Footer.jpg\" /></p>\n<div id=\"Copyright\">\n<p>作者：<span style=\"text-decoration: underline;\">爱迪生</span></p>\n<p>出处：<a href=\"https://edisontalk.cnblogs.com\" target=\"_blank\" title=\"from\">https://edisontalk.cnblogs.com</a></p>\n<p>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。</p>\n</div>\n\n</div>\n<div id=\"MySignature\">\n    <div align=\"center\"><a href=\"https://weibo.com/u/2068032061?s=6uyXnP\" target=\"_blank\"><img border=\"0\" src=\"http://service.t.sina.com.cn/widget/qmd/2068032061/d643d182/10.png\" /></a></div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 22:17</span>&nbsp;\n<a href=\"https://www.cnblogs.com/edisontalk\">EdisonZhou</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}