{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "独立开发者做海外 ai 工具站，全过程技术栈和工具分享！",
      "link": "https://www.cnblogs.com/duyuanshang/p/19445160/toolofseoai",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/duyuanshang/p/19445160/toolofseoai\" id=\"cb_post_title_url\" title=\"发布于 2026-01-06 03:19\">\n    <span>独立开发者做海外 ai 工具站，全过程技术栈和工具分享！</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">目录</div><ul><li><a href=\"#第一点快\" rel=\"noopener nofollow\">第一点、快！</a></li><li><a href=\"#第二点永远做垂直站\" rel=\"noopener nofollow\">第二点、永远做垂直站</a></li><li><a href=\"#第三点经验和技术栈类内容分享\" rel=\"noopener nofollow\">第三点、经验和技术栈类内容分享</a><ul><li><a href=\"#1-平时习惯\" rel=\"noopener nofollow\">1. 平时习惯</a></li><li><a href=\"#11-热点的市场调研呢\" rel=\"noopener nofollow\">1.1 热点的市场调研呢？</a></li><li><a href=\"#2-确定方向\" rel=\"noopener nofollow\">2. 确定方向</a></li><li><a href=\"#3-技术栈\" rel=\"noopener nofollow\">3. 技术栈</a></li><li><a href=\"#4-后台\" rel=\"noopener nofollow\">4. 后台</a></li><li><a href=\"#5-推广和统计\" rel=\"noopener nofollow\">5. 推广和统计</a></li><li><a href=\"#6-登录注册储存等杂项\" rel=\"noopener nofollow\">6. 登录注册、储存等杂项</a></li></ul></li></ul></div><p></p>\n<p>今天我来讲一些关于 AI 与 独立开发者的关键信息。</p>\n<hr />\n<p>我这两年做过很多产品（100% 纯海外站，主要是英文站，因为挣美元），目前产品都处于摇摇欲坠的竞品空窗期或更低，所以暂时不便分享，等建起绝对的壁垒后，我会在博客园专门讲一些。但即便如此，它们依然让我过上不错的收入，但很自由很有活着有希望的状态。</p>\n<p>最开始，2023 年，我不懂太深的技术，就现学现卖，找新词，抢先机，建立了一个 某小众行业的 AI 导航站，风光时间不长，基本没流量。的到了 2024 年，在推特上发觉越来越多人开始搞 Next.js 技术栈，于是就让 ai + 古法手写 做和魔改、收集了几十个免费 Next.js 模板，然后建立独立站吸引流量，显然半斤八两，也还没流量。</p>\n<p>但为我积累了建站经验，2024 年在 哥飞 这个大 V 号里学了 SEO 技巧知识，后来市面上的 AI Agent 越来越好用，，我发现 AI 做东西有复利，我电脑本地的东西，一个领域用完，我修修改改马上就能上线十万八千里的另一个领域，然后就搞了很多.....</p>\n<p>有视频生成、音乐站、虚拟商场、文章语言快速生成、网页复刻神奇、摘要工具、对话套壳.... 一发不可收拾，搞的数量很多，光域名就花了五六千大洋。仅仅是投入时间大于两三个星期的，就有十几个站了。所有站里 95% 都放弃了，都失败了，流量像样的我都改成 Ads 流量主这种展示站了，其余扔球了，目前还在维护的留下了五六个，都比较 OK ，不出意外，能持续细水漫流搞到 AI 红海时代了。</p>\n<p>分享一下经验。</p>\n<h2 id=\"第一点快\">第一点、快！</h2>\n<p>快很重要，迭代速度是唯一竞争力！</p>\n<blockquote>\n<p>在我的职业生涯中，我观察到一个不变的现象是，人们低估了快速行动的必要性。你的项目耗时久并非优点，而是一个缺点。---- 阮一峰周刊 337 期</p>\n</blockquote>\n<p>不要害怕浅尝辄止，成熟的行业才需要长期深耕，<strong>在新兴行业就得首选涉猎广泛 + 极快的开发和迭代。</strong>勇于交付、快速验证。</p>\n<p>现在，每个产品上线，我最多只允许花 2 天时间。外观全给 AI + tailwind CSS 了，因为这个组合基本无需考虑任何地方的 CSS 细调这无意义的时间，因为少了 CSS 这个.... 拖油瓶？！，所以失误率很低。</p>\n<p>上线后，当然没有流量，于是我就评估要不要打磨，打磨一个星期后才开始买外链、填文章内容找长尾巴词、发 raddit 和各种平台打榜、宣传，或者买广告。这个过程很考验 SEO 运维水平，我之前写过很多篇技巧。</p>\n<p>如果一个月都半斤八两，有三五流量就留着承接流量，没有就扔，断舍离！</p>\n<p>当然，我知道快和精，<strong>但只有一个项目和方向，通过了我心里的考验，它才有资格被我搞长期主义。</strong></p>\n<h2 id=\"第二点永远做垂直站\">第二点、永远做垂直站</h2>\n<p>不要碰通用（和chatgpt 一样，没有目标群体，而且所有人全覆盖，谁都能用）！为什么，因为通用是大人物的事情。小人物，只有做很小的某用户群体的工具，举全站之力搞，用即刻平台的某大 V 的话，就是<strong>垂直智能体</strong>。</p>\n<h2 id=\"第三点经验和技术栈类内容分享\">第三点、经验和技术栈类内容分享</h2>\n<h3 id=\"1-平时习惯\">1. 平时习惯</h3>\n<p>我个人平时，会多搜索，互联网任何角落看到 ai 字眼就进去瞧瞧、搜搜。根据经验和工具（一般是单击 Ahrefs 浏览器插件、AITDK 插件、Wappalyzer 插件三者快速看看）预估成功度，然后闭眼深思评估，感觉能去抢点饭的，就收集到 Obsidian 专用目录里。</p>\n<p>每天雷打不动，我至少看一个小时的推特里各大 V 发言。其余时间想起来就去上 ProductHunt 养号，以及简单翻翻我 feedly 里订阅的那一大堆东西。感觉有点用，就收集一下。</p>\n<p>不要关心自己的痛点。自己的痛点，大概率不值钱，因为没有市场已经存在的需求，风险很大，有多大，大到频繁受挫折从未成功的我本人已经 100% 不信任自己的任何创意和判断了，我今天只会抄   （｀へ´） ，..... 甚至已浸透我本人的全局价值观。（除非自己真的太想搞，可以酌情允许自己搞两天。）</p>\n<h3 id=\"11-热点的市场调研呢\">1.1 热点的市场调研呢？</h3>\n<p><strong>新开源项目：</strong>一个突然崛起的新开源项目，做它周边网站，流量也不少，套壳也行。这个隔两三天去 GitHub Trending 逛逛就行。</p>\n<p><strong>大模型市场调研：</strong>去 Hugging Face 的 HF Space 逛各种 demo。这里往往是未来热点的早期实验区！</p>\n<p><strong>新词调研：</strong>去 google trends ，我在我个人网站讲过方法，这里是新词的最终确认处（新开源项目 是否是 新词也可以来这里确认）。分秒必争，一旦确认，拿下，会得到很大一股流量。当然，这里也是全球真实热度的缩略，能获取不少珍贵的商业信息，辅助预测未来热点。</p>\n<p>相关文章： <a href=\"https://www.ccgxk.com/codeother/580.html\" rel=\"noopener nofollow\" target=\"_blank\">https://www.ccgxk.com/codeother/580.html</a></p>\n<p><strong>智能体 Agent 需求调研：</strong>每个垂直的 MCP 服务器都值得去做个对应的 垂直智能体 产品。可以去 mcp.so 和 mcpservers.org 这 2 个地方看看。比较火的 MCP 服务器，<strong>已经帮你验证了已存在的市场需求（这个很重要)</strong>，拿来主义，直接开淦。自己整合供应链，当一个赚差价的中间商。</p>\n<h3 id=\"2-确定方向\">2. 确定方向</h3>\n<p>这个一定要 LLM 辅助的（他们见多识广智商又高，每 1 分钟都强过我 1 星期的所谓的「苦思冥想」），是 Gemini 和 GPT 都用，咨询他们意见，让它们生成一大堆长尾词。</p>\n<p>然后 谷歌、推特、github 三大平台检索原创度、是否占用品牌（尽可能避开品牌、相似发音与拼写，避免律师函警告直接导致前功尽弃）。</p>\n<p>目前 AI 工具站（产品）分 4 种，</p>\n<ol>\n<li>写代码工具</li>\n<li>各种助手插件</li>\n<li>泛用户 智能体（啥都能干）</li>\n<li>垂直 智能体（只会干某特定行业的某事的 Agent）</li>\n</ol>\n<p>我们一般选第 4 种，其他的都是大人物做的，咱们有钱了有经验了再搞。总之，我们的目标就是「砸所有行业的饭碗」，所有行业！</p>\n<p>之后选出大词，注册域名！域名只选择常用的 com io ai app dev org 这种，com 为首选。推荐在 Namecheap 网注册。</p>\n<h3 id=\"3-技术栈\">3. 技术栈</h3>\n<p>初期，不懂网站，这个无所谓，先搞 5 个站，练手熟练了再说。</p>\n<p>（大胆全程 vibe coding ，不要怂！2025 年拜全球绞尽脑汁致力砸自己饭碗的牛马码农所赐，AI Coding 已经全称跑通商业级别编程，且成熟 ，感谢）</p>\n<p>深入的话，只推荐 next.js + TS + React + tailwindCSS，很简单。这个是 AI 最友好的语言。为什么？AI 被投喂训练的编程语言，最多的是 JS ，而 TS 又严谨，编写时会把所有低级错误扫除，react 框架又高度抽象，前后端都在一个项目仓库里，AI 不用猜，之后 AI 创建这类站，准确度很高，大部分事动动嘴皮就行了，生态很全，全流程傻瓜式部署。（如果 next.js 不想用，那 Nuxt 和 Remix  是备用选项）</p>\n<p>而且 next.js 模板很多.... 比如 OpenSaaS、saas-starter... 所以用这个最好了。</p>\n<p>也不用刻意学，只需要用这个框架就行，其余就是动嘴皮子，不需要对它工作原理很了解。</p>\n<p>（当然，你感兴趣的话，可以花 3~5 天研究一下，肯定是越熟悉越好）</p>\n<p>之后，一键部署到 Vercel 。或 cloudflare 里。</p>\n<h3 id=\"4-后台\">4. 后台</h3>\n<p>这个 API 经典的 暴露给上游、下游调用、增删查改。nodejs 。没什么可说的，有可用的模板、现成的开源库，就直接拿来用，没有就自己丢给 AI 让它以最短的代码实现，之后迭代。</p>\n<h3 id=\"5-推广和统计\">5. 推广和统计</h3>\n<p>推广宣传，理应是独立开发唯一的痛点，但这个没法说。初期的测试流量，靠花钱买几百几千点击量的广告 SEM ，稳定流量靠找长尾词和买导航外链各种外链争取 SEO 排名（<strong>一定要服务端渲染</strong>），平时多在任何社交平台传播，盼望好运降临，甚至找中介、找红人营销。</p>\n<p>注意 SEO 是需要长期主义，但是最长也就 6 个月。全力以赴 6 个月，绝大部分工具站需求的关键词，你都可以进入谷歌排名第一页。因为大部分这些词，在谷歌第一页都有乱七八糟的泛流量的无用网站网页用于占位，谷歌心里知道，但谷歌没办法。尤其是 AI 相关的词。只要第一页有无关的论坛、博客文章，你就可以全力以赴花最多最多最多 6 个月拿下。从此，你网站就有了比较稳定的免费和客户精准的自然流量了！</p>\n<p>（除了爆火大词，其余 AI 细分领域，谷歌搜索结果首页几乎都没被填满呢，都是机会）</p>\n<p>流量本身没用，精准的客户定位流量才有用。一天有 100 个，就很棒了。</p>\n<p>花钱买量冲 ProductHunt 榜也可以。打榜后会产生很大的知名度和流量。</p>\n<p>八仙过海、各显神通。尽量少花钱。</p>\n<p>而流量效果，Google Analytics 必备，GSC（Google Search Console）也得。这两个监控。为了保险期间，再加上百度统计，算是备份？！但是百度统计，每次登录都要拿手机扫码.... 很少去看，除非需要对数据。（有人说百度统计会影响海外站速度、触发隐私条款违规，这个大家可以自行判断）。Posthog 和 Umami 也可作为备份。</p>\n<p>然后是 Discord 维护社群，毕竟国外没有 QQ 群。</p>\n<h3 id=\"6-登录注册储存等杂项\">6. 登录注册、储存等杂项</h3>\n<p><strong>大模型 API：</strong>除了生僻或专用模型，使用第三方托管（如 Replicate 、Fal、HF）或自卖 GPU 服务器，可以去 OpenRouter，这里聚合了所有知名大模型。</p>\n<p><strong>登录注册</strong>：没时间、时间急就用 Clerk 这个现成的 SaaS 服务，一键上线（后续要收费的）。需要自建，就用 Auth.js 这个（开源库）。</p>\n<p><strong>数据存取：</strong>推荐 supabase ，把 数据库、登录、文件读存、API 接口等全集成了，而且上手快。当然，也可以试试 neon 。</p>\n<p><strong>界面组件库：</strong>HeroUI、Shadcn、MagicUI 都挺漂亮！</p>\n<p><strong>i18n：</strong>就是多语言国际化。使用 next.js 的好处是，有 next-intl 这个库，对多语言网站很友好。</p>\n<p><strong>收钱：</strong>我们开店，要收钱嘛。有三个主流工具，stripe、creem、lemon squeezy。当然，stripe 是主流，稳定且知名，门槛高点，但抽成低，但需要自己找中介开美国公司，全程大几千元才能开始。新手建议使用 lemon squeezy ，去支付宝申请，去社区办张护照就行，几乎 0 门槛，但抽成高。creem 差不多。</p>\n<p><strong>建站模板：</strong>推荐直接套模板，Vercel.net/templates 、codecanyon.net 、MkSaaS、ShipAny、ShipFast、OpenSaaS、saas-starter..... 很多很多。你是商人，不是科研，造轮子没必要。不要走弯路！</p>\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/duyuanshang/\" target=\"_blank\">独元殇</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/duyuanshang/p/19445160/toolofseoai\" target=\"_blank\">https://www.cnblogs.com/duyuanshang/p/19445160/toolofseoai</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-06 03:19</span>&nbsp;\n<a href=\"https://www.cnblogs.com/duyuanshang\">独元殇</a>&nbsp;\n阅读(<span id=\"post_view_count\">2</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Flink源码阅读：窗口",
      "link": "https://www.cnblogs.com/Jackeyzhe/p/19444937",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Jackeyzhe/p/19444937\" id=\"cb_post_title_url\" title=\"发布于 2026-01-05 22:47\">\n    <span>Flink源码阅读：窗口</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"Flink源码阅读：窗口\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/1828322/202601/1828322-20260105224732284-1871293272.png\" />\n        前文我们梳理了 Watermark 相关的源码，Watermark 的作用就是用来触发窗口，本文我们就一起看一下窗口相关的源码。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>前文我们梳理了 Watermark 相关的源码，Watermark 的作用就是用来触发窗口，本文我们就一起看一下窗口相关的源码。</p>\n<h3 id=\"写在前面\">写在前面</h3>\n<p>在<a href=\"https://jackeyzhe.github.io/2025/07/19/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AA%97%E5%8F%A3/\" rel=\"noopener nofollow\" target=\"_blank\">Flink学习笔记：窗口</a>一文中，我们介绍了窗口的分类以及基本的用法。按照处理数据流的类型划分，Flink 可以分为 Keyed Window 和 Non-Keyed Window，它们的用法如下：</p>\n<pre><code class=\"language-java\">stream\n       .keyBy(...)               &lt;-  仅 keyed 窗口需要\n       .window(...)              &lt;-  必填项：\"assigner\"\n      [.trigger(...)]            &lt;-  可选项：\"trigger\" (省略则使用默认 trigger)\n      [.evictor(...)]            &lt;-  可选项：\"evictor\" (省略则不使用 evictor)\n      [.allowedLateness(...)]    &lt;-  可选项：\"lateness\" (省略则为 0)\n      [.sideOutputLateData(...)] &lt;-  可选项：\"output tag\" (省略则不对迟到数据使用 side output)\n       .reduce/aggregate/apply()      &lt;-  必填项：\"function\"\n      [.getSideOutput(...)]      &lt;-  可选项：\"output tag\"\n\nstream\n       .windowAll(...)           &lt;-  必填项：\"assigner\"\n      [.trigger(...)]            &lt;-  可选项：\"trigger\" (else default trigger)\n      [.evictor(...)]            &lt;-  可选项：\"evictor\" (else no evictor)\n      [.allowedLateness(...)]    &lt;-  可选项：\"lateness\" (else zero)\n      [.sideOutputLateData(...)] &lt;-  可选项：\"output tag\" (else no side output for late data)\n       .reduce/aggregate/apply()      &lt;-  必填项：\"function\"\n      [.getSideOutput(...)]      &lt;-  可选项：\"output tag\"\n</code></pre>\n<p>下面我们根据用法，分别来看两种窗口的源码。</p>\n<h3 id=\"keyed-window\">Keyed Window</h3>\n<p><img alt=\"KeyedWindow\" class=\"lazyload\" /></p>\n<h4 id=\"windowassigner\">WindowAssigner</h4>\n<p>在示例代码中，数据流类型流转过程如图。我们聚焦于 WindowedStream，它是在调用 <code>KeyedStream.window</code> 方法之后生成的。window 方法需要传入一个 WindowAssigner，用来确定一条消息属于哪几个窗口，各个类型的窗口都有不同的实现。</p>\n<p><img alt=\"windowAssigner\" class=\"lazyload\" /></p>\n<p>我们以 TumblingEventTimeWindows 为例，看一下它具体的分配逻辑。</p>\n<pre><code class=\"language-java\">public Collection&lt;TimeWindow&gt; assignWindows(\n        Object element, long timestamp, WindowAssignerContext context) {\n    if (timestamp &gt; Long.MIN_VALUE) {\n        if (staggerOffset == null) {\n            staggerOffset =\n                    windowStagger.getStaggerOffset(context.getCurrentProcessingTime(), size);\n        }\n        // Long.MIN_VALUE is currently assigned when no timestamp is present\n        long start =\n                TimeWindow.getWindowStartWithOffset(\n                        timestamp, (globalOffset + staggerOffset) % size, size);\n        return Collections.singletonList(new TimeWindow(start, start + size));\n    } else {\n        throw new RuntimeException(\n                \"Record has Long.MIN_VALUE timestamp (= no timestamp marker). \"\n                        + \"Did you forget to call 'DataStream.assignTimestampsAndWatermarks(...)'?\");\n    }\n}\n</code></pre>\n<p>这里就是根据消息的 timestamp 来确定窗口的开始和结束时间，然后返回消息所属的窗口。这里还有个 windowStagger 变量，它是窗口触发是否错峰的配置，如果你的任务有成千上万个子任务，同时触发窗口计算带来的瞬时流量可能会对服务器本身和下游造成稳定性的影响，这时就可以通过修改 WindowStagger 配置将流量打散。</p>\n<p>将我们自己定义好的 WindowAssigner 传入 window 方法后，会创建一个 WindowOperatorBuilder，它负责创建一个 WindowOperator 对象，WindowOperator 来执行窗口具体的计算逻辑。</p>\n<pre><code class=\"language-java\">public WindowedStream(KeyedStream&lt;T, K&gt; input, WindowAssigner&lt;? super T, W&gt; windowAssigner) {\n\n    this.input = input;\n    this.isEnableAsyncState = input.isEnableAsyncState();\n\n    this.builder =\n            new WindowOperatorBuilder&lt;&gt;(\n                    windowAssigner,\n                    windowAssigner.getDefaultTrigger(),\n                    input.getExecutionConfig(),\n                    input.getType(),\n                    input.getKeySelector(),\n                    input.getKeyType());\n}\n</code></pre>\n<h4 id=\"trigger\">Trigger</h4>\n<p>有了 WindowOperatorBuilder 之后，我们可以对它进行一些设置，如 trigger、evictor 等，trigger 中提供了一些回调函数，这些回调函数的返回结果 TriggerResult 决定了是否触发窗口计算。</p>\n<pre><code class=\"language-java\">public abstract class Trigger&lt;T, W extends Window&gt; implements Serializable {\n\n    private static final long serialVersionUID = -4104633972991191369L;\n\n    public abstract TriggerResult onElement(T element, long timestamp, W window, TriggerContext ctx)\n            throws Exception;\n\n    public abstract TriggerResult onProcessingTime(long time, W window, TriggerContext ctx)\n            throws Exception;\n\n    public abstract TriggerResult onEventTime(long time, W window, TriggerContext ctx)\n            throws Exception;\n\n    public boolean canMerge() {\n        return false;\n    }\n\n    public void onMerge(W window, OnMergeContext ctx) throws Exception {\n        throw new UnsupportedOperationException(\"This trigger does not support merging.\");\n    }\n\n    public abstract void clear(W window, TriggerContext ctx) throws Exception;\n}\n</code></pre>\n<p>回调函数有三个，分别是 onElement、onProcessingTime、onEventTime，onElement 是在处理每条消息的时候触发，onProcessingTime 和 onEventTime 都是与定时器配合触发，上一篇文章我们提到过，在处理 Watermark 的时候会注册定时器，触发时就会回调这两个方法。</p>\n<p>此外，Trigger 类中还有三个方法，我们简单介绍一下。canMerge 是用来判断窗口是否可以被合并，onMerge 则是在合并窗口时的回调方法。clear 方法用于清除窗口的状态数据。</p>\n<pre><code class=\"language-java\">public enum TriggerResult {\n\n    /** No action is taken on the window. */\n    CONTINUE(false, false),\n\n    /** {@code FIRE_AND_PURGE} evaluates the window function and emits the window result. */\n    FIRE_AND_PURGE(true, true),\n\n    /**\n     * On {@code FIRE}, the window is evaluated and results are emitted. The window is not purged,\n     * though, all elements are retained.\n     */\n    FIRE(true, false),\n\n    /**\n     * All elements in the window are cleared and the window is discarded, without evaluating the\n     * window function or emitting any elements.\n     */\n    PURGE(false, true);\n}\n</code></pre>\n<p>说回 TriggerResult，它有四种枚举：</p>\n<ul>\n<li>\n<p>CONTINUE：什么也不做</p>\n</li>\n<li>\n<p>FIRE_AND_PURGE：触发窗口计算并清除窗口中的元素</p>\n</li>\n<li>\n<p>FIRE：只触发窗口计算</p>\n</li>\n<li>\n<p>PURGE：清除窗口中的元素，不触发计算</p>\n</li>\n</ul>\n<h4 id=\"evictor\">Evictor</h4>\n<p>Evictor 是用来自定义删除窗口中元素的的接口，如果设置了 evictor，WindowOperatorBuilder 就会创建 EvictingWindowOperator。在执行窗口计算逻辑前后，都会调用 evictBefore 和 evictAfter。</p>\n<pre><code class=\"language-java\">private void emitWindowContents(\n        W window, Iterable&lt;StreamRecord&lt;IN&gt;&gt; contents, ListState&lt;StreamRecord&lt;IN&gt;&gt; windowState)\n        throws Exception {\n    ...\n    evictorContext.evictBefore(recordsWithTimestamp, Iterables.size(recordsWithTimestamp));\n\n    FluentIterable&lt;IN&gt; projectedContents =\n            recordsWithTimestamp.transform(\n                    new Function&lt;TimestampedValue&lt;IN&gt;, IN&gt;() {\n                        @Override\n                        public IN apply(TimestampedValue&lt;IN&gt; input) {\n                            return input.getValue();\n                        }\n                    });\n\n    processContext.window = triggerContext.window;\n    userFunction.process(\n            triggerContext.key,\n            triggerContext.window,\n            processContext,\n            projectedContents,\n            timestampedCollector);\n    evictorContext.evictAfter(recordsWithTimestamp, Iterables.size(recordsWithTimestamp));\n    ...\n}\n</code></pre>\n<h4 id=\"allowedlateness--sideoutputlatedata\">allowedLateness &amp; sideOutputLateData</h4>\n<p>allowedLateness 和 sideOutputLateData 都是针对迟到数据的，allowedLateness 是用来指定允许的最大迟到时长，sideOutputLateData 则是将迟到数据输出到指定 outputTag。</p>\n<p>判断是否迟到的方法如下：</p>\n<pre><code class=\"language-java\">protected boolean isElementLate(StreamRecord&lt;IN&gt; element) {\n    return (windowAssigner.isEventTime())\n            &amp;&amp; (element.getTimestamp() + allowedLateness\n                    &lt;= internalTimerService.currentWatermark());\n}\n</code></pre>\n<p>如果是迟到数据，则进行如下处理：</p>\n<pre><code class=\"language-java\">if (isSkippedElement &amp;&amp; isElementLate(element)) {\n    if (lateDataOutputTag != null) {\n        sideOutput(element);\n    } else {\n        this.numLateRecordsDropped.inc();\n    }\n}\n</code></pre>\n<h4 id=\"windowoperator\">WindowOperator</h4>\n<p>设置好 WindowOperatorBuilder 之后，接着就可以调用 process/aggregate/reduce 等方法进行数据计算。</p>\n<p>我们以 process 方法为例，来看下具体的处理逻辑。</p>\n<pre><code class=\"language-java\">public &lt;R&gt; SingleOutputStreamOperator&lt;R&gt; process(\n        ProcessWindowFunction&lt;T, R, K, W&gt; function, TypeInformation&lt;R&gt; resultType) {\n    function = input.getExecutionEnvironment().clean(function);\n\n    final String opName = builder.generateOperatorName();\n    final String opDesc = builder.generateOperatorDescription(function, null);\n\n    OneInputStreamOperator&lt;T, R&gt; operator =\n            isEnableAsyncState ? builder.asyncProcess(function) : builder.process(function);\n\n    return input.transform(opName, resultType, operator).setDescription(opDesc);\n}\n</code></pre>\n<p>在 <code>WindowedStream.process</code> 方法中，就是调用 WindowOperatorBuilder 的 process 方法（如果是异步则调用异步方法）生成 WindowOperator，再将 WindowOperator 加入到执行图中。</p>\n<p>下面我们来看 WindowOperator 中几个重要的方法。</p>\n<h5 id=\"open\">open</h5>\n<p>首先是 open 方法，它主要负责进行初始化，包括创建 timerService，创建 windowState 等。</p>\n<pre><code class=\"language-java\">public void open() throws Exception {\n    super.open();\n\n    this.numLateRecordsDropped = metrics.counter(LATE_ELEMENTS_DROPPED_METRIC_NAME);\n    timestampedCollector = new TimestampedCollector&lt;&gt;(output);\n\n    internalTimerService = getInternalTimerService(\"window-timers\", windowSerializer, this);\n\n    triggerContext = new Context(null, null);\n    processContext = new WindowContext(null);\n\n    windowAssignerContext =\n            new WindowAssigner.WindowAssignerContext() {\n                @Override\n                public long getCurrentProcessingTime() {\n                    return internalTimerService.currentProcessingTime();\n                }\n            };\n\n    // create (or restore) the state that hold the actual window contents\n    // NOTE - the state may be null in the case of the overriding evicting window operator\n    if (windowStateDescriptor != null) {\n        windowState =\n                (InternalAppendingState&lt;K, W, IN, ACC, ACC&gt;)\n                        getOrCreateKeyedState(windowSerializer, windowStateDescriptor);\n    }\n\n    // create the typed and helper states for merging windows\n    if (windowAssigner instanceof MergingWindowAssigner) {\n        ...\n    }\n}\n</code></pre>\n<h5 id=\"processelement\">processElement</h5>\n<p>processElement 是负责处理进入窗口的数据，这里首先调用 <code>WindowAssigner.assignWindows</code> 方法确认元素属于哪些窗口。然后遍历窗口进行处理，包括向 windowState 中添加元素，调用 trigger 的 onElement 方法获取 TriggerResult。如果触发了窗口计算，调用 emitWindowContents 执行计算逻辑。最后是处理迟到数据，我们前面提到过。</p>\n<pre><code class=\"language-java\">public void processElement(StreamRecord&lt;IN&gt; element) throws Exception {\n    final Collection&lt;W&gt; elementWindows =\n            windowAssigner.assignWindows(\n                    element.getValue(), element.getTimestamp(), windowAssignerContext);\n\n    // if element is handled by none of assigned elementWindows\n    boolean isSkippedElement = true;\n\n    final K key = this.&lt;K&gt;getKeyedStateBackend().getCurrentKey();\n\n    if (windowAssigner instanceof MergingWindowAssigner) {\n        ...\n    } else {\n        for (W window : elementWindows) {\n\n            // drop if the window is already late\n            if (isWindowLate(window)) {\n                continue;\n            }\n            isSkippedElement = false;\n\n            windowState.setCurrentNamespace(window);\n            windowState.add(element.getValue());\n\n            triggerContext.key = key;\n            triggerContext.window = window;\n\n            TriggerResult triggerResult = triggerContext.onElement(element);\n\n            if (triggerResult.isFire()) {\n                ACC contents = windowState.get();\n                if (contents != null) {\n                    emitWindowContents(window, contents);\n                }\n            }\n\n            if (triggerResult.isPurge()) {\n                windowState.clear();\n            }\n            registerCleanupTimer(window);\n        }\n    }\n\n    // side output input event if\n    // element not handled by any window\n    // late arriving tag has been set\n    // windowAssigner is event time and current timestamp + allowed lateness no less than\n    // element timestamp\n    if (isSkippedElement &amp;&amp; isElementLate(element)) {\n        if (lateDataOutputTag != null) {\n            sideOutput(element);\n        } else {\n            this.numLateRecordsDropped.inc();\n        }\n    }\n}\n</code></pre>\n<h5 id=\"oneventtime\">onEventTime</h5>\n<p>onEventTime 方法是 eventTime 触发窗口计算时调用的。主要逻辑就是获取 TriggerResult，然后触发计算逻辑，以及对 windowState 的处理。</p>\n<pre><code class=\"language-java\">public void onEventTime(InternalTimer&lt;K, W&gt; timer) throws Exception {\n    triggerContext.key = timer.getKey();\n    triggerContext.window = timer.getNamespace();\n\n    MergingWindowSet&lt;W&gt; mergingWindows;\n\n    if (windowAssigner instanceof MergingWindowAssigner) {\n        mergingWindows = getMergingWindowSet();\n        W stateWindow = mergingWindows.getStateWindow(triggerContext.window);\n        if (stateWindow == null) {\n            // Timer firing for non-existent window, this can only happen if a\n            // trigger did not clean up timers. We have already cleared the merging\n            // window and therefore the Trigger state, however, so nothing to do.\n            return;\n        } else {\n            windowState.setCurrentNamespace(stateWindow);\n        }\n    } else {\n        windowState.setCurrentNamespace(triggerContext.window);\n        mergingWindows = null;\n    }\n\n    TriggerResult triggerResult = triggerContext.onEventTime(timer.getTimestamp());\n\n    if (triggerResult.isFire()) {\n        ACC contents = windowState.get();\n        if (contents != null) {\n            emitWindowContents(triggerContext.window, contents);\n        }\n    }\n\n    if (triggerResult.isPurge()) {\n        windowState.clear();\n    }\n\n    if (windowAssigner.isEventTime()\n            &amp;&amp; isCleanupTime(triggerContext.window, timer.getTimestamp())) {\n        clearAllState(triggerContext.window, windowState, mergingWindows);\n    }\n\n    if (mergingWindows != null) {\n        // need to make sure to update the merging state in state\n        mergingWindows.persist();\n    }\n}\n</code></pre>\n<h5 id=\"onprocessingtime\">onProcessingTime</h5>\n<p>onProcessingTime 和 onEventTime 逻辑基本一致，只是触发条件不同，这里就不再赘述了。</p>\n<p>至此，Keyed Window 从设置到使用的源码我们就梳理完成了，下面再来看另外一种窗口 Non-Keyed Window。</p>\n<h3 id=\"non-keyed-window\">Non-Keyed Window</h3>\n<p><img alt=\"AllWindow\" class=\"lazyload\" /></p>\n<p>我们调用 windowAll 得到 AllWindowedStream，在构造函数中，会给对 input 调用 keyBy 方法，传入 NullByteKeySelector， NullByteKeySelector 对每个 key 都返回0，因此所有的 key 都会被分配到同一个节点。</p>\n<pre><code class=\"language-java\">public class NullByteKeySelector&lt;T&gt; implements KeySelector&lt;T, Byte&gt; {\n\n    private static final long serialVersionUID = 614256539098549020L;\n\n    @Override\n    public Byte getKey(T value) throws Exception {\n        return 0;\n    }\n}\n</code></pre>\n<p>Non-Keyed Window 后续的逻辑都和 Keyed Window 比较类似。</p>\n<h3 id=\"总结\">总结</h3>\n<p>本文我们梳理了窗口相关的源码，几个重点概念包括 WindowAssginer、WindowOperator、Trigger、Evictor。其中 WindowAssigner 是用来确定一条消息属于哪些窗口，WindowOperator 则是窗口计算逻辑的具体执行层。Trigger 和 Evictor 分别用于触发窗口和清理窗口中数据。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-05 22:47</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Jackeyzhe\">Jackeyzhe</a>&nbsp;\n阅读(<span id=\"post_view_count\">2</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": ".NET 传统信息系统无缝集成飞书审批流",
      "link": "https://www.cnblogs.com/mudtools/p/19444914",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/mudtools/p/19444914\" id=\"cb_post_title_url\" title=\"发布于 2026-01-05 22:39\">\n    <span>.NET 传统信息系统无缝集成飞书审批流</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>周末深夜，你收到紧急审批通知——却发现只能在 PC 端处理，只能摸黑起床开电脑……</p>\n</blockquote>\n<p>这样的场景，你是否也经历过？</p>\n<p><strong>传统 .NET 系统与现代移动协同之间的鸿沟，正在悄悄吞噬着企业的效率</strong>。审批卡在桌面端、通知滞后、数据孤岛——这些问题让工作体验大打折扣。</p>\n<p>推倒重来？成本太高，风险太大。</p>\n<p><strong>本文将带你走一条渐进式改造之路</strong>：保持 .NET 系统作为业务核心，将飞书审批作为移动门户，通过 API 实现无缝协同。从原理、设计到编码，完整呈现如何让传统系统焕发新生，实现移动化、实时化的现代化升级。</p>\n<p>无论你是开发者、架构师还是技术管理者，都能收获一套可落地、可扩展的集成方案和直接复用的代码实践。</p>\n<h2 id=\"当传统业务遇上现代协同为何必须破壁\">当传统业务遇上现代协同，为何必须\"破壁\"？</h2>\n<h3 id=\"我们正在解决什么\">我们正在解决什么？</h3>\n<p><strong>传统 .NET 系统的局限</strong></p>\n<p>许多企业拥有多年累积的 .NET 业务系统，这些系统在企业运营中扮演着核心角色。然而，随着移动办公和现代协同工具的普及，这些传统系统正面临着严峻的挑战：</p>\n<table>\n<thead>\n<tr>\n<th>痛点</th>\n<th>具体表现</th>\n<th>业务影响</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>审批流程封闭</strong></td>\n<td>审批只能在桌面端完成，无法随时随地处理</td>\n<td>移动办公受阻，响应迟缓</td>\n</tr>\n<tr>\n<td><strong>通知方式滞后</strong></td>\n<td>依赖邮件或站内消息推送</td>\n<td>审批人及时性差，流程延误</td>\n</tr>\n<tr>\n<td><strong>数据孤岛严重</strong></td>\n<td>审批数据与业务数据分离</td>\n<td>无法形成完整的业务闭环</td>\n</tr>\n<tr>\n<td><strong>用户体验陈旧</strong></td>\n<td>界面风格陈旧，交互体验差</td>\n<td>用户满意度低，使用意愿下降</td>\n</tr>\n</tbody>\n</table>\n<p><strong>飞书审批的赋能价值</strong></p>\n<p>飞书审批作为企业级的审批协作平台，为我们提供了一个理想的\"流程协作中心\"：</p>\n<div class=\"mermaid\">graph LR\n    A[飞书审批平台] --&gt; B[移动优先]\n    A --&gt; C[即时强通知]\n    A --&gt; D[流程可视化]\n    A --&gt; E[完善审计日志]\n\n    B --&gt; B1[随时随地处理审批]\n    C --&gt; C1[App推送/短信提醒]\n    D --&gt; D1[拖拽式流程配置]\n    E --&gt; E1[完整操作痕迹追溯]\n</div><p><strong>我们的核心目标</strong></p>\n<p>通过本文的实践，我们将建立 <strong>\".NET 系统为业务核心，飞书审批为流程门户\"</strong> 的现代化混合架构：</p>\n<blockquote>\n<p><strong>架构愿景</strong>：将飞书审批作为统一的移动审批门户，保持 .NET 系统作为业务逻辑和数据存储的核心，通过 API 实时同步，形成优势互补的协同体系。</p>\n</blockquote>\n<h3 id=\"你将收获什么\">你将收获什么？</h3>\n<ul>\n<li>✅ <strong>一套端到端的集成方法论</strong>，覆盖从原理、设计到部署的全流程</li>\n<li>✅ <strong>清晰的 .NET 侧架构蓝图</strong>，包含关键的技术选型与设计决策</li>\n<li>✅ <strong>可直接复用的 C# 核心代码</strong>与实践中总结的\"避坑指南\"</li>\n<li>✅ <strong>一个完整的\"请假审批\"实战案例</strong>，助你从零到一完成验证</li>\n</ul>\n<hr />\n<h2 id=\"飞书审批开放平台如何与我们对话\">飞书审批开放平台如何与我们\"对话\"？</h2>\n<h3 id=\"双向集成的关键流程\">双向集成的关键流程</h3>\n<p>飞书审批与 .NET 系统的集成是一个<strong>双向数据流</strong>的过程：</p>\n<div class=\"mermaid\">sequenceDiagram\n    participant User as 用户\n    participant NET as .NET系统\n    participant API as 飞书API\n    participant FS as 飞书App\n\n    Note over User,FS: 流程输出：发起审批\n    User-&gt;&gt;NET: 1. 提交请假申请\n    NET-&gt;&gt;NET: 2. 保存业务数据（状态：审批中）\n    NET-&gt;&gt;API: 3. 调用 CreateInstanceAsync\n    API--&gt;&gt;NET: 4. 返回 instance_code\n    NET-&gt;&gt;NET: 5. 关联业务ID与instance_code\n\n    Note over User,FS: 流程输入：回调通知\n    User-&gt;&gt;FS: 6. 在飞书App中审批\n    FS-&gt;&gt;API: 7. 审批完成\n    API-&gt;&gt;NET: 8. Webhook回调事件\n    NET-&gt;&gt;NET: 9. 根据instance_code更新业务状态\n</div><h4 id=\"流程输出发起阶段\">流程输出（发起阶段）</h4>\n<p>当用户在 .NET 系统发起审批时，系统会：</p>\n<ol>\n<li>保存业务数据，状态标记为\"审批中\"</li>\n<li>调用飞书 API <code>CreateInstanceAsync</code> 创建审批实例</li>\n<li>接收返回的 <code>instance_code</code>，持久化到关联表</li>\n</ol>\n<h4 id=\"流程输入回调阶段\">流程输入（回调阶段）</h4>\n<p>当审批人在飞书 App 完成审批后：</p>\n<ol>\n<li>飞书服务器主动回调 .NET 系统的 Webhook 接口</li>\n<li>.NET 系统解析事件，提取 <code>instance_code</code> 和 <code>status</code></li>\n<li>根据关联表查询对应的业务记录</li>\n<li>更新业务状态，完成闭环</li>\n</ol>\n<h3 id=\"必须理解的三个核心概念\">必须理解的三个核心概念</h3>\n<h4 id=\"审批定义approval_code\">审批定义（approval_code）</h4>\n<p><strong>审批定义</strong>是审批流程的\"蓝图\"，在飞书管理后台配置：</p>\n<pre><code class=\"language-csharp\">// 示例：请假审批的审批定义\nvar approvalCode = \"7C468A54-8745-2245-9675-08B7C63E7A85\";\n</code></pre>\n<p><strong>定义包含</strong>：</p>\n<ul>\n<li>表单结构（请假类型、开始时间、结束时间、请假事由等）</li>\n<li>审批流程（直属主管审批 → 人事审批）</li>\n<li>权限设置（谁可以发起、谁可以审批）</li>\n</ul>\n<h4 id=\"审批实例instance_code\">审批实例（instance_code）</h4>\n<p><strong>审批实例</strong>是依据审批定义发起的一次具体审批任务：</p>\n<pre><code class=\"language-csharp\">// 创建审批实例时返回\npublic record CreateInstancesResult\n{\n    /// &lt;summary&gt;\n    /// 审批实例 Code\n    /// &lt;/summary&gt;\n    [JsonPropertyName(\"instance_code\")]\n    public string InstanceCode { get; set; } = string.Empty;\n}\n</code></pre>\n<p><strong>关键属性</strong>：</p>\n<ul>\n<li>唯一标识一次审批流程</li>\n<li>包含该次审批的所有表单数据</li>\n<li>拥有独立的状态（审批中、通过、拒绝、撤回等）</li>\n</ul>\n<h4 id=\"身份映射免登\">身份映射（免登）</h4>\n<p>实现 .NET 系统用户与飞书用户的关联：</p>\n<div class=\"mermaid\">graph LR\n    A[.NET系统用户&lt;br/&gt;UserId: 1001] --&gt;|映射关系| B[飞书用户&lt;br/&gt;OpenId: ou_3cda9c...]\n    B --&gt;|通过飞书App审批| C[审批完成]\n    C --&gt;|回调instance_code| A\n</div><p><strong>实现方式</strong>：</p>\n<ol>\n<li>在 .NET 系统的用户表中添加 <code>FeishuOpenId</code> 字段</li>\n<li>用户首次登录时进行飞书免登录认证，获取并存储 <code>open_id</code></li>\n<li>发起审批时，使用 <code>open_id</code> 指定审批发起人</li>\n</ol>\n<hr />\n<h2 id=\"构建稳健可扩展的-net-侧集成层\">构建稳健、可扩展的 .NET 侧集成层</h2>\n<h3 id=\"技术栈推荐\">技术栈推荐</h3>\n<table>\n<thead>\n<tr>\n<th>层次</th>\n<th>技术选型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>应用框架</strong></td>\n<td>.NET 6/8/10</td>\n<td>长期支持版本，性能优异</td>\n</tr>\n<tr>\n<td><strong>飞书 SDK</strong></td>\n<td>Mud.Feishu</td>\n<td>高度封装的飞书 API 客户端</td>\n</tr>\n<tr>\n<td><strong>Webhook 处理</strong></td>\n<td>Mud.Feishu.Webhook</td>\n<td>飞书事件回调处理组件</td>\n</tr>\n<tr>\n<td><strong>认证授权</strong></td>\n<td>ASP.NET Core Identity / JWT</td>\n<td>内部系统身份管理</td>\n</tr>\n<tr>\n<td><strong>异步解耦</strong></td>\n<td>RabbitMQ / Hangfire</td>\n<td>回调消息队列处理，提升可靠性</td>\n</tr>\n<tr>\n<td><strong>数据存储</strong></td>\n<td>SQL Server / PostgreSQL</td>\n<td>业务数据 + 审批关联表</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"分层架构图\">分层架构图</h3>\n<div class=\"mermaid\">graph TB\n    subgraph \"表示层 (UI)\"\n        A[Web 前端 / 移动端]\n    end\n\n    subgraph \"应用层 (API)\"\n        B[LeaveController]\n        C[FeishuWebhookController]\n    end\n\n    subgraph \"领域层 (业务逻辑)\"\n        D[ILeaveService]\n        E[ApprovalIntegrationService]\n        F[IApprovalService]\n    end\n\n    subgraph \"基础设施层\"\n        G[Mud.Feishu HTTP客户端]\n        H[Mud.Feishu.Webhook处理器]\n        I[数据仓储&lt;br/&gt;EF Core]\n    end\n\n    A --&gt; B\n    A --&gt; C\n    B --&gt; D\n    C --&gt; E\n    D --&gt; F\n    E --&gt; F\n    F --&gt; G\n    F --&gt; H\n    F --&gt; I\n</div><h4 id=\"关键设计领域层抽象\">关键设计：领域层抽象</h4>\n<p>在领域层引入 <code>IApprovalService</code> 接口，将飞书集成细节与核心业务逻辑解耦：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 审批服务抽象接口 - 解耦飞书实现细节\n/// &lt;/summary&gt;\npublic interface IApprovalService\n{\n    /// &lt;summary&gt;\n    /// 发起审批\n    /// &lt;/summary&gt;\n    Task&lt;string&gt; CreateApprovalAsync(ApprovalRequest request);\n\n    /// &lt;summary&gt;\n    /// 处理审批结果回调\n    /// &lt;/summary&gt;\n    Task HandleApprovalCallbackAsync(ApprovalCallbackEvent callbackEvent);\n}\n\n/// &lt;summary&gt;\n/// 飞书审批服务实现\n/// &lt;/summary&gt;\npublic class FeishuApprovalService : IApprovalService\n{\n    private readonly IFeishuTenantV4Approval _approvalApi;\n    private readonly IApprovalRecordRepository _repository;\n\n    public FeishuApprovalService(\n        IFeishuTenantV4Approval approvalApi,\n        IApprovalRecordRepository repository)\n    {\n        _approvalApi = approvalApi;\n        _repository = repository;\n    }\n\n    public async Task&lt;string&gt; CreateApprovalAsync(ApprovalRequest request)\n    {\n        // 调用飞书 API\n        var result = await _approvalApi.CreateInstanceAsync(...);\n        return result.Data?.InstanceCode ?? string.Empty;\n    }\n}\n</code></pre>\n<p><strong>优势</strong>：</p>\n<ul>\n<li>业务逻辑不依赖具体飞书实现</li>\n<li>便于单元测试（可 Mock 接口）</li>\n<li>未来可轻松切换到其他审批平台</li>\n</ul>\n<hr />\n<h2 id=\"实战手把手完成请假审批集成\">实战：手把手完成\"请假审批\"集成</h2>\n<h3 id=\"第一步飞书平台侧配置审批流出口\">第一步：飞书平台侧配置（审批流出口）</h3>\n<h4 id=\"创建企业自建应用\">创建企业自建应用</h4>\n<p>登录飞书开放平台（<a href=\"https://open.feishu.cn\" rel=\"noopener nofollow\" target=\"_blank\">https://open.feishu.cn</a>），进入应用管理：</p>\n<div class=\"mermaid\">graph LR\n    A[创建自建应用] --&gt; B[获取App ID]\n    A --&gt; C[获取App Secret]\n    B --&gt; D[配置到.NET系统]\n    C --&gt; D\n</div><p><strong>关键配置</strong>：</p>\n<ul>\n<li>记录 <code>App ID</code> 和 <code>App Secret</code></li>\n<li>配置应用权限：审批相关权限（<code>approval:approval:read</code>, <code>approval:instance:read</code>, <code>approval:instance:create</code>）</li>\n</ul>\n<h4 id=\"配置审批定义\">配置审批定义</h4>\n<p>在飞书管理后台创建\"请假审批\"模板：</p>\n<div class=\"mermaid\">graph LR\n    A[审批定义配置] --&gt; B[表单设置]\n    A --&gt; C[流程设置]\n    A --&gt; D[权限设置]\n\n    B --&gt; B1[请假类型&lt;br/&gt;开始时间&lt;br/&gt;结束时间&lt;br/&gt;请假天数&lt;br/&gt;请假事由]\n    C --&gt; C1[直属主管审批&lt;br/&gt;→ 人事审批]\n    D --&gt; D1[全员可发起]\n</div><p><strong>记录关键信息</strong>：</p>\n<ul>\n<li><code>approval_code</code>：审批定义的唯一标识</li>\n<li>表单控件的 <code>id</code>：用于程序填充表单数据</li>\n</ul>\n<h4 id=\"配置事件订阅\">配置事件订阅</h4>\n<p>在飞书开放平台配置 Webhook：</p>\n<table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>请求网址</td>\n<td><code>https://your-domain.com/api/feishu/webhook</code></td>\n</tr>\n<tr>\n<td>验证 Token</td>\n<td><code>your_verification_token</code>（自定义）</td>\n</tr>\n<tr>\n<td>加密 Key</td>\n<td><code>your_encrypt_key</code>（自定义）</td>\n</tr>\n<tr>\n<td>订阅事件</td>\n<td><code>approval_instance</code>（审批实例状态变更）</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h3 id=\"第二步net-侧基础搭建集成基石\">第二步：.NET 侧基础搭建（集成基石）</h3>\n<h4 id=\"封装飞书-api-客户端\">封装飞书 API 客户端</h4>\n<p>基于 <code>MudFeishu SDK</code> 封装审批服务：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 飞书审批服务封装\n/// &lt;/summary&gt;\npublic class FeishuApprovalClient\n{\n    private readonly IFeishuTenantV4Approval _approvalApi;\n    private readonly ILogger&lt;FeishuApprovalClient&gt; _logger;\n\n    public FeishuApprovalClient(\n        IFeishuTenantV4Approval approvalApi,\n        ILogger&lt;FeishuApprovalClient&gt; logger)\n    {\n        _approvalApi = approvalApi;\n        _logger = logger;\n    }\n\n    /// &lt;summary&gt;\n    /// 创建审批实例\n    /// &lt;/summary&gt;\n    public async Task&lt;string&gt; CreateInstanceAsync(CreateInstanceRequest request)\n    {\n        var result = await _approvalApi.CreateInstanceAsync(request);\n\n        if (result == null || result.Code != 0)\n        {\n            _logger.LogError(\"创建审批实例失败: {Msg}\", result?.Msg);\n            throw new InvalidOperationException($\"创建审批实例失败: {result?.Msg}\");\n        }\n\n        _logger.LogInformation(\"创建审批实例成功: {InstanceCode}\", result.Data?.InstanceCode);\n        return result.Data?.InstanceCode ?? string.Empty;\n    }\n\n    /// &lt;summary&gt;\n    /// 获取审批实例详情\n    /// &lt;/summary&gt;\n    public async Task&lt;GetApprovalInstanceResult?&gt; GetInstanceAsync(string instanceCode)\n    {\n        var result = await _approvalApi.GetInstanceByIdAsync(instanceCode);\n\n        if (result == null || result.Code != 0)\n        {\n            _logger.LogError(\"获取审批实例失败: {Msg}\", result?.Msg);\n            return null;\n        }\n\n        return result.Data;\n    }\n}\n</code></pre>\n<h4 id=\"设计数据关联表\">设计数据关联表</h4>\n<p>在业务数据库中添加审批关联表：</p>\n<pre><code class=\"language-sql\">-- 审批关联表\nCREATE TABLE ApprovalRecords (\n    Id BIGINT PRIMARY KEY IDENTITY(1,1),\n    BusinessType NVARCHAR(50) NOT NULL,          -- 业务类型：LeaveRequest, PurchaseRequest...\n    BusinessId BIGINT NOT NULL,                   -- 业务ID\n    InstanceCode NVARCHAR(64) NOT NULL,           -- 飞书审批实例Code\n    ApprovalCode NVARCHAR(64) NOT NULL,            -- 审批定义Code\n    Status NVARCHAR(20) NOT NULL,                  -- 状态：PENDING, APPROVED, REJECTED...\n    CallbackData NVARCHAR(MAX),                   -- 回调数据（JSON）\n    CreatedTime DATETIME2 NOT NULL DEFAULT GETUTCDATE(),\n    UpdatedTime DATETIME2 NOT NULL DEFAULT GETUTCDATE(),\n\n    CONSTRAINT UK_ApprovalRecords_Business UNIQUE(BusinessType, BusinessId)\n);\n\nCREATE INDEX IX_ApprovalRecords_InstanceCode ON ApprovalRecords(InstanceCode);\nCREATE INDEX IX_ApprovalRecords_Status ON ApprovalRecords(Status);\n</code></pre>\n<p>对应的实体类：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 审批关联记录\n/// &lt;/summary&gt;\npublic class ApprovalRecord\n{\n    public long Id { get; set; }\n    public string BusinessType { get; set; } = string.Empty;  // \"LeaveRequest\"\n    public long BusinessId { get; set; }                       // 请假申请ID\n    public string InstanceCode { get; set; } = string.Empty;   // 飞书实例Code\n    public string ApprovalCode { get; set; } = string.Empty;    // 审批定义Code\n    public string Status { get; set; } = string.Empty;         // PENDING/APPROVED/REJECTED\n    public string? CallbackData { get; set; }                  // JSON格式\n    public DateTime CreatedTime { get; set; }\n    public DateTime UpdatedTime { get; set; }\n}\n</code></pre>\n<hr />\n<h3 id=\"第三步核心业务流程编码双向联通\">第三步：核心业务流程编码（双向联通）</h3>\n<h4 id=\"场景用户提交请假单发起审批\">场景：用户提交请假单，发起审批</h4>\n<p><strong>流程图</strong>：</p>\n<div class=\"mermaid\">sequenceDiagram\n    participant User as 用户\n    participant Controller as LeaveController\n    participant Service as LeaveService\n    participant DB as 数据库\n    participant FeishuAPI as 飞书API\n\n    User-&gt;&gt;Controller: 提交请假申请\n    Controller-&gt;&gt;Service: SubmitLeaveRequest(request)\n    Service-&gt;&gt;DB: 保存请假记录（状态：审批中）\n    Service-&gt;&gt;Service: 构造表单数据\n    Service-&gt;&gt;FeishuAPI: CreateInstanceAsync(approvalCode, form)\n    FeishuAPI--&gt;&gt;Service: instance_code\n    Service-&gt;&gt;DB: 保存ApprovalRecord关联\n    Service--&gt;&gt;Controller: 提交成功\n    Controller--&gt;&gt;User: 等待审批\n</div><p><strong>代码实现</strong>：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 请假服务\n/// &lt;/summary&gt;\npublic class LeaveService\n{\n    private readonly ILeaveRequestRepository _leaveRepo;\n    private readonly IApprovalRecordRepository _approvalRepo;\n    private readonly FeishuApprovalClient _feishuClient;\n    private readonly ILogger&lt;LeaveService&gt; _logger;\n\n    public LeaveService(\n        ILeaveRequestRepository leaveRepo,\n        IApprovalRecordRepository approvalRepo,\n        FeishuApprovalClient feishuClient,\n        ILogger&lt;LeaveService&gt; logger)\n    {\n        _leaveRepo = leaveRepo;\n        _approvalRepo = approvalRepo;\n        _feishuClient = feishuClient;\n        _logger = logger;\n    }\n\n    /// &lt;summary&gt;\n    /// 提交请假申请并发起审批\n    /// &lt;/summary&gt;\n    public async Task&lt;long&gt; SubmitLeaveRequestAsync(SubmitLeaveRequestDto dto)\n    {\n        // 1. 保存请假业务数据\n        var leaveRequest = new LeaveRequest\n        {\n            UserId = dto.UserId,\n            LeaveType = dto.LeaveType,\n            StartTime = dto.StartTime,\n            EndTime = dto.EndTime,\n            Days = dto.Days,\n            Reason = dto.Reason,\n            Status = LeaveStatus.Pending,  // 审批中\n            CreatedTime = DateTime.UtcNow\n        };\n\n        await _leaveRepo.AddAsync(leaveRequest);\n        await _leaveRepo.SaveChangesAsync();\n\n        // 2. 构造飞书审批表单数据\n        var form = new List&lt;object&gt;\n        {\n            new { id = \"leave_type\", type = \"select\", value = dto.LeaveType },\n            new { id = \"start_time\", type = \"date\", value = dto.StartTime.ToString(\"yyyy-MM-dd\") },\n            new { id = \"end_time\", type = \"date\", value = dto.EndTime.ToString(\"yyyy-MM-dd\") },\n            new { id = \"days\", type = \"number\", value = dto.Days.ToString() },\n            new { id = \"reason\", type = \"textarea\", value = dto.Reason }\n        };\n\n        // 3. 调用飞书API创建审批实例\n        var request = new CreateInstanceRequest\n        {\n            ApprovalCode = \"7C468A54-8745-2245-9675-08B7C63E7A85\",  // 请假审批定义Code\n            UserId = dto.FeishuUserId,  // 飞书用户ID\n            Form = JsonSerializer.Serialize(form),\n            Uuid = Guid.NewGuid().ToString()  // 幂等ID\n        };\n\n        string instanceCode;\n        try\n        {\n            instanceCode = await _feishuClient.CreateInstanceAsync(request);\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"创建飞书审批实例失败\");\n            // 回滚业务数据\n            leaveRequest.Status = LeaveStatus.Failed;\n            await _leaveRepo.SaveChangesAsync();\n            throw;\n        }\n\n        // 4. 保存审批关联记录\n        var approvalRecord = new ApprovalRecord\n        {\n            BusinessType = \"LeaveRequest\",\n            BusinessId = leaveRequest.Id,\n            InstanceCode = instanceCode,\n            ApprovalCode = request.ApprovalCode,\n            Status = \"PENDING\",\n            CreatedTime = DateTime.UtcNow,\n            UpdatedTime = DateTime.UtcNow\n        };\n\n        await _approvalRepo.AddAsync(approvalRecord);\n        await _approvalRepo.SaveChangesAsync();\n\n        _logger.LogInformation(\"请假申请已提交并创建审批: LeaveId={LeaveId}, InstanceCode={InstanceCode}\",\n            leaveRequest.Id, instanceCode);\n\n        return leaveRequest.Id;\n    }\n}\n</code></pre>\n<h4 id=\"场景审批完结飞书回调通知结果\">场景：审批完结，飞书回调通知结果</h4>\n<p><strong>基于 Mud.Feishu.Webhook 实现安全的回调处理器</strong></p>\n<pre><code class=\"language-csharp\">using Mud.Feishu.Abstractions;\nusing Mud.Feishu.Abstractions.DataModels.Approval;\nusing Mud.Feishu.Abstractions.EventHandlers;\n\n/// &lt;summary&gt;\n/// 审批实例事件处理器\n/// &lt;/summary&gt;\npublic class ApprovalInstanceEventHandler : ApprovalInstanceEventHandler\n{\n    private readonly IApprovalRecordRepository _approvalRepo;\n    private readonly ILeaveRequestRepository _leaveRepo;\n\n    public ApprovalInstanceEventHandler(\n        ILogger&lt;ApprovalInstanceEventHandler&gt; logger,\n        IApprovalRecordRepository approvalRepo,\n        ILeaveRequestRepository leaveRepo)\n        : base(logger)\n    {\n        _approvalRepo = approvalRepo;\n        _leaveRepo = leaveRepo;\n    }\n\n    /// &lt;summary&gt;\n    /// 处理审批实例事件业务逻辑\n    /// &lt;/summary&gt;\n    protected override async Task ProcessBusinessLogicAsync(\n        EventData eventData,\n        ObjectEventResult&lt;ApprovalInstanceResult&gt;? eventEntity,\n        CancellationToken cancellationToken = default)\n    {\n        if (eventEntity?.Object == null)\n        {\n            _logger.LogWarning(\"审批实例事件数据无效\");\n            return;\n        }\n\n        var approvalEvent = eventEntity.Object;\n\n        _logger.LogInformation(\"收到审批实例事件: InstanceCode={InstanceCode}, Status={Status}\",\n            approvalEvent.InstanceCode, approvalEvent.Status);\n\n        // 幂等性处理：检查是否已处理过该事件\n        var existingRecord = await _approvalRepo.GetByInstanceCodeAsync(approvalEvent.InstanceCode ?? string.Empty);\n        if (existingRecord != null &amp;&amp; existingRecord.Status == approvalEvent.Status)\n        {\n            _logger.LogInformation(\"该事件已处理过，跳过: EventId={EventId}\", eventData.EventId);\n            return;\n        }\n\n        // 根据业务类型处理审批结果\n        await ProcessApprovalResultAsync(eventData, approvalEvent, cancellationToken);\n    }\n\n    /// &lt;summary&gt;\n    /// 处理审批结果\n    /// &lt;/summary&gt;\n    private async Task ProcessApprovalResultAsync(\n        EventData eventData,\n        ApprovalInstanceResult approvalEvent,\n        CancellationToken cancellationToken)\n    {\n        if (string.IsNullOrEmpty(approvalEvent.InstanceCode))\n        {\n            _logger.LogWarning(\"审批实例Code为空，跳过处理\");\n            return;\n        }\n\n        // 查询审批关联记录\n        var approvalRecord = await _approvalRepo.GetByInstanceCodeAsync(approvalEvent.InstanceCode);\n        if (approvalRecord == null)\n        {\n            _logger.LogWarning(\"未找到审批关联记录: InstanceCode={InstanceCode}\",\n                approvalEvent.InstanceCode);\n            return;\n        }\n\n        // 更新审批记录状态\n        approvalRecord.Status = approvalEvent.Status ?? string.Empty;\n        approvalRecord.CallbackData = JsonSerializer.Serialize(approvalEvent);\n        approvalRecord.UpdatedTime = DateTime.UtcNow;\n        await _approvalRepo.SaveChangesAsync();\n\n        // 根据业务类型处理\n        switch (approvalRecord.BusinessType)\n        {\n            case \"LeaveRequest\":\n                await ProcessLeaveApprovalAsync(approvalRecord, approvalEvent.Status ?? string.Empty);\n                break;\n\n            // 可扩展其他业务类型\n            default:\n                _logger.LogWarning(\"未知的业务类型: {BusinessType}\", approvalRecord.BusinessType);\n                break;\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// 处理请假审批结果\n    /// &lt;/summary&gt;\n    private async Task ProcessLeaveApprovalAsync(ApprovalRecord approvalRecord, string status)\n    {\n        var leaveRequest = await _leaveRepo.GetByIdAsync(approvalRecord.BusinessId);\n        if (leaveRequest == null)\n        {\n            _logger.LogWarning(\"未找到请假申请: BusinessId={BusinessId}\", approvalRecord.BusinessId);\n            return;\n        }\n\n        // 根据审批状态更新请假记录\n        leaveRequest.Status = status switch\n        {\n            \"APPROVED\" =&gt; LeaveStatus.Approved,\n            \"REJECTED\" =&gt; LeaveStatus.Rejected,\n            \"CANCELED\" =&gt; LeaveStatus.Canceled,\n            \"DELETED\" =&gt; LeaveStatus.Deleted,\n            _ =&gt; LeaveStatus.Pending\n        };\n\n        leaveRequest.UpdatedTime = DateTime.UtcNow;\n        await _leaveRepo.SaveChangesAsync();\n\n        _logger.LogInformation(\"请假申请状态已更新: LeaveId={LeaveId}, Status={Status}\",\n            leaveRequest.Id, leaveRequest.Status);\n\n        // TODO: 发送通知给申请人\n        // TODO: 同步到考勤系统\n    }\n}\n</code></pre>\n<p><strong>注册 Webhook 服务（Program.cs）</strong>：</p>\n<pre><code class=\"language-csharp\">using Mud.Feishu.Webhook;\nusing Mud.Feishu;\nusing YourApp.Handlers;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// 注册飞书 API 服务\nbuilder.Services.AddFeishuServices()\n    .ConfigureFrom(builder.Configuration)  // 从 \"Feishu\" 配置节读取\n    .Build();\n\n// 注册飞书 Webhook 事件订阅服务\nbuilder.Services.AddFeishuWebhookServiceBuilder()\n    .ConfigureFrom(builder.Configuration)  // 从 \"FeishuWebhook\" 配置节读取\n    .AddHandler&lt;ApprovalInstanceEventHandler&gt;()  // 添加审批事件处理器\n    .Build();\n\n// 注册业务服务\nbuilder.Services.AddScoped&lt;ILeaveRequestRepository, LeaveRequestRepository&gt;();\nbuilder.Services.AddScoped&lt;IApprovalRecordRepository, ApprovalRecordRepository&gt;();\n\nvar app = builder.Build();\n\napp.UseFeishuWebhook();  // 添加 Webhook 中间件\n\napp.Run();\n</code></pre>\n<p><strong>说明</strong>：</p>\n<ul>\n<li><code>ApprovalInstanceEventHandler</code> 继承自 <code>ApprovalInstanceEventHandler</code> 基类</li>\n<li>基类已经实现了 <code>HandleAsync</code> 方法，会自动反序列化 <code>ApprovalInstanceResult</code> 类型的事件数据</li>\n<li>只需重写 <code>ProcessBusinessLogicAsync</code> 方法实现具体的业务逻辑即可</li>\n<li>SDK 会根据 <code>SupportedEventType</code> 属性自动路由对应的事件到这个处理器</li>\n<li><code>AddFeishuServices()</code> 注册飞书 API 客户端服务，使用 <code>Feishu</code> 配置节</li>\n<li><code>AddFeishuWebhookServiceBuilder()</code> 注册 Webhook 事件订阅服务，使用 <code>FeishuWebhook</code> 配置节</li>\n</ul>\n<p><strong>配置文件（appsettings.json）</strong>：</p>\n<pre><code class=\"language-json\">{\n  // 飞书 Webhook 事件订阅配置\n  \"FeishuWebhook\": {\n    \"VerificationToken\": \"your_verification_token\",\n    \"EncryptKey\": \"your_encrypt_key\",\n    \"RoutePrefix\": \"api/feishu/webhook\",\n    \"AutoRegisterEndpoint\": true,\n    \"EnableRequestLogging\": true,\n    \"EnableExceptionHandling\": true,\n    \"EventHandlingTimeoutMs\": 30000,\n    \"MaxConcurrentEvents\": 10\n  },\n\n  // 飞书 API 客户端配置\n  \"Feishu\": {\n    \"AppId\": \"your_app_id\",\n    \"AppSecret\": \"your_app_secret\",\n    \"BaseUrl\": \"https://open.feishu.cn\",\n    \"TimeOut\": \"30\",\n    \"RetryCount\": 3,\n    \"EnableLogging\": true\n  }\n}\n</code></pre>\n<hr />\n<h3 id=\"第四步功能完善与联调测试\">第四步：功能完善与联调测试</h3>\n<h4 id=\"状态同步展示\">状态同步展示</h4>\n<p>在请假列表页展示审批状态：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 请假列表响应DTO\n/// &lt;/summary&gt;\npublic class LeaveRequestDto\n{\n    public long Id { get; set; }\n    public DateTime StartTime { get; set; }\n    public DateTime EndTime { get; set; }\n    public int Days { get; set; }\n    public string Status { get; set; } = string.Empty;      // 业务状态：Approved, Rejected\n    public string ApprovalStatus { get; set; } = string.Empty; // 飞书审批状态：APPROVED, REJECTED, PENDING\n    public string? FeishuInstanceUrl { get; set; }          // 飞书审批详情链接\n    public DateTime CreatedTime { get; set; }\n}\n\n/// &lt;summary&gt;\n/// 查询请假列表\n/// &lt;/summary&gt;\npublic async Task&lt;List&lt;LeaveRequestDto&gt;&gt; GetLeaveListAsync(long userId)\n{\n    var leaves = await _leaveRepo.GetByUserIdAsync(userId);\n    var instanceCodes = leaves.Select(l =&gt; l.InstanceCode).ToList();\n\n    // 批量查询审批记录\n    var approvals = await _approvalRepo.GetByInstanceCodesAsync(instanceCodes);\n\n    var result = leaves.Select(leave =&gt;\n    {\n        var approval = approvals.FirstOrDefault(a =&gt; a.InstanceCode == leave.InstanceCode);\n\n        return new LeaveRequestDto\n        {\n            Id = leave.Id,\n            StartTime = leave.StartTime,\n            EndTime = leave.EndTime,\n            Days = leave.Days,\n            Status = leave.Status.ToString(),\n            ApprovalStatus = approval?.Status ?? \"UNKNOWN\",\n            FeishuInstanceUrl = !string.IsNullOrEmpty(approval?.InstanceCode)\n                ? $\"https://www.feishu.cn/approval/approval/view/{approval.InstanceCode}\"\n                : null,\n            CreatedTime = leave.CreatedTime\n        };\n    }).ToList();\n\n    return result;\n}\n</code></pre>\n<h4 id=\"添加在飞书中查看链接\">添加\"在飞书中查看\"链接</h4>\n<p>在列表页添加操作按钮：</p>\n<pre><code class=\"language-html\">&lt;!-- 前端页面示例 --&gt;\n&lt;table class=\"leave-list\"&gt;\n    &lt;thead&gt;\n        &lt;tr&gt;\n            &lt;th&gt;开始时间&lt;/th&gt;\n            &lt;th&gt;结束时间&lt;/th&gt;\n            &lt;th&gt;天数&lt;/th&gt;\n            &lt;th&gt;审批状态&lt;/th&gt;\n            &lt;th&gt;操作&lt;/th&gt;\n        &lt;/tr&gt;\n    &lt;/thead&gt;\n    &lt;tbody&gt;\n        @foreach (var leave in Model.Leaves)\n        {\n            &lt;tr&gt;\n                &lt;td&gt;@leave.StartTime.ToString(\"yyyy-MM-dd\")&lt;/td&gt;\n                &lt;td&gt;@leave.EndTime.ToString(\"yyyy-MM-dd\")&lt;/td&gt;\n                &lt;td&gt;@leave.Days&lt;/td&gt;\n                &lt;td&gt;\n                    &lt;span class=\"status @leave.ApprovalStatus\"&gt;\n                        @GetStatusText(leave.ApprovalStatus)\n                    &lt;/span&gt;\n                &lt;/td&gt;\n                &lt;td&gt;\n                    @if (!string.IsNullOrEmpty(leave.FeishuInstanceUrl))\n                    {\n                        &lt;a href=\"@leave.FeishuInstanceUrl\" target=\"_blank\" class=\"btn\"&gt;\n                            在飞书中查看\n                        &lt;/a&gt;\n                    }\n                &lt;/td&gt;\n            &lt;/tr&gt;\n        }\n    &lt;/tbody&gt;\n&lt;/table&gt;\n</code></pre>\n<h4 id=\"联调测试\">联调测试</h4>\n<table>\n<thead>\n<tr>\n<th>测试场景</th>\n<th>验证要点</th>\n<th>测试工具</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>发起审批</strong></td>\n<td>飞书是否收到审批通知、表单数据是否正确</td>\n<td>直接在系统发起</td>\n</tr>\n<tr>\n<td><strong>审批流程</strong></td>\n<td>各审批节点是否正确流转</td>\n<td>飞书管理后台</td>\n</tr>\n<tr>\n<td><strong>回调接收</strong></td>\n<td>Webhook是否正确接收事件、数据是否完整</td>\n<td>飞书\"模拟事件推送\"工具</td>\n</tr>\n<tr>\n<td><strong>状态同步</strong></td>\n<td>业务状态是否正确更新、通知是否发送</td>\n<td>数据库查询、日志查看</td>\n</tr>\n<tr>\n<td><strong>异常处理</strong></td>\n<td>网络异常、签名验证失败等边界情况</td>\n<td>模拟异常场景</td>\n</tr>\n</tbody>\n</table>\n<p><strong>飞书模拟事件推送工具</strong>：</p>\n<p>在飞书开放平台的\"事件订阅\"页面，可以使用\"模拟事件推送\"功能测试 Webhook 接口：</p>\n<div class=\"mermaid\">graph LR\n    A[飞书管理后台] --&gt;|模拟事件推送| B[Webhook接口]\n    B --&gt;|日志输出| C[检查处理结果]\n    C --&gt;|成功| D[验证完成]\n    C --&gt;|失败| E[查看错误日志]\n</div><hr />\n<h2 id=\"生产级注意事项\">生产级注意事项</h2>\n<h3 id=\"安全与可靠性\">安全与可靠性</h3>\n<h4 id=\"机密管理\">机密管理</h4>\n<p><strong>切勿将敏感信息硬编码在代码中！</strong></p>\n<pre><code class=\"language-csharp\">// ❌ 错误示例\nvar appSecret = \"cli_xxxxxxxxxxxxxxx\";  // 危险！\n\n// ✅ 正确示例\nbuilder.Configuration.AddAzureKeyVault(\n    new Uri($\"https://{vaultName}.vault.azure.net/\"),\n    new DefaultAzureCredential());\n\nvar appSecret = builder.Configuration[\"Feishu:AppSecret\"];\n</code></pre>\n<p><strong>推荐方案</strong>：</p>\n<ul>\n<li>Azure Key Vault / AWS Secrets Manager</li>\n<li>HashiCorp Vault</li>\n<li>Docker Secrets（容器化部署）</li>\n</ul>\n<h4 id=\"幂等性处理\">幂等性处理</h4>\n<p>飞书可能会重复推送同一个事件（网络重试等），必须保证业务逻辑的幂等性：</p>\n<pre><code class=\"language-csharp\">public async Task HandleAsync(EventData eventData, CancellationToken cancellationToken = default)\n{\n    // 使用 EventId 或 instance_code + status 组合作为幂等键\n    var idempotencyKey = $\"{approvalEvent.InstanceCode}_{approvalEvent.Status}\";\n\n    // 检查是否已处理过\n    if (await _cache.ExistsAsync(idempotencyKey))\n    {\n        _logger.LogInformation(\"事件已处理过，跳过: Key={IdempotencyKey}\", idempotencyKey);\n        return;\n    }\n\n    // 标记为已处理（设置过期时间，如24小时）\n    await _cache.SetAsync(idempotencyKey, \"1\", TimeSpan.FromHours(24));\n\n    // 执行业务逻辑\n    await ProcessEventAsync(approvalEvent, cancellationToken);\n}\n</code></pre>\n<h4 id=\"api-容错\">API 容错</h4>\n<p>使用 Polly 为飞书 API 调用添加重试和熔断机制：</p>\n<pre><code class=\"language-csharp\">// 注册 HttpClient 时添加 Polly 策略\nbuilder.Services.AddHttpClient(\"Feishu\")\n    .AddTransientHttpErrorPolicy(p =&gt;\n        p.WaitAndRetryAsync(3, retryAttempt =&gt;\n            TimeSpan.FromSeconds(Math.Pow(2, retryAttempt))))\n    .AddPolicyHandler(Policy&lt;HttpResponseMessage&gt;\n        .Handle&lt;HttpRequestException&gt;()\n        .CircuitBreakerAsync(5, TimeSpan.FromSeconds(30)));\n</code></pre>\n<h3 id=\"边界情况与优雅降级\">边界情况与优雅降级</h3>\n<h4 id=\"审批人失效处理\">审批人失效处理</h4>\n<pre><code class=\"language-csharp\">// 飞书审批定义中配置默认审批人\nvar request = new CreateInstanceRequest\n{\n    ApprovalCode = \"xxxx\",\n    // 如果自选审批人为空，使用默认审批人\n    NodeApproverUserIdLists = dto.ApproverUserId.HasValue\n        ? new[] { new NodeApprover { NodeId = \"node1\", ApproverUserIds = new[] { dto.ApproverUserId.Value } } }\n        : null  // 走默认审批人流程\n};\n</code></pre>\n<h4 id=\"网络超时与异步处理\">网络超时与异步处理</h4>\n<p>回调处理应快速响应飞书（建议在 3 秒内），复杂逻辑移至后台作业：</p>\n<pre><code class=\"language-csharp\">public async Task HandleAsync(EventData eventData, CancellationToken cancellationToken = default)\n{\n    // 1. 快速保存事件到队列\n    await _eventQueue.EnqueueAsync(eventData);\n\n    // 2. 立即返回，由后台作业处理\n    // Hangfire、RabbitMQ 等会异步消费队列\n    await Task.CompletedTask;\n}\n\n// 后台作业处理\n[Queue(\"approval-callback\")]\npublic async Task ProcessApprovalEventAsync(EventData eventData)\n{\n    // 复杂的业务逻辑处理\n    await _approvalService.ProcessCallbackAsync(eventData);\n}\n</code></pre>\n<h4 id=\"监控与告警\">监控与告警</h4>\n<p>建立关键节点的监控：</p>\n<pre><code class=\"language-csharp\">// 监控指标\npublic class ApprovalMetrics\n{\n    private readonly Counter _approvalCreatedCounter;\n    private readonly Counter _callbackReceivedCounter;\n    private readonly Histogram _processingTimeHistogram;\n\n    public void RecordApprovalCreated(string approvalType)\n    {\n        _approvalCreatedCounter.WithLabels(approvalType).Inc();\n    }\n\n    public void RecordCallbackReceived(string status)\n    {\n        _callbackReceivedCounter.WithLabels(status).Inc();\n    }\n\n    public void RecordProcessingTime(TimeSpan duration)\n    {\n        _processingTimeHistogram.Observe(duration.TotalSeconds);\n    }\n}\n\n// 告警规则（Prometheus 示例）\n# 审批发起失败率超过 5% 触发告警\nalert: ApprovalCreationFailureRate\nexpr: rate(approval_creation_failed_total[5m]) / rate(approval_creation_total[5m]) &gt; 0.05\nfor: 5m\nannotations:\n  summary: \"审批创建失败率过高\"\n</code></pre>\n<h3 id=\"扩展性与维护性\">扩展性与维护性</h3>\n<h4 id=\"策略模式支持多平台\">策略模式支持多平台</h4>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 审批平台策略接口\n/// &lt;/summary&gt;\npublic interface IApprovalPlatformStrategy\n{\n    string PlatformName { get; }\n    Task&lt;string&gt; CreateInstanceAsync(ApprovalRequest request);\n}\n\n/// &lt;summary&gt;\n/// 飞书审批策略\n/// &lt;/summary&gt;\npublic class FeishuApprovalStrategy : IApprovalPlatformStrategy\n{\n    public string PlatformName =&gt; \"Feishu\";\n    // ... 实现\n}\n\n/// &lt;summary&gt;\n/// 钉钉审批策略\n/// &lt;/summary&gt;\npublic class DingTalkApprovalStrategy : IApprovalPlatformStrategy\n{\n    public string PlatformName =&gt; \"DingTalk\";\n    // ... 实现\n}\n\n/// &lt;summary&gt;\n/// 审批策略工厂\n/// &lt;/summary&gt;\npublic class ApprovalStrategyFactory\n{\n    private readonly IEnumerable&lt;IApprovalPlatformStrategy&gt; _strategies;\n\n    public IApprovalPlatformStrategy GetStrategy(string platformName)\n    {\n        return _strategies.FirstOrDefault(s =&gt; s.PlatformName == platformName)\n            ?? throw new NotSupportedException($\"不支持的审批平台: {platformName}\");\n    }\n}\n</code></pre>\n<h4 id=\"审计日志\">审计日志</h4>\n<p>详细记录审批流转换的关键日志：</p>\n<pre><code class=\"language-csharp\">public class ApprovalAuditService\n{\n    private readonly IApprovalAuditRepository _auditRepo;\n\n    public async Task LogAsync(ApprovalAuditLog log)\n    {\n        log.Timestamp = DateTime.UtcNow;\n        await _auditRepo.AddAsync(log);\n        await _auditRepo.SaveChangesAsync();\n\n        // 结构化日志输出\n        _logger.LogInformation(\"审批审计: {AuditType}, InstanceCode={InstanceCode}, BusinessId={BusinessId}\",\n            log.AuditType, log.InstanceCode, log.BusinessId);\n    }\n}\n\n// 使用示例\nawait _auditService.LogAsync(new ApprovalAuditLog\n{\n    AuditType = \"ApprovalStarted\",\n    InstanceCode = instanceCode,\n    BusinessId = leaveRequest.Id,\n    OperatorId = userId,\n    Details = new { leaveType, days, reason }\n});\n</code></pre>\n<hr />\n<h2 id=\"最后一点内容\">最后一点内容</h2>\n<h3 id=\"核心价值\">核心价值</h3>\n<p>通过本文的实践，我们成功实现了：</p>\n<table>\n<thead>\n<tr>\n<th>价值点</th>\n<th>实现方式</th>\n<th>收益</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>移动化审批</strong></td>\n<td>飞书 App 作为审批门户</td>\n<td>随时随地处理审批</td>\n</tr>\n<tr>\n<td><strong>即时通知</strong></td>\n<td>飞书强通知机制</td>\n<td>审批人及时响应</td>\n</tr>\n<tr>\n<td><strong>数据闭环</strong></td>\n<td>.NET 业务库 + 审批关联表</td>\n<td>完整的业务流程追踪</td>\n</tr>\n<tr>\n<td><strong>解耦设计</strong></td>\n<td>领域层抽象 + 策略模式</td>\n<td>便于扩展和维护</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"全文总结\">全文总结</h3>\n<p>本文提供了一个从理念、设计到编码落地的完整闭环：</p>\n<div class=\"mermaid\">mindmap\n  root((飞书审批集成))\n    理念\n      双向集成\n      .NET为业务核心\n      飞书为流程门户\n    设计\n      分层架构\n      领域抽象\n      安全机制\n    实现\n      发起审批\n      回调处理\n      状态同步\n    最佳实践\n      机密管理\n      幂等性\n      异步处理\n      监控告警\n</div><h3 id=\"扩展\">扩展</h3>\n<h4 id=\"场景扩展\">场景扩展</h4>\n<p>将此模式快速复用于其他业务场景：</p>\n<table>\n<thead>\n<tr>\n<th>业务场景</th>\n<th>审批流程</th>\n<th>复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>报销审批</strong></td>\n<td>发起 → 直属主管 → 财务审核</td>\n<td>中</td>\n</tr>\n<tr>\n<td><strong>采购申请</strong></td>\n<td>发起 → 部门主管 → 采购部 → 总经理</td>\n<td>高</td>\n</tr>\n<tr>\n<td><strong>合同审批</strong></td>\n<td>法务审核 → 财务审核 → 总经理</td>\n<td>高</td>\n</tr>\n<tr>\n<td><strong>加班申请</strong></td>\n<td>直属主管审批</td>\n<td>低</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"深度集成\">深度集成</h4>\n<p>利用飞书更多能力，打造更丰富的协同体验：</p>\n<div class=\"mermaid\">graph TB\n    A[飞书审批] --&gt; B[消息卡片]\n    A --&gt; C[智能机器人]\n    A --&gt; D[知识库]\n\n    B --&gt; B1[审批详情展示]\n    B --&gt; B2[操作按钮]\n    C --&gt; C1[智能提醒]\n    C --&gt; C2[自动补全]\n    D --&gt; D1[历史记录查询]\n    D --&gt; D2[审批规范]\n\n    E[.NET系统] --&gt; A\n    B --&gt; E\n    C --&gt; E\n    D --&gt; E\n</div><p><strong>功能扩展示例</strong>：</p>\n<ul>\n<li>在飞书群聊中通过消息卡片直接查看审批详情</li>\n<li>通过机器人智能回复，引导用户填写审批表单</li>\n<li>将审批记录同步到飞书知识库，方便查阅</li>\n</ul>\n<h4 id=\"平台化\">平台化</h4>\n<p>将审批集成能力抽象为中台服务，供企业内部所有系统统一调用：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 统一审批服务中台\n/// &lt;/summary&gt;\npublic interface IApprovalCenterService\n{\n    /// &lt;summary&gt;\n    /// 统一发起审批（支持多平台）\n    /// &lt;/summary&gt;\n    Task&lt;string&gt; CreateApprovalAsync(UnifiedApprovalRequest request);\n\n    /// &lt;summary&gt;\n    /// 查询审批状态\n    /// &lt;/summary&gt;\n    Task&lt;ApprovalStatus&gt; GetStatusAsync(string instanceId);\n\n    /// &lt;summary&gt;\n    /// 审批统计报表\n    /// &lt;/summary&gt;\n    Task&lt;ApprovalStatistics&gt; GetStatisticsAsync(DateTime from, DateTime to);\n}\n\n// 多个系统统一调用\nawait _approvalCenter.CreateApprovalAsync(new UnifiedApprovalRequest\n{\n    BusinessSystem = \"HR\",\n    BusinessType = \"LeaveRequest\",\n    BusinessId = leaveId,\n    Platform = \"Feishu\"  // 可切换到其他平台\n});\n</code></pre>\n<hr />\n<p><strong>结语</strong></p>\n<p>传统 .NET 系统无需推倒重来，通过合理的架构设计与飞书审批的深度集成，同样可以焕发新的活力。希望本文的实践能够为你的数字化转型之路提供有价值的参考。</p>\n<p>让我们一起告别信息孤岛，拥抱现代化的协同办公体验！🚀</p>\n<hr />\n<h2 id=\"相关资源\">相关资源</h2>\n<h3 id=\"项目地址\">项目地址</h3>\n<ul>\n<li>\n<p><strong>Gitee 仓库</strong>：<a href=\"https://gitee.com/mudtools/MudFeishu\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/mudtools/MudFeishu</a></p>\n</li>\n<li>\n<p><strong>GitHub 仓库</strong>：<a href=\"https://github.com/mudtools/MudFeishu\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/mudtools/MudFeishu</a></p>\n</li>\n<li>\n<p><strong>NuGet 包</strong>：</p>\n<ul>\n<li>\n<p><a href=\"https://www.nuget.org/packages/Mud.Feishu.Abstractions/\" rel=\"noopener nofollow\" target=\"_blank\">Mud.Feishu.Abstractions</a></p>\n</li>\n<li>\n<p><a href=\"https://www.nuget.org/packages/Mud.Feishu/\" rel=\"noopener nofollow\" target=\"_blank\">Mud.Feishu</a></p>\n</li>\n<li>\n<p><a href=\"https://www.nuget.org/packages/Mud.Feishu.WebSocket/\" rel=\"noopener nofollow\" target=\"_blank\">Mud.Feishu.WebSocket</a></p>\n</li>\n<li>\n<p><a href=\"https://www.nuget.org/packages/Mud.Feishu.Webhook/\" rel=\"noopener nofollow\" target=\"_blank\">Mud.Feishu.Webhook</a></p>\n</li>\n</ul>\n</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-05 22:39</span>&nbsp;\n<a href=\"https://www.cnblogs.com/mudtools\">玩泥巴的|mudtools.cn</a>&nbsp;\n阅读(<span id=\"post_view_count\">3</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【面试题】MySQL 三层 B+ 树能存多少数据？",
      "link": "https://www.cnblogs.com/sun-10387834/p/19388703",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sun-10387834/p/19388703\" id=\"cb_post_title_url\" title=\"发布于 2026-01-05 18:57\">\n    <span>【面试题】MySQL 三层 B+ 树能存多少数据？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>这是一个经典的面试题，但实际估算需要考虑多个变量。下面我将详细拆解计算过程：</p>\n<h2 id=\"核心计算模型\"><strong>核心计算模型</strong></h2>\n<p>MySQL B+树存储量 = 根节点扇出 × 中间节点扇出 × 叶子节点容量</p>\n<hr />\n<h2 id=\"关键假设以innodb默认配置为例\"><strong>关键假设（以InnoDB默认配置为例）</strong></h2>\n<ol>\n<li><strong>页大小</strong>：16KB（16384字节）</li>\n<li><strong>主键类型</strong>：BIGINT（8字节）</li>\n<li><strong>指针大小</strong>：6字节（InnoDB页指针）</li>\n<li><strong>行数据大小</strong>：1KB（1024字节） - <em>这是关键变量</em></li>\n<li><strong>页空间利用率</strong>：约70%（需扣除页头、页尾等元数据）</li>\n</ol>\n<hr />\n<h2 id=\"三层b树结构\"><strong>三层B+树结构</strong></h2>\n<pre><code>第1层：根节点（1个）\n第2层：中间节点（fan_out个）\n第3层：叶子节点（fan_out²个） ← 存储实际数据\n</code></pre>\n<hr />\n<h2 id=\"详细计算步骤\"><strong>详细计算步骤</strong></h2>\n<h3 id=\"1-计算单个非叶子节点能存储的键值对数量fan_out\"><strong>1. 计算单个非叶子节点能存储的键值对数量（fan_out）</strong></h3>\n<p>每个索引项大小 = 主键(8B) + 指针(6B) = 14B<br />\n可用空间 = 16KB × 70% = 11.2KB ≈ 11468字节<br />\n单个节点索引项数 = 11468 / 14 ≈ <strong>819</strong></p>\n<p>即：<strong>每个非叶子节点可指向约819个子节点</strong></p>\n<h3 id=\"2-计算单个叶子节点能存储的数据行数\"><strong>2. 计算单个叶子节点能存储的数据行数</strong></h3>\n<p>可用空间 = 16KB × 70% = 11.2KB<br />\n假设每行数据1KB → 每页约存储 <strong>11行</strong><br />\n假设每行数据200字节 → 每页约存储 <strong>57行</strong><br />\n假设每行数据800字节 → 每页约存储 <strong>14行</strong></p>\n<h3 id=\"3-三层b树总容量计算\"><strong>3. 三层B+树总容量计算</strong></h3>\n<p><strong>公式</strong>：总行数 = fan_out² × 每页行数</p>\n<ul>\n<li>若每页11行：819² × 11 ≈ <strong>730万行</strong></li>\n<li>若每页57行：819² × 57 ≈ <strong>3800万行</strong></li>\n<li>若每页14行：819² × 14 ≈ <strong>940万行</strong></li>\n</ul>\n<hr />\n<h2 id=\"更精确的估算考虑真实innodb结构\"><strong>更精确的估算（考虑真实InnoDB结构）</strong></h2>\n<p>实际InnoDB叶子节点存储的是完整数据行，需要考虑：</p>\n<ul>\n<li>行格式开销（行头约23字节）</li>\n<li>事务系统开销（MVCC的隐藏列：DB_TRX_ID 6B + DB_ROLL_PTR 7B）</li>\n<li>可能的NULL位图、变长字段列表等</li>\n</ul>\n<p><strong>保守估算</strong>：<br />\n假设主键为BIGINT，每行额外开销约50字节：</p>\n<ul>\n<li>行大小 = 数据(1024B) + 行开销(50B) = 1074B</li>\n<li>每页行数 = (16384×70%) / 1074 ≈ 10行</li>\n<li>总行数 = 819² × 10 ≈ <strong>670万行</strong></li>\n</ul>\n<hr />\n<h2 id=\"场景分析表\"><strong>场景分析表</strong></h2>\n<table>\n<thead>\n<tr>\n<th>行大小</th>\n<th>每页行数</th>\n<th>三层B+树容量</th>\n<th>四层B+树容量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>200B（小记录）</td>\n<td>~57行</td>\n<td>约3800万行</td>\n<td>约310亿行</td>\n</tr>\n<tr>\n<td>1KB（典型记录）</td>\n<td>~10行</td>\n<td>约670万行</td>\n<td>约55亿行</td>\n</tr>\n<tr>\n<td>2KB（较大记录）</td>\n<td>~5行</td>\n<td>约335万行</td>\n<td>约27亿行</td>\n</tr>\n<tr>\n<td>8KB（大记录）</td>\n<td>~1行</td>\n<td>约67万行</td>\n<td>约5.5亿行</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h2 id=\"重要说明\"><strong>重要说明</strong></h2>\n<ol>\n<li>\n<p><strong>实际容量可能更大</strong>：</p>\n<ul>\n<li>若使用INT主键（4字节），fan_out ≈ 1365，容量提升近3倍</li>\n<li>若行记录更紧凑，每页存储行数更多</li>\n</ul>\n</li>\n<li>\n<p><strong>B+树层数增长</strong>：</p>\n<ul>\n<li>当数据量超过三层容量时，B+树变为四层</li>\n<li>四层B+树容量 = fan_out³ × 每页行数</li>\n<li>对于1KB行，四层B+树可存储约 <strong>55亿行</strong></li>\n</ul>\n</li>\n<li>\n<p><strong>聚簇索引 vs 二级索引</strong>：</p>\n<ul>\n<li>上述计算针对<strong>聚簇索引</strong>（叶子节点存完整数据）</li>\n<li>二级索引叶子节点存储主键值，容量会更大</li>\n</ul>\n</li>\n</ol>\n<hr />\n<h2 id=\"结论\"><strong>结论</strong></h2>\n<p>在典型的配置下（BIGINT主键、1KB行数据）：</p>\n<ul>\n<li><strong>三层B+树大约能存储600万～1000万行数据</strong></li>\n<li><strong>四层B+树可存储数十亿行数据</strong></li>\n</ul>\n<p>这也是为什么我们常说：</p>\n<ul>\n<li>单表千万级别数据时，查询性能仍能保持良好（三层B+树）</li>\n<li>数据量过亿时，可能需要考虑分库分表或优化索引设计</li>\n</ul>\n\n</div>\n<div id=\"MySignature\">\n    \n<p>❤️ 如果你喜欢这篇文章，请点赞支持！ 👍 同时欢迎关注我的博客，获取更多精彩内容！</p>\n\n<p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/sun-10387834/\" target=\"_blank\">佛祖让我来巡山</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/sun-10387834/p/19388703\" target=\"_blank\">https://www.cnblogs.com/sun-10387834/p/19388703</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-05 18:57</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sun-10387834\">佛祖让我来巡山</a>&nbsp;\n阅读(<span id=\"post_view_count\">4</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "吴恩达深度学习课程五：自然语言处理  第一周：循环神经网络 （一）序列数据与序列模型",
      "link": "https://www.cnblogs.com/Goblinscholar/p/19437798",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Goblinscholar/p/19437798\" id=\"cb_post_title_url\" title=\"发布于 2026-01-05 18:52\">\n    <span>吴恩达深度学习课程五：自然语言处理  第一周：循环神经网络 （一）序列数据与序列模型</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>此分类用于记录吴恩达深度学习课程的学习笔记。<br />\n课程相关信息链接如下：</p>\n<ol>\n<li>原课程视频链接：<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?buvid=XU762317353676D786954061C192FE625463B&amp;from_spmid=playlist.playlist-detail.0.0&amp;is_story_h5=false&amp;mid=zqernykrmpf7XfIorMR%2FnA%3D%3D&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=ce0bc526-db69-428a-962e-c65ed8c267bc&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1713085655&amp;unique_k=DfBgvFW&amp;up_id=8654113&amp;vd_source=e035e9878d32f414b4354b839a4c31a4\" rel=\"noopener nofollow\" target=\"_blank\">[双语字幕]吴恩达深度学习deeplearning.ai</a></li>\n<li>github课程资料，含课件与笔记:<a href=\"https://github.com/robbertliu/deeplearning.ai-andrewNG\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习教学资料</a></li>\n<li>课程配套练习（中英）与答案：<a href=\"https://blog.csdn.net/u013733326/article/details/79827273\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习课后习题与答案</a></li>\n</ol>\n<p>本篇为第五课的第一周内容，<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=151\" rel=\"noopener nofollow\" target=\"_blank\">1.1</a>的内容以及一些基础的补充。</p>\n<hr />\n<p>本周为第五课的第一周内容，与 CV 相对应的，这一课所有内容的中心只有一个：<strong>自然语言处理（Natural Language Processing，NLP）</strong>。<br />\n应用在深度学习里，它是专门用来进行<strong>文本与序列信息建模</strong>的模型和技术，本质上是在全连接网络与统计语言模型基础上的一次“结构化特化”，也是人工智能中<strong>最贴近人类思维表达方式</strong>的重要研究方向之一。<br />\n<strong>这一整节课同样涉及大量需要反复消化的内容，横跨机器学习、概率统计、线性代数以及语言学直觉。</strong><br />\n语言不像图像那样“直观可见”，更多是抽象符号与上下文关系的组合，因此<strong>理解门槛反而更高</strong>。<br />\n因此，我同样会尽量补足必要的背景知识，尽可能用比喻和实例降低理解难度。<br />\n本篇的内容关于<strong>序列数据和序列模型</strong>，是自然语言处理中基础内容。</p>\n<h1 id=\"1-序列数据\">1. 序列数据</h1>\n<p>在 NLP 中，一个最基础、也最核心的问题是：<strong>语言数据，和我们之前见过的数据，有什么本质不同？</strong><br />\n答案可以简单概括为：<strong>它是有顺序的。</strong></p>\n<p>在机器学习中，我们把 <strong>”顺序本身携带信息”</strong> 的数据称为<strong>序列数据</strong>。<br />\n最直观的例子就是一句话，同样是这几个词：</p>\n<blockquote>\n<p>“我 吃 饭”<br />\n“饭 吃 我”</p>\n</blockquote>\n<p>包含的词完全一样，但表达的含义却天差地别，这说明：<strong>在语言中，信息不仅存在于“有哪些元素”，还存在于“元素出现的顺序”。</strong></p>\n<p>这与我们之前在 CV 中常见的数据有所不同。<br />\n一张图像在进入模型之前，通常已经被表示为一个<strong>固定尺寸的二维像素网格</strong>。<br />\n无论我们先看左上角还是右下角，<strong>整幅图像的所有信息在输入时是同时存在的</strong>，模型面对的是一个“完整画面”。<br />\n在这种设定下，卷积网络更关注的是<strong>空间结构关系</strong>：哪些像素彼此相邻、哪些局部区域可以组成更高层的形状。</p>\n<p>而语言数据的形式则不同，一句话并不是一个天然的“整体对象”，而是由词语<strong>按顺序依次出现</strong>的。<br />\n简单来说：在按序建模的假设下，模型对当前词的理解，往往依赖于<strong>之前已经出现的所有词所构成的上下文</strong>。</p>\n<p>需要说明的是，这里的“按顺序”并不一定意味着模型必须<strong>像人一样一个词一个词地读</strong>。<br />\n在后续将要介绍的 <strong>Transformer</strong> 模型中，整句话的所有词可以被<strong>同时送入模型进行处理</strong>，但模型仍然需要通过<strong>显式地引入位置信息</strong>，来区分“哪个词在前、哪个词在后”。</p>\n<p>再打个比方：<br />\n图像更像是一张<strong>已经摊开在桌面上的地图</strong>，所有信息一眼都在，模型在处理时不依赖显式的时间顺序，而是直接建模整体的空间结构关系。<br />\n而语言更像是一段<strong>正在播放的语音或文字流</strong>，我们从哪里听，哪里看，结果是截然不同的。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260104144013115-1425405995.png\" /><br />\n因此，在语言任务中，“先出现什么、后出现什么”本身就构成了信息的一部分，而不能被随意打乱<br />\n正因为这种差异，让CV 模型更擅长处理<strong>空间结构与局部模式</strong>，而 NLP 模型必须重点解决<strong>顺序、依赖关系以及上下文记忆</strong>的问题。</p>\n<p>我们总结语言、语音、时间等序列数据的特征如下：</p>\n<ol>\n<li>数据是<strong>按顺序排列</strong>的。</li>\n<li>当前信息往往依赖于<strong>之前已经出现的内容</strong>。</li>\n<li>数据长度通常<strong>不固定</strong>。</li>\n</ol>\n<p>这些特征决定了：<strong>在处理序列数据时，模型必须显式地考虑顺序与上下文，而不能仅把输入当作一个无序的特征集合来处理。</strong></p>\n<h1 id=\"2-序列模型\">2. 序列模型</h1>\n<p>我们分别看看，如果使用我们已经了解过的<strong>全连接网络</strong>和<strong>卷积网络</strong>来处理序列数据，效果会怎么样。</p>\n<h2 id=\"21-全连接网络无法自然处理顺序\">2.1 全连接网络：无法自然处理“顺序”</h2>\n<p>如果要应用全连接网络，最直接的想法是：  把一句话中的每个词表示成向量，再把这些向量<strong>拼接成一个长向量</strong>，送进全连接网络。</p>\n<p>这种做法在形式上是可行的，但问题也非常明显：<br />\n首先，全连接网络要求<strong>固定长度输入</strong>，而语言序列的长度是天然不固定的。<br />\n一句话可以只有几个词，也可以非常长。为了满足输入要求，我们不得不进行截断或填充，这本身就引入了额外的工程复杂度。</p>\n<p>其次，更关键的是：<strong>全连接网络并不具备“顺序感知”能力</strong>。在它看来，输入只是一个高维向量，各个维度之间没有“先后”这一概念。<br />\n模型本身并不知道：“这是第一个词”“这是第三个词”。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260104144012968-399183777.png\" /></p>\n<p>因此，这种处理方式天然忽略了语言中最重要的结构信息——顺序与依赖关系。不能用来处理序列数据。</p>\n<h2 id=\"22-卷积网络擅长局部模式但缺乏长期依赖\">2.2 卷积网络：擅长局部模式，但缺乏长期依赖</h2>\n<p>那卷积网络呢？  既然 CNN 能在图像中建模局部结构，是否也可以用于序列数据？<br />\n答案是：<strong>部分可以，但不够自然。</strong></p>\n<p>在序列上使用一维卷积时，卷积核可以捕捉<strong>局部连续片段</strong>，例如相邻几个词构成的短语或固定搭配。 从这个角度看，CNN 确实能够建模<strong>局部上下文信息</strong>。</p>\n<p>在这里，我们需要引入一个概念：<strong>感受野（receptive field）</strong>。<br />\n感受野指的是卷积层中某个神经元<strong>能够“看到”的输入区域范围</strong>。<br />\n打个比方：</p>\n<ul>\n<li>在图像中，如果一个卷积神经元的感受野是 <span class=\"math inline\">\\(3\\times3\\)</span>，它只能感知这九个像素的局部信息；</li>\n<li>类似地，在序列上，一个卷积核的感受野就是它<strong>一次性能看到的连续词的数量</strong>。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260104144316440-1063086196.png\" /><br />\n这就意味着，卷积网络在处理序列时天然擅长捕捉<strong>局部模式或短距离依赖</strong>，但如果想让模型理解“句首的词”与“句尾的词”之间的关系，就必须<strong>堆叠很多层卷积</strong>或<strong>人为扩大卷积核范围</strong>，才能覆盖整个序列。<br />\n简单来说，感受野越大，模型越容易捕捉<strong>长距离依赖</strong>，但这也带来了计算和训练上的问题。<br />\n这使得模型：</li>\n<li>对<strong>短距离依赖</strong>敏感。</li>\n<li>对<strong>长距离依赖</strong>不够高效。</li>\n<li>并且仍然缺乏一种明确的“时间状态”概念。</li>\n</ul>\n<p>可以这样理解：<br />\n卷积网络更像是在<strong>扫描局部片段</strong>，而不是在<strong>沿着时间轴逐步理解一句话的发展过程</strong>，因此，虽然卷积对序列数据的处理能力强于全连接网络，但是它仍有所局限。</p>\n<h2 id=\"23-序列模型要解决的核心问题\">2.3 序列模型要解决的核心问题</h2>\n<p>通过以上对比可以看到，全连接网络和卷积网络并不是“不能”处理序列数据，而是<strong>处理方式与序列数据的本质存在冲突</strong>。</p>\n<p>序列数据的核心特点在于：信息是<strong>随顺序逐步展开的</strong>、当前理解依赖于<strong>历史上下文</strong>且序列长度<strong>不固定</strong>。<br />\n因此，我们真正需要的是这样一类模型：  <strong>在处理当前输入的同时，能够保留并更新对“过去信息”的表示。</strong><br />\n也就是说，序列模型的核心能力并不在于“输入形式”，  而在于它是否具备一种<strong>可随时间演化的内部状态</strong>，用来承载上下文信息，并参与后续决策。<br />\n后续我们将看到的 RNN、LSTM、GRU 以及 Transformer，  虽然实现方式不同，但都围绕着同一个目标展开：  <strong>让模型在理解当前内容时，不是孤立地“看这一刻”，而是基于整个上下文来判断。</strong></p>\n<p>这就是序列模型所具备的能力。</p>\n<h1 id=\"3-序列模型的应用领域\">3. 序列模型的应用领域</h1>\n<p>序列模型在 NLP 中应用广泛，但需要注意的是：<strong>序列模型不一定要求输入和输出都是序列</strong>。它的核心能力在于能够<strong>保留上下文信息并处理随时间展开的数据</strong>。只要输入或输出中存在序列性质，序列模型就能发挥作用。<br />\n从输入和输出的角度，可以分为以下几类情况：</p>\n<ol>\n<li><strong>序列→序列：</strong> 输入和输出都是序列，例如机器翻译。模型需要根据输入序列的上下文生成对应的输出序列。</li>\n<li><strong>序列→标量或类别：</strong> 输入是序列，输出是单个值或类别，例如情感分析、文本分类。模型需要理解整段序列的语义，并输出整体判断。</li>\n<li><strong>标量或固定输入→序列：</strong> 输入不是序列，但模型需要生成序列作为输出，例如文本生成或对话系统中根据提示生成完整回答。</li>\n</ol>\n<p>由此可见，序列模型的核心能力不是“必须处理序列输入或输出”，而是<strong>能够在处理过程中维护上下文信息</strong>。<br />\n来看看序列模型的一些常见应用领域：</p>\n<table>\n<thead>\n<tr>\n<th>任务</th>\n<th>输入类型</th>\n<th>输出类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>文本分类</td>\n<td>序列</td>\n<td>类别</td>\n<td>如情感分析、新闻分类，理解整段文本并输出单一标签</td>\n</tr>\n<tr>\n<td>命名实体识别 (NER)</td>\n<td>序列</td>\n<td>序列</td>\n<td>对每个词进行标注，如“人名”“地名”等</td>\n</tr>\n<tr>\n<td>机器翻译</td>\n<td>序列</td>\n<td>序列</td>\n<td>将源语言句子转换为目标语言句子</td>\n</tr>\n<tr>\n<td>文本生成</td>\n<td>序列或标量</td>\n<td>序列</td>\n<td>根据输入文本或提示生成完整文本</td>\n</tr>\n<tr>\n<td>语音识别</td>\n<td>序列</td>\n<td>序列</td>\n<td>将语音信号转为文字序列</td>\n</tr>\n<tr>\n<td>问答系统</td>\n<td>序列</td>\n<td>序列或标量</td>\n<td>根据问题生成答案，答案可以是短文本或单一类别</td>\n</tr>\n<tr>\n<td>时间序列预测</td>\n<td>序列</td>\n<td>序列或标量</td>\n<td>如股价预测，根据历史序列预测未来数值</td>\n</tr>\n</tbody>\n</table>\n<p>通过这个分类，可以清晰地看到：<strong>序列模型的核心是处理顺序和上下文，不必限制输入输出都为序列</strong>。只要有序列信息存在，它就可以发挥价值。</p>\n<h1 id=\"4-总结\">4. 总结</h1>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>原理</th>\n<th>比喻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>序列数据</td>\n<td>数据元素按顺序排列，当前理解依赖历史上下文，长度不固定</td>\n<td>图像像摊开的地图，一眼可见整体；语言像正在播放的语音或文字流，需要顺序感知</td>\n</tr>\n<tr>\n<td>全连接网络处理序列</td>\n<td>只能接受固定长度输入，无法天然感知顺序</td>\n<td>只是把所有词拼成一个长向量，模型看不到先后顺序</td>\n</tr>\n<tr>\n<td>卷积网络处理序列</td>\n<td>能捕捉局部连续模式（短距离依赖），感受野有限，长距离依赖不高效</td>\n<td>卷积像扫描局部片段，而不是沿时间轴理解整句话的发展</td>\n</tr>\n<tr>\n<td>感受野 (Receptive Field)</td>\n<td>一个卷积神经元一次能够看到的输入区域</td>\n<td>图像：3×3像素只能看到局部；序列：卷积核一次看到几个连续词</td>\n</tr>\n<tr>\n<td>序列模型核心能力</td>\n<td>通过可随时间演化的内部状态，保留并更新上下文信息，理解当前输入时考虑历史信息</td>\n<td>模型像带记忆的阅读者，理解每个词时参考整段上下文</td>\n</tr>\n<tr>\n<td>输入/输出类型灵活性</td>\n<td>序列模型不要求输入输出都为序列，只要一方为序列即可发挥作用</td>\n<td>输入是流，输出是判断或生成，模型记忆历史信息</td>\n</tr>\n<tr>\n<td>序列模型应用</td>\n<td>NLP、语音、时间序列等领域，如文本分类、NER、机器翻译、文本生成、语音识别、问答、时间序列预测</td>\n<td>依赖上下文信息，模型像“顺序感知器”，根据过去信息做当前决策</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-05 18:52</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Goblinscholar\">哥布林学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">4</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "NVIDIA CUDA 高性能计算笔记（一）cuda编程简介及矩阵赋值案例",
      "link": "https://www.cnblogs.com/GeophysicsWorker/p/19444388",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/GeophysicsWorker/p/19444388\" id=\"cb_post_title_url\" title=\"发布于 2026-01-05 18:33\">\n    <span>NVIDIA CUDA 高性能计算笔记（一）cuda编程简介及矩阵赋值案例</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        CUDA （Compute  Unified Device Architecture）是NIVIDIA 推出的通用并行计算平台，支持C，C++，Python等语言，实现CPU和GPU协同计算。其架构采用Grid-Blocks-Threads线程层次结构和SIMT并行模式，在给出CUDA的编程实例之前，需要给出模型的基础知识做个简单的介绍。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"nvidia-cuda-高性能计算笔记一\">NVIDIA CUDA 高性能计算笔记（一）</h1>\n<p>​       CUDA （Compute  Unified Device Architecture）是NIVIDIA 推出的通用并行计算平台，支持C，C++，Python等语言，实现CPU和GPU协同计算。其架构采用Grid-Blocks-Threads线程层次结构和SIMT并行模式，在给出CUDA的编程实例之前，需要给出模型的基础知识做个简单的介绍。</p>\n<h2 id=\"11cuda编程模型简介\">1.1CUDA编程模型简介</h2>\n<p>​      CUDA编程模型是一个异构模型，需要GPU和CPU协同工作。在CUDA架构中，我们用host端指代CPU及其内存的，用device指代GPU及其内存。CUDA程序中即包含Host程序，又包含device程序，它们分别在CPU与GPU上运行。同时，host与device之间进行通信，这样它们之间可以进行数据拷贝。典型的CUDA程序的执行的程序的流程为：</p>\n<ol>\n<li>分配host内存，并进行数据初始化；</li>\n<li>分配device内存（显存、共享内存），并从host端将数据拷贝到device端；</li>\n<li>调用CUDA的核函数在device函数上完成指定的运算；</li>\n<li>将device上的运算结果拷贝到host上；</li>\n<li>释放device和host上分配的内存。</li>\n</ol>\n<p>​        由于CUDA编程模型实际上是异构编程模型，所以需要区分host和device上的代码，在CUDA中是通过函数类型限定词区别开host和device上的函数，主要的三个函数类型限定词如下：</p>\n<ul>\n<li><code>__global__</code>: 在device端上执行，从host中调用（一些特定的GPU也可以从device上调用），返回类型必须为 <code>void</code> , 不支持可变参数，不能成为类成员函数。注意<code>__global__</code> 定义的kernel是异步的，这意味着host端不会等待kernel执行完就执行下一步；</li>\n<li><code>__device__</code>: 在device端上执行，但仅可以从device中调用，不可以和 <code>__global__</code> 同时用；</li>\n<li><code>__host__</code>: 在host上执行，仅可以从host中调用，一般省略不写，不可以和 <code>__global__</code>同时用，但可以和 <code>__device__</code>，此时函数会在device和host都编译。</li>\n</ul>\n<p>​         上面的流程中最重要的一个过程是调用CUDA的核函数来执行并行计算，kernel是CUDA中的一个重要的概念，kernel是在device上线程中并行执行的函数，在调用时需要用 <code>&lt;&lt;&lt;grid,block&gt;&gt;&gt; </code> 来指定kernel要执行的线程数量，在CUDA中，每个线程都要执行核函数，并且每个线程会分配一个唯一的<span class=\"math inline\">\\(thread\\space ID\\)</span> ,这个<span class=\"math inline\">\\(ID\\)</span> 值可以通过核函数的内置变量 <code>thread Idx</code> 来获得。</p>\n<p>​       要深刻理解<span class=\"math inline\">\\(kernel\\)</span>，必须要对<span class=\"math inline\">\\(kernel\\)</span> 的线程层次结构有一个清晰的认识。首先，<span class=\"math inline\">\\(GPU\\)</span>上很多并形化的轻量级线程。<span class=\"math inline\">\\(kernel\\)</span> 在device上执行时实际上是启动很多线程，一个<span class=\"math inline\">\\(kernel\\)</span> 所启动的所有线程称为<strong>网格</strong><span class=\"math inline\">\\(grid\\)</span> ，同一个网格的线程共享相同的全局内存空间，grid是线程结构的第一个层次，而网格又可以分为很多<strong>线程块</strong>(block)，一个线程块里面包含很多线程，这是第二个层次。  为了编程方便，<span class=\"math inline\">\\(grid\\)</span> 和<span class=\"math inline\">\\(block\\)</span> 都是定义为 <code>dim3</code> 类型的变量，<code>dim3</code> 可以看成是包含三个无符号整数<span class=\"math inline\">\\((x,y,z)\\)</span> 成员的结构体变量，在定义时，缺失值初始化为1。因此，grid和block可以灵活地定义为1-dim，2-dim以及3-dim的结构，对于，<span class=\"math inline\">\\(knernel\\)</span>在定义调用时也必须通过执行配置 <code>&lt;&lt;&lt;grid,block&gt;&gt;&gt;</code>来指定kernel所使用的线程数及结构。</p>\n<p><img alt=\"fHaSP2zNs\" class=\"lazyload\" /></p>\n<p>​    所以，为了方便编程，CUDA中使用了 <code>dim3</code> 类型（<code>dim3</code> 是基于unit3定义的矢量类型，相当于由3个 <code>unsigned int</code>类型组成的结构体）的内建变量 <code>threadIdx</code> 和 <code>blockIdx</code>。这样，就可以使用一维、二维或三维的索引来标识线程，构成 一维、二维或三维线程块。使得线程组织形式对各种域（向量、矩阵，或者高维张量）中数据的划分变得直观、自然。</p>\n<ul>\n<li>对于一维的block，线程的<span class=\"math inline\">\\(threadID\\)</span>就是<span class=\"math inline\">\\(threadId.x\\)</span>;</li>\n<li>对于大小为<span class=\"math inline\">\\((Dx,Dy)\\)</span>的二维线程块block，线程的<span class=\"math inline\">\\(threadID\\)</span> 是 <span class=\"math inline\">\\((threadIdx.x+threadIdx.x\\times{Dx})\\)</span>;</li>\n<li>对于大小为<span class=\"math inline\">\\((Dx,Dy,Dz)\\)</span>的三维线程块block, 线程的<span class=\"math inline\">\\(threadID\\)</span>是（<span class=\"math inline\">\\(threadIdx.x+threadIdx.y\\times{Dx}+threadIdx.z\\times{Dx}\\times{Dy}\\)</span>）;</li>\n</ul>\n<p>另外，线程还有内置变量gridDim，用于获取网格块各个维度的大小。</p>\n<p>​       此外，这里简单介绍一下CUDA的内存模块，如图所示。可以看到，每个线程有自己的私有本地内存（<span class=\"math inline\">\\(Local Memory\\)</span>）, 而每个线程块有包含共享内存（<span class=\"math inline\">\\(Shared \\space Memory\\)</span>）。还可以访问一些只读内存块：常用内存（<span class=\"math inline\">\\(Constant \\space Memory\\)</span>）和纹理内存 （<span class=\"math inline\">\\(Texture \\space Memory\\)</span>）。内存结构涉及到程序优化，这里就过多讨论。</p>\n<p><img alt=\"fHaRlklWa\" class=\"lazyload\" /></p>\n<p>​       还有重要一点，你需要对<span class=\"math inline\">\\(GPU\\)</span>的硬件实现有一个基本的认识。上面说到了<span class=\"math inline\">\\(kernel\\)</span>的线程组织层次，那么一个<span class=\"math inline\">\\(kernel\\)</span> 实际上会启动很多线程，这些线程是逻辑上是并行的，但是在物理层也是无法却并不一定。这其实和CPU的多线程有类似之处，多线程如果没有多核支持，在物理层也无法实现并行的。但是好在<span class=\"math inline\">\\(GPU\\)</span> 存在很多CUDA核心，充分利用CUDA核心可以充分发挥GPU的并行计算能力。GPU硬件的一个核心组件是SM，前面已经说过，SM是Streaming Multiprocessor，SM的核心组件包括的CUDA核心、共享内存、寄存器等，SM可以并发的执行上，一个线程块只能在一个SM上被调度。SM一般可以调度多个线程块，这要看SM本身的能力。那么有可能一个kernel的各个线程块被分配多个SM，所以grid只是逻辑层，而SM才是执行的物理层。SM采用的是<a href=\"https://link.zhihu.com/?target=http%3A//docs.nvidia.com/cuda/cuda-c-programming-guide/index.html%23simt-architecture\" rel=\"noopener nofollow\" target=\"_blank\">SIMT</a>(Single-Instruction, Multiple-Thread，单指令多线程)架构，基本的执行单元是线程束（warps)，线程束包含32个线程，这些线程同时执行相同的指令，但是每个线程都包含自己的指令地址计数器和寄存器状态，也有自己独立的执行路径。所以尽管线程束中的线程同时从同一程序地址执行，但是可能具有不同的行为，比如遇到了分支结构，一些线程可能进入这个分支，但是另外一些有可能不执行，它们只能死等，因为GPU规定线程束中所有线程在同一周期执行相同的指令，线程束分化会导致性能下降。当线程块被划分到某个SM上时，它将进一步划分为多个线程束，因为这才是SM的基本执行单元，但是一个SM同时并发的线程束数是有限的。这是因为资源限制，SM要为每个线程块分配共享内存，而也要为每个线程束中的线程分配独立的寄存器。所以SM的配置会影响其所支持的线程块和线程束并发数量。总之，就是网格和线程块只是逻辑划分，一个kernel的所有线程其实在物理层是不一定同时并发的。所以kernel的grid和block的配置不同，性能会出现差异，这点是要特别注意的。还有，由于SM的基本执行单元是包含32个线程的线程束，所以block大小一般要设置为32的倍数。</p>\n<table>\n<thead>\n<tr>\n<th>内存类型：</th>\n<th>内存作用：</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>全局内存（Global Memory）</strong></td>\n<td><strong>容量最大（通常数GB），所有线程可访问，但延迟高（400-800周期）</strong></td>\n</tr>\n<tr>\n<td><strong>共享内存（shared Memory）</strong></td>\n<td><strong>片上内存，速度比全局内存快100倍，但容量有限（每SM通常16-64KB）</strong></td>\n</tr>\n<tr>\n<td><strong>寄存器（Registers）</strong></td>\n<td><strong>最快的存储，每个线程私有</strong></td>\n</tr>\n<tr>\n<td><strong>常量内存（Constant Memory）</strong></td>\n<td><strong>只读缓存，适合广播数据</strong></td>\n</tr>\n<tr>\n<td><strong>纹理内存（Texture Memory）</strong></td>\n<td><strong>专为图形处理优化的特殊缓存</strong></td>\n</tr>\n</tbody>\n</table>\n<p>​     内存访问特性比较：</p>\n<table>\n<thead>\n<tr>\n<th>内存类型</th>\n<th>物理位置</th>\n<th>作用域</th>\n<th>带宽、速度</th>\n<th>使用场景</th>\n<th>显式控制关键字</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>寄存器</td>\n<td>GPU芯片寄存器</td>\n<td>线程私有</td>\n<td>最高（1周期）</td>\n<td>高频访问的私有变量（如循环计数器）</td>\n<td>自动分配（局部变量）</td>\n</tr>\n<tr>\n<td>共享内存</td>\n<td>GPU芯片上的SM处理器</td>\n<td>线程块共享</td>\n<td>高（1-32周期）</td>\n<td>线程协作（如规约运算、矩阵分块）</td>\n<td><code>__share__</code></td>\n</tr>\n<tr>\n<td>本地内存</td>\n<td>实际在全局内存中内存</td>\n<td>线程私有</td>\n<td>中低（<span class=\"math inline\">\\(\\approx\\)</span>全局内存）</td>\n<td>大数组或寄存器不足时的溢出变量</td>\n<td>编译器自动分配</td>\n</tr>\n<tr>\n<td>全局内存</td>\n<td>GPU设备显存</td>\n<td>所有线程+主机</td>\n<td>中（400~800周期）</td>\n<td>大规模数据存储，需要频繁访问时需合并访问优化</td>\n<td><code>cudaMalloc</code>分配</td>\n</tr>\n<tr>\n<td>常量内存</td>\n<td>GPU芯片上的缓存</td>\n<td>所有线程只读</td>\n<td>中（缓存加速）</td>\n<td>需要广播给所有线程的至多</td>\n<td><code>__constant__</code></td>\n</tr>\n<tr>\n<td>纹理内存</td>\n<td>GPU专用缓存</td>\n<td>所有线程</td>\n<td>中 （优化访存）</td>\n<td>图形处理、具有空间局部性的非对齐访问</td>\n<td>纹理API绑定</td>\n</tr>\n<tr>\n<td>主机内存</td>\n<td>CPU内存</td>\n<td>主机+设备（需要拷贝）</td>\n<td>最低（PCLe瓶颈）</td>\n<td>CPU-GPU数据传输的中间存储</td>\n<td>malloc、cudaHostAlloc</td>\n</tr>\n</tbody>\n</table>\n<p>下面我将详细地介绍CUDA中各种内存管理函数的功能、参数和使用方法。</p>\n<p><strong>CUDA</strong>是一种用于异构并行计算的编程模型，经常需要在主机端（host）和设备端（Device）之间进行数据传输。这是因为CUDA核函数传入的必须是指向其中处理GPU显存的三个关键的API：<code>cudaMalloc</code>,<code>cudaMemcpy</code>和 <code>cudaFree</code>。</p>\n<ul>\n<li><code>cudaMalloc</code>：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">其接口API形式：</th>\n<th style=\"text-align: left;\">cudaError_t  cudaMalloc(void ** <em>devPtr</em>,size_t <em>size</em> )</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>函数功能：</strong></td>\n<td style=\"text-align: left;\"><strong>在设备上分配线性内存size字节，并通过指针返回分配的内存devPtr。分配的内存对应任何类型的变量。记忆没有被清除。失败时返回 cudaErrorMemoryAllocation。</strong></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>参数：</strong></td>\n<td style=\"text-align: left;\"><strong><code>devPtr</code> 设备内存分配指针；<code>size</code> ：分配的字节数</strong></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>返回值：</strong></td>\n<td style=\"text-align: left;\"><strong><code>cudaSuccess</code> , <code>cudaErrorMemoryAllocation</code></strong></td>\n</tr>\n</tbody>\n</table>\n<p>注意事项：</p>\n<p>分配的内存</p>\n<ul>\n<li>\n<p><code>cudaMemcpy</code> ：</p>\n<table>\n<thead>\n<tr>\n<th>其接口形式：</th>\n<th>cudaError_t cudaMemcpy(void * dist, const void * src,size_t count,CudaMemcpyKind kind)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>函数功能：</strong></td>\n<td><strong>将指向的内存区域的字节复制到指向的存储区域</strong></td>\n</tr>\n<tr>\n<td><strong>参数：</strong></td>\n<td><strong>dist-目的存储地址；src -源内存地址；count-复制内存的字节数； kind-传输类型</strong></td>\n</tr>\n<tr>\n<td><strong>返回值：</strong></td>\n<td><strong>cudaSuccess，cudaErrorInvalidValue，cudaErrorInvalidDevicePointer，cudaErrorInvalidMemcpyDirection</strong></td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p><code>cudaFree</code>：</p>\n<table>\n<thead>\n<tr>\n<th>其接口形式：</th>\n<th>cudaError_t cudaFree(void * devPtr)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>函数功能</strong>：</td>\n<td><strong>释放由 指向的内存空间，该空间必须是之前调用cudaMalloc()或cudaMallocPitch()时返回过的。否则，或者如果cudaFree()之前已被调用过，则返回错误。如果 为 0，则不执行作。cudaFree() 在失败时返回cudaErrorInvalidDevicePointer。</strong></td>\n</tr>\n<tr>\n<td><strong>参数:</strong></td>\n<td><strong><code>devPtr</code> -设备指针指向内存释放</strong></td>\n</tr>\n<tr>\n<td><strong>返回值：</strong></td>\n<td><strong>cudaSuccess，cudaErrorInvalidDevicePointer, cudaErrorInitialization</strong></td>\n</tr>\n</tbody>\n</table>\n<p>​</p>\n</li>\n</ul>\n<h2 id=\"12-cuda的第一个程序矩阵赋值matrix-assign\">1.2 CUDA的第一个程序—矩阵赋值(Matrix Assign)</h2>\n<p>​            在本节通过一个矩阵赋值（matrix Assign）例子开始真正的CUDA程序实现，本例是在SDK中template程序的基础上修改得到的。<span class=\"math inline\">\\(template\\)</span> 是 <span class=\"math inline\">\\(NVIDIA\\)</span> 公司提供的CUDA程序模板，也就是CUDA程序最基本的框架。要创建一个CUDA程序，可以把整个template文件复制一份。在一个CUDA程序中，基本的主机端代码主要完成以下的功能：</p>\n<ul>\n<li>启动CUDA，使用多卡时应该时应该加上设备号，或使用<span class=\"math inline\">\\(cudaSetDevice()\\)</span>设备GPU设备；</li>\n<li>为输入数据分配内存空间；</li>\n<li>初始化输入数据；</li>\n<li>为GPU分配内存，用于存放输入数据；</li>\n<li>将内存中的输入数据拷贝到显存；</li>\n<li>为GPU分配显存，用于存放输出数据；</li>\n<li>调用device端的kernel进行计算，将结果写到显存中的对应区域；</li>\n<li>为CPU分配内存，用于存放GPU传回来的输出数据；</li>\n<li>将显存中的结果读取到内存；</li>\n<li>释放内存和显存空间；</li>\n<li>退出CUDA；</li>\n</ul>\n<p>最简单的设备端代码主要完成以下功能：</p>\n<ul>\n<li>\n<p>从显存读取数据到GPU片内；</p>\n</li>\n<li>\n<p>对数据进行处理；</p>\n</li>\n<li>\n<p>将处理后的数据写回显存；</p>\n<p>其整个工程包含了三：</p>\n<p>（1）主程序文件CPU-Host端程序（example1main.cu）；</p>\n</li>\n</ul>\n<p>​       （2）GPU设备端函数的处理函数头文件（example_matrixassign_kernel.cuh）；</p>\n<p>​       （3）GPU设备端函数的处理函数文件（example_matrixassign_kernel.cu）；</p>\n<p>File1：主程序文件CPU-Host端程序（example1main.cu）；</p>\n<pre><code class=\"language-c\">#include&lt;stdio.h&gt; //系统头文件\n#include&lt;stdlib.h&gt;\n#include&lt;string.h&gt;\n#include&lt;math.h&gt;\n\n#include\"cuda_runtime.h\" //cuda项目头文件\n#include\"device_launch_parameters.h\"\n#include\"example_matrixassign_kernel.cuh\"  //核函数的数据的头文件\n\n\nvoid runTest(int argc, char** argv);\n\nint main(int argc,char** argv){\n\n\trunTest(argc,argv);\n\n}\n\nvoid runTest(int argc, char** argv){\n\n\tunsigned int num_blocks = 4;  //定义网格中的线程块数量\n\tunsigned int num_threads= 4;  //定义每个线程块中的线程数量\n\n\tunsigned int mem_size = sizeof(float) * num_blocks * num_threads; //为了数据分配的存储器大小，这里每一个人线程计算一个flaot\n\n\t//在host端分配内存，h_表示host端，i表示input，o表示output\n\tfloat* h_idata = nullptr;\n\tfloat* h_odata = nullptr;\n\n\th_idata =(float *)malloc(mem_size);\n\th_odata = (float*)malloc(mem_size);\n\n\tif(h_idata != nullptr) {\n\t   memset(h_idata, 0, mem_size);\n\t}else{\n\t\treturn;\n\t}\n\tif(h_odata!=nullptr){\n\t\tmemset(h_odata, 0, mem_size);\n\t}else{\n\t\treturn;\n\t}\n\t\n\t//在device端分配显存，d_表示device端，i表示input，o表示output\n\tfloat* d_idata = nullptr;\n\tfloat* d_odata = nullptr;\n\n\tcudaError_t cudaStatus;  //cuda状态判断\n\n\tcudaStatus=cudaMalloc((void**)&amp;d_idata, mem_size);\n\tif(cudaStatus != cudaSuccess){\n\t\tprintf(\"d_idata is cudaMalloc failed!\\n\");\n\t\treturn;\n\t}\n\tcudaStatus=cudaMalloc((void**)&amp;d_odata, mem_size);\n\tif(cudaStatus!=cudaSuccess){\n\t\tprintf(\"d_odata is cudaMalloc failed!\\n\");\n\t\treturn;\n\t}\n\t\n\t//初始化内存中的值\n\tfor(unsigned int i = 0; i &lt; num_threads * num_blocks;i++){\n\t\th_idata[i] =1.0f;\n\t}//end for(unsigned int i = 0; i &lt; num_threads * num_blocks;i++)\n\n\t//将内存中的输入数据读入设备端显存，这样就完成了主机对设备的数据写入\n\tcudaStatus=cudaMemcpy(d_idata,h_idata,mem_size,cudaMemcpyHostToDevice);\n\n\t//设置运行参数，即网格的形状和线程块的形状\n\tdim3 grid(num_blocks,1,1);\n\tdim3 block(num_threads,1,1);\n\n\t// 运行核函数，调用GPU进行运算\n\ttestMatrixAssignKernel &lt;&lt;&lt;grid, block&gt;&gt;&gt; (d_idata,d_odata);\n\n\t//将结果从显存写入内存\n\tcudaStatus = cudaMemcpy(h_odata,d_odata,mem_size,cudaMemcpyDeviceToHost);\n\n\t//打印结果\n\tprintf(\"赋值前的矩阵：\\n\");\n\tfor (unsigned int iblock = 0; iblock &lt; num_blocks; iblock++) {\n\t\tfor (unsigned int ithread = 0; ithread &lt; num_threads; ithread++) {\n\t\t\tprintf(\"%5.0f\", h_idata[iblock * num_threads + ithread]);\n\t\t}//end for(unsigned int ithread = 0; ithread &lt; num_threads; ithread++)\n\t\tprintf(\"\\n\");\n\t}//end for(unsigned int iblock = 0; iblock &lt; num_blocks; iblock++)\n\n\tprintf(\"赋值后的矩阵：\\n\");\n\tfor(unsigned int iblock = 0; iblock &lt; num_blocks; iblock++){\n\t\tfor(unsigned int ithread = 0; ithread &lt; num_threads; ithread++){\n\t\t\tprintf(\"%5.0f\",h_odata[iblock*num_threads+ithread]);\n\t\t}//end for(unsigned int ithread = 0; ithread &lt; num_threads; ithread++)\n\t\tprintf(\"\\n\");\n\t}//end for(unsigned int iblock = 0; iblock &lt; num_blocks; iblock++)\n\n\t//输出存储器指针\n\tfree(h_idata);\n\tfree(h_odata);\n\tcudaFree(d_idata);\n\tcudaFree(d_odata);\n}\n\n</code></pre>\n<p>从代码中看出，CUDA的主机端代码与C语言非常相似。但也有一部分C语言中没有的语句，下面逐一进行分析。</p>\n<p>​      （1）<code>cudaMalloc(size)</code>在显存global memory上分配大小为size字节的线性空间。需要注意的是，与malloc和free一样，cudaMalloc() 也必须与cudaFree()成对使用，否则无法释放显存空间，运行几次程序以后显卡上就没有显存可供分配，程序也就无法正常运行了。另外，为了杜绝指针指费的情况现象，最好在程序结束前将指针赋空并摧毁。</p>\n<p>​      （2） <code>cudaMemcpy()</code>用于拷贝存储器中的数据，其中第二参数是指向目标的指针，第二个参数是指向源的指针，第三个参数是需要拷贝的字节数，第四个参数是拷贝操作的类型。拷贝操作类型共有三种：</p>\n<ul>\n<li>cudaMemcpyDeviceToHost 将显存中的数据拷贝内存中；</li>\n<li>cudaMemcpyHostToDevice 将内存中的数据拷贝到显存中；</li>\n<li>cudaMemcpyDeviceToDevice将global memory中的数据拷贝到同一个CUDA上下文的global的另一个区域中；</li>\n</ul>\n<p>​      （3）<code>&lt;&lt;&lt;&gt;&gt;&gt;</code>运算符对kernel函数完整的执行参数配置形式是<code>&lt;&lt;&lt;Dg,Db,Ns,S&gt;&gt;&gt;</code>，其中各个参数的含义是：</p>\n<ul>\n<li>参数Dg用于定义整个grid的维度和尺寸，为dim3类型，但实际上只有前两维可以不为1。<code>Dim3 Dg(Dg.x,Dg.y,1)</code>中每行有Dg.x个block，每列有Dg.y个block的维度，第三维恒为1。</li>\n<li>参数Db为dim3类型，用于定义每个block的维度与尺寸。<code>Dim3 Db(Db.x,Db.y,Db.z)</code> 中每行有<code>Db.x</code>个thread，每列<code>Db.y</code>个thread，高为<code>Db.z</code>，可以定义三维尺寸。整个block中共有<code>Db.x*Db.y*Db.z</code> 个线程；</li>\n<li>参数Ns是一个可选参数，用于设置每个block的共享内存shared memory以外，最多能够动态分配的shared memory大小，单位为Byte。</li>\n<li>参数<span class=\"math inline\">\\(s\\)</span>是一个cudaStream_t类型的可选参数，初始值为0。在本案例中没有用到Stream的相关内容因此这个参数不填，默认为0号流。</li>\n</ul>\n<p>File2：主程序文件CPU-Host端程序（example1main.cu）；</p>\n<p>​</p>\n<pre><code class=\"language-c\">\n#pragma once\n#ifndef EXAMPLE_MATRIXASSIGN_KERNEL_H\n#define EXAMPLE_MATRIXASSIGN_KERNEL_H\n\n#include&lt;stdio.h&gt;\n#include\"cuda_runtime.h\"\n\n__global__ void testMatrixAssignKernel(float* data_input, float* data_output);\n\n\n#endif // !_EXAMPLE_MATRIXASSIGN_KERNEL_H_\n</code></pre>\n<p>File2：主程序文件CPU-Host端程序（example1main.cu）；</p>\n<pre><code class=\"language-C\">\n__global__ void testMatrixAssignKernel(float *data_input,float *data_output){\n\n\t//shared memory,extern表示大小由host端的Ns参数确定\n\textern __shared__ float sdata[];\n\n\tconst unsigned int bid = blockIdx.x; //线程所在的block的索引号\n\tconst unsigned int tid_in_block = threadIdx.x; //线程在block中的位置\n\tconst unsigned int tid_in_grid = blockDim.x * blockIdx.x + threadIdx.x;\n\n\t//按行划分任务时，线程在整个grid中的位置\n\n  // 将数据从global memory读入shared memory\n\tsdata[tid_in_block] = data_input[tid_in_grid];\n\t//读入数据后进行一次同步，保证计算时所有数据均已到位\n\t__syncthreads();\n\n\t// 计算\n\tsdata[tid_in_block] = (float)tid_in_grid;\n\t//  sdata[tid_in_block] *= (float)tid_in_block;\n\t//  sdata[tid_in_block] *= (float)tid_in_grid;\n\n\t  //进行同步，确保要写入的数据已经被更新\n\t__syncthreads();\n\n\t// 将shared memory中的数据写到global memory\n\tdata_output[tid_in_grid] = sdata[tid_in_block];\n\n\n}\n</code></pre>\n<p>由上可知，最简单的<code>__gloabal__</code>程序由以下的过程组成：</p>\n<ol>\n<li>分配<span class=\"math inline\">\\(shared \\space memory\\)</span>；</li>\n<li>将<span class=\"math inline\">\\(global\\space memory\\)</span> 中的数据读入<span class=\"math inline\">\\(shared \\space memory\\)</span>;</li>\n<li>将进行计算，将结果写到<span class=\"math inline\">\\(shared \\space memory\\)</span>;</li>\n<li>将<span class=\"math inline\">\\(shared\\)</span>中的结果写到<span class=\"math inline\">\\(global \\space memory\\)</span> ;</li>\n</ol>\n<p>​         进行一次GPU计算，要在多种存储器进行几次数据传输，要消耗相当多的时间。这导致了较大的延迟，这导致使<span class=\"math inline\">\\(GPU\\)</span> 不适合处理一些实时性要求很高的应用。不同存储器间的数据传输速率和使用方法有很大差异，开发人员需要根据硬件的特点来设计算法，以优化存储器访问。在理想情况下，在所有的存储器传输进行的同时，GPU的各个核心也始终在进行计算，这样就能够很好的隐藏各种访问延迟。CUDA 并不是一种完全硬件透明的语言，程序员需要根据硬件特征将任务进行合理的分解，在编程时对数据传输和寄存器访问进行优化。</p>\n<p>​       <code>__global__</code>前缀表示这一段代码是cuda GPU端内核函数。内核函数运行在设备上，其返回类型必须为void。<code>__global__</code>函数中是每一个线程要执行的语句，但由于<span class=\"math inline\">\\(shared\\space memory\\)</span>和同步的存在，在最好将<code>__global__</code>函数理解为对每一个block的行为的描述。</p>\n<p>​        在这一端内核函数中，首先定义了<span class=\"math inline\">\\(shared \\space memory\\)</span> 中的变量；然后根据内建变量定义每一个block和thread的索引，对任务进行划分；最后，每一个线程执行了相同的求和运算，但处理数据不同，由线程的索引决定的。程序员在编写<code>__global__</code>函数之前，要先对任务进行划分，设计各个block的工作流程后，做到成竹在胸。</p>\n<p>​        由于CUDA采用了两层并行，因此本例在划分任务时，每个thread在grid中的索引<span class=\"math inline\">\\(tid\\_in\\_grid\\)</span> 是由thread所在block内编号tid计算得来的。计算出每个线程的索引后，就可以根据索引处理线程中不同的数据，请读者好好体会这一点。</p>\n<p>​      <code>extern __shared__ float sdata[]</code> 在shared  memory中为数组data动态分配了空间。<code>extern</code> 在设备端和主机端有不同的含义：<code>__device__</code>和<code>__global__</code> 函数中表示动态分配，而在主机端函数中表示外部变量。如果要静态分配一块 <code>shared memory</code>，那么在<code>__shared__</code>之前就不加<code>extern</code>，还必须在[]中写上要分配的字节数。动态分配的shared memory大小，是&lt;&lt;&lt;&gt;&gt;&gt;的执行参数中第三个参数规定的大小。关于<code>shared memory</code>大小。</p>\n<p>​        CUDA定义了一些内建变量如下：</p>\n<ol>\n<li>gridDim： 网格的维度的变量，dim3类型</li>\n<li>blockIdx:    块的索引变量，unit3类型</li>\n<li>blockDim：块的维度变量，dim3类型</li>\n<li>threadIdx：块内的线程索引变量，unit3类型</li>\n<li>warpSize：线程中的warp大小，int类型</li>\n</ol>\n<p>其输出结果：</p>\n<p><img alt=\"输出结果\" class=\"lazyload\" /></p>\n<p>​</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-05 18:33</span>&nbsp;\n<a href=\"https://www.cnblogs.com/GeophysicsWorker\">GeoFXR</a>&nbsp;\n阅读(<span id=\"post_view_count\">7</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "[微服务进阶场景实战] - 如何处理好微服务之间千丝万缕的关系",
      "link": "https://www.cnblogs.com/yhup/p/19445135",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yhup/p/19445135\" id=\"cb_post_title_url\" title=\"发布于 2026-01-06 01:55\">\n    <span>[微服务进阶场景实战] - 如何处理好微服务之间千丝万缕的关系</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"[微服务进阶场景实战] - 如何处理好微服务之间千丝万缕的关系\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/2428649/202601/2428649-20260106015512936-1613272495.png\" />\n        本文探讨了微服务架构中依赖关系复杂化的挑战及解决方案。通过分析商品、订单等核心服务的交互场景，揭示了聚合接口归属混乱和服务依赖网状化两大痛点。项目组引入API层和BFF模式进行架构优化：API层负责数据聚合与业务编排，BFF为不同客户端定制专属接口。技术实现采用Spring Cloud三层架构（网关、BFF、后台服务），并通过公共库、独立服务或容忍重复等策略解决代码复用问题。最终形成垂直领域团队与水平BFF团队的矩阵分工模式，在保持架构清晰的同时提升开发效率。该方案有效降低了微服务间的耦合度，为复杂业务系统\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在上一章中，我们探讨了服务间频繁数据依赖的场景。除了这类需要频繁获取其他服务数据的场景，在实际开发中，我们往往还会面临另一个棘手问题——服务间的依赖关系过于杂乱。本章我们将聚焦于如何有效缓解微服务依赖复杂度的挑战。</p>\n<p>首先，让我们把完整的业务场景梳理清楚。</p>\n<h1 id=\"1-业务场景如何处理好微服务之间千丝万缕的关系\">1 业务场景：如何处理好微服务之间千丝万缕的关系</h1>\n<p>本节所涉及的系统主要包括商品、订单、加盟商、门店（运营）、工单（门店）等核心服务，其他辅助服务暂不展开。</p>\n<p>系统面向两类终端用户：一是客户使用的 App，二是供公司内部员工及加盟商员工使用的运营 App。后者用户角色多样，包括总部商品管理员、总部门店运营、加盟商员工、门店工作人员等，各角色内部还可能进一步细分权限。</p>\n<p>整体后台服务架构如下图所示</p>\n<p><img alt=\"在这里插入图片描述\" src=\"https://img2024.cnblogs.com/blog/2428649/202601/2428649-20260106015419558-1298428859.png\" /></p>\n<p>网关层在这里承担了几个关键职责：</p>\n<ol>\n<li><strong>路由</strong>：所有请求统一经过网关，由网关根据 URI 将请求分发至对应的后台服务，并在多节点环境下承担负载均衡。</li>\n<li><strong>认证</strong>：集中完成请求的身份认证与权限校验。</li>\n<li><strong>监控</strong>：记录全量 API 请求日志，便于 API 管理系统进行调用管理与性能监控。</li>\n<li><strong>限流熔断</strong>：流量过大时可在网关层限流；当后端服务响应延迟或故障时，可主动熔断，以保护后端资源并避免影响用户体验。</li>\n</ol>\n<p>这个架构看起来相当标准，甚至有点“教科书”式的完美——有点像经典的 Spring Cloud 架构。但它真的能应对所有实际场景吗？我们来看两个典型的例子：</p>\n<ol>\n<li><strong>一个页面需要聚合多处数据</strong><br />\n例如运营 App 首页，需根据用户角色动态展示信息。若用户是门店运营人员，页面需显示：工单数量、最近工单、销售订单数据、待处理订单、库存低于安全值的商品等。这些数据分散在多个服务中。</li>\n<li><strong>一次操作涉及多个服务状态变更</strong><br />\n例如处理一个工单，可能同时需要更新库存、修改销售订单状态，并变更工单本身的状态。</li>\n</ol>\n<p>于是，第一个让人头疼的问题来了：<strong>这类接口应该放在哪个服务里？</strong></p>\n<p>在实际设计过程中，团队经常为此反复讨论。当然，最终总能达成某个共识——比如第一个首页聚合接口，可能会放在门店服务中，形成下图所示的调用关系：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"https://img2024.cnblogs.com/blog/2428649/202601/2428649-20260106015419560-2088119564.png\" /></p>\n<p>而第二个工单处理接口，则可能放在工单服务中，形成另一张调用图：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"https://img2024.cnblogs.com/blog/2428649/202601/2428649-20260106015419569-1514851484.png\" /></p>\n<p>接着来看第二个问题：由于类似需求非常多，服务间频繁互相调用，时间一长，依赖关系就会变得像一团乱麻，如下图所示。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"https://img2024.cnblogs.com/blog/2428649/202601/2428649-20260106015419617-1678190778.png\" /></p>\n<p><img alt=\"在这里插入图片描述\" src=\"https://img2024.cnblogs.com/blog/2428649/202601/2428649-20260106015419651-573858958.png\" /></p>\n<p>这种错综复杂的依赖会给迭代带来“地狱级”的体验——我们在之前讨论微服务痛点的文章中已详细描述过，这里不再赘述。</p>\n<p>简单总结，当前系统面临两个核心痛点：</p>\n<ol>\n<li>针对需要聚合多方数据的接口，决策其归属服务效率低下，且容易导致职责划分不一致；</li>\n<li>服务间依赖网络复杂混乱，难以理清。</li>\n</ol>\n<p>为了解决这两个问题，项目组最终决定——<strong>抽象出一个独立的 API 层</strong>。</p>\n<h1 id=\"2-api层\">2 API层</h1>\n<p>通常，客户端（如App、网页）的接口会面临三类核心需求：</p>\n<ol>\n<li><strong>聚合</strong>：一个页面需要展示来自多个后台服务（如商品、订单、用户）的信息，这就要求后端提供一个能“打包”这些数据的接口。</li>\n<li><strong>分布式调用</strong>：用户的一个操作（如提交订单）可能需要按顺序或同时更新多个服务中的数据，这涉及到跨服务的业务编排。</li>\n<li><strong>装饰与适配</strong>：直接来自后台服务的数据格式可能不适合前端直接使用，需要剔除无用字段、转换数据结构或封装额外的状态信息。</li>\n</ol>\n<p>为了系统性地解决这些问题，项目组决定在客户端与后台微服务之间，插入一个专门的 <strong>API层</strong>。此时的架构演进如下图所示：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"https://img2024.cnblogs.com/blog/2428649/202601/2428649-20260106015419572-1252848771.png\" /></p>\n<p><strong>这个设计带来了立竿见影的好处：</strong></p>\n<ol>\n<li><strong>接口归属决策变得简单</strong>：遵循一条清晰的原则——<strong>凡是涉及数据聚合、业务编排或格式转换的逻辑，一律放在API层；凡是涉及核心业务数据读写（落库/查询）的逻辑，则归属到数据所在的服务</strong>。这极大地减少了团队间关于“接口该做在谁家”的争论。</li>\n<li><strong>服务间依赖得以简化</strong>：后台微服务之间不再为了页面渲染或复杂操作而相互直接调用，依赖关系收敛为 <strong>API层单向调用各个后台服务</strong>。后台服务得以保持职责单一和高度内聚。</li>\n</ol>\n<p>架构看似更优雅了，但很快，<strong>新的挑战</strong>随着客户端的多样化而出现。</p>\n<h1 id=\"3-客户端适配问题\">3 客户端适配问题</h1>\n<p>系统通常需要服务于多种客户端：原生App、H5页面、PC网页、微信小程序等。理想的统一调用模式如下：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"https://img2024.cnblogs.com/blog/2428649/202601/2428649-20260106015419575-1927764236.png\" /></p>\n<p>然而，这种统一模式在实践中会遭遇如下痛点：</p>\n<ol>\n<li><strong>体验差异化需求</strong>：不同客户端的页面承载能力与交互逻辑不同。例如，App首页可能信息丰满，而小程序版本则要求极简。这迫使后台的同一个API接口需要内置复杂的逻辑，来判别客户端类型并返回差异化数据。</li>\n<li><strong>频繁的前端需求变动</strong>：前端迭代速度快，经常“加一个字段，减一个字段”。为了性能（遵循数据最小化原则），后端不得不频繁发布新版本来配合这些细微改动。</li>\n<li><strong>版本兼容复杂度激增</strong>：结合上述两点，后台服务在发布新版本时，必须同时考虑所有客户端版本的兼容性问题，维护成本和风险呈指数级上升。</li>\n</ol>\n<p>为了解决这些耦合与效率问题，<strong>BFF（Backend for Frontend）模式</strong>便被引入。</p>\n<h1 id=\"4-bffbackendforfront\">4 BFF（BackendforFront）</h1>\n<p>BFF并非一种具体的架构，而是一种<strong>设计模式</strong>。其核心理念是：<strong>为不同的前端渠道量身定制专属的后端API服务</strong>。架构随之演变为：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"https://img2024.cnblogs.com/blog/2428649/202601/2428649-20260106015419649-1951652168.png\" /></p>\n<p>不同的客户端请求经过同一个网关后会分别重定向到专门为这种客户端设计的API服务（WX API即用于微信小程序的API）。</p>\n<p><strong>这样做的好处非常直接：</strong></p>\n<ul>\n<li><strong>深度优化</strong>：每个BFF服务只专注于一种客户端，可以为其进行极致的数据聚合和裁剪，响应更高效。</li>\n<li><strong>独立发布</strong>：各客户端的接口迭代可以完全独立，无需与其他渠道捆绑排期，提升了交付效率。</li>\n<li><strong>解耦与自治</strong>：前端团队与后端团队在BFF层可以有更清晰的协作边界。</li>\n</ul>\n<p>上图中的BFF架构是通用的，但还需要通过深入研究具体业务来完善。</p>\n<p>在本项目中，业务体量极为庞大（涉及近百个微服务，数百人的研发团队），且按业务域划分为新零售、供应链、财务等多个部门。每个部门都需要面向多种客户端（公司主App、部门自己的小程序/H5）提供功能。</p>\n<p>因此，最终的架构自然演进为 <strong>“按业务域垂直划分的BFF矩阵”</strong>，如下图所示：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"https://img2024.cnblogs.com/blog/2428649/202601/2428649-20260106015419573-756909560.png\" /></p>\n<p>这个架构基本上就是每个部门都会维护自己的一系列API服务。接下来展开讨论一些细节问题。</p>\n<h2 id=\"41-技术架构上怎么实现\">4.1 技术架构上怎么实现</h2>\n<p>整个BFF架构建立在成熟的 <strong>Spring Cloud</strong> 技术栈之上，其核心可清晰地划分为三个层次，具体架构如下图所示：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"https://img2024.cnblogs.com/blog/2428649/202601/2428649-20260106015419650-680575222.png\" /></p>\n<p><strong>各层职责与技术选型如下：</strong></p>\n<ol>\n<li><strong>网关层</strong>：采用 <strong>Spring Cloud Zuul</strong> 作为统一入口。其核心工作是服务发现（从ZooKeeper注册中心拉取可用的BFF服务实例）、路由转发，以及执行认证、限流等全局过滤器。它通过 <strong>Feign</strong> 客户端以声明式方式调用下游的BFF服务。</li>\n<li><strong>BFF/API服务层</strong>：每个BFF服务都是一个独立的 <strong>Spring Web</strong> 应用。关键特性在于<strong>无状态</strong>且<strong>不持有自己的数据库</strong>。它的核心职责是进行业务编排：聚合多个后台服务的数据、串行或并行发起分布式调用、以及对返回的数据进行装饰（字段裁剪、格式转换等）。它同样通过 <strong>Feign</strong> 调用后台微服务。</li>\n<li><strong>后台服务层</strong>：即传统的微服务，也是 <strong>Spring Web</strong> 应用。它们<strong>拥有独立的数据库和缓存</strong>，实现核心领域逻辑与数据持久化，是整个系统的业务能力基石。</li>\n</ol>\n<h2 id=\"42-api之间的代码重复怎么解决\">4.2 API之间的代码重复怎么解决</h2>\n<p>在多BFF的架构下，代码重复是一个需要权衡的问题。H5与小程序通常需求差异较大，重复逻辑主要集中在<strong>PC端与App端的BFF</strong>中，因为两者页面功能常相似，仅布局不同。对此，不同部门根据自身上下文，采取了三种务实策略：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">策略</th>\n<th style=\"text-align: left;\">具体做法</th>\n<th style=\"text-align: left;\">适用场景与考量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>1. 公共库（JAR）</strong></td>\n<td style=\"text-align: left;\">将共享逻辑封装成内部JAR包，供各BFF服务引入依赖。</td>\n<td style=\"text-align: left;\">适用于通用、稳定且逻辑较复杂的代码。优点是复用彻底；缺点是JAR版本升级需要所有依赖方协调发布，存在耦合。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>2. 公共API服务</strong></td>\n<td style=\"text-align: left;\">抽取一个独立的 <code>CommonAPI</code> 服务，其他BFF通过RPC调用它。</td>\n<td style=\"text-align: left;\">适用于可独立成服务、有明确边界的共享能力。引入了网络调用开销和新的故障点，需权衡收益。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>3. 容忍重复</strong></td>\n<td style=\"text-align: left;\">直接保留各BFF中的重复代码。</td>\n<td style=\"text-align: left;\">当重复量小、逻辑简单且变化不频繁时，维护重复代码的成本可能<strong>低于</strong>管理一个公共组件（JAR或服务）的协调与升级成本。这是一种经过评估的理性选择。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>关于“透传代理”接口的特别讨论：</strong><br />\n实践中，会存在一些BFF接口，其输入输出与后台服务的接口<strong>完全一致</strong>，仅做简单代理转发。针对这类“看似多余”的代码，项目组曾深入讨论是否要优化掉，提出了两种方案：</p>\n<ul>\n<li><strong>方案A（网关直调）</strong>：让网关绕过BFF，直接调用后台服务。这因<strong>严重破坏架构分层</strong>、导致职责混乱而被迅速否决。</li>\n<li><strong>方案B（智能拦截）</strong>：在BFF层设置拦截器，对未匹配的请求尝试直接转发至后台服务。此方案争论良久，最终结论是：它虽然能减少一些代码，但<strong>显著增加了系统的复杂度和不确定性</strong>（调试和问题追踪变得困难）。而编写这些“薄代理”的代码成本极低，保留它们既能维持架构清晰，维护成本也完全可控。因此，<strong>决定保留这些代理接口</strong>——这在工程上是一个“用可接受的微小冗余换取架构简洁性与可维护性”的典型决策。</li>\n</ul>\n<h2 id=\"43-后台服务与api服务的开发团队如何分工\">4.3 后台服务与API服务的开发团队如何分工</h2>\n<p>在团队组织上，项目采用了 <strong>“垂直领域团队 + 水平BFF团队”</strong> 的矩阵式分工：</p>\n<ul>\n<li><strong>专职BFF团队</strong>：设立一个集中的团队，负责所有BFF服务的开发与维护。其核心优势在于能<strong>统揽全局前端需求</strong>，作为“设计中心”确保接口划分的合理性与一致性，有效避免了后台服务边界模糊或功能重复建设的问题。</li>\n<li><strong>领域服务团队</strong>：根据业务领域（如商品、订单、供应链）划分多个小组，专注于各自领域的核心业务逻辑与数据服务开发。</li>\n</ul>\n<p>这种分工的好处是规划统一、接口规范。但一个现实挑战是：BFF层的业务逻辑相对偏重于聚合与适配，技术复杂性可能不如底层领域服务。为了保持团队技术活力和成员长期发展，项目引入了<strong>定期的岗位轮换制度</strong>，让开发人员能在BFF团队与领域团队间流动。</p>\n<h1 id=\"5-小结\">5 小结</h1>\n<p>关于BFF（Backend for Frontend）模式的探讨至此告一段落。需要明确的是，本章的核心目的并非推介某一种具体的技术栈或框架，而是系统性地阐述在微服务环境下，<strong>如何对接口的研发进行全局性的管理与架构设计</strong>。因此，文中涉及的内容更多地侧重于高层的设计思路、通用的决策模式以及在真实项目中必然会遭遇的典型场景。</p>\n<p>尽管章节标题以“BFF”命名，且其作为一种专属前端的后端模式是讨论的起点，但通篇的深层逻辑实则是<strong>以BFF的理念来重构和梳理整个后端服务的分层与协作关系</strong>。可以说，BFF所代表的“为消费端定制与聚合”的思想，是贯穿整个架构演进过程的一条主线。</p>\n<p>至此，我们关于微服务核心架构设计的系列讨论已暂告一个段落。从下一部分开始，我们将把视角转向 <strong>开发运维（DevOps）的实战领域</strong>，探讨在如此分布式、多团队的复杂系统中，如何通过工程效能工具与流程建设，来保障这一系列精良的设计能够被高效、稳定且可持续地交付与运行。论如何让开发更高效。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-06 01:55</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yhup\">yihuiComeOn</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "收藏夹里的干货都在“吃灰”？这条指令把你的大脑变成“高压缩比”知识库",
      "link": "https://www.cnblogs.com/huizhudev/p/19445127",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/huizhudev/p/19445127\" id=\"cb_post_title_url\" title=\"发布于 2026-01-06 01:36\">\n    <span>收藏夹里的干货都在“吃灰”？这条指令把你的大脑变成“高压缩比”知识库</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"收藏夹里的干货都在“吃灰”？这条指令把你的大脑变成“高压缩比”知识库\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3695776/202601/3695776-20260106013604826-1540183753.png\" />\n        别让收藏夹吃灰！本文分享一条能强制执行“费曼学习法”的AI指令，将晦涩的技术文档和书籍“编译”成清晰的知识框架、通俗类比和记忆口诀。把AI变成你的认知压缩工具，实现从“囤积”到“内化”的降维打击。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>承认吧，我们都是<strong>“数字松鼠”</strong>。</p>\n<p>看到一篇《微服务架构详解》，收藏！<br />\n刷到一个《10分钟精通Rust》，稍后读！<br />\n发现一本《算法导论》PDF，下载保存！</p>\n<p>然后呢？它们就像你Steam库里的游戏一样，静静地躺在硬盘的某个角落，直到你换了下一台电脑。</p>\n<p><strong>囤积知识带来的不是充实感，而是更深层的技术焦虑。</strong> 我们的大脑I/O带宽是有限的，试图用“遍历”的方式去处理海量信息，结果只能是Buffer Overflow（缓冲区溢出）。</p>\n<p>在信息爆炸的时代，<strong>“学过”和“学会”之间，隔着一个巨大的“编译”过程。</strong></p>\n<p>只阅读不总结，就像写代码不编译，永远跑不起来。而今天，我要把这个最耗时的“编译”过程，外包给最擅长处理文本的AI。</p>\n<p><img alt=\"收藏夹里的干货都在“吃灰”？这条指令把你的大脑变成“高压缩比”知识库\" class=\"lazyload\" /></p>\n<h2 id=\"-费曼学习法的数字化实现\">🧠 费曼学习法的“数字化”实现</h2>\n<p>理查德·费曼曾说：“如果你不能简单地解释它，你就没有真正理解它。”</p>\n<p>但问题是，我们不仅忙，而且懒。把复杂的概念拆解、重组、用人话讲出来，这个过程太烧脑了。</p>\n<p>这正是我设计这条<strong>「知识点总结 AI 指令」</strong>的初衷。它不是一个简单的“摘要工具”，而是一个强制执行<strong>费曼学习法</strong>的<strong>“认知编译器”</strong>。</p>\n<p>它会强迫 AI 扮演一位深谙认知心理学的“学习大师”，把那些晦涩的官方文档、枯燥的教科书、长篇大论的技术博客，<strong>“无损压缩”</strong>成你大脑最容易兼容的格式。</p>\n<h3 id=\"️-复制这个指令给你的大脑装个解压软件\">🛠️ 复制这个指令，给你的大脑装个“解压软件”</h3>\n<p>这条指令的核心逻辑是<strong>“降维打击”</strong>。它要求 AI 将高维的复杂知识，拆解为<strong>核心概念、通俗类比、记忆挂钩、自测验证</strong>四个维度。</p>\n<p>不管你是要备考系统架构师，还是想搞懂什么是 Transformer 模型，扔给它，它就能吐出“人话”。</p>\n<pre><code class=\"language-markdown\"># 角色定义\n你是一位资深的学习方法专家和知识整理大师，拥有10年以上的教育培训经验。你擅长运用费曼学习法、思维导图、记忆宫殿等多种学习技巧，能够将复杂的知识体系拆解为清晰、易懂、易记的知识点。你深谙认知心理学原理，善于构建知识框架，帮助学习者高效掌握和内化知识。\n\n# 任务描述\n请针对以下学习内容，进行专业的知识点总结和整理。你的目标是帮助我构建清晰的知识框架，提炼核心要点，并提供有效的记忆和理解方法。\n\n**输入信息**:\n- 学习主题/内容: [请粘贴或描述需要总结的学习内容]\n- 学科领域: [如：数学、物理、历史、编程、经济学等]\n- 学习目的: [如：考试备考、技能提升、兴趣探索、工作应用等]\n- 当前水平: [如：零基础、有一定了解、中级、进阶等]\n- 时间要求: [如：快速概览5分钟、深度学习30分钟、系统掌握等]\n\n# 输出要求\n\n## 1. 内容结构\n请按照以下结构输出知识点总结：\n\n### 📌 核心概念速览\n- 用1-3句话概括这个知识点的本质\n- 说明这个知识点在整个知识体系中的位置和重要性\n\n### 🎯 关键知识点\n- 提炼3-7个核心知识点\n- 每个知识点用简洁的标题+详细解释的形式呈现\n- 标注重要程度（⭐必考/必会、🔸重点、💡拓展）\n\n### 🔗 知识框架图\n- 用文字版思维导图或层级结构展示知识点之间的关系\n- 标明核心概念、分支概念、关联概念\n\n### 💡 通俗理解\n- 用生活化的类比或比喻解释难点\n- 提供具体的例子帮助理解\n\n### 📝 记忆技巧\n- 提供口诀、联想记忆、首字母缩写等记忆方法\n- 设计1-2个帮助记忆的小故事或场景\n\n### ✅ 自测清单\n- 设计3-5个自测问题检验理解程度\n- 问题由易到难排列\n\n### 🔄 关联拓展\n- 与该知识点相关的其他知识点\n- 推荐的进一步学习方向\n\n## 2. 质量标准\n- **准确性**: 知识点必须准确无误，专业术语使用规范\n- **完整性**: 覆盖该主题的所有核心要点，不遗漏关键信息\n- **简洁性**: 语言精炼，避免冗余，每个要点言简意赅\n- **逻辑性**: 知识点之间的关系清晰，层次分明\n- **实用性**: 便于记忆和应用，真正能帮助学习者\n\n## 3. 格式要求\n- 使用Markdown格式，层次清晰\n- 善用表格对比相似概念\n- 重点内容使用**加粗**或`高亮`标注\n- 适当使用emoji增强可读性\n- 总字数控制在800-2000字之间（根据内容复杂度调整）\n\n## 4. 风格约束\n- **语言风格**: 通俗易懂但不失专业性，像一位耐心的老师在讲解\n- **表达方式**: 第二人称\"你\"，增强亲切感和互动感\n- **专业程度**: 根据用户的当前水平调整，零基础更注重通俗，进阶更注重深度\n\n# 质量检查清单\n\n在完成输出后，请自我检查：\n- [ ] 核心概念是否用最简洁的语言解释清楚？\n- [ ] 知识框架是否完整且逻辑清晰？\n- [ ] 是否提供了有效的记忆技巧？\n- [ ] 通俗类比是否贴切易懂？\n- [ ] 自测问题是否能有效检验理解程度？\n\n# 注意事项\n- 确保知识点的准确性，如有不确定的内容请标注说明\n- 避免使用过于专业的术语，如必须使用则提供解释\n- 知识点总结要突出重点，区分\"必须掌握\"和\"了解即可\"\n- 针对易混淆的概念，专门进行对比区分\n\n# 输出格式\n请严格按照上述结构输出，确保格式整洁、内容完整。如果输入的学习内容较多，可以分模块进行总结。\n</code></pre>\n<h2 id=\"️-实战测试把天书变成小抄\">⚡️ 实战测试：把“天书”变成“小抄”</h2>\n<p>为了验证这个“编译器”的性能，我找了一个让无数 Python 初学者头大的概念：<strong>列表推导式（List Comprehension）</strong>。</p>\n<p>如果不使用这个指令，你搜到的教程可能是一堆枯燥的语法糖解释。但看看 AI 拿到这个指令后输出了什么：</p>\n<p><strong>输入</strong>：</p>\n<blockquote>\n<p>学习主题：Python列表推导式<br />\n当前水平：基础语法已掌握<br />\n时间要求：快速概览10分钟</p>\n</blockquote>\n<p><strong>AI 输出的高能片段</strong>：</p>\n<blockquote>\n<p><strong>💡 通俗理解</strong><br />\n<strong>类比：流水线工厂</strong><br />\n想象一条生产流水线：</p>\n<ul>\n<li>原材料（可迭代对象）放在传送带上</li>\n<li>质检员（if条件）筛选合格品</li>\n<li>加工机器（表达式）对合格品进行加工</li>\n<li>最终产品装箱（新列表）</li>\n</ul>\n<p>普通写法 = 手工作坊，一步一步来<br />\n列表推导式 = 自动化流水线，一气呵成</p>\n</blockquote>\n<blockquote>\n<p><strong>📝 记忆技巧</strong><br />\n<strong>口诀</strong>: \"方括号里写循环，表达式放最前面，条件筛选放后面\"</p>\n</blockquote>\n<p>看到区别了吗？它没有堆砌术语，而是直接构建了一个<strong>心理模型（Mental Model）</strong>。这才是最高效的知识压缩。</p>\n<h2 id=\"-重新定义你的学习工作流\">🚀 重新定义你的“学习工作流”</h2>\n<p>在这个技术迭代比翻书还快的年代，<strong>“学习速度”就是你的核心竞争力</strong>。</p>\n<p>建议你把这个指令保存到你的 Note 工具里（或者直接作为 AI 助手的 Preset）。下一次，当你面对：</p>\n<ol>\n<li><strong>新技术的官方文档</strong>（太长不看版）</li>\n<li><strong>晦涩的学术论文</strong>（只看结论版）</li>\n<li><strong>枯燥的合规条例</strong>（要点提取版）</li>\n</ol>\n<p>别再做只管收藏的“松鼠党”了。<strong>Copy 指令 -&gt; 粘贴内容 -&gt; 获取“作弊纸”</strong>。</p>\n<p>把省下来的时间，去写代码，去构建产品，去创造真正的价值。毕竟，<strong>只有被消化的知识，才配叫“干货”。</strong></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-06 01:36</span>&nbsp;\n<a href=\"https://www.cnblogs.com/huizhudev\">realhuizhu</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "SK + Neo4j 实现简单问答系统",
      "link": "https://www.cnblogs.com/kklldog/p/19445097",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/kklldog/p/19445097\" id=\"cb_post_title_url\" title=\"发布于 2026-01-06 00:42\">\n    <span>SK + Neo4j 实现简单问答系统</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>大家好！</p>\n<p>在这个全民 RAG 的时代，人们似乎找到了一条蹭 AI 的捷径。大模型加上领域知识分分钟包装成知识库，智能体，垂直大模型？但在实际应用中，传统 RAG 并不能解决所有问题，尤其是需要复杂推理和关系分析的场景。知识图谱（Knowledge Graph）作为结构化语义网络，能更好地表达实体及其关系，补足 RAG 的不足。</p>\n<p>本文将结合 Neo4j 图数据库和大语言模型（LLM），介绍如何实现一个简单的问答系统。当然我也还在学习跟尝试当中，如有不当的地方请友好探讨。</p>\n<h2 id=\"什么是-knowledge-graph\">什么是 Knowledge Graph</h2>\n<p>知识图谱（Knowledge Graph）是一种通过节点和关系来表达知识的结构化方式。</p>\n<p><strong>节点（Node）</strong>：节点代表知识图谱中的实体，可以是人、地点、事物、事件等。例如，“张三”、“北京”、“苹果公司”都可以作为节点。</p>\n<p><strong>边（Edge）</strong>：边用于连接两个节点，表示它们之间存在某种关系。每条边都有方向和类型。例如，“张三”——[居住于]——&gt;“北京”，“苹果公司”——[创始人]——&gt;“乔布斯”。</p>\n<p><strong>关系（Relationship）</strong>：关系是边的具体类型，描述节点之间的语义联系。关系可以是“属于”、“包含”、“朋友”、“创始人”等。关系通常带有属性，比如时间、权重等。</p>\n<p>通过节点和边的组合，知识图谱能够以图结构的方式表达复杂的现实世界知识，实现语义理解和推理。</p>\n<h2 id=\"知识图谱与rag的对比\">知识图谱与RAG的对比</h2>\n<p>RAG（Retrieval-Augmented Generation，检索增强生成）是一种结合检索与生成的AI问答技术。它通常通过向量数据库检索相关文档片段，然后用大模型进行生成式回答。</p>\n<p><strong>对比点：</strong></p>\n<ul>\n<li><strong>结构化 vs 非结构化</strong>：知识图谱以结构化的图数据存储知识，节点和关系清晰；RAG主要处理非结构化文本，通过语义检索相关内容。</li>\n<li><strong>推理能力</strong>：知识图谱支持复杂的语义推理和关系查询，适合多跳问答和实体关系分析；RAG更依赖检索结果和大模型的生成能力，推理能力受限于检索和模型本身。</li>\n<li><strong>更新与扩展</strong>：知识图谱需要人工或自动化方式维护结构和关系，扩展时需保证一致性；RAG可以直接添加新文档，扩展更灵活。</li>\n<li><strong>应用场景</strong>：知识图谱适合企业知识管理、推荐、风控等场景；RAG适合快速搭建问答系统、文档检索、智能客服等。</li>\n</ul>\n<p>实际应用中，知识图谱和RAG可以结合使用，既利用结构化知识进行推理，又用检索增强生成提升问答的广度和灵活性。</p>\n<h2 id=\"neo4j\">Neo4j</h2>\n<p>本次试验我们使用 Neo4j 作为图数据库。<br />\nNeo4j 是一个高性能的开源图数据库，专门用于存储和管理图结构数据。它以节点、关系和属性为核心，能够高效地处理复杂的连接和关系查询。</p>\n<p><strong>Neo4j 的主要特点：</strong></p>\n<ul>\n<li><strong>原生图存储</strong>：Neo4j 采用原生图结构进行存储和处理，节点和关系都是一等公民，查询效率高。</li>\n<li><strong>强大的查询语言 Cypher</strong>：Cypher 是 Neo4j 的声明式图查询语言，语法简洁，易于表达复杂的图查询。</li>\n<li><strong>高性能关系查询</strong>：相比传统关系型数据库，Neo4j 在多跳关系、路径查找等场景下有显著性能优势。</li>\n<li><strong>灵活的数据模型</strong>：支持动态添加节点、关系和属性，适合不断变化的业务需求。</li>\n<li><strong>可扩展性和高可用性</strong>：支持集群部署，适合大规模数据和高并发访问。</li>\n</ul>\n<p>Neo4j 广泛应用于社交网络、推荐系统、知识图谱、风控反欺诈等领域，能够帮助企业高效地挖掘和分析数据中的关联关系。</p>\n<h2 id=\"初始化数据\">初始化数据</h2>\n<h3 id=\"安装-neo4j\">安装 Neo4j</h3>\n<p>安装的话使用 docker 非常的方便，不多说。</p>\n<pre><code>docker run \\\n    --restart always \\\n    --publish=7474:7474 --publish=7687:7687 \\\n    neo4j:2025.06.2\n</code></pre>\n<p>在我们进行试验前，需要先准备一些数据到 neo4j 的数据库里。这里采用 Neo4j 安装向导自带的一个关于演员与电影之间的知识库。包含 38 部电影与 133 个演员的信息。</p>\n<pre><code>\nCREATE CONSTRAINT movie_title IF NOT EXISTS FOR (m:Movie) REQUIRE m.title IS UNIQUE;\nCREATE CONSTRAINT person_name IF NOT EXISTS FOR (p:Person) REQUIRE p.name IS UNIQUE;\n\nMERGE (TheMatrix:Movie {title:'The Matrix'}) ON CREATE SET TheMatrix.released=1999, TheMatrix.tagline='Welcome to the Real World'\n\nMERGE (Keanu:Person {name:'Keanu Reeves'}) ON CREATE SET Keanu.born=1964\nMERGE (Carrie:Person {name:'Carrie-Anne Moss'}) ON CREATE SET Carrie.born=1967\nMERGE (Laurence:Person {name:'Laurence Fishburne'}) ON CREATE SET Laurence.born=1961\nMERGE (Hugo:Person {name:'Hugo Weaving'}) ON CREATE SET Hugo.born=1960\nMERGE (LillyW:Person {name:'Lilly Wachowski'}) ON CREATE SET LillyW.born=1967\nMERGE (LanaW:Person {name:'Lana Wachowski'}) ON CREATE SET LanaW.born=1965\nMERGE (JoelS:Person {name:'Joel Silver'}) ON CREATE SET JoelS.born=1952\n...\n\n\n</code></pre>\n<p><img alt=\"\" src=\"https://static.xbaby.xyz/wechat_2025-07-27_152130_404.png\" /></p>\n<h2 id=\"访问数据库\">访问数据库</h2>\n<p>使用 C# 去访问 Neo4j 呢也相当简单。安装相关的驱动把 cypher 发过去就行了。</p>\n<pre><code>  &lt;ItemGroup&gt;\n    &lt;PackageReference Include=\"Neo4j.Driver\" Version=\"5.28.2\" /&gt;\n  &lt;/ItemGroup&gt;\n</code></pre>\n<p>代码：</p>\n<pre><code>const string dbUri = \"neo4j://125.gen8.com:7687\";\nconst string dbUser = \"neo4j\";\nconst string dbPassword = \"neo4j@123\";\n\nawait using var driver = GraphDatabase.Driver(dbUri, AuthTokens.Basic(dbUser, dbPassword));\nawait driver.VerifyConnectivityAsync();\nConsole.WriteLine(\"Connection established.\");\n\nvar query = \"MATCH (n)-[r]-(m) RETURN *\";\nvar result = await driver.ExecutableQuery(query)\n    .WithConfig(new QueryConfig(database: \"neo4j\"))\n    .ExecuteAsync();\n</code></pre>\n<h2 id=\"实现-chatbot\">实现 chatbot</h2>\n<p>要实现这个 chatbot 呢，首先让我们来理一下整个流程：</p>\n<div class=\"mermaid\">graph TD\n    A[用户输入问题] --&gt; B[LLM 生成 Cypher 查询语句]\n    B --&gt; C[C# 代码访问 Neo4j 数据库]\n    C --&gt; D[Neo4j 返回查询结果]\n    D --&gt; E[LLM 总结并生成回答]\n    E --&gt; F[返回给用户]\n</div><p>流程说明：</p>\n<ol>\n<li>用户输入自然语言问题。</li>\n<li>LLM（大语言模型）将问题转化为 Cypher 查询语句。</li>\n<li>C# 程序将 Cypher 语句发送到 Neo4j 数据库。</li>\n<li>Neo4j 执行查询并返回结果。</li>\n<li>LLM 根据查询结果生成最终回答。</li>\n<li>答案返回给用户。</li>\n</ol>\n<p>直接看完整代码吧，测试模型试验 gpt-4.1，SK 什么的背景知识就不解释了，可以翻以前的文章。</p>\n<pre><code class=\"language-c#\">// Populate values from your OpenAI deployment\nvar modelId = \"gpt-4.1\";\nvar endpoint = \"https://kklldog-openai.openai.azure.com/\";\nvar apiKey = \"\";\n\n// Create a kernel with Azure OpenAI chat completion\nvar builder = Kernel.CreateBuilder();\nbuilder.AddAzureOpenAIChatCompletion(modelId, endpoint, apiKey);\n\nvar sk = builder.Build();\n\nvar chatCompletionService = sk.GetRequiredService&lt;IChatCompletionService&gt;();\n\n//var q = \"Who is Tom Cruise ?\";\n\nvar q = Console.ReadLine();\n\n// round1 =&gt; get cypher query\nChatHistory chatHistory = [\n    new() {\n        Role = AuthorRole.System,\n        Content = \"你是一个neo4j的专家，当收到问题后，请尝试给出可以帮助回答问题的 cypher 查询语句。\" +\n        \"你可以使用以下标签：\" +\n        \"Movie,Person \" +\n        \"你可以使用以下关系：\" +\n        \"ACTED_IN,DIRECTED,FOLLOWS,PRODUCED,REVIEWED,WROTE \" +\n        \"请直接返回cypher语句，不需要多余的内容\"\n    },\n    new() {\n        Role = AuthorRole.User,\n        Content = q\n    }\n];\nvar chatResponse = await chatCompletionService.GetChatMessageContentAsync(\n    chatHistory\n);\n\nstring query = chatResponse.ToString();\nConsole.WriteLine(query);\n\nconst string dbUri = \"neo4j://125.gen8.com:7687\";\nconst string dbUser = \"neo4j\";\nconst string dbPassword = \"neo4j@123\";\n\nawait using var driver = GraphDatabase.Driver(dbUri, AuthTokens.Basic(dbUser, dbPassword));\nawait driver.VerifyConnectivityAsync();\nConsole.WriteLine(\"Connection established.\");\n\nvar result = await driver.ExecutableQuery(query)\n    .WithConfig(new QueryConfig(database: \"neo4j\"))\n    .ExecuteAsync();\n\nvar answerTxt = JsonConvert.SerializeObject(result.Result);\nConsole.WriteLine(answerTxt);\n\n// round2 =&gt; get answer\nChatHistory chatHistory_1 = [\n    new() {\n        Role = AuthorRole.System,\n        Content = \"我会给你一段 cypher 语句，以及它的查询结果。请根据这些内容对问题进行回答，如果无法回答就说不知道。\" +\n        \"query:\" + query +  \n        \"answer:\" + answerTxt\n    },\n    new() {\n        Role = AuthorRole.User,\n        Content = q\n    }\n];\nvar chatResponse_1 = await chatCompletionService.GetChatMessageContentAsync(\n    chatHistory_1\n);\n\nConsole.WriteLine(chatResponse_1);\n</code></pre>\n<h3 id=\"运行程序\">运行程序</h3>\n<p>让我们试跑一下，输入问题：<code>How many movies does tom cruise acted in?</code></p>\n<pre><code>Hello, World!\nHow many movies does tom cruise acted in?\nMATCH (p:Person {name: \"Tom Cruise\"})-[:ACTED_IN]-&gt;(m:Movie)\nRETURN count(m) AS num_movies\nConnection established.\n[{\"num_movies\":3}]\nTom Cruise has acted in 3 movies.\n</code></pre>\n<h2 id=\"总结\">总结</h2>\n<p>本文介绍了如何结合 Neo4j 图数据库与大语言模型（LLM）实现一个简单的问答系统。通过知识图谱结构化存储信息，利用 LLM 自动生成 Cypher 查询语句，并用 C# 代码访问 Neo4j 获取结果，最后由 LLM 进行答案总结，实现了从自然语言到结构化知识的闭环。</p>\n<p>这种方案的优势在于：</p>\n<ul>\n<li>能够充分发挥知识图谱的语义推理和关系查询能力；</li>\n<li>LLM 自动生成查询语句，降低了用户的技术门槛；</li>\n<li>查询结果可直接用于生成自然语言答案，提升问答系统的智能化水平。</li>\n</ul>\n<p>未来可以进一步扩展：</p>\n<ul>\n<li>丰富知识图谱的数据和关系类型；</li>\n<li>优化 LLM 的提示词和上下文设计，提高查询准确率；</li>\n<li>支持更复杂的问题和多轮对话。</li>\n</ul>\n<p>总之，Neo4j + LLM 的结合为智能问答和知识管理提供了强大的技术基础，值得在更多场景中探索和应用。</p>\n\n</div>\n<div id=\"MySignature\">\n    <div id=\"AllanboltSignature\">        \n<p id=\"PSignature\">       \nQQ群：1022985150 VX：kklldog 一起探讨学习.NET技术\n<br />\n作者：<a href=\"http://www.cnblogs.com/kklldog\" target=\"_blank\">Agile.Zhou(kklldog)</a>            \n<br /> \n出处：<a href=\"http://www.cnblogs.com/kklldog/\" target=\"_blank\">http://www.cnblogs.com/kklldog/</a>\n<br />本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。\n </p>  \n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-06 00:42</span>&nbsp;\n<a href=\"https://www.cnblogs.com/kklldog\">Agile.Zhou</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "新版微信4.1及以上dat文件转图片",
      "link": "https://www.cnblogs.com/wang_xy/p/19444824",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wang_xy/p/19444824\" id=\"cb_post_title_url\" title=\"发布于 2026-01-05 21:48\">\n    <span>新版微信4.1及以上dat文件转图片</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>微信电脑版现在已经是日常工作生活必不可少的工具，有时删除了聊天记录或被系统清理软件清理了，但还想查看曾经的微信聊天图片。<br />这个时候辛辛苦苦找到了文件，却发现无法查看，因为微信电脑版为了保护我们的隐私，把原先的图片格式文件给做了加密处理变成了DAT格式，这里不得不给微信一个大大的赞。<br />那么我们就只能是看着文件没有办法了么？答案当然是：有方法的。下面看看应该如何处理微信DAT图片转换jpg图片格式（或gif或png）吧。<br />一键批量将微信聊天接受到的加密存储DAT图片文件转化为普通图片。<br /><span style=\"color: rgba(255, 0, 255, 1);\">通过查看转化后的图片，您可以：</span><br /><span style=\"color: rgba(255, 0, 255, 1);\">（1）清理无用的历史图片，节省电脑硬盘存储空间。</span><br /><span style=\"color: rgba(255, 0, 255, 1);\">（2）恢复寻找重要照片资料。</span></p>\n<p>下载地址：</p>\n<p>（1）点击下载：<a href=\"https://weijiesoft.lanzouu.com/iJ7Bq3f44h8h\" rel=\"noopener nofollow\" target=\"_blank\">&gt;&gt;&gt;点我下载&lt;&lt;&lt;</a></p>\n<p>（2）或复制链接到浏览器下载：&nbsp;https://weijiesoft.lanzouu.com/iJ7Bq3f44h8h</p>\n<p>他支持微信4.1版本及以上，也支持微信3.9.x的老版本微信的dat的转换图片。</p>\n<p>支持批量转换，支持单个转换。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/687256/202601/687256-20260105213100992-1663916089.png\" /></p>\n<p>&nbsp;（1）单个转换</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/687256/202601/687256-20260105214431641-1449253764.png\" /></p>\n<p>&nbsp;</p>\n<p>（2）批量转换</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/687256/202601/687256-20260105213422839-134454665.png\" /></p>\n<p>&nbsp;</p>\n</div>\n<div id=\"MySignature\">\n    <div id=\"MySignature\" style=\"display: block;\"><br />\n<fieldset style=\"padding: 10px; margin: 10px; background-color: #708090; width: 850px;\">\n<p><span style=\"color: #fff;\">版权声明</span></p><p>\n</p><hr style=\"color: #fff;\" />\n<p><span style=\"color: #fff;\">作者：</span><span style=\"color: #fff;\">Wagwei</span></p>\n  <p><span style=\"color: #fff;\">联系方式：</span><span style=\"color: #fff;\">\n   \n   \n   <span><a class=\"btn btn-qq\" href=\"\"><img alt=\"qq:453357830\" border=\"0\" src=\"http://pub.idqqimg.com/wpa/images/counseling_style_52.png\" title=\"与我聊天\" /></a></span>\n\n\n\n    QQ:453357830\n    </span></p>\n<p><span style=\"color: #fff;\">出处：</span><a href=\"http://www.cnblogs.com/wagxy\" style=\"color: #fff;\" target=\"_blank\">博客园 Wagwei 的技术博客--http://www.cnblogs.com/wagxy</a> </p>\n<p><span style=\"color: #fff;\">您的支持是对博主最大的鼓励，感谢您的认真阅读。</span></p>\n<p><span style=\"color: #fff;\">本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</span></p>\n</fieldset></div>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-05 21:48</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wang_xy\">Wagwei</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}