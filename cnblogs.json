{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "lidar 3d object detection",
      "link": "https://www.cnblogs.com/DemoFX/p/19479527",
      "published": "",
      "description": "<div class=\"postTitle\">\n\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/DemoFX/p/19479527\" id=\"cb_post_title_url\" title=\"发布于 2026-01-14 00:13\">\n    <span>lidar 3d object detection</span>\n    \n\n</a>\n\n\t</div>\n\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        lidar三维物体检测\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>最近在网上偶然发现一个做三维物体检测的开发包OpenPCDet,加上一直准备学学python,就决定动手一把。网上已经有不少开发的文档，在编译的过程中也参考了不少网上的资料，现在写点自己的体会。<br />\n首先安装python,因为用的win7,所以一开始使用的python38,这已经是支持win7的最高版本了，然后下了pytorch,同时下载了其他项目依赖的模块，在安装spconv的时候遇到一些问题，我在网上查的是要使用spconv-cu102支持cuda，而且spconv和版本cumm的cuda号要一致，但是还是出现DLL找不到的问题，在网上也看到有人遇到类似的情况，但没有解决方案，最后我尝试更换到python37，问题才得到解决。<br />\nSharedArray也是项目依赖的一个包，但并没有相应的安装文件，最后在github上找了个SharedNumpyArray的项目替换。<br />\n编译需要至少vs2017的支持，虽然开发包并没有使用什么太高级的C++功能，但是因为使用的pytorch,对于编译器有要求，自己用的是vs2015,编译一直报错，在网上看到也是使用vs2015的编译器同样无法使用，最后因为电脑硬盘空间不够了，只能装个vsBuildTools，编译就ok了。<br />\n下面列举一些开发中遇到的问题。</p>\n<p>1.pcdet\\ops\\iou3d_nms\\src/iou3d_nms.cpp(163): error C2131: expression did not evaluate to a constant<br />\npcdet\\ops\\iou3d_nms\\src/iou3d_nms.cpp(213): error C2131: expression did not evaluate to a constant<br />\nconst数组使用的问题，好像很多项目编译都有这个问题，应该是在linux下编译没问题，但是在windows下会出问题.解决方案是使用vector代替数组就可以了。<br />\n2.pcdet\\ops\\iou3d_nms\\src\\iou3d_nms_kernel.cu(77): error: identifier \"EPS\" is undefined in device code<br />\n用宏定义代替变量声明就可以了。<br />\n3.iou3d_nms_kernel.obj : error LNK2005: \"int __cdecl check_rect_cross(struct Point const &amp;,struct Point const &amp;,struct Point const &amp;,struct Point const &amp;)\" (?check_rect_cross@@YAHAEBUPoint@@000@Z) already defined in iou3d_cpu.obj<br />\n函数重名，改了就行了。<br />\n4.iou3d_nms.obj : error LNK2001: unresolved external symbol \"public: long * __cdecl at::TensorBase::data_ptr(void)const \" (??$data_ptr@J@TensorBase@at@@QEBAPEAJXZ)<br />\n这个bug比较神奇，在网上找得解决方案，增加#include cstdint,把long替换成int64_t,unsigned long long替换成uint64_t问题得到解决。<br />\n5.Searching for spconv-cu102<br />\nReading <a href=\"https://pypi.org/simple/spconv-cu102/\" rel=\"noopener nofollow\" target=\"_blank\">https://pypi.org/simple/spconv-cu102/</a><br />\nScanning index of all packages (this may take a while)<br />\nReading <a href=\"https://pypi.org/simple/\" rel=\"noopener nofollow\" target=\"_blank\">https://pypi.org/simple/</a><br />\n这个是项目依赖，一开始用的cuda102的版本，后来换成了cuda113.<br />\n6.ImportError:cannot import name 'getgrouplist' from os<br />\n这个是使用了windows没有的函数，我看只是引用没有使用，把代码注释掉就ok了。</p>\n<p>python demo.py --cfg_file .\\pv_rcnn.yaml --data_path 000000.bin --ckpt .\\weight/pv_rcnn_8369.pth<br />\n最后运行demo,整个测试用的dataset有十几G，下载太慢也太占地方，我从github上找的下载包，只有50M左右。<br />\n最后放上一张运行的效果图。</p>\n<p><img alt=\"demo\" class=\"lazyload\" height=\"332\" width=\"475\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-01-14 00:13</span>&nbsp;\n<a href=\"https://www.cnblogs.com/DemoFX\">demofx</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "LangChain、LangFlow、LangGraph：一文讲清三大 LLM 框架的定位与差异",
      "link": "https://www.cnblogs.com/jyzhao/p/19479470/langchainlangflowlanggraph-yi-wen-jiang-qing-san-d",
      "published": "",
      "description": "<a name=\"top\"></a>\n    <h2><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/jyzhao/p/19479470/langchainlangflowlanggraph-yi-wen-jiang-qing-san-d\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 23:25\">\n    <span>LangChain、LangFlow、LangGraph：一文讲清三大 LLM 框架的定位与差异</span>\n    \n\n</a>\n</h2>\n    <small>\n<span id=\"post-date\">2026-01-13 23:25</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jyzhao\">AlfredZhao</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</small>\n    <div class=\"entry\">\n        <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>随着大模型（LLM）进入工程化落地阶段，<strong>“如何把模型变成真正可用的应用”</strong> 成了很多从业者绕不开的问题。<br />\n围绕这个目标，社区里逐渐形成了一批成熟的开源框架，其中被讨论最多的就是 <strong>LangChain、LangFlow、LangGraph</strong>。</p>\n<p>它们名字相似，但<strong>解决的问题并不相同</strong>。本文笔者将基于官方文档与开源实践，从<strong>定位、能力、使用场景和差异</strong>几个角度，帮你一次性理清。</p>\n<hr />\n<h2 id=\"01--langchainllm-应用的基础设施层\">01 | LangChain：LLM 应用的“基础设施层”</h2>\n<h3 id=\"-langchain-是什么\">① LangChain 是什么？</h3>\n<p>LangChain 是一个<strong>用于构建 LLM 应用的通用框架</strong>，核心目标只有一句话：</p>\n<blockquote>\n<p>把「大模型 + 外部工具 + 数据源 + Prompt」系统化地组织起来。</p>\n</blockquote>\n<p>它并不是一个“产品”，而是一套 <strong>开发范式和组件库</strong>。</p>\n<hr />\n<h3 id=\"-langchain-解决什么问题\">② LangChain 解决什么问题？</h3>\n<p>在没有 LangChain 之前，开发者通常需要自己处理：</p>\n<ul>\n<li>Prompt 拼接</li>\n<li>模型调用</li>\n<li>上下文管理</li>\n<li>工具调用（SQL、搜索、API）</li>\n<li>RAG（检索增强生成）</li>\n</ul>\n<p>LangChain 把这些抽象成了标准组件，例如：</p>\n<ul>\n<li>LLM / ChatModel</li>\n<li>PromptTemplate</li>\n<li>Chain</li>\n<li>Tool / Agent</li>\n<li>Memory</li>\n</ul>\n<hr />\n<h3 id=\"-典型应用场景\">③ 典型应用场景</h3>\n<ul>\n<li>RAG 问答系统</li>\n<li>NL2SQL</li>\n<li>AI 助手 / Copilot</li>\n<li>工具型 Agent</li>\n</ul>\n<p><strong>一句话总结</strong>：<br />\n<strong>LangChain = 写 LLM 应用的“后端开发框架”</strong></p>\n<hr />\n<h2 id=\"02--langflowlangchain-的可视化低代码入口\">02 | LangFlow：LangChain 的可视化“低代码入口”</h2>\n<h3 id=\"-langflow-是什么\">① LangFlow 是什么？</h3>\n<p>LangFlow 是一个 <strong>基于 LangChain 的可视化编排工具</strong>。</p>\n<p>你可以理解为：</p>\n<blockquote>\n<p>用“拖拽流程图”的方式来搭 LangChain 应用。</p>\n</blockquote>\n<p>它本质上是：</p>\n<ul>\n<li>前端可视化</li>\n<li>后端仍然运行 LangChain 逻辑</li>\n</ul>\n<hr />\n<h3 id=\"-langflow-的核心价值\">② LangFlow 的核心价值</h3>\n<p>LangFlow 并没有引入新的模型能力，它的优势在于：</p>\n<ul>\n<li><strong>降低学习门槛</strong></li>\n<li>快速原型验证</li>\n<li>Prompt / Chain 可视化调试</li>\n</ul>\n<p>对不熟悉 Python 或刚接触 LLM 的人非常友好。</p>\n<hr />\n<h3 id=\"-典型应用场景-1\">③ 典型应用场景</h3>\n<ul>\n<li>产品经理 / 咨询顾问做 Demo</li>\n<li>Prompt 调优与流程验证</li>\n<li>教学与分享演示</li>\n<li>小型 PoC 项目</li>\n</ul>\n<p><strong>一句话总结</strong>：<br />\n<strong>LangFlow = LangChain 的“可视化操作台”</strong></p>\n<hr />\n<h2 id=\"03--langgraph为复杂-agent-而生的状态机框架\">03 | LangGraph：为复杂 Agent 而生的“状态机框架”</h2>\n<h3 id=\"-langgraph-是什么\">① LangGraph 是什么？</h3>\n<p>LangGraph 是 LangChain 官方推出的一个<strong>新框架</strong>，专门解决一个问题：</p>\n<blockquote>\n<p>当 Agent 逻辑变复杂，Chain 已经不够用了，怎么办？</p>\n</blockquote>\n<p>LangGraph 引入的是：</p>\n<ul>\n<li><strong>Graph（图）</strong></li>\n<li><strong>State（状态）</strong></li>\n<li><strong>节点 + 边 + 循环</strong></li>\n</ul>\n<p>本质上是：<br />\n<strong>把 LLM Agent 当成一个“有状态的工作流/状态机”来建模</strong>。</p>\n<hr />\n<h3 id=\"-langgraph-为什么出现\">② LangGraph 为什么出现？</h3>\n<p>在真实项目中，Agent 往往需要：</p>\n<ul>\n<li>多轮决策</li>\n<li>条件分支</li>\n<li>回退 / 重试</li>\n<li>人工介入（Human-in-the-loop）</li>\n</ul>\n<p>这些用传统 Chain 非常别扭，而 LangGraph 天然支持：</p>\n<ul>\n<li>循环</li>\n<li>分支</li>\n<li>并行</li>\n<li>可恢复执行</li>\n</ul>\n<hr />\n<h3 id=\"-典型应用场景-2\">③ 典型应用场景</h3>\n<ul>\n<li>多 Agent 协作系统</li>\n<li>复杂业务流程自动化</li>\n<li>长任务 AI 助手</li>\n<li>需要“可控行为”的智能体</li>\n</ul>\n<p><strong>一句话总结</strong>：<br />\n<strong>LangGraph = 面向复杂 Agent 的“流程与状态控制层”</strong></p>\n<hr />\n<h2 id=\"04--三者核心差异一图读懂\">04 | 三者核心差异一图读懂</h2>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>LangChain</th>\n<th>LangFlow</th>\n<th>LangGraph</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>核心定位</td>\n<td>LLM 应用框架</td>\n<td>可视化编排工具</td>\n<td>Agent 状态机框架</td>\n</tr>\n<tr>\n<td>抽象模型</td>\n<td>Chain / Agent</td>\n<td>Flow</td>\n<td>Graph / State</td>\n</tr>\n<tr>\n<td>使用方式</td>\n<td>写代码</td>\n<td>拖流程</td>\n<td>写图结构代码</td>\n</tr>\n<tr>\n<td>适合人群</td>\n<td>工程师</td>\n<td>初学者 / 产品</td>\n<td>高级工程师</td>\n</tr>\n<tr>\n<td>复杂逻辑</td>\n<td>一般</td>\n<td>一般</td>\n<td>非常强</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h2 id=\"05--应该如何选择\">05 | 应该如何选择？</h2>\n<p>笔者给你一个<strong>不踩坑的选择建议</strong>：</p>\n<ul>\n<li><strong>想系统做 LLM 应用</strong> → 先学 <strong>LangChain</strong></li>\n<li><strong>想快速出 Demo / 学概念</strong> → 用 <strong>LangFlow</strong></li>\n<li><strong>Agent 逻辑开始变复杂</strong> → 上 <strong>LangGraph</strong></li>\n</ul>\n<p>现实项目中，<strong>三者是可以组合使用的</strong>：</p>\n<blockquote>\n<p>LangFlow 画流程 → LangChain 落代码 → LangGraph 控复杂控制</p>\n</blockquote>\n<hr />\n<h2 id=\"06--写在最后\">06 | 写在最后</h2>\n<p>LangChain 生态的演进，本质上反映了一件事：</p>\n<blockquote>\n<p>LLM 应用，正在从“Prompt 工程”，走向真正的软件工程。</p>\n</blockquote>\n<p>理解这三者的边界，比死记 API 更重要。<br />\n如果你正在做 <strong>RAG、NL2SQL、AI Agent</strong>，这套认知几乎是绕不开的基础。</p>\n<p>希望这篇文章，能帮你少走一些弯路。</p>\n\n</div>\n<div id=\"MySignature\">\n    <a href=\"https://www.cnblogs.com/jyzhao/\" target=\"_blank\">AlfredZhao</a>©版权所有「从Oracle起航，领略精彩的IT技术。」<br />\n转载请注明原文链接：<a href=\"https://www.cnblogs.com/jyzhao/p/19479470/langchainlangflowlanggraph-yi-wen-jiang-qing-san-d\" target=\"_blank\">https://www.cnblogs.com/jyzhao/p/19479470/langchainlangflowlanggraph-yi-wen-jiang-qing-san-d</a>\n<hr />\n<div style=\"text-align: center; margin-top: 30px;\">\n  <p style=\"font-size: 14px; color: #555;\">\n    👋 感谢阅读，欢迎关注我的公众号 <b>「赵靖宇」</b>\n  </p>\n  <img src=\"https://images.cnblogs.com/cnblogs_com/jyzhao/824234/o_250208075013_qrcode-zjy.jpg\" style=\"border: 1px solid #ddd; border-radius: 8px;\" width=\"160\" />\n</div>\n</div>\n<div class=\"clear\"></div>\n\n        <div class=\"clear\"></div>\n        \n</div>\n    <ul class=\"postmetadata\">\n        \n    </ul>"
    },
    {
      "title": "浅聊算法竞赛中维护中位数的小技巧",
      "link": "https://www.cnblogs.com/GroundhogKing/p/19479345",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/GroundhogKing/p/19479345\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 23:13\">\n    <span>浅聊算法竞赛中维护中位数的小技巧</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>首先来看暑假杭电多校的一道题目：</p>\n<hr />\n<p>对于一个长度为 <span class=\"math inline\">\\(L\\)</span>(<span class=\"math inline\">\\(L\\)</span>为奇数) 的数组 <span class=\"math inline\">\\(a\\)</span>，定义它的中位数 <span class=\"math inline\">\\(median(a)\\)</span> 为 <span class=\"math inline\">\\(a\\)</span> 中第 <span class=\"math inline\">\\(\\frac{L+1}{2}\\)</span> 大的数。现在给你一个长度为 <span class=\"math inline\">\\(n\\)</span> 的排列，对于每对满足 <span class=\"math inline\">\\(1\\leq i \\leq j \\leq n\\)</span> 且 <span class=\"math inline\">\\(j-i \\equiv 0 (mod 2)\\)</span> 的 <span class=\"math inline\">\\((i,j)\\)</span>，你需要计算 <span class=\"math inline\">\\(i*j*median(p[i,j])\\)</span>。输出所有值的和。</p>\n<p>多测数 <span class=\"math inline\">\\(T \\leq 20\\)</span>，排列长度 <span class=\"math inline\">\\(n \\leq 2000\\)</span>。</p>\n<hr />\n<p>对于这道题，首先想到的是枚举所有 <span class=\"math inline\">\\([i,j]\\)</span>，通过数据结构(对顶堆等)维护中位数。由于这些方法都带log，并且本题多测数据不保证 <span class=\"math inline\">\\(n\\)</span> 的总和。因此复杂度 <span class=\"math inline\">\\(O(n^2lognT)\\)</span>，无法通过本题。</p>\n<p>换个思路，枚举区间不行，就计算每个位置的贡献。想想一个位置能成为一个区间的中位数，需要满足什么条件？该区间中大于它和小于它的数的数量相等。</p>\n<p>一个很经典的处理就是，将小于 <span class=\"math inline\">\\(x\\)</span> 的数赋-1，将大于 <span class=\"math inline\">\\(x\\)</span> 的数赋1，我们对这个数组做前缀和，记作 <span class=\"math inline\">\\(pre\\)</span>。于是问题就转换为，在 <span class=\"math inline\">\\(x\\)</span> 的左边找到 <span class=\"math inline\">\\(pre_i\\)</span>，在 <span class=\"math inline\">\\(x\\)</span> 的右边找到 <span class=\"math inline\">\\(pre_j\\)</span>，使得 <span class=\"math inline\">\\(pre_i = pre_j\\)</span>。那么 <span class=\"math inline\">\\(pre_j - pre_i = 0\\)</span>，这就意味着，区间 <span class=\"math inline\">\\([l+1,r]\\)</span> 中大于 <span class=\"math inline\">\\(x\\)</span> 和小于 <span class=\"math inline\">\\(x\\)</span> 的数的数量相等。</p>\n<p>对于每个数处理一次这样的前缀和数组是 <span class=\"math inline\">\\(O(n)\\)</span> 的，因此可以在 <span class=\"math inline\">\\(O(n^2T)\\)</span> 的时间下通过本题。</p>\n<p><strong>Code:</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nusing ll = long long;\n\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; a(n+10);\n    for (int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; a[i];\n\n    ll ans = 0;\n    for (int i = 1 ; i &lt;= n ; i++) //枚举中位数\n    {\n        vector&lt;int&gt; pre(n+10);\n        vector&lt;int&gt; t(2*n+10); //桶,因为会出现负数，要带n的偏移\n        t[n]++;\n        for (int j = 1 ; j &lt;= n ; j++)\n        {\n            pre[j] = pre[j-1];\n            if (a[j] &gt; a[i]) pre[j]++;\n            else if (a[j] &lt; a[i]) pre[j]--;\n\n            if (j &lt; i) t[pre[j]+n] += j + 1;\n            else ans += (ll)a[i] * t[pre[j]+n] * j;\n        }\n    }\n\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int T;\n    cin &gt;&gt; T;\n    while (T--) solve();\n\n    return 0;\n}\n</code></pre>\n<p>基于本题，可以归纳一个维护中位数的小技巧：通过给大于 <span class=\"math inline\">\\(x\\)</span> 和 小于 <span class=\"math inline\">\\(x\\)</span> 的数分别赋值，并求前缀和，就可以把求中位数问题，转化成维护前缀和之差为0。</p>\n<p>以下再做个拓展：序列 <span class=\"math inline\">\\(a\\)</span> 的中位数 <span class=\"math inline\">\\(median(a) \\ge v\\)</span>，当且仅当 <span class=\"math inline\">\\(a\\)</span> 中 <span class=\"math inline\">\\(cnt_{a_i \\geq v} \\geq cnt_{a_i &lt; v}\\)</span>（式中是否取等号取决于题目怎么定义中位数）。也就是说，<span class=\"math inline\">\\(median(a) \\geq v\\)</span> 的充要条件是 <span class=\"math inline\">\\(a\\)</span> 中 <span class=\"math inline\">\\(\\geq v\\)</span> 的数的数量多于或等于 <span class=\"math inline\">\\(&lt; v\\)</span> 的数的数量。这个式子比较好理解，这里不做证明。</p>\n<p>这个式子给我们提供了一种二分的思路。</p>\n<p>看下面这道题<a href=\"https://codeforces.com/contest/2128/problem/E1\" rel=\"noopener nofollow\" target=\"_blank\">Submedians (Easy Version)</a>：</p>\n<hr />\n<p>对于长度为 <span class=\"math inline\">\\(m\\)</span> 的数组 <span class=\"math inline\">\\(b\\)</span>，整数 <span class=\"math inline\">\\(v\\)</span> 是 <span class=\"math inline\">\\(b\\)</span> 的中位数，当且仅当：</p>\n<ul>\n<li><span class=\"math inline\">\\(v\\)</span> 至少大于等于数组中 <span class=\"math inline\">\\(\\lceil \\frac{m}{2} \\rceil\\)</span> 个元素，并且</li>\n<li><span class=\"math inline\">\\(v\\)</span> 至少小于等于数组中 <span class=\"math inline\">\\(\\lceil \\frac{m}{2} \\rceil\\)</span> 个元素。</li>\n</ul>\n<p>现在给定一个整数 <span class=\"math inline\">\\(k\\)</span> 和一个由 <span class=\"math inline\">\\(1\\)</span> 到 <span class=\"math inline\">\\(n\\)</span> 之间的整数构成的数组 <span class=\"math inline\">\\(a_1, \\ldots, a_n\\)</span>。</p>\n<p>如果存在至少一对下标 <span class=\"math inline\">\\((l, r)\\)</span> 满足：</p>\n<ul>\n<li><span class=\"math inline\">\\(1 \\leq l \\leq r \\leq n\\)</span>，</li>\n<li><span class=\"math inline\">\\(r - l + 1 \\geq k\\)</span>，</li>\n<li><span class=\"math inline\">\\(v\\)</span> 是子数组 <span class=\"math inline\">\\([a_l, \\ldots, a_r]\\)</span> 的中位数，</li>\n</ul>\n<p>则称 <span class=\"math inline\">\\(1\\)</span> 到 <span class=\"math inline\">\\(n\\)</span> 之间的整数 <span class=\"math inline\">\\(v\\)</span> 是一个子中位数。</p>\n<p>可以证明，至少存在一个子中位数。请你找出最大的子中位数 <span class=\"math inline\">\\(v_{\\max}\\)</span>，以及任意一组对应的下标对 <span class=\"math inline\">\\((l, r)\\)</span>。</p>\n<hr />\n<p>考虑二分：当 <span class=\"math inline\">\\(v\\)</span> 越大，<span class=\"math inline\">\\(cnt_{a_i\\geq v}\\)</span> 越少，反之 <span class=\"math inline\">\\(cnt_{a_i &lt; v}\\)</span> 越大，因此越大的数越不可能作为中位数。</p>\n<p>同样将 <span class=\"math inline\">\\(\\geq v\\)</span> 的数赋1，<span class=\"math inline\">\\(&lt; v\\)</span> 的数赋-1，做前缀和维护即可。</p>\n<p><strong>Code:</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvoid solve()\n{\n    int n,k;\n    cin &gt;&gt; n &gt;&gt; k;\n    vector&lt;int&gt; a(n+10);\n    for (int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; a[i];\n\n    int ansl, ansr;\n    auto check = [&amp;](int mid)\n    {\n        vector&lt;int&gt; sum(n+10);\n        for (int i = 1 ; i &lt;= n ; i++)\n        {\n            sum[i] = sum[i-1];\n            if (a[i] &gt;= mid) sum[i]++;\n            else sum[i]--;\n        }\n\n        int minn = 2e9;\n        int l;\n        for (int i = k ; i &lt;= n ; i++)\n        {\n            if (sum[i-k] &lt; minn)\n            {\n                minn = sum[i-k];\n                l = i - k + 1;\n            }\n            if (sum[i]-minn &gt;= 0)\n            {\n                ansl = l;\n                ansr = i;\n                return true;\n            }\n        }\n\n        return false;\n    };\n\n    int l = 0;\n    int r = n + 1;\n    while (l+1 != r)\n    {\n        int mid = (l+r) &gt;&gt; 1;\n        if (check(mid)) l = mid;\n        else r = mid;\n    }\n\n    check(l);\n    cout &lt;&lt; l &lt;&lt; \" \" &lt;&lt; ansl &lt;&lt; \" \" &lt;&lt; ansr &lt;&lt; endl;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int T;\n    cin &gt;&gt; T;\n    while (T--) solve();\n\n    return 0;\n}\n</code></pre>\n<p>一道与上题几乎一样的题目<a href=\"https://codeforces.com/contest/1486/problem/D\" rel=\"noopener nofollow\" target=\"_blank\">Max Median</a>：</p>\n<p>题目很短，这里不做题意概述。需要注意的是，由于本题定义中位数为第 <span class=\"math inline\">\\(\\lfloor \\frac{L+1}{2} \\rfloor\\)</span> 大的数，因此本题 <span class=\"math inline\">\\(median(a) \\geq v\\)</span> 的条件为：<span class=\"math inline\">\\(cnt_{a_i \\geq v} &gt; cnt_{a_i &lt; v}\\)</span>。</p>\n<p><strong>Code:</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvoid solve()\n{\n    int n,k;\n    cin &gt;&gt; n &gt;&gt; k;\n    vector&lt;int&gt; a(n+10);\n    for (int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; a[i];\n\n    int ansl, ansr;\n    auto check = [&amp;](int mid)\n    {\n        vector&lt;int&gt; sum(n+10);\n        for (int i = 1 ; i &lt;= n ; i++)\n        {\n            sum[i] = sum[i-1];\n            if (a[i] &gt;= mid) sum[i]++;\n            else sum[i]--;\n        }\n\n        int minn = 2e9;\n        int l;\n        for (int i = k ; i &lt;= n ; i++)\n        {\n            if (sum[i-k] &lt; minn)\n            {\n                minn = sum[i-k];\n                l = i - k + 1;\n            }\n            if (sum[i]-minn &gt; 0)\n            {\n                ansl = l;\n                ansr = i;\n                return true;\n            }\n        }\n\n        return false;\n    };\n\n    int l = 0;\n    int r = n + 1;\n    while (l+1 != r)\n    {\n        int mid = (l+r) &gt;&gt; 1;\n        if (check(mid)) l = mid;\n        else r = mid;\n    }\n\n    check(l);\n    cout &lt;&lt; l &lt;&lt; endl;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int T = 1;\n    while (T--) solve();\n\n    return 0;\n}\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 23:13</span>&nbsp;\n<a href=\"https://www.cnblogs.com/GroundhogKing\">GroundhogKing</a>&nbsp;\n阅读(<span id=\"post_view_count\">1</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "当条形图遇上极坐标：径向与圆形条形图的视觉革命",
      "link": "https://www.cnblogs.com/wang_yb/p/19479454",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wang_yb/p/19479454\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 23:10\">\n    <span>当条形图遇上极坐标：径向与圆形条形图的视觉革命</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>想象一下，你正站在一个圆形广场的中心，周围均匀排列着12根高度不同的灯柱，这就是<strong>径向条形图</strong>带给我们的视觉体验。</p>\n<p>在数据可视化领域，我们常常满足于传统的直角坐标系条形图，但当数据具有周期性或比较性时，<strong>径向条形图</strong>和<strong>圆形条形图</strong>为我们打开了新的可能性。</p>\n<h1 id=\"1-设计原理\">1. 设计原理</h1>\n<p>这两种图表把传统的<strong>笛卡尔坐标系</strong>换成<strong>极坐标系</strong>：角度表示类别，半径或角度长度表示数值。</p>\n<h2 id=\"11-径向条形图\">1.1. 径向条形图</h2>\n<p><strong>径向条形图</strong>本质上是将传统条形图的直角坐标系转换为极坐标系。</p>\n<p>在极坐标系中，每个数据点不再由<code>(x, y)</code>定位，而是由<strong>(角度, 半径)</strong>确定，条形的高度（或长度）由半径值表示，而条形的排列则沿着圆周方向。</p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260113230907077-321355021.png\" /></p>\n<p><strong>设计灵感</strong>：如同钟表的指针或雷达的扫描线，径向条形图借鉴了自然界和人工制品中常见的圆形布局，利用了人类对角度和对称性的天然感知能力。</p>\n<h2 id=\"12-圆形条形图\">1.2. 圆形条形图</h2>\n<p><strong>圆形条形图</strong>是径向条形图的一种特殊形式，它固定了起点和终点，使所有条形都在同一圆周上开始，只在半径方向上延伸。</p>\n<p>这种设计解决了完全径向布局可能导致的<strong>数据比较困难</strong>问题，因为所有条形的基准线是一致的。</p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260113230907250-2040360098.png\" /></p>\n<p><strong>设计比喻</strong>：想象一组跳高运动员，他们都从同一高度起跳，只是跳跃的高度不同——圆形条形图就是这样公平的\"竞技场\"。</p>\n<h1 id=\"2-应用示例\">2. 应用示例</h1>\n<p>下面通过示例来演示这两种图在实际场景中的应用。</p>\n<h2 id=\"21-径向条形图\">2.1. 径向条形图</h2>\n<pre><code class=\"language-python\"># --- 1. 构造测试数据 ---\n# 假设我们想比较一年中每个月的平均降水量\n月份 = [\n    \"一月\",\n    \"二月\",\n    \"三月\",\n    \"四月\",\n    \"五月\",\n    \"六月\",\n    \"七月\",\n    \"八月\",\n    \"九月\",\n    \"十月\",\n    \"十一月\",\n    \"十二月\",\n]\n# 生成模拟的降水量数据 (单位: mm)\nnp.random.seed(42)  # 为了结果可复现\n降水量 = np.random.uniform(30, 150, size=len(月份))  # 随机生成30-150mm的数据\n\n# --- 2. 创建图形 ---\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 7), facecolor=\"white\")\n\n# --- 2.1 绘制传统条形图 ---\n# ... 省略 ...\n\n# --- 2.2 绘制径向条形图 ---\n# 计算每个条形的角度位置\n# ... 省略 ...\n\n# 使用极坐标子图\nax2 = plt.subplot(122, projection=\"polar\")\n# 关键：设置 'bottom' 参数为 inner_radius，这样条形就从 inner_radius 开始画，长度为 radii\nbars = ax2.bar(\n    theta,\n    radii,\n    width=0.4,\n    bottom=inner_radius,\n    color=\"lightcoral\",\n    edgecolor=\"darkred\",\n    alpha=0.7,\n)\n\n# 添加数值标签 (在条形内部，靠近外侧)\nfor angle, radius, month in zip(theta, radii, 月份):\n    ax2.text(\n        angle,\n        inner_radius + radius / 2,\n        f\"{radius:.1f}\",\n        ha=\"center\",\n        va=\"center\",\n        fontsize=8,\n        color=\"black\",\n    )\n\n# 添加月份标记 (在条形外部)\n# ... 省略 ...\n\n# --- 3. 显示图形 ---\nplt.tight_layout()\nplt.show()\n</code></pre>\n<p>这段代码首先生成了模拟的月度降水量数据，然后在同一个图形窗口中创建了两个子图。</p>\n<p>左侧是使用 <code>plt.bar</code> 创建的传统条形图，右侧是使用 <code>plt.subplot(..., projection='polar')</code> 和 <code>ax.bar</code> 创建的径向条形图。</p>\n<p><strong>径向条形图</strong>利用了极坐标系，将类别（月份）分布在圆周上，将数值（降水量）映射到径向长度上。</p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260113230907232-60855079.png\" /></p>\n<p><strong>径向条形图</strong>是一种在极坐标系上绘制的图表，可以提供比传统条形图更具视觉吸引力的替代方案。它通过弧长来表示数值，并且可以有效地利用空间，尤其是在处理类别较多或需要强调周期性模式（例如按月份或季度分组的数据）时。</p>\n<h2 id=\"22-圆形条形图\">2.2. 圆形条形图</h2>\n<pre><code class=\"language-python\">from matplotlib import cm\nfrom math import log10\n\nlabels = list(\"ABCDEFG\")\ndata = [21, 57, 88, 14, 76, 91, 26]\n# ... 省略 ...\n\n#create colors along a chosen colormap\ncolors = [cm.terrain(i / n) for i in range(n)]\n\n#create figure, axis\nfig, ax = plt.subplots()\n\n#create rings of donut chart\nfor i in range(n):\n    current_outer_radius = r - i * w\n    innerring, _ = ax.pie([m - data[i], data[i]], \n                          radius = current_outer_radius, \n                          startangle = 90, \n                          colors = [\"white\", colors[i]])\n\n    # 添加标签\n    # ... 省略 ...\n\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260113230907034-1742470964.png\" /></p>\n<p><strong>圆形条形图</strong>从同一基准线开始，避免了<strong>径向条形图</strong>中不同角度起始点不同的问题，更加便于比较。</p>\n<h1 id=\"3-总结\">3. 总结</h1>\n<p><strong>径向条形图</strong>和<strong>圆形条形图</strong>代表了数据可视化从纯功能向功能美学平衡的演进。</p>\n<p>它们不是要完全取代传统条形图，而是为我们提供了更多视觉叙事的工具。</p>\n<p>就像一位熟练的厨师拥有多种刀具一样，优秀的数据分析师也应该掌握多种可视化技术，根据数据特性和沟通目标选择最合适的\"刀具\"。</p>\n<p>当你的数据讲述着周期性的故事，或需要在有限空间内进行多维度比较时，不妨尝试这些圆形可视化方法。它们不仅能更有效地传达信息，还能为你的报告或仪表板增添独特的视觉魅力。</p>\n<p>最好的可视化不是最复杂的，而是最能清晰传达数据故事的。</p>\n<p><strong>径向</strong>和<strong>圆形条形图</strong>正是这样一种工具：在传统与现代之间，在功能与美学之间，找到了优雅的平衡点。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 23:10</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wang_yb\">wang_yb</a>&nbsp;\n阅读(<span id=\"post_view_count\">3</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Spring 的西西弗斯之石：理解 BeanFactory、FactoryBean 与 ObjectFactory",
      "link": "https://www.cnblogs.com/xzqcsj/p/19479429",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xzqcsj/p/19479429\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 22:46\">\n    <span>Spring 的西西弗斯之石：理解 BeanFactory、FactoryBean 与 ObjectFactory</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"Spring 的西西弗斯之石：理解 BeanFactory、FactoryBean 与 ObjectFactory\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3703499/202601/3703499-20260113224556329-1020363253.png\" />\n        今天，代码又报错了。或者也许是昨天，我不清楚。\n不管怎样，Spring 容器抛出了一个 BeanCreationException。为了解决它，我被迫潜入框架的深处，去注视那些平时被 @Autowired 掩盖的齿轮。\n在 Spring 的世界里，存在着一种必然的复杂性。这种复杂性并非设计者的恶趣味，而是为了在一个静态的语言中构建动态世界所付出的代价。\n在这个庞大的机器中，有三个名字极其相似的概念经常被混淆：BeanFactory、FactoryBean 和 ObjectFactory。这并不是命名的贫瘠，而是它们在本质上确实存在着微妙的纠缠。\n今天，我们剥离掉那些花哨的比喻和无用的糖衣，用一种冷静的、近乎解剖学的视角，去审视这三个概念的本质。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>今天，代码又报错了。或者也许是昨天，我不清楚。<br />\n不管怎样，Spring 容器抛出了一个 <code>BeanCreationException</code>。为了解决它，我被迫潜入框架的深处，去注视那些平时被 <code>@Autowired</code> 掩盖的齿轮。</p>\n<p>在 Spring 的世界里，存在着一种必然的复杂性。这种复杂性并非设计者的恶趣味，而是为了在一个静态的语言中构建动态世界所付出的代价。</p>\n<p>在这个庞大的机器中，有三个名字极其相似的概念经常被混淆：<code>BeanFactory</code>、<code>FactoryBean</code> 和 <code>ObjectFactory</code>。这并不是命名的贫瘠，而是它们在本质上确实存在着微妙的纠缠。</p>\n<p>今天，我们剥离掉那些花哨的比喻和无用的糖衣，用一种冷静的、近乎解剖学的视角，去审视这三个概念的本质。</p>\n<hr />\n<h2 id=\"一beanfactory存在的容器\">一、BeanFactory：存在的容器</h2>\n<p><strong>让我们首先纠正一个观念：BeanFactory 名为工厂，但其本质是容器（Container）。</strong></p>\n<p>当我们谈论 Spring 容器时，我们实际上是在谈论 <code>BeanFactory</code>。它是 Spring IoC 容器的根接口，是整个世界的物理法则。</p>\n<h3 id=\"11-唯一的职责\">1.1 唯一的职责</h3>\n<p>它的定义极其克制。它不关心业务逻辑，只关心一件事：<strong>管理对象的生命周期</strong>。</p>\n<pre><code class=\"language-java\">public interface BeanFactory {\n    Object getBean(String name) throws BeansException;\n    &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType);\n    boolean containsBean(String name);\n    // ...\n}\n</code></pre>\n<p>当你启动一个 Spring Boot 应用时，<code>ApplicationContext</code> 就像一个充满活力的城市，而 <code>BeanFactory</code> 则是支撑这座城市的地下管网。所有的 BeanDefinition（关于 Bean 应该如何创建的蓝图）都注册在这里。</p>\n<h3 id=\"12-残酷的现实\">1.2 残酷的现实</h3>\n<p>在大多数情况下，你不需要直接与 <code>BeanFactory</code> 对话。因为 <code>ApplicationContext</code> 已经为你封装好了一切。<br />\n但当你试图理解为什么你的 Bean 没有被正确初始化，或者为什么你的循环依赖失效时，你就必须意识到：<strong>你所有的 Bean，都只是 <code>BeanFactory</code> 中的 entries（条目）。</strong></p>\n<p>它是一个巨大的 <code>Map&lt;String, BeanDefinition&gt;</code> 和 <code>Map&lt;String, Object&gt;</code> 的管理者。它冷酷无情，只按照定义的规则（Scope, Lazy, Dependence）来实例化对象。</p>\n<hr />\n<h2 id=\"二factorybean必要的欺骗\">二、FactoryBean：必要的欺骗</h2>\n<p>如果说 <code>BeanFactory</code> 是宏观规则的制定者，那么 <code>FactoryBean</code> 就是微观规则的<strong>潜行者</strong>。</p>\n<h3 id=\"21-静态语言的困境\">2.1 静态语言的困境</h3>\n<p>想象这样一个场景：<strong>你需要注入一个接口的实现，但这个实现类并不存在于代码中，它是通过动态代理在运行时生成的。</strong><br />\n这在 RPC 框架（如 Dubbo、Feign）和 ORM 框架（如 MyBatis）中极其常见。</p>\n<p>你无法通过简单的 <code>&lt;bean class=\"...\"&gt;</code> 或 <code>@Component</code> 来描述一个“不存在的类”。<br />\n这时候，你需要一个中间人。这个中间人表面上是一个普通的 Bean，但实际上，它是一个工厂。</p>\n<h3 id=\"22-伪装的艺术以-mybatis-为例\">2.2 伪装的艺术：以 MyBatis 为例</h3>\n<p>为什么你只需要写一个 <code>UserMapper</code> 接口，就能直接 <code>@Autowired</code> 使用？<br />\n因为 Spring 容器里注册的那个 \"userMapper\" Bean，根本不是你的接口实现，而是一个 <code>MapperFactoryBean</code>。</p>\n<pre><code class=\"language-java\">// 简化的逻辑示意\npublic class MapperFactoryBean&lt;T&gt; implements FactoryBean&lt;T&gt; {\n    \n    private Class&lt;T&gt; mapperInterface;\n\n    @Override\n    public T getObject() throws Exception {\n        // 往里跟进，最终这里发生了魔法：通过 JDK 动态代理生成接口的实\n        return (T) Proxy.newProxyInstance(\n            mapperInterface.getClassLoader(), \n            new Class[] { mapperInterface }, \n            new MapperProxy&lt;&gt;()\n        );\n    }\n\n    @Override\n    public Class&lt;?&gt; getObjectType() {\n        return mapperInterface;\n    }\n\n    @Override\n    public boolean isSingleton() {\n        return true;\n    }\n}\n</code></pre>\n<h3 id=\"23-这里的真相\">2.3 这里的真相</h3>\n<p>当容器调用 <code>getBean(\"userMapper\")</code> 时，它发现这是一个 <code>FactoryBean</code>。于是，它不会返回 <code>FactoryBean</code> 实例本身，而是默默地调用 <code>getObject()</code>，并返回那个代理对象。</p>\n<p>这就是欺骗。<strong>你以为你拿到了一个 Bean，其实你拿到的是 Bean 生产的产品。</strong></p>\n<p>如果你渴望看到真相，看到那个操纵傀儡的幕后黑手，你需要在 Bean 名称前加上 <code>&amp;</code>：</p>\n<pre><code class=\"language-java\">// 获取的是 MapperProxy 代理对象\nObject product = context.getBean(\"userMapper\"); \n\n// 获取的是 FactoryBean 工厂本身\nObject factory = context.getBean(\"&amp;userMapper\");\n</code></pre>\n<hr />\n<h2 id=\"三objectfactory时间的延迟\">三、ObjectFactory：时间的延迟</h2>\n<p><code>BeanFactory</code> 负责掌控空间（容器），<code>FactoryBean</code> 负责掌控构造（逻辑），而 <code>ObjectFactory</code> 则是为了掌控<strong>时间</strong>。</p>\n<h3 id=\"31-循环的死结\">3.1 循环的死结</h3>\n<p>在 Spring 的世界里，有一个经典的荒谬：A 需要 B，B 需要 A。<br />\n如果是构造器注入，只需坦然承认失败。但如果是 Setter 注入，Spring 试图挽救这种死结。</p>\n<p>在 A 创建的过程中，需要注入 B。B 创建时，又需要注入 A。<br />\n此时 A 还在创建中，尚不是一个完整的 Bean。怎么办？<br />\nSpring 引入了三级缓存的概念。而第三级缓存，存放的就是一个 <code>ObjectFactory</code>。</p>\n<h3 id=\"32-回调的本质\">3.2 回调的本质</h3>\n<p><code>ObjectFactory</code> 在源码中简单得令人发指：</p>\n<pre><code class=\"language-java\">@FunctionalInterface\npublic interface ObjectFactory&lt;T&gt; {\n    T getObject() throws BeansException;\n}\n</code></pre>\n<p>它只是一个<strong>函数式接口</strong>，一个回调。<br />\n它存在的意义在于：<strong>我现在不想要这个对象，但我想要一个“在未来某个时刻能获取这个对象”的能力。</strong></p>\n<p>在循环依赖中，Spring 提前暴露了一个 <code>ObjectFactory</code>：</p>\n<pre><code class=\"language-java\">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));\n</code></pre>\n<p>当 B 需要 A 时，它通过这个 <code>ObjectFactory</code> 拿到了 A 的早期引用（Early Reference）。尽管 A 还没完全初始化好，但 B 已经可以持有它的引用了。死结解开了。</p>\n<h3 id=\"33-作用域的错位\">3.3 作用域的错位</h3>\n<p>另一个场景是：一个单例（Singleton）的 Service 需要使用一个 原型（Prototype）的 Bean。<br />\n如果你直接 <code>@Autowired</code>，原型的 Bean 只有在 Service 创建时被注入一次，之后也就是永远同一个对象了。这违背了原型的初衷。</p>\n<p>如何解决？使用 <code>ObjectFactory</code> 延迟获取。</p>\n<pre><code class=\"language-java\">@Service\npublic class ReportService {\n    \n    @Autowired\n    private ObjectFactory&lt;ReportBuilder&gt; builderFactory;\n\n    public void generate() {\n        // 每次调用 getObject()，容器都会创建一个全新的 ReportBuilder\n        ReportBuilder builder = builderFactory.getObject();\n        builder.build();\n    }\n}\n</code></pre>\n<p>在这里，<strong><code>ObjectFactory</code> 就像是一个通往容器的句柄，让你随时可以伸手进去拿一个新的对象，而不是守着陈旧的缓存。</strong></p>\n<hr />\n<h2 id=\"四审判与裁决\">四、审判与裁决</h2>\n<p>让我们在最后，用最客观的表格来审判这三者的区别。这不是为了背诵，而是为了理清混乱。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">维度</th>\n<th style=\"text-align: left;\">BeanFactory</th>\n<th style=\"text-align: left;\">FactoryBean</th>\n<th style=\"text-align: left;\">ObjectFactory</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>存在形式</strong></td>\n<td style=\"text-align: left;\"><strong>容器</strong> (Container)</td>\n<td style=\"text-align: left;\"><strong>Bean</strong> (Component)</td>\n<td style=\"text-align: left;\"><strong>接口</strong> (Interface/Callback)</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>底层逻辑</strong></td>\n<td style=\"text-align: left;\"><code>ApplicationContext</code> 的父级接口 / <strong>宏观工厂</strong></td>\n<td style=\"text-align: left;\">实现了 <code>FactoryBean</code> 接口的类 / <strong>微观工厂</strong></td>\n<td style=\"text-align: left;\">函数式接口 / <strong>延迟回调</strong></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>核心职责</strong></td>\n<td style=\"text-align: left;\">管理所有 Bean 的生命周期</td>\n<td style=\"text-align: left;\">此 Bean 负责<strong>生产</strong>另一个复杂的 Bean</td>\n<td style=\"text-align: left;\">封装对象的创建过程，提供<strong>延迟</strong>获取能力</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>获取方式</strong></td>\n<td style=\"text-align: left;\"><code>ApplicationContext</code> 是它的超集</td>\n<td style=\"text-align: left;\"><code>getBean(\"name\")</code> 拿产品<br /><code>getBean(\"&amp;name\")</code> 拿工厂</td>\n<td style=\"text-align: left;\">注入 <code>ObjectFactory&lt;T&gt;</code> 后调用 <code>getObject()</code></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>真实场景</strong></td>\n<td style=\"text-align: left;\">Spring 框架的基石</td>\n<td style=\"text-align: left;\">Mybatis <code>MapperFactoryBean</code>, <code>ProxyFactoryBean</code></td>\n<td style=\"text-align: left;\">解决循环依赖(三级缓存), Scope(原型模式)适配</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"五结语\">五、结语</h2>\n<p>在代码的荒原上，我们通过构建抽象来对抗混乱。</p>\n<ul>\n<li><strong>BeanFactory</strong> 是我们脚下的大地。<strong>它被称为工厂，但它实际是孕育万物的土壤（容器）。</strong></li>\n<li><strong>FactoryBean</strong> 是我们手中的精密机床。<strong>它是一个特殊的 Bean，存在的目的却是为了制造另一个 Bean。</strong></li>\n<li><strong>ObjectFactory</strong> 是我们预留的时间胶囊。<strong>它只是一个单纯的接口，为了应对循环与未来的不确定性。</strong></li>\n</ul>\n<p>理解它们，并不是为了通过面试，而是为了在下一次抛出异常时，你能冷静地凝视堆栈信息，知道机器的哪个齿轮发生了错位。</p>\n<p>既然我们选择了与机器共舞，就必须理解机器的逻辑。这或许就是作为开发者的西西弗斯式命运——<strong>我们需要一次又一次地将巨石推向山顶，以此证明我们对这个庞大系统的掌控</strong>。</p>\n<blockquote>\n<p><strong>本文通过 AI 润色（加缪风格），试图以一种冷静、客观甚至存在主义的视角，去解构这些在日常 Coding 中被我们习以为常的概念。希望这种独特的叙事风格，能让你对这些枯燥的技术概念有更深刻的“存在感”。</strong></p>\n</blockquote>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 22:46</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xzqcsj\">一旅人</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "吴恩达深度学习课程五：自然语言处理  第一周：循环神经网络 （七）双向 RNN 与深层 RNN",
      "link": "https://www.cnblogs.com/Goblinscholar/p/19479253",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Goblinscholar/p/19479253\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 22:37\">\n    <span>吴恩达深度学习课程五：自然语言处理  第一周：循环神经网络 （七）双向 RNN 与深层 RNN</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>此分类用于记录吴恩达深度学习课程的学习笔记。<br />\n课程相关信息链接如下：</p>\n<ol>\n<li>原课程视频链接：<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?buvid=XU762317353676D786954061C192FE625463B&amp;from_spmid=playlist.playlist-detail.0.0&amp;is_story_h5=false&amp;mid=zqernykrmpf7XfIorMR%2FnA%3D%3D&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=ce0bc526-db69-428a-962e-c65ed8c267bc&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1713085655&amp;unique_k=DfBgvFW&amp;up_id=8654113&amp;vd_source=e035e9878d32f414b4354b839a4c31a4\" rel=\"noopener nofollow\" target=\"_blank\">[双语字幕]吴恩达深度学习deeplearning.ai</a></li>\n<li>github课程资料，含课件与笔记:<a href=\"https://github.com/robbertliu/deeplearning.ai-andrewNG\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习教学资料</a></li>\n<li>课程配套练习（中英）与答案：<a href=\"https://blog.csdn.net/u013733326/article/details/79827273\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习课后习题与答案</a></li>\n</ol>\n<p>本篇为第五课的第一周内容，<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=161\" rel=\"noopener nofollow\" target=\"_blank\">1.11</a>到<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=162\" rel=\"noopener nofollow\" target=\"_blank\">1.12</a>的内容，同时也是本周理论部分的最后一篇。</p>\n<hr />\n<p>本周为第五课的第一周内容，与 CV 相对应的，这一课所有内容的中心只有一个：<strong>自然语言处理（Natural Language Processing，NLP）</strong>。<br />\n应用在深度学习里，它是专门用来进行<strong>文本与序列信息建模</strong>的模型和技术，本质上是在全连接网络与统计语言模型基础上的一次“结构化特化”，也是人工智能中<strong>最贴近人类思维表达方式</strong>的重要研究方向之一。<br />\n<strong>这一整节课同样涉及大量需要反复消化的内容，横跨机器学习、概率统计、线性代数以及语言学直觉。</strong><br />\n语言不像图像那样“直观可见”，更多是抽象符号与上下文关系的组合，因此<strong>理解门槛反而更高</strong>。<br />\n因此，我同样会尽量补足必要的背景知识，尽可能用比喻和实例降低理解难度。<br />\n本篇的内容关于<strong>双向 RNN 与深层 RNN</strong>，是对基础 RNN 结构的一些补充。</p>\n<h1 id=\"1-双向-rnnbidirectional-rnn\">1. 双向 RNN（Bidirectional RNN）</h1>\n<p>在前面对 <strong><a href=\"https://www.cnblogs.com/Goblinscholar/p/19449622\" target=\"_blank\">RNN</a>、<a href=\"https://www.cnblogs.com/Goblinscholar/p/19463351\" target=\"_blank\">GRU</a> 与 <a href=\"https://www.cnblogs.com/Goblinscholar/p/19474433\" target=\"_blank\">LSTM</a></strong> 的讨论中，我们始终默认了一个前提：<strong>序列只能沿时间轴单向展开，模型在当前时刻只能利用已经出现的历史信息。</strong></p>\n<p>这种设定在一些简单任务中是合理的，但在大量<strong>序列理解与标注任务</strong>中，却隐藏着一个结构性限制：  <strong>当前时刻的语义或状态，往往同时依赖于过去和未来的上下文信息。</strong><br />\n举个课程里的例子：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260113211513804-150472822.png\" /><br />\n于是，问题出现了：<strong>如果未来信息才是判定当前状态的重要依据，该怎么办？</strong></p>\n<p>正是在这样的背景下，<strong>双向 RNN（Bidirectional Recurrent Neural Networks）</strong> 被提出。<br />\n早在 <strong>1997 年</strong>，<strong><a href=\"https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=650093\" rel=\"noopener nofollow\" target=\"_blank\">Bidirectional Recurrent Neural Networks</a></strong> 这篇论文中就指出：对于序列标注与整体理解任务，仅依赖过去上下文会造成信息利用上的先天不足，因此有必要在模型结构层面<strong>同时建模正向与反向的时间依赖关系</strong>。</p>\n<p>需要强调的是，双向 RNN 并不是一种新的循环单元设计。<br />\n它并不改变 RNN、LSTM 或 GRU 内部的计算形式，而是通过在时间维度上引入<strong>前向与后向两条独立的状态传播链路</strong>，使模型在每一个时间步都能够融合<strong>历史与未来的上下文信息</strong>。</p>\n<p>也正因为这种“结构独立于单元”的特性，双向 RNN 可以自然地与 LSTM、GRU 结合，形成 <strong>Bi-LSTM、Bi-GRU</strong>，成为提升上下文建模能力的标准配置。</p>\n<p>它的实现逻辑并不复杂，这里引用一张比较清晰易懂的传播图：（<a href=\"https://medium.com/@fraidoonomarzai99/bidirectional-rnn-in-depth-1efd32c3cf46\" rel=\"noopener nofollow\" target=\"_blank\">出处</a>）<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260113211514563-1603287401.png\" /><br />\n这样，你就会发现，同一序列被 <strong>正向（蓝色）</strong> 和 <strong>反向（绿色）</strong> 两条 RNN 同时建模，每个时间步 <span class=\"math inline\">\\(t\\)</span> 都能“看到”正向的历史上下文和反向的未来上下文，最终输出 <span class=\"math inline\">\\(\\hat y^{\\langle t\\rangle}\\)</span> 由两个方向的信息共同决定。</p>\n<p></p><div class=\"math display\">\\[h^{(t)}\n=\n\\operatorname{concat}\\!\\left(\n\\overrightarrow{{h}^{(t)}},\n\\overleftarrow{{h}^{(t)}}\n\\right)\n\\quad \\text{or} \\quad\n\\overrightarrow{{h}^{(t)}} + \\overleftarrow{{h}^{(t)}}\n\\]</div><p></p><p>在实践中，双向 RNN 更常采用<strong>拼接方式</strong>保留来自两个时间方向的完整信息，而<strong>逐元素相加</strong>则是一种更紧凑、但表达能力受限的折中选择。</p>\n<p>最后，再打个比方：把序列比作一座<strong>要建的桥</strong>，双向 RNN 就像是两队工人从两侧同时施工并不断交流进度，确保精准，但同时，施工队伍翻倍，整体成本也随之上升。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260113211553645-1826290875.png\" /></p>\n<h1 id=\"2-深层-rnn\">2. 深层 RNN</h1>\n<p>深层 RNN 的概念同样不难理解。<br />\n在最开始引入 <strong><a href=\"https://www.cnblogs.com/Goblinscholar/p/19449622\" target=\"_blank\">循环神经网络</a></strong> 时，我们说明过，默认使用<strong>单层 RNN</strong> 来进行演示：<br />\n在每一个时间步 <span class=\"math inline\">\\(t\\)</span>，输入 <span class=\"math inline\">\\(x^{(t)}\\)</span> 经过一次循环计算，得到对应的隐藏状态 <span class=\"math inline\">\\(a^{(t)}\\)</span>，并沿时间轴不断传递。</p>\n<p>但从模型表达能力的角度来看，这种结构存在限制：<strong>每个时间步内部，只进行了一次非线性变换。</strong><br />\n这意味着，无论序列本身有多复杂，在“同一时刻”对输入信息的处理深度都是有限的。<br />\n到这里，就和之前的全连接、卷积网络相通了：<br />\n<strong>如果我们希望模型在每一个时间步上，也具备类似深度前馈网络、卷积网络那样的层级表达能力，该怎么办？</strong><br />\n答案自然就是：<strong>在时间维度之外，再引入层级维度。</strong></p>\n<p>在深层 RNN 中，循环结构不再只有一层，而是<strong>在同一时间步上堆叠多层 RNN 单元</strong>。<br />\n它的传播图是这样的：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260113211513339-2004923823.png\" /><br />\n关于深度的逻辑和之前都是相同的，深层 RNN 通过在同一时间步上的堆叠，让模型可以进行更复杂的非线性变换，<strong>增强了其表达能力</strong>。但同样也会增加计算成本，<strong>带来梯度问题与过拟合风险</strong>，这些都是我们的老生常谈了。</p>\n<p>于此同时，和双向 RNN 类似，<strong>深层结构同样独立于具体的循环单元设计</strong>。  而且在工程实践中，<strong>深度、方向性和门控机制往往是可以同时叠加的</strong>，例如：</p>\n<ul>\n<li>多层 Bi-LSTM</li>\n<li>多层 Bi-GRU</li>\n</ul>\n<p>我们把各个组件组合或创新，便形成了深度学习 NLP 中纷繁复杂的诸多模型。</p>\n<p>最后，如果继续沿用前面的比喻：<br />\n<strong>双向 RNN</strong> 像是从桥的两端同时施工。<br />\n那么 <strong>深层 RNN</strong> 更像是： 每一个施工点上，不只是铺一层路面，而是<strong>一层层打地基、加结构、再铺表层。</strong> 这样结构更稳、表达更强，但施工流程更复杂，成本和训练难度也随之上升。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260113211517590-653078512.png\" /></p>\n<h1 id=\"3总结\">3.总结</h1>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>原理</th>\n<th>比喻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>双向 RNN（Bidirectional RNN）</td>\n<td>在时间维度上引入<strong>正向和反向两条独立状态链路</strong>，每个时间步同时利用过去和未来上下文信息。适用于序列标注与整体理解任务。可以与 RNN/LSTM/GRU 结合，形成 Bi-RNN、Bi-LSTM、Bi-GRU。</td>\n<td>序列比作桥，两队工人从两端同时施工并交流进度，确保精准，但施工队伍翻倍，成本增加。</td>\n</tr>\n<tr>\n<td>深层 RNN（Deep RNN）</td>\n<td>在同一时间步上<strong>堆叠多层 RNN 单元</strong>，增加每个时间步内部的非线性表达能力，从而增强模型的表示能力。可与门控机制和双向结构叠加，形成多层 Bi-LSTM、Bi-GRU 等。</td>\n<td>每个施工点上不是只铺一层路面，而是<strong>一层层打地基、加结构、再铺表层</strong>，结构更稳、表达更强，但施工流程复杂，成本和训练难度增加。</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 22:37</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Goblinscholar\">哥布林学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "synchronized关键字相关",
      "link": "https://www.cnblogs.com/xi-yongqi/p/19479394",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xi-yongqi/p/19479394\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 22:24\">\n    <span>synchronized关键字相关</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h5 id=\"synchronized是java中用于解决并发问题的核心关键字它通过确保多个线程对共享资源的互斥访问来避免线程安全问题如竞态条件数据不一致等\">synchronized是Java中用于解决并发问题的核心关键字，它通过确保多个线程对共享资源的互斥访问，来避免线程安全问题（如竞态条件、数据不一致等）。</h5>\n<h4 id=\"synchronized的核心特性\">synchronized的核心特性</h4>\n<ul>\n<li>原子性（Atomicity）：确保一个或多个操作要么全部执行成功，要么全部执行失败。在synchronized代码块中的代码是不可中断的，同一时刻只有一个线程能执行。</li>\n<li>可见性（Visibility）：保证一个线程对共享变量的修改，对于其他后续进入同步代码块的线程是可见的。当线程释放锁时，会将私有内存中的变量值刷新回主内存。</li>\n<li>有序性（Ordering）：虽然编译器和处理器为了优化会进行指令重排，但synchronized可以保证多线程程序在逻辑上的执行顺序，即“同步块内的代码在执行上具有先后顺序”。</li>\n<li>可重入性：可重入性是指一个线程已经获取到某个锁后，再次请求该锁时可以直接获取，无需重新竞争。synchronized是可重入锁，其内部通过计数器记录锁的持有次数（初始为0，获取锁时加1，释放锁时减1，计数器为0时锁才被真正释放）。这一特性避免了线程在递归调用同步方法/代码块时出现死锁。例如，一个同步方法A调用另一个同步方法B（两者锁对象相同），线程获取A的锁后，调用B时可直接获取锁。</li>\n</ul>\n<h4 id=\"synchronized的使用方式\">synchronized的使用方式</h4>\n<h5 id=\"synchronized的使用灵活可修饰不同的代码结构核心是明确锁对象线程竞争的是锁对象只有获取到锁对象的线程才能执行同步代码常见使用方式有3种\">synchronized的使用灵活，可修饰不同的代码结构，核心是明确“锁对象”——线程竞争的是锁对象，只有获取到锁对象的线程才能执行同步代码，常见使用方式有3种。</h5>\n<ol>\n<li>修饰实例方法（对象锁），语法：<code>public synchronized void methodName() { ... }</code></li>\n</ol>\n<ul>\n<li>锁对象：当前类的实例对象（this）。</li>\n<li>特点：不同实例对象的锁相互独立，即多个线程访问同一个实例的同步实例方法时会竞争锁；访问不同实例的同步实例方法时，因锁对象不同，不会竞争。</li>\n<li>示例：同一User实例的add()方法被多线程调用时互斥，不同User实例的add()方法可并行执行。</li>\n</ul>\n<ol start=\"2\">\n<li>修饰静态方法（类锁）语法：<code>public static synchronized void methodName() { ... }</code></li>\n</ol>\n<ul>\n<li>锁对象：当前类的Class对象（每个类在JVM中只有一个Class对象，是全局唯一的）。</li>\n<li>特点：类锁是全局锁，无论创建多少个类的实例，所有线程访问该类的同步静态方法时，都会竞争同一个Class对象锁。</li>\n<li>注意：类锁与对象锁相互独立，即同步静态方法和同步实例方法的锁对象不同，线程访问时不会竞争。</li>\n</ul>\n<ol start=\"3\">\n<li>修饰代码块（自定义锁对象），语法：<code>synchronized (锁对象) { ... 同步代码 ... }</code></li>\n</ol>\n<ul>\n<li>锁对象：可自定义，支持两种类型：① 实例对象（this或其他实例）；② Class对象（类名.class）。</li>\n<li>特点：粒度最细，可精准控制需要同步的代码片段（而非整个方法），减少锁竞争，提高程序性能。</li>\n<li>常见场景：\n<ul>\n<li>锁当前实例：<code>synchronized (this) { ... }</code>，效果与修饰实例方法一致，但仅同步代码块内的逻辑。</li>\n<li>锁Class对象：<code>synchronized (User.class) { ... }</code>，效果与修饰静态方法一致。</li>\n<li>锁自定义对象：<code>private Object lock = new Object(); synchronized (lock) { ... }</code>，通过独立的锁对象，避免与其他同步逻辑竞争锁，灵活性最高。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"synchronized的锁机制\">synchronized的锁机制</h4>\n<ul>\n<li>Java 6及以后对synchronized进行了大幅优化，引入了“偏向锁、轻量级锁、重量级锁”三种锁状态，目的是根据线程竞争的激烈程度动态切换锁状态，平衡性能与线程安全。锁机制的核心是“对象头”——Java对象在内存中的布局包括对象头、实例数据、对齐填充，其中对象头存储了锁的状态信息（Mark Word）、类元数据指针等。</li>\n<li>三种锁状态的优先级：无锁 &lt; 偏向锁 &lt; 轻量级锁 &lt; 重量级锁，随着线程竞争的加剧，锁会从低级别向高级别升级，且升级过程不可逆（一旦升级为重量级锁，无法回退为轻量级锁或偏向锁）。\n<ul>\n<li>无锁（No Lock）：初始状态。</li>\n<li>偏向锁（Biased Lock）：当只有一个线程访问同步块时，直接在对象头记录线程ID，下次该线程进入时无需CAS操作，性能极高。</li>\n<li>轻量级锁（Lightweight Lock）：当出现竞争，但竞争不激烈时，通过CAS自旋来尝试获取锁，避免线程阻塞。</li>\n<li>重量级锁（Heavyweight Lock）：当自旋超过一定次数或竞争非常激烈时，升级为重量级锁。此时未获取到锁的线程会进入阻塞（Blocked）状态，交给操作系统管理。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"锁优化补充\">锁优化补充</h5>\n<ul>\n<li><strong>锁消除</strong>：JVM的即时编译器（JIT）在运行时，会对一些“不可能存在竞争的锁”进行消除。例如，局部变量作为锁对象（每个线程都有独立的局部变量，无共享），JVM会直接删除该synchronized修饰，避免不必要的锁开销。</li>\n<li><strong>锁粗化</strong>：当多个连续的synchronized代码块使用同一个锁对象时，JVM会将这些代码块合并为一个大的同步代码块，减少锁的获取/释放次数（每次获取/释放锁都有开销）。例如，循环内多次调用同步方法，JVM可能将锁粗化到循环外部。</li>\n</ul>\n<hr />\n<h4 id=\"cas-compare-and-swap比较并交换-是并发编程中实现原子操作的核心算法是一种乐观锁的实现策略\">CAS (Compare And Swap，比较并交换) 是并发编程中实现原子操作的核心算法，是一种乐观锁的实现策略。</h4>\n<ol>\n<li>CAS的工作原理，包含三个核心参数：</li>\n</ol>\n<ul>\n<li>内存地址 V (Memory Location)：变量在内存中的实际值。</li>\n<li>期望值 A (Expected Value)：线程认为该变量当前应该是什么值。</li>\n<li>新值 B (New Value)：线程想要更新成的值。</li>\n<li>执行逻辑：当且仅当内存地址 V 的值等于期望值 A 时，处理器才会将 V 的值更新为 B。否则，说明该变量已被其他线程修改，当前线程什么都不做，通常会进入自旋（死循环重试）。</li>\n</ul>\n<ol start=\"2\">\n<li>CAS的优缺点<br />\n<strong>优点：</strong></li>\n</ol>\n<ul>\n<li>非阻塞性：CAS 是一种非阻塞算法（Non-blocking），它不需要像 synchronized 那样挂起和恢复线程。</li>\n<li>性能高：在低、中度竞争的情况下，由于减少了线程上下文切换的开销，效率远高于重量级锁。<br />\n<strong>缺点：</strong></li>\n<li>循环时间长（自旋开销）：如果高并发下竞争激烈，CAS 会频繁失败并不断自旋，这会给 CPU 带来巨大的计算压力。</li>\n<li>只能保证一个共享变量的原子操作：对于多个变量的操作，仍需使用 synchronized 或 ReentrantLock。</li>\n<li>ABA 问题（最经典的缺点）。</li>\n</ul>\n<ol start=\"3\">\n<li>什么是 ABA 问题？</li>\n</ol>\n<ul>\n<li>如果变量初始值为A，在线程1准备修改它的过程中，线程2快速地将其改成了B，然后又改回了A。 现象：线程1观察到值依然是A，认为它没变过，于是CAS成功。 风险：虽然数值没变，但变量的状态（或对象内部的属性）可能已经发生了变化，导致逻辑错误。</li>\n<li>Java提供了AtomicStampedReference类，通过引入版本号（Stamp）来解决： 每次变量更新时，不仅更新值，还增加一个版本号。只有值和版本号都一致，CAS才会成功。</li>\n<li>还可以设置时间戳来解决。</li>\n</ul>\n<ol start=\"4\">\n<li>CAS 在Java中的实现</li>\n</ol>\n<ul>\n<li>在Java中，CAS主要由 sun.misc.Unsafe 类提供支持。该类中的方法（如 compareAndSwapInt）是 native 的，直接调用硬件底层的指令。</li>\n</ul>\n<hr />\n<h4 id=\"reentrantlock可重入锁\">ReentrantLock（可重入锁）</h4>\n<ul>\n<li>ReentrantLock是 Java java.util.concurrent.locks 包下的可重入锁实现，基于 AQS（抽象队列同步器）构建，是 synchronized 的 “增强版”—— 既保留了 synchronized 的可重入特性，又提供了更灵活的同步控制能力。</li>\n</ul>\n<h5 id=\"两者对比\">两者对比:</h5>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>synchronized</th>\n<th>ReentrantLock</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>实现层面</td>\n<td>JVM 层面（关键字），由 C++ 实现</td>\n<td>JDK 层面（API），由 Java 编写（基于 AQS）</td>\n</tr>\n<tr>\n<td>锁的释放</td>\n<td>自动释放（代码执行完或异常后）</td>\n<td>手动释放（必须在 finally 中调用 unlock()）</td>\n</tr>\n<tr>\n<td>灵活性</td>\n<td>低（不可中断，无超时机制）</td>\n<td>高（支持尝试获取、超时获取、可中断获取）</td>\n</tr>\n<tr>\n<td>公平性</td>\n<td>只支持非公平锁</td>\n<td>支持公平锁与非公平锁（默认非公平）</td>\n</tr>\n<tr>\n<td>等待队列</td>\n<td>只能关联 1 个 等待队列（wait/notify）</td>\n<td>可以绑定 多个 Condition（精细化唤醒）</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"reentrantlock的特有高级功能\">ReentrantLock的特有高级功能</h5>\n<ol>\n<li>响应中断 (lockInterruptibly)</li>\n</ol>\n<ul>\n<li>synchronized一旦进入阻塞等待，除非拿到锁，否则无法被中断。而ReentrantLock允许线程在等待锁的过程中响应Thread.interrupt()，从而避免死等。</li>\n</ul>\n<ol start=\"2\">\n<li>超时机制 (tryLock)</li>\n</ol>\n<ul>\n<li>线程可以尝试获取锁，如果锁被占用，立即返回 false 或者等待一段时间后返回，而不是一直阻塞。这在预防死锁时非常有用。</li>\n</ul>\n<ol start=\"3\">\n<li>公平锁 (Fairness)</li>\n</ol>\n<ul>\n<li>公平锁：按照线程请求锁的顺序分配，先到先得。</li>\n<li>非公平锁（默认）：允许“插队”。如果新来的线程正好碰到锁释放，它可以直接抢占，性能通常比公平锁高。</li>\n</ul>\n<ol start=\"4\">\n<li>多个 Condition 对象</li>\n</ol>\n<ul>\n<li>通过lock.newCondition()，你可以创建多个等待集。例如在阻塞队列中，可以定义 notFull 和 notEmpty 两个条件，实现比 notifyAll 更精准的线程唤醒。</li>\n</ul>\n<h5 id=\"基本使用示例\">基本使用示例：</h5>\n<pre><code class=\"language-java\">import java.util.concurrent.locks.ReentrantLock;\n\npublic class ReentrantLockDemo {\n    // 创建非公平锁（默认），若需公平锁：new ReentrantLock(true)\n    private static final ReentrantLock lock = new ReentrantLock();\n\n    public static void doTask() {\n        // 1. 普通获取锁（不可中断）\n        lock.lock();\n        try {\n            // 临界区代码（线程安全）\n            System.out.println(Thread.currentThread().getName() + \" 执行任务\");\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        } finally {\n            // 必须在finally中释放锁，否则锁永远无法释放\n            lock.unlock();\n        }\n    }\n\n    // 超时获取锁示例\n    public static void tryLockWithTimeout() {\n        try {\n            // 尝试在2秒内获取锁，获取成功返回true，失败返回false\n            if (lock.tryLock(2, java.util.concurrent.TimeUnit.SECONDS)) {\n                try {\n                    System.out.println(Thread.currentThread().getName() + \" 超时获取锁成功\");\n                } finally {\n                    lock.unlock();\n                }\n            } else {\n                System.out.println(Thread.currentThread().getName() + \" 超时获取锁失败\");\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    public static void main(String[] args) {\n        // 测试普通获取锁\n        new Thread(ReentrantLockDemo::doTask, \"线程1\").start();\n        new Thread(ReentrantLockDemo::doTask, \"线程2\").start();\n        \n        // 测试超时获取锁\n        new Thread(ReentrantLockDemo::tryLockWithTimeout, \"线程3\").start();\n    }\n}\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 22:24</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xi-yongqi\">我会替风去</a>&nbsp;\n阅读(<span id=\"post_view_count\">4</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "从Shapefile到GeoJSON：用GDAL实现GIS矢量数据读写与空间分析",
      "link": "https://www.cnblogs.com/charlee44/p/19479143",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/charlee44/p/19479143\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 20:25\">\n    <span>从Shapefile到GeoJSON：用GDAL实现GIS矢量数据读写与空间分析</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"从Shapefile到GeoJSON：用GDAL实现GIS矢量数据读写与空间分析\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/1000410/202601/1000410-20260113202625252-636759511.png\" />\n        通过 GDAL/OGR 实现了 GIS 矢量数据的完整处理流程——从 Shapefile 读取、WGS84 到 Web 墨卡托坐标转换，到 GeoJSON 写入，并演示了点与多边形拓扑关系（如 Contains）的判断方法。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>本文节选自作者新书<a href=\"https://item.jd.com/14603137.html\" rel=\"noopener nofollow\" target=\"_blank\">《GIS基础原理与技术实践》</a>第4章，系统讲解矢量数据开发基础，涵盖 OGR/GDAL 使用、坐标转换、拓扑判断等实战内容。</p>\n</blockquote>\n<p><img alt=\"GIS基础原理与技术实践\" class=\"lazyload\" /></p>\n<h2 id=\"44-矢量数据开发基础\">4.4 矢量数据开发基础</h2>\n<p>通过之前的介绍，相信读者已经对于GIS的矢量数据有了一个全面的认识，尽管可能不是那么深入。但是没有关系，我们可以在实际的开发过程中加深对其的认识。</p>\n<h3 id=\"441-第三方开源库ogrgdal\">4.4.1 第三方开源库OGR/GDAL</h3>\n<p>在第3章的时候，我们小试牛刀，通过第三方开源库PROJ/GDAL很简单的就实现了地理空间参考系统的相互转换。在这里同样如此，我们可以通过GDAL的OGR组件，轻松实现GIS矢量数据的基础开发。</p>\n<p>OGR曾经是一个独立的矢量IO库，表示OpenGIS Simple Features Reference Implementation的意思，但其实OGR不完全符合OGC的Simple Feature标准规范，因此未被批准作为该规范的参考实现（当然也非常接近规范了）。从GDAL2.0开始，GDAL和OGR组件被集成在一起。</p>\n<p>OGR/GDAL提供了非常强大的矢量读写能力，支持市面上绝大多数矢量数据格式。在第3章我们介绍GDAL的时候就提到过，GDAL是一个GIS数据抽象库。所谓数据抽象，是指无论是哪一种具体的矢量数据格式，GDAL都会将其抽象成数据集对象（Dataset），从而可以支持读取、写出和处理操作。常用的矢量数据格式如下：</p>\n<ul>\n<li>DXF/DWG：应用最广泛的几何图形数据格式，在CAD领域内用的非常多，但是缺点是缺少地理信息。</li>\n<li>ESRI Shapefile：GIS中最常见的矢量数据格式，几乎所有的商业和开源GIS软件都支持。除了几何信息之外，还包含空间信息和属性信息。</li>\n<li>GeoJSON：一种通过JSON来表述要素的矢量数据格式，因而很容易被JavaScript解析和处理，适用于Web端的轻量化应用。</li>\n<li>KML：Google提出的一种基于XML标准来描述地理空间信息的数据格式（包括点、线、面、多边形和模型等），并且已经被OGC认定为开放地理信息编码标准。</li>\n</ul>\n<p>在GDAL中，对数据格式的支持被封装成驱动（dirver），包括上述格式在内的数据驱动要么内嵌在GDAL中，要么通过另外的第三方库来支持。当然这些我们可以暂时不用关心，直接使用本书Github主页代码仓库中的GDAL即可。</p>\n<h3 id=\"442-矢量数据的读取处理和写入\">4.4.2 矢量数据的读取、处理和写入</h3>\n<p>了解了第三方库OGR/GDAL，接下来我们就通过其实现关于GIS矢量数据的基础开发。一个很容易理解的常识是，包含GIS矢量数据在内的任何数据的操作都离不开三个过程：读取、处理和写入。因此，这里我们结合前面空间坐标参考转换的实践，实现一个简单的实例：读取一个面的矢量，然后对其进行空间参考的转换，最后重新写出一个矢量。具体的实现代码如下：</p>\n<pre><code class=\"language-cpp\">#include &lt;ogrsf_frmts.h&gt;\n\n#include &lt;Eigen/Eigen&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\nusing namespace Eigen;\n\nusing Point = Vector3d;\nusing Line = vector&lt;Point&gt;;\nusing Polygon = vector&lt;Line&gt;;\n\nvector&lt;Polygon&gt; polygonData;\n\nOGRSpatialReference srcFileSpatialReference;\nOGRSpatialReference dstFileSpatialReference;\n\nvoid OgrRing2Line(OGRLinearRing *ogrLinearRing, Line &amp;line) {\n  for (int i = 0; i &lt; ogrLinearRing-&gt;getNumPoints(); i++) {\n    line.emplace_back(ogrLinearRing-&gt;getX(i), ogrLinearRing-&gt;getY(i),\n                      ogrLinearRing-&gt;getZ(i));\n  }\n}\n\nvoid OgrPolygon2Polygon(OGRPolygon *ogrPolygon, Polygon &amp;polygon) {\n  //外环\n  Line line;\n  OgrRing2Line(ogrPolygon-&gt;getExteriorRing(), line);\n  polygon.push_back(line);\n\n  //内环\n  for (int ri = 0; ri &lt; ogrPolygon-&gt;getNumInteriorRings(); ri++) {\n    Line line;\n    OgrRing2Line(ogrPolygon-&gt;getInteriorRing(ri), line);\n    polygon.push_back(line);\n  }\n}\n\nbool ReadShp() {\n  string srcFile = getenv(\"GISBasic\");\n  srcFile = srcFile + \"/../Data/Vector/multipolygons.shp\";\n\n  GDALDataset *poDS = (GDALDataset *)GDALOpenEx(srcFile.c_str(), GDAL_OF_VECTOR,\n                                                NULL, NULL, NULL);\n  if (!poDS) {\n    printf(\"无法读取该文件，请检查数据是否存在问题！\");\n    return false;\n  }\n\n  if (poDS-&gt;GetLayerCount() &lt; 1) {\n    printf(\"该文件的层数小于1，请检查数据是否存在问题！\");\n    return false;\n  }\n\n  //原始数据空间参考\n  char *pszWKT = nullptr;\n  poDS-&gt;GetLayer(0)-&gt;GetSpatialRef()-&gt;exportToWkt(&amp;pszWKT);\n  srcFileSpatialReference.importFromWkt(pszWKT);\n  CPLFree(pszWKT);\n  pszWKT = nullptr;\n\n  for (int li = 0; li &lt; poDS-&gt;GetLayerCount(); li++) {\n    OGRLayer *poLayer = poDS-&gt;GetLayer(li);  //读取层\n    poLayer-&gt;ResetReading();\n\n    //输出字段名\n    OGRFeatureDefn *poFDefn = poLayer-&gt;GetLayerDefn();\n    int n = poFDefn-&gt;GetFieldCount();\n    for (int iField = 0; iField &lt; n; iField++) {\n      OGRFieldDefn *OGRFieldDefn = poFDefn-&gt;GetFieldDefn(iField);\n      cout &lt;&lt; OGRFieldDefn-&gt;GetNameRef() &lt;&lt; endl;\n    }\n\n    //遍历特征\n    OGRFeature *poFeature = nullptr;\n    while ((poFeature = poLayer-&gt;GetNextFeature()) != nullptr) {\n      OGRGeometry *geometry = poFeature-&gt;GetGeometryRef();\n      OGRwkbGeometryType geometryType = geometry-&gt;getGeometryType();\n\n      switch (geometryType) {\n        case wkbPolygon:\n        case wkbPolygonM:\n        case wkbPolygonZM: {\n          OGRPolygon *ogrPolygon = dynamic_cast&lt;OGRPolygon *&gt;(geometry);\n          if (!ogrPolygon) {\n            continue;\n          }\n\n          Polygon polygon;\n          OgrPolygon2Polygon(ogrPolygon, polygon);\n          polygonData.push_back(polygon);\n\n          break;\n        }\n        case wkbMultiPolygon:\n        case wkbMultiPolygonM:\n        case wkbMultiPolygonZM: {\n          OGRMultiPolygon *ogrMultiPolygon =\n              dynamic_cast&lt;OGRMultiPolygon *&gt;(geometry);\n          if (!ogrMultiPolygon) {\n            continue;\n          }\n\n          for (int gi = 0; gi &lt; ogrMultiPolygon-&gt;getNumGeometries(); gi++) {\n            OGRPolygon *ogrPolygon =\n                dynamic_cast&lt;OGRPolygon *&gt;(ogrMultiPolygon-&gt;getGeometryRef(gi));\n            if (!ogrPolygon) {\n              continue;\n            }\n\n            Polygon polygon;\n            OgrPolygon2Polygon(ogrPolygon, polygon);\n            polygonData.push_back(polygon);\n          }\n\n          break;\n        }\n        default: {\n          printf(\"未处理的特征类型\\n\");\n          break;\n        }\n      }\n\n      //输出每个字段的值\n      for (int iField = 0; iField &lt; n; iField++) {\n        cout &lt;&lt; poFeature-&gt;GetFieldAsString(iField) &lt;&lt; \"    \";\n      }\n      cout &lt;&lt; endl;\n\n      OGRFeature::DestroyFeature(poFeature);\n    }\n  }\n\n  GDALClose(poDS);\n  poDS = nullptr;\n\n  return true;\n}\n\nvoid Convert() {\n  dstFileSpatialReference.importFromEPSG(3857);\n  dstFileSpatialReference.SetAxisMappingStrategy(OAMS_TRADITIONAL_GIS_ORDER);\n  srcFileSpatialReference.SetAxisMappingStrategy(OAMS_TRADITIONAL_GIS_ORDER);\n\n  OGRCoordinateTransformation *src2DstTransformation =\n      OGRCreateCoordinateTransformation(&amp;srcFileSpatialReference,\n                                        &amp;dstFileSpatialReference);\n\n  if (!src2DstTransformation) {\n    return;\n  }\n\n  for (auto &amp;polygon : polygonData) {\n    for (auto &amp;line : polygon) {\n      for (auto &amp;point : line) {\n        src2DstTransformation-&gt;Transform(1, point.data(), point.data() + 1,\n                                         point.data() + 2);\n      }\n    }\n  }\n}\n\nbool CreateField(OGRLayer *poLayer) {\n  // 字符串\n  OGRFieldDefn oField1(\"Type\", OFTString);\n  oField1.SetWidth(8);\n  if (poLayer-&gt;CreateField(&amp;oField1) != OGRERR_NONE) {\n    printf(\"Creating Name field failed.\\n\");\n    return false;\n  }\n\n  // 浮点数\n  OGRFieldDefn oField2(\"Area\", OFTReal);\n  oField2.SetPrecision(3);\n  if (poLayer-&gt;CreateField(&amp;oField2) != OGRERR_NONE) {\n    printf(\"Creating Name field failed.\\n\");\n    return false;\n  }\n\n  // 整型\n  OGRFieldDefn oField3(\"VertexCount\", OFTInteger);\n  if (poLayer-&gt;CreateField(&amp;oField3) != OGRERR_NONE) {\n    printf(\"Creating Name field failed.\\n\");\n    return false;\n  }\n\n  return true;\n}\n\nbool WriteGeoJson() {\n  string dstFile = getenv(\"GISBasic\");\n  dstFile = dstFile + \"/../Data/Out.geoJson\";\n\n  //创建\n  GDALDriver *driver = GetGDALDriverManager()-&gt;GetDriverByName(\"GeoJSON\");\n  if (!driver) {\n    printf(\"Get Driver GeoJSON Error！\\n\");\n    return false;\n  }\n\n  GDALDataset *dataset =\n      driver-&gt;Create(dstFile.c_str(), 0, 0, 0, GDT_Unknown, NULL);\n  OGRLayer *poLayer = dataset-&gt;CreateLayer(\n      \"FirstLayer\", &amp;dstFileSpatialReference, wkbPolygon, NULL);\n\n  if (!CreateField(poLayer)) {\n    return false;\n  }\n\n  //创建特征\n  for (const auto &amp;polygon : polygonData) {\n    OGRFeature ogrFeature(poLayer-&gt;GetLayerDefn());\n\n    OGRPolygon ogrPolygon;\n\n    int vertexNum = 0;\n    for (const auto &amp;line : polygon) {\n      OGRLinearRing ogrRing;\n      for (const auto &amp;point : line) {\n        ogrRing.addPoint(point.x(), point.y(), point.z());\n        vertexNum++;\n      }\n      ogrPolygon.addRing(&amp;ogrRing);\n    }\n    ogrFeature.SetGeometry(&amp;ogrPolygon);\n\n    ogrFeature.SetField(\"Type\", \"Polygon\");\n    ogrFeature.SetField(\"Area\", ogrPolygon.get_Area());\n    ogrFeature.SetField(\"VertexCount\", vertexNum);\n\n    if (poLayer-&gt;CreateFeature(&amp;ogrFeature) != OGRERR_NONE) {\n      printf(\"Failed to create feature.\\n\");\n      return false;\n    }\n  }\n\n  //释放\n  GDALClose(dataset);\n  dataset = nullptr;\n\n  return true;\n}\n\nint main() {\n  GDALAllRegister();\n  CPLSetConfigOption(\"GDAL_FILENAME_IS_UTF8\", \"NO\");  //支持中文路径\n  CPLSetConfigOption(\"SHAPE_ENCODING\", \"\");           //解决中文乱码问题\n\n  if (!ReadShp()) {\n    return 1;\n  }\n\n  Convert();\n\n  WriteGeoJson();\n}\n</code></pre>\n<p>在这里，读取的矢量是一个Shapefile文件，包含的都是多边形的要素，空间参考为WGS84地理坐标系（EPSG：4326），显示如下图4.14所示：</p>\n<p><img alt=\"图4.14 处理前多边形矢量要素\" class=\"lazyload\" /></p>\n<p>经过空间参考转换后，空间参考为Web墨卡托投影坐标系（EPSG：3857），且生成的是一个GeoJson文件。如下图4.15所示，可以看到在空间坐标参考转换之后形状似乎“变窄”了一点，这是地图投影变换的特性决定的（参考第2章介绍的知识）。</p>\n<p><img alt=\"图4.15 处理后多边形矢量要素\" class=\"lazyload\" /></p>\n<p>这段代码的关键在于如下几点：</p>\n<ul>\n<li>\n<p>读取矢量时，矢量数据被读取成数据集对象GDALDataset，GDALDataset管理图层对象OGRLayer，OGRLayer管理特征类对象OGRFeature，OGRFeature则包含几何对象类OGRGeometry。OGRGeometry是一个抽象父类，有意义的是其表达具体的几何对象的子类，比如OGRPolygon代表多边形几何对象。OGRPolygon又是由1个外环和多个内环（环线：OGRLinearRing）组成。矢量就是这样一层层抽象组合表达出来的。</p>\n</li>\n<li>\n<p>在进行数据处理也就是空间参考转换之前，我们把读取的数据放到我们自己的数据容器中：</p>\n<pre><code class=\"language-cpp\">using Point = Vector3d;\nusing Line = vector&lt;Point&gt;;\nusing Polygon = vector&lt;Line&gt;;\n\nvector&lt;Polygon&gt; polygonData;\n</code></pre>\n<p>真实的GIS数据处理开发要求是千变万化的，操作的往往不是读取组件（这里指OGR）定义的数据结构对象。我们可以将其读取在成自定义的数据结构中，以方便我们进行更加通用的操作，或者进行并行优化。在这里我们遍历了自定义的数据结构对象中的顶点，逐点进行空间坐标参考的转换。进行其他的数据处理也是如此，根据自己的需要操作自己的数据结构容器。</p>\n</li>\n<li>\n<p>写出矢量时，将处理结束的自定义数据结构对象恢复成数据集对象GDALDataset（读取矢量的逆操作）。另外，需要关注的是GDAL的数据驱动GDALDriver，其是通过名称来创建对应格式的矢量文件，例如这里传入到名称是GeoJson:</p>\n<pre><code class=\"language-cpp\">GDALDriver *driver = GetGDALDriverManager()-&gt;GetDriverByName(\"GeoJSON\");\nif (!driver) {\n  printf(\"Get Driver GeoJSON Error！\\n\");\n  return false;\n}\n</code></pre>\n</li>\n<li>\n<p>矢量数据的属性表数据与数据库中的表结构比较类似，每个字段具有自己的定义属性，例如数据类型、长度、精度等。并且，每一个特征都对应了一行记录。因而属性表的操作还是挺复杂的，往往与业务操作相关联。这里仅仅只是输出显示了读取的属性表信息，写入了自己创建的字段与值。读取和写入的属性表数据如下图4.16、图4.17所示：</p>\n</li>\n</ul>\n<p><img alt=\"图4.16 读取的属性表信息\" class=\"lazyload\" /><br />\n<img alt=\"图4.17 写入的属性表信息\" class=\"lazyload\" /></p>\n<h3 id=\"443-空间拓扑关系的判断\">4.4.3 空间拓扑关系的判断</h3>\n<p>对矢量要素进行空间拓扑关系的判断也是GIS开发中常用的功能。在4.3.3节中介绍了OGC的Simple Feature标准规范中拓扑关系，OGR/GDAL对其做了具体的实现。任何继承了OGRGeometry的几何对象类（如OGRPoint、OGRPolygon）都可以调用标准中定义的接口（二元谓词），判断该几何对象与另外一个几何对象的拓扑关系。在如下实例中，判断了空间中某点与某多边形是否存在包含（Contains）关系：</p>\n<pre><code class=\"language-cpp\">#include &lt;ogrsf_frmts.h&gt;\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n  OGRLinearRing linearRing;\n  linearRing.addPoint(268.28, 784.75);\n  linearRing.addPoint(153.98, 600.60);\n  linearRing.addPoint(274.63, 336.02);\n  linearRing.addPoint(623.88, 401.64);\n  linearRing.addPoint(676.80, 634.47);\n  linearRing.addPoint(530.75, 822.85);\n  linearRing.closeRings();\n\n  OGRPolygon polygon;\n  polygon.addRing(&amp;linearRing);\n\n  cout &lt;&lt; \"点A是否在多边形内：\";\n  OGRPoint pointA(407.98, 579.43);  \n  cout &lt;&lt; polygon.Contains(&amp;pointA) &lt;&lt; endl;\n\n  cout &lt;&lt; \"点B是否在多边形内：\";\n  OGRPoint pointB(678.92, 482.07);  \n  cout &lt;&lt; polygon.Contains(&amp;pointB) &lt;&lt; endl;\n}\n</code></pre>\n<p>运行的结果如下所示：</p>\n<pre><code class=\"language-text\">点A是否在多边形内：1\n点B是否在多边形内：0\n</code></pre>\n<p>在4.3.3节中介绍过，包含(Contains)与内含(Within)是一对相反的关系。在这里我们当然也可以调用OGRPoint的内含(Within)接口，会返回与上述同样的结果。不止如此，其他空间拓扑关系的接口也是这样调用，读者可以根据自己的需求尝试一二，这里只是抛砖引玉。</p>\n<hr />\n<p>本文节选自作者新书《GIS基础原理与技术实践》第4章。书中系统讲解 GIS 核心理论与多语言实战，适合开发者与高校师生。</p>\n<p>📚 <strong>配套资源开源</strong>：<a href=\"https://github.com/fafa1899/GISBasic\" rel=\"noopener nofollow\" target=\"_blank\">GitHub</a> | <a href=\"https://gitcode.com/charlee44/GISBasic\" rel=\"noopener nofollow\" target=\"_blank\">GitCode</a></p>\n<p>🛒 <strong>支持正版</strong>：<a href=\"https://item.jd.com/14603137.html\" rel=\"noopener nofollow\" target=\"_blank\">京东</a>｜<a href=\"https://product.dangdang.com/29988568.html\" rel=\"noopener nofollow\" target=\"_blank\">当当</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 20:25</span>&nbsp;\n<a href=\"https://www.cnblogs.com/charlee44\">charlee44</a>&nbsp;\n阅读(<span id=\"post_view_count\">13</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "电位器实现电机绝对位置测量-PART-电位计-绝对位置",
      "link": "https://www.cnblogs.com/SimLab/p/19479117",
      "published": "",
      "description": "<h2>\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/SimLab/p/19479117\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 20:11\">\n    <span>电位器实现电机绝对位置测量-PART-电位计-绝对位置</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"postbody\">\n            <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"电位器实现电机绝对位置测量-part-电位计-绝对位置\">电位器实现电机绝对位置测量-PART-电位计-绝对位置</h1>\n<blockquote>\n<p><strong>关键字</strong>：绝对位置, 电位器, Vishay Spectrol, 132</p>\n</blockquote>\n<hr />\n<h2 id=\"一问题分析\">一、问题分析</h2>\n<p>在运动控制实验中，我们需要测量旋转电机在有限角度范围（如 0–90°）内来回摆动的<strong>绝对位置</strong>。</p>\n<p>常规方法：</p>\n<ul>\n<li>绝对编码器或增量编码器输出数字信号，精度高。</li>\n</ul>\n<p>现场问题：</p>\n<ul>\n<li><strong>实验硬件本身不支持绝对编码器采集</strong>，无法直接使用</li>\n<li>摆动角度有限（不需要全圈 360°）</li>\n<li>系统需要稳定、可实时获取绝对位置的方案</li>\n</ul>\n<blockquote>\n<p>核心问题：如何在硬件不支持绝对编码器采集的情况下，实现可靠的绝对位置测量？</p>\n</blockquote>\n<hr />\n<h2 id=\"二解决方法--实施方案\">二、解决方法 / 实施方案</h2>\n<h3 id=\"1️⃣-硬件方案\">1️⃣ 硬件方案</h3>\n<ul>\n<li><strong>电位器选型</strong>：Vishay Spectrol Model 132（旋转角 352°）</li>\n<li><strong>齿轮传动</strong>：电机轴 → 齿轮 → 电位器滑动轴\n<ul>\n<li>电机旋转角 → 齿轮比 → 电位器滑动角</li>\n<li>保证电位器满量程覆盖实验摆动角度</li>\n</ul>\n</li>\n<li><strong>供电与电路设计</strong>：\n<ul>\n<li>电位器两端各自串7.5 kΩ 电阻分别接入 ±12 V 供电</li>\n<li>输出电压与摆动角度线性映射</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2️⃣-示意图\">2️⃣ 示意图</h3>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<hr />\n<h2 id=\"三使用提示\">三、使用提示</h2>\n<ul>\n<li>实验硬件不支持绝对编码器采集时，可使用电位器方案</li>\n<li>摆动角度有限（通常 0–90°）时，132 型电位器配齿轮可覆盖全范围</li>\n<li>电位器末端预留死区，避免机械磨损</li>\n<li>齿轮比合理设计，保证电位器满量程对应实验摆动角度</li>\n<li>输出电压可直接用于采集系统或模拟控制器</li>\n<li>若实验需要更大角度或全圈测量，可考虑升级电位器或使用绝对编码器</li>\n</ul>\n<blockquote>\n<p>总结：在硬件不支持绝对编码器采集的实验环境下，<strong>132 型电位器 + 齿轮传动 + 串联电阻供电</strong>是一种稳定、可行的绝对位置测量方案，操作简单，实验验证稳定。</p>\n</blockquote>\n<hr />\n<h2 id=\"四说明\">四、说明</h2>\n<ul>\n<li>\n<blockquote>\n<p>本文首发于【GitHub/Gitee】，作者：KANIC，研究方向为 自动化实验平台、控制算法验证及半实物仿真系统。</p>\n</blockquote>\n<p>相关实验或程序已整理至 GitHub，可在 GitHub 平台搜索 KANIC-lab/KANIC 查看。</p>\n<p>如需进一步讨论，可私信联系，并注明文章编号。文章编号位于标题末尾，以字母开头如“EXP-XXXX-XXX”</p>\n</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n        </div>\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\">2026-01-13 20:11</span>&nbsp;\n<a href=\"https://www.cnblogs.com/SimLab\">控制迷思</a>&nbsp;\n阅读(<span id=\"post_view_count\">9</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n        </p>"
    },
    {
      "title": "[python] 基于python-docx库的Word文档自动处理全解",
      "link": "https://www.cnblogs.com/luohenyueji/p/19479110",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/luohenyueji/p/19479110\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 20:08\">\n    <span>[python] 基于python-docx库的Word文档自动处理全解</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>python-docx是一款纯Python实现的第三方库，专门用于创建和修改Microsoft Word的.docx格式文档。该库无需依赖 Microsoft Word软件即可运行，具备优秀的跨平台特性，可在Windows、Mac、Linux等系统上使用。需要注意的是，python-docx仅兼容.docx 格式（对应 Word 2007 及以上版本），不支持旧版的.doc 格式文件。.docx是基于XML的开放压缩格式，而.doc是二进制私有格式，前者体积更小、兼容性更优。</p>\n<p>python-docx官方代码仓库见：<a href=\"https://github.com/python-openxml/python-docx\" rel=\"noopener nofollow\" target=\"_blank\">python-docx</a>，详细文档见：<a href=\"https://python-docx.readthedocs.io/en/latest/\" rel=\"noopener nofollow\" target=\"_blank\">python-docx docs</a>。截至本文撰写时，python-docx的稳定版本为1.2.0，python-docx安装命令如下：</p>\n<blockquote>\n<p>pip install python-docx</p>\n</blockquote>\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">目录</div><ul><li><a href=\"#1-使用说明\" rel=\"noopener nofollow\">1 使用说明</a><ul><li><a href=\"#11-快速入门\" rel=\"noopener nofollow\">1.1 快速入门</a></li><li><a href=\"#12-python-docx的核心对象\" rel=\"noopener nofollow\">1.2 Python-docx的核心对象</a><ul><li><a href=\"#121-document对象\" rel=\"noopener nofollow\">1.2.1 Document对象</a></li><li><a href=\"#122-table对象\" rel=\"noopener nofollow\">1.2.2 Table对象</a></li><li><a href=\"#123-文本处理\" rel=\"noopener nofollow\">1.2.3 文本处理</a></li><li><a href=\"#124-sections对象\" rel=\"noopener nofollow\">1.2.4 Sections对象</a></li><li><a href=\"#125-页眉页脚对象\" rel=\"noopener nofollow\">1.2.5 页眉页脚对象</a></li></ul></li><li><a href=\"#13-非文本内容管理\" rel=\"noopener nofollow\">1.3 非文本内容管理</a><ul><li><a href=\"#131-样式管理\" rel=\"noopener nofollow\">1.3.1 样式管理</a></li><li><a href=\"#132-批注管理\" rel=\"noopener nofollow\">1.3.2 批注管理</a></li><li><a href=\"#133-图片对象\" rel=\"noopener nofollow\">1.3.3 图片对象</a></li></ul></li><li><a href=\"#14-综合示例\" rel=\"noopener nofollow\">1.4 综合示例</a></li></ul></li><li><a href=\"#2-参考\" rel=\"noopener nofollow\">2 参考</a></li></ul></div><p></p>\n<h1 id=\"1-使用说明\">1 使用说明</h1>\n<h2 id=\"11-快速入门\">1.1 快速入门</h2>\n<p>Python-docx中的Word文档内存对象模型采用树状结构分层映射文档元素，使得程序能够精准控制文档的内容、格式与布局。该树状结构示意如下：</p>\n<pre><code class=\"language-shell\">Document（文档）\n├── Sections（节）\n├── Paragraphs（段落）\n│   ├── Runs（文本片段）\n│   └── InlineShapes（内联形状，如图片）\n├── Tables（表格）\n│   ├── Rows（行）\n│   │   └── Cells（单元格）\n│   │       └── Paragraphs（单元格内的段落）\n└── Core Properties（文档属性）\n</code></pre>\n<p>各个对象简介如下：</p>\n<table>\n<thead>\n<tr>\n<th>核心对象</th>\n<th>代表含义</th>\n<th>在文档树中的位置</th>\n<th>主要功能与说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Document</code></td>\n<td>整个Word文档对象</td>\n<td>根对象</td>\n<td>用于打开或创建一个<code>.docx</code>文件</td>\n</tr>\n<tr>\n<td><code>Sections</code></td>\n<td>文档的节</td>\n<td><code>Document.sections</code></td>\n<td>管理页面设置（如页边距、纸张方向）</td>\n</tr>\n<tr>\n<td><code>Paragraph</code></td>\n<td>段落</td>\n<td><code>Document.paragraphs</code>或<code>Table.cell.paragraphs</code></td>\n<td>文档的基本单元由一个或多个<code>Run</code>组成，并拥有统一的段落格式</td>\n</tr>\n<tr>\n<td><code>Run</code></td>\n<td>具有相同格式的连续文本</td>\n<td><code>Paragraph.runs</code></td>\n<td>格式控制的最小单位，可以对<code>Run</code>单独设置字体、大小等字符级格式</td>\n</tr>\n<tr>\n<td><code>Table</code></td>\n<td>表格</td>\n<td><code>Document.tables</code></td>\n<td>代表文档中的一个表格，由行（<code>Table.rows</code>）、列（<code>Table.columns</code>）和单元格（<code>Table.cell</code>）组成</td>\n</tr>\n<tr>\n<td><code>Cell</code></td>\n<td>表格单元格</td>\n<td><code>Table.cell(row,col)</code></td>\n<td>每个<code>Cell</code>本身可以包含多个<code>Paragraph</code>，就像一个微缩文档</td>\n</tr>\n<tr>\n<td><code>InlineShape</code></td>\n<td>内嵌形状（如图片）</td>\n<td><code>Paragraph.add_picture()</code>创建</td>\n<td>代表文档中与文本在同一层的图形对象，最常用的是图片</td>\n</tr>\n<tr>\n<td><code>Styles</code></td>\n<td>样式集合</td>\n<td><code>Document.styles</code></td>\n<td>管理文档中定义的所有样式（如“标题1”、“正文”等）</td>\n</tr>\n</tbody>\n</table>\n<p><img alt=\"\" src=\"https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/CSDN/%5Bpython%5D%20%E5%9F%BA%E4%BA%8Epython-docx%E5%BA%93%E7%9A%84Word%E6%96%87%E6%A1%A3%E8%87%AA%E5%8A%A8%E5%A4%84%E7%90%86%E5%85%A8%E8%A7%A3/imgs/1.jpg\" /></p>\n<p>以下代码示例描述了如何通过python-docx库快速实现文档的创建，完成段落、标题、表格、图片等内容添加及字符段落样式设置，并保存为docx文件：</p>\n<pre><code class=\"language-python\"># 1. 初始化文档\nfrom docx import Document\nfrom docx.shared import Inches, Cm\n\n# 新建空白文档，不添加参数，默认新建\ndoc = Document()  \n\n# 2. 添加段落\n# 默认都会把内容追加到文档的末尾\ndoc.add_paragraph(\"这是文档正文段落\")  # 直接添加段落\npara = doc.add_paragraph(\"主段落\") # 该方法返回新段落的引用对象\npara.insert_paragraph_before(\"插入在主段落上方的段落\")  # 主段落的引用之前插入段落\npara = doc.add_paragraph(\"插入在主段落下方的段落\") # 主段落的引用之后插入段落\n\n# 3. 添加标题（级别1-9，0为文档标题）\ndoc.add_heading(\"文档总标题\", level=0) # 一份报告的封面标题\ndoc.add_heading(\"第一章 概述\", level=1) # 一级标题\ndoc.add_heading(\"1.1 核心功能\", level=2) # 二级标题\n\n# 4. 分页符\ndoc.add_page_break()  # 强制后续内容另起一页\n\n# 5. 添加表格（固定行+动态行+样式）\n# 5.1 固定表格（2行2列）\ntable1 = doc.add_table(rows=2, cols=2)\ntable1.cell(0, 0).text = \"姓名\"\ntable1.cell(0, 1).text = \"年龄\"\ntable1.cell(1, 0).text = \"张三\"\ntable1.cell(1, 1).text = \"25\"\n\n# 5.2 动态表格（表头+数据行）\ntable2 = doc.add_table(rows=1, cols=3)\n# 将鼠标悬停在Word表格样式库中的表格样式缩略图上，即可找到表格样式名称\ntable2.style = \"Light Shading Accent 1\"  # 应用预设样式\nheaders = [\"数量\", \"产品编号\", \"描述\"]\nfor i, header in enumerate(headers):\n    table2.rows[0].cells[i].text = header\n# 批量添加数据\nitems = [(7, \"1024\", \"毛绒小猫\"), (3, \"2042\", \"菲比精灵\"), (1, \"1288\", \"豪华项圈\")]\nfor item in items:\n    row = table2.add_row().cells\n    row[0].text = str(item[0])\n    row[1].text = item[1]\n    row[2].text = item[2]\n\n# 6. 添加图片（本地文件+尺寸调整）\ndoc.add_picture(\"test.png\", width=Inches(1.5))  # 1.5英寸宽（自动等比缩放）\ndoc.add_picture(\"test2.jpg\", width=Cm(5),height=Cm(1))  # 同时指定宽高\n\n# 7. 段落样式（项目符号/编号）\ndoc.add_paragraph(\"项目符号列表项1\", style=\"ListBullet\")\ndoc.add_paragraph(\"项目符号列表项2\", style=\"ListBullet\")\ndoc.add_paragraph(\"编号列表项1\", style=\"ListNumber\")\n\n# 8. 字符格式（粗体/斜体）\npara = doc.add_paragraph()\npara.add_run(\"普通文本 \").bold = False\npara.add_run(\"粗体文本\").bold = True\npara.add_run(\" 普通文本 \").italic = False\npara.add_run(\"斜体文本\").italic = True\n\n# 9. 字符样式（预设样式）\npara2 = doc.add_paragraph(\"普通文本，\")\npara2.add_run(\"带强调的文本\", style=\"Emphasis\")  # 应用\"强调\"样式\n\n# 10. 保存文档\ndoc.save(\"test_output.docx\")\n</code></pre>\n<p>后续内容将对python-docx的各个核心对象进行具体介绍。</p>\n<h2 id=\"12-python-docx的核心对象\">1.2 Python-docx的核心对象</h2>\n<h3 id=\"121-document对象\">1.2.1 Document对象</h3>\n<p>Python-docx本质上是一个文档修改工具。即使创建新文档，其原理也是基于一个预设的空白模板进行修改。因此，文档的格式（如样式、页眉、页脚）与正文内容是分离存储的，即使清空模板文字也不会删除格式设定。以下示例展示了如何创建文档或打开已有文档：</p>\n<pre><code class=\"language-python\">from docx import Document\nfrom io import BytesIO, StringIO  # 用于类文件对象操作\n\n\"\"\"演示python-docx操作文档的核心功能\"\"\"\n# ===================== 1. 创建新文档并保存 =====================\nprint(\"1. 创建新文档并保存...\")\n# 基于默认模板创建空文档\nnew_doc = Document()\nnew_doc.add_heading('python-docx 文档操作示例', level=1)\nnew_doc.add_paragraph('这是通过python-docx创建的新文档')\n# 保存新文档到本地\nnew_doc.save('新建文档.docx')\nprint(\"✅ 新文档已保存为：新建文档.docx\")\n\n# ===================== 2. 打开现有文档并修改保存 =====================\nprint(\"\\n2. 打开现有文档并修改...\")\n# 打开刚才创建的文档\nexisting_doc = Document('新建文档.docx')\n# 向文档追加内容\nexisting_doc.add_paragraph('这是打开现有文档后追加的内容')\n# 另存为新文件（避免覆盖原文件）\nexisting_doc.save('修改后的文档.docx')\nprint(\"✅ 修改后的文档已保存为：修改后的文档.docx\")\n\n# ===================== 3. 通过类文件对象（BytesIO）读写文档 =====================\nprint(\"\\n3. 通过类文件对象操作文档...\")\n# 3.1 读取：将本地文档读取到BytesIO流中\nwith open('修改后的文档.docx', 'rb') as f:  # 必须用rb（二进制读），跨平台兼容\n    doc_stream = BytesIO(f.read())  # 用BytesIO而非StringIO\n\n# 从流中打开文档\nstream_doc = Document(doc_stream)\n# 追加内容\nstream_doc.add_paragraph('这是通过类文件对象添加的内容')\n\n# 3.2 保存：将文档保存到BytesIO流中（不落地到本地文件）\noutput_stream = BytesIO()\nstream_doc.save(output_stream)\n\n# 可选：将流中的内容写入本地文件，验证结果\nwith open('类文件对象生成的文档.docx', 'wb') as f:\n    f.write(output_stream.getvalue())\nprint(\"✅ 类文件对象操作的文档已保存为：类文件对象生成的文档.docx\")\n\n# 关闭流\ndoc_stream.close()\noutput_stream.close()\n</code></pre>\n<h3 id=\"122-table对象\">1.2.2 Table对象</h3>\n<p>Word软件中的表格功能相当复杂，这导致在使用python-docx操作表格时，往往难以提前明确表格的具体内容和结构，增加了处理的难度。本节将从简单表格到复杂表格来介绍如何使用python-docx操作表格。</p>\n<p><strong>规整表格</strong></p>\n<p>规整表格也就是一个行列数固定、无合并或省略单元格的标准表格，这是最基础的表格形式。关系型数据库表和pandas数据表都是规整表格的典型示例：</p>\n<pre><code class=\"language-shell\">+---+---+---+\n| a | b | c |\n+---+---+---+\n| d | e | f |\n+---+---+---+\n| g | h | i |\n+---+---+---+\n</code></pre>\n<p>通过控制表格行列数即可创建规整表格：</p>\n<pre><code class=\"language-python\">from docx import Document\nfrom docx.shared import Inches\n\n# 创建新文档\ndoc = Document()\n\n# 添加3行2列的规整表格\ntable = doc.add_table(rows=3, cols=2)\ntable.style = 'Table Grid'  # 显示表格边框，便于查看\n\n# 填充单元格内容（a-i 对应示例中的规整表格）\ncell_texts = ['a', 'b', 'c', 'd', 'e', 'f']\nidx = 0\nfor row in table.rows:\n    for cell in row.cells:\n        cell.text = cell_texts[idx]\n        idx += 1\n\n# 保存文档\ndoc.save('规整表格示例.docx')\n\n# 读取并验证规整表格的行列数（每行单元格数相同）\nprint(\"规整表格每行的单元格数：\")\nfor i, row in enumerate(table.rows):\n    print(f\"第{i+1}行：{len(row.cells)}个单元格\")\n</code></pre>\n<p><strong>合并单元格</strong></p>\n<p>将多个连续的横向或纵向单元格合并为一个单元格，是实际使用中非常常见的方式：</p>\n<pre><code class=\"language-shell\">+---+---+---+   +---+---+---+\n|   a   | b |   |   | b | c |\n+---+---+---+   + a +---+---+\n| c | d | e |   |   | d | e |\n+---+---+---+   +---+---+---+\n| f | g | h |   | f | g | h |\n+---+---+---+   +---+---+---+\n</code></pre>\n<p>实现方式为先创建规整表格，再通过<code>cell.merge()</code>实现单元格的横向或纵向合并：</p>\n<pre><code class=\"language-python\">from docx import Document\n\ndoc = Document()\ntable = doc.add_table(rows=2, cols=3)\ntable.style = 'Table Grid'\n\n# 示例1：横向合并（第一行第一个单元格合并右侧单元格）\ncell_1_1 = table.cell(0, 0)  # 第1行第1列（索引从0开始）\ncell_1_2 = table.cell(0, 1)\ncell_1_1.merge(cell_1_2)\ncell_1_1.text = '合并单元格（横向）'\n\n# 示例2：纵向合并（第三列前两个单元格合并）\ncell_1_3 = table.cell(0, 2)\ncell_2_3 = table.cell(1, 2)\ncell_1_3.merge(cell_2_3)\ncell_1_3.text = '合并单元格（纵向）'\n\n# 填充其他单元格\ntable.cell(1, 0).text = 'd'\ntable.cell(1, 1).text = 'e'\n\n# 查看合并后每行的单元格数\n# 注意以下内容返回的是原始表格结构\nprint(\"合并单元格后每行的单元格数：\")\nfor i, row in enumerate(table.rows):\n    print(f\"第{i+1}行：{len(row.cells)}个单元格\")\n\ndoc.save('合并单元格示例.docx')\n</code></pre>\n<p><strong>递归表格</strong></p>\n<p>表格处理的另一个复杂点是其递归特性，Word中的表格单元格本身可以包含一个或多个表格。可以通过<code>_Cell.tables</code>或<code>_Cell.iter_inner_content()</code>检测嵌套表格：</p>\n<ul>\n<li><code>_Cell.tables</code>：直接返回单元格内包含的所有表格。</li>\n<li><code>_Cell.iter_inner_content()</code>：按文档顺序返回单元格内的所有内容（包括段落和表格），保持表格与段落的相对位置不变。</li>\n</ul>\n<p>示例代码如下：</p>\n<pre><code class=\"language-python\">from docx import Document\nfrom docx.shared import Inches\nfrom docx.table import Table\nfrom docx.text.paragraph import Paragraph\n\ndef generate_nested_table_doc():\n    \"\"\"生成带嵌套表格的示例Word文档（示例数据）\"\"\"\n    # 1. 创建新文档\n    doc = Document()\n\n    # 2. 创建外层表格（2行2列）\n    outer_table = doc.add_table(rows=2, cols=2)\n    outer_table.style = 'Table Grid'  # 显示表格边框\n\n    # 3. 填充外层表格的普通单元格\n    cell_1_1 = outer_table.cell(0, 0)\n    cell_1_1.text = \"下方单元格包含嵌套表格\"\n\n    cell_1_2 = outer_table.cell(0, 1)\n    cell_1_2.text = \"普通单元格（无嵌套）\"\n\n    # 4. 关键：在 (1,0) 单元格中嵌套一个子表格\n    cell_2_1 = outer_table.cell(1, 0)\n    # 先给嵌套表格前加一个段落（模拟真实文档的混合内容）\n    para = cell_2_1.add_paragraph(\"嵌套表格前的段落内容：\")\n    # 在单元格内创建嵌套表格（3行1列）\n    inner_table = cell_2_1.add_table(rows=3, cols=1)\n    inner_table.style = 'Table Grid'\n    # 填充嵌套表格\n    inner_table.cell(0, 0).text = \"嵌套表格-行1\"\n    inner_table.cell(1, 0).text = \"嵌套表格-行2\"\n    inner_table.cell(2, 0).text = \"嵌套表格-行3\"\n    # 嵌套表格后再加一个段落\n    cell_2_1.add_paragraph(\"嵌套表格后的段落内容\")\n\n    # 5. 填充外层表格最后一个单元格\n    cell_2_2 = outer_table.cell(1, 1)\n    cell_2_2.text = \"普通单元格（无嵌套）\"\n\n    # 6. 保存文档（生成示例数据）\n    doc.save(\"嵌套表格.docx\")\n    print(\"=\" * 50)\n    print(\"✅ 嵌套表格.docx\")\n    print(\"=\" * 50)\n\ndef traverse_table(table, level=0):\n    \"\"\"\n    递归遍历表格，处理嵌套表格\n    :param table: 要遍历的表格对象\n    :param level: 表格嵌套层级（外层为0，内层+1）\n    \"\"\"\n    indent = \"  \" * level  # 缩进，方便区分层级\n    print(f\"\\n{indent}=== 遍历【层级{level}】表格 ===\")\n    \n    # 遍历表格的每一行\n    for row_idx, row in enumerate(table.rows):\n        # 遍历行中的每一个单元格\n        for col_idx, cell in enumerate(row.cells):\n            print(f\"\\n{indent}单元格 ({row_idx+1}, {col_idx+1})：\")\n            \n            # --------------------------\n            # 方法1：_Cell.tables - 直接获取单元格内的所有表格\n            # --------------------------\n            inner_tables = cell.tables\n            if inner_tables:\n                print(f\"{indent}  📌 检测到 {len(inner_tables)} 个嵌套表格：\")\n                # 递归遍历每个嵌套表格\n                for inner_table in inner_tables:\n                    traverse_table(inner_table, level + 1)\n            else:\n                print(f\"{indent}  📌 无嵌套表格\")\n            \n            # --------------------------\n            # 方法2：_Cell.iter_inner_content() - 按顺序获取单元格内所有内容（段落+表格）\n            # --------------------------\n            print(f\"{indent}  📌 单元格内完整内容（按顺序）：\")\n            for content in cell.iter_inner_content():\n                if isinstance(content, Paragraph):\n                    # 处理段落内容（过滤空段落）\n                    text = content.text.strip()\n                    if text:\n                        print(f\"{indent} [段落]：{text}\")\n                elif isinstance(content, Table):\n                    # 遇到表格时的提示（避免重复遍历，仅演示位置）\n                    print(f\"{indent} [表格]：嵌套表格（层级{level+1}）\")\n\ndef parse_nested_tables():\n    \"\"\"解析生成的嵌套表格文档，演示核心方法\"\"\"\n    # 1. 打开示例文档\n    doc = Document(\"嵌套表格.docx\")\n\n    # 2. 遍历文档中的所有外层表格\n    print(\"\\n开始解析嵌套表格：\")\n    print(\"-\" * 50)\n    for table in doc.tables:\n        traverse_table(table)\n\n# 主程序入口\nif __name__ == \"__main__\":\n    # 生成带嵌套表格的示例文档\n    generate_nested_table_doc()\n    \n    # 第二步：解析嵌套表格，演示_Cell.tables和iter_inner_content的使用\n    parse_nested_tables()\n    \n    print(\"\\n\" + \"=\" * 50)\n    print(\"✅ 嵌套表格解析完成！\")\n    print(\"=\" * 50)\n</code></pre>\n<h3 id=\"123-文本处理\">1.2.3 文本处理</h3>\n<p>在Word文档中，内容的组织逻辑分为两个主要层级：块级对象和行内对象。</p>\n<ul>\n<li>块级对象（如段落、表格）是占据整行的大模块，其宽度由页面边距、分栏或单元格边界决定，文本会在其左右边界内自动换行。</li>\n<li>行内对象则存在于这些大模块内部，如加粗的词语或句子，最常见的表现形式是文本片段（runs）。一个段落就是由一个或多个文本片段组成的。</li>\n</ul>\n<p>相应地，格式控制也分为两类：</p>\n<ul>\n<li>块级属性（如缩进、间距、对齐方式）控制模块在页面上的布局位置；</li>\n<li>行内属性（如字体、加粗、颜色）则控制模块内部文字的具体外观。</li>\n</ul>\n<p>下面通过Python-docx的代码示例，展示这两类格式的实际应用：</p>\n<pre><code class=\"language-python\">from docx import Document\nfrom docx.shared import Inches, Pt, RGBColor\nfrom docx.enum.text import (\n    WD_ALIGN_PARAGRAPH,\n    WD_TAB_ALIGNMENT,\n    WD_TAB_LEADER,\n    WD_UNDERLINE\n)\nfrom docx.enum.dml import MSO_THEME_COLOR\n\n# 创建一个新的 Word 文档\ndoc = Document()\n\n# ==================== 1. 块级格式设置：段落布局控制 ====================\n# 1.1 标题段落（居中对齐、段后间距）\ntitle_para = doc.add_paragraph(\"Python-docx 文本格式示例\")\ntitle_format = title_para.paragraph_format  # 块级格式对象\ntitle_format.alignment = WD_ALIGN_PARAGRAPH.CENTER  # 居中对齐（块级属性）\ntitle_format.space_after = Pt(18)  # 段后间距（块级属性）\n\n# 1.2 正文段落（缩进与行间距）\ncontent_para = doc.add_paragraph(\"这是一个带缩进和自定义行间距的正文段落。\")\ncontent_format = content_para.paragraph_format\ncontent_format.left_indent = Inches(0.5)          # 左缩进\ncontent_format.first_line_indent = Inches(-0.25)  # 悬挂缩进\ncontent_format.line_spacing = 1.5                # 1.5倍行间距\ncontent_format.space_before = Pt(12)             # 段前间距\n\n# 1.3 带制表位的段落（块级定位）\ntab_para = doc.add_paragraph(\"姓名:\\t张三\\t年龄:\\t25\")\ntab_format = tab_para.paragraph_format\ntab_stops = tab_format.tab_stops\n# 添加三个制表位（位置、对齐方式、前导符）\ntab_stops.add_tab_stop(Inches(1.5), WD_TAB_ALIGNMENT.RIGHT, WD_TAB_LEADER.DOTS)\ntab_stops.add_tab_stop(Inches(2.5), WD_TAB_ALIGNMENT.LEFT, WD_TAB_LEADER.SPACES)\ntab_stops.add_tab_stop(Inches(3.5), WD_TAB_ALIGNMENT.RIGHT, WD_TAB_LEADER.DOTS)\n\n# 1.4 分页控制（块级保持与孤行控制）\npage_para1 = doc.add_paragraph(\"这是章节标题（确保与下一段同页）\")\npage_para1.paragraph_format.keep_with_next = True  # 与下段同页\npage_para2 = doc.add_paragraph(\"这是章节内容，启用了孤行控制，避免段落首行/末行单独显示在一页。\" * 20)\npage_para2.paragraph_format.widow_control = True   # 避免孤行\n\n# ==================== 2. 行内格式设置：文字外观控制 ====================\nchar_para = doc.add_paragraph(\"字符格式示例：\")\n\n# 粗体\nbold_run = char_para.add_run(\"粗体文本\")\nbold_run.font.bold = True\nchar_para.add_run(\" | \")\n\n# 斜体\nitalic_run = char_para.add_run(\"斜体文本\")\nitalic_run.font.italic = True\nchar_para.add_run(\" | \")\n\n# 下划线（双下划线）\nunderline_run = char_para.add_run(\"双下划线文本\")\nunderline_run.font.underline = WD_UNDERLINE.DOUBLE\nchar_para.add_run(\" | \")\n\n# 不同字号和颜色\ncolor_run = char_para.add_run(\"16号红色文本\")\ncolor_run.font.size = Pt(16)               # 字号\ncolor_run.font.color.rgb = RGBColor(255, 0, 0)  # 颜色\nchar_para.add_run(\" | \")\n\n# 上标\nsup_run = char_para.add_run(\"上标\")\nsup_run.font.superscript = True\n\n# ==================== 3. 保存文档 ====================\ndoc.save(\"文本格式示例.docx\")\nprint(\"文档已保存为：文本格式示例.docx\")\n</code></pre>\n<h3 id=\"124-sections对象\">1.2.4 Sections对象</h3>\n<p>Word引入了节（section）的概念，它指文档中具有相同页面布局（如页边距、纸张方向）的连续部分。通过分节，用户可以在同一份文档中混合使用不同版式，例如同时包含纵向页面和横向页面。此外，每个节还可以独立设置其页眉与页脚的样式。绝大多数Word文档默认仅包含一个节，通常也无需更改页面布局。然而，当确实需要对页面布局进行调整时，理解节的功能与设置方法就变得至关重要。以下示例展示了如何使用python-docx库创建包含多个节、各节拥有不同页面设置的Word文档：</p>\n<pre><code class=\"language-python\">from docx import Document\nfrom docx.enum.section import WD_SECTION_START\nfrom docx.enum.section import WD_ORIENT\nfrom docx.shared import Inches\n\n# 1. 创建新文档并查看默认节\ndocument = Document()\nprint(\"初始文档的节数量：\", len(document.sections))  # 默认1个节\n\n# 获取默认节并修改其基础布局（纵向，常规边距）\ndefault_section = document.sections[0]\n# 设置默认节的边距：左1.5英寸、右1英寸、上下各1英寸\ndefault_section.left_margin = Inches(1.5)\ndefault_section.right_margin = Inches(1)\ndefault_section.top_margin = Inches(1)\ndefault_section.bottom_margin = Inches(1)\n\n# 2. 给默认节添加内容（纵向页面内容）\ndocument.add_heading('第一节：纵向页面内容', level=1)\ndocument.add_paragraph('这是默认节的内容，页面为纵向，边距：左1.5英寸、右1英寸。')\n\n# 3. 添加新节（奇数页开始，横向布局）\n# 创建新节，指定分节符类型为奇数页开始\nnew_section = document.add_section(WD_SECTION_START.ODD_PAGE)\n# 修改新节的页面方向为横向（需同时交换宽高）\nnew_section.orientation = WD_ORIENT.LANDSCAPE\n# 先交换宽高值，避免页面尺寸异常\nnew_width, new_height = new_section.page_height, new_section.page_width\nnew_section.page_width = new_width\nnew_section.page_height = new_height\n# 设置新节的边距：左右各1.25英寸，上下各0.8英寸\nnew_section.left_margin = Inches(1.25)\nnew_section.right_margin = Inches(1.25)\nnew_section.top_margin = Inches(0.8)\nnew_section.bottom_margin = Inches(0.8)\n\n# 4. 给新节添加内容（横向页面内容）\ndocument.add_heading('第二节：横向页面内容', level=1)\ndocument.add_paragraph('这是新节的内容，页面为横向，边距：左右1.25英寸、上下0.8英寸。')\n\n# 5. 再添加一个新节（偶数页开始，纵向布局）\nthird_section = document.add_section(WD_SECTION_START.EVEN_PAGE)\n# 恢复纵向布局\nthird_section.orientation = WD_ORIENT.PORTRAIT\nthird_section.page_width = Inches(8.5)\nthird_section.page_height = Inches(11)\n# 设置特殊边距（添加装订线）\nthird_section.gutter = Inches(0.2)  # 装订线0.2英寸\nthird_section.header_distance = Inches(0.6)  # 页眉距离0.6英寸\n\n# 6. 给第三个节添加内容\ndocument.add_heading('第三节：带装订线的纵向页面', level=1)\ndocument.add_paragraph('这一节包含0.2英寸的装订线，页眉距离页面顶部0.6英寸。')\n\n# 7. 遍历所有节，打印关键属性\nprint(\"\\n=== 所有节的关键属性 ===\")\nfor idx, section in enumerate(document.sections):\n    print(f\"\\n第{idx+1}节：\")\n    print(f\"  起始类型：{section.start_type}\")\n    print(f\"  页面方向：{section.orientation}\")\n    print(f\"  左右边距：{section.left_margin/914400:.2f}英寸 / {section.right_margin/914400:.2f}英寸\")\n    print(f\"  装订线：{section.gutter/914400:.2f}英寸\")\n\n# 保存文档\ndocument.save(\"多节文档示例.docx\")\nprint(\"\\n文档已保存为：多节文档示例.docx\")\n</code></pre>\n<h3 id=\"125-页眉页脚对象\">1.2.5 页眉页脚对象</h3>\n<p>页眉是指显示在每一页上页边距区域的文本，与正文内容相互独立，通常用于展示文档标题、作者、创建日期或页码等上下文信息。同一文档中的页眉在各页面间基本保持一致，仅在部分内容上可能存在细微差异，例如章节标题或页码的变化。页脚在功能和特性上与页眉完全类似，唯一的区别是页脚位于页面底部。页脚与脚注不同，脚注在各页面间并不统一。以下是操作文档页眉页脚的示例代码：</p>\n<pre><code class=\"language-python\">from docx import Document\n\n# -------------------------- 1. 初始化文档并创建基础页眉 --------------------------\n# 创建新文档\ndoc = Document()\n\n# 获取文档的第一个节（新建文档默认只有1个节）\nsection1 = doc.sections[0]\nheader1 = section1.header\n\n# 检查初始状态：新建文档的页眉默认关联到前一节页眉设置（此处无前置节，故无实际页眉）\nprint(f\"初始页眉关联状态: {header1.is_linked_to_previous}\")  # 输出: True\n\n# 为第一节添加简单页眉（仅左侧文本）\n# 直接编辑页眉的第一个段落（新建页眉默认包含1个空段落）\npara1 = header1.paragraphs[0]\npara1.text = \"文档主标题 - 第一节页眉\"\n# 自动创建独立页眉定义，关联状态变为False\nprint(f\"添加页眉后关联状态: {header1.is_linked_to_previous}\")  # 输出: False\n\n# -------------------------- 2. 添加带分区（左/中/右）的页眉 --------------------------\n# 先清空第一节原有页眉内容，重新设置分区页眉\npara1.clear()\n# 使用制表符\\t分隔左、中、右三部分内容\npara1.text = \"左侧：文档名称\\t居中：2026年1月\\t右侧：页码\"\n# 应用Word默认的\"Header\"样式（确保制表位生效）\npara1.style = doc.styles[\"Header\"]\n\n# -------------------------- 3. 添加新节并设置独立页眉 --------------------------\n# 向文档末尾添加新节（section2）\nsection2 = doc.add_section()\nheader2 = section2.header\n\n# 初始状态：新节的页眉默认关联到前一节（section1）\nprint(f\"第二节初始关联状态: {header2.is_linked_to_previous}\")  # 输出: True\n# 验证：此时编辑header2的内容会直接修改section1的页眉（继承特性）\n# 先取消关联，创建第二节的独立页眉\nheader2.is_linked_to_previous = False\n# 为第二节添加专属页眉\npara2 = header2.paragraphs[0]\npara2.text = \"第二节独立页眉 - 仅本节显示\"\n\n# -------------------------- 4. 添加页脚（与页眉用法完全一致） --------------------------\n# 为第一节添加页脚（包含页码）\nfooter1 = doc.sections[0].footer\nfooter1.is_linked_to_previous = False  # 取消关联，创建独立页脚\nfooter_para1 = footer1.paragraphs[0]\nfooter_para1.text = \"\\t第 {PAGE} 页 / 共 {NUMPAGES} 页\\t\"  # 居中显示页码\nfooter_para1.style = doc.styles[\"Footer\"]\n# 为第二节添加不同的页脚\nfooter2 = doc.sections[1].footer\nfooter2.is_linked_to_previous = False\nfooter_para2 = footer2.paragraphs[0]\nfooter_para2.text = \"第二节页脚 - 联系人：测试账号\"\n\n# -------------------------- 5. 删除页眉（恢复关联状态） --------------------------\n# 若需删除第二节的独立页眉，只需将其关联状态设为True（会永久删除内容）\n# 此处仅演示，注释掉避免影响最终效果\n# header2.is_linked_to_previous = True\n\n# -------------------------- 6. 保存文档 --------------------------\ndoc.save(\"页眉页脚示例.docx\")\nprint(\"文档已保存为：页眉页脚示例.docx\")\n</code></pre>\n<h2 id=\"13-非文本内容管理\">1.3 非文本内容管理</h2>\n<h3 id=\"131-样式管理\">1.3.1 样式管理</h3>\n<p>在Word中，内置样式会出现在Word界面的样式面板中，但不会自动加入文档中，直到你第一次使用它。这样避免了文件因所有样式定义而臃肿。一旦某样式被使用，其定义就会永久加入文档，即使后来删除应用内容也不会消失。因此，若要用python-docx使样式生效，必须在初始文档中包含其定义，否则样式会静默失效。<br />\n以下是一个综合性的示例，它整合了文档中所有核心的样式操作功能，包括样式的访问、应用、创建、删除，以及字符段落格式的定义等：</p>\n<pre><code class=\"language-python\">from docx import Document\nfrom docx.enum.style import WD_STYLE_TYPE\nfrom docx.shared import Pt, Inches\nfrom docx.enum.text import WD_UNDERLINE\n\n# 1. 创建新文档并访问样式集合\ndoc = Document()\nstyles = doc.styles\nprint(f\"初始样式数量: {len(styles)}\")\n\n# 2. 访问并筛选特定类型的样式\n# 筛选所有段落样式并打印名称\nprint(\"\\n=== 所有段落样式 ===\")\nparagraph_styles = [s for s in styles if s.type == WD_STYLE_TYPE.PARAGRAPH]\nfor style in paragraph_styles[:5]:  # 只打印前5个避免输出过长\n    print(f\"- {style.name}\")\n\n# 3. 应用现有样式到新段落\n# 方式1: 创建时指定样式名称\ndoc.add_heading(\"样式操作示例\", level=0)\nheading1_para = doc.add_paragraph(\"这是应用 Heading 1 样式的段落\", style=\"Heading 1\")\n# 方式2: 先创建段落再赋值样式对象\nnormal_para = doc.add_paragraph()\nnormal_para.text = \"这是先创建再应用 Normal 样式的段落\"\nnormal_para.style = styles[\"Normal\"]\n\n# 4. 创建自定义样式\n# 4.1 创建段落样式并设置基础样式、字符格式、段落格式\ncitation_style = styles.add_style(\"Citation\", WD_STYLE_TYPE.PARAGRAPH)\n# 设置基础样式（继承 Normal 样式的格式）\ncitation_style.base_style = styles[\"Normal\"]\n# 设置字符格式\ncitation_style.font.name = \"宋体\"\ncitation_style.font.size = Pt(10)\ncitation_style.font.italic = True  # 斜体\ncitation_style.font.underline = WD_UNDERLINE.DOT_DASH  # 点划线下划线\n# 设置段落格式（悬挂缩进、段前间距）\ncitation_style.paragraph_format.left_indent = Inches(0.25)\ncitation_style.paragraph_format.first_line_indent = Inches(-0.25)\ncitation_style.paragraph_format.space_before = Pt(6)\n# 设置后续段落样式\ncitation_style.next_paragraph_style = styles[\"Normal\"]\n\n# 应用自定义样式\ncitation_para = doc.add_paragraph(\"这是自定义 Citation 样式的引用文本\", style=\"Citation\")\nprint(f\"\\n自定义样式应用后名称: {citation_para.style.name}\")\n\n# 5. 控制样式在 Word 中的显示（快速样式、优先级）\nbody_text_style = styles[\"Body Text\"]\nbody_text_style.hidden = False\nbody_text_style.quick_style = True\nbody_text_style.priority = 1\n\n# 6. 处理潜在样式（Latent Styles）\nlatent_styles = styles.latent_styles\nprint(f\"\\n潜在样式总数: {len(latent_styles)}\")\n\n# 为 List Bullet 添加潜在样式定义\nif \"List Bullet\" not in latent_styles:\n    latent_list_bullet = latent_styles.add_latent_style(\"List Bullet\")\n    latent_list_bullet.hidden = False\n    latent_list_bullet.priority = 2\n    latent_list_bullet.quick_style = True\nprint(f\"List Bullet 潜在样式优先级: {latent_styles['List Bullet'].priority}\")\n\n# 7. 删除样式\nprint(f\"\\n删除前样式数量: {len(styles)}\")\nif \"Citation\" in styles:\n    styles[\"Citation\"].delete()\n    print(f\"删除后样式数量: {len(styles)}\")\n\n# 8. 保存文档\ndoc.save(\"样式操作示例.docx\")\nprint(\"\\n文档已保存为: 样式操作示例.docx\")\n</code></pre>\n<h3 id=\"132-批注管理\">1.3.2 批注管理</h3>\n<p>Word支持在文档中添加批注，这是审阅功能的一部分，通常用于他人在不修改原文的情况下提供反馈。Word文档里操作步骤如下：</p>\n<ol>\n<li>选取文本范围；</li>\n<li>点击审阅工具栏中的新建批注；</li>\n<li>输入或粘贴批注内容。</li>\n</ol>\n<p>批注仅能添加至文档主体，不可插入页眉、页脚或其他批注内。Word文档里脚注和尾注中理论上允许添加批注，但当前python-docx暂不支持该操作。此外高版本Word支持解决批注和回复批注功能，但python-docx暂未实现。以下是包含批注创建、富文本批注、元数据修改及批注遍历的完整示例：</p>\n<pre><code class=\"language-python\"># 导入必要的库\nfrom docx import Document\nfrom datetime import datetime, timezone\n\n\"\"\"\n创建文档并演示批注的完整操作流程：\n1. 创建基础批注\n2. 创建富文本格式批注\n3. 修改批注元数据\n4. 访问和遍历所有批注\n\"\"\"\n# 1. 初始化文档对象\ndoc = Document()\ndoc.add_heading(\"Python-docx 批注演示文档\", level=1)\n\n# 2. 示例1：创建基础文本批注\npara1 = doc.add_paragraph(\"这是第一段测试文本，用于添加基础批注。\")\n# 为整段文本添加基础批注\nbasic_comment = doc.add_comment(\n    runs=para1.runs,  # 关联的文本块\n    text=\"基础批注：这段文本表述清晰，建议保留。\",  # 批注纯文本内容\n    author=\"张三\",  # 批注作者\n    initials=\"ZS\"  # 作者缩写\n)\nprint(f\"✅ 基础批注创建完成\")\n# 3. 示例2：创建富文本格式批注（包含粗体、斜体等样式）\npara2 = doc.add_paragraph(\"这是第二段测试文本，用于添加富文本批注。\")\n# 创建空内容批注（后续手动添加富文本）\nrich_comment = doc.add_comment(\n    runs=para2.runs,\n    text=\"\",  # 初始为空，后续添加富文本\n    author=\"李四\",\n    initials=\"LS\"\n)\n# 向批注中添加富文本内容\ncmt_para = rich_comment.paragraphs[0]  # 获取批注的默认段落\ncmt_para.add_run(\"富文本批注：\")  # 普通文本\ncmt_para.add_run(\"重点建议：\").bold = True  # 粗体文本\ncmt_para.add_run(\"这段文本需要补充案例，\").italic = True  # 斜体文本\ncmt_para.add_run(\"建议参考行业标准。\")  # 普通文本\n\n# 4. 示例3：修改批注元数据（作者、缩写）\nbasic_comment.author = \"张小三\"  # 修改作者名\nbasic_comment.initials = \"ZXS\"  # 修改作者缩写\nprint(f\"✅ 基础批注元数据已更新：作者={basic_comment.author}，缩写={basic_comment.initials}\")\n\n# 5. 示例4：访问和遍历所有批注\nprint(\"\\n📋 文档中所有批注信息：\")\nfor idx, comment in enumerate(doc.comments):\n    print(f\"\\n批注 {idx+1}：\")\n    print(f\"  作者：{comment.author}\")\n    print(f\"  缩写：{comment.initials}\")\n    # 提取批注的完整文本（兼容富文本）\n    comment_text = \"\\n  \".join([para.text for para in comment.paragraphs])\n    print(f\"  内容：{comment_text}\")\n\n# 6. 保存文档\ndoc.save(\"批注演示文档.docx\")\nprint(\"\\n📄 文档已保存为：批注演示文档.docx\")\n</code></pre>\n<h3 id=\"133-图片对象\">1.3.3 图片对象</h3>\n<p>Word文档中的内容分为两个图层：文本层和绘图层。文本层按从左到右、自上而下的顺序排列，页满则自动换页。绘图层中的对象称为形状，可自由放置。图片是一种特殊形状，可置于文本层或绘图层。位于文本层的图片称为嵌入式图片，它在排版中被视为一个大型文本字符：行高会自动调整以容纳图片，并支持类似文本的换行效果。若在其前方插入文本，图片会随之向后移动。嵌入式图片通常独占一个段落，但也可与前后文本共存于同一段落中。</p>\n<p>当前python-docx库仅支持嵌入式图片。通过Document.add_picture()方法可将图片默认添加至文档末尾的独立段落中，但经过适当设置，也能实现灵活的图文混排效果，示例如下：</p>\n<pre><code class=\"language-python\">from docx import Document\nfrom docx.shared import Inches, Pt\nfrom docx.enum.text import WD_ALIGN_PARAGRAPH\n\n# 1. 创建一个新的Word文档\ndoc = Document()\n\n# 2. 基础用法：在文档末尾插入图片（单独占一个段落）\ndoc.add_heading('1. 基础插入图片', level=2)\n# 添加图片，设置宽度为2英寸（高度会按比例自动调整）\ndoc.add_picture('test.png', width=Inches(2))\n\n# 3. 进阶用法：图文混排（图片和文本在同一个段落）\ndoc.add_heading('2. 图文混排示例', level=2)\n# 创建一个新段落\nmixed_paragraph = doc.add_paragraph()\n# 添加文本到段落开头\nmixed_paragraph.add_run('这是图片左侧的文本，')\n# 在段落中插入图片（非单独段落）\nimg_run = mixed_paragraph.add_run()\nimg_run.add_picture('test.png', width=Inches(1))\n# 在图片右侧添加文本\nmixed_paragraph.add_run('这是图片右侧的文本。')\n\n# 4. 自定义图片尺寸+段落对齐\ndoc.add_heading('3. 自定义尺寸与对齐', level=2)\nalign_para = doc.add_paragraph()\nalign_para.alignment = WD_ALIGN_PARAGRAPH.CENTER  # 段落居中对齐\nalign_run = align_para.add_run()\n# 同时设置宽度和高度（注意：可能导致图片变形）\nalign_run.add_picture('test.png', width=Inches(1.5), height=Inches(1))\nalign_para.add_run('\\n这是居中显示的图片')\n\n# 5. 保存文档\ndoc.save('形状图片示例.docx')\nprint(\"文档已保存为形状图片示例.docx\")\n</code></pre>\n<h2 id=\"14-综合示例\">1.4 综合示例</h2>\n<p>在实际应用中，python-docx主要被用于文档修改和自动化生成，而非从头创建文档。本节将通过一个综合示例，展示如何对一个包含标题、段落、多种表格、多张图片和分页符的多页文档进行针对性修改，并提供相应的文档生成代码。</p>\n<p><img alt=\"\" src=\"https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/CSDN/%5Bpython%5D%20%E5%9F%BA%E4%BA%8Epython-docx%E5%BA%93%E7%9A%84Word%E6%96%87%E6%A1%A3%E8%87%AA%E5%8A%A8%E5%A4%84%E7%90%86%E5%85%A8%E8%A7%A3/imgs/2.jpg\" /></p>\n<p><strong>文档生成</strong></p>\n<p>以下代码生成一个示例多页文档，涵盖了日常办公中常见的文档结构：</p>\n<pre><code class=\"language-python\">from docx import Document\nfrom docx.shared import Inches, Pt\nfrom docx.enum.text import WD_ALIGN_PARAGRAPH\nfrom docx.enum.table import WD_TABLE_ALIGNMENT\nfrom docx.oxml.ns import qn\nimport os\n\ndef ensure_test_images():\n    # 简单生成测试图片（如果没有的话）\n    try:\n        from PIL import Image\n        for i in range(1, 3):\n            img_path = f\"image{i}.jpg\"\n            if not os.path.exists(img_path):\n                img = Image.new('RGB', (800, 600), color='lightblue')\n                img.save(img_path)\n        print(\"测试图片已准备完成\")\n    except ImportError:\n        print(\"请安装pillow库：pip install pillow\")\n        exit(1)\n\n# 生成Word文档\ndef generate_complex_doc():\n    # 创建新文档\n    doc = Document()\n    \n    # 设置文档默认字体（解决中文显示问题）\n    doc.styles['Normal'].font.name = '微软雅黑'\n    doc.styles['Normal']._element.rPr.rFonts.set(qn('w:eastAsia'), '微软雅黑')\n    \n    # ========== 第一页内容 ==========\n    # 标题\n    title = doc.add_heading('XX项目调研报告', 0)\n    title.alignment = WD_ALIGN_PARAGRAPH.CENTER  # 居中对齐\n    title_run = title.runs[0]\n    title_run.font.size = Pt(24)\n    title_run.font.bold = True\n    \n    # 副标题/说明\n    sub_para = doc.add_paragraph('报告生成时间：2026年1月  报告编制人：测试用户')\n    sub_para.alignment = WD_ALIGN_PARAGRAPH.RIGHT\n    sub_para_run = sub_para.runs[0]\n    sub_para_run.font.size = Pt(10)\n    \n    # 正文段落\n    doc.add_heading('一、项目概述', level=1)\n    overview_para = doc.add_paragraph()\n    overview_para.add_run('本项目针对企业数字化转型需求，重点解决现有业务系统数据孤岛、流程不规范、决策效率低等核心问题。').font.size = Pt(12)\n    overview_para.add_run('\\n项目覆盖范围包括：').font.bold = True\n    overview_para.add_run('\\n1) 生产管理模块：实现生产流程自动化监控')\n    overview_para.add_run('\\n2) 销售管理模块：打通客户数据与订单系统')\n    overview_para.add_run('\\n3) 财务管理模块：实现财务数据实时汇总分析')\n    \n    # 第一个表格：项目基础信息表（2行4列）\n    doc.add_heading('1.1 项目基础信息', level=2)\n    table1 = doc.add_table(rows=2, cols=4)\n    table1.alignment = WD_TABLE_ALIGNMENT.CENTER  # 表格居中\n    table1.style = 'Table Grid'  # 带边框样式\n    \n    # 填充表格1表头\n    hdr_cells = table1.rows[0].cells\n    hdr_cells[0].text = '项目编号'\n    hdr_cells[1].text = '项目名称'\n    hdr_cells[2].text = '启动时间'\n    hdr_cells[3].text = '预计工期'\n    \n    # 填充表格1内容\n    row_cells = table1.rows[1].cells\n    row_cells[0].text = 'XM2026001'\n    row_cells[1].text = '企业数字化转型项目'\n    row_cells[2].text = '2026-01-01'\n    row_cells[3].text = '12个月'\n    \n    # 调整表格1单元格字体\n    for row in table1.rows:\n        for cell in row.cells:\n            for paragraph in cell.paragraphs:\n                for run in paragraph.runs:\n                    run.font.size = Pt(10)\n                    run.font.name = '微软雅黑'\n                    run._element.rPr.rFonts.set(qn('w:eastAsia'), '微软雅黑')\n    \n    # 插入第一张图片\n    doc.add_heading('1.2 项目架构图', level=2)\n    img1_para = doc.add_paragraph()\n    img1_para.alignment = WD_ALIGN_PARAGRAPH.CENTER\n    img1_run = img1_para.add_run()\n    img1_run.add_picture('image1.jpg', width=Inches(5))  # 图片宽度5英寸\n    img1_para.add_run('\\n图1：项目整体架构图').font.size = Pt(10)\n    \n    # 插入分页符（第一页结束）\n    doc.add_page_break()\n    \n    # ========== 第二页内容 ==========\n    doc.add_heading('二、项目资源配置', level=1)\n    resource_para = doc.add_paragraph('本项目所需资源包括人力资源、硬件资源、软件资源三大类，具体配置如下表所示：')\n    \n    # 第二个表格：资源配置表（5行3列）\n    table2 = doc.add_table(rows=5, cols=3)\n    table2.style = 'Table Grid'\n    table2.alignment = WD_TABLE_ALIGNMENT.CENTER\n    \n    # 填充表格2\n    table2_data = [\n        ['资源类型', '规格/数量', '备注'],\n        ['人力资源', '项目经理1人，开发工程师5人，测试工程师2人', '均为全职'],\n        ['服务器', '8核16G云服务器3台', '阿里云ECS'],\n        ['数据库', 'MySQL 8.0 主从架构', '数据实时备份'],\n        ['软件授权', 'Python、Office、开发工具', '企业版授权']\n    ]\n    \n    for i, row_data in enumerate(table2_data):\n        row_cells = table2.rows[i].cells\n        for j, cell_text in enumerate(row_data):\n            row_cells[j].text = cell_text\n            # 设置单元格字体\n            for paragraph in row_cells[j].paragraphs:\n                for run in paragraph.runs:\n                    run.font.size = Pt(10)\n                    run.font.name = '微软雅黑'\n                    run._element.rPr.rFonts.set(qn('w:eastAsia'), '微软雅黑')\n        # 表头加粗\n        if i == 0:\n            for cell in table2.rows[i].cells:\n                for paragraph in cell.paragraphs:\n                    for run in paragraph.runs:\n                        run.font.bold = True\n    \n    # 插入第二张图片\n    doc.add_heading('2.1 资源部署示意图', level=2)\n    img2_para = doc.add_paragraph()\n    img2_para.alignment = WD_ALIGN_PARAGRAPH.CENTER\n    img2_run = img2_para.add_run()\n    img2_run.add_picture('image2.jpg', width=Inches(5))\n    img2_para.add_run('\\n图2：资源部署拓扑图').font.size = Pt(10)\n    \n    # 补充段落内容\n    doc.add_paragraph('资源配置遵循「够用且预留扩展」原则，硬件资源可根据项目进度弹性扩容，人力资源采用「核心+外协」模式保障交付进度。')\n    \n    # 插入分页符（第二页结束）\n    doc.add_page_break()\n    \n    # ========== 第三页内容 ==========\n    doc.add_heading('三、项目风险评估', level=1)\n    risk_para = doc.add_paragraph('通过对技术、人员、成本、进度四个维度的评估，识别出以下核心风险点及应对措施：')\n    \n    # 第三个表格：风险评估表（4行4列）\n    table3 = doc.add_table(rows=4, cols=4)\n    table3.style = 'Table Grid'\n    table3.alignment = WD_TABLE_ALIGNMENT.CENTER\n    \n    table3_data = [\n        ['风险类型', '风险等级', '影响范围', '应对措施'],\n        ['技术风险', '中', '核心功能模块', '提前进行技术预研，制定备选方案'],\n        ['进度风险', '低', '整体交付', '设置里程碑节点，每周进度复盘'],\n        ['成本风险', '低', '预算管控', '建立成本台账，超支提前预警']\n    ]\n    \n    for i, row_data in enumerate(table3_data):\n        row_cells = table3.rows[i].cells\n        for j, cell_text in enumerate(row_data):\n            row_cells[j].text = cell_text\n            for paragraph in row_cells[j].paragraphs:\n                for run in paragraph.runs:\n                    run.font.size = Pt(10)\n                    run.font.name = '微软雅黑'\n                    run._element.rPr.rFonts.set(qn('w:eastAsia'), '微软雅黑')\n        if i == 0:\n            for cell in table3.rows[i].cells:\n                for paragraph in cell.paragraphs:\n                    for run in paragraph.runs:\n                        run.font.bold = True\n    \n    # 结尾段落\n    doc.add_paragraph('\\n综上所述，本项目整体可控，通过科学的资源配置和风险管控措施，能够保障项目按计划交付并达到预期目标。')\n    \n    # 保存文档\n    doc.save('项目报告.docx')\n    print(\"项目报告文档已生成\")\n\nif __name__ == '__main__':\n    ensure_test_images()  # 准备测试图片\n    generate_complex_doc()\n</code></pre>\n<p><strong>文档修改</strong></p>\n<p>文档修改代码针对上述生成的文档，实现以下常见修改需求：</p>\n<ul>\n<li>修改标题和段落文本</li>\n<li>修改表格中的内容</li>\n<li>替换图片</li>\n<li>添加新的段落和表格</li>\n<li>修改字体样式</li>\n</ul>\n<p>示例代码如下：</p>\n<pre><code class=\"language-python\">from docx import Document\nfrom docx.shared import Inches, Pt\nfrom docx.shared import RGBColor\nfrom docx.enum.table import WD_TABLE_ALIGNMENT\nfrom docx.enum.text import WD_ALIGN_PARAGRAPH\nfrom docx.oxml.ns import qn\nimport os\n\n# 修改已生成的Word文档\ndef modify_complex_doc(file_path):\n    # 打开已生成的文档\n    doc = Document(file_path)\n    print(\"已打开待修改的文档\")\n    \n    # ========== 1. 修改标题 ==========\n    # 第一个标题是级别0的标题（主标题）\n    main_title = doc.paragraphs[0]\n    main_title.runs[0].text = 'XX企业数字化转型项目终版报告'  # 修改主标题文本\n    main_title.runs[0].font.color.rgb = RGBColor(0, 0, 255)  # 标题改为蓝色\n    main_title.runs[0].font.size = Pt(20)\n    main_title.runs[0].font.name = '微软雅黑'\n    main_title.runs[0]._element.rPr.rFonts.set(qn('w:eastAsia'), '微软雅黑')\n    main_title.alignment = WD_ALIGN_PARAGRAPH.CENTER\n    \n    # ========== 2. 修改段落文本 ==========\n    # 找到\"项目概述\"下的段落（可通过文本特征定位）\n    for para in doc.paragraphs:\n        if '本项目针对企业数字化转型需求' in para.text:\n            # 清空原有内容，重新写入\n            para.clear()\n            new_run = para.add_run('本项目针对大型制造企业数字化转型需求，重点解决现有业务系统数据孤岛、流程不规范、决策效率低等核心问题。')\n            new_run.font.size = Pt(12)\n            new_run.font.name = '微软雅黑'\n            new_run._element.rPr.rFonts.set(qn('w:eastAsia'), '微软雅黑')\n            # 追加内容\n            para.add_run('\\n项目升级后新增：')\n            para.add_run('\\n4) 供应链管理模块：打通上下游供应商数据')\n            break\n    \n    # ========== 3. 修改表格内容并添加表格名 ==========\n    # 表格1：项目基础信息表（第一个表格）\n    table1 = doc.tables[0]\n    # 修改项目编号\n    table1.rows[1].cells[0].text = 'XM2026001-FINAL'\n    # 修改预计工期\n    table1.rows[1].cells[3].text = '10个月'\n    # 给修改后的单元格文字标红\n    for cell in [table1.rows[1].cells[0], table1.rows[1].cells[3]]:\n        for para in cell.paragraphs:\n            for run in para.runs:\n                run.font.color.rgb = RGBColor(255, 0, 0)\n                run.font.size = Pt(11)\n                run.font.name = '微软雅黑'\n                run._element.rPr.rFonts.set(qn('w:eastAsia'), '微软雅黑')\n    \n    # 为表格1添加表格名（表题）\n    # 找到表格1的位置，在表格上方插入表名\n    table1_elem = table1._element\n    table_caption1 = doc.add_paragraph('表1 项目基础信息表')\n    table_caption1.alignment = WD_ALIGN_PARAGRAPH.CENTER  # 居中对齐\n    table_caption1.paragraph_format.space_before = Pt(0)\n    table_caption1.paragraph_format.space_after = Pt(0)\n    # 设置表名字体格式\n    for run in table_caption1.runs:\n        run.font.size = Pt(11)\n        run.font.name = '微软雅黑'\n        run._element.rPr.rFonts.set(qn('w:eastAsia'), '微软雅黑')\n        run.font.bold = True  # 加粗\n    # 将表名插入到表格上方\n    table1_elem.addprevious(table_caption1._element)\n    \n    # 表格2：资源配置表（第二个表格）\n    table2 = doc.tables[1]\n    # 修改服务器配置\n    table2.rows[3].cells[1].text = '16核32G云服务器3台（升级配置）'\n    # 设置表格2单元格字体\n    for row in table2.rows:\n        for cell in row.cells:\n            for para in cell.paragraphs:\n                for run in para.runs:\n                    run.font.size = Pt(11)\n                    run.font.name = '微软雅黑'\n                    run._element.rPr.rFonts.set(qn('w:eastAsia'), '微软雅黑')\n    \n    # 为表格2添加表格名（表题）\n    table2_elem = table2._element\n    table_caption2 = doc.add_paragraph('表2 项目资源配置表')\n    table_caption2.alignment = WD_ALIGN_PARAGRAPH.CENTER\n    for run in table_caption2.runs:\n        run.font.size = Pt(11)\n        run.font.name = '微软雅黑'\n        run._element.rPr.rFonts.set(qn('w:eastAsia'), '微软雅黑')\n        run.font.bold = True\n    table2_elem.addprevious(table_caption2._element)\n    \n    # ========== 4. 替换图片并规范图名 ==========\n    # 先准备一张新的测试图片\n    from PIL import Image\n    new_img_path = 'test.png'\n    if not os.path.exists(new_img_path):\n        img = Image.new('RGB', (800, 600), color='lightgreen')\n        img.save(new_img_path)\n    \n    # 找到第一张图片所在的段落（通过图片相关特征）\n    img_para_index = -1\n    for i, para in enumerate(doc.paragraphs):\n        if '图1：项目整体架构图' in para.text or 'graphicData' in str(para._element.xml):\n            img_para_index = i\n            break\n    \n    if img_para_index != -1:\n        # 清空段落中的图片和文字，重新添加\n        img_para = doc.paragraphs[img_para_index]\n        img_para.clear()\n        \n        # 重新添加新图片\n        img_run = img_para.add_run()\n        img_run.add_picture(new_img_path, width=Inches(5))\n        \n        # 添加规范的图名（图题）\n        img_caption = img_para.add_run('\\n图1 项目整体架构图（终版）')\n        img_caption.font.size = Pt(10)\n        img_caption.font.name = '微软雅黑'\n        img_caption._element.rPr.rFonts.set(qn('w:eastAsia'), '微软雅黑')\n        img_para.alignment = WD_ALIGN_PARAGRAPH.CENTER\n    \n    # ========== 5. 添加新内容并为新表格加表名 ==========\n    # 在第三页风险评估后添加新的段落和表格\n    # 先找到风险评估标题的位置，在其后添加内容\n    for i, para in enumerate(doc.paragraphs):\n        if '三、项目风险评估' in para.text:\n            # 添加新的子标题\n            new_sub_heading = doc.add_heading('3.1 风险应对预案', level=2)\n            # 插入到指定位置\n            doc.paragraphs.insert(i+1, new_sub_heading)\n            \n            # 添加新段落\n            new_para = doc.add_paragraph('针对高优先级风险，制定专项应对预案，包括应急响应流程、备用资源调配方案等，确保风险发生时可快速处置。')\n            new_para.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY\n            for run in new_para.runs:\n                run.font.size = Pt(12)\n                run.font.name = '微软雅黑'\n                run._element.rPr.rFonts.set(qn('w:eastAsia'), '微软雅黑')\n            doc.paragraphs.insert(i+2, new_para)\n            \n            # 添加新表格（应急预案表）\n            new_table = doc.add_table(rows=2, cols=2)\n            new_table.style = 'Table Grid'\n            new_table.alignment = WD_TABLE_ALIGNMENT.CENTER\n            # 填充新表格\n            new_table.rows[0].cells[0].text = '风险类型'\n            new_table.rows[0].cells[1].text = '应急联系人'\n            new_table.rows[1].cells[0].text = '技术风险'\n            new_table.rows[1].cells[1].text = '张工 13800138000'\n            # 设置新表格字体\n            for row in new_table.rows:\n                for cell in row.cells:\n                    for para_cell in cell.paragraphs:\n                        for run in para_cell.runs:\n                            run.font.size = Pt(10)\n                            run.font.name = '微软雅黑'\n                            run._element.rPr.rFonts.set(qn('w:eastAsia'), '微软雅黑')\n            \n            # 为新表格添加表名\n            new_table_caption = doc.add_paragraph('表3 风险应急联系人表')\n            new_table_caption.alignment = WD_ALIGN_PARAGRAPH.CENTER\n            for run in new_table_caption.runs:\n                run.font.size = Pt(11)\n                run.font.name = '微软雅黑'\n                run._element.rPr.rFonts.set(qn('w:eastAsia'), '微软雅黑')\n                run.font.bold = True\n            \n            # 插入新表格名和新表格\n            doc.element.body.insert(i+3, new_table_caption._element)\n            doc.element.body.insert(i+4, new_table._element)\n            break\n    \n    # ========== 保存修改后的文档 ==========\n    doc.save('项目报告_修改版.docx')\n    print(\"修改后的文档已保存：项目报告_修改版.docx\")\n\nif __name__ == '__main__':\n    # 确保原文档存在\n    file_path = '项目报告.docx'\n    if not os.path.exists(file_path):\n        print(\"请先运行生成代码创建原始文档！\")\n    else:\n        modify_complex_doc(file_path)\n</code></pre>\n<h1 id=\"2-参考\">2 参考</h1>\n<ul>\n<li><a href=\"https://github.com/python-openxml/python-docx\" rel=\"noopener nofollow\" target=\"_blank\">python-docx</a></li>\n<li><a href=\"https://python-docx.readthedocs.io/en/latest/\" rel=\"noopener nofollow\" target=\"_blank\">python-docx docs</a></li>\n</ul>\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/luohenyueji/\" target=\"_blank\">落痕的寒假</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/luohenyueji/p/19479110\" target=\"_blank\">https://www.cnblogs.com/luohenyueji/p/19479110</a></p>\n\n<div style=\"text-align: center;\">\n    <img src=\"https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/wechat/content/%E5%8A%A0%E6%B2%B9%E9%B8%AD.gif\" />\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 20:08</span>&nbsp;\n<a href=\"https://www.cnblogs.com/luohenyueji\">落痕的寒假</a>&nbsp;\n阅读(<span id=\"post_view_count\">11</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}