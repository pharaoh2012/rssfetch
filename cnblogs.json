{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "Agentic Coding一些实践总结",
      "link": "https://www.cnblogs.com/tsingroo/p/19573451",
      "published": "",
      "description": "<h2 class=\"post-title\">\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/tsingroo/p/19573451\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 11:55\">\n    <span>Agentic Coding一些实践总结</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>&nbsp; 最近一年AI编码飞速发展，现在我的90%以上的代码都是出自AI。想想在2024年调用OpneAI官方接口（3.5模型）,超过10K的Token就让LLM的上下文完全混乱，导致LLM无法记住太多东西，更不用说调用工具，生成代码了。到目前为止，用了各种工具已经半年以上了，记录一下总体的实践经验。后面将cursor、Claude Code、OpenCode等工具统称为AgenticCoding工具，我的主要工作语言是go/Rust，各个工具和模型在不同语言上会有所差异，你自己的结论可能和我不太一样。</p>\n<p><strong><span style=\"font-size: 16px;\">&nbsp; 1.Agentic Coding是工具的扩展，而不是智能的扩展（就目前来看）</span></strong></p>\n<p>&nbsp; 虽然现在接近90%以上的代码都能由AI生成，但是这些工具还是依赖于你或者团队原先的见识、知识、流程等，本质还是工具。<strong><span style=\"color: rgba(255, 0, 0, 1);\">如果之前你的团队或者你没有接触过良好的软件工程管理、规范或实践，那你在有了Agentic Coding之后只是感觉上让你更爽了一点而已，对于软件工程的管理甚至会起到反作用。</span></strong><span style=\"color: rgba(0, 0, 0, 1);\">比如更多的未经审查的代码会进入git仓库，更多的不明确的需求导致Agnetic Coding工具的自由发挥空间过大，AI在不恰当的地方过度设计，未经审查合并代码后导致测试人员更难发现BUG，以及提交自己看不明白的代码导致线上出问题后无法快速排查，技术债越来越多。</span></p>\n<p><strong><span style=\"font-size: 16px;\">&nbsp; 2.【好的上下文工程+一般的模型】效果好于【一般的上下文工程+好的大模型】</span></strong></p>\n<p>&nbsp; 这里的上下文工程就是各类编码工具。Agentic Coding工具就是使用良好的上下文管理加上你提供的提示词来调用大模型接口，并使用大模型的接口的返回来决定下一步如何做。</p>\n<p>&nbsp; 仅就go语言而言，经过几个月的测试，Claude Code使用GLM 4.7(或者Kimi 2.5) 要好于 Kiro使用Claude Opus 4.5或者antigravity使用 Claude Opus 4.5。这个也可能是与语言相关。 我没用过Claude Code搭配原生的Sonnet或者Opus模型，但是在cursor+Opus跟使用cursor+kimi差异没有想的那么大。</p>\n<p><span style=\"font-size: 16px;\"><strong>&nbsp; 3.如果你需求管理混乱，你要先规范需求；如果你的团队流程混乱，你要先规范流程</strong></span></p>\n<p>&nbsp; 有些公司，包括一些大公司的一些部门，管理比较混乱。需求评审的时候，产品只能拿出一个想法和简单的几句话的文档，但是又要开发预估时间，之后开发过程中会不断发现问题，导致后面需求和前面的需求大相径庭，有时候进入测试之后产品还在调整需求文档。部门领导对此视而不见，如果有人说流程混乱、需求混乱，那就先把提问题的这个人解决掉，就不会有问题了。有些小公司有这种情况，有些大公司的某些部分也有这种情况。<span style=\"color: rgba(255, 0, 0, 1);\">如果我没遇到，我敢瞎说？😓</span></p>\n<p>&nbsp; 不解决需求和流程混乱的问题，在Agentic Coding的加持下，每个人只会更累，生成的代码也会更乱。<span style=\"color: rgba(255, 0, 0, 1);\">AI时代，你首先得知道自己想要什么，你不能在你自己还不清楚的情况下先把代码写完了</span>。</p>\n<p><span style=\"font-size: 16px;\"><strong>&nbsp; 4.要注重知识共享和落地讲解，跟随AI工具的发展</strong></span></p>\n<p>&nbsp; 不要口头说一个东西多好多有用，要在团队中，打开项目，以一个实际需求为例，给大家展示一下这个技术有多好。比如MCP/Skills，不要夸他有多好，不光要推荐给大家，还要以实际拉个会议来讲解如果落地使用，否则就跟空喊：“努力努力，加油加油”一样。当然这也不是一个人责任，团队中可以定期分享。比如Claude Code中的斜杠命令、SubAgents、Skill等。</p>\n<p>&nbsp; 附加: 斯坦福大学的<a href=\"https://themodernsoftware.dev/\" rel=\"noopener nofollow\" target=\"_blank\">《CS 146S: 现代软件开发者》</a>这门课。</p>\n<p><span style=\"font-size: 16px;\"><strong>&nbsp; 5.一些技巧</strong></span></p>\n<ul>\n<li>&nbsp;编写代码的时候一定要先使用Plan模式制定规划，并再次让AI审查计划，之后才让AI编写代码。目前主流Agentic Coding工具均已支持Plan模式</li>\n<li>让AI写代码之前，先将当前的代码都提交。这样如果AI生成的不满意可以随时撤销代码。同时【个人建议】不要给工具git commit和git push权限</li>\n<li>如果Agentic Coding工具生成的代码，时常偏离项目或者你的预期。你需要将你的预期以及限制写到类似CLAUDE.md或者skills中，来让AI来遵守</li>\n<li>所有AI生成的代码，目前阶段都要人工审核后才能提交到代码仓库</li>\n<li>在达到LLM的上下文阈值之前开启新会话来做任务。目前几百K的Token注意力，在某些时候感觉已经超过了人类的注意力(我没有关注的点，AI会意外的考虑到)，但是上下文一长之后就容易腐坏(Context Rot)。</li>\n</ul>\n<p>&nbsp;</p>\n\n</div>\n<div class=\"clear\"></div>\n\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\">2026-02-04 11:55</span>&nbsp;\n<a href=\"https://www.cnblogs.com/tsingroo\">阿摩罗识</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n        </p>"
    },
    {
      "title": "AI开发-python-langchain框架（1-10 返回日期-格式解析器）",
      "link": "https://www.cnblogs.com/yclh/p/19573432",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yclh/p/19573432\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 11:52\">\n    <span>AI开发-python-langchain框架（1-10 返回日期-格式解析器）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><span class=\"qwen-markdown-text\">如何让大模型返回的结果是一个标准的日期格式？</span></p>\n<p><span class=\"qwen-markdown-text\">如下这段代码展示了如何使用 LangChain 构建一个结构化输出链（chain），将自然语言问题（“中华人民共和国是什么时候创立的？”）通过大语言模型（LLM）转换为标准的 Python <code class=\"qwen-markdown-codespan\" style=\"cursor: pointer;\">datetime</code><span class=\"qwen-markdown-text\"> 对象</span></span></p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:python;gutter:true;\">from langchain.prompts import PromptTemplate\nfrom langchain_openai import ChatOpenAI\nfrom langchain.output_parsers import DatetimeOutputParser\nimport os\n\n# 日期时间输出解析器 自动将模型返回的文本字符串解析为 Python 的 datetime 对象\noutput_parser = DatetimeOutputParser()\n\nprint('###########原生的提示词是英文的')\nformat_instructions=output_parser.get_format_instructions()\nprint(format_instructions)\nprint('###########')\n\n\ntemplate = \"\"\"回答用户的问题:\n{question}\n{format_instructions}\"\"\"\n\nformat_instructions='''响应的格式用日期时间字符串:“%Y-%m-%dT%H:%M:%S.%fZ”。\n示例: 1898-05-31T06:59:40.248940Z, 1808- 10-20T01:56:09.167633Z、0226-10-17T06:18:24.192024Z\n仅返回此字符串！'''\n\nprompt = PromptTemplate.from_template(\n    template,\n    partial_variables={\"format_instructions\":format_instructions},\n)\n\n#输出提示词\nprint(prompt.invoke({\"question\": \"中华人民共和国是什么时候创立的？\"}).text)\n\nllm = ChatOpenAI(\n    api_key=os.getenv(\"DEEPSEEK_API_KEY\"),\n    base_url=os.getenv(\"BASE_URL\"),  # Deepseek 的 API 基础地址\n    model=\"deepseek-v3:671b\",  # Deepseek 对话模型（可选：deepseek-chat-pro 等高级模型）\n    temperature=0.7,  # 温度参数（0-1，越低越稳定）\n    max_tokens=1024  # 最大生成 tokens\n)\n\n\nchain = prompt | llm | output_parser\n\nprint('--------------')\nresult = chain.invoke({\"question\": \"中华人民共和国是什么时候创立的？\"})\nprint(result)\n</pre>\n</div>\n<p>&nbsp;返回结果：</p>\n<p>###########原生的提示词是英文的<br />Write a datetime string that matches the following pattern: '%Y-%m-%dT%H:%M:%S.%fZ'.<br /><br />Examples: 1466-10-12T18:56:24.473648Z, 0322-04-03T12:00:41.805552Z, 1762-08-02T08:58:50.100670Z<br /><br />Return ONLY this string, no other words!<br />###########<br />回答用户的问题:<br />中华人民共和国是什么时候创立的？<br />响应的格式用日期时间字符串:“%Y-%m-%dT%H:%M:%S.%fZ”。<br />示例: 1898-05-31T06:59:40.248940Z, 1808- 10-20T01:56:09.167633Z、0226-10-17T06:18:24.192024Z<br />仅返回此字符串！<br />--------------<br />1949-10-01 00:00:00</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 11:52</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yclh\">万笑佛</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Redisson 使用手册：从 API 误区到看门狗失效，在此终结分布式锁的噩梦",
      "link": "https://www.cnblogs.com/xzqcsj/p/19573422",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xzqcsj/p/19573422\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 11:49\">\n    <span>Redisson 使用手册：从 API 误区到看门狗失效，在此终结分布式锁的噩梦</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"Redisson 使用手册：从 API 误区到看门狗失效，在此终结分布式锁的噩梦\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3703499/202602/3703499-20260204114906823-385277354.png\" />\n        在上一篇《分布式锁的代价与选择：为什么我们最终拥抱了Redisson？》中，我们聊到了手写 SETNX 的\"茹毛饮血\"时代。既然选择了 Redisson，就意味着我们已经告别了那些让人提心吊胆的死锁噩梦。\n很多时候，我们以为只是调用了一个简单的 lock.lock()，但背后其实是一整套复杂的自动续期、Lua 脚本原子执行和发布订阅机制在默默支撑。\n这篇文章不讲虚的，我们从常用的 API 起手，一路通过生产环境的避坑实战，最后钻进底层数据结构与 Lua 源码里，把 Redisson 彻底扒个干干净净。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p><strong>写在前面</strong></p>\n<p>在上一篇<a href=\"https://mp.weixin.qq.com/s/IkRhzVdLvjr4V3ojdu_4gA\" rel=\"noopener nofollow\" target=\"_blank\">《分布式锁的代价与选择：为什么我们最终拥抱了Redisson？》</a>中，我们聊到了手写 <code>SETNX</code> 的\"茹毛饮血\"时代。既然选择了 <strong>Redisson</strong>，就意味着我们已经告别了那些让人提心吊胆的死锁噩梦。</p>\n<p>很多时候，我们以为只是调用了一个简单的 <code>lock.lock()</code>，但背后其实是一整套复杂的<strong>自动续期</strong>、<strong>Lua 脚本原子执行</strong>和<strong>发布订阅机制</strong>在默默支撑。</p>\n<p>这篇文章不讲虚的，我们从<strong>常用的 API</strong> 起手，一路通过<strong>生产环境的避坑实战</strong>，最后钻进<strong>底层数据结构与 Lua 源码</strong>里，把 Redisson 彻底扒个干干净净。</p>\n</blockquote>\n<hr />\n<h2 id=\"一不仅是-lock-这么简单核心-api-全景\">一、不仅是 Lock 这么简单：核心 API 全景</h2>\n<p>Redisson 之所以受欢迎，是因为它把分布式锁封装成了我们最熟悉的 <code>java.util.concurrent.locks.Lock</code> 接口风格，<strong>极大地降低了学习成本</strong>。但除了最基础的 <code>lock()</code>，还有核心功能是你必须掌握的。</p>\n<h3 id=\"1-基础那把锁rlock\">1. 基础那把锁：<code>RLock</code></h3>\n<p>这是 <strong>90% 场景下</strong>的默认选择。它对应 Redis 底层的 <strong>Hash</strong> 结构。</p>\n<pre><code class=\"language-java\">RLock lock = redisson.getLock(\"order:1001\");\nlock.lock(); // 阻塞式等待，默认 30秒过期，自带看门狗\ntry {\n   // 业务逻辑\n} finally {\n   lock.unlock();\n}\n</code></pre>\n<h3 id=\"2-更聪明的锁trylock-️推荐\">2. 更聪明的锁：<code>tryLock</code> (⚡️推荐)</h3>\n<p>在实际业务中，我们往往不希望线程无限死等，浪费资源。这里有两种常见姿势：</p>\n<h4 id=\"姿势-a要等待--启用看门狗-最常用\">姿势 A：要等待 + 启用看门狗 (最常用)</h4>\n<p>只指定 <code>waitTime</code>，不指定 <code>leaseTime</code>。这是<strong>既想要非阻塞（或有限等待），又想要自动续期</strong>的最佳实践。</p>\n<pre><code class=\"language-java\">// 参数1：wait time，我只愿意排队 3秒，拿不到就走人\n// 参数2：时间单位\n// 重点：没传 leaseTime，所以看门狗机制会自动生效！\nboolean res = lock.tryLock(3, TimeUnit.SECONDS);\n\nif (res) {\n   try {\n     // 处理业务（哪怕跑 5分钟 也不怕锁过期）\n   } finally {\n     lock.unlock();\n   }\n} else {\n   log.warn(\"抢锁失败，别挤了！\");\n}\n</code></pre>\n<h4 id=\"姿势-b要等待--自动过期-慎用\">姿势 B：要等待 + 自动过期 (慎用)</h4>\n<p>指定了 <code>leaseTime</code>，看门狗会失效。</p>\n<pre><code class=\"language-java\">// 参数1：wait time，排队 3秒\n// 参数2：lease time，上锁后 10秒 自动强制释放（注意：指定 leaseTime 会让看门狗失效！）\n// 参数3：时间单位\nboolean res = lock.tryLock(3, 10, TimeUnit.SECONDS);\n\nif (res) {\n   try {\n     // 处理业务，必须保证在 10秒 内完成！\n   } finally {\n     lock.unlock();\n   }\n}\n</code></pre>\n<h3 id=\"3-文明的排队公平锁-fairlock\">3. 文明的排队：公平锁 <code>FairLock</code></h3>\n<p>默认的锁是<strong>非公平</strong>的（Non-Fair），线程抢锁全靠 CPU 调度，谁快谁得。但如果你的业务要求\"先来后到\"（比如抢票排队），请务必使用公平锁。</p>\n<pre><code class=\"language-java\">// 内部利用 Redis 的 List（作为线程等待队列）和 Hash（作为超时记录）实现\nRLock fairLock = redisson.getFairLock(\"ticket:queue\");\nfairLock.lock();\n</code></pre>\n<h3 id=\"4-读多写少的神器读写锁-readwritelock\">4. 读多写少的神器：读写锁 <code>ReadWriteLock</code></h3>\n<p>这个场景太经典了：商品详情页，读的人多（10000次/秒），改库存的人少（1次/秒）。如果全互斥，性能直接崩盘。</p>\n<pre><code class=\"language-java\">RReadWriteLock rwLock = redisson.getReadWriteLock(\"product:stock:101\");\n\n// 读锁：多个线程可以同时加读锁，只要没有写锁\nrwLock.readLock().lock();\n\n// 写锁：必须等所有读锁和写锁都释放了才能加，全互斥\nrwLock.writeLock().lock();\n</code></pre>\n<h3 id=\"5-联锁-multilock-原子性加多把锁\">5. 联锁 <code>MultiLock</code> (原子性加多把锁)</h3>\n<p>有时候我们需要同时锁定多个资源，比如\"库存\"和\"余额\"，要么都锁住，要么都不锁，<strong>防止死锁</strong>。</p>\n<pre><code class=\"language-java\">RLock lock1 = redisson.getLock(\"lock:order\");\nRLock lock2 = redisson.getLock(\"lock:stock\");\n// 同时加锁：lock1 lock2\nRedissonMultiLock lock = new RedissonMultiLock(lock1, lock2);\nlock.lock();\n</code></pre>\n<hr />\n<h2 id=\"二扒开底层hash-结构与-lua-脚本\">二、扒开底层：Hash 结构与 Lua 脚本</h2>\n<blockquote>\n<p>以下源码基于 <strong>Redisson 3.16+</strong> 版本（目前生产环境主流版本）分析。</p>\n</blockquote>\n<p>Redisson 为什么能实现<strong>可重入锁</strong>？为什么它比我们自己写的 SETNX 强？<br />\n答案藏在 Redis 的数据结构里。Redisson 并没有使用简单的 <code>String</code> 类型，而是使用了 <strong><code>Hash</code></strong>。</p>\n<h3 id=\"1-redis-里的样子\">1. Redis 里的样子</h3>\n<p>假设我们对 <code>order:1001</code> 加锁，Redis 里实际存储的数据长这样：</p>\n<pre><code class=\"language-bash\">KEY: order:1001\nTYPE: Hash\n\n# hash 对应 value 内容\n{\n    \"UUID:ThreadID\" : 1  # 锁的持有者 : 重入次数\n}\n</code></pre>\n<ul>\n<li><strong>KEY</strong>: 锁的名字。</li>\n<li><strong>FIELD</strong> (Key): <code>UUID:ThreadId</code>。这里由客户端生成的唯一 UUID 加上当前线程 ID 拼接而成。<strong>为什么要加 UUID？</strong> 因为不同服务器上的 JVM 进程 ID 可能一样，必须通过客户端启动时生成的 UUID（ConnectionManagerId）来唯一标识一个 Redisson 实例。</li>\n<li><strong>VALUE</strong>: <code>1</code>。这是重入计数器。如果同一个线程再 lock 一次，这里变成 2。</li>\n</ul>\n<h3 id=\"2-加锁的-lua-脚本\">2. 加锁的 Lua 脚本</h3>\n<p>Redisson 为了保证一系列判断和写入是原子的，把它封装在 Lua 脚本里发给 Redis。</p>\n<pre><code class=\"language-lua\">-- KEYS[1] = 锁名称\n-- ARGV[1] = 过期时间 (默认 30000ms)\n-- ARGV[2] = 锁持有者唯一ID (UUID:ThreadId)\n\n-- 情况 1：锁根本不存在\nif (redis.call('exists', KEYS[1]) == 0) then\n    -- 创建 Hash，设置重入次数为 1\n    redis.call('hincrby', KEYS[1], ARGV[2], 1);\n    -- 设置过期时间\n    redis.call('pexpire', KEYS[1], ARGV[1]);\n    return nil; -- 返回 null 表示加锁成功\nend;\n\n-- 情况 2：锁存在，且持有者就是我（重入）\nif (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then\n    -- 重入次数 +1\n    redis.call('hincrby', KEYS[1], ARGV[2], 1);\n    -- 重新续期\n    redis.call('pexpire', KEYS[1], ARGV[1]);\n    return nil;\nend;\n\n-- 情况 3：锁存在，但不是我\n-- 返回当前锁还剩多少毫秒过期，方便客户端等待\nreturn redis.call('pttl', KEYS[1]);\n</code></pre>\n<p>这段脚本完美解释了：</p>\n<ol>\n<li><strong>原子性</strong>：这一大坨逻辑在 Redis 里是原子执行的，不会插队。</li>\n<li><strong>可重入</strong>：通过 <code>hexists</code> 判断是不是自己，是的话就 <code>hincrby</code>。</li>\n<li><strong>互斥性</strong>：如果既不是新锁，也不是自己的锁，直接返回剩余时间，让你可以去睡一会儿再来。</li>\n</ol>\n<hr />\n<h2 id=\"三拆开看门狗的黑盒源码漫游\">三、拆开看门狗的黑盒：源码漫游</h2>\n<p>经常听说\"看门狗\"，它到底长什么样？<br />\n其实，它本质上是一个 <strong>HashedWheelTimer（时间轮）</strong> 驱动的定时任务。</p>\n<h3 id=\"1-启动入口\">1. 启动入口</h3>\n<p>当我们调用 <code>lock()</code> <strong>不传时间</strong>时，最终会走到这里：</p>\n<pre><code class=\"language-java\">// RedissonLock.java\nprivate void lock(long leaseTime, TimeUnit unit, boolean interruptibly) throws InterruptedException {\n    long threadId = Thread.currentThread().getId();\n    Long ttl = tryAcquire(leaseTime, unit, threadId);\n\n    // 如果 lock 成功，ttl 会返回 null\n    if (ttl == null) {\n        return;\n    }\n    \n    // 如果失败，会订阅一个 Redis Channel，等待锁释放的消息（不用死循环空转）\n    // ... 省略订阅逻辑\n}\n</code></pre>\n<p>关键在 <code>tryAcquireAsync</code> 里：</p>\n<pre><code class=\"language-java\">private &lt;T&gt; RFuture&lt;Long&gt; tryAcquireAsync(long leaseTime, TimeUnit unit, long threadId) {\n    if (leaseTime != -1) {\n        // 如果你传了时间，就按你的时间走，不启动看门狗\n        return tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG);\n    }\n    \n    // 没传时间（leaseTime = -1）\n    // 先设置默认 30秒 过期\n    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);\n    \n    // 加锁成功后，开启续期任务\n    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; {\n        if (e == null) {\n           if (ttlRemaining == null) {\n               // 重点：启动定时续期\n               scheduleExpirationRenewal(threadId);\n           }\n        }\n    });\n    return ttlRemainingFuture;\n}\n</code></pre>\n<h3 id=\"2-续期的无限套娃\">2. 续期的无限套娃</h3>\n<p><code>scheduleExpirationRenewal</code> 最终会调用 <code>renewExpiration</code>：</p>\n<pre><code class=\"language-java\">private void renewExpiration() {\n    // 这里的 1/3 是硬编码的规则\n    // 默认 lockWatchdogTimeout 是 30000ms\n    // 所以每 10000ms 执行一次\n    Timeout task = commandExecutor.getConnectionManager().newTimeout(new TimerTask() {\n        @Override\n        public void run(Timeout timeout) throws Exception {\n            \n            // 执行 Lua 脚本，把 ttl 重新刷回 30秒\n            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);\n            \n            future.onComplete((res, e) -&gt; {\n                if (res) {\n                    // 如果续期成功，这就形成了递归调用：自己调自己\n                    renewExpiration();\n                }\n            });\n        }\n    }, internalLockLeaseTime / 3, TimeUnit.MILLISECONDS);\n}\n</code></pre>\n<p><strong>核心逻辑总结</strong>：</p>\n<ol>\n<li><strong>三分之一原则</strong>：每隔锁超时时间的 1/3（默认10秒），检查一次。</li>\n<li><strong>无限递归</strong>：只要检查到锁还在，就重置过期时间，并注册下一次检查。</li>\n<li><strong>生死绑定</strong>：这个任务跑在客户端进程里，如果客户端宕机，任务停止，Redis 里的锁在 30秒 后自动过期。</li>\n</ol>\n<hr />\n<h2 id=\"四我在生产环境踩过的坑避坑实战\">四、我在生产环境踩过的坑：避坑实战</h2>\n<p>API 谁都会调，但能避开坑的才是老司机。这六个坑，都是真金白银换来的教训。</p>\n<h3 id=\"-陷阱一好心办坏事--弄死看门狗\">💣 陷阱一：好心办坏事 —— 弄死看门狗</h3>\n<p>这是新手最容易犯的错。</p>\n<p><strong>❌ 错误姿势</strong>：</p>\n<pre><code class=\"language-java\">// 我怕死锁，所以强行指定 10秒 过期\nlock.lock(10, TimeUnit.SECONDS); \n// 或者\nlock.tryLock(1, 10, TimeUnit.SECONDS);\n</code></pre>\n<p><strong>⚠️ 后果</strong>：<br />\n<strong>Redisson 的看门狗（WatchDog）机制只有在你<code>未指定</code>锁过期时间时才会生效！</strong><br />\n一旦你手动传了 <code>leaseTime</code>，Redisson 就会认为你有自己的想法，不再插手。如果你的业务因为数据库卡顿跑了 15秒，第 10秒 时锁就会强制过期，其他线程长驱直入，爆发并发事故。</p>\n<p><strong>✅ 正确姿势</strong>：<br />\n除非你非常确定业务能在指定时间内跑完，否则<strong>尽量不要传 leaseTime，让看门狗帮你自动续期</strong>。</p>\n<h3 id=\"-陷阱二锁粒度太粗--全服暂停键\">💣 陷阱二：锁粒度太粗 —— 全服暂停键</h3>\n<p><strong>❌ 错误姿势</strong>：</p>\n<pre><code class=\"language-java\">// 所有订单共用一把锁\nRLock lock = redisson.getLock(\"LOCK_ORDER\");\n</code></pre>\n<p><strong>⚠️ 后果</strong>：<br />\n这相当于把高速公路封成了独木桥。不管有多少个用户下单，同一时间只能处理一个。性能直接归零。</p>\n<p><strong>✅ 正确姿势</strong>：<br />\n<strong>锁的粒度越细越好</strong>。只锁那个具体产生竞争的资源 ID。</p>\n<pre><code class=\"language-java\">// 只锁这个订单\nRLock lock = redisson.getLock(\"order:pay:\" + orderId);\n</code></pre>\n<h3 id=\"-陷阱三解锁的艺术--谁加的锁谁来解\">💣 陷阱三：解锁的艺术 —— 谁加的锁谁来解</h3>\n<p><strong>❌ 错误姿势</strong>：</p>\n<pre><code class=\"language-java\">try {\n    // 业务逻辑\n} finally {\n    lock.unlock(); // 直接解锁\n}\n</code></pre>\n<p><strong>⚠️ 后果</strong>：</p>\n<ol>\n<li>如果业务执行超时，锁已经被自动释放了，你再去 <code>unlock</code> 会抛出 <code>IllegalMonitorStateException</code>。</li>\n<li>如果不小心解了别人的锁（虽然 Redisson 有 ID 校验防止误删，但异常处理依然重要）。</li>\n</ol>\n<p><strong>✅ 正确姿势</strong>：</p>\n<pre><code class=\"language-java\">if (lock.isLocked() &amp;&amp; lock.isHeldByCurrentThread()) {\n    lock.unlock();\n}\n</code></pre>\n<h3 id=\"-陷阱四重入锁的递归噩梦\">💣 陷阱四：重入锁的\"递归噩梦\"</h3>\n<p>Redisson 的锁虽然是可重入的（Reentrant），但如果你在递归或嵌套调用中不注意，很容易逻辑混乱。</p>\n<p><strong>❌ 风险代码</strong>：</p>\n<pre><code class=\"language-java\">void methodA() {\n    lock.lock();\n    try {\n        methodB(); // methodB 里又 lock 了一次\n    } finally {\n        lock.unlock(); // 只解了一层\n    }\n}\n</code></pre>\n<p><strong>⚠️ 后果</strong>：<br />\nRedis 里的锁计数器（Counter）如果不归零，锁是不会释放的。确保你的加锁次数和解锁次数<strong>严格匹配</strong>。</p>\n<h3 id=\"-陷阱五主从切换的幽灵锁\">💣 陷阱五：主从切换的\"幽灵锁\"</h3>\n<p>这是 Redis 架构天生的短板。</p>\n<ol>\n<li>Client A 在 <strong>Master</strong> 节点拿到了锁。</li>\n<li>Master 还没来得及把锁同步给 Slave，就<strong>宕机</strong>了。</li>\n<li>Slave 升级为新的 Master。</li>\n<li>Client B 来加锁，发现新 Master 上没锁，于是也<strong>加锁成功</strong>。</li>\n</ol>\n<p><strong>⚠️ 后果</strong>：<br />\nA 和 B 同时持有了锁。<br />\n<strong>解法</strong>：如果你不能容忍这个概率（极低），请看下文的 RedLock，或者转投 Zookeeper。对于 99% 的业务，我们选择<strong>接受</strong>这个风险。</p>\n<hr />\n<h2 id=\"五redlock-的爱恨情仇\">五、RedLock 的爱恨情仇</h2>\n<p>有些面试官特别喜欢问 RedLock，但在实际工作中，它是一个让人爱恨交加的存在。</p>\n<h3 id=\"1-它是为了解决什么\">1. 它是为了解决什么？</h3>\n<p>解决 Redis 主从集群在 Failover（故障转移）时可能丢锁的问题。</p>\n<h3 id=\"2-怎么用\">2. 怎么用？</h3>\n<p>你需要准备 <strong>3个或5个</strong> 完全独立的 Redis 实例（不是 Cluster，不是 Sentinel，就是干干净净的单实例）。</p>\n<pre><code class=\"language-java\">RLock lock1 = redissonInstance1.getLock(\"lock\");\nRLock lock2 = redissonInstance2.getLock(\"lock\");\nRLock lock3 = redissonInstance3.getLock(\"lock\");\n\n// 创建红锁\nRedissonRedLock lock = new RedissonRedLock(lock1, lock2, lock3);\n\ntry {\n    // 同时向 3个 Redis 申请锁\n    // 只要有 &gt; 1.5个 (即2个) 申请成功，就算赢\n    lock.lock();\n    // 业务逻辑\n} finally {\n    lock.unlock();\n}\n</code></pre>\n<h3 id=\"3-灵魂拷问值得吗\">3. 灵魂拷问：值得吗？</h3>\n<p>我的看法是：<strong>不值得</strong>。</p>\n<ul>\n<li><strong>运维成本飙升</strong>：为了个锁，我要多维护好几个独立的 Redis？</li>\n<li><strong>性能打折</strong>：串行或者并发去多个节点请求，网络开销大。</li>\n<li><strong>并非绝对安全</strong>：Martin Kleppmann 指出，如果发生 STW（Stop-The-World）GC，或者时钟发生跳跃，RedLock 依然可能失效。</li>\n</ul>\n<p><strong>建议</strong>：<br />\n如果你在做银行核心账务系统，请用 <strong>Zookeeper</strong> 或 <strong>Etcd</strong>。<br />\n除此之外的 99% 的场景，<strong>Redisson 配合主从集群</strong> 已经足够优秀了。</p>\n<hr />\n<blockquote>\n<p><strong>结语</strong></p>\n<p>很多时候，我们在技术选型时容易陷入\"既要又要\"的怪圈。但软件工程的本质，就是<strong>权衡</strong>（Trade-off）。</p>\n<p><strong>Redisson</strong> 不是神，它只是一把被打磨得足够锋利的刀。它不能解决所有的一致性问题，但它在<strong>易用性</strong>、<strong>性能</strong>和<strong>可靠性</strong>之间找到了一个极佳的平衡点。</p>\n<p>希望这篇文章能帮你不仅\"会用\"锁，更能\"懂\"锁。愿你的系统在洪峰流量下，依然稳如泰山；愿你的代码，既有逻辑的骨架，又有温度的血肉。、</p>\n</blockquote>\n<hr />\n<blockquote>\n<p>文章的最后，想和你多聊两句。</p>\n<p>技术之路，常常是热闹与孤独并存。那些深夜的调试、灵光一闪的方案、还有踩坑爬起后的顿悟，如果能有人一起聊聊，该多好。</p>\n<p>为此，我建了一个小花园——我的微信公众号「<strong>[努力的小郑]</strong>」。</p>\n<p>这里没有高深莫测的理论堆砌，只有我对后端开发、系统设计和工程实践的持续思考与沉淀。它更像我的<strong>数字笔记本</strong>，记录着那些值得被记住的解决方案和思维火花。</p>\n<p>如果你觉得今天的文章还有一点启发，或者单纯想找一个同行者偶尔聊聊技术、谈谈思考，那么，欢迎你来坐坐。<br />\n<img alt=\"85f114bceb12e933bb817ec5fecdfef7\" class=\"lazyload\" /></p>\n<p>愿你前行路上，总有代码可写，有梦可追，也有灯火可亲。</p>\n</blockquote>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 11:49</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xzqcsj\">一旅人</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "kubectl top 没数据：一次从 metrics-server 追到 kubelet feature gate 的排查（OrbStack 2.0.5）",
      "link": "https://www.cnblogs.com/suknna/p/19573394",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/suknna/p/19573394\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 11:44\">\n    <span>kubectl top 没数据：一次从 metrics-server 追到 kubelet feature gate 的排查（OrbStack 2.0.5）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>日期：2026-02-04</p>\n<p>环境信息：</p>\n<ul>\n<li>OrbStack：2.0.5 (19905)</li>\n<li>kubectl：v1.32.7</li>\n<li>kube-apiserver / kubelet（集群）：v1.33.5+orb1</li>\n</ul>\n<ol>\n<li>问题出现：<code>kubectl top</code> 失灵</li>\n</ol>\n<hr />\n<p>我想在本地集群里看一下 Pod 的资源使用量，按惯例跑：</p>\n<pre><code class=\"language-bash\">kubectl top pod -A\n</code></pre>\n<p>这一步如果正常，应该能看到每个 Pod 的 CPU(cores)/MEMORY(bytes)。</p>\n<p>但现实是：<code>top</code> 没有指标可用（典型表现是无数据或 Metrics not available 之类的提示）。直觉告诉我：metrics-server 可能没装好。</p>\n<ol start=\"2\">\n<li>先不要动 metrics-server：先把链路理清楚</li>\n</ol>\n<hr />\n<p><code>kubectl top</code> 的数据来源是 <code>metrics.k8s.io</code> API，而 <code>metrics.k8s.io</code> 是 metrics-server 聚合出来的。metrics-server 本身不采集，它去各节点 kubelet 拉指标。</p>\n<p>所以链路是这样的：</p>\n<ul>\n<li>kubelet 暴露 Summary API：<code>/stats/summary</code></li>\n<li>metrics-server 抓 Summary API（或相关 kubelet stats）</li>\n<li>metrics-server 生成 <code>metrics.k8s.io</code></li>\n<li><code>kubectl top</code> 读取 <code>metrics.k8s.io</code></li>\n</ul>\n<p>结论：排查时必须先确认 kubelet 有没有“原材料”。</p>\n<ol start=\"3\">\n<li>metrics 层排查：API 还在，但可能只是空转</li>\n</ol>\n<hr />\n<p>我先直接看 <code>metrics.k8s.io</code> 是否返回内容：</p>\n<pre><code class=\"language-bash\">kubectl get --raw \"/apis/metrics.k8s.io/v1beta1/pods\" | head\n</code></pre>\n<p>当它返回 <code>PodMetricsList</code> 时，说明 metrics-server 至少活着、API 路由也通。<br />\n但这不代表数据就完整，因为 metrics-server 可能只是拿到了一部分，或者 kubelet 根本没吐 Pod/Container stats。</p>\n<p>接着看 metrics-server 日志（用于确认它是否在抱怨 kubelet）：</p>\n<pre><code class=\"language-bash\">kubectl -n kube-system logs deploy/metrics-server --tail=200\n</code></pre>\n<p>Kubernetes 社区里有一类非常典型的错误：metrics-server 抓 kubelet 的 <code>/stats/summary</code> 时得到 500，然后 <code>kubectl top</code> 没数据。[1]</p>\n<ol start=\"4\">\n<li>kubelet 层排查：Summary API 才是真相</li>\n</ol>\n<hr />\n<p>既然 metrics-server 只是中间商，那就绕过它，直接查 kubelet Summary API。</p>\n<p>先取一个 node 名：</p>\n<pre><code class=\"language-bash\">NODE=\"$(kubectl get node -o name | head -n1 | cut -d/ -f2)\"\n</code></pre>\n<p>然后通过 apiserver proxy 请求：</p>\n<pre><code class=\"language-bash\">kubectl get --raw \"/api/v1/nodes/$NODE/proxy/stats/summary\" | head\n</code></pre>\n<p>关键点在 <code>pods</code> 字段。我用 <code>rg</code> 快速定位：</p>\n<pre><code class=\"language-bash\">kubectl get --raw \"/api/v1/nodes/$NODE/proxy/stats/summary\" | rg '\"pods\"' -n\n</code></pre>\n<p>当时的核心现象是：Summary 里 Pod/Container 级别统计不对劲（常见就是 <code>pods</code> 为空或缺失）。<br />\n这就解释了为什么 <code>kubectl top</code> 没法工作：上游根本拿不到 Pod 的资源使用量。</p>\n<ol start=\"5\">\n<li>查 GitHub：OrbStack issue 给了答案</li>\n</ol>\n<hr />\n<p>到这一步，问题从“metrics-server 配置”变成了“kubelet 的 stats 从哪里来”。</p>\n<p>继续搜索后，找到了 OrbStack 的相关 issue：</p>\n<p><a href=\"https://github.com/orbstack/orbstack/issues/2143\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/orbstack/orbstack/issues/2143</a></p>\n<p>里面提到：需要在 kubelet 配置中开启一个 feature gate：</p>\n<pre><code class=\"language-yaml\">featureGates:\n  PodAndContainerStatsFromCRI: true\n</code></pre>\n<ol start=\"6\">\n<li>修复：在 kubelet 配置里开启 <code>PodAndContainerStatsFromCRI</code></li>\n</ol>\n<hr />\n<p>我在 OrbStack 的 Kubernetes 设置页（Kubelet Configuration）里加上：</p>\n<pre><code class=\"language-yaml\">apiVersion: kubelet.config.k8s.io/v1beta1\nkind: KubeletConfiguration\nfeatureGates:\n  PodAndContainerStatsFromCRI: true\n</code></pre>\n<p>应用并重启集群后，再验证：</p>\n<pre><code class=\"language-bash\">kubectl top pod -A\nkubectl get --raw \"/apis/metrics.k8s.io/v1beta1/pods\" | head\nkubectl get --raw \"/api/v1/nodes/$NODE/proxy/stats/summary\" | rg '\"pods\"' -n\n</code></pre>\n<p>这次 <code>kubectl top</code> 正常输出，<code>metrics.k8s.io</code> 也能看到容器级的 <code>usage.cpu</code> / <code>usage.memory</code>。</p>\n<ol start=\"7\">\n<li>这个配置的作用：为什么加了它就好？</li>\n</ol>\n<hr />\n<p>Kubernetes 官方文档对这个开关的解释很明确：</p>\n<ul>\n<li>默认情况下，kubelet 使用内嵌 cAdvisor 获取节点概要指标数据</li>\n<li>如果启用 <code>PodAndContainerStatsFromCRI</code>，并且容器运行时支持通过 CRI 访问统计信息，那么 kubelet 会改为通过 CRI 获取 Pod/容器级别指标，而不是从 cAdvisor 获取。[2]</li>\n</ul>\n<p>把它翻译成一句话就是：</p>\n<p>让 kubelet “别自己猜”，而是“直接问容器运行时（CRI）你到底用了多少 CPU/内存”。</p>\n<p>在 OrbStack 这种“本地虚拟化封装很深”的环境里，cAdvisor 的观测路径可能不完整；改走 CRI stats 之后，kubelet 能拿到更可靠的 Pod/Container 统计，于是 Summary API 变完整，metrics-server 才有东西可聚合，<code>kubectl top</code> 才能恢复。</p>\n<ol start=\"8\">\n<li>收获：以后遇到 <code>kubectl top</code> 问题怎么最快定位？</li>\n</ol>\n<hr />\n<p>我把排查顺序固定成三步，基本就不会走弯路：</p>\n<p>1）看聚合层：<code>metrics.k8s.io</code> 是否有数据</p>\n<pre><code class=\"language-bash\">kubectl get --raw \"/apis/metrics.k8s.io/v1beta1/pods\" | head\n</code></pre>\n<p>2）看源头：kubelet Summary API 的 <code>pods</code> 是否正常</p>\n<pre><code class=\"language-bash\">kubectl get --raw \"/api/v1/nodes/$NODE/proxy/stats/summary\" | rg '\"pods\"' -n\n</code></pre>\n<p>3）如果 Summary 的 pod stats 不正常，再去找“该发行版/环境”的已知问题<br />\n这次就是 OrbStack issue 直接给了 feature gate 的解法。</p>\n<ol start=\"9\">\n<li>延伸阅读</li>\n</ol>\n<hr />\n<ul>\n<li>\n<p>OrbStack issue（本次直接线索）：<code>orbstack/orbstack#2143</code><br />\n<a href=\"https://github.com/orbstack/orbstack/issues/2143\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/orbstack/orbstack/issues/2143</a></p>\n</li>\n<li>\n<p>Kubernetes 官方文档：Node metrics、Summary API、以及 <code>PodAndContainerStatsFromCRI</code> 的说明<br />\n<a href=\"https://kubernetes.io/zh-cn/docs/reference/instrumentation/node-metrics/\" rel=\"noopener nofollow\" target=\"_blank\">https://kubernetes.io/zh-cn/docs/reference/instrumentation/node-metrics/</a>  [2]</p>\n</li>\n<li>\n<p>Kubernetes issue：metrics-server 抓 <code>/stats/summary</code> 返回 500、<code>kubectl top</code> 无数据的典型案例（用于对照症状）<br />\n<a href=\"https://github.com/kubernetes/kubernetes/issues/111276\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/kubernetes/kubernetes/issues/111276</a>  [1]</p>\n</li>\n</ul>\n<h2 id=\"参考\">参考</h2>\n<p>[1] <a href=\"https://github.com/kubernetes/kubernetes/issues/111276\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/kubernetes/kubernetes/issues/111276</a><br />\n[2] <a href=\"https://kubernetes.io/zh-cn/docs/reference/instrumentation/node-metrics/\" rel=\"noopener nofollow\" target=\"_blank\">https://kubernetes.io/zh-cn/docs/reference/instrumentation/node-metrics/</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 11:44</span>&nbsp;\n<a href=\"https://www.cnblogs.com/suknna\">suknna</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "FastAPI定时任务全攻略：从入门到避开多进程的坑",
      "link": "https://www.cnblogs.com/ymtianyu/p/19573111",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ymtianyu/p/19573111\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 11:01\">\n    <span>FastAPI定时任务全攻略：从入门到避开多进程的坑</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文详细介绍了在FastAPI框架中如何集成并使用APScheduler创建可靠的定时任务。从为什么需要专门的定时任务库讲起，通过比喻解释核心概念，提供了完整的、可直接复用的集成代码。文章重点剖析了多进程部署环境下定时任务重复执行的经典问题，并给出了基于文件锁和数据库锁的两种实用解决方案，帮助你避免线上事故。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2>你的FastAPI后台任务是不是还在“裸奔”？</h2>\n<p>先说事实案例：有个促销活动需要定时上线。结果呢？依赖的云函数服务突然抖动，那个“简单可靠”的<code style=\"color: rgba(186, 55, 42, 1);\">crontab</code>脚本愣是没触发。凌晨三点，运营的电话直接把你的美梦干碎。😫 事后复盘，才意识到：<strong style=\"color: rgba(186, 55, 42, 1);\">把定时任务寄生于操作系统或者外部黑盒服务，在微服务架构里，就是给自己埋雷。</strong></p>\n<p>痛定思痛，最后把定时任务“请”回了应用内部，用<code style=\"color: rgba(186, 55, 42, 1);\">APScheduler</code>在FastAPI里搞了个自治的小闹钟。今天，咱们就来聊聊这套实战经验，连同那些半夜爬起来填的坑……</p>\n<hr />\n<h2>🎯 本文你能得到什么</h2>\n<div>\n<p>1. 为什么说FastAPI自带的<code style=\"color: rgba(186, 55, 42, 1);\">BackgroundTasks</code>不适合做定时任务。</p>\n<p>2. APScheduler的核心概念，用“闹钟”和“餐厅”的比喻让你秒懂。</p>\n<p>3. 手把手集成，提供可直接复制粘贴的代码块。</p>\n<p>4. <strong style=\"color: rgba(186, 55, 42, 1);\">最重要的</strong>：多进程部署（比如用<span style=\"color: rgba(186, 55, 42, 1);\"><code>Uvicorn workers</code></span>）时，定时任务重复执行的“鬼故事”与解决之道。</p>\n</div>\n<h2>🔧 第一部分：问题与背景 —— 为什么另起炉灶？</h2>\n<p>FastAPI 的 <code style=\"color: rgba(186, 55, 42, 1);\">BackgroundTasks</code> 是个好同志，但它只是个“跑腿小哥”。你API请求来了，它帮你异步处理些杂事，比如发邮件、写日志。但它有个硬伤：<strong style=\"color: rgba(186, 55, 42, 1);\">它没有记忆，也不会看表。</strong> 服务一重启，所有计划内的“跑腿”任务全忘光光。</p>\n<p>定时任务呢？它需要的是“忠诚的管家”。不管服务是否重启，都要记得每天上午10点要发报表，每周一凌晨要清缓存。这需要持久化和时间调度能力，这正是 <code style=\"color: rgba(186, 55, 42, 1);\">APScheduler</code> 的绝活。</p>\n<p>你可能会问，用<span style=\"color: rgba(186, 55, 42, 1);\"><code>Celery</code></span>行不行？行，但杀鸡用牛刀了。APScheduler更轻量，与你FastAPI应用同生共死，管理起来简单直接，特别适合业务逻辑清晰、不需要分布式协调的定时场景。</p>\n<h2>⚙️ 第二部分：核心原理 —— APScheduler的三板斧</h2>\n<p>别被它的名字吓到，把它想象成一个<strong style=\"color: rgba(186, 55, 42, 1);\">高度可定制的智能闹钟系统</strong>。它主要由三部分组成：</p>\n<div>\n<p><strong>📅 <span style=\"color: rgba(186, 55, 42, 1);\">触发器 (Trigger)</span></strong><span style=\"color: rgba(186, 55, 42, 1);\">:</span> 决定“什么时候响”。是每天固定时间（<span style=\"color: rgba(186, 55, 42, 1);\"><code>date</code></span>），还是间隔固定时间（<span style=\"color: rgba(186, 55, 42, 1);\"><code>interval</code></span>），或者是像crontab那样的复杂周期（<span style=\"color: rgba(186, 55, 42, 1);\"><code>cron</code></span>）？</p>\n<p><strong>📝 <span style=\"color: rgba(186, 55, 42, 1);\">作业存储器 (Job Store)</span></strong><span style=\"color: rgba(186, 55, 42, 1);\">:</span> 记住“有哪些闹钟要响”。默认存在内存里，重启就忘。我们可以让它记在数据库里（比如SQLite、PostgreSQL），实现持久化。</p>\n<p><strong>👨‍💼 <span style=\"color: rgba(186, 55, 42, 1);\">执行器 (Executor)</span></strong><span style=\"color: rgba(186, 55, 42, 1);\">:</span> 负责“闹钟响了以后具体做什么”。是用线程池还是进程池来执行我们的任务函数？</p>\n</div>\n<p>而<strong style=\"color: rgba(186, 55, 42, 1);\">调度器 (Scheduler)</strong> 就是总控台，把上面三个部件组装起来，并启动这个闹钟系统。</p>\n<h2>🚀 第三部分：实战演示 —— 手把手集成到FastAPI</h2>\n<p>好，咱们先来安装。这步最简单：</p>\n<pre class=\"language-bash highlighter-hljs\"><code>pip install apscheduler</code></pre>\n<p>接下来重点来了，初始化并集成到FastAPI的生命周期。这里有个关键技巧：<strong style=\"color: rgba(186, 55, 42, 1);\">一定要把scheduler的启动和关闭挂在FastAPI的应用事件上</strong>，保证应用启动时它启动，应用优雅关闭时它也停下。千万别学我当初，直接在模块层面<code style=\"color: rgba(186, 55, 42, 1);\">scheduler.start()</code>，导致测试时脚本跑完不退出。</p>\n<pre class=\"language-python highlighter-hljs\"><code># 项目结构建议\n# app/\n#   __init__.py\n#   main.py       # FastAPI 应用创建和事件处理\n#   scheduler.py  # 调度器配置和任务定义\n#   tasks.py      # 具体的任务函数\n\n# app/scheduler.py\nfrom apscheduler.schedulers.asyncio import AsyncIOScheduler\nfrom apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStore\nfrom apscheduler.executors.pool import ThreadPoolExecutor\n\n# 1. 配置组件\njobstores = {\n    'default': SQLAlchemyJobStore(url='sqlite:///jobs.sqlite')  # 使用SQLite持久化\n}\nexecutors = {\n    'default': ThreadPoolExecutor(20)  # 线程池执行\n}\njob_defaults = {\n    'coalesce': False,  # 错过的任务是否合并执行（一般False）\n    'max_instances': 3  # 同一个任务同时运行的最大实例数\n}\n\n# 2. 创建调度器实例\nscheduler = AsyncIOScheduler(\n    jobstores=jobstores,\n    executors=executors,\n    job_defaults=job_defaults,\n    timezone=\"Asia/Shanghai\"  # 时区！时区！时区！重要的事说三遍\n)\n\n# 3. 定义任务函数 (可以放在同文件，也可从其他模块导入)\ndef my_sync_job():\n    print(\"同步任务执行了！\")\n\nasync def my_async_job():\n    print(\"异步任务执行了！\")\n    # 这里可以愉快地调用其他async函数\n\n# 4. 添加任务的函数 (通常在应用启动时调用)\ndef add_jobs():\n    # 间隔任务：每30秒执行一次\n    scheduler.add_job(my_sync_job, 'interval', seconds=30, id='sync_interval_job')\n    # Cron任务：每分钟的第30秒执行\n    scheduler.add_job(my_async_job, 'cron', second=30, id='async_cron_job')\n    # 单次任务：2023年10月1日执行\n    # scheduler.add_job(xxx, 'date', run_date='2023-10-01 00:00:00')    </code></pre>\n<p>然后在你的<code style=\"color: rgba(186, 55, 42, 1);\">main.py</code>里，把它和FastAPI绑在一起：</p>\n<pre class=\"language-python highlighter-hljs\"><code># app/main.py\nfrom fastapi import FastAPI\nfrom .scheduler import scheduler, add_jobs\n\napp = FastAPI(title=\"定时任务演示\")\n\n@app.on_event(\"startup\")\nasync def startup_event():\n    # 应用启动时，添加任务并启动调度器\n    if not scheduler.running:\n        add_jobs()\n        scheduler.start()\n        print(\"APScheduler 已启动\")\n\n@app.on_event(\"shutdown\")\nasync def shutdown_event():\n    # 应用关闭时，优雅地关闭调度器\n    if scheduler.running:\n        scheduler.shutdown()\n        print(\"APScheduler 已关闭\")\n\n#from contextlib import asynccontextmanager\n#@asynccontextmanager\n#async def lifespan(app: FastAPI):\n#    # 应用启动时，添加任务并启动调度器\n#    if not scheduler.running:\n#        add_jobs()\n#        scheduler.start()\n#        print(\"APScheduler 已启动\")\n#    yield\n#    # 应用关闭时，优雅地关闭调度器\n#    if scheduler.running:\n#        scheduler.shutdown()\n#        print(\"APScheduler 已关闭\")\n#app = FastAPI(title=\"定时任务演示\", lifespan=lifespan)\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello World\"}\n\n# 可选：提供一个API来手动触发或查看任务状态\n@app.get(\"/jobs\")\nasync def list_jobs():\n    jobs = scheduler.get_jobs()\n    return {\"jobs\": [{\"id\": j.id, \"next_run\": str(j.next_run_time)} for j in jobs]}    </code></pre>\n<p>这里保留了旧式的<span style=\"color: rgba(186, 55, 42, 1);\"><code>on_event</code></span>生命周期管理函数，方便理解<span style=\"color: rgba(186, 55, 42, 1);\"><code>scheduler</code></span>的开启与关闭逻辑，开发时改为<span style=\"color: rgba(186, 55, 42, 1);\"><code>lifespan</code></span>进行更优雅的生命周期管理。</p>\n<p>跑起来试试吧！你会看到控制台每隔30秒和每分钟的第30秒都有输出。到数据库里看看，<code style=\"color: rgba(186, 55, 42, 1);\">jobs.sqlite</code>里已经存下了我们的任务配置，重启应用任务也不会丢失。🎉</p>\n<h2>💥 第四部分：天坑预警 —— 多进程部署与重复执行</h2>\n<p>是不是以为这样就万事大吉了？<strong style=\"color: rgba(186, 55, 42, 1);\">最大的坑才刚刚浮出水面。</strong></p>\n<p>当你用生产模式启动FastAPI，比如：</p>\n<pre class=\"language-lua highlighter-hljs\"><code>uvicorn app.main:app --host 0.0.0.0 --port 8000 --workers 4</code></pre>\n<p>这<code style=\"color: rgba(186, 55, 42, 1);\">--workers 4</code>意味着启动了4个独立的进程。那么，<code style=\"color: rgba(186, 55, 42, 1);\">app.on_event(\"startup\")</code>会在这4个进程里<strong style=\"color: rgba(186, 55, 42, 1);\">各执行一次</strong>！结果就是，你的定时任务被添加了4次，会被重复执行4次！想象一下，每小时发一次的报表邮件，突然变成了每小时发四封，老板和用户都会疯掉。</p>\n<h3>🔐 解决方案：文件锁与领导者选举</h3>\n<p>核心思路很简单：<strong style=\"color: rgba(186, 55, 42, 1);\">确保在多个进程中，只有一个进程能真正启动和添加定时任务。</strong> 这里分享两种我们线上在用的方法。</p>\n<div>\n<p><strong>方案一：简单粗暴的文件锁（适合大部分场景）</strong></p>\n<p>利用<code style=\"color: rgba(186, 55, 42, 1);\">fcntl</code>（Linux）或<code style=\"color: rgba(186, 55, 42, 1);\">msvcrt</code>（Windows）给一个文件加锁，只有拿到锁的进程才能初始化调度器。</p>\n<pre class=\"language-python highlighter-hljs\"><code># 在 scheduler.py 或 startup 事件中\nimport os\nimport sys\n\ndef try_acquire_lock(lock_file):\n    try:\n        import fcntl\n        f = open(lock_file, 'w')\n        # 尝试获取非阻塞的独占锁\n        fcntl.flock(f, fcntl.LOCK_EX | fcntl.LOCK_NB)\n        return f  # 返回文件对象，保持打开状态以持有锁\n    except (BlockingIOError, ImportError):\n        # 获取失败（其他进程已持有锁）或不支持的系统\n        return None\n\nlock_file = \"/tmp/fastapi_scheduler.lock\"\nlock_fd = try_acquire_lock(lock_file)\n\n@app.on_event(\"startup\")\nasync def startup_event():\n    if lock_fd is not None:\n        # 只有拿到锁的进程才启动调度器\n        if not scheduler.running:\n            add_jobs()\n            scheduler.start()\n            print(f\"进程 {os.getpid()} 成功启动 APScheduler\")\n    else:\n        print(f\"进程 {os.getpid()} 未获得锁，跳过调度器启动\")        </code></pre>\n</div>\n<div>\n<p><strong>方案二：利用数据库原子操作（更分布式）</strong></p>\n<p>在数据库里建一张表，用原子性的“插入或竞争”操作来选举一个“领导者”进程。</p>\n<pre class=\"language-python highlighter-hljs\"><code># 假设使用SQLAlchemy ORM\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom your_app.models import SchedulerLock\nimport datetime\n\nasync def acquire_db_lock(session: AsyncSession, timeout_minutes=10):\n    try:\n        # 尝试插入一条锁记录，host和pid标识当前进程\n        lock = SchedulerLock(\n            id=1,  # 固定ID\n            host=\"my_host\",\n            pid=os.getpid(),\n            last_heartbeat=datetime.datetime.utcnow()\n        )\n        session.add(lock)\n        await session.commit()\n        return True  # 插入成功，获得锁\n    except IntegrityError:  # 唯一约束冲突，记录已存在\n        await session.rollback()\n        # 检查已有的锁是否已过期\n        existing_lock = await session.get(SchedulerLock, 1)\n        if existing_lock and (datetime.datetime.utcnow() - existing_lock.last_heartbeat).seconds &gt; timeout_minutes * 60:\n            # 锁已过期，更新为当前进程\n            existing_lock.host = \"my_host\"\n            existing_lock.pid = os.getpid()\n            existing_lock.last_heartbeat = datetime.datetime.utcnow()\n            await session.commit()\n            return True\n        return False  # 未能获得锁\n\n# 在 startup 事件中调用 acquire_db_lock 判断        </code></pre>\n</div>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">记住，多进程部署下定时任务初始化，不加锁等于制造线上事故。</strong> 我个人更推荐方案一，足够简单可靠，除非你已经是跨机器的分布式部署了。</p>\n<h2>✨ 最后啰嗦一句</h2>\n<p>定时任务看似是小功能，但把它做可靠却需要处处留心。从选择<code style=\"color: rgba(186, 55, 42, 1);\">APScheduler</code>，到正确集成到应用生命周期，再到最后用文件锁避开多进程的坑，每一步都是我们踩过的雷。</p>\n<p>技术栈没有银弹，但有了这套组合拳，你的FastAPI后台定时任务，基本可以高枕无忧了。至少，能让你睡个安稳觉，不用再担心凌晨三点的电话。</p>\n<hr />\n<p>希望这篇“踩坑日记”对你有用。如果你在实践过程中又发现了新的“坑点”，或者有更优雅的解决方案，一定要在评论区告诉我啊！独乐乐不如众乐乐，啊不，是独坑坑不如众填填。😄</p>\n<p><strong>收藏点赞关注</strong>，你的支持是我分享更多实战干货的最大动力。下期可能聊聊FastAPI如何优雅地做分布式日志追踪，我们不见不散！</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 11:01</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ymtianyu\">一名程序媛呀</a>&nbsp;\n阅读(<span id=\"post_view_count\">64</span>)&nbsp;\n评论(<span id=\"post_comment_count\">4</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "懂得编程语言的通用结构，随便哪个语言都是手拿把掐",
      "link": "https://www.cnblogs.com/pie-o/p/19571670",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/pie-o/p/19571670\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 09:45\">\n    <span>懂得编程语言的通用结构，随便哪个语言都是手拿把掐</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        编程语言的通用架构，直接助力语言学习的系统性框架认知\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>编程语言核心结构体系：从相似性到本质理解</p>\n</blockquote>\n<h2 id=\"前言\">前言</h2>\n<p>在接触过多个编程语言的学习之后，观察到一些通用的范式结构，编程语言虽然表面差异巨大，但底层存在一套<strong>不可简化的最小完备集</strong>——这是所有语言都必须包含的基本元素，否则无法表达任意算法。</p>\n<p>而把握住这一点之后，对任意编程语言的学习都有一种脉络极其明晰的感觉，一旦了解到这种通用范式的结构，那么对于入门编程语言就会有一个系统性的学习认知框架，知道该学什么，从哪里开始学。</p>\n<p>这种通用的范式结构就是所有编程语言共有的基础元素，这种相似性源于计算机科学的基本原理——所有编程语言本质上都是人与计算机沟通的抽象工具，需要遵循<strong>计算机底层执行逻辑的约束</strong>。</p>\n<p>正是这样的约束，导致了编程语言在设计时所共同遵守的某种规则，也就是那些隐藏在各种语法表面之下的<strong>共性规律</strong>。也因为是讲解共性的内容，所以只会涉及到有哪些共性，不会描述这些共性在具体语言中是怎么表示的内容。</p>\n<h2 id=\"基础要素\">基础要素</h2>\n<p>任何编程语言都像一座建筑，需要最基础的材料和结构。这些基础元素是表达程序逻辑的基本单元，它们共同构成了编程语言的基础框架，包括如下五个部分：</p>\n<ol>\n<li><code>数据表示</code></li>\n<li><code>表达式与运算</code></li>\n<li><code>控制结构</code></li>\n<li><code>抽象机制</code></li>\n<li><code>输入输出机制</code></li>\n</ol>\n<p>下面按顺序进行介绍。</p>\n<h3 id=\"数据表示\">数据表示</h3>\n<blockquote>\n<p>任何计算都涉及数据，必须有<strong>表示数据</strong>的方式</p>\n</blockquote>\n<p>就像是在草稿本上求解数学题一样，特别是代数内容，有字母、计算符号以及数值，这些写在本子上的字符是表达这些内容的具体形式，并且可以保证每个学习过代数的人都可以看懂和理解，因为是一套相同的机制。</p>\n<h4 id=\"变量\">变量</h4>\n<p>首先要介绍的是<code>变量</code>，那么为什么要有变量呢？想象一下，在代数中，如果没有变量，只有常量，也就是具体的数值，那么所有的问题都只是数值计算问题，而且是必须一次性完成的计算，不可能分步骤，迭代式的计算。</p>\n<p>同时在实际情况中，就是有求解<strong>未知量</strong>的需求，也有某些量在<strong>动态变化</strong>的情况，所以单纯的常量无法建构一个复杂且动态的数学世界，对编程而言也同样如此。</p>\n<p>在程序中，变量的作用如下所示：</p>\n<ol>\n<li><strong>临时保存数据</strong>，用于分步计算，避免一次性大量计算</li>\n<li><strong>避免直接使用常量</strong>，因为在一个表达式中，常量是无法修改的\n<ul>\n<li>假设定义一个穿了增高鞋的人的身高函数为<code>f(x)=x+2</code>，其中变量<code>x</code>表示这个人的实际身高，而整数常量2就表示增高鞋的高度，是固定的数值</li>\n<li>如果它只穿同一个增高鞋的话，这个函数没有问题，但是哪天他换了其他高度的鞋子，这个2就不适用了</li>\n<li>难道要为每个鞋子定义一个专属的函数吗，这显然不可能。但是又不知道鞋子具体能给他提供多少身高</li>\n<li>所以这时候就换用变量<code>a</code>来描述，<code>f(x)=x+a</code>，此时这个变量<code>a</code>就代指了增高鞋的高度，根据实际鞋子的增高功能同步变化，灵活度就更高了。</li>\n</ul>\n</li>\n<li><strong>记录程序运行状态</strong>，不同于临时保存数据只是某一计算的中间过程，此处的运行状态可以调控程序的流程和效果</li>\n<li><strong>根据输入变化行为</strong>，提供了与外界交互的可能，因为输入是不确定的，只有变量才能描述这种不确定性</li>\n<li><strong>隐藏内存细节</strong>，因为变量本质上是内存中存储数据的位置代称，否则需要直接操作内存地址，可读性非常差</li>\n</ol>\n<p>下面给一个关于代数中的变量与程序中的变量的对比：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>代数</th>\n<th>编程</th>\n<th>相同点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>变量</strong></td>\n<td>表示未知数或可变的量</td>\n<td>本质上是内存中存储数据的位置代称，或者说一个容器的名字</td>\n<td>1. 两者都是\"符号代表值\"<br />2. 都可以被重新赋值<br />3. 都遵循\"先定义后使用\"的原则<br /></td>\n</tr>\n</tbody>\n</table>\n<p>有一个常见的混淆点，就是符号=，在数学中，=表示的是一种等价<strong>关系</strong>，只是一种逻辑关系、比如<code>x=5</code>，表示的是<code>x等于5</code>这样一个关系或事实表述；而在程序中，表示的是一个<strong>动作</strong>，即赋值，也可以形象的表述为把一个值放入进一个容器中，具体来说就是把数值5放入到名为<code>x</code>的容器中，这个<code>x</code>也称为变量。</p>\n<p>作为对比，现在有表达式<code>x=x+1</code>，如果从数学的角度来看，这个等价关系是不成立的，但是从程序的角度来看，就是取出容器<code>x</code>的值，加一后再放回去的意思。</p>\n<p>小结一下，可以认为变量就是一种容器（当然也有其它类型的容器），既然是容器那么就是<strong>可重复利用</strong>的，同时所有语言都必须提供<strong>将数据存储在内存中并可通过名称引用</strong>的机制，这是计算的前提，后面的内容表述中，容器就是变量的意思。</p>\n<h4 id=\"标识符\">标识符</h4>\n<p>上一小节介绍了变量，也提到变量就是容器，但这些都是抽象的概念，也就是说，给你一些看起来一模一样的容器，然后拿一个小球随机放进一个容器中，并打乱容器的摆放顺序，你还能找到小球在哪个容器中吗？</p>\n<p>很难对吧，但是如果给每个容器标识一个唯一的名字，那么只要记住小球放入哪个名字标识的容器就可以了，因为此时容器是可识别的。</p>\n<p>实际上只要标识符能唯一确定某个容器，并不会关心标识符由什么组成，但现实是程序的标识符需要遵循一些规范，比如不能以数字开头、不能包含特殊字符等。</p>\n<p>此外还有一类编程语言独有的<code>预定义标识符</code>，也称为<strong>关键字</strong>，这些标识符是不可使用的，比如<code>python</code>中的<code>input</code>、<code>print</code>内置函数名。</p>\n<h4 id=\"数据值\">数据/值</h4>\n<p>既然有了<strong>容器(变量)</strong>，那么总要往容器里面放入一些东西，对于程序而言，就是数据，也可以称为<code>值</code>，而把数据放入变量这种容器的动作就是赋值操作。</p>\n<p>数据有很多种类型，比如日常在<code>excel</code>中有文本类型的数据、有数值类型的数据，还有一些复合类型的数据，这是因为数据来源于多种形式的活动中。</p>\n<p>其中文本类型的数据可能是公司的员工姓名、数值类型的数据可能是员工的薪资、复合类型的数据可能是员工其他信息的组合。</p>\n<p>在数学中，数字有整数、小数，复数等类型，同样在程序中的数据类型也有多种，比如数值类型(整数，浮点数)、布尔类型(真/假)和字符串类型等。</p>\n<p>之所以有这些数据类型，就是要<strong>定义数据的性质以及不同类型的处理方式</strong>，既可以是同类型之间的运算，比如<code>3+2</code>是两个整数之间的运算；也可以是不同类型之间的运算，比如<code>3+2.5</code>中一个是整数，另一个是小数，定义它们之间的运算方式为：把整数转换为小数之后再与另一个小数进行计算。</p>\n<h3 id=\"表达式与运算\">表达式与运算</h3>\n<blockquote>\n<p>没有运算就无法计算</p>\n</blockquote>\n<p>所有语言都支持<strong>将值通过运算符组合成新值</strong>，而这种由<code>变量</code>、<code>常量</code>和<code>运算符</code>组合的形式就是表达式，比如<code>x + 5 * 3</code>，和数学中的形式很像，并且一般情况下运算符的语义也是相通的。</p>\n<p>这样的表达式称为<strong>算术表达式</strong>，可以包含变量和常量，也可以通过小括号改变运算顺序，但是不同于数学中这样的表达式只表示关系，在程序中，这样的表达式会实际计算值，也就是有一个算术结果，并且乘号不能省略。</p>\n<p>接下来是<strong>比较与逻辑运算</strong>，比如数学中<code>x &gt; 5</code>，表示变量与数值的关系，是这样一个事实陈述：<code>x大于5</code>；在程序中，这样的表达式称为<strong>布尔表达式</strong>，会产生一个布尔值(真/假)。</p>\n<p>要记住只要是值就可以赋值给变量，比如<code>is_greater = x &gt; 5</code>，那么如果x&gt;5，则变量<code>is_greater</code>保存的结果就为一个逻辑真值，在<code>python</code>中就是<code>true</code>，否则为一个逻辑假值<code>false</code>，一般布尔表达式用于条件判断，比如<code>if</code>条件判断。</p>\n<h3 id=\"控制结构\">控制结构</h3>\n<blockquote>\n<p>控制流就是逻辑的表达</p>\n</blockquote>\n<p>基本控制结构有下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>元素</th>\n<th>本质作用</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>顺序执行</td>\n<td>默认执行方式</td>\n<td>语句按顺序依次执行</td>\n</tr>\n<tr>\n<td>条件分支</td>\n<td>根据条件选择路径</td>\n<td>必须支持<code>if</code>或等价机制</td>\n</tr>\n<tr>\n<td>循环/迭代</td>\n<td>重复执行代码块</td>\n<td>必须支持<code>while</code>或等价机制</td>\n</tr>\n<tr>\n<td>跳转/返回</td>\n<td>改变执行位置，体现思维的跳跃</td>\n<td>如<code>return</code>、<code>break</code></td>\n</tr>\n</tbody>\n</table>\n<p>其中顺序执行图示如下：</p>\n<div class=\"mermaid\">graph TD\n    A[开始] --&gt; B[步骤1]\n    B --&gt; C[步骤2]\n    C --&gt; D[结束]\n</div><p>按照规定好的工序一步步顺序执行，不完成步骤1，就不会执行到步骤2，就比如洗完澡穿衣服，正常的顺序应该是先穿内衣再穿外衣，也就是步骤1是穿内衣，步骤2是穿外衣，排除不穿内衣的情况，那么应该没人会先执行步骤2穿外衣，再执行步骤1穿内衣吧（不会吧不会吧😲😲）</p>\n<p>条件分支图示如下：</p>\n<div class=\"mermaid\">graph TD\n    Start([开始]) --&gt; Condition{条件判断}\n    Condition --&gt;|True| ProcessA[执行操作A]\n    Condition --&gt;|False| ProcessB[执行操作B]\n    ProcessA --&gt; End([结束])\n    ProcessB --&gt; End\n</div><p>一个逻辑判断只会产生两个结果，不是真就是假，比如<code>你今天下班买菜了吗</code>这个逻辑判断，要么买了，要么没买，所以对应到图上，只会产生两条支路，如果买菜了，那么就执行操作A，可以是自己做晚饭，如果没买菜，那么执行操作B，可以是点外卖</p>\n<p>循环结构图示如下：</p>\n<div class=\"mermaid\">graph TD\n    Start([开始]) --&gt; Init[初始化计数器]\n    Init --&gt; Condition{判断循环条件}\n    \n    subgraph 循环体\n        Process[执行循环操作]\n        Update[更新计数器]\n    end\n    \n    Condition --&gt;|满足条件| Process\n    Process --&gt; Update\n    Update --&gt; Condition\n    Condition --&gt;|不满足条件| End([结束])\n</div><p>循环，可以理解为就是重复，比如你计划一个长达1年的早起习惯养成目标，那么对应到图上，循环条件就是不满365天，也就是还在习惯养成过程中。</p>\n<p>然后循环体中就是要执行早起这个动作并且累计早起天数，从开始早起的第一天算起，后面每天早起都增加天数，直到超过365天，这时候就恭喜完成1年的目标啦</p>\n<p>对于跳转和返回这类非顺序的控制流，关键在于打破默认的从上至下的执行顺序，但一般用在循环的结束条件和函数上下文切换中，其他地方不推荐使用，比如<code>goto</code>语句，因为属于逻辑跳跃，不利于理解。</p>\n<p>其次是所有图灵完备语言都必须支持<strong>条件判断和循环</strong>（或等价的递归），这是表达任意算法的必要条件</p>\n<h3 id=\"抽象机制\">抽象机制</h3>\n<blockquote>\n<p>没有抽象就无法管理复杂度</p>\n</blockquote>\n<p>从本质上讲，抽象就是<strong>信息隐藏</strong>——将复杂的内部实现封装起来，只对外提供必要的操作接口。这就像驾驶汽车：你只需要知道油门、刹车、方向盘，而不需要了解发动机如何工作、变速箱如何换挡。在程序中，基础的抽象的形式主要有：<code>函数/过程</code>，<code>类与对象</code>。</p>\n<h4 id=\"函数过程\">函数/过程​</h4>\n<p>什么是函数呢，本质上是将一段完成特定任务的代码封装成一个独立的、可复用的单元，通过定义<code>输入</code>（参数）和<code>输出</code>（返回值）来隐藏内部实现细节。</p>\n<p>它是最基础、最核心的编程抽象机制。通过这种方式我们可以将复杂系统分解为易于理解和管理的小模块，所有实用语言都提供<strong>将代码组织成可复用单元</strong>的机制，否则无法编写大型程序。</p>\n<p>形象的理解函数，可以认为函数就是一台机器，排除额外的改造之外，每台机器都有各自的功能，这是在机器诞生之日起就固定下来了，比如吸尘器，顾名思义，就是吸入灰尘的。</p>\n<p>也就是说吸尘器的输入是灰尘，灰尘经过吸尘器之后会有一个输出，一团聚集的灰尘，这是机器的理想工作状态，那如果输入纸巾呢，好像也勉强能接收吧，可能有的机器处理的不是很好吧，但如果输入砖头呢，应该没有哪个吸尘器能干这个事情吧。</p>\n<p>所以一台机器的输入是有规定的，虽然它的输入是不受机器自身控制，而来源于外部，但是如果想要正常使用机器的功能，那么就不能由着自己的性子，想输入什么就输入什么</p>\n<p>同样的对于输出而言，这是机器本身固定的部分，吸尘器不能把灰尘变成黄金，同时对于输入是砖头时，吸尘器也不知道该输出什么，它直接罢工不干了。</p>\n<p>总结下来，函数的核心作用如下所示：</p>\n<ol>\n<li>代码复用，一次定义，多次使用</li>\n<li>可维护性，修改一处即可</li>\n<li>可读性，函数名表达意图</li>\n<li>错误排查，错误集中在函数内</li>\n</ol>\n<p>那么该怎么使用函数呢，首先就是定义的问题，也就是确定<strong>函数的作用</strong>、<strong>函数的输入</strong>以及<strong>函数的输出</strong>，即<code>函数名</code>、<code>参数</code>以及<code>返回值</code>。作为对比，可以和数学中的函数定义进行比较，</p>\n<table>\n<thead>\n<tr>\n<th>数学思维</th>\n<th>编程思维</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>函数是一种<strong>映射关系</strong>，  <br />从定义域映射到值域</td>\n<td>函数是一个<strong>可执行过程</strong>，  <br />会实际计算出结果</td>\n</tr>\n<tr>\n<td>函数的输入来自于定义域</td>\n<td>函数的参数有类型约束</td>\n</tr>\n<tr>\n<td>函数的输出来自于值域</td>\n<td>函数的返回值也有类型约束</td>\n</tr>\n</tbody>\n</table>\n<p>需要注意的是，需要区分函数的定义与调用，也就是先有定义才可以调用，比如先有函数<code>f(x)=2x</code>，才会有<code>f(2)=2*x=4</code>这个计算过程。</p>\n<h3 id=\"输入输出机制\">输入输出机制</h3>\n<blockquote>\n<p>没有I/O的程序无法与外界交互</p>\n</blockquote>\n<p>日常中，我们能感知到的输入输出机制就是在使用手机的过程中，比如刷手机时，手指滑动屏幕，会切换到下一个视频。</p>\n<p>此时输入就是手指滑动这个动作，输出就是手机屏幕做切换视频的动作，这就是一种与用户交互的方式，可以很直观的被用户感知到。</p>\n<p>所有实用语言都提供<strong>与外部世界交互</strong>的途径，否则程序的作用就被限制在计算机内部。</p>\n<p>除了这种显式的交互方式，还有就是隐藏在系统内部发生的输入输出过程，这里涉及到多层级的过程，对于用户而言，输入和输出都在最外层。</p>\n<p>这个过程就像食品加工过程一样，比如水果罐头的加工过程，如下图所示：</p>\n<div class=\"mermaid\">graph TD\n    %% 输入源\n    水果原料[🍎 水果原料] --&gt; 原料准备\n    \n    %% 第一层：原料准备\n    subgraph 第一层_原料准备\n        原料准备[原料预处理&lt;br&gt;输入: 水果原料&lt;br&gt;输出: 洁净果块] --&gt; 装罐[装罐与糖水灌注&lt;br&gt;输入: 洁净果块 + 糖水&lt;br&gt;输出: 半成品罐头]\n    end\n    \n    %% 第二层：密封杀菌\n    subgraph 第二层_密封杀菌\n        装罐 --&gt; 密封杀菌[密封与杀菌&lt;br&gt;输入: 半成品罐头&lt;br&gt;输出: 杀菌罐头]\n    end\n    \n    %% 第三层：成品处理\n    subgraph 第三层_成品处理\n        密封杀菌 --&gt; 冷却包装[冷却与包装&lt;br&gt;输入: 杀菌罐头&lt;br&gt;输出: 包装成品]\n    end\n    \n    %% 最终输出\n    冷却包装 --&gt; 成品[🍑 整果罐头成品]\n    \n    %% 样式设置\n    style 第一层_原料准备 fill:#fff3e0,stroke:#ef6c00,stroke-width:2px\n    style 第二层_密封杀菌 fill:#f3e5f5,stroke:#8e24aa,stroke-width:2px\n    style 第三层_成品处理 fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px\n    style 水果原料 fill:#ffccbc,stroke:#d84315,stroke-width:2px\n    style 成品 fill:#c8e6c9,stroke:#388e3c,stroke-width:3px\n</div><p>输入输出关系标注规则如下所示：</p>\n<ul>\n<li><strong>输入</strong>：当前工序接收的物料/半成品</li>\n<li><strong>输出</strong>：当前工序处理后产生的物料/半成品</li>\n<li>每个工序框内都明确标注了输入和输出内容</li>\n<li>箭头方向表示物料流向，即<strong>上一工序的输出是下一工序的输入</strong></li>\n</ul>\n<p>对比到app的登陆验证过程中，用户输入密码-&gt;app内部做验证-&gt;返回验证结果，对于用户而言内部怎么做验证是不需要关心的，只要密码正确就应该登录进账户，密码错误就应该无法进入账户。</p>\n<p>而对于app而言，它不会直接接收到用户的输入，用户的输入直接给到了键盘，这中间还有操作系统的工作，app只是接收了某一过程的输出作为输入。</p>\n<p>同样对于验证结果而言，用户能看到的只有屏幕，但是屏幕绝不会做验证密码的事情，实际上app输出的验证结果也不是直接给到屏幕作为输入的，这个验证结果也要经过操作系统的底层操作，输出给屏幕，然后屏幕再输出给用户显示结果。</p>\n<p>在学习编程时，都会想要看到反馈的结果，一个普遍的做法是把结果或其他信息输出到屏幕上，比如<code>python</code>的<code>print</code>函数，就可以输出信息到屏幕，比如<code>print(\"读取文件失败\")</code>这一语句就表示程序想要读取某个文件，但是读取失败了。</p>\n<p>那么接下来可以就为啥会读取失败这个问题，有针对性的调试代码了，这种信息就是调试信息。而这个<code>print</code>函数其实并不能直接驱动屏幕，它只是触发了驱动屏幕的开关，给了下一层级一个输入，也就是哪个调试信息文本，整个流程就和上面介绍的水果罐头加工过程一样，涉及到底层I/O操作。</p>\n<h2 id=\"总结\">总结</h2>\n<p>经过以上内容的介绍，我们知道在学习新语言时，就应该先把握住如下重点：</p>\n<ol>\n<li>它如何表示数据（变量、值），如何声明变量和赋值，有哪些数据类型</li>\n<li>它如何进行计算（运算符、表达式），有哪些基本运算符（算术、比较、逻辑）</li>\n<li>它如何控制流程（条件、循环），如何写条件语句（if或等价形式），如何写循环（while/for或等价形式）</li>\n<li>它如何封装代码（函数、作用域），如何定义和调用函数</li>\n<li>它如何与外界交互（I/O），如何读取输入和输出结果</li>\n</ol>\n<p>一旦对编程语言的认知框架形成，基本就掌握了使用这个编程语言的能力，处理一些简单问题是完全足够的。</p>\n<p>在理解语言共性时，应关注<strong>功能等价性</strong>而非<strong>语法相似性</strong>。例如，Python的缩进和C++的花括号都是表达代码块的方式，本质相同。</p>\n<p>这种\"透过语法看语义\"的视角，才能真正把握编程语言的共性规律。</p>\n<p>加油吧，每个初学编程的朋友。</p>\n<p>微信公众号：软趴趴的工程师<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<p><a href=\"https://mp.weixin.qq.com/s/cTPVXA_0kT9m0Rn_288HC\" rel=\"noopener nofollow\" target=\"_blank\">原文链接</a></p>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/pie-o/\" target=\"_blank\">pie_thn</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/pie-o/p/19571670\" target=\"_blank\">https://www.cnblogs.com/pie-o/p/19571670</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 09:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/pie-o\">pie_thn</a>&nbsp;\n阅读(<span id=\"post_view_count\">16</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "HagiCode 启动页设计：React 19 应用中填补 Hydration 空白期的极致体验",
      "link": "https://www.cnblogs.com/newbe36524/p/19572516",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/newbe36524/p/19572516\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 09:23\">\n    <span>HagiCode 启动页设计：React 19 应用中填补 Hydration 空白期的极致体验</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"为-hagicode-设计-12-种极致的启动体验从极简到赛博朋克\">为 HagiCode 设计 12 种极致的启动体验：从极简到赛博朋克</h1>\n<blockquote>\n<p>在 React 19 应用下载和 Hydration 的短暂间隙，是留给用户感知品牌个性的黄金窗口。本文分享了我们在 HagiCode 项目中，基于 HTML/CSS/JS 构建的一套完整的启动风格系统。</p>\n</blockquote>\n\n<h2 id=\"背景\">背景</h2>\n<p>HagiCode 作为一个基于 ASP.NET Core 10 和 React 19 (Vite) 的现代化应用，采用了前后端分离部署的架构。前端产物被打包放置于后端的 <code>wwwroot/</code> 目录下由 ASP.NET Core 托管。</p>\n<p>然而，这种架构带来了一个经典的用户体验痛点：当用户访问网页时，浏览器需要先加载 HTML，再下载巨大的 JS Bundle，最后由 React 执行 Hydration（注水）。在这几百毫秒到数秒的\"真空期\"里，用户面对的是一片空白，或者是一个毫无生气的静态页面。</p>\n<p>为了填补这段间隙，并注入 HagiCode 的品牌个性，我们需要设计一套完全基于 <code>index.html</code> 内联代码的启动风格系统。</p>\n<h2 id=\"关于-hagicode\">关于 HagiCode</h2>\n<p>本文分享的启动页设计方案来自我们在 <a href=\"https://github.com/HagiCode-org/site\" rel=\"noopener nofollow\" target=\"_blank\">HagiCode</a> 项目中的实践经验。作为一个 AI 代码助手，HagiCode 不仅关注代码生成的效率，也同样重视开发者的视觉体验。这套启动系统正是我们在追求极致前端性能过程中的产物。</p>\n<h2 id=\"核心挑战与架构设计\">核心挑战与架构设计</h2>\n<p>在动手设计之前，我们必须先明确技术约束。既然要在 <code>index.html</code> 中内联实现，意味着我们不能加载任何外部 CSS 或 JS 文件（除了 React 本身的 Bundle）。</p>\n<h3 id=\"技术约束分析\">技术约束分析</h3>\n<ol>\n<li><strong>零依赖原则</strong>：所有样式必须写在 <code>&lt;style&gt;</code> 标签内，逻辑写在 <code>&lt;script&gt;</code> 标签内。</li>\n<li><strong>防御式 CSS</strong>：为了防止 React 应用挂载后，全局样式污染启动页，我们决定使用高优先级的 ID 前缀（如 <code>#boot-screen</code>）包裹所有启动样式。</li>\n<li><strong>性能优先</strong>：动画尽量使用 CSS <code>transform</code> 和 <code>opacity</code>，避免触发重排，确保不阻塞主线程。</li>\n<li><strong>视觉一致性</strong>：颜色、字体必须与 HagiCode 的 Tailwind 配置保持一致。</li>\n</ol>\n<h3 id=\"架构模式shell--injector\">架构模式：Shell &amp; Injector</h3>\n<p>我们采用了一种<strong>变体模式</strong>。核心逻辑封装在一个立即执行函数（IIFE）中，具体的渲染逻辑作为配置项注入。这样我们就可以通过简单的配置切换不同的风格，而不需要重复编写 DOM 操作逻辑。</p>\n<p>以下是核心的架构代码：</p>\n<pre><code class=\"language-html\">&lt;!-- 内联于 index.html --&gt;\n&lt;div id=\"boot-root\"&gt;&lt;/div&gt;\n\n&lt;script&gt;\n(function() {\n  const BootSequence = {\n    config: {\n      theme: 'terminal', // 可配置为 'minimal', 'skeleton', 'code-rain' 等\n      color: '#3b82f6'   // 品牌色\n    },\n    \n    // 核心生命周期\n    init() {\n      this.render();\n      this.listenForMount();\n    },\n\n    // 渲染当前选定的风格\n    render() {\n      const root = document.getElementById('boot-root');\n      if (this.variants[this.config.theme]) {\n        root.innerHTML = this.variants[this.config.theme].render();\n      }\n    },\n\n    // 监听 React 挂载成功，优雅退出\n    listenForMount() {\n      window.addEventListener('hagicode:ready', () =&gt; {\n        const screen = document.getElementById('boot-root');\n        // 先淡出，再移除 DOM，避免闪烁\n        screen.style.opacity = '0';\n        screen.style.transition = 'opacity 0.3s ease';\n        setTimeout(() =&gt; screen.remove(), 300);\n      });\n    },\n\n    // 12种风格的实现逻辑集中在这里\n    variants: {\n      // ...具体实现见下文\n    }\n  };\n\n  BootSequence.init();\n})();\n&lt;/script&gt;\n</code></pre>\n<h2 id=\"12-种启动风格设计清单\">12 种启动风格设计清单</h2>\n<p>我们将这 12 种风格分为了六大类，以满足不同场景和审美需求。</p>\n<h3 id=\"a-极简主义\">A. 极简主义</h3>\n<blockquote>\n<p>\"少即是多\"。对于追求极致加载速度的场景，我们提供了最轻量的方案。</p>\n</blockquote>\n<h4 id=\"1-minimalist-dot-极简呼吸\">1. Minimalist Dot (极简呼吸)</h4>\n<p>屏幕中心只有一个简单的圆点，配合呼吸动画。</p>\n<ul>\n<li><strong>实现</strong>：CSS <code>@keyframes</code> 控制scale和opacity。</li>\n<li><strong>适用</strong>：任何需要保持页面绝对干净的场合。</li>\n</ul>\n<h4 id=\"2-brand-reveal-品牌揭示\">2. Brand Reveal (品牌揭示)</h4>\n<p>通过 SVG <code>stroke-dasharray</code> 动画，模拟手绘般绘制出 HagiCode 的 Logo 线条，随后淡入文字。</p>\n<ul>\n<li><strong>技巧</strong>：使用 SVG 路径动画，极具质感。</li>\n</ul>\n<h3 id=\"b-骨架屏拟态\">B. 骨架屏拟态</h3>\n<blockquote>\n<p>\"欺骗眼睛的艺术\"。通过模拟真实 UI 布局，让用户感觉页面已经加载了一半。</p>\n</blockquote>\n<h4 id=\"3-sidebar-chat-skeleton-侧边栏骨架屏\">3. Sidebar Chat Skeleton (侧边栏骨架屏)</h4>\n<p>这可能是最实用的一种。我们手动用 HTML 构建了与 React 组件 <code>Sidebar</code> 和 <code>ChatInput</code> 一模一样的布局，并覆盖灰色条纹动画。</p>\n<ul>\n<li><strong>价值</strong>：当 React hydrate 完成时，骨架屏瞬间变成真实组件，用户几乎感觉不到切换。</li>\n</ul>\n<h4 id=\"4-card-stack-skeleton-卡片堆叠\">4. Card Stack Skeleton (卡片堆叠)</h4>\n<p>模拟提案卡片加载时的堆叠动效，使用 3D 变换让卡片微微浮动。</p>\n<h3 id=\"c-抽象与艺术\">C. 抽象与艺术</h3>\n<blockquote>\n<p>展示 HagiCode 的极客基因。</p>\n</blockquote>\n<h4 id=\"5-geometric-morph-几何变形\">5. Geometric Morph (几何变形)</h4>\n<p>在屏幕中心渲染一个几何体（正方形），它会随着时间平滑地变换为圆形、三角形，最后变成 Logo。</p>\n<ul>\n<li><strong>技术</strong>：CSS <code>border-radius</code> 的平滑过渡。</li>\n</ul>\n<h4 id=\"6-code-rain-代码雨\">6. Code Rain (代码雨)</h4>\n<p>向《黑客帝国》致敬。使用 JetBrains Mono 字体，在背景中落下淡淡的字符流。</p>\n<ul>\n<li><strong>注意</strong>：为了性能，字符流必须限制在较小的区域或降低刷新频率。</li>\n</ul>\n<h4 id=\"7-neon-pulse-霓虹脉冲\">7. Neon Pulse (霓虹脉冲)</h4>\n<p>赛博朋克风格的发光圆环，利用 <code>box-shadow</code> 的多重叠加产生强烈的发光感。</p>\n<h3 id=\"d-品牌与主题\">D. 品牌与主题</h3>\n<blockquote>\n<p>让系统\"活\"起来。</p>\n</blockquote>\n<h4 id=\"8-seasonal-theme-节日主题\">8. Seasonal Theme (节日主题)</h4>\n<p>这是一个动态加载器。根据当前日期判断节日（如春节、圣诞节），加载对应的 SVG 动画。</p>\n<ul>\n<li><strong>例子</strong>：春节时，屏幕下方会有红灯笼轻轻摆动。</li>\n</ul>\n<h4 id=\"9-gradient-flow-渐变流\">9. Gradient Flow (渐变流)</h4>\n<p>背景使用 HagiCode 品牌色的流体渐变，配合 <code>background-size</code> 和 <code>background-position</code> 的动画，营造出极光般的流动感。</p>\n<h3 id=\"e-技术感\">E. 技术感</h3>\n<blockquote>\n<p>向开发者致敬。</p>\n</blockquote>\n<h4 id=\"10-terminal-boot-终端启动\">10. Terminal Boot (终端启动)</h4>\n<p>模拟控制台输出。一行行代码快速滚动：</p>\n<pre><code class=\"language-text\">&gt; Initializing HagiCode Core...\n&gt; Loading models...\n&gt; Connecting to neural network...\n</code></pre>\n<p>这会让每一个开发者都感到亲切。</p>\n<h4 id=\"11-progress-bar-极简进度条\">11. Progress Bar (极简进度条)</h4>\n<p>屏幕顶部一条细细的进度条，右侧显示百分比。虽然我们无法获取真实的下载进度，但可以用一个定时器模拟出一个\"可信\"的加载过程（前 80% 快速，后 20% 减速）。</p>\n<h3 id=\"f-创意\">F. 创意</h3>\n<h4 id=\"12-pixel-assembly-像素组装\">12. Pixel Assembly (像素组装)</h4>\n<p>这是一个很有趣的创意。屏幕上散落着一些方块，它们汇聚到中心，逐渐拼凑出 HagiCode 的 Logo 图标。象征着代码的构建过程。</p>\n<h2 id=\"最佳实践与踩坑总结\">最佳实践与踩坑总结</h2>\n<p>在 HagiCode 的实际开发中，我们总结了一些至关重要的实践细节。</p>\n<h3 id=\"1-防御式-css-是必须的\">1. 防御式 CSS 是必须的</h3>\n<p>千万别偷懒不写前缀。曾经有一次，我们没有给启动页样式加 ID 限制，导致 React 挂载后的全局 <code>div</code> 样式意外影响了启动页，导致布局崩坏。<br />\n<strong>经验</strong>：所有 CSS 选择器都挂在 <code>#boot-screen</code> 下，且使用 <code>!important</code> 提升优先级（仅在启动页 CSS 中）。</p>\n<h3 id=\"2-优雅的过渡\">2. 优雅的过渡</h3>\n<p>React mount 成功后，不要直接 <code>remove()</code> 启动页 DOM。<br />\n<strong>正确做法</strong>：</p>\n<ol>\n<li>React 触发 <code>window.dispatchEvent(new Event('hagicode:ready'))</code>。</li>\n<li>启动页监听到事件，先设置 <code>opacity: 0</code>。</li>\n<li>等待 300ms (CSS transition 时间)，确保用户看不见了，再执行 <code>.remove()</code>。</li>\n</ol>\n<h3 id=\"3-主题变量同步\">3. 主题变量同步</h3>\n<p>启动页的颜色代码是写死在 <code>index.html</code> 里的。如果我们修改了 Tailwind 的主色，必须同步修改这里。<br />\n<strong>优化方案</strong>：在 Vite 构建脚本中，编写一个简单的插件，读取 <code>tailwind.config.js</code> 并将颜色变量注入到 <code>index.html</code> 的模板变量中，实现单一数据源。</p>\n<h3 id=\"4-字体预加载\">4. 字体预加载</h3>\n<p>启动页通常需要使用品牌字体，但如果字体加载慢，会出现 FOUT (Flash of Unstyled Text)。<br />\n<strong>解决方案</strong>：在 <code>&lt;head&gt;</code> 中加入 <code>&lt;link rel=\"preload\" href=\"/fonts/JetBrainsMono.woff2\" as=\"font\" type=\"font/woff2\" crossorigin&gt;</code>。这是提升体验的低成本高回报手段。</p>\n<h3 id=\"5-性能监控\">5. 性能监控</h3>\n<p>我们在 <code>index.html</code> 底部注入了 <code>performance.mark('boot-start')</code>，并在 React 挂载成功时标记 <code>boot-end</code>。<br />\n<strong>意义</strong>：通过 Application Insights 收集这些数据，我们可以真实看到启动页对用户感知等待时间（Perceived Loading Time）的缩短程度。数据表明，优秀的骨架屏能让用户对\"慢速网络\"的容忍度提升 50% 以上。</p>\n<h2 id=\"总结\">总结</h2>\n<p>一个好的启动页，不仅仅是\"等待时的装饰\"，它是产品与用户第一次交互的握手信号。在 HagiCode 项目中，这套基于 <strong>Variants 模式</strong>的启动系统，让我们能够灵活地在不同节日、不同版本间切换风格，极大地增强了产品的趣味性和专业感。</p>\n<p>本文分享的方案完全基于原生 Web 标准，没有引入任何沉重的依赖，这正是 HagiCode 追求\"轻量且强大\"的体现。如果你觉得这套方案有价值，欢迎来 HagiCode 仓库看看我们的源码实现，甚至贡献你的创意设计！</p>\n<h2 id=\"参考资料\">参考资料</h2>\n<ul>\n<li><strong>HagiCode 项目地址</strong>：<a href=\"https://github.com/HagiCode-org/site\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/HagiCode-org/site</a></li>\n<li><strong>官网了解更多</strong>：<a href=\"https://hagicode-org.github.io/site\" rel=\"noopener nofollow\" target=\"_blank\">https://hagicode-org.github.io/site</a></li>\n<li><strong>观看实战演示</strong>：<a href=\"https://www.bilibili.com/video/BV1pirZBuEzq/\" rel=\"noopener nofollow\" target=\"_blank\">https://www.bilibili.com/video/BV1pirZBuEzq/</a></li>\n<li><strong>一键安装体验</strong>：<a href=\"https://hagicode-org.github.io/site/docs/installation/docker-compose\" rel=\"noopener nofollow\" target=\"_blank\">https://hagicode-org.github.io/site/docs/installation/docker-compose</a></li>\n</ul>\n<p>如果本文对你有帮助，欢迎来 GitHub 给个 Star，公测已开始，期待你的反馈！</p>\n<hr />\n<p>感谢您的阅读,如果您觉得本文有用,快点击下方点赞按钮👍,让更多的人看到本文。</p>\n<p>本内容采用人工智能辅助协作,经本人审核,符合本人观点与立场。</p>\n<ul>\n<li><strong>本文作者:</strong> <a href=\"https://www.newbe.pro\" rel=\"noopener nofollow\" target=\"_blank\">newbe36524</a></li>\n<li><strong>本文链接:</strong> <a href=\"https://hagicode-org.github.io/site/blog/2026-02-03-hagicode-react-19-hydration-splash-screen/\" rel=\"noopener nofollow\" target=\"_blank\">https://hagicode-org.github.io/site/blog/2026-02-03-hagicode-react-19-hydration-splash-screen/</a></li>\n<li><strong>版权声明:</strong> 本博客所有文章除特别声明外,均采用 BY-NC-SA 许可协议。转载请注明出处!</li>\n</ul>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 09:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/newbe36524\">Newbe36524</a>&nbsp;\n阅读(<span id=\"post_view_count\">19</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "APEX实战第12篇：Oracle APEX 工作区密码忘记了怎么办？",
      "link": "https://www.cnblogs.com/jyzhao/p/19572308/apex-shi-zhan-di12pianoracle-apex-gong-zuo-qu-mi-m",
      "published": "",
      "description": "<a name=\"top\"></a>\n    <h2><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/jyzhao/p/19572308/apex-shi-zhan-di12pianoracle-apex-gong-zuo-qu-mi-m\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 07:28\">\n    <span>APEX实战第12篇：Oracle APEX 工作区密码忘记了怎么办？</span>\n    \n\n</a>\n</h2>\n    <small>\n<span id=\"post-date\">2026-02-04 07:28</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jyzhao\">AlfredZhao</a>&nbsp;\n阅读(<span id=\"post_view_count\">43</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</small>\n    <div class=\"entry\">\n        <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在 Oracle APEX 开发过程中，最让人抓狂的瞬间莫过于：由于长时间没登录或者浏览器缓存失效，突然发现自己的 <strong>Workspace（工作区）</strong> 密码死活对不上了。</p>\n<p>作为一名在 APEX 坑里摸爬滚打的从业者，笔者今天就带大家梳理一下官方提供的几种“自救”方案。无论你是普通开发者，还是手握重权的管理员，都能找到对应的破解之法。</p>\n<hr />\n<h2 id=\"01--情况一我是普通开发者但管理员还在\">01 | 情况一：我是普通开发者，但管理员还在</h2>\n<p>如果你只是团队中的一名开发人员，或者你的工作区里还有其他拥有“管理员”权限的账号，那么问题非常简单。</p>\n<h3 id=\"-向工作区管理员求助\">① 向工作区管理员求助</h3>\n<p>这是最快的方法。请联系你的同事，让他执行以下操作：</p>\n<ol>\n<li>登录该工作区。</li>\n<li>点击顶部导航栏的 <strong>Administration</strong> -&gt; <strong>Manage Users and Groups</strong>。</li>\n<li>在列表中找到你的用户名，点击进入。</li>\n<li>在 <strong>Password</strong> 栏直接输入新密码并点击 <strong>Apply Changes</strong>。</li>\n</ol>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/635610/202602/635610-20260204072813066-1686472654.jpg\" /></p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/635610/202602/635610-20260204072813261-336974113.jpg\" /></p>\n<blockquote>\n<p><strong>笔者提醒：</strong> 这种方式不需要重启任何服务，即修改即生效，非常适合团队协作开发。</p>\n</blockquote>\n<hr />\n<h2 id=\"02--情况二我是管理员但记不住密码了\">02 | 情况二：我是管理员，但记不住密码了</h2>\n<p>如果你是该工作区唯一的管理员，但你还记得 <strong>INTERNAL</strong> 管理台（即 Instance Admin）的登录凭据，那么你依然可以通过“降维打击”来解决问题。</p>\n<h3 id=\"-登录-internal-工作区\">① 登录 INTERNAL 工作区</h3>\n<ol>\n<li>在 APEX 登录页面，将工作区名称输入为 <code>INTERNAL</code>。</li>\n<li>使用实例管理员账号（通常是 <code>ADMIN</code>）登录。</li>\n</ol>\n<h3 id=\"-管理所有用户\">② 管理所有用户</h3>\n<ol>\n<li>进入后，依次点击 <strong>Manage Workspaces</strong> -&gt; <strong>Manage Developers and Users</strong>。</li>\n</ol>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/635610/202602/635610-20260204072813215-1661679627.jpg\" /></p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/635610/202602/635610-20260204072813245-1600580137.jpg\" /></p>\n<ol start=\"2\">\n<li>找到你要重置的密码，直接reset，手工设置新的密码。</li>\n</ol>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/635610/202602/635610-20260204072813237-1522213160.jpg\" /></p>\n<p>注意：这里特意选择手工输入密码，所以就可以不必管什么Email能否收到，直接使用你修改的密码登录即可。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/635610/202602/635610-20260204072813083-292191341.jpg\" /></p>\n<hr />\n<h2 id=\"03--情况三终极绝招连-internal-密码也忘了\">03 | 情况三：终极绝招，连 INTERNAL 密码也忘了</h2>\n<p>这是最极端的情况：你不仅进不去自己的 Workspace，连整个 APEX 实例的超级管理员密码也丢了。这时，我们需要动用数据库底层的力量。</p>\n<h3 id=\"-准备工作\">① 准备工作</h3>\n<p>你需要拥有数据库所在服务器的访问权限，并且能够以 <code>SYSDBA</code> 身份连接数据库。</p>\n<h3 id=\"-运行官方重置脚本\">② 运行官方重置脚本</h3>\n<p>Oracle APEX 在安装包中专门提供了一个名为 <code>apxchpwd.sql</code> 的脚本，它是专门用来重置 <code>INTERNAL</code> 实例管理员密码的“后悔药”。</p>\n<ol>\n<li>找到你的 APEX 安装源文件目录（即你解压 <code>apex_xx.x.zip</code> 的地方）。</li>\n<li>在命令行中进入该目录，并进入 SQL*Plus：</li>\n</ol>\n<pre><code class=\"language-sql\">sqlplus / as sysdba\n</code></pre>\n<ol start=\"3\">\n<li>运行重置脚本：</li>\n</ol>\n<pre><code class=\"language-sql\">@apxchpwd.sql\n</code></pre>\n<ol start=\"4\">\n<li>根据系统提示，输入新的 <code>ADMIN</code> 密码。</li>\n</ol>\n<blockquote>\n<p><strong>官方规范提示：</strong> 密码必须符合 APEX 的复杂度要求（通常包含大小写字母、数字及特殊符号）。脚本运行成功后，你就可以用这个新密码登录 <code>INTERNAL</code> 工作区，然后再去救治其他业务工作区了。</p>\n</blockquote>\n<hr />\n<h2 id=\"04--总结与预防\">04 | 总结与预防</h2>\n<p>为了避免下次再陷入这种尴尬，笔者建议大家在日常使用中，不要完全依赖浏览器的密码保存，也自己在本地另存一份密码信息，并定期更新。</p>\n<p>另外密码丢失不可怕，可怕的是不知道如何快速重置密码。希望这篇指南能帮你在遇到这类场景时快速找回密码，继续愉快的 Low-Code 之旅！</p>\n\n\n</div>\n<div id=\"MySignature\">\n    <a href=\"https://www.cnblogs.com/jyzhao/\" target=\"_blank\">AlfredZhao</a>©版权所有「从Oracle起航，领略精彩的IT技术。」<br />\n转载请注明原文链接：<a href=\"https://www.cnblogs.com/jyzhao/p/19572308/apex-shi-zhan-di12pianoracle-apex-gong-zuo-qu-mi-m\" target=\"_blank\">https://www.cnblogs.com/jyzhao/p/19572308/apex-shi-zhan-di12pianoracle-apex-gong-zuo-qu-mi-m</a>\n<hr />\n<div style=\"text-align: center; margin-top: 30px;\">\n  <p style=\"font-size: 14px; color: #555;\">\n    👋 感谢阅读，欢迎关注我的公众号 <b>「赵靖宇」</b>\n  </p>\n  <img src=\"https://images.cnblogs.com/cnblogs_com/jyzhao/824234/o_250208075013_qrcode-zjy.jpg\" style=\"border: 1px solid #ddd; border-radius: 8px;\" width=\"160\" />\n</div>\n</div>\n<div class=\"clear\"></div>\n\n        <div class=\"clear\"></div>\n        \n</div>\n    <ul class=\"postmetadata\">\n        \n    </ul>"
    },
    {
      "title": "使用 NanUI 快速创建具有现代用户界面的 WinForm 应用程序",
      "link": "https://www.cnblogs.com/Can-daydayup/p/19571766",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Can-daydayup/p/19571766\" id=\"cb_post_title_url\" title=\"发布于 2026-02-03 22:52\">\n    <span>使用 NanUI 快速创建具有现代用户界面的 WinForm 应用程序</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2><span class=\"content\">前言</span></h2>\n<p>今天大姚给大家分享一个强大的 .NET 开源框架，它利用 Web 技术（HTML5、CSS3、JavaScript）为 WinForm 应用程序构建现代化的用户界面：NanUI。</p>\n<p>如果你正在寻找一个用于创建具有现代用户界面的 WinForm 应用程序的框架，NanUI 是一个不错的选择。</p>\n<h2><span class=\"content\">项目介绍</span></h2>\n<p>NanUI 是一个基于 .NET 平台的开源（MIT License）框架，旨在帮助开发者使用 HTML5、CSS3 和 JavaScript 构建具有现代感的 WinForm 应用程序用户界面。它底层依托于 Xilium.CefGlue 这是 Chromium Embedded Framework（CEF）在 .NET 环境下的官方绑定实现，通过嵌入完整的 Chromium 渲染引擎，使 WinForm 应用能够呈现 Web 技术驱动的富交互界面。</p>\n<h2><span class=\"content\">基本原理</span></h2>\n<p><strong>官方介绍：</strong></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202602/1336199-20260203224945896-1709690796.png\" /></p>\n<p><strong>基本原理概括：</strong></p>\n<ul>\n<li><strong>Chromium Embedded Framework (CEF)</strong>&nbsp;是一个开源项目，一个用于将基于 Chromium 的浏览器嵌入其他应用程序的简单框架。</li>\n<li>它提供稳定的 C/C++ API，支持多进程架构（Browser 进程 + Renderer/GPU 等子进程），具备完整的 HTML5 渲染、JavaScript 执行、网络请求、安全沙箱等能力。</li>\n<li>NanUI 并未直接调用 CEF 的 C 接口，而是基于&nbsp;<strong>Xilium.CefGlue</strong>&nbsp;这是一个高质量的 .NET 封装库，将 CEF 的 C++ API 转换为 C# 可调用的托管接口。</li>\n</ul>\n<h2><span class=\"content\">环境要求</span></h2>\n<h3><span class=\"content\">开发环境</span></h3>\n<ul>\n<li>Visual Studio 2019 或更高版本。</li>\n<li>NET Framework 4.6.2 或更高版本 / .NET 6.0 或更高版本。</li>\n</ul>\n<h3><span class=\"content\">部署环境</span></h3>\n<ul>\n<li>.NET Framework 4.6.2 或更高版本。</li>\n<li>.NET 6.0 需要 Windows 7 Service Pack 1 或更高版本。</li>\n<li>.NET 7.0/8.0/9.0 需要 Windows 10 或 Windows 11。</li>\n<li>Microsoft Windows 7 Service Pack 1 或更高版本。</li>\n</ul>\n<h2><span class=\"content\">项目源代码</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202602/1336199-20260203225000339-222340467.png\" /></p>\n<h2><span class=\"content\">快速使用</span></h2>\n<h3><span class=\"content\">创建一个 WinForm 应用程序</span></h3>\n<p>首先我们快速创建一个名为<code>NanUIExercise</code>&nbsp;Windows 窗体应用程序：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202602/1336199-20260203225039530-1668443758.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202602/1336199-20260203225044905-2091682107.png\" /></p>\n<p><img alt=\"image\" height=\"458\" src=\"https://img2024.cnblogs.com/blog/1336199/202602/1336199-20260203225051053-201638939.png\" width=\"1075\" /></p>\n<h3><span class=\"content\">安装 NanUI NuGet 包</span></h3>\n<p>安装&nbsp;<code>NanUI</code>&nbsp;包&nbsp;<code>NetDimension.NanUI</code>&nbsp;：</p>\n<p><img alt=\"image\" height=\"607\" src=\"https://img2024.cnblogs.com/blog/1336199/202602/1336199-20260203225112224-661517538.png\" width=\"1100\" /></p>\n<p>&nbsp;安装&nbsp;<code>NanUI</code>&nbsp;所依赖的&nbsp;<code>Chromium Embedded Framework</code>&nbsp;依赖包&nbsp;<code>NetDimension.NanUI.Runtime</code>：</p>\n<p><img alt=\"image\" height=\"607\" src=\"https://img2024.cnblogs.com/blog/1336199/202602/1336199-20260203225122223-56769435.png\" width=\"1103\" /></p>\n<p>&nbsp;</p>\n<h3><span class=\"content\">创建一个基本的 NanUI 应用程序</span></h3>\n<p><strong>Program.cs：</strong></p>\n<pre class=\"custom\"><code class=\"hljs\"><span class=\"hljs-keyword\">using&nbsp;NetDimension.NanUI;<br /><br /><span class=\"hljs-keyword\">namespace&nbsp;<span class=\"hljs-title\">NanUIExercise<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">internal&nbsp;<span class=\"hljs-keyword\">static&nbsp;<span class=\"hljs-keyword\">class&nbsp;<span class=\"hljs-title\">Program<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\"><span class=\"hljs-doctag\">///&nbsp;<span class=\"hljs-doctag\">&lt;summary&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\"><span class=\"hljs-doctag\">///&nbsp;&nbsp;The&nbsp;main&nbsp;entry&nbsp;point&nbsp;for&nbsp;the&nbsp;application.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\"><span class=\"hljs-doctag\">///&nbsp;<span class=\"hljs-doctag\">&lt;/summary&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class=\"hljs-meta\">STAThread]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-function\"><span class=\"hljs-keyword\">static&nbsp;<span class=\"hljs-keyword\">void&nbsp;<span class=\"hljs-title\">Main(<span class=\"hljs-params\">)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">var&nbsp;builder&nbsp;=&nbsp;NanUIApp.CreateBuilder();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.UseNanUIApp&lt;MyFirstAPP&gt;();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">var&nbsp;app&nbsp;=&nbsp;builder.Build();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;app.Run();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>\n<p><strong>创建一个类继承 AppStartup 来配置应用程序：</strong></p>\n<pre class=\"custom\"><code class=\"hljs\">using&nbsp;Microsoft.Extensions.DependencyInjection;<br />using&nbsp;NetDimension.NanUI;<br /><br />namespace&nbsp;NanUIExercise<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;class&nbsp;MyFirstAPP&nbsp;:&nbsp;AppStartup<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;override&nbsp;MainWindowCreationAction?&nbsp;UseMainWindow(MainWindowOptions&nbsp;opts)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;设置应用程序的主窗体<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\">return&nbsp;opts.UseMainFormium&lt;MyWindow&gt;();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;override&nbsp;void&nbsp;ProgramMain(string[]&nbsp;args)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Main函数中的代码应该在这里，该函数只在主进程中运行。这样可以防止子进程运行一些不正确的初始化代码。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ApplicationConfiguration.Initialize();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;override&nbsp;void&nbsp;ConfigurationChromiumEmbedded(ChromiumEnvironmentBuiler&nbsp;cef)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;在此处配置&nbsp;Chromium&nbsp;Embedded&nbsp;Framwork<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;override&nbsp;void&nbsp;ConfigureServices(IServiceCollection&nbsp;services)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;在这里配置该应用程序的服务<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br /><br /></span></code></pre>\n<p><strong>创建一个类实现 Formium，用于配置应用程序的主窗口：</strong></p>\n<pre class=\"custom\"><code class=\"hljs\">using&nbsp;NetDimension.NanUI;<br />using&nbsp;NetDimension.NanUI.Forms;<br /><br />namespace&nbsp;NanUIExercise<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;class&nbsp;MyWindow&nbsp;:&nbsp;Formium<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;<span class=\"hljs-function\"><span class=\"hljs-title\">MyWindow()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Url&nbsp;=&nbsp;<span class=\"hljs-string\">\"https://juejin.cn/\";<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;override&nbsp;FormStyle&nbsp;ConfigureWindowStyle(WindowStyleBuilder&nbsp;builder)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;此处配置窗口的样式和属性，或留空以使用默认样式<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;style&nbsp;=&nbsp;builder.UseSystemForm();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;style.TitleBar&nbsp;=&nbsp;<span class=\"hljs-literal\">false;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;style.DefaultAppTitle&nbsp;=&nbsp;<span class=\"hljs-string\">\"My&nbsp;First&nbsp;NanUI&nbsp;App\";<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\">return&nbsp;style;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br /></span></span></span></span></span></span></code></pre>\n<p><strong>运行效果查看：</strong></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202602/1336199-20260203225205762-1526989538.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202602/1336199-20260203225210743-1010420250.png\" /></p>\n<h2><span class=\"content\">项目源码地址</span></h2>\n<p>更多项目实用功能和特性欢迎前往项目开源地址查看👀，别忘了给项目一个Star支持💖。</p>\n<ul>\n<li><strong>Gitee开源地址：</strong>&nbsp;<a href=\"https://gitee.com/dotnetchina/NanUI\" rel=\"noopener nofollow\">https://gitee.com/dotnetchina/NanUI</a></li>\n<li><strong>项目文档地址：</strong>&nbsp;<a href=\"https://gitee.com/dotnetchina/NanUI/blob/master/docs/README.md\" rel=\"noopener nofollow\">https://gitee.com/dotnetchina/NanUI/blob/master/docs/README.md</a></li>\n</ul>\n<h2><span class=\"content\">优秀项目和框架精选</span></h2>\n<p>该项目已收录到C#/.NET/.NET Core优秀项目和框架精选中，关注优秀项目和框架精选能让你及时了解C#、.NET和.NET Core领域的最新动态和最佳实践，提高开发工作效率和质量。坑已挖，欢迎大家踊跃提交PR推荐或自荐（<strong>让优秀的项目和框架不被埋没🤞</strong>）。</p>\n<ul>\n<li><strong>GitHub开源地址：</strong>&nbsp;<a href=\"https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md\" rel=\"noopener nofollow\">https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md</a></li>\n<li><strong>Gitee开源地址：</strong>&nbsp;<a href=\"https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md\" rel=\"noopener nofollow\">https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md</a></li>\n</ul>\n\n</div>\n<div id=\"MySignature\">\n    <blockquote>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者名称：</span><a href=\"https://www.cnblogs.com/Can-daydayup/\" target=\"_blank\">追逐时光者</a></p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者简介：</span>一个热爱编程、善于分享、喜欢学习、探索、尝试新事物和新技术的全栈软件工程师。</p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\">\n本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。如果该篇文章对您有帮助的话，可以点一下右下角的<a href=\"\" style=\"color: red;\">【♥推荐♥】</a>，希望能够持续的为大家带来好的技术文章，文中可能存在描述不正确的地方，欢迎指正或补充，不胜感激。\n</p>\n</blockquote>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-03 22:52</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Can-daydayup\">追逐时光者</a>&nbsp;\n阅读(<span id=\"post_view_count\">287</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "DTS按业务场景批量迁移阿里云MySQL表实战（下）：迁移管理平台设计与实现",
      "link": "https://www.cnblogs.com/wuyuegb2312/p/19571685",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wuyuegb2312/p/19571685\" id=\"cb_post_title_url\" title=\"发布于 2026-02-03 22:34\">\n    <span>DTS按业务场景批量迁移阿里云MySQL表实战（下）：迁移管理平台设计与实现</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>本文是 <a href=\"https://www.cnblogs.com/wuyuegb2312/p/19566555\" target=\"_blank\">DTS按业务场景批量迁移阿里云MySQL表实战（上）：技术选型和API对接</a>  的后续，应用状态模式，完成业务系统中的迁移模块。DTS的对接方式可参考前文。</p>\n<h1 id=\"迁移管理平台设计与实现\">迁移管理平台设计与实现</h1>\n<p>完成DTS API对接后，就需要考虑如何将DTS和业务系统有机结合实现整套的迁移流程。</p>\n<p>出于信息安全角度的考虑，本文删除了大量涉及实际业务的实现代码。</p>\n<h2 id=\"业务约束\">业务约束</h2>\n<p>从业务出发，最好的体验肯定是用户无感的，即迁移完成后，确认新旧表数据一致，直接切换到新表查询。</p>\n<p>如果迁移期间，用户对旧表进行了写入，新表可能会少数据，不能贸然切换，要做数据的对比。如果用户一直在写入，就要一直反复的对比、确认，有增量数据就要删除新表重新迁移，流程复杂。</p>\n<p>和业务方沟通，得知对方可以接受：禁止写入正在迁移的公司的表，向用户报错，等迁移完成后再恢复使用。<br />\n这样流程就简单多了，开始迁移时，将旧表重命名增加特殊的后缀，就能防止用户操作，并确保旧表数据不发生变更。</p>\n<h2 id=\"技术校验\">技术校验</h2>\n<p>如何判断一个公司是否迁移成功？最严谨的方式是逐表逐行数据对比，但是在使用DTS的情况下并无必要。我采取的比较策略是，在迁移前后：</p>\n<ol>\n<li>\n<p>源表目标表数量相同</p>\n</li>\n<li>\n<p>对应表数据量相同、数据最后更新时间（如有此列）相同</p>\n</li>\n</ol>\n<p>只要满足以上要求，就认为数据是一致的。可以通过SELECT COUNT(*), MAX(updateTime) FROM table_name一次性获取。</p>\n<h2 id=\"迁移状态机\">迁移状态机</h2>\n<p>经过分析和简化，迁移状态机如下：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/228024/202602/228024-20260203223055533-1166349172.png\" /></p>\n<p>可以发现，每个状态都可以进行“推进”和“回滚”两个动作，很适合使用状态模式来实现。状态模式的实现先放一放，看看几个基本数据结构：</p>\n<h2 id=\"迁移任务\">迁移任务</h2>\n<pre><code class=\"language-Java\">@Data\npublic class TableMigrateTask {\n  // 主键\n  private Long id;\n  // 公司id\n  private Long companyId;\n  // 原始分库位\n  private Long oldSchemaId;\n  // 新分库位\n  private Long newSchemaId;\n  // 任务状态\n  private Integer state;\n  // DTS任务状态，和阿里云定义一致\n  private String dtsStatus;\n  // DTS任务已删除（释放）\n  private Boolean dtsDeleted;\n  // DTS实例id\n  private String dtsInstanceId;\n  // DTS任务id\n  private String dtsJobId;\n  // 失败原因\n  private String failedReason;\n  // 状态跳转时的信息，辅助排查问题\n  private String transitInfo;\n  // 迁移前表数据统计，json格式，表名、数据量、最后更新时间\n  private String tableStatisticsSrc;\n  // 迁移表结果统计，json格式kv结构，表名-数据量\n  private String tableStatisticsDest;\n}\n</code></pre>\n<h2 id=\"迁移上下文\">迁移上下文</h2>\n<p>迁移状态机实际处理的对象，封装了一些服务，可以视为领域对象（充血模型）。</p>\n<pre><code class=\"language-Java\">@Setter\npublic class TableMigrateExecuteContext {\n\n  // 持有的任务对象\n  @Getter\n  private TableMigrateTask tableMigrateTask;\n\n  // 当前的状态\n  @Getter\n  private TableMigrateState currentState;\n\n  private TableMigrateTaskRepository tableMigrateTaskRepository;\n\n  private TableMigrateQueryService tableMigrateQueryService;\n\n  private TableMigrateService tableMigrateService;\n\n  private TableArchiveService tableArchiveService;\n\n  private DataSourceHolder dataSourceHolder;\n\n  public void createInstanceAndConfigureDtsJob() {\n      // 调用DTS API创建任务\n  }\n\n  public DescribeDtsJobDetailResponse queryDtsMigJob() {\n      // 调用DTS API查询\n  }\n\n  public void switchRoute(long oldSchemaId, long newSchemaId) {\n      // 将分表以外的单表update为newSchemaId\n  }\n\n  public void stopDtsMigJob() {\n      // 调用DTS API停止\n  }\n\n  public void updateTableMigrateTask(TableMigrateTask modifiedTask) {\n       // 更新持有的任务(持久化)\n  }\n\n  /**\n   * 状态推进\n   *\n   * @return 返回信息，不成功时非空\n   */\n  public String forward() {\n    return currentState.forward(this);\n  }\n\n  /** 状态回滚 */\n  public String rollback() {\n    return currentState.rollback(this);\n  }\n\n  /**\n   * 重命名旧表\n   *\n   * @param forward true-迁移场景，加——migold，反之则不加\n   * @param ignoreExited 是否忽略已存在的表，仅在初始态的回滚场景可用\n   */\n  public void renameOldTableNames(boolean forward, boolean ignoreExited) {\n      // 注意要考虑源库中是否存在和旧表相同的同名表\n  }\n\n\n  public void updateDestTableInfo() {\n     // 更新目标表的统计信息\n  }\n\n  public void archiveNewTables(List&lt;String&gt; needArchiveTables) {\n      // 归档新表  \n  }\n\n  /**\n   * 删除表\n   *\n   * @param newTable true-新表，false-旧表\n   */\n  public void deleteTables(boolean newTable) {\n      // 批量执行DROP TABLE\n  }\n\n  public void deleteDtsInstanceAndJob() {\n      // 调用DTS API释放实例\n  }\n}\n</code></pre>\n<h3 id=\"工厂类\">工厂类</h3>\n<pre><code class=\"language-Java\">@Component\npublic class TableMigrateContextFactory {\n\n  @Resource private TableMigrateTaskRepository tableMigrateTaskRepository;\n  @Resource private TableMigrateQueryService tableMigrateQueryService;\n  @Resource private TableMigrateService tableMigrateService;\n  @Resource private TableArchiveService tableArchiveService;\n  @Resource private DataSourceHolder dataSourceHolder;\n\n  public TableMigrateExecuteContext buildContext(long taskId) {\n    TableMigrateTask task = tableMigrateTaskRepository.getById(taskId);\n    if (task == null || task.getStatus() == 0) {\n      throw new BizException(\"表迁移任务不存在或已被删除\");\n    }\n    TableMigrateExecuteContext context = new TableMigrateExecuteContext();\n    context.setTableMigrateTask(task);\n    context.setCurrentState(buildState(TableMigrateStateEnum.getByValue(task.getState())));\n\n    // 服务注入\n    context.setTableMigrateTaskRepository(tableMigrateTaskRepository);\n    context.setTableMigrateQueryService(tableMigrateQueryService);\n    context.setTableMigrateService(tableMigrateService);\n    context.setTableArchiveService(tableArchiveService);\n    context.setDataSourceHolder(dataSourceHolder);\n    return context;\n  }\n\n  private TableMigrateState buildState(TableMigrateStateEnum stateEnum) {\n    switch (stateEnum) {\n      case INIT:\n        return new MigrateInitState();\n      case FAILED:\n        return new MigrateFailedState();\n      case PROCESSING:\n        return new MigrateProcessingState();\n      case NEED_SWITCH:\n        return new MigrateNeedSwitchState();\n      case SWITCHED:\n        return new MigrateSwitchedState();\n      case FINISH:\n        return new MigrateFinishState();\n      default:\n        throw new BizException(\"迁移状态非法\");\n    }\n  }\n}\n</code></pre>\n<h2 id=\"迁移状态\">迁移状态</h2>\n<p>我在做本次的系统设计时，对状态模式做了一些回顾和参考。迁移状态是状态模式的核心，从设计模式的角度来看，状态模式“允许对象在其内部状态改变时动态调整自身行为，使得对象的表现形态如同修改了其所属类。”</p>\n<p>以下是各个类的继承关系：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/228024/202602/228024-20260203223122974-1126879955.png\" /></p>\n<p>对应的状态如下：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>类名</td>\n<td>含义</td>\n<td>说明</td>\n</tr>\n<tr>\n<td>TableMigrateState</td>\n<td>接口定义</td>\n<td></td>\n</tr>\n<tr>\n<td>AbstractMigrateState</td>\n<td>状态抽象类</td>\n<td></td>\n</tr>\n<tr>\n<td>AbstractFinalState</td>\n<td>终态抽象类</td>\n<td>终态很多操作都是不支持的，和AbstractMigrateState分开更简洁</td>\n</tr>\n<tr>\n<td>MigrateInitState</td>\n<td>初始</td>\n<td>记录要迁移的统计数据和配置</td>\n</tr>\n<tr>\n<td>MigrateProcessingState</td>\n<td>迁移中</td>\n<td>DTS进行迁移动作的状态</td>\n</tr>\n<tr>\n<td>MigrateNeedSwitchState</td>\n<td>迁移完成待切换分库位</td>\n<td>数据已同步在新表，但还不可以通过业务功能直接访问</td>\n</tr>\n<tr>\n<td>MigrateSwitchedState</td>\n<td>分库位已切换待删除旧表</td>\n<td>数据已同步在新表，且能通过业务功能直接访问</td>\n</tr>\n<tr>\n<td>MigrateFinishState</td>\n<td>迁移完成</td>\n<td>数据已同步在新表且能访问，旧表已删除</td>\n</tr>\n<tr>\n<td>MigrateFailedState</td>\n<td>迁移失败</td>\n<td>回滚，旧表恢复访问，新表如果有则删除</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"状态接口\">状态接口</h3>\n<pre><code class=\"language-Java\">public interface TableMigrateState {\n\n  /**\n   * 前进到下一状态\n   *\n   * @param context\n   * @return 失败的提示信息\n   */\n  String forward(TableMigrateExecuteContext context);\n\n  /**\n   * 回滚操作\n   *\n   * @param context\n   * @return 失败的提示信息\n   */\n  String rollback(TableMigrateExecuteContext context);\n\n  /**\n   * 获取当前的状态对应枚举\n   */\n  TableMigrateStateEnum getState();\n\n  /**\n   * 获取下一个状态\n   */\n  TableMigrateState getNextState();\n\n  /**\n   * 获取回滚的状态\n   */\n  TableMigrateState getRollbackState();\n}\n</code></pre>\n<h3 id=\"状态抽象类\">状态抽象类</h3>\n<pre><code class=\"language-TypeScript\">public abstract class AbstractMigrateState implements TableMigrateState {\n\n  @Override\n  public String forward(TableMigrateExecuteContext context) {\n    TableMigrateTask task = context.getTableMigrateTask();\n\n    // 1. 前置校验\n    // 根据校验结果，判断是留在当前状态，还是直接回滚到迁移失败状态\n\n    // 2. 实际动作，由实现类完成\n   // 简单起见，在实际动作里的异常都自动回滚\n\n    // 3. 状态跳转\n    transit(context, getNextState());\n    return null;\n  }\n\n  @Override\n  public String rollback(TableMigrateExecuteContext context) {\n    TableMigrateTask task = context.getTableMigrateTask();\n    // 1. 当前状态校验\n    checkCurrentState(context);\n\n    // 2. 回滚操作，如果发生异常，保持在当前状态\n\n    // 3. 状态跳转\n    transit(context, getRollbackState());\n    return null;\n  }\n\n  /**\n   * 前置校验\n   *\n   * @param context\n   */\n  protected PreCheckResult preCheck(TableMigrateExecuteContext context) {\n    return checkCurrentState(context);\n  }\n\n  protected PreCheckResult checkCurrentState(TableMigrateExecuteContext context) {\n      // 检查当前状态是否符合预期，构造检查结果\n  }\n\n  /**\n   * 改变当前执行上下文状态, 不做其他的业务操作\n   *\n   * @param context\n   * @param nextState\n   */\n  private void transit(TableMigrateExecuteContext context, TableMigrateState nextState) {\n    TableMigrateTask task = context.getTableMigrateTask();\n    task.setState(nextState.getState().getValue());\n    context.updateTableMigrateTask(task);\n    context.setCurrentState(nextState);\n  }\n  \n  protected abstract void doForward(TableMigrateExecuteContext context);\n\n  /**\n   * 回滚操作\n   *\n   * &lt;p&gt;需要保证幂等，如果单个回滚操作失败，可以重复执行\n   *\n   * @param context\n   */\n  protected abstract void doRollback(TableMigrateExecuteContext context);\n\n  /**\n   * 旧表更名\n   *\n   * @param context\n   * @param forward true-迁移场景，旧表加后缀; false-回滚场景，旧表删除后缀\n   */\n  protected void renameOldTableNames(\n      TableMigrateExecuteContext context, boolean forward, boolean ignoreExited) {\n    context.renameOldTableNames(forward, ignoreExited);\n  }\n\n  /**\n   * 删除新表\n   *\n   * &lt;p&gt;新表的删除，最好不要共用这个方法\n   *\n   * @param context\n   */\n  protected void deleteNewTables(TableMigrateExecuteContext context) {\n    context.deleteTables(true);\n  }\n\n  /** 前置校验结果 */\n  @Data\n  @AllArgsConstructor\n  public static class PreCheckResult {\n    /** 中断，需要回滚 */\n    public static final int ABORT = -1;\n\n    /** 校验通过 */\n    public static final int PASS = 0;\n\n    /** 校验不通过，保持原有状态 */\n    public static final int NOT_PASS = 1;\n\n    private int code;\n\n    private String msg;\n\n    public static PreCheckResult buildPass() {\n      return new PreCheckResult(PASS, null);\n    }\n\n    public boolean isPass() {\n      return this.code == PASS;\n    }\n  }\n}\n</code></pre>\n<h3 id=\"终态抽象类\">终态抽象类</h3>\n<pre><code class=\"language-TypeScript\">public abstract class AbstractFinalState implements TableMigrateState {\n  @Override\n  public String forward(TableMigrateExecuteContext context) {\n    return \"当前状态【\" + getState().getValue() + \" \" + getState().getDes() + \"】已是终态，不能进行下一步操作\";\n  }\n\n  @Override\n  public String rollback(TableMigrateExecuteContext context) {\n    return \"当前状态【\" + getState().getValue() + \" \" + getState().getDes() + \"】已是终态，不能进行撤销操作\";\n  }\n\n  @Override\n  public TableMigrateState getNextState() {\n    throw new BizException(\"当前状态\" + getState().getValue() + \"已是终态，没有后续状态可跳转\");\n  }\n\n  @Override\n  public TableMigrateState getRollbackState() {\n    throw new BizException(\"当前状态\" + getState().getValue() + \"已是终态，没有后续撤销态可跳转\");\n  }\n}\n</code></pre>\n<h3 id=\"初始\">初始</h3>\n<pre><code class=\"language-TypeScript\">public class MigrateInitState extends AbstractMigrateState {\n  @Override\n  protected void doForward(TableMigrateExecuteContext context) {\n    TableMigrateTask task = context.getTableMigrateTask();\n    if (task.getOldSchemaId().equals(task.getNewSchemaId())) {\n      throw new BizException(\"迁移前后的分库位id相同\");\n    }\n\n    // 1. 旧表更名, 直接阻止后续的变更\n    // 归档不影响RENAME\n    renameOldTableNames(context, true, false);\n\n    // 2. 创建DTS任务并回写到task字段\n    // 创建失败则直接抛异常，回滚\n    // 此处DTS任务是直接提交执行的，并不能确定当前实际是哪个状态，因此状态留空\n    context.createInstanceAndConfigureDtsJob();\n  }\n  \n  @Override\n  protected void doRollback(TableMigrateExecuteContext context) {\n    // 初始态回滚时，旧表可能还没有更名\n    renameOldTableNames(context, false, true);\n  }\n\n  @Override\n  public TableMigrateStateEnum getState() {\n    return TableMigrateStateEnum.INIT;\n  }\n\n  @Override\n  public TableMigrateState getNextState() {\n    return new MigrateProcessingState();\n  }\n\n  @Override\n  public TableMigrateState getRollbackState() {\n    return new MigrateFailedState();\n  }\n}\n</code></pre>\n<h3 id=\"迁移中\">迁移中</h3>\n<pre><code class=\"language-TypeScript\">public class MigrateProcessingState extends AbstractMigrateState {\n\n  /** DTS-未初始化的状态 */\n  private static final Set&lt;String&gt; DTS_NOT_INIT =\n      Sets.newHashSet(\n          DtsJobStatusEnum.NOT_STARTED.getCode(), DtsJobStatusEnum.NOT_CONFIGURED.getCode());\n\n  /** DTS-处理中的状态 */\n  private static final Set&lt;String&gt; DTS_PROCESSING =\n      Sets.newHashSet(\n          DtsJobStatusEnum.PRECHECKING.getCode(),\n          DtsJobStatusEnum.PRECHECK_PASS.getCode(),\n          DtsJobStatusEnum.INITIALIZING.getCode(),\n          DtsJobStatusEnum.SYNCHRONIZING.getCode(),\n          DtsJobStatusEnum.MIGRATING.getCode(),\n          DtsJobStatusEnum.SUSPENDING.getCode(),\n          DtsJobStatusEnum.MODIFYING.getCode(),\n          DtsJobStatusEnum.RETRYING.getCode(),\n          DtsJobStatusEnum.UPGRADING.getCode(),\n          DtsJobStatusEnum.DOWNGRADING.getCode(),\n          DtsJobStatusEnum.LOCKED.getCode());\n\n  /** DTS-失败的状态 */\n  private static final Set&lt;String&gt; DTS_FAILED =\n      Sets.newHashSet(\n          DtsJobStatusEnum.PRECHECK_FAILED.getCode(),\n          DtsJobStatusEnum.INITIALIZE_FAILED.getCode(),\n          DtsJobStatusEnum.FAILED.getCode(),\n          DtsJobStatusEnum.MIGRATION_FAILED.getCode());\n\n  @Override\n  public PreCheckResult preCheck(TableMigrateExecuteContext context) {\n    checkCurrentState(context);\n    // 校验DTS任务已完成\n    TableMigrateTask task = context.getTableMigrateTask();\n    DescribeDtsJobDetailResponse dtsJobDetailResponse = context.queryDtsMigJob();\n    if (dtsJobDetailResponse == null || dtsJobDetailResponse.getBody() == null) {\n      return new PreCheckResult(\n          PreCheckResult.NOT_PASS,\n          String.format(\n              \"DTS任务结果查询失败, 返回结果为空。instanceId=%s, jobId=%s\",\n              task.getDtsInstanceId(), task.getDtsJobId()));\n    }\n    DescribeDtsJobDetailResponseBody responseBody = dtsJobDetailResponse.getBody();\n    if (BooleanUtils.isNotTrue(responseBody.getSuccess())) {\n      return new PreCheckResult(\n          PreCheckResult.NOT_PASS,\n          String.format(\n              \"DTS任务结果查询失败, 接口调用结果为失败。instanceId=%s, jobId=%s\",\n              task.getDtsInstanceId(), task.getDtsJobId()));\n    }\n    DtsJobStatusEnum dtsJobStatusEnum = DtsJobStatusEnum.getByCode(responseBody.getStatus());\n    if (dtsJobStatusEnum == null) {\n      return new PreCheckResult(\n          PreCheckResult.NOT_PASS,\n          String.format(\n              \"DTS任务状态非法，请稍后重试。instanceId=%s, jobId=%s, 阿里云状态=%s\",\n              task.getDtsInstanceId(), task.getDtsJobId(), responseBody.getStatus()));\n    }\n    task.setDtsStatus(dtsJobStatusEnum.getCode());\n    if (DTS_NOT_INIT.contains(dtsJobStatusEnum.getCode())) {\n      return new PreCheckResult(\n          PreCheckResult.NOT_PASS,\n          String.format(\n              \"DTS任务状态异常，尚未初始化。instanceId=%s, jobId=%s, 阿里云状态=%s\",\n              task.getDtsInstanceId(), task.getDtsJobId(), responseBody.getStatus()));\n    }\n    if (DTS_PROCESSING.contains(dtsJobStatusEnum.getCode())) {\n      return new PreCheckResult(\n          PreCheckResult.NOT_PASS,\n          String.format(\n              \"DTS任务仍在处理中。instanceId=%s, jobId=%s, 阿里云状态=%s\",\n              task.getDtsInstanceId(), task.getDtsJobId(), responseBody.getStatus()));\n    }\n    if (DTS_FAILED.contains(dtsJobStatusEnum.getCode())) {\n      return new PreCheckResult(\n          PreCheckResult.ABORT,\n          String.format(\n              \"DTS任务执行失败。instanceId=%s, jobId=%s, 阿里云状态=%s\",\n              task.getDtsInstanceId(), task.getDtsJobId(), responseBody.getStatus()));\n    }\n    if (StringUtils.equals(DtsJobStatusEnum.FINISHED.getCode(), dtsJobStatusEnum.getCode())) {\n      return PreCheckResult.buildPass();\n    }\n    return new PreCheckResult(\n        PreCheckResult.NOT_PASS,\n        String.format(\n            \"DTS任务状态非法。instanceId=%s, jobId=%s, 阿里云状态=%s\",\n            task.getDtsInstanceId(), task.getDtsJobId(), responseBody.getStatus()));\n  }\n\n  @Override\n  protected void doForward(TableMigrateExecuteContext context) {\n    // 已在校验时更新任务状态，并根据DTS执行状态判断要不要回滚\n\n    // 1. 将迁移后的表，按照原表的状态进行归档\n\n    // 2. 写入迁移后的表统计信息\n    context.updateDestTableInfo();\n  }\n\n  @Override\n  protected void doRollback(TableMigrateExecuteContext context) {\n    // 1. 尝试中止DTS任务，对已完成的DTS任务调用不会抛异常\n\n    // 2. 新表删除\n    deleteNewTables(context);\n\n    // 3. 旧表名称还原\n    renameOldTableNames(context, false, false);\n  }\n\n  @Override\n  public TableMigrateStateEnum getState() {\n    return TableMigrateStateEnum.PROCESSING;\n  }\n\n  @Override\n  public TableMigrateState getNextState() {\n    return new MigrateNeedSwitchState();\n  }\n\n  @Override\n  public TableMigrateState getRollbackState() {\n    return new MigrateFailedState();\n  }\n}\n</code></pre>\n<h3 id=\"迁移完成待切换分库位\">迁移完成待切换分库位</h3>\n<pre><code class=\"language-TypeScript\">public class MigrateNeedSwitchState extends AbstractMigrateState {\n\n  @Override\n  protected void doForward(TableMigrateExecuteContext context) {\n    // 单表路由切换\n    context.switchRoute(\n        context.getTableMigrateTask().getOldSchemaId(),\n        context.getTableMigrateTask().getNewSchemaId());\n  }\n\n  @Override\n  protected void doRollback(TableMigrateExecuteContext context) {\n    // 1. 新表删除\n    deleteNewTables(context);\n\n    // 2. 旧表名称还原\n    renameOldTableNames(context, false, false);\n\n    // 3. 单表和路由恢复\n    // 可能已经在forward时做过，因此也做复原\n    context.switchRoute(\n        context.getTableMigrateTask().getNewSchemaId(),\n        context.getTableMigrateTask().getOldSchemaId());\n  }\n\n  @Override\n  public TableMigrateStateEnum getState() {\n    return TableMigrateStateEnum.NEED_SWITCH;\n  }\n\n  @Override\n  public TableMigrateState getNextState() {\n    return new MigrateSwitchedState();\n  }\n\n  @Override\n  public TableMigrateState getRollbackState() {\n    return new MigrateFailedState();\n  }\n}\n</code></pre>\n<h3 id=\"分库位已切换待删除旧表\">分库位已切换待删除旧表</h3>\n<pre><code class=\"language-TypeScript\">public class MigrateSwitchedState extends AbstractMigrateState {\n\n  @Override\n  protected void doForward(TableMigrateExecuteContext context) {\n    // 删除旧表\n    context.deleteTables(false);\n  }\n\n  @Override\n  protected void doRollback(TableMigrateExecuteContext context) {\n    // 1. 新表删除\n    deleteNewTables(context);\n\n    // 2. 旧表名称还原\n    renameOldTableNames(context, false, false);\n\n    // 3. 单表和路由恢复\n    context.switchRoute(\n        context.getTableMigrateTask().getNewSchemaId(),\n        context.getTableMigrateTask().getOldSchemaId());\n  }\n\n  @Override\n  public TableMigrateStateEnum getState() {\n    return TableMigrateStateEnum.SWITCHED;\n  }\n\n  @Override\n  public TableMigrateState getNextState() {\n    return new MigrateFinishState();\n  }\n\n  @Override\n  public TableMigrateState getRollbackState() {\n    return new MigrateFailedState();\n  }\n}\n</code></pre>\n<h3 id=\"迁移完成\">迁移完成</h3>\n<pre><code class=\"language-Java\">public class MigrateFinishState extends AbstractFinalState {\n  @Override\n  public TableMigrateStateEnum getState() {\n    return TableMigrateStateEnum.FINISH;\n  }\n}\n</code></pre>\n<h3 id=\"迁移失败\">迁移失败</h3>\n<pre><code class=\"language-Java\">public class MigrateFailedState extends AbstractFinalState {\n  @Override\n  public TableMigrateStateEnum getState() {\n    return TableMigrateStateEnum.FAILED;\n  }\n}\n</code></pre>\n<h2 id=\"操作流程\">操作流程</h2>\n<ol>\n<li>\n<p>创建迁移任务TableMigrateTask</p>\n</li>\n<li>\n<p>通过工厂类，使用任务id创建包含迁移任务TableMigrateTask的迁移上下文TableMigrateExecuteContext</p>\n</li>\n<li>\n<p>调用TableMigrateExecuteContext的forward()推进状态、rollback()回滚状态</p>\n</li>\n</ol>\n<h2 id=\"查询相关功能实现\">查询相关功能实现</h2>\n<h3 id=\"dts任务列表查询\">DTS任务列表查询</h3>\n<p>因为已经把DTS的相关字段持久化了，可以通过业务系统相关的迁移任务表实现分页查询。</p>\n<p>不过在“迁移中”跳转到“迁移完成待切换分库位”的过程中，DTS也会经历多个状态，典型的有Prechecking、Migrating、Finished等（见<a href=\"https://next.api.aliyun.com/document/Dts/2020-01-01/DescribeDtsJobDetail\" rel=\"noopener nofollow\" target=\"_blank\">DescribeDtsJobDetail_数据传输_API文档</a>的Status字段说明），可以通过接口获取最新的状态并写入迁移任务表。</p>\n<h3 id=\"如何查询待迁移的表\">如何查询待迁移的表？</h3>\n<p>回顾一下，要迁移的表分以下三种形式：</p>\n<ul>\n<li>\n<p>后缀是公司id，如table_companyId</p>\n</li>\n<li>\n<p>后缀是 公司_年份，如table_company_year</p>\n</li>\n<li>\n<p>后缀是业务id，如table_bizId</p>\n</li>\n</ul>\n<p>对于同一个前缀，以companyId=123为例，第一、三种表都可以精确匹配：</p>\n<ul>\n<li>\n<p>第一种表每个公司只有一张，比如table_a_123、table_b_123；</p>\n</li>\n<li>\n<p>第三种表每个bizId同一个公司只有一张，比如bizId可以取1、2，那么会存在table_c_1、table_c_2、table_d_1、table_d_2，并且，bizId是有限的，可以从一张bizId_table表获取所有可选值。</p>\n</li>\n<li>\n<p>对于第二种表year的取值范围，虽然可以类似bizId一样去找，但是并没有直接的关系表。</p>\n</li>\n</ul>\n<p>我想到了两种方案，最后选择了第二种。</p>\n<h4 id=\"show-tables-like查询指定前缀\">SHOW TABLES LIKE查询指定前缀</h4>\n<p>这是最先考虑到的方案，比较直接，而且在开发、测试环境中运行良好。但是在线上就不行了，将所有表查询一次要数分钟，调用早已超时。我想这应该和线上环境表数量过多导致元数据获取变慢有关，每次查询需要上百ms，累计耗时长达数分钟。</p>\n<h4 id=\"databasemetadata一次性获取所有表后过滤\">DatabaseMetaData一次性获取所有表后过滤</h4>\n<p>可以通过DataSource的元数据，一次性获取数据源对应库的所有的表，再将表名进行过滤。经过测试，10W级数据获取全部表的时间在3~7S之间，和方案一相比快很多。</p>\n<p>以下代码片段展示了如何获取所有表名，忽略异常处理。</p>\n<pre><code class=\"language-Java\">String physicalSchemaName = dataSourceHolder.getPhysicalSchemaName(logicalSchemaName);\nHikariDataSource dataSource = dataSourceHolder.getDataSourceByPhysicalSchemaName(physicalSchemaName);\ntry (Connection connection = dataSource.getConnection()) {\n    DatabaseMetaData metaData = connection.getMetaData();\n    ResultSet catalogs = metaData.getCatalogs();\n    while (catalogs.next()) {\n        String tableCat = catalogs.getString(\"TABLE_CAT\");\n        if (!StringUtils.equals(tableCat, physicalSchemaName)) {\n            // 判断库名是否一致。如果多个库实际上在同一个RDS实例，元数据实际上是这些库的，而非单个库的\n            continue;\n        }\n\n        // 获取指定数据库中的所有表名\n        ResultSet tableResultSet =\n            metaData.getTables(physicalSchemaName, null, \"%\", new String[] {\"TABLE\"});\n        int count = 0;\n        while (tableResultSet.next()) {\n          count++;\n          String physicalTableName = tableResultSet.getString(\"TABLE_NAME\");\n          // 确定是否是要查的表，判断逻辑此处省略【注1】\n         }\n        LoggerUtils.info(\"本次共查询了\" + count + \"个表的元数据\");\n      }\n      LoggerUtils.info(\n          \"获取\" + physicalSchemaName + \"库的所有表元数据总耗时：\" + (System.currentTimeMillis() - t1) + \"ms\");\n    } catch (SQLException e) {\n      LoggerUtils.error(\"获取分库元数据失败, 发生SQL异常\", e);\n      throw new BizException(\"获取分库元数据失败, 发生SQL异常\", e);\n    }\n}\n</code></pre>\n<p>对数据库中每个表判定它是否是当前公司的表，对于第一、三种表，可以将后者放到一个HashSet中，每次循环时对比；对于第二种表，字符串前缀匹配无疑要花大量的时间。</p>\n<p>为了加速前缀匹配，可以使用经典的数据结构——前缀匹配树。前缀匹配树的代码如下：</p>\n<pre><code class=\"language-Java\">public class StringPrefixTrie {\n  private final Node root = new Node();\n\n  static class Node {\n    boolean isEnd;\n    Map&lt;Character, Node&gt; children = new HashMap&lt;&gt;();\n  }\n\n  /**\n   * 增加一个待匹配的模式\n   *\n   * @param pattern\n   */\n  public void addPattern(String pattern) {\n    Node current = root;\n    for (char c : pattern.toCharArray()) {\n      current = current.children.computeIfAbsent(c, k -&gt; new Node());\n    }\n    current.isEnd = true;\n  }\n\n  /**\n   * 是否满足前缀匹配\n   *\n   * @param str\n   * @return\n   */\n  public String match(String str) {\n    Node current = root;\n    for (int i = 0; i &lt; str.length(); i++) {\n      current = current.children.get(str.charAt(i));\n      if (current == null) {\n        // 没有匹配到任何前缀\n        return null;\n      }\n      if (current.isEnd) {\n        // 返回匹配到的任意一个前缀\n        return str.substring(0, i + 1);\n      }\n    }\n    return null;\n  }\n}\n</code></pre>\n<p>对所有需要前缀匹配的表的前缀调用addPattern()，在循环中先判断是否满足前缀匹配，再判断精准匹配即可。</p>\n<h2 id=\"后续规划\">后续规划</h2>\n<ol>\n<li>\n<p>批量迁移功能，将迁移批量化、自动化：</p>\n<ol>\n<li>\n<p>批量捞取公司，判断是否需要迁移、迁移成本。理想情况下，数据量少但表多的公司，是迁移到其他库的最佳候选，大大降低源库的表量又节约了复制数据的时间</p>\n</li>\n<li>\n<p>多个公司id提交、创建任务、状态流转</p>\n</li>\n</ol>\n</li>\n<li>\n<p>自动校验迁移是否成功</p>\n</li>\n</ol>\n\n\n</div>\n<div id=\"MySignature\">\n    <div id=\"AllanboltSignature\">\n        <p id=\"PSignature\">\n            <br />\n            作者：<a href=\"http://www.cnblogs.com/wuyuegb2312\" target=\"_blank\">五岳</a>\n            <br />\n            出处：<a href=\"http://www.cnblogs.com/wuyuegb2312\" target=\"_blank\">http://www.cnblogs.com/wuyuegb2312</a>\n            <br />\n            对于标题未标注为“转载”的文章均为原创，其版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。\n        </p>\n    　</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-03 22:34</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wuyuegb2312\">五岳</a>&nbsp;\n阅读(<span id=\"post_view_count\">78</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}