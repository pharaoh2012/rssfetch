{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "Nano-vLLM-Ascend(持续更新中)",
      "link": "https://www.cnblogs.com/linzm14/p/19611415",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/linzm14/p/19611415\" id=\"cb_post_title_url\" title=\"发布于 2026-02-13 11:38\">\n    <span>Nano-vLLM-Ascend(持续更新中)</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"nano-vllm-ascend\"><a href=\"https://github.com/linzm1007/nano-vllm-ascend\" rel=\"noopener nofollow\" target=\"_blank\">Nano-vLLM-Ascend</a></h2>\n<p>项目链接：<a href=\"https://github.com/linzm1007/nano-vllm-ascend\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/linzm1007/nano-vllm-ascend</a><br />\nnano-vllm是外网开源的一个gpu推理项目，基于开源版本弄的一个ascend npu版本推理小demo，旨在帮助初学者了解推理的整体流程，区别于vllm，nano-vllm体量更小，麻雀虽小五脏俱全，更有助于初学者学习，非常适合用于相关概念的理解。</p>\n<h2 id=\"框架层流程图\">框架层流程图</h2>\n<p><img alt=\"nona-vllm框架\" class=\"lazyload\" /></p>\n<h2 id=\"模型层流程图\">模型层流程图</h2>\n<p><img alt=\"Qwen3-0.6B\" class=\"lazyload\" /></p>\n<h2 id=\"特性\">特性</h2>\n<ul>\n<li>📖 <strong>可读代码库</strong> - 核心约2428行Python代码的清晰实现</li>\n<li>⚡ <strong>优化套件</strong> - 张量并行、torchair Ascend IR图编译和图缓存、融合算子、前缀缓存等</li>\n</ul>\n<ul>\n<li>[✅] 待完成：目前只支持单算子, npu图模式实现</li>\n<li>[✅] 支持CPU环境运行：<a href=\"https://github.com/linzm1007/nano-vllm-cpu\" rel=\"noopener nofollow\" target=\"_blank\">nano-vllm-cpu 代码仓库</a></li>\n<li>[✅] 性能优化</li>\n<li>[⏳] 支持模型: Qwen3-0.6B、Qwen3-32B、Qwen2-0.5B、Qwen2.5-0.5B、Qwen2.5-0.5B-Instruct、Llama-3.2-1B-Instruct、Qwen3-30B-A3B、Qwen3-VL-2B-Instruct、MiniCPM4-0.5B</li>\n<li>[✅] 支持一个moe模型:Qwen3-30B-A3B(暂时不支持入图)</li>\n<li>[📅] 支持一个omni模型</li>\n<li>[✅] 支持一个vl模型:Qwen3-VL-2B-Instruct(暂时不支持入图)</li>\n<li>[✅] 实现page attention</li>\n<li>[📅] 实现一个自定义算子</li>\n<li>[📅] 支持在线推理</li>\n</ul>\n<p>torchair接口参考 <a href=\"https://www.hiascend.com/document/detail/zh/Pytorch/710/modthirdparty/torchairuseguide/torchair_00008.html\" rel=\"noopener nofollow\" target=\"_blank\">https://www.hiascend.com/document/detail/zh/Pytorch/710/modthirdparty/torchairuseguide/torchair_00008.html</a><br />\n融合算子接口参考 <a href=\"https://www.hiascend.com/document/detail/zh/Pytorch/720/apiref/torchnpuCustomsapi/context/torch_npu-npu_fused_infer_attention_score_v2.md\" rel=\"noopener nofollow\" target=\"_blank\">https://www.hiascend.com/document/detail/zh/Pytorch/720/apiref/torchnpuCustomsapi/context/torch_npu-npu_fused_infer_attention_score_v2.md</a><br />\nattention实现参考 <a href=\"https://gitee.com/omniai/omniinfer/blob/master/omni/layers/attention/backend/attention.py\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/omniai/omniinfer/blob/master/omni/layers/attention/backend/attention.py</a>  forward_vanilla函数</p>\n<h2 id=\"支持的模型\">支持的模型</h2>\n<table>\n<thead>\n<tr>\n<th>架构</th>\n<th>模型</th>\n<th>示例 HF 模型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Qwen3ForCausalLM</td>\n<td>Qwen3-0.6B,Qwen3-32B</td>\n<td></td>\n</tr>\n<tr>\n<td>Qwen2ForCausalLM</td>\n<td>Qwen2-0.5B</td>\n<td></td>\n</tr>\n<tr>\n<td>LlamaForCausalLM</td>\n<td>Llama-3.2-1B-Instruct</td>\n<td></td>\n</tr>\n<tr>\n<td>Qwen3MoeForCausalLM</td>\n<td>Qwen3-30B-A3B</td>\n<td></td>\n</tr>\n<tr>\n<td>Qwen3VLForConditionalGeneration</td>\n<td>Qwen2.5-VL-3B-Instruct</td>\n<td></td>\n</tr>\n<tr>\n<td>MiniCPMForCausalLM</td>\n<td>MiniCPM4-0.5B</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"代码行数\">代码行数</h2>\n<p>📊 总体数据</p>\n<table>\n<thead>\n<tr>\n<th>范围</th>\n<th>文件数</th>\n<th>总行数</th>\n<th>占比</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>nanovllm 全部</td>\n<td>20 个</td>\n<td>4,652 行</td>\n<td>100%</td>\n</tr>\n<tr>\n<td>models 目录</td>\n<td>5 个</td>\n<td>2,224 行</td>\n<td>47.8%</td>\n</tr>\n<tr>\n<td>除 models 外</td>\n<td>15 个</td>\n<td>2,428 行</td>\n<td>52.2%</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"推理优化技术大纲\">推理优化技术大纲</h2>\n<p>📚 <strong>完整技术文档</strong>：<a href=\"https://github.com/linzm1007/nano-vllm-ascend/blob/main/docs/inference_optimization_guide.md\" rel=\"noopener nofollow\" target=\"_blank\">LLM 推理优化技术大纲</a></p>\n<p>本文档整理了 LLM 推理领域的 <strong>20 大类关键技术</strong>，分为 7 个层次：</p>\n<h3 id=\"-核心技术基础必备\">🔥 核心技术（基础必备）</h3>\n<ul>\n<li><strong>KV Cache 管理</strong>：PageAttention、Prefix Caching、KV Cache 压缩</li>\n<li><strong>Attention 优化</strong>：FlashAttention、GQA/MQA、稀疏注意力</li>\n<li><strong>批处理策略</strong>：Continuous Batching、Dynamic Batching</li>\n</ul>\n<h3 id=\"-性能优化进阶\">🚀 性能优化（进阶）</h3>\n<ul>\n<li><strong>量化技术</strong>：INT8/INT4/FP8、AWQ、GPTQ、GGUF</li>\n<li><strong>投机采样</strong>：Speculative Decoding、Medusa、Lookahead</li>\n<li><strong>解码优化</strong>：Parallel Decoding、Token Tree Verification</li>\n</ul>\n<h3 id=\"️-系统架构\">🏗️ 系统架构</h3>\n<ul>\n<li><strong>调度策略</strong>：FCFS、SJF、Priority-based、Preemption</li>\n<li><strong>内存优化</strong>：Memory Pool、Swapping、Offloading</li>\n<li><strong>并行策略</strong>：Tensor/Pipeline/Expert/Sequence Parallelism</li>\n</ul>\n<h3 id=\"-特殊场景\">🧠 特殊场景</h3>\n<ul>\n<li><strong>长上下文</strong>：RoPE Scaling、StreamingLLM、Ring Attention</li>\n<li><strong>多模态</strong>：Vision-Language、Audio-Language、Unified Architecture</li>\n<li><strong>MoE 优化</strong>：Expert Routing、Load Balancing、All-to-All 通信</li>\n</ul>\n<h3 id=\"-底层优化\">⚡ 底层优化</h3>\n<ul>\n<li><strong>图编译</strong>：TorchAir、TensorRT-LLM、Torch.compile</li>\n<li><strong>算子融合</strong>：QKV Fusion、Custom CUDA/Triton Kernels</li>\n<li><strong>通信优化</strong>：NCCL/HCCL、RDMA、GPUDirect</li>\n</ul>\n<h3 id=\"-评估观测\">📊 评估观测</h3>\n<ul>\n<li><strong>性能分析</strong>：Memory/Compute Profiling、Roofline Analysis</li>\n<li><strong>关键指标</strong>：TTFT、TPOT、Throughput、GPU Utilization</li>\n</ul>\n<h3 id=\"-前沿趋势\">🔮 前沿趋势</h3>\n<ul>\n<li><strong>模型架构</strong>：Mamba/RWKV、Mixture of Depths、RetNet</li>\n<li><strong>服务化</strong>：Disaggregated Serving、Elastic Scaling</li>\n<li><strong>新兴方向</strong>：推理蒸馏、Early Exit、Hardware-Aware NAS</li>\n</ul>\n<hr />\n<h2 id=\"attention\">Attention</h2>\n<h3 id=\"pageattention\">PageAttention</h3>\n<p><strong>PageAttention</strong> 是 vLLM 的核心创新技术，灵感来自操作系统的<strong>虚拟内存分页机制</strong>，用于高效管理 LLM 推理中的 KV Cache。</p>\n<h4 id=\"核心概念\">核心概念</h4>\n<p>传统 KV Cache 分配方式会为每个序列预分配最大可能长度的连续内存，导致严重的内存浪费和碎片。PageAttention 借鉴操作系统分页思想，将 KV Cache 划分为固定大小的 block，按需动态分配。</p>\n<h4 id=\"关键技术点\">关键技术点</h4>\n<table>\n<thead>\n<tr>\n<th>技术</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Block 管理</strong></td>\n<td>将 KV Cache 划分为固定大小的 block（如 16/32 tokens），每个 block 独立分配</td>\n</tr>\n<tr>\n<td><strong>Block Table</strong></td>\n<td>类似页表的数据结构，记录逻辑 token 位置到物理 block 的映射关系</td>\n</tr>\n<tr>\n<td><strong>非连续存储</strong></td>\n<td>同一序列的 KV Cache 可以分散在多个不连续的 block 中</td>\n</tr>\n<tr>\n<td><strong>内存共享</strong></td>\n<td>并行解码（如 beam search）时可共享 prompt 的 KV cache</td>\n</tr>\n<tr>\n<td><strong>Copy-on-Write</strong></td>\n<td>写时复制机制，仅在需要修改时才复制 block</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"内存使用对比\">内存使用对比</h4>\n<pre><code>传统方式：\n- 序列长度 1000，最大支持 4096\n- 内存占用：4096 * hidden_size\n- 浪费率：约 75%\n\nPageAttention：\n- 序列长度 1000，block_size=16\n- 需要 block：1000/16 = 63 个\n- 实际分配：63 * 16 = 1008 tokens\n- 浪费率：仅 0.8%\n</code></pre>\n<h4 id=\"代码实现\">代码实现</h4>\n<pre><code class=\"language-python\"># nanovllm/layers/attention.py\n# Block Table 映射\nblock_table = context.block_tables  # 映射表\n\n# Slot Mapping - 将 token 映射到 block 中的具体位置\n# slot_mapping 格式：[block_idx, offset_in_block]\ncontext.slot_mapping\n\n# 分页存储 KV Cache\ntorch_npu._npu_reshape_and_cache(\n    k, v,\n    k_cache.view(num_blocks, block_size, num_kv_heads, head_dim),\n    v_cache.view(num_blocks, block_size, num_kv_heads, head_dim),\n    slot_mapping.int()\n)\n</code></pre>\n<h4 id=\"优势\">优势</h4>\n<ol>\n<li><strong>内存效率</strong>：按需分配，无内部碎片</li>\n<li><strong>动态扩展</strong>：序列增长时只需分配新 block</li>\n<li><strong>内存共享</strong>：多个序列可共享相同的 prompt KV Cache</li>\n<li><strong>高吞吐量</strong>：支持更大的 batch size</li>\n</ol>\n<h4 id=\"详细对比\">详细对比</h4>\n<p>📄 <strong>详细技术文档</strong>：<a href=\"https://github.com/linzm1007/nano-vllm-ascend/blob/main/docs/pageattention_comparison.md\" rel=\"noopener nofollow\" target=\"_blank\">HuggingFace Transformers 早期实现与 PageAttention 对比</a></p>\n<p>包含：</p>\n<ul>\n<li>早期 Transformers 代码实现分析</li>\n<li>内存浪费的量化对比（75% vs 6.25%）</li>\n<li>不同 batch size 和序列长度的详细对比表</li>\n<li>vLLM 论文数据来源说明</li>\n<li>实际代码示例和场景分析</li>\n</ul>\n<hr />\n<h3 id=\"flashattention\">FlashAttention</h3>\n<p><strong>FlashAttention</strong> 是斯坦福大学提出的 <strong>IO 感知</strong> 注意力优化算法，通过分块计算和减少 HBM（高带宽内存）访问来提升性能。</p>\n<h4 id=\"核心问题\">核心问题</h4>\n<p>标准 Attention 实现需要存储中间结果（注意力矩阵）到 HBM，导致：</p>\n<ul>\n<li><strong>内存瓶颈</strong>：HBM 带宽远低于计算速度</li>\n<li><strong>O(N²) 内存</strong>：序列长度的平方级内存增长</li>\n<li><strong>多次数据搬运</strong>：Q、K、V 需要多次读写 HBM</li>\n</ul>\n<h4 id=\"核心创新\">核心创新</h4>\n<table>\n<thead>\n<tr>\n<th>技术</th>\n<th>原理</th>\n<th>效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Tiling（分块）</strong></td>\n<td>将 Q、K、V 分块加载到高速 SRAM</td>\n<td>减少 HBM 访问次数</td>\n</tr>\n<tr>\n<td><strong>Online Softmax</strong></td>\n<td>流式计算 softmax，无需完整注意力矩阵</td>\n<td>内存降至 O(N)</td>\n</tr>\n<tr>\n<td><strong>Recomputation</strong></td>\n<td>反向传播时重新计算中间值</td>\n<td>牺牲计算换内存</td>\n</tr>\n<tr>\n<td><strong>Kernel Fusion</strong></td>\n<td>多个操作融合为单个 CUDA kernel</td>\n<td>减少 kernel 启动开销</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"内存层次结构对比\">内存层次结构对比</h4>\n<pre><code>GPU 内存层次：\n┌─────────────────────────────────────┐\n│  HBM (High Bandwidth Memory)        │  ← 1.5 TB/s，容量大但速度慢\n│  - 容量：40-80 GB                   │  ← 标准 Attention 在此频繁读写\n│  - 延迟：高                         │\n├─────────────────────────────────────┤\n│  SRAM (Static RAM / Shared Memory)  │  ← 19 TB/s，容量小但速度快\n│  - 容量：~100 KB per SM             │  ← FlashAttention 主要在此计算\n│  - 延迟：极低                       │\n└─────────────────────────────────────┘\n</code></pre>\n<h4 id=\"计算流程对比\">计算流程对比</h4>\n<p><strong>标准 Attention：</strong></p>\n<pre><code>1. 从 HBM 加载 Q, K, V\n2. 计算 S = QK^T → 写入 HBM\n3. 计算 P = softmax(S) → 写入 HBM  \n4. 计算 O = PV → 写入 HBM\n❌ 多次 HBM 读写，内存占用 O(N²)\n</code></pre>\n<p><strong>FlashAttention：</strong></p>\n<pre><code>1. 分块加载 Qᵢ, Kⱼ, Vⱼ 到 SRAM\n2. 在 SRAM 中计算 softmax\n3. 累加结果到输出\n4. 丢弃中间结果，重复直到完成\n✅ 仅需 O(N) 内存，大幅减少 HBM 访问\n</code></pre>\n<h4 id=\"代码实现-1\">代码实现</h4>\n<pre><code class=\"language-python\"># nanovllm/layers/attention_ori.py\nfrom flash_attn import (\n    flash_attn_varlen_func,      # Prefill 阶段\n    flash_attn_with_kvcache      # Decode 阶段\n)\n\n# Prefill - 处理变长序列，支持 PageAttention\nflash_attn_varlen_func(\n    q, k, v,\n    max_seqlen_q=max_seqlen_q,\n    cu_seqlens_q=cu_seqlens_q,    # 累计长度支持变长\n    causal=True,                  # 因果掩码\n    block_table=block_table       # PageAttention block table\n)\n\n# Decode - 单 token 推理，复用分页 KV Cache\nflash_attn_with_kvcache(\n    q.unsqueeze(1),               # [batch, 1, num_heads, head_dim]\n    k_cache, v_cache,             # 分页 KV 缓存\n    cache_seqlens=context_lens,   # 实际序列长度\n    block_table=block_table       # block table 映射\n)\n</code></pre>\n<h4 id=\"性能收益\">性能收益</h4>\n<ul>\n<li><strong>内存效率</strong>：从 O(N²) 降至 O(N)</li>\n<li><strong>计算速度</strong>：A100 上可达 <strong>2-4 倍</strong>加速</li>\n<li><strong>序列长度</strong>：支持更长的上下文（如 100K+ tokens）</li>\n</ul>\n<hr />\n<h3 id=\"三种-attention-实现对比\">三种 Attention 实现对比</h3>\n<p>本项目包含三种 Attention 实现，适用于不同场景：</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>attention_ori.py</th>\n<th>attention.py</th>\n<th>attention_torch_native.py</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>底层实现</strong></td>\n<td>Flash Attention 库</td>\n<td>NPU 原生算子</td>\n<td>PyTorch 原生</td>\n</tr>\n<tr>\n<td><strong>适用平台</strong></td>\n<td>CUDA GPU</td>\n<td>华为昇腾 NPU</td>\n<td>通用（CPU/GPU）</td>\n</tr>\n<tr>\n<td><strong>性能</strong></td>\n<td>⭐⭐⭐⭐⭐</td>\n<td>⭐⭐⭐⭐⭐</td>\n<td>⭐⭐</td>\n</tr>\n<tr>\n<td><strong>可读性</strong></td>\n<td>⭐⭐</td>\n<td>⭐⭐</td>\n<td>⭐⭐⭐⭐⭐</td>\n</tr>\n<tr>\n<td><strong>用途</strong></td>\n<td>生产环境（GPU）</td>\n<td>生产环境（NPU）</td>\n<td>学习调试</td>\n</tr>\n</tbody>\n</table>\n<p><strong>选择建议：</strong></p>\n<ul>\n<li><strong>生产环境（GPU）</strong>：使用 <code>attention_ori.py</code>（Flash Attention）</li>\n<li><strong>生产环境（昇腾 NPU）</strong>：使用 <code>attention.py</code>（NPU 算子）</li>\n<li><strong>学习/调试</strong>：使用 <code>attention_torch_native.py</code>（易于理解）</li>\n</ul>\n<h2 id=\"文档索引\">文档索引</h2>\n<p>本目录包含项目各模块的详细流程图文档，使用 Mermaid 语法绘制。</p>\n<h3 id=\"engine-模块流程图\">Engine 模块流程图</h3>\n<table>\n<thead>\n<tr>\n<th>文档</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://github.com/linzm1007/nano-vllm-ascend/blob/main/docs/engine/sequence_flowchart.md\" rel=\"noopener nofollow\" target=\"_blank\">docs/engine/sequence_flowchart.md</a></td>\n<td>Sequence 序列状态管理流程</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/linzm1007/nano-vllm-ascend/blob/main/docs/engine/block_manager_flowchart.md\" rel=\"noopener nofollow\" target=\"_blank\">docs/engine/block_manager_flowchart.md</a></td>\n<td>BlockManager KV缓存块管理流程</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/linzm1007/nano-vllm-ascend/blob/main/docs/engine/scheduler_flowchart.md\" rel=\"noopener nofollow\" target=\"_blank\">docs/engine/scheduler_flowchart.md</a></td>\n<td>Scheduler 调度器流程</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/linzm1007/nano-vllm-ascend/blob/main/docs/engine/model_runner_flowchart.md\" rel=\"noopener nofollow\" target=\"_blank\">docs/engine/model_runner_flowchart.md</a></td>\n<td>ModelRunner 模型运行器流程</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/linzm1007/nano-vllm-ascend/blob/main/docs/engine/llm_engine_flowchart.md\" rel=\"noopener nofollow\" target=\"_blank\">docs/engine/llm_engine_flowchart.md</a></td>\n<td>LLMEngine 主引擎流程</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"layers-模块流程图\">Layers 模块流程图</h3>\n<table>\n<thead>\n<tr>\n<th>文档</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://github.com/linzm1007/nano-vllm-ascend/blob/main/docs/layers/linear_flowchart.md\" rel=\"noopener nofollow\" target=\"_blank\">docs/layers/linear_flowchart.md</a></td>\n<td>线性层与张量并行策略</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/linzm1007/nano-vllm-ascend/blob/main/docs/layers/attention_torch_native_flowchart.md\" rel=\"noopener nofollow\" target=\"_blank\">docs/layers/attention_torch_native_flowchart.md</a></td>\n<td>PyTorch原生Attention实现</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/linzm1007/nano-vllm-ascend/blob/main/docs/layers/attention_flowchart.md\" rel=\"noopener nofollow\" target=\"_blank\">docs/layers/attention_flowchart.md</a></td>\n<td>NPU专用Attention实现</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/linzm1007/nano-vllm-ascend/blob/main/docs/layers/attention_ori_flowchart.md\" rel=\"noopener nofollow\" target=\"_blank\">docs/layers/attention_ori_flowchart.md</a></td>\n<td>Flash Attention优化实现</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/linzm1007/nano-vllm-ascend/blob/main/docs/layers/sampler_flowchart.md\" rel=\"noopener nofollow\" target=\"_blank\">docs/layers/sampler_flowchart.md</a></td>\n<td>采样器（温度采样）</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/linzm1007/nano-vllm-ascend/blob/main/docs/layers/rotary_embedding_flowchart.md\" rel=\"noopener nofollow\" target=\"_blank\">docs/layers/rotary_embedding_flowchart.md</a></td>\n<td>RoPE位置编码</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/linzm1007/nano-vllm-ascend/blob/main/docs/layers/layernorm_flowchart.md\" rel=\"noopener nofollow\" target=\"_blank\">docs/layers/layernorm_flowchart.md</a></td>\n<td>RMSNorm归一化层</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/linzm1007/nano-vllm-ascend/blob/main/docs/layers/embed_head_flowchart.md\" rel=\"noopener nofollow\" target=\"_blank\">docs/layers/embed_head_flowchart.md</a></td>\n<td>词嵌入与LM Head</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/linzm1007/nano-vllm-ascend/blob/main/docs/layers/activation_flowchart.md\" rel=\"noopener nofollow\" target=\"_blank\">docs/layers/activation_flowchart.md</a></td>\n<td>SwiGLU激活函数</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"models-模块流程图\">Models 模块流程图</h3>\n<table>\n<thead>\n<tr>\n<th>文档</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://github.com/linzm1007/nano-vllm-ascend/blob/main/docs/models/llama_flowchart.md\" rel=\"noopener nofollow\" target=\"_blank\">docs/models/llama_flowchart.md</a></td>\n<td>Llama模型架构</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/linzm1007/nano-vllm-ascend/blob/main/docs/models/qwen3_flowchart.md\" rel=\"noopener nofollow\" target=\"_blank\">docs/models/qwen3_flowchart.md</a></td>\n<td>Qwen3模型架构</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/linzm1007/nano-vllm-ascend/blob/main/docs/models/qwen3_vl_flowchart.md\" rel=\"noopener nofollow\" target=\"_blank\">docs/models/qwen3_vl_flowchart.md</a></td>\n<td>Qwen3-VL多模态模型架构</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/linzm1007/nano-vllm-ascend/blob/main/docs/models/qwen3_moe_flowchart.md\" rel=\"noopener nofollow\" target=\"_blank\">docs/models/qwen3_moe_flowchart.md</a></td>\n<td>Qwen3-MoE稀疏专家模型架构</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/linzm1007/nano-vllm-ascend/blob/main/docs/models/mini_cpm4_flowchart.md\" rel=\"noopener nofollow\" target=\"_blank\">docs/models/mini_cpm4_flowchart.md</a></td>\n<td>MiniCPM4模型架构</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/linzm1007/nano-vllm-ascend/blob/main/docs/models/models_map_flowchart.md\" rel=\"noopener nofollow\" target=\"_blank\">docs/models/models_map_flowchart.md</a></td>\n<td>模型注册映射关系</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h2 id=\"bench数据\">bench数据</h2>\n<p>仅供参考，硬软条件不同，跑出的数据也会有差异</p>\n<h4 id=\"不同模型对比\">不同模型对比</h4>\n<table>\n<thead>\n<tr>\n<th>model</th>\n<th>Output Tokens</th>\n<th>Time (s)</th>\n<th>Throughput (tokens/s)</th>\n<th>TP</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Qwen3-0.6B</td>\n<td>143,770</td>\n<td>36.82</td>\n<td>3904.20</td>\n<td>1</td>\n</tr>\n<tr>\n<td>Qwen2-0.5B</td>\n<td>143,770</td>\n<td>20.71</td>\n<td>6940.84</td>\n<td>1</td>\n</tr>\n<tr>\n<td>Qwen2.5-0.5B-Instruct</td>\n<td>143,770</td>\n<td>19.82</td>\n<td>7252.67</td>\n<td>1</td>\n</tr>\n<tr>\n<td>Llama-3.2-1B-Instruct</td>\n<td>143,770</td>\n<td>25.45</td>\n<td>5648.50</td>\n<td>1</td>\n</tr>\n<tr>\n<td>Qwen3-32B</td>\n<td>143,770</td>\n<td>206.69</td>\n<td>695.59</td>\n<td>2</td>\n</tr>\n<tr>\n<td>Qwen3-32B</td>\n<td>143,770</td>\n<td>119.86</td>\n<td>1199.50</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"其他框架对比2025-12-30\">其他框架对比(2025-12-30)</h4>\n<p>vLLM Nano-vLLM 数据来源 <a href=\"https://github.com/GeeeekExplorer/nano-vllm\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/GeeeekExplorer/nano-vllm</a></p>\n<table>\n<thead>\n<tr>\n<th>Inference Engine</th>\n<th>Output Tokens</th>\n<th>Time (s)</th>\n<th>Throughput (tokens/s)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>vLLM</td>\n<td>133,966</td>\n<td>98.37</td>\n<td>1361.84</td>\n</tr>\n<tr>\n<td>Nano-vLLM</td>\n<td>133,966</td>\n<td>93.41</td>\n<td>1434.13</td>\n</tr>\n<tr>\n<td>Nano-vLLM-Ascend python torch原生实现</td>\n<td>4805</td>\n<td>257.49</td>\n<td>18.66</td>\n</tr>\n<tr>\n<td>Nano-vLLM-Ascend 融合算子+图编译bs=256</td>\n<td>133,966</td>\n<td>33.88</td>\n<td>3954.20</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"图模式不同bs对比2025-12-30\">图模式不同bs对比(2025-12-30)</h4>\n<table>\n<thead>\n<tr>\n<th>Batch Size</th>\n<th>Output Tokens</th>\n<th>Time (s)</th>\n<th>Throughput (tokens/s)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bs=16</td>\n<td>133,966</td>\n<td>107.23</td>\n<td>1249.37</td>\n</tr>\n<tr>\n<td>bs=32</td>\n<td>133,966</td>\n<td>75.89</td>\n<td>1765.35</td>\n</tr>\n<tr>\n<td>bs=48</td>\n<td>133,966</td>\n<td>64.84</td>\n<td>2066.22</td>\n</tr>\n<tr>\n<td>bs=64</td>\n<td>133,966</td>\n<td>54.06</td>\n<td>2478.31</td>\n</tr>\n<tr>\n<td>bs=128</td>\n<td>133,966</td>\n<td>43.08</td>\n<td>3109.56</td>\n</tr>\n<tr>\n<td>bs=256</td>\n<td>133,966</td>\n<td>33.88</td>\n<td>3954.20</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"单算子padding和non-padding对比2025-12-30\">单算子Padding和Non-padding对比(2025-12-30)</h4>\n<p>bs=256</p>\n<table>\n<thead>\n<tr>\n<th>Prepare Strategy</th>\n<th>Output Tokens</th>\n<th>Time (s)</th>\n<th>Throughput (tokens/s)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Padding</td>\n<td>133,966</td>\n<td>158.46</td>\n<td>845.41</td>\n</tr>\n<tr>\n<td>Non-padding</td>\n<td>133,966</td>\n<td>152.14</td>\n<td>880.55</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"环境搭建参考vllm-ascend\">环境搭建（参考vllm-ascend）</h2>\n<p><a href=\"https://docs.vllm.ai/projects/vllm-ascend-cn/zh-cn/latest/quick_start.html\" rel=\"noopener nofollow\" target=\"_blank\">https://docs.vllm.ai/projects/vllm-ascend-cn/zh-cn/latest/quick_start.html</a></p>\n<p>ubuntu</p>\n<pre><code># Update DEVICE according to your device (/dev/davinci[0-7])\nexport DEVICE=/dev/davinci0\n# Update the vllm-ascend image\n# Atlas A2:\n# export IMAGE=quay.io/ascend/vllm-ascend:v0.14.0rc1\n# Atlas A3:\n# export IMAGE=quay.io/ascend/vllm-ascend:v0.14.0rc1-a3\nexport IMAGE=quay.io/ascend/vllm-ascend:v0.14.0rc1\ndocker run --rm \\\n--name vllm-ascend \\\n--shm-size=1g \\\n--device $DEVICE \\\n--device /dev/davinci_manager \\\n--device /dev/devmm_svm \\\n--device /dev/hisi_hdc \\\n-v /usr/local/dcmi:/usr/local/dcmi \\\n-v /usr/local/bin/npu-smi:/usr/local/bin/npu-smi \\\n-v /usr/local/Ascend/driver/lib64/:/usr/local/Ascend/driver/lib64/ \\\n-v /usr/local/Ascend/driver/version.info:/usr/local/Ascend/driver/version.info \\\n-v /etc/ascend_install.info:/etc/ascend_install.info \\\n-v /root/.cache:/root/.cache \\\n-p 8000:8000 \\\n-it $IMAGE bash\n# Install curl\napt-get update -y &amp;&amp; apt-get install -y curl\n</code></pre>\n<h2 id=\"安装依赖\">安装依赖</h2>\n<pre><code class=\"language-bash\">pip install .\n</code></pre>\n<h2 id=\"模型下载\">模型下载</h2>\n<pre><code class=\"language-bash\">huggingface-cli download --resume-download Qwen/Qwen3-0.6B \\\n  --local-dir ~/huggingface/Qwen3-0.6B/ \\\n  --local-dir-use-symlinks False\n</code></pre>\n<h2 id=\"快速开始\">快速开始</h2>\n<p>请参见 example.py 了解用法。该 API 与 vLLM 的接口基本一致，仅在 LLM.generate 方法上存在一些细微差异：</p>\n<pre><code class=\"language-python\">from nanovllm import LLM, SamplingParams\nllm = LLM(\"/YOUR/MODEL/PATH\", enforce_eager=True, tensor_parallel_size=1)\nsampling_params = SamplingParams(temperature=0.6, max_tokens=256)\nprompts = [\"Hello, Nano-vLLM.\"]\noutputs = llm.generate(prompts, sampling_params)\noutputs[0][\"text\"]\n</code></pre>\n<h2 id=\"example运行结果\">example运行结果</h2>\n<p><img alt=\"result-image\" class=\"lazyload\" /></p>\n<h2 id=\"bench环境\">bench环境</h2>\n<p>仅供参考<br />\nascend-dmi -c #查看</p>\n<ul>\n<li>硬件环境​：\n<ul>\n<li>1.显卡:A3 910C</li>\n<li>2.驱动版本:24.1.rc3.10</li>\n<li>3.固件版本:7.5.0.109.220</li>\n</ul>\n</li>\n<li>​软件环境​：\n<ul>\n<li>1.CANN包 8.3.RC1</li>\n<li>2.PTA版本：torch-npu 2.5.1.post2+gitd7a85f8，torch 2.5.1</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"benchmark\">Benchmark</h2>\n<p>See <code>bench.py</code> for benchmark.</p>\n<p><strong>Test Configuration:</strong></p>\n<ul>\n<li>Model: Qwen3-0.6B</li>\n<li>Total Requests: 256 sequences</li>\n<li>Input Length: Randomly sampled between 100–1024 tokens</li>\n<li>Output Length: Randomly sampled between 100–1024 tokens</li>\n</ul>\n<p><strong>Performance Results:</strong><br />\nNano-vLLM-Ascend 实在太慢了只跑了10条seq</p>\n<table>\n<thead>\n<tr>\n<th>Inference Engine</th>\n<th>Output Tokens</th>\n<th>Time (s)</th>\n<th>Throughput (tokens/s)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>vLLM</td>\n<td>133,966</td>\n<td>98.37</td>\n<td>1361.84</td>\n</tr>\n<tr>\n<td>Nano-vLLM</td>\n<td>133,966</td>\n<td>93.41</td>\n<td>1434.13</td>\n</tr>\n<tr>\n<td>Nano-vLLM-Ascend</td>\n<td>4805</td>\n<td>257.49</td>\n<td>18.66</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"qwen3-06b-layers\">qwen3-0.6B layers</h2>\n<pre><code class=\"language-angular2html\">ModuleList(\n  (0-27): 28 x Qwen3DecoderLayer(\n    (self_attn): Qwen3Attention(\n      (qkv_proj): QKVParallelLinear()\n      (o_proj): RowParallelLinear()\n      (rotary_emb): RotaryEmbedding()\n      (attn): Attention()\n      (q_norm): RMSNorm()\n      (k_norm): RMSNorm()\n    )\n    (mlp): Qwen3MLP(\n      (gate_up_proj): MergedColumnParallelLinear()\n      (down_proj): RowParallelLinear()\n      (act_fn): SiluAndMul()\n    )\n    (input_layernorm): RMSNorm()\n    (post_attention_layernorm): RMSNorm()\n  )\n)\n\n</code></pre>\n\n\n</div>\n<div id=\"MySignature\">\n    蓝天和白云是标配。\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-13 11:38</span>&nbsp;\n<a href=\"https://www.cnblogs.com/linzm14\">linzm14</a>&nbsp;\n阅读(<span id=\"post_view_count\">10</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "AI × 博客园皮肤",
      "link": "https://www.cnblogs.com/guangzan/p/19609096",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/guangzan/p/19609096\" id=\"cb_post_title_url\" title=\"发布于 2026-02-13 10:56\">\n    <span>AI × 博客园皮肤</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"1-前言\">1. 前言</h2>\n<p>博客园自 2004 年上线以来，凭借着简洁的界面、浓厚的技术氛围成为了国内程序员的核心创作平台之一，而皮肤定制则是博客园用户个性化表达的重要方式。从早期的纯 CSS 样式修改，到后来的 JS 脚本增强，博客园皮肤开发的需求不断升级，但平台的原生开发模式却始终没有跟上前端技术的发展步伐。</p>\n<p>在前端工程化、现代化框架（React/Vue）、实用型 CSS 框架（Tailwind CSS）成为行业主流，且 AI 大模型深度融入前端开发的今天，博客园原生的“浏览器端修改 CSS/JS 片段”的开发模式显得格格不入：用户只能在浏览器中检查元素、修改样式，没有热模块替换（HMR）、没有类型校验、没有打包优化、没有模块化，无法享受现代前端便利。更让 AI 大模型无法有效接入——AI 难以读取博客园的原生模板。</p>\n<p>正是在这样的背景下，我创建了 <strong>Tona</strong>。Tona 是基于 Monorepo 架构打造的一套完整的博客园皮肤开发工具链。本文将从技术底层到实战应用，全面介绍 Tona 的设计与实现，并结合 AI 大模型的能力，打造一套 <strong>AI × Tona × 博客园皮肤</strong>的现代化开发范式，让每一位开发者都能快速开发出高质量、可维护、个性化的博客园皮肤，同时享受 AI 协作开发的高效与便捷。</p>\n<h2 id=\"2-博客园皮肤开发的痛点\">2. 博客园皮肤开发的痛点</h2>\n<p>博客园为用户提供了<strong>页面定制 CSS</strong>、<strong>博客侧边栏公告</strong>、<strong>页脚 HTML 代码</strong>、<strong>自定义 JS 脚本</strong>等入口，允许用户通过编写 CSS/JS/HTML 片段实现皮肤定制，但这种开发模式存在六大核心痛点，严重制约了开发效率和皮肤质量：</p>\n<p><strong>（1）开发环境简陋，无现代化前端工程化能力</strong></p>\n<p>博客园的皮肤开发完全依赖<strong>浏览器端</strong>：开发者需要先在博客园后台编辑代码，保存后刷新页面查看效果，没有<strong>热更新（HMR）</strong> 能力，修改一行样式需要等待页面重新加载；没有打包工具，无法对 JS/CSS 进行压缩、树摇、按需加载；没有模块系统，无法使用 ES6+的<code>import/export</code>，只能通过全局变量实现代码复用，代码冗余且难以维护。</p>\n<p><strong>（2）调试难度大，无完整的调试工具链</strong></p>\n<p>博客园的原生代码运行在平台的全局环境中，开发者只能通过浏览器的开发者工具进行简单的元素检查和断点调试，无法使用 Vite、Webpack 等工具的调试能力，也无法对代码进行单元测试、集成测试；同时，博客园的原生 HTML 模板不可修改，开发者需要在已有 DOM 结构上进行样式覆盖和 JS 操作，DOM 结构的不确定性进一步增加了调试难度。</p>\n<p><strong>（3）技术栈受限，无法使用现代化前端框架与工具</strong></p>\n<p>博客园原生开发仅支持原生 CSS/JS/HTML，无法直接使用 React/React/Vue 等现代化前端框架，也无法使用 Tailwind CSS、UnoCSS 等实用型 CSS 框架；即使开发者通过手动引入框架 CDN 包实现了部分功能，也会面临全局变量冲突、打包体积过大、性能不佳等问题，无法发挥现代化工具的真正价值。</p>\n<p><strong>（4）代码可维护性差，无模块化与类型安全</strong></p>\n<p>由于没有模块系统和类型校验，博客园皮肤的代码往往是“面条式代码”：CSS 样式相互覆盖，JS 函数全局挂载，HTML 片段零散分布；没有 TypeScript 的类型校验，开发者在编写代码时容易出现语法错误、变量名错误等问题，且错误只能在运行时发现，开发效率极低。</p>\n<p><strong>（5）团队协作困难，无标准化的开发流程</strong></p>\n<p>博客园皮肤的开发以个人为主，没有标准化的项目结构、代码规范、提交规范；代码保存在博客园后台，无法通过 Git 进行版本管理，也无法进行团队协作开发；同时，没有 Lint 工具、Prettier 工具的代码格式化能力，不同开发者的代码风格差异大，代码合并与维护困难。</p>\n<p><strong>（6）AI 难以接入，无法享受 AI 大模型的开发红利</strong></p>\n<p>这是新时代博客园皮肤开发的核心痛点之一。AI 大模型的有效开发需要<strong>标准化的项目结构</strong>、<strong>可访问的代码文件</strong>、<strong>清晰的技术规范</strong>，而博客园原生开发的代码仅存在于博客园后台的零散片段中，AI 无法读取博客园的原生 HTML 模板、无法理解代码的上下文、无法生成符合规范的模块化代码，更无法参与工程化的开发流程，让开发者错失 AI 开发的红利。</p>\n<h2 id=\"3-tona架构技术栈与工程化流水线\">3. Tona：架构、技术栈与工程化流水线</h2>\n<h3 id=\"31-博客园皮肤开发的现代化解决方案\">3.1 博客园皮肤开发的现代化解决方案</h3>\n<div class=\"mermaid\">flowchart TD\n    A[传统 CNBlogs 开发] --&gt; B[浏览器检查元素]\n    B --&gt; C[手动修改 CSS/JS]\n    C --&gt; D[上传设置界面测试]\n    D --&gt; E[重复调试，效率低]\n\n    F[Tona 开发] --&gt; G[pnpm create tona 初始化]\n    G --&gt; H[Vite 本地服务器 + 模板注入]\n    H --&gt; I[热更新 + AI 生成代码]\n    I --&gt; J[构建打包 + 部署]\n\n    subgraph 解决方案\n    F --&gt; J\n    end\n\n    subgraph 痛点\n    A --&gt; E\n    end\n</div><p>Tona 核心定位是博客园专属的模块化皮肤开发工具链，其设计初衷就是解决上述博客园原生开发的所有痛点。Tona 基于 Monorepo 架构打造了一套完整的皮肤开发工具链，包含可复用的核心包、预构建的皮肤、可扩展的插件系统，同时深度整合 Vite 生态，实现了博客园皮肤的本地开发、工程化构建、标准化部署。</p>\n<p>Tona 的核心解决方案可以总结为以下五点：</p>\n<ol>\n<li><strong>本地开发环境搭建</strong>：通过<code>tona-vite</code>插件将博客园的原生 HTML 模板注入 Vite Dev Server 中，让开发者可以在本地脱离博客园环境进行皮肤开发，享受 Vite 的热更新、调试、打包等工程化能力；</li>\n<li><strong>现代化技术栈支持</strong>：原生支持 TypeScript、React、Tailwind CSS V4 等现代化前端技术栈，提供了标准化的项目结构和代码规范，让开发者可以使用熟悉的工具开发博客园皮肤；</li>\n<li><strong>模块化的核心包体系</strong>：将核心能力拆分为<code>tona-core</code>、<code>tona-hooks</code>、<code>tona-options</code>、<code>tona-utils</code>等多个核心包，每个包负责特定的功能，实现了功能的解耦与复用，同时也为 AI 开发提供了标准化的 API；</li>\n<li><strong>工程化的开发流程</strong>：提供了完整的开发、构建、测试、发布，集成了 Vitest、Biome、Stylelint 等工具，实现了代码的 Lint、格式化、单元测试、集成测试，同时支持 Git 版本管理和团队协作开发；</li>\n<li><strong>可扩展的插件系统</strong>：提供了<code>tona-plugins</code>插件系统，开发者可以通过编写插件实现 DOM 操作、功能增强等需求，同时内置了多个实用插件，满足开发者的日常开发需求。</li>\n</ol>\n<p>简单来说，Tona 让博客园皮肤开发从<strong>“浏览器端的零散片段开发”</strong> 升级为<strong>“本地的现代化前端项目开发”</strong>，让开发者可以像开发普通前端项目一样开发博客园皮肤，同时为 AI 接入搭建了标准化的技术底座。</p>\n<h3 id=\"32-monorepo-架构设计\">3.2 Monorepo 架构设计</h3>\n<p>Tona 采用<strong>基于 pnpm workspace 的 Monorepo 架构</strong>，这是现代化前端的主流架构选择，其优势在于可以将核心能力拆分为多个独立的包，实现功能的解耦与复用，同时便于版本管理和团队协作开发。</p>\n<p>Tona 的 Monorepo 结构主要分为<strong>三大核心目录</strong>：</p>\n<p><strong>（1）根目录：工程化流水线配置</strong></p>\n<p>Tona 的根目录包含了所有工程化配置文件，如<code>pnpm-workspace.yaml</code>（pnpm 工作区配置）、<code>biome.jsonc</code>（代码 Lint 与格式化）、<code>vitest.config.ts</code>（测试配置）、<code>package.json</code>（根目录脚本与依赖）等，同时提供了<code>scripts/</code>目录，包含开发、构建、发布的核心脚本，实现了<strong>一键开发、一键构建、一键发布</strong>。</p>\n<p><strong>（2）<code>packages/</code>：核心包与工具链（12 个包）</strong></p>\n<p><code>packages/</code>目录是 Tona 的核心，包含 12 个独立的包，每个包负责特定的功能，采用<strong>分层架构</strong>设计（构建层、扩展层、UI 层、工具层、基础层），包之间通过<code>workspace:*</code>协议相互引用，实现本地开发无需发布，同时便于版本同步。</p>\n<p>所有包均使用 TypeScript 开发，提供完整的类型定义，这不仅保证了类型安全，也为 AI 开发提供了清晰的 API 提示。</p>\n<p><strong>（3）<code>themes/</code>：内置皮肤实现（3 个皮肤）</strong></p>\n<p><code>themes/</code>目录包含 Tona 内置的 3 个博客园皮肤皮肤，分为<strong>组件化模式</strong>和<strong>插件化模式</strong>两种开发范式：</p>\n<ul>\n<li><strong>Shadcn 皮肤</strong>：基于 React+Tailwind CSS V4 的组件化皮肤，采用 Tona 的全量核心包，适合开发复杂、美观、可定制的高端皮肤；</li>\n<li><strong>Geek/Reacg 皮肤</strong>：基于原生 DOM+Sass 的插件化皮肤，仅使用 Tona 的核心包（core/options/plugins），适合开发轻量、高效的极简皮肤。</li>\n</ul>\n<p>这 3 个皮肤不仅是可直接使用的博客园皮肤，更是 Tona 的<strong>实战示例</strong>，AI 可以通过读取这些皮肤的代码，学习 Tona 的开发规范和最佳实践。</p>\n<p><img alt=\"image\" height=\"935\" src=\"https://img2024.cnblogs.com/blog/1501373/202602/1501373-20260213101052637-421617829.png\" width=\"1511\" /></p>\n<p><img alt=\"image\" height=\"943\" src=\"https://img2024.cnblogs.com/blog/1501373/202602/1501373-20260213100059752-592802182.png\" width=\"1511\" /></p>\n<p><img alt=\"image\" height=\"939\" src=\"https://img2024.cnblogs.com/blog/1501373/202602/1501373-20260213100904348-378022767.png\" width=\"1511\" /></p>\n<p><img alt=\"image\" height=\"943\" src=\"https://img2024.cnblogs.com/blog/1501373/202602/1501373-20260213101430958-1237882624.png\" width=\"1511\" /></p>\n<h3 id=\"34-核心技术栈选型\">3.4 核心技术栈选型</h3>\n<p>Tona 的技术栈选型遵循<strong>轻量、现代、高效、适配博客园</strong>的原则，所有技术栈均为当前前端行业的主流选择，同时充分考虑了博客园的运行环境。</p>\n<p>Tona 的核心技术栈可分为<strong>核心开发工具</strong>、<strong>前端框架</strong>、<strong>样式工具</strong>、<strong>工程化工具</strong>四大类，具体选型及版本、用途如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>技术栈</th>\n<th>版本</th>\n<th>核心用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>构建工具</td>\n<td>Vite</td>\n<td>^7.3.1</td>\n<td>开发服务器、热更新、打包构建、树摇优化</td>\n</tr>\n<tr>\n<td>包管理器</td>\n<td>pnpm</td>\n<td>10.28.2</td>\n<td>Monorepo 工作区管理、依赖安装、包之间的引用</td>\n</tr>\n<tr>\n<td>开发语言</td>\n<td>TypeScript</td>\n<td>^5.9.3</td>\n<td>全框架类型安全、代码提示、语法校验</td>\n</tr>\n<tr>\n<td>UI 框架</td>\n<td>Preact</td>\n<td>^10.28.2</td>\n<td>轻量 React 替代方案，体积小、性能高，适配博客园的全局环境</td>\n</tr>\n<tr>\n<td>样式框架</td>\n<td>Tailwind CSS</td>\n<td>^4.1.18</td>\n<td>工具类优先的 CSS 框架，快速实现样式开发，支持@apply 指令</td>\n</tr>\n<tr>\n<td>包构建工具</td>\n<td>tsdown</td>\n<td>latest</td>\n<td>TypeScript 包编译，将 TS 代码编译为 ES 模块，适配 Vite 生态</td>\n</tr>\n<tr>\n<td>测试工具</td>\n<td>Vitest</td>\n<td>^4.0.16</td>\n<td>单元测试、集成测试，支持快照测试、模拟测试</td>\n</tr>\n<tr>\n<td>代码 Lint</td>\n<td>Biome</td>\n<td>^2.3.11</td>\n<td>代码 Lint、格式化、语法校验，替代 ESLint+Prettier，性能更高</td>\n</tr>\n<tr>\n<td>Git Hooks</td>\n<td>Lefthook</td>\n<td>^2.0.13</td>\n<td>提交前代码校验、测试，保证代码提交质量</td>\n</tr>\n<tr>\n<td>CSS 预处理器</td>\n<td>Sass</td>\n<td>latest</td>\n<td>插件化皮肤的样式开发，支持变量、混合、嵌套</td>\n</tr>\n<tr>\n<td>动画库</td>\n<td>motion</td>\n<td>^12.25.0</td>\n<td>tona-theme-shadcn 皮肤的动画效果，实现流畅的页面过渡和交互</td>\n</tr>\n<tr>\n<td>图标库</td>\n<td>lucide-React</td>\n<td>^0.562.0</td>\n<td>tona-theme-shadcn 皮肤的图标系统，提供丰富的矢量图标</td>\n</tr>\n<tr>\n<td>组件库</td>\n<td>@base-ui-components</td>\n<td>1.0.0-beta.4</td>\n<td>tona-theme-shadcn 皮肤的无头 UI 组件，实现可定制的基础组件</td>\n</tr>\n</tbody>\n</table>\n<p><strong>技术栈选型的核心考量</strong>：</p>\n<ol>\n<li><strong>Preact</strong>：React 的体积仅 3KB 左右，远小于 React，且 API 与 React 完全兼容，不会在博客园的全局环境中造成体积过大或变量冲突的问题；</li>\n<li><strong>Vite 作为构建工具</strong>：Vite 的热更新速度极快，打包效率高，且原生支持 ES 模块，非常适合博客园皮肤的本地开发；</li>\n<li><strong>pnpm 作为包管理器</strong>：pnpm 的包安装速度快、磁盘占用低，且原生支持 Monorepo 架构，是 Tona 的最佳选择；</li>\n<li><strong>Tailwind CSS V4</strong>：Tailwind CSS V4 相比旧版本性能更高、功能更全，支持@apply 指令的高级用法，非常适合博客园皮肤的样式开发；</li>\n<li><strong>Biome 替代 ESLint+Prettier</strong>：Biome 是一款高性能的一站式代码工具，集成了 Lint、格式化、语法校验等功能，配置简单，性能远高于 ESLint+Prettier，适合 Monorepo 架构的工程化管理。</li>\n</ol>\n<h3 id=\"35-开发与构建流水线\">3.5 开发与构建流水线</h3>\n<p>Tona 提供了<strong>标准化的开发与构建流水线</strong>，所有操作都通过根目录的<code>package.json</code>脚本实现，开发者无需关心底层的实现细节，只需执行简单的命令即可完成开发、构建、测试、发布等操作。同时，这一流水线也为 AI 开发提供了标准化的操作入口——AI 可以通过执行这些脚本，参与全流程的开发。</p>\n<p>Tona 的开发与构建流水线可通过以下 Mermaid 图直观展示：</p>\n<div class=\"mermaid\">graph LR\n    A[开发阶段] --&gt; A1[pnpm dev：启动开发服务器]\n    A1 --&gt; A2[scripts/dev-theme.ts：皮肤开发脚本]\n    A2 --&gt; A3[Vite Dev Server+HMR：热更新开发]\n    B[测试阶段] --&gt; B1[pnpm test：执行单元/集成测试（Vitest）]\n    B1 --&gt; B2[pnpm typecheck：TypeScript 类型校验]\n    B2 --&gt; B3[pnpm lint：代码 Lint 与格式化（Biome）]\n    C[构建阶段] --&gt; C1[pnpm build：构建皮肤（Vite）]\n    C1 --&gt; C2[pnpm build:pkg：并行构建所有核心包]\n    C2 --&gt; C3[Vite Build+树摇：皮肤打包优化]\n    C2 --&gt; C4[tsdown：TS 包编译为 ES 模块]\n    C3 --&gt; C5[themes/*/dist/：皮肤构建产物]\n    C4 --&gt; C6[packages/*/dist/：包构建产物]\n    D[发布阶段] --&gt; D1[pnpm release：版本发布]\n    D1 --&gt; D2[bumpp：版本号自增]\n    D2 --&gt; D3[scripts/update-versions.mjs：同步所有包版本]\n    D3 --&gt; D4[发布到 npm/私有仓库]\n</div><p><strong>（1）核心脚本说明</strong></p>\n<p>Tona 的根目录<code>package.json</code>提供了 7 个核心脚本，覆盖了开发、测试、构建、发布的全流程，具体如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>脚本名</th>\n<th>具体命令</th>\n<th>核心用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>dev</td>\n<td>node scripts/dev-theme.ts</td>\n<td>启动 Vite 开发服务器，注入博客园模板，实现热更新开发</td>\n</tr>\n<tr>\n<td>build</td>\n<td>node scripts/build-theme.ts</td>\n<td>构建所有皮肤，通过 Vite 进行打包、压缩、树摇优化，生成可部署的构建产物</td>\n</tr>\n<tr>\n<td>build:pkg</td>\n<td>pnpm -r --filter=./packages/** --parallel run build</td>\n<td>并行构建<code>packages/</code>目录下的所有核心包，提高构建效率</td>\n</tr>\n<tr>\n<td>typecheck</td>\n<td>tsc --noEmit</td>\n<td>对所有 TypeScript 代码进行类型校验，保证类型安全</td>\n</tr>\n<tr>\n<td>test</td>\n<td>vitest test</td>\n<td>执行 Vitest 的单元测试和集成测试，保证代码质量</td>\n</tr>\n<tr>\n<td>lint</td>\n<td>pnpm exec biome check --write</td>\n<td>对所有代码进行 Lint 和格式化，自动修复代码风格问题</td>\n</tr>\n<tr>\n<td>release</td>\n<td>bumpp ... -x \"zx scripts/update-versions.mjs\"</td>\n<td>版本号自增，同步所有核心包和皮肤的版本，实现一键发布</td>\n</tr>\n</tbody>\n</table>\n<p><strong>（2）流水线的核心特点</strong></p>\n<ol>\n<li><strong>一键化操作</strong>：所有流程都通过简单的<code>pnpm &lt;script&gt;</code>命令实现，开发者无需关心底层细节；</li>\n<li><strong>并行构建</strong>：<code>build:pkg</code>脚本通过<code>pnpm -r --parallel</code>实现所有核心包的并行构建，大幅提高构建效率；</li>\n<li><strong>自动化校验</strong>：<code>lint</code>、<code>typecheck</code>、<code>test</code>脚本实现了代码的自动化校验，保证代码质量；</li>\n<li><strong>版本同步</strong>：<code>release</code>脚本通过<code>bumpp</code>和自定义脚本实现了所有包和皮肤的版本同步，避免版本不一致的问题；</li>\n<li><strong>产物标准化</strong>：构建后的产物存放在<code>themes/*/dist/</code>和<code>packages/*/dist/</code>目录中，结构标准化，便于部署和使用。</li>\n</ol>\n<h2 id=\"4-tona-核心包解析从设计到实现\">4. Tona 核心包解析：从设计到实现</h2>\n<p>Tona 的核心能力体现在<code>packages/</code>目录的 12 个核心包中，这些包采用<strong>分层架构</strong>设计，相互解耦又相互协作，构成了 Tona 的完整能力体系。本节将重点解析 Tona 中最核心的几个包：包括其设计思路、关键实现、示例代码。</p>\n<h3 id=\"41-tona-vite本地开发的核心引擎让-ai-读懂博客园模板\">4.1 tona-vite：本地开发的核心引擎，让 AI 读懂博客园模板</h3>\n<p><code>tona-vite</code>是 Tona 的<strong>核心引擎</strong>，也是 AI 接入博客园皮肤开发的<strong>关键包</strong>。其核心功能是<strong>将博客园的原生 HTML 模板注入 Vite Dev Server 中</strong>，让开发者可以在本地脱离博客园环境进行皮肤开发，让 AI 可以直接读取这些模板，理解博客园的 DOM 结构。</p>\n<p><strong>（1）tona-vite 的工作原理</strong></p>\n<p><code>tona-vite</code>作为一款 Vite 插件，其工作原理主要分为<strong>模板注入</strong>、<strong>Dev Server 启动</strong>、<strong>热更新支持</strong>三个步骤，可通过以下 Mermaid 图展示：</p>\n<div class=\"mermaid\">graph TD\n    A[tona-vite 插件初始化] --&gt; A1[读取本地模板：packages/tona-vite/public/templates/]\n    A1 --&gt; A2[模板预处理：解析 DOM 结构、注入全局变量]\n    B[Vite Dev Server 启动] --&gt; B1[插件注册：将模板注入 Vite 的 Dev Server]\n    B1 --&gt; B2[路由映射：将模板映射到 Vite 的路由（/templates/*）]\n    C[本地开发阶段] --&gt; C1[皮肤代码开发：React/CSS/JS]\n    C1 --&gt; C2[热更新：Vite HMR 触发皮肤代码重新渲染]\n    C2 --&gt; C3[模板渲染：Vite Dev Server 渲染注入的博客园模板+皮肤代码]\n    C3 --&gt; C4[浏览器访问：本地查看博客园皮肤效果]\n</div><p><strong>核心关键点</strong>：</p>\n<ol>\n<li><strong>模板本地化</strong>：<code>tona-vite</code>将博客园的所有原生 HTML 模板（首页、文章页、相册页、分类页等）下载并保存到本地<code>packages/tona-vite/public/templates/</code>目录中，尽可能保证了与博客园线上环境的一致性；</li>\n<li><strong>路由映射</strong>：<code>tona-vite</code>将本地模板映射到 Vite Dev Server 的<code>/templates/*</code>路由中，开发者可以通过<code>http://localhost:5173/templates/home.html</code>访问博客园首页模板，通过<code>http://localhost:5173/templates/post-markdown.html</code>访问文章页模板；</li>\n<li><strong>代码注入</strong>：开发者编写的皮肤代码（React 组件、CSS 样式、JS 脚本）会被 Vite Dev Server 注入到模板中，实现皮肤效果的实时渲染；</li>\n<li><strong>热更新支持</strong>：基于 Vite 的 HMR 能力，开发者修改皮肤代码后，页面会实时更新，无需刷新，大幅提高开发效率。</li>\n</ol>\n<p><strong>（2）tona-vite 的关键实现</strong></p>\n<p>插件使用 Vite 的 configResolved 和 configureServer 钩子，注入博客园模板到 public 目录。</p>\n<pre><code class=\"language-typescript\">// packages/tona-vite/index.ts （简化版）\nimport { Plugin } from 'vite'\nimport fs from 'fs-extra'\nimport path from 'path'\n\nexport function tonaVite(): Plugin {\n  return {\n    name: 'tona-vite',\n    configResolved(config) {\n      // 注入模板\n      const templatesDir = path.resolve(__dirname, 'public/templates')\n      fs.copySync(templatesDir, config.root + '/public/templates')\n    },\n    configureServer(server) {\n      server.middlewares.use((req, res, next) =&gt; {\n        if (req.url.startsWith('/templates/')) {\n          // 模拟 CNBlogs 模板响应\n          res.end(fs.readFileSync(path.resolve(config.root, req.url)))\n        } else {\n          next()\n        }\n      })\n    },\n  }\n}\n</code></pre>\n<p><strong>（3）AI 接入的核心优势</strong></p>\n<p><code>tona-vite</code>为 AI 开发提供了两个核心优势：</p>\n<ol>\n<li><strong>模板可访问性</strong>：博客园的原生 HTML 模板被保存到本地，AI 可以直接读取这些模板文件，理解博客园的 DOM 结构、HTML 布局，从而生成符合模板结构的皮肤代码；</li>\n<li><strong>开发环境标准化</strong>：AI 可以通过执行<code>pnpm dev</code>命令启动 Vite Dev Server，参与本地开发，同时可以通过 Vite 的 API 获取皮肤代码的实时状态，实现 AI 与人类开发者的协同开发。</li>\n</ol>\n<div class=\"mermaid\">sequenceDiagram\n    participant User/AI\n    participant ViteServer\n    participant TonaVitePlugin\n    participant CNBlogsTemplate\n\n    User/AI-&gt;&gt;ViteServer: pnpm dev\n    ViteServer-&gt;&gt;TonaVitePlugin: configResolved\n    TonaVitePlugin-&gt;&gt;CNBlogsTemplate: 复制模板到 public/\n    User/AI-&gt;&gt;ViteServer: 修改代码\n    ViteServer-&gt;&gt;TonaVitePlugin: HMR 更新\n    TonaVitePlugin-&gt;&gt;User/AI: 刷新页面\n</div><h3 id=\"42-tona-core核心-api\">4.2 tona-core：核心 API</h3>\n<p><code>tona-core</code>是 Tona 的<strong>基础包</strong>，提供<code>createTheme</code>和<code>defineOptions</code>两个核心 API，负责<strong>皮肤实例的创建、插件的注册与执行、配置的合并与读取</strong>。所有皮肤都通过<code>createTheme().use(plugin)</code>串联插件，所有插件通过<code>defineOptions</code>声明可配置项，实现统一的模块与生命周期管理。</p>\n<p><strong>（1）createTheme：皮肤实例与插件系统</strong></p>\n<p><code>createTheme()</code>返回一个皮肤实例，实例提供<code>use(plugin, ...options)</code>方法用于注册插件：</p>\n<pre><code class=\"language-typescript\">// packages/core/src/createThemeApi.ts （简化版）\nexport function createTheme() {\n  const context = { theme: null, config: { globalProperties: {} } }\n  const installedPlugins = new Set()\n\n  const theme = {\n    version: '3.0',\n    _context: context,\n    get config() {\n      return context.config\n    },\n\n    use(plugin, ...options) {\n      if (installedPlugins.has(plugin)) return theme\n      if (typeof plugin?.install === 'function') {\n        installedPlugins.add(plugin)\n        plugin.install(theme, ...options)\n      } else if (typeof plugin === 'function') {\n        installedPlugins.add(plugin)\n        plugin(theme, ...options)\n      }\n      return theme\n    },\n  }\n\n  context.theme = theme\n  init()\n  return theme\n}\n</code></pre>\n<p>插件可以是<strong>函数</strong>或<strong>带<code>install</code>方法的对象</strong>，调用时传入皮肤实例和可选参数；<code>use</code>支持链式调用，返回皮肤实例本身。<code>init()</code>在创建时执行，负责隐藏博客园加载动画、开发模式下初始化<code>window.opts</code>等。</p>\n<p><strong>（2）defineOptions：配置合并与用户覆盖</strong></p>\n<p><code>defineOptions</code>用于声明<strong>插件的配置项</strong>，将默认值、用户配置（<code>window.opts</code>）、开发时覆盖三者合并，供插件内部使用：</p>\n<pre><code class=\"language-typescript\">// packages/core/src/defineOptionsApi.ts （简化版）\nexport function defineOptions(userOptionName, defaultOptions) {\n  return (devOptions) =&gt; {\n    const userConfig = window.opts || {}\n    const user =\n      typeof userOptionName === 'string'\n        ? userConfig[userOptionName]\n        : getValue(userOptionName, userConfig) // 数组时按顺序匹配第一个存在的键\n    return Object.assign({}, defaultOptions, user, devOptions)\n  }\n}\n\n// 使用示例\nconst getBackgroundOptions = defineOptions('bodyBackground', {\n  enable: false,\n  value: '',\n  opacity: 0.85,\n  repeat: false,\n})\n\nconst opts = getBackgroundOptions({ enable: true }) // 开发时覆盖\n// 线上：从 window.opts.bodyBackground 读取用户配置，与默认值合并\n</code></pre>\n<p><code>userOptionName</code>支持字符串或数组（多别名），数组时按顺序查找第一个存在于用户配置中的键。博客园用户通过「页脚 HTML 代码」注入<code>window.opts = { bodyBackground: { enable: true, ... } }</code>，皮肤即可读取到合并后的配置。</p>\n<h3 id=\"43-tona-hooks-常用-hooks\">4.3 tona-hooks: 常用 Hooks</h3>\n<p><code>tona-hooks</code>是 Tona 为 <strong>React 生态</strong>打造的自定义 Hook 包，其核心功能是<strong>封装博客园皮肤开发中常用的 DOM 操作、状态管理、业务逻辑</strong>，让开发者可以像使用 React Hook 一样，快速实现博客园皮肤的开发，同时大幅减少重复代码。其设计遵循 <strong>“面向博客园业务场景”</strong> 的原则，所有 Hook 都针对博客园皮肤开发的实际需求进行封装。</p>\n<p>其中，<code>useQueryDOM</code>是<code>tona-hooks</code>中的核心 Hook。<code>useQueryDOM</code>的核心功能是<strong>封装博客园的 DOM 查询操作，支持 DOM 节点的自动更新和重渲染</strong>，解决了博客园 DOM 结构动态变化导致的查询失败问题。</p>\n<p><strong>useQueryDOM Hook 的实现</strong></p>\n<pre><code class=\"language-typescript\">// packages/tona-hooks/src/useQueryDOM.ts\nimport { useState, useEffect, useCallback } from 'React/hooks'\n\n/**\n * 博客园 DOM 查询 Hook\n * @param selector DOM 选择器\n * @param options 配置项：是否监听 DOM 变化、是否立即查询\n * @returns DOM 节点、重新查询方法\n */\nexport function useQueryDOM&lt;T extends HTMLElement&gt;(\n  selector: string,\n  options: { observe: boolean; immediate: boolean } = {\n    observe: true,\n    immediate: true,\n  },\n) {\n  const [node, setNode] = useState&lt;T | null&gt;(null)\n\n  // DOM 查询方法\n  const queryNode = useCallback(() =&gt; {\n    const el = document.querySelector&lt;T&gt;(selector)\n    setNode(el)\n    return el\n  }, [selector])\n\n  // 初始化查询\n  useEffect(() =&gt; {\n    if (options.immediate) {\n      queryNode()\n    }\n  }, [options.immediate, queryNode])\n\n  // 监听 DOM 变化\n  useEffect(() =&gt; {\n    if (!options.observe) return\n\n    // 创建 MutationObserver，监听 DOM 树变化\n    const observer = new MutationObserver((mutations) =&gt; {\n      // 当 DOM 树发生变化时，重新查询\n      queryNode()\n    })\n\n    // 监听整个文档的 DOM 变化\n    observer.observe(document.documentElement, {\n      childList: true,\n      subtree: true,\n      attributes: false,\n      characterData: false,\n    })\n\n    // 销毁时取消监听\n    return () =&gt; {\n      observer.disconnect()\n    }\n  }, [options.observe, queryNode])\n\n  return [node, queryNode] as const\n}\n</code></pre>\n<p><strong>useQueryDOM Hook 的使用</strong></p>\n<pre><code class=\"language-typescript\">import { useQueryDOM } from 'tona-hooks';\n\nexport function PostTitle() {\n  // 查询博客园文章标题节点\n  const { data, isPending } = useQueryDOM({\n    selector: '#cb_post_title_url',\n    observe: true,\n    queryFn: (el) =&gt; {\n      return el?.querySelector('[role=\"heading\"]')?.innerHTML ?? ''\n    },\n  });\n\n  if (isPending) {\n    return &lt;h1 className=\"text-2xl font-bold\"&gt;加载中...&lt;/h1&gt;;\n  }\n\n  return (\n    &lt;h1 className=\"text-3xl font-bold text-blue-600 hover:text-blue-800 transition-colors\"&gt;\n      {titleNode.innerText}\n    &lt;/h1&gt;\n  );\n}\n</code></pre>\n<blockquote>\n<p>你可以试试通过此 Hook 实现的文章底部推荐按钮、评论列表以及个人主页的关注按钮功能。</p>\n</blockquote>\n<h3 id=\"44-tona-tailwind-stylelint-插件\">4.4 tona tailwind stylelint 插件</h3>\n<p>如果在博客园皮肤开发中使用 tailwind，需要考虑的问题是 class name 被打包至 js 文件中，js 文件体检快速增长的问题。我们可以在 CSS 文件内使用 tailwind。</p>\n<p>stylelint-one-utility-class-per-line 插件强制 @apply 指令一行一个类名，支持自动修复。解决多类名一行导致的可读性差问题。</p>\n<pre><code class=\"language-css\">.card {\n  @apply flex flex-col items-center justify-center p-6 bg-white dark:bg-gray-800 rounded-lg shadow-md hover:shadow-lg transition-shadow duration-300;\n}\n</code></pre>\n<p>lint 后</p>\n<pre><code class=\"language-css\">.card {\n  @apply flex \n    flex-col \n    items-center \n    justify-center \n    p-6 \n    bg-white \n    dark:bg-gray-800 \n    rounded-lg \n    shadow-md \n    hover:shadow-lg \n    transition-shadow \n    duration-300;\n}\n</code></pre>\n<h3 id=\"45-create-tonacli-快速初始化一键搭建皮肤开发脚手架\">4.5 create-tona：CLI 快速初始化，一键搭建皮肤开发脚手架</h3>\n<p><img alt=\"image\" height=\"804\" src=\"https://img2024.cnblogs.com/blog/1501373/202602/1501373-20260213102615101-1943776826.png\" width=\"1268\" /></p>\n<p><code>create-tona</code>是 Tona 的 <strong>CLI 快速初始化工具</strong>，其核心功能是<strong>通过一行命令创建 Tona 皮肤项目脚手架</strong>，让开发者无需手动配置 Vite、tona-vite 插件、依赖安装等，即可在数秒内获得一个可运行的博客园皮肤开发环境。其设计遵循<strong>“开箱即用、模板可选、流程标准化”</strong>的原则，是 Tona 开发流程的**入口包。</p>\n<p><strong>（1）create-tona 的工作原理</strong></p>\n<p><code>create-tona</code>作为一款 Node.js CLI 工具，其工作原理主要分为<strong>交互式引导</strong>、<strong>模板选择与复制</strong>、<strong>依赖安装与启动</strong>三个步骤，可通过以下 Mermaid 图展示：</p>\n<div class=\"mermaid\">graph TD\n    A[执行 pnpm create tona] --&gt; A1[解析命令行参数：-t --template, -i --immediate]\n    A1 --&gt; A2[检测运行环境：TTY 交互模式 / 非 TTY 静默模式]\n    B[交互式引导] --&gt; B1[项目名称 &amp; 目标目录]\n    B1 --&gt; B2[目录冲突处理：覆盖 / 忽略 / 取消]\n    B2 --&gt; B3[包名校验：npm 规范]\n    B3 --&gt; B4[模板选择：TypeScript / JavaScript]\n    B4 --&gt; B5[是否立即安装依赖并启动 dev]\n    C[项目搭建] --&gt; C1[复制 template-ts 或 template-js 到目标目录]\n    C1 --&gt; C2[更新 package.json 的 name 字段]\n    C2 --&gt; C3[可选：pnpm install + pnpm dev]\n    C3 --&gt; C4[完成：输出后续命令提示]\n</div><p><strong>核心关键点</strong>：</p>\n<ol>\n<li><strong>双模板支持</strong>：<code>create-tona</code>提供<code>template-ts</code>（TypeScript）和<code>template-js</code>（JavaScript）两种模板，模板已预配置<code>tona-vite</code>插件、<code>tona</code>依赖、Vite 构建脚本，开发者可根据技术栈偏好选择；</li>\n<li><strong>包管理器自动识别</strong>：通过<code>npm_config_user_agent</code>环境变量识别调用方（pnpm、npm、yarn、bun、deno），自动采用对应命令进行依赖安装和脚本执行；</li>\n<li><strong>目录冲突处理</strong>：当目标目录非空时，提供“取消 / 清空后继续 / 忽略并继续”三种选项，避免意外覆盖；</li>\n<li><strong>即时启动</strong>：支持<code>-i</code>或<code>--immediate</code>参数，在项目创建完成后自动执行<code>pnpm install</code>和<code>pnpm dev</code>，实现“创建即开发”。</li>\n</ol>\n<p><strong>（2）create-tona 的关键实现</strong></p>\n<p>CLI 使用<code>@clack/prompts</code>实现交互式提问，使用<code>mri</code>解析命令行参数，通过 Node.js 的<code>fs</code>模块复制模板文件。</p>\n<pre><code class=\"language-typescript\">// packages/create-tona/src/index.ts （简化版）\nimport fs from 'node:fs'\nimport path from 'node:path'\nimport { fileURLToPath } from 'node:url'\nimport * as prompts from '@clack/prompts'\nimport spawn from 'cross-spawn'\nimport mri from 'mri'\n\nconst argv = mri(process.argv.slice(2), {\n  boolean: ['help', 'overwrite', 'immediate', 'interactive'],\n  alias: { h: 'help', t: 'template', i: 'immediate' },\n  string: ['template'],\n})\n\nasync function init() {\n  // 1. 获取目标目录（交互或参数）\n  const targetDir = argv._[0]\n    ? formatTargetDir(String(argv._[0]))\n    : await prompts.text({\n        message: 'Project name:',\n        defaultValue: 'tona-theme',\n      })\n\n  // 2. 目录冲突处理\n  if (fs.existsSync(targetDir) &amp;&amp; !isEmpty(targetDir)) {\n    const overwrite = await prompts.select({\n      message: '...',\n      options: ['no', 'yes', 'ignore'],\n    })\n    if (overwrite === 'yes') emptyDir(targetDir)\n  }\n\n  // 3. 选择模板：ts / js\n  const template =\n    argv.template ??\n    (await prompts.select({\n      message: 'Select a template:',\n      options: [\n        { label: 'TypeScript', value: 'ts' },\n        { label: 'JavaScript', value: 'js' },\n      ],\n    }))\n\n  // 4. 复制 template-ts 或 template-js 到目标目录\n  const __dirname = path.dirname(fileURLToPath(import.meta.url))\n  const templateDir = path.resolve(__dirname, '..', `template-${template}`)\n  copyDir(templateDir, targetDir)\n\n  // 5. 更新 package.json 的 name\n  const pkg = JSON.parse(\n    fs.readFileSync(path.join(targetDir, 'package.json'), 'utf-8'),\n  )\n  pkg.name = path.basename(path.resolve(targetDir))\n  fs.writeFileSync(\n    path.join(targetDir, 'package.json'),\n    JSON.stringify(pkg, null, 2),\n  )\n\n  // 6. 可选：立即安装并启动\n  if (argv.immediate) {\n    spawn.sync(pkgManager, ['install'], { cwd: targetDir })\n    spawn.sync(pkgManager, ['dev'], { cwd: targetDir })\n  }\n}\n</code></pre>\n<p><strong>模板结构</strong>：每个模板包含<code>package.json</code>、<code>vite.config.mts</code>、<code>src/main.ts</code>、<code>src/style.css</code>等，其中<code>vite.config.mts</code>已配置<code>tona-vite</code>插件和<code>@</code>路径别名，<code>main.ts</code>为插件式入口示例（<code>createTheme().use(myPlugin)</code>）。</p>\n<h2 id=\"5-示例皮肤实现拆解\">5. 示例皮肤实现拆解</h2>\n<p><code>tona-theme-shadcn</code>是 Tona 内置的<strong>组件化模式</strong>示例皮肤，近期开发并发布。采用 Preact + Tailwind CSS V4 + shadcn/ui 风格设计，是 Tona 皮肤开发的实践参考。本节从项目结构、入口与插件链、页面路由、数据获取、样式体系、构建输出六个维度拆解其实现，我们一起看看如何基于 Tona 开发高质量博客园皮肤。</p>\n<h3 id=\"51-项目结构与技术栈\">5.1 项目结构与技术栈</h3>\n<p><code>tona-theme-shadcn</code>采用<strong>组件化 + 插件化</strong>的混合架构：核心 UI 以 Preact 组件实现，增强功能以插件形式挂载。目录结构如下：</p>\n<pre><code class=\"language-md\">themes/shadcn/\n├── src/\n│ ├── main.ts # 入口：插件链注册\n│ ├── styles/ # 全局样式\n│ │ ├── globals.css # Tailwind + shadcn + markdown + theme\n│ │ ├── shadcn/ # shadcn 皮肤变量、组件样式\n│ │ ├── markdown.css # 文章 Markdown 样式\n│ │ └── theme.css # 皮肤皮肤变量\n│ ├── lib/utils.ts # cn() 工具函数\n│ ├── components/ui/ # 通用 UI 组件（Button、Separator、Sonner 等）\n│ └── plugins/\n│ ├── app/ # 主应用插件：Preact 渲染整页\n│ │ ├── app.tsx # App 根组件\n│ │ ├── components/ # 页面级组件\n│ │ │ ├── page/ # 路由分发\n│ │ │ ├── home-page/ # 首页\n│ │ │ ├── post-page/ # 文章页\n│ │ │ ├── top-nav-bar/ # 顶部导航\n│ │ │ ├── post-comments/ # 评论\n│ │ │ └── ...\n│ │ └── hooks/ # 业务 hooks\n│ ├── code-copy-button/ # 代码块复制（原生 DOM 插件）\n│ └── smooth-scroll/ # 平滑滚动（原生 DOM 插件）\n├── vite.config.mts\n└── package.json\n</code></pre>\n<p><strong>技术栈</strong>：Preact、Tailwind CSS V4、class-variance-authority（cva）、clsx + tailwind-merge（cn）、lucide-preact（图标）、motion（动画）、tona-hooks（useQueryDOM）、tona-utils、tona-sonner（Toast）。</p>\n<p>通过目录结构可以看到，由 preact 实现的部分（皮肤主体）几乎是一个 SPA，只是 Tona 的一个插件。你可以使用任何前端框架开发博客园皮肤，但需要权衡体积、是否 AI 友好、生态等因素。我认为 preact 是一个不错的选择，所以我选用 preact 实现了 tona-theme-shadcn 皮肤。</p>\n<h3 id=\"52-入口与插件链\">5.2 入口与插件链</h3>\n<p>皮肤入口通过<code>createTheme().use()</code>串联多个插件，实现<strong>渐进式增强</strong>：</p>\n<pre><code class=\"language-typescript\">// themes/shadcn/src/main.ts\nimport { createTheme } from 'tona'\nimport './styles/globals.css'\nimport { app } from './plugins/app'\nimport { codeCopyButton } from './plugins/code-copy-button'\nimport { smoothScroll } from './plugins/smooth-scroll'\n\ncreateTheme().use(app).use(smoothScroll).use(codeCopyButton)\n</code></pre>\n<ul>\n<li><strong>app</strong>：Preact 渲染核心，将整页 UI 以<code>document.body.prepend(frag)</code>注入，覆盖博客园原生布局；</li>\n<li><strong>smoothScroll</strong>：设置<code>scrollBehavior</code>；</li>\n<li><strong>codeCopyButton</strong>：为代码块添加复制按钮，纯 DOM 操作。</li>\n</ul>\n<p><code>app</code>插件的实现方式体现了<strong>组件化</strong>与<strong>模板注入</strong>的结合：将 Preact 应用挂载到<code>DocumentFragment</code>，再插入到<code>body</code>顶部，从而在博客园模板之上叠加现代化 UI。</p>\n<h3 id=\"53-页面路由与组件复用\">5.3 页面路由与组件复用</h3>\n<p>博客园不同页面（首页、文章页、分类页等）对应不同的 DOM 结构，shadcn 通过<code>tona-utils</code>的<code>getCurrentPage()</code>识别当前页面类型，再在<code>Page</code>组件中做路由分发：</p>\n<pre><code class=\"language-typescript\">// themes/shadcn/src/plugins/app/components/page/index.tsx\nimport { getCurrentPage } from 'tona-utils'\nimport { HomePage } from '../home-page'\nimport { PostPage } from '../post-page'\n\nexport function Page() {\n  const currentPage = getCurrentPage()\n\n  if (currentPage === 'home') return &lt;HomePage /&gt;\n  if (currentPage === 'post') return &lt;PostPage /&gt;\n  return null\n}\n</code></pre>\n<p>如果你的皮肤比较复杂，甚至可以做代码拆分，在不同博客页面按需加载资源。</p>\n<h3 id=\"54-数据获取与-dom-适配usequerydom-实战\">5.4 数据获取与 DOM 适配：useQueryDOM 实战</h3>\n<p>博客园页面 DOM 由服务端渲染，结构固定但内容动态。shadcn 皮肤使用<code>tona-hooks</code>的<code>useQueryDOM</code>，从 DOM 中提取数据并驱动 Preact 组件渲染。</p>\n<p><strong>示例一：文章列表</strong>。首页的<code>.forFlow</code>内包含按日期分组的文章列表，<code>usePostList</code>通过<code>queryFn</code>解析出每篇文章的标题、链接、时间、浏览/评论/推荐数等：</p>\n<pre><code class=\"language-typescript\">// themes/shadcn/src/plugins/app/components/home-page/post-list/hooks.ts\nexport function usePostList() {\n  return useQueryDOM({\n    selector: '.forFlow',\n    observe: true,\n    queryFn: (el) =&gt; {\n      const items: PostItem[] = []\n      const dayElements = el?.querySelectorAll('.day') ?? []\n      dayElements.forEach((dayEl) =&gt; {\n        // 解析 .dayTitle、.postTitle、.postCon、.postDesc 等\n        // 提取 title、href、date、viewCount、commentCount、diggCount...\n        items.push({ date, title, href, description, ... })\n      })\n      return items\n    },\n  })\n}\n</code></pre>\n<p><strong>示例二：文章标题与元信息</strong>。文章页通过<code>#cb_post_title_url</code>、<code>#cnblogs_post_body</code>等选择器获取标题 HTML、发布日期、阅读时间等：</p>\n<pre><code class=\"language-typescript\">// themes/shadcn/src/plugins/app/components/post-hero/hooks.ts\nexport function usePostTitle() {\n  return useQueryDOM({\n    selector: '#cb_post_title_url',\n    queryFn: (el) =&gt; el?.querySelector('[role=\"heading\"]')?.innerHTML ?? '',\n  })\n}\n\nexport function usePostInfo() {\n  return useQueryDOM({\n    selector: '#cnblogs_post_body',\n    observe: true,\n    queryFn: (el) =&gt; ({\n      publishTime: getCurrentPostDateAdded(),\n      readingTime: calculateReadingTime(el?.textContent ?? ''),\n      updateTime: null,\n    }),\n  })\n}\n</code></pre>\n<p><code>observe: true</code>时，<code>useQueryDOM</code>内部使用<code>MutationObserver</code>监听 DOM 变化，在博客园 AJAX 更新内容后自动重新查询，保证数据与视图同步。</p>\n<p><strong>示例三：文章内容“搬迁”</strong>。<code>PostDetails</code>组件不重新渲染博客园文章 body，而是通过<code>appendChild</code>将<code>#cnblogs_post_body</code>迁移到 Preact 渲染的容器内，在保留博客园原生 Markdown 渲染效果的同时，实现与皮肤布局的无缝融合。</p>\n<h3 id=\"55-样式体系tailwind--shadcn--皮肤变量\">5.5 样式体系：Tailwind + shadcn + 皮肤变量</h3>\n<p>shadcn 的样式采用<strong>分层导入</strong>：</p>\n<pre><code class=\"language-css\">/* themes/shadcn/src/styles/globals.css */\n@import 'tailwindcss' source('../../src');\n@import 'tw-animate-css';\n@import './shadcn/index.css';\n@import './markdown.css';\n@import './theme.css';\n@import './reset.css';\n</code></pre>\n<ul>\n<li><strong>Tailwind</strong>：工具类主体，<code>source()</code> 指向 <code>src</code> 以支持 <code>@theme</code> 等配置；</li>\n<li><strong>tw-animate-css</strong>：预设动画；</li>\n<li><strong>shadcn</strong>：CSS 变量（<code>--background</code>、<code>--foreground</code>、<code>--primary</code> 等）、组件样式；</li>\n<li><strong>markdown</strong>：文章内容 Markdown 渲染样式；</li>\n<li><strong>theme</strong>：皮肤级皮肤变量；</li>\n<li><strong>reset</strong>：基础重置。</li>\n</ul>\n<p>组件使用<code>cva</code>管理样式变体，<code>cn()</code>合并类名：</p>\n<pre><code class=\"language-typescript\">// themes/shadcn/src/components/ui/button.tsx\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center rounded-md font-medium ...\",\n  {\n    variants: {\n      variant: { default: '...', outline: '...', ghost: '...' },\n      size: { default: '...', sm: '...', icon: '...' },\n    },\n    defaultVariants: { variant: 'default', size: 'default' },\n  },\n)\n\nfunction Button({ variant, size, className, ...props }) {\n  return &lt;slot className={cn(buttonVariants({ variant, size }), className)} {...props} /&gt;\n}\n</code></pre>\n<p>暗色模式通过<code>dark:</code>前缀和 CSS 变量切换实现，满足 AGENTS.md 中的皮肤规范。</p>\n<h3 id=\"56-构建与输出\">5.6 构建与输出</h3>\n<p>Vite 配置将皮肤打包为<strong>单文件 IIFE</strong>，便于博客园「页脚 HTML 代码」「自定义 JS 脚本」等入口引入：</p>\n<pre><code class=\"language-typescript\">// themes/shadcn/vite.config.mts（节选）\nbuild: {\n  lib: {\n    formats: ['iife'],\n    entry: resolve(__dirname, 'src/main.ts'),\n    name: 'shadcn',\n    fileName: () =&gt; 'shadcn.js',\n  },\n  cssCodeSplit: false,\n  rollupOptions: {\n    output: { assetFileNames: 'shadcn.[ext]' },\n  },\n}\n</code></pre>\n<p>构建产物为<code>dist/shadcn.js</code>和<code>dist/shadcn.css</code>，用户将两者引入博客园后台即可使用。</p>\n<hr />\n<p>通过本节拆解，可以看到 tona-theme-shadcn 如何将<strong>Tona 核心包</strong>（tona-vite、tona-hooks、tona-utils）、<strong>Preact 组件化</strong>、<strong>Tailwind 样式体系</strong>与<strong>博客园 DOM 结构</strong>有机结合，形成一套可维护、可扩展的皮肤实现范式，为 AI 提供了清晰的参考模板。</p>\n<p>顺便一提，评论列表作为这个皮肤的最复杂的功能之一，样式和功能都完全由 AI 实现。</p>\n<h2 id=\"6-最后\">6. 最后</h2>\n<p>欢迎使用皮肤，也欢迎尝试使用 Tona 亲手构建一款皮肤。不妨用<code>pnpm create tona</code>快速初始化一个皮肤项目，感受本地热更新、TypeScript 与 Tailwind 带来的开发效率，让 AI 像开发普通前端页面那样开发博客园皮肤。也可以将 Tona 仓库中的模板、核心包与示例皮肤作为上下文，生成高质量的皮肤代码。</p>\n<p>Tona 是开源项目，托管于 <a href=\"https://github.com/guangzan/tona\" rel=\"noopener nofollow\" target=\"_blank\">GitHub</a>。欢迎 🌟、提交 Issue、参与讨论或贡献代码，一起推动博客园皮肤开发的现代化与 AI 化。</p>\n<h2 id=\"7-参考资料\">7. 参考资料</h2>\n<ul>\n<li><a href=\"https://github.com/guangzan/tona\" rel=\"noopener nofollow\" target=\"_blank\">gitHub/tona</a></li>\n<li><a href=\"https://www.yuque.com/r/awescnb/books\" rel=\"noopener nofollow\" target=\"_blank\">使用皮肤</a></li>\n<li><a href=\"https://www.cnblogs.com/guangzan/p/19585389\" target=\"_blank\">shadcn 皮肤上线</a></li>\n</ul>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-13 10:56</span>&nbsp;\n<a href=\"https://www.cnblogs.com/guangzan\">guangzan</a>&nbsp;\n阅读(<span id=\"post_view_count\">85</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "线上服务重启后，从nacos取不到配置了，怎么回事",
      "link": "https://www.cnblogs.com/grey-wolf/p/19611093",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/grey-wolf/p/19611093\" id=\"cb_post_title_url\" title=\"发布于 2026-02-13 10:19\">\n    <span>线上服务重启后，从nacos取不到配置了，怎么回事</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"背景\">背景</h1>\n<p>前一阵，线上某个服务升级，典型的spring boot应用，引入了spring cloud，主要是为了使用nacos来统一管理配置。</p>\n<p>典型的bootstrap.yml配置如下，包含了用户名密码：</p>\n<p><img alt=\"image-20260213093118522\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260213093118522.png\" /></p>\n<p>服务启动时，就会去nacos读取配置，读取配置当然要先登录，这里配置的用户名密码就是登录用的。</p>\n<p>我们遇到的问题是，线上那个服务，不是第一次上线，一直跑得好好的，本次更新主要是更新了fat jar，改了点业务逻辑，像bootstrap.yml这些没任何改动。结果运维同事替换了jar包后一重启，说启动不了，说你这个包是不是有问题啊。</p>\n<h1 id=\"定位过程\">定位过程</h1>\n<h2 id=\"抓包\">抓包</h2>\n<p>过去运维那边看了下，发现报错是说什么数据库连不上，ip一看，是开发环境的数据库ip，我就感觉是不是没取到nacos里的配置，所以用了默认的开发环境配置了（fat jar中有默认的开发环境配置文件）。</p>\n<p>我就说这得抓个包看看，nacos的监听端口是8848，主要用于登录，获取token；还有9849，用于服务注册、配置拉取等。</p>\n<pre><code class=\"language-shell\">tcpdump -i any tcp port 8848 or tcp port 9848 -w nacos.pcap\n</code></pre>\n<p>把包抓下来一看，发现确实没拉取到配置，但是，原因是登录就失败了。</p>\n<p>报文如下：</p>\n<p><img alt=\"image-20260213093813785\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260213093813785.png\" /></p>\n<h2 id=\"网页端登录\">网页端登录</h2>\n<p>难道是密码错了吗，然后同样的用户密码，在nacos管理系统那里登录，发现是正常的。这个确实是很奇怪，F12看了下，看了接口也是上面那个接口。</p>\n<p><img alt=\"image-20260213094323596\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260213094323596.png\" /></p>\n<p>唯一不同的也就是参数携带方式有一点差异：</p>\n<p><img alt=\"image-20260213094353557\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260213094353557.png\" /></p>\n<p>这个网页端，是用户名、密码都在form表单的http body里。而api那边，是username在url里，密码在body里。</p>\n<h2 id=\"拉人\">拉人</h2>\n<p>然后我们就确认是nacos 服务端感觉有点问题。另外，我们也找了其他类似的服务A，把那个服务A用的nacos用户名、密码拿过来，配置到本服务里，重启，发现竟然也报同样的错误。</p>\n<p>然后就感觉是nacos服务端出了问题，找到对应负责的同事，一起来看。我们还测了下，把服务A自己重启了下，发现重启也启动不起来了，同样是提示403，用户找不到。</p>\n<p>接下来，继续测试，当时是怀疑是不是密码有特殊字符导致的，然后nacos负责人，把我们的用户的密码重置了下，然后我们重试，发现可以了。</p>\n<p>最终的解决，就是靠：</p>\n<p>把用户的密码重置一下，也就是改一下密码就好了（但不是特殊字符的问题，我们试着改成了有特殊字符的密码，发现还是可以成功启动的）。</p>\n<p>这个事当时也就了了，没管了。</p>\n<h1 id=\"继续探索\">继续探索</h1>\n<h2 id=\"登录接口\">登录接口</h2>\n<p>今天空了后，感觉这个事情还是有点古怪，为什么密码重置后就好了，当时我就怀疑：nacos服务端内部估计有缓存，可能是缓存出问题了，然后重置密码这个动作，就导致缓存变得正常了。</p>\n<p>网上没找到特别匹配我这个案例的，翻了半天，看到有nacos源码解析的，于是我就想着代码拉下来看一下算了。</p>\n<p>线上的nacos版本不确定，但应该是2.2.2，因为我看了下开发环境就是这个版本。</p>\n<p>找了对应的源码：</p>\n<p><a href=\"https://github.com/alibaba/nacos/tree/2.2.2\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/nacos/tree/2.2.2</a></p>\n<p><a href=\"https://github.com/alibaba/nacos/releases/tag/2.2.0\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/nacos/releases/tag/2.2.0</a></p>\n<p>直接下了个zip包，idea里打开。</p>\n<p>全局搜索login\"，发现如下代码：</p>\n<p>com.alibaba.nacos.plugin.auth.impl.controller.UserController#login</p>\n<p><img alt=\"image-20260213095720124\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260213095720124.png\" /></p>\n<p><img alt=\"image-20260213095743794\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260213095743794.png\" /></p>\n<p>然后，这里有个根据用户名，查找用户详细信息的：</p>\n<p><img alt=\"image-20260213095803120\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260213095803120.png\" /></p>\n<p>下面这里，先是去一个缓存map里查询，如果没开启一个cacheEnabled的开关，则会继续去查数据库，以数据库的为准：</p>\n<pre><code class=\"language-java\">private Map&lt;String, User&gt; userMap = new ConcurrentHashMap&lt;&gt;();\n</code></pre>\n<p><img alt=\"image-20260213095851520\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260213095851520.png\" /></p>\n<p>我看了下，我们本地开发环境的开关，反正是默认打开的，我估计，线上也是这样，也就是说，是允许缓存的，这都年末了，运维放假了，不打扰了。</p>\n<p>具体的缓存开关是这个：</p>\n<pre><code class=\"language-java\">public static final String NACOS_CORE_AUTH_CACHING_ENABLED = \"nacos.core.auth.caching.enabled\";\n</code></pre>\n<p>配置文件中是开启的：</p>\n<pre><code class=\"language-shell\">[root@COMPASS-NACOS-1 nacos]# cat conf/application.properties |grep caching\n### Turn on/off caching of auth information. By turning on this switch, the update of auth information would have a 15 seconds delay.\nnacos.core.auth.caching.enabled=true\n</code></pre>\n<p>那就是了，应该就是缓存里的用户数据有问题。</p>\n<p>那为啥，重置密码就好了呢？</p>\n<h2 id=\"修改密码接口\">修改密码接口</h2>\n<p>修改密码这个，我们当时还测试了，自己改密码还不行，必须是nacos负责人那个管理账号改了才生效的。</p>\n<p>另外，我看了下，上面那个登录接口里，查用户的sql如下：</p>\n<pre><code class=\"language-java\">    public User findUserByUsername(String username) {\n        String sql = \"SELECT username,password FROM users WHERE username=? \";\n        return databaseOperate.queryOne(sql, new Object[] {username}, USER_ROW_MAPPER);\n    }\n</code></pre>\n<p>那修改密码，全局搜一下<code>update users</code>：</p>\n<p><img alt=\"image-20260213100640175\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260213100640175.png\" /></p>\n<pre><code class=\"language-shell\">com.alibaba.nacos.plugin.auth.impl.controller.UserController#updateUser\n</code></pre>\n<p><img alt=\"image-20260213100822326\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260213100822326.png\" /></p>\n<p>我们发现，改密码的接口，朴实无华，就是改下数据库，没涉及到清下缓存啥的：</p>\n<p><img alt=\"image-20260213100836452\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260213100836452.png\" /></p>\n<p>那就从那个缓存的map着手，看了下：</p>\n<pre><code class=\"language-shell\">com.alibaba.nacos.plugin.auth.impl.users.NacosUserDetailsServiceImpl#reload\n</code></pre>\n<p>结果发现了一个定时任务，这里每隔15s执行一次，从数据库加载user数据到缓存：</p>\n<p><img alt=\"image-20260213101021274\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260213101021274.png\" /></p>\n<p>那就理解了，改密码是只操作数据库；然后定时任务去数据库查询最新数据，放到缓存里，这样呢，缓存数据就和数据库数据一致了。</p>\n<p>另一个猜测：缓存每15秒从数据库同步，缓存数据有问题，是不是说明有问题的可能是数据库呢？也就是说，数据库里的用户数据出了问题，通过修改密码的方式才正常，然后15秒后，缓存里数据变得正常。</p>\n<p>至于数据库数据为啥出了问题，这个就不好找了，本篇就不探究了。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-13 10:19</span>&nbsp;\n<a href=\"https://www.cnblogs.com/grey-wolf\">三国梦回</a>&nbsp;\n阅读(<span id=\"post_view_count\">36</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MindIE 踩坑日记和一个web小工具",
      "link": "https://www.cnblogs.com/chumochen/p/19610004",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/chumochen/p/19610004\" id=\"cb_post_title_url\" title=\"发布于 2026-02-12 22:40\">\n    <span>MindIE 踩坑日记和一个web小工具</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h4 id=\"引言\">引言</h4>\n<p>最近在昇腾（Ascend）NPU 上部署大模型，官方主推的推理框架是 MindIE。功能确实完整，文档也写得挺“规范”，但实际用起来却存在不少“隐形门槛”。</p>\n<h4 id=\"踩坑总结\">踩坑总结</h4>\n<p><strong>1.  Docker容器权限与进程管理坑</strong></p>\n<ul>\n<li>必须加 --privileged 参数：否则容器里根本访问不到NPU设备，启动就报错。</li>\n<li>僵尸进程：不加 --init 的话，推理服务退出后，进程回收不了，直接导致后续推理服务启动失败，只能手动杀进程或重启容器服务。</li>\n</ul>\n<p><strong>2. 动态库找不到：libcsec.so: not found</strong><br />\n容器中进行推理会出现libcsec.so找不到的情况，需要手动设置 LD_LIBRARY_PATH 或写入 /etc/ld.so.conf.d/</p>\n<p><strong>3. 容器秒退</strong><br />\n官方镜像没有前台进程，docker run -d 启动后立刻退出，要么临时用 tail -f /dev/null 占位，或者自己封装启动脚本。</p>\n<p><strong>4. CANN高版本问题</strong><br />\n服务器的NPU驱动和CANN的高版本不一定匹配，如果安装高版本CANN会导致系统内核版本和NPU驱动版本不匹配，导致NPU无法识别</p>\n<p><strong>5. 接口兼容问题：</strong><br />\nvllm兼容OpenAI的推理接口/v1/completions，即使参数配置正确，也会提示“Messages token length must be in (0, 1048576], but got 0”错误。解决方案是切换为兼容TGI 0.9.4版本接口的/generate接口。</p>\n<p>还有一些其他的问题，比如<br />\n1 . 配置不可见、不可改：所有配置文件深藏容器内，修改需重建镜像或 exec 进入。<br />\n2 . 服务启动繁琐：每次都要手动激活 CANN 环境、设置变量。<br />\n3 . 缺乏可视化测试工具：只能靠 curl 调试。<br />\n4 . 部署流程不透明：日志分散，错误信息难定位。</p>\n<p>踩坑踩多了，人也麻了。加上后面要交给客户用，总不能每次都让人家开终端敲命令。<br />\n于是写了个纯 Web 界面的 MindIE 小助手。</p>\n<p>仓库地址：<a href=\"https://github.com/jclown/MyMindIEWebConsole\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/jclown/MyMindIEWebConsole</a><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1212315/202602/1212315-20260212223800963-1865678913.png\" /></p>\n<p><strong>1 可视化参数配置</strong><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1212315/202602/1212315-20260212223656466-1398105072.png\" /></p>\n<p><strong>2 模型管理和部署</strong><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1212315/202602/1212315-20260212223713695-1347474859.png\" /></p>\n<p><strong>3 对话测试界面</strong><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1212315/202602/1212315-20260212223737527-1308806231.png\" /></p>\n<p><strong>4 日志监测</strong><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1212315/202602/1212315-20260212223724078-1950248665.png\" /></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-12 22:40</span>&nbsp;\n<a href=\"https://www.cnblogs.com/chumochen\">少年知有</a>&nbsp;\n阅读(<span id=\"post_view_count\">42</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【EF Core】实体追踪——Entry中记录的数据",
      "link": "https://www.cnblogs.com/tcjiaan/p/19601119",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/tcjiaan/p/19601119\" id=\"cb_post_title_url\" title=\"发布于 2026-02-12 22:23\">\n    <span>【EF Core】实体追踪——Entry中记录的数据</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>这回终于可以 Free 了，刚好快过年了，工厂的机器也很人性化地坏了，需要供应商维修，不用测试项目了。所以老周也回家快活了几天。其实他们自己有开发团队，小改小测的他们完全可以自己弄，非要找老周麻烦。</p>\n<p>咱们接着上次的话题聊，上次老周给大伙伴们胡诌了一番有关实体状态追踪的基础。这一次咱们把注意力放到名为 EntityEntry 的对象上。咦，这名怎么看着这么奇葩？咱们不管它奇不奇葩，只要知道它负责保存实体对象的属性值就行了。</p>\n<p>毕竟实体类通常就是一个普通类，EF Core 需要状态追踪功能，总不能让开发者自己去跟踪吧，所以，EF 内部会用字典数据结构来保存实体的各个属性的值。字典是个好东西，啥都能放。有时候在写 Web API 时，一些返回 JSON 结构是动态的，为它们都定义一个类来序列化是不明智的，直接拼装 JSON 有点麻烦，这时候用字典就很爽。</p>\n<p>当实体从数据库查询出来时，EF 先为实体对象创建一个快照，表明它的原始数据。然后，当你对实体进行各种搔操作之后，调用一下&nbsp;DetectChanges 方法，它会扫描实体对象各个属性的值，并和当初创建的快照比较，以确定实体是否被修改（或删除）。</p>\n<p>为了让初学的大伙伴们好理解，咱们做个对比实验。</p>\n<p>假设有这么个实体类，它表示一本书的信息。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> Book\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> BookId { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span> Name { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span>; } = <span style=\"color: rgba(0, 0, 255, 1);\">null</span>!<span style=\"color: rgba(0, 0, 0, 1);\">;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span> ISBN { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span>; } = <span style=\"color: rgba(0, 0, 255, 1);\">null</span>!<span style=\"color: rgba(0, 0, 0, 1);\">;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span> Author { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span>; } = <span style=\"color: rgba(0, 0, 255, 1);\">null</span>!<span style=\"color: rgba(0, 0, 0, 1);\">;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> PubYear {  <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n}</span></pre>\n</div>\n<p>然后是实现数据库上下文。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> MyDb : DbContext\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> DbSet&lt;Book&gt; Books { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">protected</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n    {\n        optionsBuilder.UseSqlite(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">data source=shop.db</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">protected</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> OnModelCreating(ModelBuilder modelBuilder)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> bookEnt = modelBuilder.Entity&lt;Book&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 主键名称</span>\n        bookEnt.HasKey(x =&gt; x.BookId).HasName(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">PK_Book</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 字符串长度</span>\n        bookEnt.Property(a =&gt; a.Name).HasMaxLength(<span style=\"color: rgba(128, 0, 128, 1);\">65</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        bookEnt.Property(b </span>=&gt; b.Author).HasMaxLength(<span style=\"color: rgba(128, 0, 128, 1);\">20</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        bookEnt.Property(c </span>=&gt; c.ISBN).HasMaxLength(<span style=\"color: rgba(128, 0, 128, 1);\">15</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        bookEnt.ToTable(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">tb_Books</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, t =&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n        {\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 约束</span>\n            t.HasCheckConstraint(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">CK_Pubyear</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\\\"PubYear\\\" &gt;= 2020 AND \\\"PubYear\\\" &lt;= 2080</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        });\n    }\n}</span></pre>\n</div>\n<p>上面那些都是常规操作了，大家瞄两眼就行。下面代码创建数据库并插入一条数据。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">using</span> MyDb context = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\">();\ncontext.Database.EnsureCreated();</span><span style=\"color: rgba(0, 0, 0, 1);\">\n\n        <span style=\"background-color: rgba(255, 255, 0, 1);\">Book bb </span></span><span style=\"background-color: rgba(255, 255, 0, 1);\">= <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\">()\n</span></span>        <span style=\"background-color: rgba(255, 255, 0, 1);\"><span style=\"color: rgba(0, 0, 0, 1);\">{\n</span></span>            <span style=\"background-color: rgba(255, 255, 0, 1);\"><span style=\"color: rgba(0, 0, 0, 1);\">Name </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">回魂术</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n</span></span>            <span style=\"background-color: rgba(255, 255, 0, 1);\"><span style=\"color: rgba(0, 0, 0, 1);\">Author </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">老周</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n</span></span>            <span style=\"background-color: rgba(255, 255, 0, 1);\"><span style=\"color: rgba(0, 0, 0, 1);\">ISBN </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">551269882</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n</span></span>            <span style=\"background-color: rgba(255, 255, 0, 1);\"><span style=\"color: rgba(0, 0, 0, 1);\">PubYear </span>= <span style=\"color: rgba(128, 0, 128, 1);\">2028</span></span>\n        <span style=\"color: rgba(0, 0, 0, 1);\"><span style=\"background-color: rgba(255, 255, 0, 1);\">};</span>\ncontext.Books.Add(bb);\ncontext.SaveChanges();</span></pre>\n</div>\n<p>下面重头戏来了。咱们从数据库中查询出这条记录，然后改变 PubYear 属性的值。</p>\n<div class=\"cnblogs_code\">\n<pre> <span style=\"color: rgba(0, 0, 255, 1);\">var</span> theBook =<span style=\"color: rgba(0, 0, 0, 1);\"> context.Books.FirstOrDefault();\n </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (theBook == <span style=\"color: rgba(0, 0, 255, 1);\">null</span>) <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n\n </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 打印一次追踪</span>\n<span style=\"color: rgba(0, 0, 0, 1);\"> Console.WriteLine(context.ChangeTracker.ToDebugString());\n </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 更改属性</span>\n theBook.PubYear = <span style=\"color: rgba(128, 0, 128, 1);\">2030</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 再打印一次</span>\n Console.WriteLine(context.ChangeTracker.ToDebugString());</pre>\n</div>\n<p>ChangeTracker.ToDebugString 方法方便测试，可以直接观察框架对实体对象的更改记录。两次调用的输出如下：</p>\n<div class=\"cnblogs_code\">\n<pre>Book {BookId: <span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">} Unchanged\n    BookId: </span><span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\"> PK\n    Author: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">老周</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    ISBN: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">551269882</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    Name: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">回魂术</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    PubYear: </span><span style=\"color: rgba(128, 0, 128, 1);\">2028</span><span style=\"color: rgba(0, 0, 0, 1);\">\n\nBook {BookId: </span><span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">} Unchanged\n    BookId: </span><span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\"> PK\n    Author: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">老周</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    ISBN: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">551269882</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    Name: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">回魂术</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    PubYear: </span><span style=\"color: rgba(128, 0, 128, 1);\">2030</span> Originally <span style=\"color: rgba(128, 0, 128, 1);\">2028</span></pre>\n</div>\n<p>很明显，EF 并不知道咱们修改了实体，所以，调用一下&nbsp;DetectChanges 方法会触发一次扫描和比较。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 打印一次追踪</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">Console.WriteLine(context.ChangeTracker.ToDebugString());\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 更改属性</span>\ntheBook.PubYear = <span style=\"color: rgba(128, 0, 128, 1);\">2030</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n<strong><span style=\"background-color: rgba(255, 255, 0, 1);\">context.ChangeTracker.DetectChanges()</span></strong>;\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 再打印一次</span>\nConsole.WriteLine(context.ChangeTracker.ToDebugString());</pre>\n</div>\n<p>这次 EF 就知道实体被修改了。</p>\n<div class=\"cnblogs_code\">\n<pre>Book {BookId: <span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">} Unchanged\n    BookId: </span><span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\"> PK\n    Author: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">老周</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    ISBN: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">551269882</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    Name: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">回魂术</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    PubYear: </span><span style=\"color: rgba(128, 0, 128, 1);\">2028</span><span style=\"color: rgba(0, 0, 0, 1);\">\n\nBook {BookId: </span><span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">} <span style=\"background-color: rgba(255, 255, 0, 1);\">Modified</span>\n    BookId: </span><span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\"> PK\n    Author: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">老周</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    ISBN: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">551269882</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    Name: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">回魂术</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>\n    <span style=\"background-color: rgba(255, 255, 0, 1);\"><span style=\"color: rgba(0, 0, 0, 1);\">PubYear: </span><span style=\"color: rgba(128, 0, 128, 1);\">2030</span> Modified Originally <span style=\"color: rgba(128, 0, 128, 1);\">2028</span></span></pre>\n</div>\n<p>由于 PubYear 属性被更新，使得实体的状态变更为 Modified。</p>\n<p>那，为什么我调用 SaveChanges 方法时 EF 能顺利生成更新 SQL 呢，因为这个方法会先 DetectChanges，再根据实体的状态来生成更新语句。</p>\n<p>但是，如果你在代码里面把&nbsp;AutoDetectChangesEnabled 属性设置为 false，那么调用 SaveChanges 方法是不会更新的。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">using</span> MyDb context = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\">();\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 注意这一行</span>\ncontext.<strong><span style=\"background-color: rgba(255, 255, 0, 1);\">ChangeTracker.AutoDetectChangesEnabled = <span style=\"color: rgba(0, 0, 255, 1);\">false</span></span></strong><span style=\"color: rgba(0, 0, 0, 1);\">;\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 找出第一条记录</span>\nBook onebook =<span style=\"color: rgba(0, 0, 0, 1);\"> context.Books.First();\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 打印一次</span>\nConsole.WriteLine($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">{onebook.Name}, {onebook.PubYear}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 改一下年份</span>\nonebook.PubYear = <span style=\"color: rgba(128, 0, 128, 1);\">2031</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 提交更改</span>\n<span style=\"color: rgba(0, 0, 0, 1); background-color: rgba(0, 255, 0, 1);\">context.SaveChanges();\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 再查询一次</span>\nBook otherOne = context.Books.First(b =&gt; b.BookId ==<span style=\"color: rgba(0, 0, 0, 1);\"> onebook.BookId);\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 再次打印</span>\nConsole.WriteLine($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">{otherOne.Name}, {otherOne.PubYear}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 看看实体追踪信息</span>\nConsole.WriteLine(context.Entry(otherOne).DebugView.LongView);</pre>\n</div>\n<p>看看调试信息。</p>\n<div class=\"cnblogs_code\">\n<pre>回魂术, <span style=\"color: rgba(128, 0, 128, 1);\">2028</span><span style=\"color: rgba(0, 0, 0, 1);\">\n回魂术, </span><span style=\"color: rgba(128, 0, 128, 1);\">2031</span><span style=\"color: rgba(0, 0, 0, 1);\">\nBook {BookId: </span><span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">} <strong><span style=\"background-color: rgba(255, 0, 0, 1); color: rgba(255, 255, 255, 1);\">Unchanged</span></strong>\n    BookId: </span><span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\"> PK\n    Author: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">老周</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    ISBN: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">551269882</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    Name: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">回魂术</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>\n    <span style=\"background-color: rgba(0, 255, 0, 1);\"><span style=\"color: rgba(0, 0, 0, 1);\">PubYear: </span><span style=\"color: rgba(128, 0, 128, 1);\">2031</span> Originally <span style=\"color: rgba(128, 0, 128, 1);\">2028</span></span></pre>\n</div>\n<p>虽然 EF 追踪到 PubYear 属性被改为 2031，但注意它现在的状态是 Unchanged，所以 SaveChanges 不会更新数据库。</p>\n<p>大伙伴们，这里你千万别犯糊涂，把概念搞混了。<span style=\"background-color: rgba(255, 0, 0, 1); font-size: 15px; color: rgba(255, 255, 255, 1);\"><strong>AutoDetectChangesEnabled 属性设置为 false 只表明 EF 在 SaveChanges 方法中不会自动扫描检测实体的状态，可人家没说不会追踪实体的变更哟</strong></span>。</p>\n<p>你如果只是查询数据，不更改数据，不需要追踪实体状态（以提升不太明显的性能），那么你不应该关闭&nbsp;AutoDetectChangesEnabled 属性，而应该设置&nbsp;QueryTrackingBehavior 属性。</p>\n<div class=\"cnblogs_code\">\n<pre>context.ChangeTracker.QueryTrackingBehavior = <strong><span style=\"background-color: rgba(255, 255, 0, 1);\">QueryTrackingBehavior.NoTracking</span></strong>;</pre>\n</div>\n<p>禁用追踪后，更新数据库就跟 Sugar 一样，需要你开手动档。你只需要调用一下 Update 方法，将实体状态变为 Modified 就行，缺点是生成的 UPDATE 语句会把所有字段都 SET 一遍。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 找出第一条记录</span>\nBook onebook =<span style=\"color: rgba(0, 0, 0, 1);\"> context.Books.First();\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 打印一次</span>\nConsole.WriteLine($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">{onebook.Name}, {onebook.PubYear}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 改一下年份</span>\nonebook.PubYear = <span style=\"color: rgba(128, 0, 128, 1);\">2024</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 改变状态</span>\n<span style=\"color: rgba(0, 0, 0, 1);\"><strong><span style=\"background-color: rgba(255, 255, 0, 1);\">context.Update(onebook)</span></strong>;\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 提交更改</span>\ncontext.SaveChanges();</pre>\n</div>\n<p>那有没有方法让生成的 UPDATE 语句只 SET 被改动过的字段呢？大伙伴肯定猜到，老周既然这么写，那说明肯定有的。但老周希望你不要死记方法，而是思路。咱们好好想一下：EF 是不是在查询出数据到为实体建立快照，然后进行比较，以确定哪些属性（字段）被修改了。既然这样，咱们在查询实体后，手动给它弄个快照，然后再修改属性值，再提交更新不就完事了吗？好，想干就干。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 找出第一条记录</span>\nBook onebook =<span style=\"color: rgba(0, 0, 0, 1);\"> context.Books.First();\n\ncontext.Books.Attach(onebook);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 记录快照</span>\n<span style=\"color: rgba(0, 0, 0, 1);\"><strong><span style=\"background-color: rgba(255, 255, 0, 1);\">context.Entry(onebook).OriginalValues.SetValues(onebook)</span></strong>;\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 改一下年份</span>\nonebook.PubYear = <span style=\"color: rgba(128, 0, 128, 1);\">2021</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 打印一下状态信息</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">Console.WriteLine(context.Entry(onebook).DebugView.LongView);\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 严重警告：如果你把 AutoDetectChangesEnabled 属性设置为 false，那一定要调用下面这一行以扫描更改，否则只能更新个毛线\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 如果你没有改动 AutoDetectChangesEnabled 属性，它默认是打开的，那下面这行可以忽略\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> context.ChangeTracker.DetectChanges();\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 提交更改</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">context.SaveChanges();\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 再查询一次</span>\nBook otherOne = context.Books.First(b =&gt; b.BookId ==<span style=\"color: rgba(0, 0, 0, 1);\"> onebook.BookId);\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 再次打印状态信息</span>\nConsole.WriteLine(context.Entry(otherOne).DebugView.LongView);</pre>\n</div>\n<p>结果如下：</p>\n<div class=\"cnblogs_code\">\n<pre>Book {BookId: <span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">} Modified\n    BookId: </span><span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\"> PK\n    Author: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">老周</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    ISBN: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">551269882</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    Name: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">回魂术</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    PubYear: </span><span style=\"color: rgba(128, 0, 128, 1);\">2021</span> <strong><span style=\"background-color: rgba(255, 255, 0, 1);\">Modified Originally <span style=\"color: rgba(128, 0, 128, 1);\">2025</span></span></strong><span style=\"color: rgba(0, 0, 0, 1);\">\nBook {BookId: </span><span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">} Detached\n    BookId: </span><span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\"> PK\n    Author: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">老周</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    ISBN: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">551269882</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    Name: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">回魂术</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    PubYear: </span><span style=\"color: rgba(128, 0, 128, 1);\">2021</span></pre>\n</div>\n<p>生成的SQL语句如下：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">UPDATE</span> \"tb_Books\" <span style=\"background-color: rgba(255, 255, 0, 1);\"><span style=\"color: rgba(0, 0, 255, 1);\">SET</span> \"PubYear\" <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(0, 128, 0, 1);\">@p0</span></span>\n<span style=\"color: rgba(0, 0, 255, 1);\">WHERE</span> \"BookId\" <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(0, 128, 0, 1);\">@p1</span><span style=\"color: rgba(0, 0, 0, 1);\">\nRETURNING </span><span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span>;</pre>\n</div>\n<p>因为咱们设置为不追踪实体（QueryTrackingBehavior.NoTracking），所以在查询后，要用 Attach 方法把实体连接到追踪器，并设定状态为 Unchanged。然后，context.Entry 方法获取到 EntityEntry 对象（本文的主角出场了），再往&nbsp;OriginalValues 里面放点原材料（目前查询出来的值），这样快照就建立了。再然后，可以大胆地修改实体了，这时候 EF 能扫描到更改。由于咱们设置的不追踪，所以更新之后 EF 又把实体给甩了，于是实体状态又变回 Detached。</p>\n<p>说简单点，在手动档追踪下，实体的状态经历了 Detached -&gt; Unchanged -&gt; Modified -&gt; Detached 的生死轮回。</p>\n<p>-----------------------------------------------------------------------------------------------------------------------------------------------------------</p>\n<p>Entry 是“记录”的意思，EntityEntry 望文生义一下就是“实体记录”，它维护着实体的状态和各属性的值。一句话斯基总结：它是为实体追踪（跟踪）服务的，管理着实体相关的数据。</p>\n<p>在 80% 的使用场景下，我们不需要用 Entry 的，走常规流程，从数据库中查询数据，自动追踪，修改后提交就完事了。不过，像影子属性这种不在实体类中的成员，你咋办？影子属性的元数据在数据库模型中，而值是保存在 EntityEntry 中。下面咱们用一个实例来说明。</p>\n<p>咱们定义一个用户实体。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> User\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> Id { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span> Name { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span>; } = <span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\">.Empty;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span> LogName { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span>; } = <span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\">.Empty;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span>? Password {  <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n}</span></pre>\n</div>\n<p>然后是实现自己的数据库上下文。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> AppContext : DbContext\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> DbSet&lt;User&gt; Users { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">protected</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n    {\n        optionsBuilder.UseSqlite(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">data source=demo996.db</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">protected</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> OnModelCreating(ModelBuilder modelBuilder)\n    {\n        EntityTypeBuilder</span>&lt;User&gt; entUser = modelBuilder.Entity&lt;User&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 常规配置</span>\n        entUser.Property(x =&gt; x.Name).HasColumnName(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">u_name</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        entUser.Property(w </span>=&gt; w.LogName).HasColumnName(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">log_name</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        entUser.Property(t </span>=&gt; t.Password).HasColumnName(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">u_pwd</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        entUser.Property(m </span>=&gt; m.Id).HasColumnName(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">u_id</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        entUser.HasKey(x </span>=&gt; x.Id).HasName(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">PK_Userid</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 影子属性</span>\n        <strong><span style=\"background-color: rgba(255, 255, 0, 1);\">entUser.Property&lt;DateTime?&gt;(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">LastLog</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>).HasColumnName(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">_last_log</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span></span></strong><span style=\"color: rgba(0, 0, 0, 1);\"><strong><span style=\"background-color: rgba(255, 255, 0, 1);\">)</span></strong>;\n    }\n}</span></pre>\n</div>\n<p>User 实体有一个影子属性 LastLog，记录用户上一次登录的时间。在实体中不需要使用，或不希望被访问的属性，在建立数据库模型时可以作为影子属性。</p>\n<p>在查询表达式中可以使用 EF.Property 方法来获取影子属性的值，EF 类中的方法成员都会抛出异常，没有真正实现，而是通过表达式树来翻译处理。因此，在非查询语句中访问影子属性，或要修改影子属性就不能使用 EF 类了。影子属性的值保存在 Entry 中，可以用以下代码来设置 LastLog 属性的值。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 先查询出实体</span>\nUser? u = context.Users.FirstOrDefault(x =&gt; x.Name == <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Teto</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (u <span style=\"color: rgba(0, 0, 255, 1);\">is</span> <span style=\"color: rgba(0, 0, 255, 1);\">null</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n{\n    Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">用户不存在</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n}\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 通过 Entry 修改影子属性</span>\nDateTime theTime =<span style=\"color: rgba(0, 0, 0, 1);\"> DateTime.Now;\ncontext.<strong><span style=\"background-color: rgba(255, 255, 0, 1);\">Entry(u).Property(</span></strong></span><strong><span style=\"background-color: rgba(255, 255, 0, 1);\"><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">LastLog</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>).CurrentValue =</span></strong><span style=\"color: rgba(0, 0, 0, 1);\"><strong><span style=\"background-color: rgba(255, 255, 0, 1);\"> theTime</span></strong>;\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 打印追踪信息</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">Console.WriteLine(context.ChangeTracker.DebugView.LongView);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 提交保存</span>\ncontext.SaveChanges();</pre>\n</div>\n<p>直接使用 Entry 修改属性值会自动应用实体的状态。User 实体变为 Modeified 状态。</p>\n<div class=\"cnblogs_code\">\n<pre>User {Id: <span style=\"color: rgba(128, 0, 128, 1);\">3</span><span style=\"color: rgba(0, 0, 0, 1);\">} <strong><span style=\"background-color: rgba(255, 255, 0, 1);\">Modified</span></strong>\n    Id: </span><span style=\"color: rgba(128, 0, 128, 1);\">3</span><span style=\"color: rgba(0, 0, 0, 1);\"> PK\n    LastLog: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 128, 0, 1);\">2026/2/12 18:25:01</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span> Modified Originally <span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 128, 0, 1);\">2026/2/12 17:41:20</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    LogName: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 128, 0, 1);\">teto</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    Name: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 128, 0, 1);\">Teto</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    Password: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 128, 0, 1);\">balabala</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span></pre>\n</div>\n<p>想验证是否更新数据库，可以查询一遍整个表。</p>\n<div class=\"cnblogs_code\">\n<pre>using(var context =<span style=\"color: rgba(0, 0, 0, 1);\"> new AppContext())\n{\n    Console.WriteLine(</span><span style=\"color: rgba(128, 128, 128, 1);\">\"</span><span style=\"color: rgba(128, 128, 128, 1);\">\\n------ 所有用户 ------\");</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    foreach(User usr in context.Users)\n    {\n        Console.WriteLine($</span><span style=\"color: rgba(128, 128, 128, 1);\">\"</span><span style=\"color: rgba(128, 128, 128, 1);\">\"\"</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">            用户ID：{usr.Id}\n            用户名：{usr.Name}\n            上次登录时间：{context.Entry(usr).Property(</span><span style=\"color: rgba(128, 128, 128, 1);\">\"</span><span style=\"color: rgba(128, 128, 128, 1);\">LastLog\").CurrentValue}</span>\n            <span style=\"color: rgba(128, 128, 128, 1);\">\"</span><span style=\"color: rgba(128, 128, 128, 1);\">\"\");</span>\n        Console.Write(<span style=\"color: rgba(128, 128, 128, 1);\">\"</span><span style=\"color: rgba(128, 128, 128, 1);\">\\n\");</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    }\n}</span></pre>\n</div>\n<div class=\"cnblogs_code\">\n<pre>------ 所有用户 ------<span style=\"color: rgba(0, 0, 0, 1);\">\n用户ID：</span><span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">\n用户名：Kaito\n上次登录时间：</span><span style=\"color: rgba(128, 0, 128, 1);\">2026</span>/<span style=\"color: rgba(128, 0, 128, 1);\">2</span>/<span style=\"color: rgba(128, 0, 128, 1);\">12</span> <span style=\"color: rgba(128, 0, 128, 1);\">17</span>:<span style=\"color: rgba(128, 0, 128, 1);\">40</span>:<span style=\"color: rgba(128, 0, 128, 1);\">45</span><span style=\"color: rgba(0, 0, 0, 1);\">\n\n用户ID：</span><span style=\"color: rgba(128, 0, 128, 1);\">2</span><span style=\"color: rgba(0, 0, 0, 1);\">\n用户名：Gumi\n上次登录时间：</span><span style=\"color: rgba(128, 0, 128, 1);\">2026</span>/<span style=\"color: rgba(128, 0, 128, 1);\">2</span>/<span style=\"color: rgba(128, 0, 128, 1);\">12</span> <span style=\"color: rgba(128, 0, 128, 1);\">17</span>:<span style=\"color: rgba(128, 0, 128, 1);\">40</span>:<span style=\"color: rgba(128, 0, 128, 1);\">13</span><span style=\"color: rgba(0, 0, 0, 1);\">\n\n用户ID：</span><span style=\"color: rgba(128, 0, 128, 1);\">3</span><span style=\"color: rgba(0, 0, 0, 1);\">\n用户名：Teto\n上次登录时间：</span><span style=\"color: rgba(128, 0, 128, 1);\">2026</span>/<span style=\"color: rgba(128, 0, 128, 1);\">2</span>/<span style=\"color: rgba(128, 0, 128, 1);\">12</span> <span style=\"color: rgba(128, 0, 128, 1);\">18</span>:<span style=\"color: rgba(128, 0, 128, 1);\">25</span>:<span style=\"color: rgba(128, 0, 128, 1);\">01</span></pre>\n</div>\n<p>上面的做法要先查询一次，然后更新，即数据库往返两回。99.99965% 的情况下也没啥影响的，而且很多时候用户编辑数据时确实得先查后改的，毕竟编辑界面你得先显示现有的数据才方便用户去修改。如果你不想 SELECT 只想直接 UPDATE 也可以的。</p>\n<div class=\"cnblogs_code\">\n<pre> <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 直接实例化\n </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Id 是主键，必须赋值，明确要更新的记录</span>\n User data = <span style=\"color: rgba(0, 0, 255, 1);\">new</span>() { <strong><span style=\"background-color: rgba(255, 255, 0, 1);\">Id = <span style=\"color: rgba(128, 0, 128, 1);\">2</span></span></strong><span style=\"color: rgba(0, 0, 0, 1);\"> };\n </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> entry =<span style=\"color: rgba(0, 0, 0, 1);\"> context.Entry(data);\n </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 标记实体的状态为已修改</span>\n entry.State =<span style=\"color: rgba(0, 0, 0, 1);\"><span style=\"background-color: rgba(0, 255, 0, 1);\"> EntityState.Modified</span>;\n </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 先改变实体的状态再去改变某个属性的状态\n </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 因为在设置实体为 Modified 时会把所有属性都设置为 Modified\n </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 先设置实体再设置属性成员就不会被覆盖</span>\n <span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> p <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> entry.Properties)\n {\n     </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (p.Metadata.Name == <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">LastLog</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n     {\n         </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 只修改这个属性</span>\n         p.<span style=\"background-color: rgba(0, 255, 0, 1);\">IsModified = <span style=\"color: rgba(0, 0, 255, 1);\">true</span></span><span style=\"color: rgba(0, 0, 0, 1);\">;\n         p.CurrentValue </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> DateTime.Now;\n     }\n     </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\">\n     {\n         </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 其他属性不改，标记为非修改状态</span>\n         p.<span style=\"background-color: rgba(0, 255, 0, 1);\">IsModified = <span style=\"color: rgba(0, 0, 255, 1);\">false</span></span><span style=\"color: rgba(0, 0, 0, 1);\">;\n     }\n }\n\n </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 打印追踪信息</span>\n<span style=\"color: rgba(0, 0, 0, 1);\"> Console.WriteLine(context.ChangeTracker.DebugView.LongView);\n </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 提交保存</span>\n context.SaveChanges();</pre>\n</div>\n<p>在改变实体状态时，先设置整个实体为 Modified，此时由于没有初始快照做比较，实体的所有属性（不含主键）都被标记为 Modified，如果这样更新数据库的话，会把 Name、LogName、Password 等属性都更改为 null 了。所以，咱们在设置实体为 Modified 后，还要对各个属性做做手脚。用 foreach 枚举各个属性，只有 LastLog 属性才设置为 Modified，其他的属性设置为未更改，这样发送到数据库的 UPDATE 语句只会 SET LastLog 属性。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">UPDATE</span> \"Users\" <span style=\"color: rgba(0, 0, 255, 1);\">SET</span> \"_last_log\" <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(0, 128, 0, 1);\">@p0</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">WHERE</span> \"u_id\" <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(0, 128, 0, 1);\">@p1</span><span style=\"color: rgba(0, 0, 0, 1);\">\nRETURNING </span><span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span>;</pre>\n</div>\n<p>由于咱们要更新的是影子属性，不能使用 ExecuteUpdate 这样的便捷方法。</p>\n<p>本文到此结束。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-12 22:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/tcjiaan\">东邪独孤</a>&nbsp;\n阅读(<span id=\"post_view_count\">38</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "AiReader：一个不联网的 AI 阅读助手，让你的算力为你服务",
      "link": "https://www.cnblogs.com/lissajous/p/19608767",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lissajous/p/19608767\" id=\"cb_post_title_url\" title=\"发布于 2026-02-12 15:54\">\n    <span>AiReader：一个不联网的 AI 阅读助手，让你的算力为你服务</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"AiReader：一个不联网的 AI 阅读助手，让你的算力为你服务\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3618712/202602/3618712-20260212155315495-120542706.png\" />\n        AiReader ：一个内置 AI 的桌面阅读器，所有 AI 推理都在你本地的 CPU/GPU 上运行。\n不需要联网，不需要注册，不需要 API Key。安装后首次配置下载一个 AI 模型（几百 MB 到几 GB），之后拔掉网线也能用。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"你的文档正在被谁阅读\">你的文档，正在被谁阅读？</h2>\n<p>每次你把一篇论文扔进在线翻译工具，每次你让 AI 帮你解读一份合同——你的文档都被上传到了某家公司的服务器上。</p>\n<p>也许你觉得无所谓。但如果有一种方式，<strong>AI 一样好用，但文档永远不离开你的电脑呢？</strong></p>\n<p>这就是 AiReader 在做的事。</p>\n<hr />\n<h2 id=\"aireader-是什么\">AiReader 是什么</h2>\n<p>一句话：<strong>一个内置 AI 的桌面阅读器，所有 AI 推理都在你本地的 CPU/GPU 上运行。</strong></p>\n<p>不需要联网，不需要注册，不需要 API Key。安装后首次配置下载一个 AI 模型（几百 MB 到几 GB），之后拔掉网线也能用。</p>\n<p>它支持阅读 <strong>PDF、EPUB、Markdown、TXT</strong> 四种格式，内置以下 AI 能力：</p>\n<hr />\n<h3 id=\"-选中即译\">📖 选中即译</h3>\n<p>在文档中选中任意文字，AI 立即翻译。支持三种模式：</p>\n<ul>\n<li><strong>直译</strong>：保留原文结构</li>\n<li><strong>意译</strong>：更自然的目标语言表达</li>\n<li><strong>白话</strong>：用最简单的话解释</li>\n</ul>\n<p>自动识别中英文方向。不是逐词机翻，是理解上下文后的翻译。</p>\n<h3 id=\"-文法解释\">🔍 文法解释</h3>\n<p>选中一个复杂句子，AI 拆解句子结构：主谓宾、从句关系、关键词汇用法。</p>\n<p>比起翻译，这才是真正帮你「读懂」一门语言的工具。</p>\n<h3 id=\"-上下文对话\">💬 上下文对话</h3>\n<p>选中一段内容，然后像和 ChatGPT 一样追问。可以锁定上下文反复深入，对话历史按文档自动保存。</p>\n<h3 id=\"-智能笔记\">📝 智能笔记</h3>\n<p>翻译、解释、对话内容都可以一键保存为笔记。笔记关联文档，支持 Markdown 导出。</p>\n<h3 id=\"-离线词典\">📚 离线词典</h3>\n<p>内置 ECDICT（英汉）+ CC-CEDICT（汉英），双击任意单词弹窗查词，无需联网。</p>\n<p><img alt=\"select-translate\" class=\"lazyload\" /></p>\n<hr />\n<h2 id=\"它凭什么能在本地跑-ai\">它凭什么能在本地跑 AI？</h2>\n<p>底层用的是 <strong>llama.cpp</strong> —— 目前最成熟的开源本地大模型推理引擎，被全球数百万开发者使用。内置的模型是 <strong>Qwen3 系列</strong>（通义千问），从 0.6B 到 32B 参数量都有。</p>\n<p>在不同硬件上的表现：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">你的硬件</th>\n<th style=\"text-align: left;\">能跑什么</th>\n<th style=\"text-align: left;\">体验</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">游戏笔记本（RTX 3060+）</td>\n<td style=\"text-align: left;\">8B 模型</td>\n<td style=\"text-align: left;\">和 ChatGPT 一样流畅</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">普通笔记本（无独显）</td>\n<td style=\"text-align: left;\">1.7B-4B 模型</td>\n<td style=\"text-align: left;\">流畅，翻译质量够用</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">办公电脑</td>\n<td style=\"text-align: left;\">0.6B 模型</td>\n<td style=\"text-align: left;\">可用，简单翻译没问题</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Mac M 系列芯片</td>\n<td style=\"text-align: left;\">4B-8B 模型</td>\n<td style=\"text-align: left;\">Metal 加速，非常流畅</td>\n</tr>\n</tbody>\n</table>\n<p><strong>你不需要了解这些细节。</strong> 首次启动时，应用会自动检测你的硬件、跑基准测试、推荐最合适的模型，全程一键完成。</p>\n<hr />\n<h2 id=\"三个平台都能用\">三个平台都能用</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">平台</th>\n<th style=\"text-align: left;\">GPU 加速</th>\n<th style=\"text-align: left;\">安装包</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>Windows</strong> x64</td>\n<td style=\"text-align: left;\">NVIDIA (CUDA) · AMD/Intel (Vulkan)</td>\n<td style=\"text-align: left;\"><code>.exe</code> 安装包</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>macOS</strong> ARM / Intel</td>\n<td style=\"text-align: left;\">Metal</td>\n<td style=\"text-align: left;\"><code>.dmg</code></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Linux</strong> x64</td>\n<td style=\"text-align: left;\">Vulkan</td>\n<td style=\"text-align: left;\"><code>.AppImage</code> / <code>.deb</code></td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h2 id=\"完全免费完全开源\">完全免费，完全开源</h2>\n<ul>\n<li><strong>MIT 协议</strong>：你可以自由使用、修改、分发</li>\n<li><strong>无付费版</strong>：所有功能免费</li>\n<li><strong>无广告</strong>：没有任何广告和推广</li>\n<li><strong>无数据收集</strong>：不收集任何用户数据</li>\n<li><strong>代码公开</strong>：每一行代码都在 GitHub 上，欢迎审查</li>\n</ul>\n<hr />\n<h2 id=\"谁适合用\">谁适合用</h2>\n<ul>\n<li>📄 经常阅读英文论文、技术文档、外文书籍的人</li>\n<li>🔒 处理敏感文件（商业合同、内部报告、未发表研究）不想上传云端的人</li>\n<li>🎓 正在学外语，需要文法拆解而不只是翻译的学生</li>\n<li>🖥️ 想体验本地大模型但不知道从哪里开始的技术爱好者</li>\n<li>💡 信奉\"我的数据我做主\"的人</li>\n</ul>\n<hr />\n<h2 id=\"怎么获取\">怎么获取</h2>\n<h3 id=\"下载\">下载</h3>\n<p>GitHub Releases 页面下载对应平台安装包：</p>\n<p>🔗 <strong><a href=\"https://github.com/LissajousX/aireader/releases\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/LissajousX/aireader/releases</a></strong></p>\n<h3 id=\"安装\">安装</h3>\n<ul>\n<li><strong>Windows</strong>：双击 <code>.exe</code> 安装包，一路下一步</li>\n<li><strong>macOS</strong>：打开 <code>.dmg</code>，拖入应用程序文件夹\n<blockquote>\n<p>⚠️ macOS 版本暂未完成 Apple 签名认证，首次打开需要：右键点击 App → 选择「打开」→ 确认。或在终端执行 <code>xattr -cr /Applications/Aireader.app</code></p>\n</blockquote>\n</li>\n<li><strong>Linux</strong>：运行 <code>.AppImage</code> 或安装 <code>.deb</code> 包</li>\n</ul>\n<h3 id=\"首次使用\">首次使用</h3>\n<p>启动后跟随引导向导：选择语言 → 设置存储路径 → 一键配置 AI → 开始阅读。</p>\n<p>整个过程 3-5 分钟（主要是下载模型的时间）。</p>\n<hr />\n<h2 id=\"一些你可能会问的问题\">一些你可能会问的问题</h2>\n<p><strong>Q: 翻译质量和在线工具比怎么样？</strong><br />\nA: 4B 以上的模型，日常翻译质量接近 GPT-3.5 水平。8B 模型在大多数场景下和 GPT-4 差距不大。专业术语密集的场景（如医学、法律），建议用更大的模型或接入云端 API。</p>\n<p><strong>Q: 只能用内置模型吗？</strong><br />\nA: 不是。你也可以连接 Ollama（本地跑更大的模型）或任何 OpenAI 兼容的 API（如 DeepSeek）。</p>\n<p><strong>Q: 电脑配置不够怎么办？</strong><br />\nA: 最低 4GB 内存 + 任意 CPU 就能跑 0.6B 模型。如果觉得质量不够，可以接 Ollama 或云端 API 作为补充。</p>\n<p><strong>Q: 支持中文文档吗？</strong><br />\nA: 支持。Qwen3 模型本身就擅长中英双语。界面也支持中英文切换。</p>\n<p><strong>Q: 安全吗？代码可信吗？</strong><br />\nA: MIT 开源，全部代码公开。你可以自己审查，也可以自己编译。没有混淆，没有后门。</p>\n<hr />\n<h2 id=\"让你的算力为你服务\">让你的算力为你服务</h2>\n<p>你的电脑里有一颗强大的处理器，可能还有一块不便宜的显卡。大多数时候，它们都在闲着。</p>\n<p>AiReader 让这些算力做它们最擅长的事：<strong>帮你阅读、翻译、理解、思考。</strong></p>\n<p>而且，完全在你自己的电脑上。</p>\n<hr />\n<p><strong>🔗 GitHub: <a href=\"https://github.com/LissajousX/aireader\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/LissajousX/aireader</a></strong></p>\n<p>如果觉得有用，一个 ⭐ Star 就是最好的支持。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-12 15:54</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lissajous\">李萨如</a>&nbsp;\n阅读(<span id=\"post_view_count\">245</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "AI 画图全家桶来了！这回想自己手绘图都难了",
      "link": "https://www.cnblogs.com/chengxy-nds/p/19610998",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/chengxy-nds/p/19610998\" id=\"cb_post_title_url\" title=\"发布于 2026-02-13 09:48\">\n    <span>AI 画图全家桶来了！这回想自己手绘图都难了</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p><strong>大家好，我是小富～</strong></p>\n<p>前几天我不是分享了如何零成本搭建 <strong>next-ai-draw-io</strong>，教大家用 AI 生成 draw.io 风格的架构图。后台反响还不错，看来大家对手绘架构图真的是苦之久矣。</p>\n<p><img alt=\"\" src=\"http://fire-blog.oss-cn-beijing.aliyuncs.com/20251229-160034.gif\" /></p>\n<p>但在日常写文章时，我发现很多读者更偏爱那种手绘感十足的 <strong>Excalidraw</strong> 风格，就是下面这种，逼格高、视觉美，能让文章瞬间显得高级起来：</p>\n<p><img alt=\"\" src=\"http://fire-blog.oss-cn-beijing.aliyuncs.com//images/20260203151400.png\" /></p>\n<p>我原本在琢磨，能不能用 Gemini Pro 给自己搓一个 AI 绘图整合平台，把 draw.io 和 Excalidraw 全揉进去。</p>\n<p>结果去 GitHub 一搜，好家伙，已经有大佬把我想做的给做了！这个开源项目简直是为我这种懒癌博主量身定制的：<strong>Mermaid、draw.io、Excalidraw</strong> 三大王牌风格全部支持。</p>\n<p>回头再看看以前为了画个原理图熬夜的样子，真的感觉是在浪费生命啊！</p>\n<h4 id=\"ai-draw-nexus-ai-绘图全家桶\">AI Draw Nexus AI 绘图全家桶</h4>\n<p><strong>GitHub 地址</strong>：<code>https://github.com/hkxiaoyao/ai-draw-nexus</code></p>\n<p><strong>在线体验</strong>：<code>https://ai-draw-nexus.aizhi.site/</code></p>\n<p>我挨个试了一遍，大家感受下这输出质量：</p>\n<p><strong>1. Excalidraw 风格</strong></p>\n<p>输入: HTTP 长轮询原理图，生成的逻辑线条清晰，手绘质感爆棚。</p>\n<p><img alt=\"\" src=\"http://fire-blog.oss-cn-beijing.aliyuncs.com//images/20260203152428.png\" /></p>\n<p><strong>2. Draw.io 风格</strong></p>\n<p>我之前很多的系统架构、流程图都是这个风格，现在 AI 加持真的太方便了。</p>\n<p><img alt=\"\" src=\"http://fire-blog.oss-cn-beijing.aliyuncs.com//images/20260203153031.png\" /></p>\n<p><strong>3. Mermaid 风格</strong></p>\n<p>写 Markdown 就更简单了一秒出图。</p>\n<p><img alt=\"\" src=\"http://fire-blog.oss-cn-beijing.aliyuncs.com//images/20260203153451.png\" /></p>\n<p>这不是功能阉割版，而是全量版！可以在 AI 生成的基础上，直接手动微调。</p>\n<h4 id=\"快速上手\">快速上手</h4>\n<p>如果你想本地运行，这个基于 Next.js 的前端项目安装起来也非常简单：</p>\n<pre><code class=\"language-shell\"># 1. 克隆项目\ngit clone https://github.com/hkxiaoyao/ai-draw-nexus\ncd ai-draw-nexus\n\n# 2. 安装依赖 (推荐用 pnpm)\npnpm install\n\n# 3. 开启生产力大门\npnpm dev\n</code></pre>\n<p>不过，目前的在线版本每天有 10 次免费配额，这也很正常毕竟 API 线上的费用确实贵（上次我那个免费工具被大家两天就用欠费了，哈哈 😂）。</p>\n<p><img alt=\"\" src=\"http://fire-blog.oss-cn-beijing.aliyuncs.com//images/20260203152800.png\" /></p>\n<p>现在仅支持 <strong>OpenAI</strong> 和 <strong>Anthropic</strong> 两大模型。如果你有自己的 Key，建议本地搭一个，那才是真正的绘图自由！</p>\n<p>好了，下期见～</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-13 09:48</span>&nbsp;\n<a href=\"https://www.cnblogs.com/chengxy-nds\">程序员小富</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一款Go语言Gin框架DDD脚手架，适合快速搭建项目",
      "link": "https://www.cnblogs.com/letjs/p/19610915",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/letjs/p/19610915\" id=\"cb_post_title_url\" title=\"发布于 2026-02-13 09:19\">\n    <span>一款Go语言Gin框架DDD脚手架，适合快速搭建项目</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"一款go语言gin框架ddd脚手架适合快速搭建项目\">一款Go语言Gin框架DDD脚手架，适合快速搭建项目</h1>\n<blockquote>\n<p>一个开箱即用的 DDD（领域驱动设计）Go 脚手架，基于 Gin + RocketMQ，包含双数据库、统一响应、中间件与事件驱动示例。</p>\n</blockquote>\n<h2 id=\"这是什么\">这是什么</h2>\n<p>Gin-Framework-DDD 是一个面向 Go 语言的 DDD 工程脚手架，帮你快速搭建符合 DDD 分层规范的 Web 服务。项目内置用户与订单示例、领域事件与 RocketMQ 生产/消费、邮件通知示例、统一响应与中间件，适合作为团队工程模板或教学示例。</p>\n<h2 id=\"为什么要用ddd\">为什么要用DDD？</h2>\n<p>很多人认为 Go 语言没必要用 DDD，毕竟它和 Python、JS 一样轻巧灵活，用 MVC 就足够了。确实，大多数场景下 MVC 完全够用。工程化无非是把接口处理、业务逻辑、数据处理区分开，让各部分各司其职，方便维护和扩展。DDD 相对更适合中大型项目：如果项目有几十个模块、上百个接口，用 DDD 设计会更合适；模块少、接口不多的话，简单分层就够了。</p>\n<p>总之，是否采用 DDD 和语言无关，只跟业务规模有关。一个东西变复杂了，就需要用一些机制去规范它，才能更好掌控。</p>\n<p>源码地址：<a href=\"https://github.com/microwind/design-patterns/tree/main/practice-projects/gin-ddd\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/microwind/design-patterns/tree/main/practice-projects/gin-ddd</a></p>\n<p>项目目录：<code>gin-ddd/</code></p>\n<h2 id=\"核心特点\">核心特点</h2>\n<ul>\n<li>严格 DDD 四层架构：领域层、应用层、基础设施层、接口层</li>\n<li>Gin Web 框架：高性能 HTTP 服务</li>\n<li>事件驱动：领域事件 + RocketMQ 生产者/消费者</li>\n<li>双数据库支持：用户库 + 订单库可独立配置（默认 MySQL + PostgreSQL）</li>\n<li>统一响应格式：Response 封装，错误码集中管理</li>\n<li>全局中间件：日志、恢复、跨域</li>\n<li>可选邮件通知：订单创建事件驱动 SMTP 邮件发送</li>\n</ul>\n<h2 id=\"技术栈\">技术栈</h2>\n<table>\n<thead>\n<tr>\n<th>技术</th>\n<th>版本</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Go</td>\n<td>1.21+</td>\n<td>语言版本</td>\n</tr>\n<tr>\n<td>Gin</td>\n<td>1.9+</td>\n<td>HTTP 框架</td>\n</tr>\n<tr>\n<td>RocketMQ</td>\n<td>5.3+</td>\n<td>事件消息队列</td>\n</tr>\n<tr>\n<td>MySQL</td>\n<td>8.0+</td>\n<td>用户库默认</td>\n</tr>\n<tr>\n<td>PostgreSQL</td>\n<td>14+</td>\n<td>订单库默认</td>\n</tr>\n<tr>\n<td>YAML</td>\n<td>-</td>\n<td>配置文件格式</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"工程结构\">工程结构</h2>\n<h3 id=\"工程结构图\">工程结构图</h3>\n<div class=\"mermaid\">flowchart TB\n    subgraph 接口层\n        Handler[HTTP Handler / 路由]\n    end\n\n    subgraph 应用层\n        AppService[应用服务]\n    end\n\n    subgraph 领域层\n        DomainService[领域服务]\n        Model[聚合根/实体]\n        RepoInterface[仓储接口]\n        NotificationInterface[通知接口]\n    end\n\n    subgraph 基础设施层\n        RepoImpl[仓储实现]\n        Mail[邮件服务]\n        MQ[消息队列]\n        DB[(数据库)]\n    end\n\n    Handler --&gt; AppService\n    AppService --&gt; DomainService\n    AppService --&gt; RepoInterface\n    DomainService --&gt; Model\n    DomainService --&gt; NotificationInterface\n    RepoInterface -.实现.-&gt; RepoImpl\n    NotificationInterface -.实现.-&gt; Mail\n    RepoImpl --&gt; DB\n    AppService -.发布事件.-&gt; MQ\n</div><h3 id=\"工程结构列表\">工程结构列表</h3>\n<pre><code>gin-ddd/\n├── cmd/server/main.go                            # 启动入口，装配各层并启动 HTTP + MQ\n├── config/config.yaml                            # 应用配置\n├── docs/init.sql                                 # MySQL 初始化脚本（示例）\n├── internal/\n│   ├── domain/                                   # 领域层\n│   │   ├── model/\n│   │   │   ├── order/order.go                    # 订单聚合根\n│   │   │   └── user/user.go                      # 用户聚合根\n│   │   ├── repository/                           # 仓储接口\n│   │   │   ├── order/order_repository.go\n│   │   │   └── user/user_repository.go\n│   │   ├── event/                                # 领域事件\n│   │   │   ├── domain_event.go\n│   │   │   ├── order_event.go\n│   │   │   ├── user_event.go\n│   │   │   └── event_publisher.go\n│   │   ├── notification/mail_service.go          # 通知领域接口（邮件）\n│   │   └── service/                              # 领域服务（预留）\n│   ├── application/                              # 应用层\n│   │   ├── dto/\n│   │   │   ├── order/order_dto.go\n│   │   │   └── user/user_dto.go\n│   │   └── service/\n│   │       ├── order/order_service.go            # 订单应用服务（发布事件）\n│   │       └── user/user_service.go              # 用户应用服务\n│   ├── infrastructure/                           # 基础设施层\n│   │   ├── config/                               # 配置与 DB 初始化\n│   │   ├── persistence/                          # 仓储实现\n│   │   │   ├── order/order_repository_impl.go\n│   │   │   └── user/user_repository_impl.go\n│   │   ├── mq/                                   # RocketMQ 实现\n│   │   │   ├── rocketmq_producer.go\n│   │   │   └── rocketmq_consumer.go\n│   │   ├── mail/                                 # SMTP 邮件实现\n│   │   ├── middleware/                           # Gin 中间件\n│   │   ├── common/response.go                    # 统一响应\n│   │   └── constants/error_code.go               # 错误码\n│   └── interfaces/                               # 接口层\n│       ├── handler/                              # HTTP 处理器\n│       ├── router/                               # 路由配置\n│       └── vo/                                   # 请求/响应对象\n└── pkg/utils/                                    # 日志等工具\n</code></pre>\n<h2 id=\"各层职责说明\">各层职责说明</h2>\n<table>\n<thead>\n<tr>\n<th>层级</th>\n<th>位置</th>\n<th>职责</th>\n<th>关键原则</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>领域层</td>\n<td><code>internal/domain/</code></td>\n<td>领域模型、规则与事件</td>\n<td>不依赖框架、业务逻辑内聚</td>\n</tr>\n<tr>\n<td>应用层</td>\n<td><code>internal/application/</code></td>\n<td>编排领域对象、事务边界</td>\n<td>薄而清晰，不实现业务规则</td>\n</tr>\n<tr>\n<td>基础设施层</td>\n<td><code>internal/infrastructure/</code></td>\n<td>DB、MQ、邮件等技术细节</td>\n<td>向上提供实现，细节下沉</td>\n</tr>\n<tr>\n<td>接口层</td>\n<td><code>internal/interfaces/</code></td>\n<td>HTTP 请求/响应与路由</td>\n<td>处理外部交互，不含业务规则</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"快速开始\">快速开始</h2>\n<h3 id=\"1-环境准备\">1. 环境准备</h3>\n<ul>\n<li>Go 1.21+</li>\n<li>MySQL 8.0+ 与 PostgreSQL 14+（或自行选择其一）</li>\n<li>RocketMQ 5.3+（可选）</li>\n</ul>\n<h3 id=\"2-初始化数据库\">2. 初始化数据库</h3>\n<p>默认配置使用双数据库：</p>\n<ul>\n<li>用户库：MySQL</li>\n<li>订单库：PostgreSQL</li>\n</ul>\n<p>MySQL 用户库示例（可直接用 <code>docs/init.sql</code> 作为起点）：</p>\n<pre><code class=\"language-sql\">CREATE DATABASE IF NOT EXISTS gin_ddd CHARACTER SET utf8mb4;\nUSE gin_ddd;\n\nCREATE TABLE IF NOT EXISTS users (\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(50) NOT NULL UNIQUE,\n    email VARCHAR(100) NOT NULL UNIQUE,\n    phone VARCHAR(20),\n    created_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    updated_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\n);\n</code></pre>\n<p>PostgreSQL 订单库示例（与当前订单仓储字段一致）：</p>\n<pre><code class=\"language-sql\">CREATE DATABASE seed;\n\\c seed;\n\nCREATE TABLE IF NOT EXISTS orders (\n    id BIGSERIAL PRIMARY KEY,\n    order_no VARCHAR(50) NOT NULL UNIQUE,\n    user_id BIGINT NOT NULL,\n    total_amount DECIMAL(10, 2) NOT NULL DEFAULT 0.00,\n    status VARCHAR(20) NOT NULL DEFAULT 'PENDING',\n    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP\n);\n</code></pre>\n<p>数据库适配注意：</p>\n<ul>\n<li>若订单库改为 MySQL，需要将 SQL 占位符从 <code>$1</code> 形式改为 <code>?</code></li>\n<li>若用户库改为 PostgreSQL，需要将插入 ID 获取逻辑改为 <code>RETURNING id</code></li>\n</ul>\n<h3 id=\"3-配置应用\">3. 配置应用</h3>\n<p>编辑 <code>config/config.yaml</code>，至少配置数据库与 RocketMQ：</p>\n<pre><code class=\"language-yaml\">server:\n  host: \"0.0.0.0\"\n  port: 8080\n  mode: \"debug\"\n\ndatabase:\n  user:\n    driver: \"mysql\"\n    host: \"localhost\"\n    port: 3306\n    username: \"root\"\n    password: \"your_password\"\n    database: \"gin_ddd\"\n  order:\n    driver: \"postgres\"\n    host: \"localhost\"\n    port: 5432\n    username: \"postgres\"\n    password: \"your_password\"\n    database: \"seed\"\n\nrocketmq:\n  enabled: true\n  nameserver: \"localhost:9876\"\n  group_name: \"gin-ddd-group\"\n  instance_name: \"gin-ddd-instance\"\n  topics:\n    order_event: \"order-event-topic\"\n</code></pre>\n<p>说明：</p>\n<ul>\n<li><code>rocketmq.enabled: true</code> 才会初始化生产者与消费者</li>\n<li>当前订单事件 Topic 在代码中使用固定值 <code>order-event-topic</code>，需与配置保持一致</li>\n</ul>\n<h3 id=\"4-启动-rocketmq可选\">4. 启动 RocketMQ（可选）</h3>\n<pre><code class=\"language-bash\">sh bin/mqnamesrv\nsh bin/mqbroker -n localhost:9876\n</code></pre>\n<h3 id=\"5-启动应用\">5. 启动应用</h3>\n<pre><code class=\"language-bash\">go mod tidy\ngo run cmd/server/main.go\n</code></pre>\n<h3 id=\"6-验证接口\">6. 验证接口</h3>\n<pre><code class=\"language-bash\">curl http://localhost:8080/health\ncurl http://localhost:8080/api/users\ncurl http://localhost:8080/api/orders\n</code></pre>\n<h2 id=\"如何基于脚手架开发新功能\">如何基于脚手架开发新功能</h2>\n<p>示例：新增“商品管理”模块</p>\n<p>步骤 1：新增领域模型 <code>internal/domain/model/product/product.go</code></p>\n<pre><code class=\"language-go\">package product\n\nimport \"time\"\n\ntype Product struct {\n\tID        int64\n\tName      string\n\tPrice     float64\n\tStock     int\n\tCreatedAt time.Time\n\tUpdatedAt time.Time\n}\n</code></pre>\n<p>步骤 2：新增仓储接口 <code>internal/domain/repository/product/product_repository.go</code></p>\n<pre><code class=\"language-go\">package product\n\nimport (\n\t\"context\"\n\t\"gin-ddd/internal/domain/model/product\"\n)\n\ntype ProductRepository interface {\n\tCreate(ctx context.Context, p *product.Product) error\n\tUpdate(ctx context.Context, p *product.Product) error\n\tFindByID(ctx context.Context, id int64) (*product.Product, error)\n\tFindAll(ctx context.Context) ([]*product.Product, error)\n}\n</code></pre>\n<p>步骤 3：新增仓储实现 <code>internal/infrastructure/persistence/product/product_repository_impl.go</code></p>\n<pre><code class=\"language-go\">package product\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"gin-ddd/internal/domain/model/product\"\n)\n\ntype ProductRepositoryImpl struct {\n\tdb *sql.DB\n}\n\nfunc NewProductRepository(db *sql.DB) *ProductRepositoryImpl {\n\treturn &amp;ProductRepositoryImpl{db: db}\n}\n\nfunc (r *ProductRepositoryImpl) Create(ctx context.Context, p *product.Product) error {\n\t_, err := r.db.ExecContext(ctx,\n\t\t`INSERT INTO products (name, price, stock, created_at, updated_at) VALUES (?, ?, ?, ?, ?)`,\n\t\tp.Name, p.Price, p.Stock, p.CreatedAt, p.UpdatedAt,\n\t)\n\treturn err\n}\n</code></pre>\n<p>步骤 4：新增应用服务 <code>internal/application/service/product/product_service.go</code></p>\n<pre><code class=\"language-go\">package product\n\nimport (\n\t\"context\"\n\t\"time\"\n\t\"gin-ddd/internal/domain/model/product\"\n\tproductDomain \"gin-ddd/internal/domain/repository/product\"\n)\n\ntype ProductService struct {\n\trepo productDomain.ProductRepository\n}\n\nfunc NewProductService(repo productDomain.ProductRepository) *ProductService {\n\treturn &amp;ProductService{repo: repo}\n}\n\nfunc (s *ProductService) Create(ctx context.Context, name string, price float64, stock int) error {\n\tp := &amp;product.Product{\n\t\tName:      name,\n\t\tPrice:     price,\n\t\tStock:     stock,\n\t\tCreatedAt: time.Now(),\n\t\tUpdatedAt: time.Now(),\n\t}\n\treturn s.repo.Create(ctx, p)\n}\n</code></pre>\n<p>步骤 5：新增 HTTP Handler 和路由</p>\n<p>将请求/响应对象放到 <code>internal/interfaces/vo/product/</code>，Handler 放到 <code>internal/interfaces/handler/product/</code>，并在 <code>internal/interfaces/router/router.go</code> 中注册路由。</p>\n<p>步骤 6：新增数据库表</p>\n<pre><code class=\"language-sql\">CREATE TABLE IF NOT EXISTS products (\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    price DECIMAL(10, 2) NOT NULL,\n    stock INT NOT NULL DEFAULT 0,\n    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP\n);\n</code></pre>\n<h2 id=\"事件驱动与-rocketmq\">事件驱动与 RocketMQ</h2>\n<h3 id=\"事件类型\">事件类型</h3>\n<p>订单事件：</p>\n<ul>\n<li>order.created</li>\n<li>order.paid</li>\n<li>order.shipped</li>\n<li>order.delivered</li>\n<li>order.cancelled</li>\n<li>order.refunded</li>\n</ul>\n<p>用户事件：</p>\n<ul>\n<li>user.created</li>\n<li>user.activated</li>\n<li>user.deactivated</li>\n<li>user.blocked</li>\n<li>user.deleted</li>\n</ul>\n<h3 id=\"消息流转\">消息流转</h3>\n<pre><code>HTTP 请求 -&gt; Application Service -&gt; Domain Model\n            -&gt; 发布 DomainEvent -&gt; RocketMQ Producer\n            -&gt; RocketMQ Broker -&gt; Consumer\n            -&gt; 事件处理 -&gt; 发送邮件/触发后续流程\n</code></pre>\n<h3 id=\"事件发布与消费关键点\">事件发布与消费关键点</h3>\n<ul>\n<li>订单创建后会发布 <code>order.created</code> 事件（发布失败不会影响主流程）</li>\n<li>消费端按 Tag 解析为 <code>OrderEvent</code> 或 <code>UserEvent</code></li>\n<li>订单邮件通知仅在 <code>order.created</code> 且启用邮件时触发</li>\n</ul>\n<h2 id=\"邮件发送配置qq-邮箱\">邮件发送配置（QQ 邮箱）</h2>\n<p>在 <code>config/config.yaml</code> 中开启邮件配置：</p>\n<pre><code class=\"language-yaml\">mail:\n  enabled: true\n  host: \"smtp.qq.com\"\n  port: 465\n  username: \"your@qq.com\"\n  password: \"你的SMTP授权码\"\n  from_email: \"your@qq.com\"\n  from_name: \"订单系统\"\n</code></pre>\n<p>注意事项：</p>\n<ul>\n<li>必须使用 SMTP 授权码，不是 QQ 登录密码</li>\n<li>端口 465 使用 TLS，端口 587 使用 STARTTLS</li>\n<li>收件人取自用户表中的 <code>email</code> 字段</li>\n</ul>\n<h2 id=\"常见问题排查\">常见问题排查</h2>\n<ul>\n<li>日志提示“事件发布器未初始化”：RocketMQ 未启用或初始化失败</li>\n<li>订单事件已发送但邮件未到：确认用户邮箱字段正确，且 SMTP 授权码可用</li>\n<li>消费者没有收到消息：确认 Topic 与 Tag 正确、Broker 启动正常</li>\n</ul>\n<h2 id=\"开发规范\">开发规范</h2>\n<p>命名建议：</p>\n<ul>\n<li>领域模型：名词，如 <code>Order</code>、<code>User</code></li>\n<li>应用服务：<code>XxxService</code></li>\n<li>仓储接口：<code>XxxRepository</code></li>\n<li>仓储实现：<code>XxxRepositoryImpl</code></li>\n<li>Handler：<code>XxxHandler</code></li>\n</ul>\n<p>分层原则：</p>\n<ul>\n<li>领域层不依赖基础设施</li>\n<li>应用层只做编排与事务协调</li>\n<li>基础设施提供技术实现</li>\n<li>接口层只负责 HTTP 交互</li>\n</ul>\n<h2 id=\"常用命令\">常用命令</h2>\n<pre><code class=\"language-bash\">go mod tidy\ngo test ./...\n</code></pre>\n<h2 id=\"源码地址\">源码地址</h2>\n<p><a href=\"https://github.com/microwind/design-patterns/tree/main/practice-projects/gin-ddd\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/microwind/design-patterns/tree/main/practice-projects/gin-ddd</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-13 09:19</span>&nbsp;\n<a href=\"https://www.cnblogs.com/letjs\">刀法如飞</a>&nbsp;\n阅读(<span id=\"post_view_count\">32</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "LockSupport深度解析：线程阻塞与唤醒的底层实现原理",
      "link": "https://www.cnblogs.com/sevencoding/p/19588531",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sevencoding/p/19588531\" id=\"cb_post_title_url\" title=\"发布于 2026-02-13 09:00\">\n    <span>LockSupport深度解析：线程阻塞与唤醒的底层实现原理</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"locksupport简介\">LockSupport简介</h2>\n<p>LockSupprot 用来阻塞和唤醒线程，底层实现依赖于&nbsp;<a href=\"https://www.seven97.top/java/concurrent/unsafe.html\" rel=\"noopener nofollow\" target=\"_blank\">Unsafe 类</a>。</p>\n<p>LockSupport用来创建锁和其他同步类的基本线程阻塞原语。简而言之，当调用LockSupport.park时，表示当前线程将会等待，直至获得许可，当调用LockSupport.unpark时，必须把等待获得许可的线程作为参数进行传递，好让此线程继续运行。在AQS中大量使用，AQS最终都是使用LockSupport来阻塞线程的。</p>\n<p>该类包含一组用于阻塞和唤醒线程的静态方法，这些方法主要是围绕 park 和 unpark 展开，话不多说，直接来看一个简单的例子吧。</p>\n<pre><code class=\"language-java\">public class LockSupportDemo1 {\n    public static void main(String[] args) {\n        Thread mainThread = Thread.currentThread();\n\n        // 创建一个线程从1数到1000\n        Thread counterThread = new Thread(() -&gt; {\n            for (int i = 1; i &lt;= 1000; i++) {\n                System.out.println(i);\n                if (i == 500) {\n                    // 当数到500时，唤醒主线程\n                    LockSupport.unpark(mainThread);\n                }\n            }\n        });\n\n        counterThread.start();\n\n        // 主线程调用park\n        LockSupport.park();\n        System.out.println(\"Main thread was unparked.\");\n    }\n}\n</code></pre>\n<p>上面的代码中，当 counterThread 数到 500 时，它会唤醒 mainThread。而 mainThread 在调用 park 方法时会被阻塞，直到被 unpark。</p>\n<p>LockSupport 中的方法不多，这里将这些方法做一个总结：</p>\n<h3 id=\"阻塞线程\">阻塞线程</h3>\n<ol>\n<li><code>void park()</code>：阻塞当前线程，如果调用 unpark 方法或线程被中断，则该线程将变得可运行。请注意，park 不会抛出 InterruptedException，因此线程必须单独检查其中断状态。</li>\n<li><code>void park(Object blocker)</code>：功能同方法 1，入参增加一个 Object 对象，用来记录导致线程阻塞的对象，方便问题排查。</li>\n<li><code>void parkNanos(long nanos)</code>：阻塞当前线程一定的纳秒时间，或直到被 unpark 调用，或线程被中断。</li>\n<li><code>void parkNanos(Object blocker, long nanos)</code>：功能同方法 3，入参增加一个 Object 对象，用来记录导致线程阻塞的对象，方便问题排查。</li>\n<li><code>void parkUntil(long deadline)</code>：阻塞当前线程直到某个指定的截止时间（以毫秒为单位），或直到被 unpark 调用，或线程被中断。</li>\n<li><code>void parkUntil(Object blocker, long deadline)</code>：功能同方法 5，入参增加一个 Object 对象，用来记录导致线程阻塞的对象，方便问题排查。</li>\n</ol>\n<h3 id=\"唤醒线程\">唤醒线程</h3>\n<p><code>void unpark(Thread thread)</code>：唤醒一个由 park 方法阻塞的线程。如果该线程未被阻塞，那么下一次调用 park 时将立即返回。这允许“先发制人”式的唤醒机制。</p>\n<p>实际上，LockSupport 阻塞和唤醒线程的功能依赖于&nbsp;<code>sun.misc.Unsafe</code>，这是一个很底层的类，比如 LockSupport 的 park 方法是通过&nbsp;<code>unsafe.park()</code>&nbsp;方法实现的。</p>\n<h2 id=\"locksupport源码分析\">LockSupport源码分析</h2>\n<h3 id=\"类的属性\">类的属性</h3>\n<pre><code class=\"language-java\">public class LockSupport {\n    // Hotspot implementation via intrinsics API\n    private static final sun.misc.Unsafe UNSAFE;\n    // 表示内存偏移地址\n    private static final long parkBlockerOffset;\n    // 表示内存偏移地址\n    private static final long SEED;\n    // 表示内存偏移地址\n    private static final long PROBE;\n    // 表示内存偏移地址\n    private static final long SECONDARY;\n    \n    static {\n        try {\n            // 获取Unsafe实例\n            UNSAFE = sun.misc.Unsafe.getUnsafe();\n            // 线程类类型\n            Class&lt;?&gt; tk = Thread.class;\n            // 获取Thread的parkBlocker字段的内存偏移地址\n            parkBlockerOffset = UNSAFE.objectFieldOffset\n                (tk.getDeclaredField(\"parkBlocker\"));\n            // 获取Thread的threadLocalRandomSeed字段的内存偏移地址\n            SEED = UNSAFE.objectFieldOffset\n                (tk.getDeclaredField(\"threadLocalRandomSeed\"));\n            // 获取Thread的threadLocalRandomProbe字段的内存偏移地址\n            PROBE = UNSAFE.objectFieldOffset\n                (tk.getDeclaredField(\"threadLocalRandomProbe\"));\n            // 获取Thread的threadLocalRandomSecondarySeed字段的内存偏移地址\n            SECONDARY = UNSAFE.objectFieldOffset\n                (tk.getDeclaredField(\"threadLocalRandomSecondarySeed\"));\n        } catch (Exception ex) { throw new Error(ex); }\n    }\n}\n</code></pre>\n<p>说明: UNSAFE字段表示<a href=\"https://www.seven97.top/java/concurrent/unsafe.html\" rel=\"noopener nofollow\" target=\"_blank\">sun.misc.Unsafe</a>类，一般程序中不允许直接调用，而long型的表示实例对象相应字段在内存中的偏移地址，可以通过该偏移地址获取或者设置该字段的值。</p>\n<h3 id=\"类的构造函数\">类的构造函数</h3>\n<pre><code class=\"language-java\">// 私有构造函数，无法被实例化\nprivate LockSupport() {}\n</code></pre>\n<p>说明: LockSupport只有一个私有构造函数，无法被实例化。</p>\n<h3 id=\"核心函数分析\">核心函数分析</h3>\n<p>在分析LockSupport函数之前，先引入sun.misc.Unsafe类中的park和unpark函数，因为LockSupport的核心函数都是基于Unsafe类中定义的park和unpark函数，下面给出两个函数的定义:</p>\n<pre><code class=\"language-java\">public native void park(boolean isAbsolute, long time);\npublic native void unpark(Thread thread);\n</code></pre>\n<p>说明: 对两个函数的说明如下:</p>\n<ul>\n<li>\n<p>park函数，阻塞线程，并且该线程在下列情况发生之前都会被阻塞:</p>\n<ul>\n<li>\n<p>调用unpark函数，释放该线程的许可。</p>\n</li>\n<li>\n<p>该线程被中断。</p>\n</li>\n<li>\n<p>设置的时间到了。并且，当time为绝对时间时，isAbsolute为true，否则，isAbsolute为false。当time为0时，表示无限等待，直到unpark发生。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>unpark函数，释放线程的许可，即激活调用park后阻塞的线程。这个函数不是安全的，调用这个函数时要确保线程依旧存活。</p>\n</li>\n</ul>\n<h4 id=\"park函数\">park函数</h4>\n<p>park函数有两个重载版本，方法摘要如下</p>\n<pre><code class=\"language-java\">public static void park()；\npublic static void park(Object blocker)；\n</code></pre>\n<p>说明: 两个函数的区别在于park()函数没有没有blocker，即没有设置线程的parkBlocker字段。park(Object)型函数如下。</p>\n<pre><code class=\"language-java\">public static void park(Object blocker) {\n    // 获取当前线程\n    Thread t = Thread.currentThread();\n    // 设置Blocker\n    setBlocker(t, blocker);\n    // 获取许可\n    UNSAFE.park(false, 0L);\n    // 重新可运行后再此设置Blocker\n    setBlocker(t, null);\n}\n</code></pre>\n<p>说明: 调用park函数时，首先获取当前线程，然后设置当前线程的parkBlocker字段，即调用setBlocker函数，之后调用Unsafe类的park函数，之后再调用setBlocker函数。那么问题来了，为什么要在此park函数中要调用两次setBlocker函数呢? 原因其实很简单，调用park函数时，当前线程首先设置好parkBlocker字段，然后再调用Unsafe的park函数，此后，当前线程就已经阻塞了，等待该线程的unpark函数被调用，所以后面的一个setBlocker函数无法运行，unpark函数被调用，该线程获得许可后，就可以继续运行了，也就运行第二个setBlocker，把该线程的parkBlocker字段设置为null，这样就完成了整个park函数的逻辑。如果没有第二个setBlocker，那么之后没有调用park(Object blocker)，而直接调用getBlocker函数，得到的还是前一个park(Object blocker)设置的blocker，显然是不符合逻辑的。总之，必须要保证在park(Object blocker)整个函数执行完后，该线程的parkBlocker字段又恢复为null。所以，park(Object)型函数里必须要调用setBlocker函数两次。setBlocker方法如下。</p>\n<pre><code class=\"language-java\">private static void setBlocker(Thread t, Object arg) {\n    // 设置线程t的parkBlocker字段的值为arg\n    UNSAFE.putObject(t, parkBlockerOffset, arg);\n}\n</code></pre>\n<p>说明: 此方法用于设置线程t的parkBlocker字段的值为arg。</p>\n<p>另外一个无参重载版本，park()函数如下。</p>\n<pre><code class=\"language-java\">public static void park() {\n    // 获取许可，设置时间为无限长，直到可以获取许可\n    UNSAFE.park(false, 0L);\n}\n</code></pre>\n<p>说明: 调用了park函数后，会禁用当前线程，除非许可可用。在以下三种情况之一发生之前，当前线程都将处于休眠状态，即下列情况发生时，当前线程会获取许可，可以继续运行。</p>\n<ul>\n<li>\n<p>其他某个线程将当前线程作为目标调用 unpark。</p>\n</li>\n<li>\n<p>其他某个线程中断当前线程。</p>\n</li>\n<li>\n<p>该调用不合逻辑地(即毫无理由地)返回。</p>\n</li>\n</ul>\n<h4 id=\"parknanos函数\">parkNanos函数</h4>\n<p>此函数表示在许可可用前禁用当前线程，并最多等待指定的等待时间。具体函数如下。</p>\n<pre><code class=\"language-java\">public static void parkNanos(Object blocker, long nanos) {\n    if (nanos &gt; 0) { // 时间大于0\n        // 获取当前线程\n        Thread t = Thread.currentThread();\n        // 设置Blocker\n        setBlocker(t, blocker);\n        // 获取许可，并设置了时间\n        UNSAFE.park(false, nanos);\n        // 设置许可\n        setBlocker(t, null);\n    }\n}\n</code></pre>\n<p>说明: 该函数也是调用了两次setBlocker函数，nanos参数表示相对时间，表示等待多长时间。</p>\n<h4 id=\"parkuntil函数\">parkUntil函数</h4>\n<p>此函数表示在指定的时限前禁用当前线程，除非许可可用, 具体函数如下:</p>\n<pre><code class=\"language-java\">public static void parkUntil(Object blocker, long deadline) {\n    // 获取当前线程\n    Thread t = Thread.currentThread();\n    // 设置Blocker\n    setBlocker(t, blocker);\n    UNSAFE.park(true, deadline);\n    // 设置Blocker为null\n    setBlocker(t, null);\n}\n</code></pre>\n<p>说明: 该函数也调用了两次setBlocker函数，deadline参数表示绝对时间，表示指定的时间。</p>\n<h4 id=\"unpark函数\">unpark函数</h4>\n<p>此函数表示如果给定线程的许可尚不可用，则使其可用。如果线程在 park 上受阻塞，则它将解除其阻塞状态。否则，保证下一次调用 park 不会受阻塞。如果给定线程尚未启动，则无法保证此操作有任何效果。具体函数如下:</p>\n<pre><code class=\"language-java\">public static void unpark(Thread thread) {\n    if (thread != null) // 线程为不空\n        UNSAFE.unpark(thread); // 释放该线程许可\n}\n</code></pre>\n<p>说明: 释放许可，指定线程可以继续运行。</p>\n<h2 id=\"更深入的理解\">更深入的理解</h2>\n<h3 id=\"与-synchronzed-的区别\">与 synchronzed 的区别</h3>\n<p><a href=\"https://www.seven97.top/java/concurrent/02-keyword1-synchronized.html\" rel=\"noopener nofollow\" target=\"_blank\">synchronzed</a>&nbsp;会使线程阻塞，线程会进入 BLOCKED 状态，而调用 LockSupprt 方法阻塞线程会使线程进入到 WAITING 状态。</p>\n<h3 id=\"threadsleep和objectwait的区别\">Thread.sleep()和Object.wait()的区别</h3>\n<p>首先，我们先来看看Thread.sleep()和Object.wait()的区别，这是一个烂大街的题目了，大家应该都能说上来两点。</p>\n<ul>\n<li>\n<p>Thread.sleep()不会释放占有的锁，Object.wait()会释放占有的锁；</p>\n</li>\n<li>\n<p>Thread.sleep()必须传入时间，Object.wait()可传可不传，不传表示一直阻塞下去；</p>\n</li>\n<li>\n<p>Thread.sleep()到时间了会自动唤醒，然后继续执行；</p>\n</li>\n<li>\n<p>Object.wait()不带时间的，需要另一个线程使用Object.notify()唤醒；</p>\n</li>\n<li>\n<p>Object.wait()带时间的，假如没有被notify，到时间了会自动唤醒，这时又分好两种情况，一是立即获取到了锁，线程自然会继续执行；二是没有立即获取锁，线程进入同步队列等待获取锁；</p>\n</li>\n</ul>\n<p>其实，他们俩最大的区别就是Thread.sleep()不会释放锁资源，Object.wait()会释放锁资源。</p>\n<h3 id=\"objectwait和conditionawait的区别\">Object.wait()和Condition.await()的区别</h3>\n<p>Object.wait()和Condition.await()的原理是基本一致的，不同的是Condition.await()底层是调用LockSupport.park()来实现阻塞当前线程的。</p>\n<p>实际上，它在阻塞当前线程之前还干了两件事，一是把当前线程添加到条件队列中，二是“完全”释放锁，也就是让state状态变量变为0，然后才是调用LockSupport.park()阻塞当前线程。</p>\n<h3 id=\"threadsleep和locksupportpark的区别\">Thread.sleep()和LockSupport.park()的区别</h3>\n<p>LockSupport.park()还有几个兄弟方法——parkNanos()、parkUtil()等，我们这里说的park()方法统称这一类方法。</p>\n<ul>\n<li>\n<p>从功能上来说，Thread.sleep()和LockSupport.park()方法类似，都是阻塞当前线程的执行，且都不会释放当前线程占有的锁资源；</p>\n</li>\n<li>\n<p>Thread.sleep()没法从外部唤醒，只能自己醒过来；</p>\n</li>\n<li>\n<p>LockSupport.park()方法可以被另一个线程调用LockSupport.unpark()方法唤醒；</p>\n</li>\n<li>\n<p>Thread.sleep()方法声明上抛出了InterruptedException中断异常，所以调用者需要捕获这个异常或者再抛出；</p>\n</li>\n<li>\n<p>LockSupport.park()方法不需要捕获中断异常；</p>\n</li>\n<li>\n<p>Thread.sleep()本身就是一个native方法；</p>\n</li>\n<li>\n<p>LockSupport.park()底层是调用的Unsafe的native方法；</p>\n</li>\n</ul>\n<h3 id=\"objectwait和locksupportpark的区别\">Object.wait()和LockSupport.park()的区别</h3>\n<p>二者都会阻塞当前线程的运行，他们有什么区别呢? 经过上面的分析相信你一定很清楚了，真的吗? 往下看！</p>\n<ul>\n<li>\n<p>Object.wait()方法需要在synchronized块中执行；</p>\n</li>\n<li>\n<p>LockSupport.park()可以在任意地方执行；</p>\n</li>\n<li>\n<p>Object.wait()方法声明抛出了中断异常，调用者需要捕获或者再抛出；</p>\n</li>\n<li>\n<p>LockSupport.park()不需要捕获中断异常；</p>\n</li>\n<li>\n<p>Object.wait()不带超时的，需要另一个线程执行notify()来唤醒，但不一定继续执行后续内容；</p>\n</li>\n<li>\n<p>LockSupport.park()不带超时的，需要另一个线程执行unpark()来唤醒，一定会继续执行后续内容；</p>\n</li>\n</ul>\n<p>park()/unpark()底层的原理是“二元信号量”，你可以把它相像成只有一个许可证的Semaphore，只不过这个信号量在重复执行unpark()的时候也不会再增加许可证，最多只有一个许可证。</p>\n<h3 id=\"如果在wait之前执行了notify会怎样\">如果在wait()之前执行了notify()会怎样?</h3>\n<p>如果当前的线程不是此对象锁的所有者，却调用该对象的notify()或wait()方法时抛出IllegalMonitorStateException异常；</p>\n<p>如果当前线程是此对象锁的所有者，wait()将一直阻塞，因为后续将没有其它notify()唤醒它。</p>\n<h3 id=\"如果在park之前执行了unpark会怎样\">如果在park()之前执行了unpark()会怎样?</h3>\n<p>线程不会被阻塞，直接跳过park()，继续执行后续内容</p>\n<h3 id=\"locksupportpark会释放锁资源吗\">LockSupport.park()会释放锁资源吗?</h3>\n<p>不会，它只负责阻塞当前线程，释放锁资源实际上是在Condition的await()方法中实现的。</p>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自在线网站：seven的菜鸟成长之路，作者：seven，转载请注明原文链接：www.seven97.top</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-13 09:00</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sevencoding\">程序员Seven</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "AI工具实践日记（二）：在 OpenClaw 中调用 OpenCode 进行开发任务",
      "link": "https://www.cnblogs.com/rsls/p/19606311",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/rsls/p/19606311\" id=\"cb_post_title_url\" title=\"发布于 2026-02-13 08:56\">\n    <span>AI工具实践日记（二）：在 OpenClaw 中调用 OpenCode 进行开发任务</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"AI工具实践日记（二）：在 OpenClaw 中调用 OpenCode 进行开发任务\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/280247/202602/280247-20260212005137002-1578926574.png\" />\n        AI 开发需要\"指挥中心\"\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"引言ai-开发需要指挥中心\">引言：AI 开发需要\"指挥中心\"</h2>\n<p>上一篇日记讲了如何在树莓派上搭建 OpenClaw。这篇来说说<strong>真正用 OpenClaw 干活</strong>的体验。</p>\n<p>直接用 Claude、GPT 或 OpenCode 写代码有个问题：<strong>对话散落在各个窗口，进度没法追踪，结果也不好管理。</strong></p>\n<p>OpenClaw 解决的就是这个问题——它像一个\"指挥中心\"，让你能：</p>\n<ul>\n<li>启动 AI 编程任务（后台运行，不阻塞）</li>\n<li>实时监控进度（随时查看输出）</li>\n<li>自动处理错误（卡住时自动恢复或报警）</li>\n<li>统一管理上下文（workspace、memory、技能）</li>\n</ul>\n<p>这篇日记记录了我用 <strong>OpenClaw + OpenSpec + OpenCode</strong> 组合开发任务看板的真实过程。</p>\n<hr />\n<h2 id=\"为什么要用-openspec规范先于代码\">为什么要用 OpenSpec：规范先于代码</h2>\n<h3 id=\"ai-编程的痛点\">AI 编程的痛点</h3>\n<p>用 AI 写代码很方便，但有个致命问题：<strong>需求只存在于聊天记录里。</strong></p>\n<p>想象这个场景：</p>\n<ul>\n<li>你跟 Claude 说：\"帮我加个标签功能\"</li>\n<li>AI 写好了代码</li>\n<li>一周后你想改这个功能，但找不到当时的对话</li>\n<li>你重新描述需求，但描述得不完全一样</li>\n<li>AI 写的代码和之前不兼容</li>\n</ul>\n<p><strong>结果：代码一团糟，还得自己重写。</strong></p>\n<h3 id=\"openspec-是什么\">OpenSpec 是什么</h3>\n<p><strong>OpenSpec 是一个规范驱动开发（Spec-Driven Development）框架。</strong></p>\n<p>它的核心理念：<strong>先写规范，再写代码。</strong></p>\n<p>所有需求、设计、任务都写成文档，放在 <code>openspec/</code> 目录下。AI 按照规范文档执行，而不是根据聊天内容猜测。</p>\n<h3 id=\"openspec-目录结构\">OpenSpec 目录结构</h3>\n<pre><code>openspec/\n├── specs/                    # 系统行为的源头（当前状态）\n│   └── &lt;domain&gt;/\n│       └── spec.md          # 系统规格文档\n├── changes/                  # 提议的变更（每个功能一个文件夹）\n│   └── &lt;功能名&gt;/\n│       ├── proposal.md      # 为什么要做（意图和范围）\n│       ├── design.md        # 怎么做（技术方案）\n│       ├── tasks.md         # 任务清单 ⭐ 最关键\n│       └── specs/           # 变更的具体规格\n└── config.yaml              # 项目配置\n</code></pre>\n<h3 id=\"使用-openspec-的必要性\">使用 OpenSpec 的必要性</h3>\n<p><strong>1. 需求可追溯</strong></p>\n<table>\n<thead>\n<tr>\n<th>方式</th>\n<th>需求在哪里</th>\n<th>一个月后还能找到吗</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>直接聊天</td>\n<td>聊天记录</td>\n<td>❌ 找不到了</td>\n</tr>\n<tr>\n<td>OpenSpec</td>\n<td><code>changes/功能名/proposal.md</code></td>\n<td>✅ 永远在文件里</td>\n</tr>\n</tbody>\n</table>\n<p><strong>2. 设计可复用</strong></p>\n<p>设计文档 <code>design.md</code> 记录了技术方案。下次遇到类似功能，可以直接参考。</p>\n<p><strong>3. 任务可拆分</strong></p>\n<p><code>tasks.md</code> 把复杂功能拆成可执行的小任务。AI 按清单逐个完成，不会遗漏。</p>\n<p><strong>4. 进度可监控</strong></p>\n<p>每个任务完成后，AI 输出 <code>[DONE] 任务X.X</code>。你可以实时知道：</p>\n<ul>\n<li>完成了多少任务</li>\n<li>还剩多少任务</li>\n<li>有没有卡住</li>\n</ul>\n<p><strong>5. 变更有历史</strong></p>\n<pre><code class=\"language-bash\"># 查看所有变更\n$ ls openspec/changes/\nadd-archive-feature/    # 归档功能\nadd-task-tags/          # 标签功能\nmigrate-to-sqlite/      # 数据库迁移\n\n# 每个变更都有完整的提案、设计、任务记录\n</code></pre>\n<h3 id=\"不用-openspec-的后果\">不用 OpenSpec 的后果</h3>\n<p>我做过对比实验：</p>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>使用 OpenSpec</th>\n<th>不使用 OpenSpec</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>标签功能</td>\n<td>6个任务，10分钟，一次成功</td>\n<td>反复沟通，30分钟，代码混乱</td>\n</tr>\n<tr>\n<td>数据库迁移</td>\n<td>24个任务拆成2个变更，5分钟</td>\n<td>直接说\"迁移到SQLite\"，卡住</td>\n</tr>\n<tr>\n<td>可维护性</td>\n<td>3个月后仍能看懂设计</td>\n<td>1周后忘记当时怎么想的</td>\n</tr>\n</tbody>\n</table>\n<p><strong>结论：OpenSpec 是 AI 编程的\"基础设施\"，不用它就是在裸奔。</strong></p>\n<h3 id=\"openspec-工作流程\">OpenSpec 工作流程</h3>\n<pre><code>1. 有新需求\n   ↓\n2. 创建变更\n   $ openspec change new 功能名\n   ↓\n3. 编写规范文档\n   - proposal.md（为什么要做）\n   - design.md（怎么做）\n   - tasks.md（任务清单）\n   ↓\n4. 让 AI 执行\n   $ opencode run \"按 tasks.md 实现\"\n   ↓\n5. 验证结果\n   - 功能测试\n   - 代码审查\n   ↓\n6. 归档变更\n   $ openspec change archive 功能名\n   ↓\n7. 更新系统规格\n   - 把变更合并到 specs/\n</code></pre>\n<hr />\n<h2 id=\"工具链介绍\">工具链介绍</h2>\n<h3 id=\"openclawai-指挥中心\">OpenClaw：AI 指挥中心</h3>\n<p>OpenClaw 是一个 AI 助手平台，核心能力：</p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>说明</th>\n<th>命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>启动后台任务</td>\n<td>不阻塞当前会话</td>\n<td><code>sessions_spawn task:\"...\"</code></td>\n</tr>\n<tr>\n<td>实时监控</td>\n<td>查看任务输出和进度</td>\n<td><code>sessions_history sessionKey:\"...\"</code></td>\n</tr>\n<tr>\n<td>任务管理</td>\n<td>列出发送消息、强制停止</td>\n<td><code>sessions_list</code>, <code>sessions_send</code>, <code>process action:kill</code></td>\n</tr>\n<tr>\n<td>上下文管理</td>\n<td>自动读取 workspace、memory</td>\n<td>内置</td>\n</tr>\n<tr>\n<td>错误处理</td>\n<td>自动检测和恢复</td>\n<td>内置</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"opencodeai-编程代理\">OpenCode：AI 编程代理</h3>\n<p>OpenCode 读取 OpenSpec 规范，自动写代码。支持多种调用方式：</p>\n<ol>\n<li><strong>命令行</strong>：<code>opencode run \"实现功能\"</code></li>\n<li><strong>OpenClaw exec</strong>：<code>exec command:\"opencode run ...\"</code></li>\n<li><strong>OpenClaw sessions_spawn</strong>：<code>sessions_spawn task:\"...\"</code> ⭐推荐</li>\n</ol>\n<hr />\n<h2 id=\"实战一标签功能开发\">实战一：标签功能开发</h2>\n<h3 id=\"需求\">需求</h3>\n<p>给任务看板添加<strong>标签功能</strong>：</p>\n<ul>\n<li>支持为任务添加多个标签</li>\n<li>可以按标签筛选任务</li>\n<li>标签显示在任务卡片上</li>\n</ul>\n<h3 id=\"openclaw-执行流程\">OpenClaw 执行流程</h3>\n<p><strong>第一步：创建 OpenSpec 规范</strong></p>\n<pre><code class=\"language-bash\">cd aimier-kanban\nopenspec change new add-task-tags\n</code></pre>\n<p>编辑 <code>openspec/changes/add-task-tags/tasks.md</code>：</p>\n<pre><code class=\"language-markdown\"># Tasks: Add Task Tags\n\n## 1. Backend\n- [ ] 1.1 Add tags field to task data structure\n- [ ] 1.2 Update create_task API to support tags\n- [ ] 1.3 Create GET /api/tags endpoint\n\n## 2. Frontend\n- [ ] 2.1 Add tag input box in task modal\n- [ ] 2.2 Display tags on task cards\n- [ ] 2.3 Add tag filter dropdown\n</code></pre>\n<p><strong>第二步：通过 OpenClaw 启动 OpenCode</strong></p>\n<pre><code class=\"language-bash\"># 在 OpenClaw 中执行\nsessions_spawn task:\"按照 openspec/changes/add-task-tags/tasks.md 实现任务标签功能\"\n  label:\"implement-task-tags\"\n  timeoutSeconds:600\n</code></pre>\n<p><strong>第三步：实时监控进度</strong></p>\n<pre><code class=\"language-bash\"># 查看任务列表\n$ sessions_list\n\n# 查看具体输出（每30秒检查一次）\n$ sessions_history sessionKey:\"agent:main:subagent:implement-task-tags\" limit:50\n\n# 输出示例：\n[DONE] 任务1.1: 添加 tags 字段到任务数据结构\n[DONE] 任务1.2: 修改创建任务 API\n[DONE] 任务1.3: 创建标签列表 API\n[DONE] 任务2.1: 在任务模态框添加标签输入\n[DONE] 任务2.2: 在任务卡片显示标签\n[DONE] 任务2.3: 添加标签筛选功能\n[ALL DONE]\n</code></pre>\n<p><strong>第四步：验证结果</strong></p>\n<pre><code class=\"language-bash\"># 检查代码语法\nexec command:\"cd aimier-kanban &amp;&amp; python3 -m py_compile app.py\"\n\n# 测试功能\n# 启动服务，在浏览器验证标签功能\n</code></pre>\n<h3 id=\"结果\">结果</h3>\n<ul>\n<li>✅ 6 个任务全部完成</li>\n<li>✅ 耗时约 10 分钟</li>\n<li>✅ 代码质量符合预期</li>\n<li>✅ 无需人工干预</li>\n</ul>\n<hr />\n<h2 id=\"实战二sqlite-数据库迁移复杂功能\">实战二：SQLite 数据库迁移（复杂功能）</h2>\n<h3 id=\"需求-1\">需求</h3>\n<p>把任务看板从 JSON 文件存储迁移到 SQLite 数据库。</p>\n<p><strong>复杂度评估：</strong></p>\n<ul>\n<li>数据库初始化：4 个任务</li>\n<li>数据迁移：4 个任务</li>\n<li>API 更新：16 个任务（<strong>过多！</strong>）</li>\n</ul>\n<h3 id=\"任务拆分策略\">任务拆分策略</h3>\n<p>直接让 OpenCode 实现 24 个任务会卡住。我的策略：<strong>拆分为两个变更</strong>。</p>\n<p><strong>变更1：sqlite-database（8个任务）</strong></p>\n<pre><code class=\"language-markdown\"># Tasks: SQLite Database Layer\n\n## 1. Database Setup\n- [ ] 1.1 Import sqlite3 module\n- [ ] 1.2 Create database connection helper\n- [ ] 1.3 Add init_db() function\n- [ ] 1.4 Create tasks table schema\n\n## 2. Data Migration\n- [ ] 2.1 Load existing tasks from JSON\n- [ ] 2.2 Insert tasks into SQLite\n- [ ] 2.3 Migrate archived tasks\n- [ ] 2.4 Verify migration success\n</code></pre>\n<p><strong>变更2：sqlite-api（16个任务）</strong></p>\n<pre><code class=\"language-markdown\"># Tasks: Update API to use SQLite\n\n## 1. Backend Refactor\n- [ ] 1.1 Update load_tasks() to use SQL\n- [ ] 1.2 Update save_task() to use SQL INSERT/UPDATE\n- [ ] 1.3 Update delete_task() to use SQL DELETE\n- [ ] 1.4 Update archive functions\n\n## 2. API Endpoints\n- [ ] 2.1 Update GET /api/tasks\n- [ ] 2.2 Update POST /api/tasks\n- [ ] 2.3 Update PATCH /api/tasks/&lt;id&gt;\n- [ ] 2.4 Update DELETE /api/tasks/&lt;id&gt;\n- [ ] 2.5 Update PATCH /api/tasks/&lt;id&gt;/status\n- [ ] 2.6 Update GET /api/stats\n- [ ] 2.7 Update GET /api/tags\n- [ ] 2.8 Update GET /api/archives\n- [ ] 2.9 Update POST /api/archives/&lt;id&gt;/restore\n- [ ] 2.10 Update DELETE /api/archives/&lt;id&gt;\n</code></pre>\n<h3 id=\"openclaw-执行流程-1\">OpenClaw 执行流程</h3>\n<p><strong>执行变更1：</strong></p>\n<pre><code class=\"language-bash\">sessions_spawn task:\"按照 openspec/changes/sqlite-database/tasks.md 实现数据库层\"\n  label:\"sqlite-database\"\n  timeoutSeconds:600\n</code></pre>\n<p><strong>监控输出：</strong></p>\n<pre><code>[DONE] 任务1.1-1.4: 数据库初始化完成\n[DONE] 任务2.1-2.2: 迁移了 12 个任务\n[DONE] 任务2.3-2.4: 迁移了 4 个归档任务\n[ALL DONE]\n\n耗时：约3分钟\n状态：✅ 成功\n</code></pre>\n<p><strong>执行变更2：</strong></p>\n<pre><code class=\"language-bash\">sessions_spawn task:\"按照 openspec/changes/sqlite-api/tasks.md 更新API层\"\n  label:\"sqlite-api\"\n  timeoutSeconds:900\n</code></pre>\n<p><strong>监控输出：</strong></p>\n<pre><code>[DONE] 任务1.1: Import sqlite3 module\n[DONE] 任务1.2: Create get_db() helper function\n[DONE] 任务1.3: Add init_db() for startup\n[DONE] 任务2.1: Update load_tasks() to use SQL\n...\n[DONE] 任务2.10: Update DELETE /api/archives/&lt;id&gt;\n[ALL DONE]\n\n耗时：约2分钟\n状态：✅ 成功\n</code></pre>\n<h3 id=\"效果对比\">效果对比</h3>\n<table>\n<thead>\n<tr>\n<th>方案</th>\n<th>变更数</th>\n<th>总任务数</th>\n<th>耗时</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>原始方案（未拆分）</td>\n<td>1</td>\n<td>24</td>\n<td>卡住</td>\n<td>❌ 失败</td>\n</tr>\n<tr>\n<td><strong>组合方案（拆分后）</strong></td>\n<td><strong>2</strong></td>\n<td><strong>24</strong></td>\n<td><strong>5分钟</strong></td>\n<td><strong>✅ 成功</strong></td>\n</tr>\n</tbody>\n</table>\n<p><strong>关键发现：</strong></p>\n<ul>\n<li>任务拆分后，即使总任务数相同，成功率反而提升</li>\n<li>单个变更的任务数控制在 8-16 个是 sweet spot</li>\n<li><code>[DONE]</code> 标记让进度透明，心里更有底</li>\n</ul>\n<hr />\n<h2 id=\"监控和管理技巧\">监控和管理技巧</h2>\n<h3 id=\"实时监控命令\">实时监控命令</h3>\n<pre><code class=\"language-bash\"># 查看所有活跃任务\n$ sessions_list\n\n# 查看最近10分钟活跃的任务\n$ sessions_list activeMinutes:10\n\n# 查看具体任务的输出\n$ sessions_history sessionKey:\"...\" limit:50\n\n# 搜索 [DONE] 标记\n$ sessions_history sessionKey:\"...\" | grep \"\\[DONE\\]\"\n\n# 统计已完成任务数\n$ sessions_history sessionKey:\"...\" | grep -c \"\\[DONE\\]\"\n</code></pre>\n<h3 id=\"错误处理和恢复\">错误处理和恢复</h3>\n<p><strong>场景1：OpenCode 卡住（5分钟无输出）</strong></p>\n<pre><code class=\"language-bash\"># 检查最后输出时间\n$ sessions_history sessionKey:\"...\" | tail -20\n\n# 发送唤醒信号\n$ sessions_send sessionKey:\"...\" message:\"请继续实现，从任务2.1开始\"\n\n# 如果无响应，强制停止并重新启动\n$ process action:kill sessionId:xxx\n$ sessions_spawn task:\"继续实现，从任务2.1开始\" label:\"resume-task\"\n</code></pre>\n<p><strong>场景2：生成代码有语法错误</strong></p>\n<pre><code class=\"language-bash\"># 自动运行语法检查\n$ exec command:\"cd aimier-kanban &amp;&amp; python3 -m py_compile app.py\"\n\n# 如果有错误，OpenClaw 会自动分析并给出建议\n</code></pre>\n<hr />\n<h2 id=\"踩坑记录\">踩坑记录</h2>\n<h3 id=\"坑1直接使用-opencode-cli\">坑1：直接使用 OpenCode CLI</h3>\n<p><strong>问题：</strong> 直接在终端运行 <code>opencode run \"...\"</code>，卡住时无法感知。</p>\n<p><strong>解决：</strong> 改用 OpenClaw 的 <code>sessions_spawn</code>，后台运行 + 实时监控。</p>\n<h3 id=\"坑2任务太大不拆分\">坑2：任务太大（不拆分）</h3>\n<p><strong>问题：</strong> 让 OpenCode 一次性实现 24 个任务，卡在中间不动。</p>\n<p><strong>解决：</strong> 拆分为多个小变更，每个变更 8-16 个任务。</p>\n<h3 id=\"坑3缺乏进度反馈\">坑3：缺乏进度反馈</h3>\n<p><strong>问题：</strong> OpenCode 不报告进度，不知道做到哪了。</p>\n<p><strong>解决：</strong> 在 tasks.md 和提示词中强制要求 <code>[DONE]</code> 标记。</p>\n<h3 id=\"坑4上下文缺失\">坑4：上下文缺失</h3>\n<p><strong>问题：</strong> OpenCode 不知道项目结构，需要反复说明。</p>\n<p><strong>解决：</strong> OpenClaw 自动读取 workspace，提供完整上下文。</p>\n<hr />\n<h2 id=\"经验总结\">经验总结</h2>\n<h3 id=\"最佳实践\">最佳实践</h3>\n<ol>\n<li>\n<p><strong>任务拆分原则</strong></p>\n<ul>\n<li>复杂功能拆分为多个变更</li>\n<li>每个变更 8-16 个任务</li>\n<li>任务之间有明确依赖顺序</li>\n</ul>\n</li>\n<li>\n<p><strong>提示词模板</strong></p>\n<pre><code>请严格按照 openspec/changes/&lt;change-name&gt;/tasks.md 实现。\n\n执行要求：\n1. 按编号顺序完成每个任务\n2. 每完成一个，输出：[DONE] 任务X.X: &lt;描述&gt;\n3. 全部完成后输出：[ALL DONE]\n4. 遇到问题输出：[ERROR]: &lt;描述&gt;\n</code></pre>\n</li>\n<li>\n<p><strong>监控频率</strong></p>\n<ul>\n<li>每 30 秒检查一次进度</li>\n<li>5 分钟无新 <code>[DONE]</code> 标记视为卡住</li>\n<li>准备好手动兜底的 plan B</li>\n</ul>\n</li>\n<li>\n<p><strong>工具链组合</strong></p>\n<table>\n<thead>\n<tr>\n<th>工具</th>\n<th>作用</th>\n<th>优势</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OpenClaw</td>\n<td>任务管理</td>\n<td>会话、监控、错误处理</td>\n</tr>\n<tr>\n<td>OpenSpec</td>\n<td>规范定义</td>\n<td>结构化需求、易于追溯</td>\n</tr>\n<tr>\n<td>OpenCode</td>\n<td>代码生成</td>\n<td>按规范自动实现</td>\n</tr>\n</tbody>\n</table>\n</li>\n</ol>\n<h3 id=\"适用场景\">适用场景</h3>\n<p><strong>适合：</strong></p>\n<ul>\n<li>✅ 功能明确、边界清晰的需求</li>\n<li>✅ 重复性的 CRUD 操作</li>\n<li>✅ 数据库迁移、API 开发</li>\n<li>✅ 基于现有模式的扩展</li>\n</ul>\n<p><strong>不适合：</strong></p>\n<ul>\n<li>❌ 需求模糊、需要探索</li>\n<li>❌ 复杂架构设计</li>\n<li>❌ 深度性能优化</li>\n<li>❌ 创新性算法</li>\n</ul>\n<h3 id=\"性能基准树莓派-4b-实测\">性能基准（树莓派 4B 实测）</h3>\n<table>\n<thead>\n<tr>\n<th>单个变更任务数</th>\n<th>成功率</th>\n<th>平均耗时</th>\n<th>推荐度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3-6 个</td>\n<td>95%</td>\n<td>3-5分钟</td>\n<td>⭐⭐⭐⭐⭐</td>\n</tr>\n<tr>\n<td>7-10 个</td>\n<td>85%</td>\n<td>5-10分钟</td>\n<td>⭐⭐⭐⭐</td>\n</tr>\n<tr>\n<td>11-16 个</td>\n<td>70%</td>\n<td>10-15分钟</td>\n<td>⭐⭐⭐</td>\n</tr>\n<tr>\n<td>&gt;16 个</td>\n<td>&lt;30%</td>\n<td>卡住</td>\n<td>❌ 不推荐</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h2 id=\"完整工作流示例\">完整工作流示例</h2>\n<p><strong>从需求到部署的标准流程：</strong></p>\n<pre><code>1. 需求分析（任琪）\n   ↓\n2. 创建 OpenSpec 变更\n   $ openspec change new feature-name\n   ↓\n3. 编写规范文档\n   - proposal.md（为什么要做）\n   - design.md（怎么做）\n   - tasks.md（任务清单，≤16个任务）\n   ↓\n4. OpenClaw 调用 OpenCode\n   $ sessions_spawn task:\"实现功能\" label:\"implement-feature\"\n   ↓\n5. 实时监控和管理\n   $ sessions_list\n   $ sessions_history sessionKey:\"...\"\n   ↓\n6. 代码验证\n   - 自动语法检查\n   - 功能测试\n   ↓\n7. 提交和推送\n   $ git add .\n   $ git commit -m \"实现功能\"\n   $ git push\n   ↓\n8. 归档规范\n   $ openspec change archive feature-name\n</code></pre>\n<hr />\n<h2 id=\"结语\">结语</h2>\n<p>用 OpenClaw 调用 OpenCode 进行开发，最大的价值是<strong>可控性</strong>。</p>\n<ul>\n<li>任务在后台运行，不阻塞当前会话</li>\n<li>实时监控进度，知道做到哪了</li>\n<li>卡住时自动处理或报警</li>\n<li>所有工作可追溯、可管理</li>\n</ul>\n<p>但这套工具链也有局限。它适合<strong>执行明确的需求</strong>，不适合<strong>探索未知的问题</strong>。关键还是<strong>把需求想清楚</strong>——这是程序员的工作，AI 无法替代。</p>\n<p>如果你也在尝试类似的工作流，欢迎交流踩坑经验。</p>\n<hr />\n<h2 id=\"参考链接\">参考链接</h2>\n<ul>\n<li>OpenClaw 文档：<a href=\"https://docs.openclaw.ai\" rel=\"noopener nofollow\" target=\"_blank\">https://docs.openclaw.ai</a></li>\n<li>OpenSpec 仓库：<a href=\"https://github.com/fission-ai/openspec\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/fission-ai/openspec</a></li>\n<li>OpenCode 文档：<a href=\"https://opencode.ai\" rel=\"noopener nofollow\" target=\"_blank\">https://opencode.ai</a></li>\n<li>爱弥儿任务看板：<a href=\"https://github.com/ren8179/aimier-kanban\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/ren8179/aimier-kanban</a></li>\n</ul>\n<hr />\n<p><em>本文是爱弥儿任务看板开发过程中的真实记录，由 AI 助手爱弥儿整理撰写。</em></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-13 08:56</span>&nbsp;\n<a href=\"https://www.cnblogs.com/rsls\">五蕴非空</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}