{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "TAOCP 1.2.1部分习题",
      "link": "https://www.cnblogs.com/SilverGo/p/19518861",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/SilverGo/p/19518861\" id=\"cb_post_title_url\" title=\"发布于 2026-01-22 19:40\">\n    <span>TAOCP 1.2.1部分习题</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"taocp-121部分习题\">TAOCP 1.2.1部分习题</h1>\n<h2 id=\"t9\">T9</h2>\n<p><strong>题目标记</strong>：[25]</p>\n<p><strong>题目</strong>：<br />\n试求下面式子的求和表达式，并予以证明：</p>\n<p></p><div class=\"math display\">\\[1^2 , 2^2 -1^2 , 3^2 -2^2 +1^2 , 4^2 -3^2 +2^2 -1^2\n\\]</div><p></p><p><strong>以下是分析</strong>：<br />\n手动计算几个，发现就是等差数列求和。<br />\n于是我们猜想，前n项和为 <span class=\"math inline\">\\(\\frac{n(n+1)}{2}\\)</span> 。</p>\n<p><strong>接下来是证明</strong>：</p>\n<p>我们使用数学归纳法证明。</p>\n<p>当 <span class=\"math inline\">\\(n=1\\)</span> 时，左边为 <span class=\"math inline\">\\(1^2=1\\)</span>，右边为 <span class=\"math inline\">\\(\\frac{1(1+1)}{2}=1\\)</span>，成立。</p>\n<p>假设当 <span class=\"math inline\">\\(n=k\\)</span> 时，等式成立，即归纳假设IHk:</p>\n<p></p><div class=\"math display\">\\[k^2 - (k-1)^2 + (k-2)^2 - \\cdots - (-1)^{k}= \\frac{k(k+1)}{2}\n\\]</div><p></p><p>成立。</p>\n<p>现在考虑 <span class=\"math inline\">\\(n=k+1\\)</span> 的情况。记前 <span class=\"math inline\">\\(n\\)</span> 项和为 <span class=\"math inline\">\\(F_n\\)</span>，则有</p>\n<p></p><div class=\"math display\">\\[F_k = \\frac{k(k+1)}{2}\n\\]</div><p></p><p>我们尝试表示 <span class=\"math inline\">\\(F_{k+1}-F_k\\)</span>，注意到 <span class=\"math inline\">\\(F_{k+1}\\)</span> 与 <span class=\"math inline\">\\(F_k\\)</span> 除首项外，每项符号相反，因此，当我们计算 <span class=\"math inline\">\\(F_{k+1}-F_k\\)</span> 时，只有首项 <span class=\"math inline\">\\((k+1)^2\\)</span> 会被保留，其余项均翻倍。</p>\n<p>因此，</p>\n<p></p><div class=\"math display\">\\[F_{k+1} -F_k = - 2F_k + (k+1)^2 \\\\\n= - 2 \\cdot \\frac{k(k+1)}{2} + (k+1)^2 \\\\\n= - k(k+1) + (k+1)^2 \\\\\n= (k+1)(-k + k + 1) \\\\\n= k+1\n\\]</div><p></p><p>因此，</p>\n<p></p><div class=\"math display\">\\[F_{k+1} = F_k + (k+1) \\\\\n= \\frac{k(k+1)}{2} + (k+1) \\\\\n= \\frac{k(k+1) + 2(k+1)}{2} \\\\\n= \\frac{(k+1)(k+2)}{2}\n\\]</div><p></p><p>证毕。</p>\n<h2 id=\"t10\">T10</h2>\n<p><strong>题目标记</strong>：[30]</p>\n<p><strong>题目</strong>：<br />\n试求下面式子的求和表达式，并予以证明：</p>\n<p></p><div class=\"math display\">\\[\\frac{1^3}{1^4+4} +\\frac{3^3}{3^4+4}+ \\cdots + \\frac{(-1)^{n}(2n-1)^3}{(2n-1)^4+4}\n\\]</div><p></p><p><strong>以下是分析</strong>：<br />\n手动计算，我们注意到，分母之间每次差4的倍数，于是我们大胆猜想，是否有分母是类似 <span class=\"math inline\">\\(1+4 \\times 2+4 \\times 3+ \\cdots +4 \\times n\\)</span> 的形式。</p>\n<p>显然是有的，这一步大约花费了我5min的时间。</p>\n<p>随后我们考虑分子，肉眼就能观察到，分子就是 <span class=\"math inline\">\\(n\\)</span> 。</p>\n<p>综上，我们有：</p>\n<p></p><div class=\"math display\">\\[\\frac{1^3}{1^4+4} +\\frac{3^3}{3^4+4}+ \\cdots + \\frac{(-1)^{n}(2n-1)^3}{(2n-1)^4+4} \\\\\n= \\frac{(-1)^{n+1} \\cdot n}{1+4n^2}\n\\]</div><p></p><p><strong>接下来是证明</strong>：</p>\n<p>我们使用数学归纳法证明。</p>\n<p>当 <span class=\"math inline\">\\(n=1\\)</span> 时，左边为 <span class=\"math inline\">\\(\\frac{1^3}{1^3+4}=\\frac{1}{5}\\)</span>，右边为 <span class=\"math inline\">\\(\\frac{(-1)^{1+1} \\cdot 1}{1+4 \\cdot 1^2}=\\frac{1}{5}\\)</span>，成立。</p>\n<p>假设当 <span class=\"math inline\">\\(n=k\\)</span> 时，等式成立，即</p>\n<p></p><div class=\"math display\">\\[\\frac{1^3}{1^4+4} +\\frac{3^3}{3^4+4}+ \\cdots + \\frac{(-1)^{k}(2k-1)^3}{(2k-1)^4+4} \\\\\n= \\frac{(-1)^{k+1} \\cdot k}{1+4k^2}\n\\]</div><p></p><p>现在考虑 <span class=\"math inline\">\\(n=k+1\\)</span> 的情况。我们记前 <span class=\"math inline\">\\(n\\)</span> 项和为 <span class=\"math inline\">\\(F_n\\)</span>，则有</p>\n<p></p><div class=\"math display\">\\[F_k = \\frac{(-1)^{k+1} \\cdot k}{1+4k^2}\n\\]</div><p></p><p>则左边为</p>\n<p></p><div class=\"math display\">\\[\\frac{1^3}{1^4+4} +\\frac{3^3}{3^4+4}+ \\cdots + \\frac{(-1)^{k}(2k-1)^3}{(2k-1)^4+4} + \\frac{(-1)^{k+1}(2(k+1)-1)^3}{(2(k+1)-1)^4+4} \\\\\n= F_k + \\frac{(-1)^{k+1}(2(k+1)-1)^3}{(2(k+1)-1)^4+4} \\\\\n\\]</div><p></p><p></p><div class=\"math display\">\\[= \\frac{(-1)^{k+1} \\cdot k}{1+4k^2} + \\frac{(-1)^{k+1}(2k+1)^3}{(2k+1)^4+4} \\\\\n\\]</div><p></p><p></p><div class=\"math display\">\\[= \\frac{(-1)^{k+1} \\cdot k((2k+1)^4+4) + (-1)^{k+1}(2k+1)^3(1+4k^2)}{(1+4k^2)((2k+1)^4+4)} \\\\\n\\]</div><p></p><p></p><div class=\"math display\">\\[= \\frac{(-1)^{k+1}((2k+1)^3(1+4k^2) + k((2k+1)^4+4))}{(1+4k^2)((2k+1)^4+4)} \\\\\n\\]</div><p></p><p></p><div class=\"math display\">\\[= \\frac{(-1)^{k+1}((2k+1)^3 + 8k^2(2k+1)^3 + k(16k^4 + 32k^3 + 24k^2 + 8k + 5))}{(1+4k^2)((2k+1)^4+4)} \\\\\n\\]</div><p></p><p></p><div class=\"math display\">\\[= \\frac{(-1)^{k+1}(16k^5 + 32k^4 + 24k^3 + 8k^2 + (2k+1)^3 + 8k^2(2k+1)^3)}{(1+4k^2)((2k+1)^4+4)} \\\\\n\\]</div><p></p><p></p><div class=\"math display\">\\[= \\frac{(-1)^{k+1}(16k^5 + 32k^4 + 24k^3 + 8k^2 + 8k^3 + 12k^2 + 6k + 1 + 64k^5 + 96k^4 + 48k^3 + 8k^2)}{(1+4k^2)((2k+1)^4+4)} \\\\\n\\]</div><p></p><p></p><div class=\"math display\">\\[= \\frac{(-1)^{k+1}(80k^5 + 128k^4 + 80k^3 + 28k^2 + 6k + 1)}{(1+4k^2)((2k+1)^4+4)} \\\\\n\\]</div><p></p><p></p><div class=\"math display\">\\[= \\frac{(-1)^{k+1}((2k+2)(16k^4 + 48k^3 + 40k^2 + 12k + 1))}{(1+4k^2)((2k+1)^4+4)} \\\\\n\\]</div><p></p><p></p><div class=\"math display\">\\[= \\frac{(-1)^{k+2} \\cdot (k+1)}{1+4(k+1)^2}\n\\]</div><p></p><p>证毕。</p>\n<h2 id=\"t16t15加强版本\">T16：（T15加强版本）</h2>\n<p><strong>题目</strong>：<br />\n求</p>\n<p></p><div class=\"math display\">\\[\\sum_{j=0}^{n}{jx^j}\n\\]</div><p></p><p><strong>解</strong>：</p>\n<p></p><div class=\"math display\">\\[\\sum_{j=0}^{n}{jx^j} \\\\\n= \\sum_{0\\leq i\\leq n}{ix^i} \\\\\n= x\\sum_{1\\leq i\\leq n}{ix^{i-1}} \\\\\n= x\\sum_{0\\leq i\\leq n-1}{(i+1)x^i} \\\\\n= x\\sum_{0\\leq i\\leq n-1}{ix^i} + x\\sum_{0\\leq i\\leq n-1}{x^i} \\\\\n= x\\sum_{0\\leq i\\leq n}{ix^i} -nx^{n+1} + x\\sum_{0\\leq i\\leq n-1}{x^i}\n\\]</div><p></p><p>注意到：</p>\n<p></p><div class=\"math display\">\\[x\\sum_{0\\leq i\\leq n-1}{x^i} \\\\\n= x\\sum_{0\\leq i\\leq n}{x^i} -x^{n+1} \\\\\n= x + x\\sum_{1\\leq i\\leq n}{x^i} -x^{n+1} \\\\\n= x + x^{2}\\sum_{1\\leq i\\leq n}{x^{i-1}} -x^{n+1} \\\\\n= x + x^{2}\\sum_{0\\leq i\\leq n-1}{x^{i}} -x^{n+1}\n\\]</div><p></p><p>不妨令：</p>\n<p></p><div class=\"math display\">\\[S = x\\sum_{0\\leq i\\leq n-1}{x^i}\n\\]</div><p></p><p>我们有：</p>\n<p></p><div class=\"math display\">\\[S = x+ xS -x^{n+1} \\\\\n\\]</div><p></p><p></p><div class=\"math display\">\\[S-Sx = x-x^{n+1} \\\\\n\\]</div><p></p><p></p><div class=\"math display\">\\[S = \\frac{x-x^{n+1}}{1-x}\n\\]</div><p></p><p>所以：</p>\n<p></p><div class=\"math display\">\\[\\sum_{j=0}^{n}{jx^j} \\\\\n= x\\sum_{0\\leq i\\leq n}{ix^i} -nx^{n+1} + x\\sum_{0\\leq i\\leq n-1}{x^i} \\\\\n= x\\sum_{0\\leq i\\leq n}{ix^i} -nx^{n+1} + \\frac{x-x^{n+1}}{1-x}\n\\]</div><p></p><p>再令：</p>\n<p></p><div class=\"math display\">\\[F = \\sum_{1\\leq i\\leq n}{ix^i}\n\\]</div><p></p><p>我们有：</p>\n<p></p><div class=\"math display\">\\[F = x\\sum_{0\\leq i\\leq n}{ix^i} -nx^{n+1} + \\frac{x-x^{n+1}}{1-x} \\\\\n\\]</div><p></p><p></p><div class=\"math display\">\\[F-xF = -nx^{n+1} + \\frac{x-x^{n+1}}{1-x} \\\\\n\\]</div><p></p><p></p><div class=\"math display\">\\[F = \\frac{nx^{n+2}-(n+1)x^{n+1}+x}{(x-1)^2}\n\\]</div><p></p><p>结束。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-22 19:40</span>&nbsp;\n<a href=\"https://www.cnblogs.com/SilverGo\">Ghost-Face</a>&nbsp;\n阅读(<span id=\"post_view_count\">2</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "AI开发-python-langchain框架（1-4动态少样本提示）",
      "link": "https://www.cnblogs.com/yclh/p/19518845",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yclh/p/19518845\" id=\"cb_post_title_url\" title=\"发布于 2026-01-22 19:31\">\n    <span>AI开发-python-langchain框架（1-4动态少样本提示）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p class=\"qwen-markdown-paragraph\"><span class=\"qwen-markdown-text\">这个代码的核心功能是：<strong class=\"qwen-markdown-strong\"><span class=\"qwen-markdown-text\">基于输入词的长度动态选择反义词示例，并调用大模型生成反义词</span></strong><span class=\"qwen-markdown-text\">，体现了 <strong class=\"qwen-markdown-strong\"><span class=\"qwen-markdown-text\">“动态少样本提示（Dynamic Few-Shot Prompting）”</span></strong><span class=\"qwen-markdown-text\"> 与 <strong class=\"qwen-markdown-strong\"><span class=\"qwen-markdown-text\">“上下文长度感知的示例选择”</span></strong><span class=\"qwen-markdown-text\"> 的能力。</span></span></span></span></p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:python;gutter:true;\">from langchain.prompts import FewShotPromptTemplate, PromptTemplate\nfrom langchain.prompts.example_selector import LengthBasedExampleSelector\nfrom langchain_core.output_parsers import StrOutputParser\nfrom langchain_openai import ChatOpenAI\nimport os\nfrom dotenv import load_dotenv\n\n\n# 定义反义词任务的示例数据集（few-shot examples）\n# 每个示例包含一个输入词（input）和对应的反义词（output）\nexamples = [\n    {\"input\": \"开心\", \"output\": \"伤心\"},\n    {\"input\": \"高\", \"output\": \"矮\"},\n    {\"input\": \"精力充沛\", \"output\": \"没精打采\"},\n    {\"input\": \"粗\", \"output\": \"细\"},\n]\n\n# 定义单个示例的格式模板\n# 使用 {input} 和 {output} 作为占位符，用于后续填充具体值\nexample_prompt = PromptTemplate(\n    input_variables=[\"input\", \"output\"],  # 声明模板中使用的变量名\n    template=\"Input: {input}\\nOutput: {output}\",  # 示例的文本格式\n)\n\n# 创建一个基于长度的示例选择器（LengthBasedExampleSelector）\n# 作用：根据输入提示的总长度动态选择最合适的示例数量，避免超出模型上下文限制\nexample_selector = LengthBasedExampleSelector(\n    examples=examples,  # 提供所有候选示例\n    example_prompt=example_prompt,  # 用于格式化每个示例的模板\n    max_length=25,  # 设定整个 prompt（含前缀、示例、后缀）的最大 token 长度（此处为字符数近似）\n    # 注意：LengthBasedExampleSelector 默认使用 len(text) 计算长度（非精确 token 数），适用于简单场景\n)\n\n# 构建动态少样本提示模板（FewShotPromptTemplate）\n# 它会根据输入内容的长度，自动从 examples 中选择合适数量的示例插入到 prompt 中\ndynamic_prompt = FewShotPromptTemplate(\n    example_selector=example_selector,  # 使用上面定义的动态选择器（而非固定示例列表）\n    example_prompt=example_prompt,      # 单个示例的格式\n    prefix=\"给出每个输入的反义词\",       # 提示的开头部分（任务指令）\n    suffix=\"Input: {adjective}\\nOutput:\",  # 提示的结尾部分，包含待预测的输入占位符\n    input_variables=[\"adjective\"],      # 声明最终用户输入的变量名（与 suffix 中的 {adjective} 对应）\n)\n\n# === 测试 1：输入较短，应选择多个示例 ===\nprint(\"【测试1】输入较短，选择多个示例：\")\nprint(dynamic_prompt.format(adjective=\"big\"))\n\nprint('------------')\n\n# === 测试 2：输入很长，应只选择少量或一个示例以控制总长度 ===\nlong_string = \"big and huge and massive and large and gigantic and tall and much much much much much bigger than everything else\"\nprint(\"【测试2】输入很长，仅选择一个示例：\")\nprint(dynamic_prompt.format(adjective=long_string))\n\nprint('------------')\n\n# === 测试 3：动态添加新示例 ===\n# 向示例选择器中新增一个示例（\"胖\" -&gt; \"瘦\"）\nnew_example = {\"input\": \"胖\", \"output\": \"瘦\"}\ndynamic_prompt.example_selector.add_example(new_example)\nprint(\"【测试3】添加新示例后，查询'热情'：\")\nprint(dynamic_prompt.format(adjective=\"热情\"))\n\nprint('------------')\n\n# === 配置并调用 DeepSeek 大语言模型 ===\n\nllm = ChatOpenAI(\n    api_key=os.getenv(\"DEEPSEEK_API_KEY\"),\n    base_url=os.getenv(\"DEEP_URL\"),  # Deepseek 的 API 基础地址\n    model=\"deepseek-v3:671b\",  # Deepseek 对话模型（可选：deepseek-chat-pro 等高级模型）\n    temperature=0.7,  # 温度参数（0-1，越低越稳定）\n    max_tokens=1024  # 最大生成 tokens\n)\n\n# 创建字符串输出解析器，用于将模型返回的 AIMessage 转换为纯文本\noutput_parser = StrOutputParser()\n\n# 构建处理链（Chain）：prompt → LLM → output parser\n# 使用 LangChain 的管道操作符 `|` 连接各组件\nchain = dynamic_prompt | llm | output_parser\n\n# 调用链，传入输入变量 {\"adjective\": \"热情\"}\n# 注意：chain.invoke() 内部已包含 llm 调用和 output_parser 解析，无需再手动调用 output_parser\nmessage = chain.invoke({\"adjective\": \"热情\"})\n\n# ⚠️ 注意：上一行 `chain.invoke()` 已经返回了字符串（因为最后是 StrOutputParser）\n# 所以下面这行是多余的，甚至会导致错误（因为 message 已是 str，不能再次 invoke）\n# result = output_parser.invoke(message)  # ❌ 错误：message 是 str，不是 AIMessage\n\n# 正确做法：直接使用 message 作为结果\nresult = message\n\nprint('###############')\nprint(\"【模型输出】\")\nprint(result)\n</pre>\n</div>\n<h1>输出结果：</h1>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:python;gutter:true;\">【测试1】输入较短，选择多个示例：\n给出每个输入的反义词\n\nInput: 开心\nOutput: 伤心\n\nInput: 高\nOutput: 矮\n\nInput: 精力充沛\nOutput: 没精打采\n\nInput: 粗\nOutput: 细\n\nInput: big\nOutput:\n------------\n【测试2】输入很长，仅选择一个示例：\n给出每个输入的反义词\n\nInput: 开心\nOutput: 伤心\n\nInput: big and huge and massive and large and gigantic and tall and much much much much much bigger than everything else\nOutput:\n------------\n【测试3】添加新示例后，查询'热情'：\n给出每个输入的反义词\n\nInput: 开心\nOutput: 伤心\n\nInput: 高\nOutput: 矮\n\nInput: 精力充沛\nOutput: 没精打采\n\nInput: 粗\nOutput: 细\n\nInput: 胖\nOutput: 瘦\n\nInput: 热情\nOutput:\n------------\n###############\n【模型输出】\n冷淡\n</pre>\n</div>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h1>&nbsp;</h1>\n<h1>核心要点总结</h1>\n<div>&nbsp;</div>\n<div>这段代码是基于 LangChain 框架对接 DeepSeek 大模型，实现「动态少样本（Few-Shot）反义词生成」的完整案例，核心解决「固定示例易超出模型上下文长度」的问题，通过动态示例选择器适配不同长度输入，同时结合 LangChain 链式调用简化模型调用流程，先明确整体定位，再拆解核心重点：</div>\n<div>&nbsp;</div>\n<h2>一、整体流程概览（核心逻辑链）</h2>\n<div>&nbsp;</div>\n<div>代码遵循 LangChain 「示例准备 → 动态提示构建 → 模型调用 → 结果解析」的少样本学习经典流程，整体可概括为：</div>\n<div>\n<div dir=\"ltr\">\n<div>\n<pre><code>1. 定义反义词任务的固定示例数据集，为模型提供参考案例\n2. 配置基于长度的示例选择器，根据输入文本长度动态筛选示例数量\n3. 构建动态少样本提示模板，自动适配输入长度生成合规 Prompt\n4. 初始化 DeepSeek 模型客户端，配置核心调用参数\n5. 构建「提示模板 → 大模型 → 输出解析」的链式调用流程\n6. 调用链条完成反义词生成，并输出纯文本结果\n</code></pre>\n</div>\n<div>&nbsp;</div>\n</div>\n</div>\n<div>&nbsp;</div>\n<h2>二、核心重点拆解（必掌握）</h2>\n<div>&nbsp;</div>\n<h3>1. 少样本提示（Few-Shot Prompt）核心组件</h3>\n<div>&nbsp;</div>\n<div>这是实现「模型参考示例生成结果」的基础，也是 LangChain 提示工程的核心用法：</div>\n<div>&nbsp;</div>\n<div>&nbsp; &nbsp;<code>- 示例数据集（examples）：以键值对形式存储「输入-输出」示例，为模型提供任务参考（如\"开心\"→\"伤心\"）；</code></div>\n<div><code> - 单示例模板（example_prompt）：定义单个示例的文本格式（Input/Output 固定样式），统一示例展示形式；</code></div>\n<div>\n<div dir=\"ltr\">\n<div>\n<pre><code>- 动态少样本模板（FewShotPromptTemplate）：整合示例选择器、单示例模板、前缀/后缀，生成最终发给模型的完整 Prompt；\n  - prefix：任务指令（\"给出每个输入的反义词\"），明确模型要执行的任务；\n  - suffix：待填充的用户输入占位符，承接动态输入内容。\n</code></pre>\n</div>\n</div>\n</div>\n<h3>2. 动态示例选择器（LengthBasedExampleSelector）</h3>\n<div>&nbsp;</div>\n<div>这是代码的核心亮点，解决「固定示例数量易超上下文长度」的问题：</div>\n<div>\n<div dir=\"ltr\">\n<div>\n<pre><code>核心作用：根据输入文本的长度，自动计算并选择合适数量的示例（输入越长，选的示例越少），避免 Prompt 总长度超出模型上下文限制；\n关键参数：\n  - examples：候选示例列表；\n  - example_prompt：示例格式化模板（用于计算单示例长度）；\n  - max_length：Prompt 允许的最大长度（此处为字符数近似值）。\n</code></pre>\n</div>\n<div>&nbsp;</div>\n</div>\n</div>\n<div>&nbsp;</div>\n<h3>3. LangChain 链式调用（| 操作符）</h3>\n<div>&nbsp;</div>\n<div>简化多组件协作流程，是 LangChain 核心设计理念：</div>\n<div>\n<div dir=\"ltr\">\n<div>\n<pre><code>- 链条构成：dynamic_prompt（生成 Prompt） | llm（调用模型） | output_parser（解析结果）；\n- 核心优势：无需手动分步调用（先格式化 Prompt、再调用模型、最后解析结果），一行代码完成全流程；\n- 调用方式：chain.invoke({\"adjective\": \"热情\"}) 传入输入变量，直接返回解析后的纯文本结果。\n</code></pre>\n</div>\n<div>&nbsp;</div>\n</div>\n</div>\n<div>&nbsp;</div>\n<h3>4. 输出解析器（StrOutputParser）</h3>\n<div>&nbsp;</div>\n<div>解决「模型返回 AIMessage 对象→提取纯文本」的问题：</div>\n<div>\n<div dir=\"ltr\">\n<div>\n<pre><code>核心作用：将 LangChain 模型返回的 AIMessage 类型（含 content/metadata 等字段）转换为纯字符串，简化结果使用；\n关键注意点：链式调用中已包含解析步骤，无需手动再次调用 output_parser.invoke()（否则会报错）。</code></pre>\n</div>\n</div>\n</div>\n<p>&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-22 19:31</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yclh\">万笑佛</a>&nbsp;\n阅读(<span id=\"post_view_count\">7</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "SEAL全同态加密BFV方案入门详解",
      "link": "https://www.cnblogs.com/zhaoweiwei/p/19510487/bfv",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zhaoweiwei/p/19510487/bfv\" id=\"cb_post_title_url\" title=\"发布于 2026-01-22 15:50\">\n    <span>SEAL全同态加密BFV方案入门详解</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文介绍微软的开源全同态项目SEAL中BFV方案的相关数学理论基础，以及相应加解密的主要流程，最后简单地介绍了SEAL源码的编译过程及简单应用示例。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>Microsoft SEAL（Simple Encrypted Arithmetic Library）是微软开源的轻量级、高性能全同态加密（FHE）库，专为整数/浮点数的密文运算设计，支持BFV、CKKS、BGV等主流FHE方案，广泛应用于隐私计算、联邦学习、数据加密等场景，源码：<a href=\"https://github.com/microsoft/SEAL\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/microsoft/SEAL</a>。</p>\n<h1>1 数学基础</h1>\n<h2>1.1 多项式环</h2>\n<p>SEAL使用的基础环是：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260121153443048-88951557.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p align=\"left\">BFV的所有运算都在这个多项式环中进行，符号含义如下：</p>\n<p align=\"left\">Z<sub>q</sub>：系数域，即多项式的所有系数都取自“模q的整数集合”，q称为系数模数（一个大素数或多个素数的乘积），决定密文的噪声容忍度和运算深度。</p>\n<p align=\"left\">x<sup>N</sup>+1：多项式模，要求N是2的整数幂（如4096、8192），满足x<sup>N</sup>≡-1 (mod x<sup>N</sup>+1)，这意味着所有多项式的次数都不会超过N-1（超过的项可通过x<sup>N</sup> = -1降次）。</p>\n<p align=\"left\">R<sub>q</sub>元素形式：任意元素是一个次数≤ N - 1的多项式，形如：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260121154506434-1453063209.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>&nbsp;</p>\n<h2>1.2 明文空间</h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260121155707555-629451098.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>明文（待加密的整数）会被编码为R<sub>t</sub>中的多项式，t满足t≡1 (mod 2N)，这是批量加密的硬性要求，明文在进行加密前要进行编码，有两种编码方式：</p>\n<p><strong>单整数编码</strong>：将单个整数m编码为常数多项式f(x)=m，即所有高次项系数为0。</p>\n<p><strong>批量编码</strong>：将N个小整数[m<sub>0</sub>,m<sub>1</sub>,...,m<sub>N-1</sub>]直接做为多项式的系数，编码为：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260121160312132-985918846.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<h2>1.3 RLWE问题</h2>\n<p align=\"left\">BFV的安全性基于RLWE问题（Ring Learning With Errors）的计算困难性，简单描述为：</p>\n<p align=\"left\">给定多项式R<sub>q</sub>，选择一个秘密多项式s(x)∈R<sub>q</sub>（系数为0/1的短多项式），以及大量的“噪声多项式对”（a<sub>i</sub>(x), b<sub>i</sub>(x)），其中a<sub>i</sub>(x)是随机生成的，b<sub>i</sub>(x)=-a<sub>i</sub>(x)s(x)+e<sub>i</sub>(x) (mod q)是通过秘密多项式s(x)计算得到的“响应多项式”，加入噪声e<sub>i</sub>(x)是为了让b<sub>i</sub>(x)看起来像一个完全随机的多项式，从而隐藏s(x)的存在，而在计算上无法从这些多项式对中恢复出秘密多项式s(x)。对于b<sub>i</sub>(x)其生成时每一部分的作用如下：</p>\n<p align=\"left\">a<sub>i</sub>(x)：从多项式环R<sub>q</sub>中均匀随机生成的多项式，相当于“公共输入”，可以公开。</p>\n<p align=\"left\">s(x)：秘密多项式（系数仅为0或1），是整个RLWE问题的核心，必须严格保密。</p>\n<p align=\"left\">e<sub>i</sub>(x)：小系数噪声多项式（系数仅为-1、0、1），是“隐藏秘密”的关键。</p>\n<p align=\"left\">b<sub>i</sub>(x)：由a<sub>i</sub>(x)s(x)加上噪声得到的结果，与ai(x)一起构成公开的“多项式对”。</p>\n<p align=\"left\">如果没有噪声e<sub>i</sub>(x)，即e<sub>i</sub>(x)=0，那么b<sub>i</sub>(x)=-a<sub>i</sub>(x)s(x) (mod q)，此时攻击者可以通过多组(a<sub>i</sub>(x), b<sub>i</sub>(x))构建线性方程组，直接解密出秘密多项式s(x)，这就完全失去了安全性。而加入小噪声e<sub>i</sub>(x)后：</p>\n<p align=\"left\">b<sub>i</sub>(x)不再是a<sub>i</sub>(x)s(x)的精确结果，而是一个“近似值”；</p>\n<p align=\"left\">这个近似值的误差被控制在很小的范围内（由e<sub>i</sub>(x)的系数大小决定）；</p>\n<p align=\"left\">从计算角度，目前没有任何算法（包括量子算法）能高效地从这些带噪声的近似结果中恢复出s(x)，这正是RLWE问题的“计算困难性”来源，也是BFV适合后量子秘密场景的原因。</p>\n<h2>1.4 缩放因子</h2>\n<p>在BFV同态加密方案中，缩放因子（Scaling Factor）是连接明文空间（Z<sub>t</sub>）和密文空间（Z<sub>q</sub>）的核心系数，本质是为了让明文多项式能“适配”系数模数q的范围，同时保证解密时可以精确还原明文。BFV的明文模数t远小于系数模数q（t&lt;&lt;q)，比如t=65537，q=2<sup>60</sup>量级。</p>\n<p>明文多项式m(x)∈R<sub>t</sub>的系数范围是[0, t-1]，而密文多项式c(x)∈R<sub>q</sub>的系数范围是[0, q-1]，如果直接将明文m(x)放入密文公式，由于t太小，明文信息会被噪声和掩码完全淹没，无法解密。因此需要一个缩放因子，将明文系数放大到q的量级，再参与密文计算。缩放因子贯穿加密和解密两个核心步骤，是明文和密文的“桥梁”。</p>\n<p>（1）加密时：明文放大</p>\n<p>在加密步骤中，明文多项式m(x)不会直接代入密文公式，而是先乘于缩放因子Δ，再放入到公式：</p>\n<p>&nbsp;</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122103147623-1899019256.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>作用：将明文系数从[0, t-1]放大到[0,&nbsp;Δ*(t-1)]，这个范围在q的量级内，能避免明文被噪声覆盖。</p>\n<p>（2）解密时：明文缩小</p>\n<p>解密的核心步骤是先计算聚合多项式D(ct)，代入加密公式后可得：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122103532065-202805649.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>此时需要反向缩放来还原明文：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122103637412-765250880.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>概括来说，缩放因子不会直接参与运算，但会间接影响噪声的增长速度：</p>\n<p align=\"left\">1) 加法运算：密文加法是系数直接相加，噪声线性叠加，缩放因子不影响噪声增长；</p>\n<p align=\"left\">2) 乘法运算：密文乘法是多项式乘法，噪声会平方增长，而缩放因子Δ越大，噪声的规模也会越大，导致运算深度降低。</p>\n<p align=\"left\">因此，在参数配置时，需要在“明文范围（t大小）”和“运算深度（q大小）”之间做权衡：</p>\n<p align=\"left\">若t增大→Δ减小→噪声容忍度提升→运算深度增加；</p>\n<p align=\"left\">若t减小→Δ增大→噪声容忍度降低→运算深度减小。</p>\n<p align=\"left\">所以t与Δ成反比，需根据业务需求平衡明文范围和运算深度。</p>\n<h1>2 BFV核心流程</h1>\n<h2>2.1 参数配置</h2>\n<p>参数配置决定方案的性能与安全性，BFV核心参数有4个，需严格满足数学约束：</p>\n<p><img alt=\"image\" height=\"249\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260121155055832-1091265286.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"798\" /></p>\n<p>参数约束：需满足q&gt;t*(2N)<sup>d</sup>*B（d是目标运算深度，B是噪声上限），否则运算过程中噪声会“爆炸”导致解密失败。</p>\n<h2>2.2 密钥生成</h2>\n<p>基于RLWE问题生成私钥、公钥、重线性化密钥3中密钥，核心是构造含噪声的多项式对。</p>\n<p>（1）私钥（sk）</p>\n<p>随机生成一个短多项式s(x)∈R<sub>q</sub>，系数仅为0或1（如s(x) = 1 + x<sup>2</sup> + x<sup>5</sup>），私钥就是s(x)。</p>\n<p>（2）公钥（pk）</p>\n<p>随机生成多项式a(x)∈R<sub>q</sub>，生成小希数噪声多项式e(x)∈R<sub>q</sub>，计算b(x) = -a(x)s(x) + e(x) (mod q)，公钥是多项式对pk = (b(x), a(x))，可公开传播。这里的噪声e(x)让攻击者无法从公钥对中恢复私钥s(x)，目的是解决“公钥本身的安全性”。</p>\n<p>（3）重线性化密钥（rlk）</p>\n<p>密文乘法会导致密文从“2项多项式”膨胀为“3项多项式”，后续运算效率骤降。重线性化密钥用于将膨胀后的密文压缩回2项，生成逻辑与公钥类似，本质是一组扩展的RLWE多项式对。</p>\n<h2>2.3 加密</h2>\n<p>将明文多项式转为密文多项式，BFV的密文是R<sub>q</sub>中的2项多项式对ct = (c<sub>0</sub>(x), c<sub>1</sub>(x))，加密过程分两步：</p>\n<p>（1）明文编码：将整数明文m编码为明文多项式m(x)∈R<sub>t</sub>；</p>\n<p>（2）添加噪声与混淆：</p>\n<p>随机生成两个小噪声多项式e<sub>0</sub>(x),e<sub>1</sub>(x)∈R<sub>q</sub>，随机生成一个“掩码多项式”u(x)∈R<sub>q</sub>（系数为0/1），计算密文：</p>\n<p><img alt=\"image\" height=\"72\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122101343624-1971179879.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"506\" /></p>\n<p>核心设计：密文中包含明文信息m(x)，但被噪声e<sub>0</sub>/e<sub>1</sub>和掩码u(x)混淆，只有私钥能去除混淆和噪声。该步骤中的掩码多项式u(x)和噪声多项式e<sub>0</sub>(x),e<sub>1</sub>(x)是两套独立的安全机制，它们解决的是完全不同的问题，不能互相替代，如下图：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122145538684-995418377.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>u(x)通过随机缩放实现公钥和明文间的非固定线性关系，噪声通过“近似”进一步打破它们之间精确的代数关系，使得攻击者无法从近似值中还原精确明文。</p>\n<h2>2.4 同态运算</h2>\n<p>这步的核心是：密文运算=多项式环运算，BFV支持秘密&amp;密文（Ct&amp;Ct）和密文&amp;明文（Ct&amp;Pt）的加减乘运算，所有运算都在多项式环R<sub>q</sub>中进行，且无需密钥。</p>\n<p><img alt=\"image\" height=\"252\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122102234951-828568152.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"925\" /></p>\n<p>运算后的密文仍然是合法的RLWE密文，可继续参与后续运算——这就是「同态性」的体现。</p>\n<h2>2.5 解密</h2>\n<p>解密是加密的逆运算，核心是去除噪声、还原明文多项式，步骤如下：</p>\n<p>（1）密文聚合</p>\n<p>用私钥s(x)计算聚合多项式：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122102616840-333286614.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>代入加密公式可推导：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122102653366-486423113.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>（2）噪声去除</p>\n<p>由于总噪声e<sub>total</sub>&lt;q/(2t)，可通过“舍入+模运算”还原明文：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122102808245-1880527419.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />（3）明文解码</p>\n<p>将解密后的多项式m(x)转换回整数（单整数取常数项，批量加密取所有系数）。</p>\n<p>解密成功条件：总噪声e<sub>total</sub>&lt;q/(2t)，若运算次数过多导致噪声爆炸，舍入后无法还原明文，则会解密失败——这是BFV“层次性”的本质，运算深度有限。</p>\n<h2>2.6 python示例</h2>\n<p>以下是一个完整的python示例程序：</p>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed\" id=\"code_img_closed_09b97ffc-eef3-46ba-bb50-d1e4cf620627\" src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" /><img class=\"code_img_opened\" id=\"code_img_opened_09b97ffc-eef3-46ba-bb50-d1e4cf620627\" src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_09b97ffc-eef3-46ba-bb50-d1e4cf620627\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> numpy as np\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> random\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> PolynomialRing:\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span> <span style=\"color: rgba(128, 0, 128, 1);\">__init__</span><span style=\"color: rgba(0, 0, 0, 1);\">(self, n, modulus):\n        self.n </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> n\n        self.modulus </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> modulus\n        self.phi </span>= np.zeros(n + 1, dtype=<span style=\"color: rgba(0, 0, 0, 1);\">int)\n        self.phi[0] </span>= 1<span style=\"color: rgba(0, 0, 0, 1);\">\n        self.phi[n] </span>= 1\n\n    <span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> poly_add(self, a, b):\n        result </span>= np.zeros(self.n, dtype=<span style=\"color: rgba(0, 0, 0, 1);\">int)\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> i <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(self.n):\n            result[i] </span>= (a[i] + b[i]) %<span style=\"color: rgba(0, 0, 0, 1);\"> self.modulus\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> result\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> poly_mul(self, a, b):\n        result </span>= np.zeros(2 * self.n - 1, dtype=<span style=\"color: rgba(0, 0, 0, 1);\">int)\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> i <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(self.n):\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> j <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(self.n):\n                result[i </span>+ j] = (result[i + j] + a[i] * b[j]) %<span style=\"color: rgba(0, 0, 0, 1);\"> self.modulus\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> self.poly_mod(result)\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> poly_mod(self, poly):\n        result </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> poly.copy()\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> i <span style=\"color: rgba(0, 0, 255, 1);\">in</span> range(len(result) - 1, self.n - 1, -1<span style=\"color: rgba(0, 0, 0, 1);\">):\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> result[i] !=<span style=\"color: rgba(0, 0, 0, 1);\"> 0:\n                coeff </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> result[i]\n                result[i] </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> 0\n                idx </span>= i -<span style=\"color: rgba(0, 0, 0, 1);\"> self.n\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> idx &lt;<span style=\"color: rgba(0, 0, 0, 1);\"> len(result):\n                    result[idx] </span>= (result[idx] - coeff) %<span style=\"color: rgba(0, 0, 0, 1);\"> self.modulus\n        result </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> result[:self.n]\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> result\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> poly_sub(self, a, b):\n        result </span>= np.zeros(self.n, dtype=<span style=\"color: rgba(0, 0, 0, 1);\">int)\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> i <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(self.n):\n            result[i] </span>= (a[i] - b[i]) %<span style=\"color: rgba(0, 0, 0, 1);\"> self.modulus\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> result\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> poly_scale(self, a, scalar):\n        result </span>= np.zeros(self.n, dtype=<span style=\"color: rgba(0, 0, 0, 1);\">int)\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> i <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(self.n):\n            result[i] </span>= (a[i] * scalar) %<span style=\"color: rgba(0, 0, 0, 1);\"> self.modulus\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> result\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> random_poly(self):\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> np.random.randint(0, self.modulus, self.n)\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> binary_poly(self):\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> np.random.randint(0, 2<span style=\"color: rgba(0, 0, 0, 1);\">, self.n)\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span> small_poly(self, bound=3<span style=\"color: rgba(0, 0, 0, 1);\">):\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> np.random.randint(-bound, bound + 1<span style=\"color: rgba(0, 0, 0, 1);\">, self.n)\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> BFV:\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span> <span style=\"color: rgba(128, 0, 128, 1);\">__init__</span>(self, n=256, q=1048576, t=256<span style=\"color: rgba(0, 0, 0, 1);\">):\n        self.n </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> n\n        self.q </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> q\n        self.t </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> t\n        self.ring </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> PolynomialRing(n, q)\n        self.plaintext_ring </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> PolynomialRing(n, t)\n        self.delta </span>= q //<span style=\"color: rgba(0, 0, 0, 1);\"> t\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> keygen(self):\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 产生密钥</span>\n        s =<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.binary_poly()\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 挑战多项式</span>\n        a =<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.random_poly()\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 随机多项式</span>\n        e =<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.small_poly()\n        a_s </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_mul(a, s)\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 响应多项式</span>\n        pk0 =<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_sub(e, a_s)\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 公钥</span>\n        pk =<span style=\"color: rgba(0, 0, 0, 1);\"> [pk0, a]\n        sk </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> s\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> pk, sk\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 编码明文</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> encode(self, message):\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> isinstance(message, int):\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 单整数编码</span>\n            m = np.zeros(self.n, dtype=<span style=\"color: rgba(0, 0, 0, 1);\">int)\n            m[0] </span>= message %<span style=\"color: rgba(0, 0, 0, 1);\"> self.t\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 批量编码</span>\n            m = np.array(message, dtype=int) %<span style=\"color: rgba(0, 0, 0, 1);\"> self.t\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> m\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 使用公钥加密</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> encrypt(self, pk, message):\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 对明文进行编码</span>\n        m =<span style=\"color: rgba(0, 0, 0, 1);\"> self.encode(message)\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 对明文编码结果进行放大</span>\n        m_scaled =<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_scale(m, self.delta)\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\">print(\"m_scaled: {}\".format(m_scaled))</span>\n        \n        <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 生成掩码多项式</span>\n        u =<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.binary_poly()\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 产生两个小噪声多项式</span>\n        e1 =<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.small_poly()\n        e2 </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.small_poly()\n        \n        pk0_u </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_mul(pk[0], u)\n        pk1_u </span>= self.ring.poly_mul(pk[1<span style=\"color: rgba(0, 0, 0, 1);\">], u)\n        \n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 生成密文c0</span>\n        c0 =<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_add(pk0_u, e1)\n        c0 </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_add(c0, m_scaled)\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 生成密文c1</span>\n        c1 =<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_add(pk1_u, e2)\n        \n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 返回密文</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> [c0, c1]\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> decrypt(self, sk, ciphertext):\n        c0, c1 </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> ciphertext\n        s_c1 </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_mul(sk, c1)\n        decrypted </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_add(c0, s_c1)\n        \n        result </span>= np.zeros(self.n, dtype=<span style=\"color: rgba(0, 0, 0, 1);\">int)\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> i <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(self.n):\n            result[i] </span>= round(decrypted[i] * self.t / self.q) %<span style=\"color: rgba(0, 0, 0, 1);\"> self.t\n        \n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> result\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> add(self, c1, c2):\n        c0 </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_add(c1[0], c2[0])\n        c1 </span>= self.ring.poly_add(c1[1], c2[1<span style=\"color: rgba(0, 0, 0, 1);\">])\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> [c0, c1]\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> main():\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">=== BFV 同态加密方案演示 ===\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    bfv </span>= BFV(n=256, q=1048576, t=256<span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">参数设置:</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">  多项式次数 n = {bfv.n}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">  密文模数 q = {bfv.q}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">  明文模数 t = {bfv.t}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">  缩放因子 Δ = {bfv.delta}\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    pk, sk </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.keygen()\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">密钥生成完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">私钥 s 前5个系数: {sk[:5]}...\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span><span style=\"color: rgba(0, 0, 0, 1);\">(sk)\n    \n    m1 </span>= 42<span style=\"color: rgba(0, 0, 0, 1);\">\n    m2 </span>= 17\n    <span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">明文 m1 = {m1}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">明文 m2 = {m2}\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    c1 </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.encrypt(pk, m1)\n    c2 </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.encrypt(pk, m2)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">加密完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">密文 c1[0] 前5个系数: {c1[0][:5]}...</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">密文 c1[1] 前5个系数: {c1[1][:5]}...\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">密文c1 {}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">.format(c1))\n    \n    d1 </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.decrypt(sk, c1)\n    d2 </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.decrypt(sk, c2)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">解密完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">解密结果 d1 = {d1[0]}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">解密结果 d2 = {d2[0]}\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">=== 同态加法演示 ===</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    c_sum </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.add(c1, c2)\n    d_sum </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.decrypt(sk, c_sum)\n    expected_sum </span>= (m1 + m2) %<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.t\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">密文同态加法: c1 + c2</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">解密结果: {d_sum[0]}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">期望结果: {expected_sum}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">验证: {'成功' if d_sum[0] == expected_sum else '失败'}\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">=== 多项式明文演示 ===</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    m_poly </span>= np.array([1, 2, 3, 4, 5] + [0] * 251, dtype=<span style=\"color: rgba(0, 0, 0, 1);\">int)\n    c_poly </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.encrypt(pk, m_poly)\n    d_poly </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.decrypt(sk, c_poly)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">多项式明文前5个系数: {m_poly[:5]}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">解密结果前5个系数: {d_poly[:5]}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">验证: {'成功' if np.array_equal(d_poly[:5], m_poly[:5]) else '失败'}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> <span style=\"color: rgba(128, 0, 128, 1);\">__name__</span> == <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">__main__</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n    main()</span></pre>\n</div>\n<span class=\"cnblogs_code_collapse\">View Code</span></div>\n<h1>3 SEAL使用</h1>\n<h2>3.1 源码编译</h2>\n<p>这里仅简单介绍下Windows下使用VS2022环境进行编译，下载源码并安装cmake，运行VS2022安装菜单下的“Developer Command Prompt for VS 2022”命令行，执行命令进行配置：</p>\n<div class=\"cnblogs_code\">\n<pre>cmake -S . -B build -G <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Visual Studio 17 2022</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> -A x64 -DCMAKE_INSTALL_PREFIX=./<span style=\"color: rgba(0, 0, 255, 1);\">out</span></pre>\n</div>\n<p>这里编译的是64位版本，并将安装目录设置为当前目录下的out文件夹，配置完成后再执行以下命令进行编译</p>\n<div class=\"cnblogs_code\">\n<pre>cmake --build build --<span style=\"color: rgba(0, 0, 0, 1);\">config Release    #编译Release版本\ncmake </span>--build build --config Debug      #编译Debug版本</pre>\n</div>\n<p>编译完成后会生成seal-4.1.lib库文件：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122113702648-1311816022.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>然后执行以下命令进行安装：</p>\n<div class=\"cnblogs_code\">\n<pre>cmake --install build</pre>\n</div>\n<p>out下include中是头文件，lib中是静态库文件：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122114032047-1402497300.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<h2>3.2 示例程序</h2>\n<p>使用VS2022创建空项目，并添加demo.cpp文件，内容如下：</p>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed\" id=\"code_img_closed_1771d7b9-7319-4893-9ce5-5347e3e25b4a\" src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" /><img class=\"code_img_opened\" id=\"code_img_opened_1771d7b9-7319-4893-9ce5-5347e3e25b4a\" src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_1771d7b9-7319-4893-9ce5-5347e3e25b4a\">\n<pre><span style=\"color: rgba(0, 128, 128, 1);\"> 1</span> #include &lt;iostream&gt;\n<span style=\"color: rgba(0, 128, 128, 1);\"> 2</span> #include &lt;SEAL/SEAL.h&gt;\n<span style=\"color: rgba(0, 128, 128, 1);\"> 3</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 4</span> <span style=\"color: rgba(0, 0, 255, 1);\">using</span> <span style=\"color: rgba(0, 0, 255, 1);\">namespace</span><span style=\"color: rgba(0, 0, 0, 1);\"> std;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 5</span> <span style=\"color: rgba(0, 0, 255, 1);\">using</span> <span style=\"color: rgba(0, 0, 255, 1);\">namespace</span><span style=\"color: rgba(0, 0, 0, 1);\"> seal;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 6</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 7</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> main() {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 8</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 步骤 1：配置加密参数（BFV 方案）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 9</span> <span style=\"color: rgba(0, 0, 0, 1);\">    EncryptionParameters parms(scheme_type::bfv);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">10</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 多项式模数：4096（2的幂次）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">11</span>     size_t poly_modulus_degree = <span style=\"color: rgba(128, 0, 128, 1);\">4096</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">12</span> <span style=\"color: rgba(0, 0, 0, 1);\">    parms.set_poly_modulus_degree(poly_modulus_degree);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">13</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 明文模数：支持批量运算，取值范围 2^20</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">14</span>     parms.set_plain_modulus(PlainModulus::Batching(poly_modulus_degree, <span style=\"color: rgba(128, 0, 128, 1);\">20</span><span style=\"color: rgba(0, 0, 0, 1);\">));\n</span><span style=\"color: rgba(0, 128, 128, 1);\">15</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 系数模数：使用 BFV 默认参数</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">16</span> <span style=\"color: rgba(0, 0, 0, 1);\">    parms.set_coeff_modulus(CoeffModulus::BFVDefault(poly_modulus_degree));\n</span><span style=\"color: rgba(0, 128, 128, 1);\">17</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">18</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">明文模数 t = </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; parms.plain_modulus().value() &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">19</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">明文模数 t 比特数 = </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; parms.plain_modulus().bit_count() &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">20</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">t mod 2N = </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; (parms.plain_modulus().value() % (<span style=\"color: rgba(128, 0, 128, 1);\">2</span> * poly_modulus_degree)) &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">21</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">22</span>     vector&lt;Modulus&gt; coeff_mods =<span style=\"color: rgba(0, 0, 0, 1);\"> CoeffModulus::BFVDefault(poly_modulus_degree);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">23</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">24</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 3. 系数模数 q（多素数乘积）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">25</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\\n系数模数 q 的构成（素数列表）：</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">26</span>     <span style=\"color: rgba(0, 0, 255, 1);\">int</span> total_bits = <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">27</span>     <span style=\"color: rgba(0, 0, 255, 1);\">for</span> (size_t i = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; i &lt; coeff_mods.size(); i++<span style=\"color: rgba(0, 0, 0, 1);\">) {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">28</span>         cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">第</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; i + <span style=\"color: rgba(128, 0, 128, 1);\">1</span> &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">个素数：</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> coeff_mods[i].value()\n</span><span style=\"color: rgba(0, 128, 128, 1);\">29</span>             &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">（比特数：</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; coeff_mods[i].bit_count() &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">）</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">30</span>         total_bits +=<span style=\"color: rgba(0, 0, 0, 1);\"> coeff_mods[i].bit_count();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">31</span> <span style=\"color: rgba(0, 0, 0, 1);\">    }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">32</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">系数模数总比特数 = </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; total_bits &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">33</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">34</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 步骤 2：创建加密上下文，验证参数合法性</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">35</span> <span style=\"color: rgba(0, 0, 0, 1);\">    SEALContext context(parms);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">36</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 打印上下文信息（可选，查看参数配置）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">37</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Context created successfully, scheme type: BFV</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">38</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">39</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 步骤 3：生成密钥（适配 SEAL 4.1 API，核心修改部分）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">40</span> <span style=\"color: rgba(0, 0, 0, 1);\">    KeyGenerator keygen(context);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">41</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 4.1 版本：通过 create_public_key() 生成公钥（替代原 public_key()）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">42</span> <span style=\"color: rgba(0, 0, 0, 1);\">    PublicKey public_key;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">43</span> <span style=\"color: rgba(0, 0, 0, 1);\">    keygen.create_public_key(public_key);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">44</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 4.1 版本：直接通过成员函数获取私钥（该接口未变更）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">45</span>     SecretKey secret_key =<span style=\"color: rgba(0, 0, 0, 1);\"> keygen.secret_key();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">46</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 4.1 版本：通过 create_relin_keys() 生成评估密钥（替代原 relin_keys()）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">47</span> <span style=\"color: rgba(0, 0, 0, 1);\">    RelinKeys relin_keys;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">48</span> <span style=\"color: rgba(0, 0, 0, 1);\">    keygen.create_relin_keys(relin_keys);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">49</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">50</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 步骤 4：初始化加密器、解密器、评估器</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">51</span> <span style=\"color: rgba(0, 0, 0, 1);\">    Encryptor encryptor(context, public_key);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">52</span> <span style=\"color: rgba(0, 0, 0, 1);\">    Decryptor decryptor(context, secret_key);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">53</span> <span style=\"color: rgba(0, 0, 0, 1);\">    Evaluator evaluator(context);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">54</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">55</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 步骤 5：明文准备（两个整数）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">56</span>     Plaintext plain1(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">123</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">57</span>     Plaintext plain2(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">456</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">58</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Original plaintext 1: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; plain1.to_string() &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">59</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Original plaintext 2: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; plain2.to_string() &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">60</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">61</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 步骤 6：加密明文为密文</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">62</span> <span style=\"color: rgba(0, 0, 0, 1);\">    Ciphertext cipher1, cipher2;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">63</span> <span style=\"color: rgba(0, 0, 0, 1);\">    encryptor.encrypt(plain1, cipher1);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">64</span> <span style=\"color: rgba(0, 0, 0, 1);\">    encryptor.encrypt(plain2, cipher2);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">65</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Plaintext encrypted to ciphertext successfully</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">66</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">67</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 步骤 7：密文同态运算（加法 + 乘法）\n</span><span style=\"color: rgba(0, 128, 128, 1);\">68</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 密文加法</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">69</span> <span style=\"color: rgba(0, 0, 0, 1);\">    Ciphertext cipher_add;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">70</span> <span style=\"color: rgba(0, 0, 0, 1);\">    evaluator.add(cipher1, cipher2, cipher_add);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">71</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 密文乘法 + 重线性化（减少密文大小）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">72</span> <span style=\"color: rgba(0, 0, 0, 1);\">    Ciphertext cipher_mult;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">73</span> <span style=\"color: rgba(0, 0, 0, 1);\">    evaluator.multiply(cipher1, cipher2, cipher_mult);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">74</span> <span style=\"color: rgba(0, 0, 0, 1);\">    evaluator.relinearize_inplace(cipher_mult, relin_keys);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">75</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">76</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 步骤 8：解密密文，验证结果</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">77</span> <span style=\"color: rgba(0, 0, 0, 1);\">    Plaintext plain_add, plain_mult;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">78</span> <span style=\"color: rgba(0, 0, 0, 1);\">    decryptor.decrypt(cipher_add, plain_add);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">79</span> <span style=\"color: rgba(0, 0, 0, 1);\">    decryptor.decrypt(cipher_mult, plain_mult);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">80</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Ciphertext add result: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; plain_add.to_string() &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">81</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Ciphertext multiply result: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; plain_mult.to_string() &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">82</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\">83</span>     <span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">84</span> }</pre>\n</div>\n<span class=\"cnblogs_code_collapse\">View Code</span></div>\n<p>将之间产生的out文件夹下的include和lib拷贝到项目文件夹下，配置项目的C/C++编译包含头文件路径，库文件路径以及输入库，即可进行编译。</p>\n<p><img alt=\"image\" height=\"434\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122114406545-2054417852.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"593\" /></p>\n<p>编译完成后运行程序，输出如下：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122114732024-1409765149.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>在该示例程序中，多项式模数N是4096，明文模数t是1032193，位宽为20bits，系数模数q是3个素数的乘积68719403009*68719230977*137438822401=0x1ffff4400622fecd904df7f92001，位宽是109bits，示例中演示了0x123和0x456的加法和乘法运行，可见加密运算后的解密结果和未加密运算的结果完全一致。</p>\n<p>&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-22 15:50</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zhaoweiwei\">weiwei22844</a>&nbsp;\n阅读(<span id=\"post_view_count\">11</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "我的“Python海龟”诞生了一枚金蛋孵出的却是精灵",
      "link": "https://www.cnblogs.com/lixingqiu/p/19516100",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lixingqiu/p/19516100\" id=\"cb_post_title_url\" title=\"发布于 2026-01-22 11:17\">\n    <span>我的“Python海龟”诞生了一枚金蛋孵出的却是精灵</span>\n    \n\n</a>\n</h1>\n\t<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>时光回溯到2010年，那是一个充满探索与求知的年份。在此之前，我沉浸于使用Visual Basic语言开发3D小游戏，那种在代码的世界里创造出奇妙虚拟场景的感觉，让我乐此不疲。当时，我自认为Basic已经是相当简单的计算机语言了，然而，内心深处却始终有个疑问：是否存在一种比Basic更适合少儿编程的专用计算机语言呢？</p>\n<p>带着这个疑问，我开始在网络上广泛搜寻。功夫不负有心人，我终于发现了Scratch 1.4版。这只来自美国麻省理工的“小猫咪”，瞬间吸引了我的目光，从此我便深深爱上了它。2013年，怀揣着对少儿编程教育的热情，我开设了少儿编程培训班。到了2015年，我又将Python纳入教学体系，希望能为学生们带来更丰富的编程体验。经过几年的教学实践，到2018年时，我已经自己编写了较多的青少年Python教学资料。</p>\n<p>在这个过程中，我逐渐发现Python的小海龟功能存在一定的局限性。为了深入探究其原理，我打开了它的turtle.py源代码文件，仔细研究其中的奥秘。从2019年开始，我基于Python turtle模块，踏上了开发Python精灵模块的征程。Python精灵模块的核心是设计了一个名为Sprite的类，这一创新大大增加了海龟的功能，例如实现了像素级别的碰撞检测等。如今，所有人都可以通过简单的命令“pip install sprites”来安装并使用这个强大的Python精灵模块。</p>\n<p>近几年，我将主要精力投入到信息学奥赛的教学中。每日都在“苦思冥想”各种难题，力求为学生找到更有效的学习方法。2025年8月，暑假班结束，我又开始思考一个新的问题：如果C++的入门教学能够像Python turtle一样简单易懂，那无疑会给中国所有少年带来福音。</p>\n<p>为了实现这个目标，我在GitHub上广泛寻找前人的研究成果，下载了许多用C语言或者C++开发的类turtle库。其中，有小熊猫C++库里自带的C语言海龟作图，还有GoC等相关库。我还特意购买了相关书籍，准备教授中小学生，甚至买了一本少儿3维C++编程书。然而，经过深入研究和对比，我最终并没有选择使用它们，这背后有着多方面的原因。</p>\n<p>就拿小熊猫C++库里自带的C语言海龟作图来说，其作者显然没有Python少儿编程教育的经历。我曾尝试联系作者，希望他能将里面的命令改成类似Python turtle的风格，但考虑到不能总是麻烦他人，后来也就没有再继续联系。而GoC这个库，里面的命令也没有承接自Python turtle。为了方便儿童输入字符，它将命令设计成一个字符或两个字符，比如pen.o或者pen.oo之类的。其命令相对较少，功能也不够丰富，而且主要是在线使用，作者至今似乎都没有开发自己的编辑器。以前我使用过它的离线版，还需要借助notepad++。从本质上讲，它更像是为专攻信息学奥赛设计的前置课程工具。网上有人建议一、二年级的学生就开始学习GoC，但如果不打算专攻信奥赛，其实可以不必学习。为什么呢？</p>\n<p>从大脑发育的角度来看，一、二年级的学生，他们的大脑尚处于发育阶段。科学研究表明，这个阶段的孩子，大脑的前额叶皮质尚未完全成熟，抽象思维能力相对较弱。虽然有些孩子可能在早期就展现出了较强的学习能力和天赋，如果教练眼光独到，能识别出这些苗子，让他们尝试学习GoC也未尝不可。但现实情况是，不可能每个小学生都得去专攻信息学奥赛，毕竟信奥赛的竞争十分激烈，它就是学霸们的战场。而且，对于普通学生而言，他们的少儿编程学习经历应该是丰富多彩的，不应局限于C++编程。因为学习编程的本质并非仅仅掌握某种计算机语言，而是培养逻辑思维、创造力等多方面的能力。有些人大脑发育相对迟缓一些，如果硬要他们在低年级就开始学习C++，很可能会适得其反，就是拔苗助长。根据神经科学的研究，儿童在中低年级阶段，形象思维更为活跃，此时学习图形化编程更加符合他们的认知发展规律。等到他们年龄稍大，心智更加成熟，再去学习C++也不迟。大脑需要得到多方面的刺激，才能得到充分的锻炼和发展。就像一颗种子，需要在适宜的环境中，经历不同的养分滋养，才能茁壮成长。最终，有些学生到了高中阶段，随着大脑的进一步发育和知识的积累，会突然开窍，在学习编程等方面取得更大的进步。</p>\n<p>那么，面对绝大多数的普通学生群体，他们的学习路径通常是一、二年级学习图形化编程，三、四年级学习Python编程，到了一定阶段后再学习C++编程。在这种情况下，是否存在一种针对普通学生，能够完美衔接这一课程体系的C++课程呢？据我了解，这样的课程相对比较少，即便有，可能也不公开或者需要收费。毕竟中国地域广阔，很多事情我也难以全面知晓。但不管怎样，我决定自己全新开发一个，正所谓“金窝银窝不如自己草窝”。</p>\n<p>在开发过程中，首先面临的就是选择合适的库来作为基础。如果让我的C++库基于OpenGL，虽然可行，但我需要先花费大量时间去学习它，这对于我来说，学习成本过高。于是，我找到了曾经用过的easyX，并用它开发出了原形库。然而，在使用过程中，我发现很多底层的东西我无法掌控，无奈之下只能放弃。接着，我又发现了raylib，它基于SDL2，接口众多，封装得较为复杂。随后，我注意到了SFML，这是一个很不错的库，但考虑到它已经封装了很多内容，我想要掌握更多底层技术，最终还是弃用了它。最后，我选择了工业级别的SDL2库。这个库功能相对较少，但也意味着我自己的开发自由度更大，对底层的掌控力更强。</p>\n<p>所以，现在的版本是基于SDL2库开发的。最初，我将其命名为C++ Sprites库，后来又正式命名为C++精灵库。在开发过程中，我不断地进行修改和调试，只为让普通用户能够更好地上手使用。为了让这个库更加完善，我还中途开发了pxC++编辑器，这是专门为C++精灵库量身打造的编辑器。同时，我还开发了DevC++5.11升级包，使DevC++5.11能够支持C++精灵库，从而让它更好地融入到主流的中小学生C++教学生态中。</p>\n<p>现在的C++精灵库，比较完美地继承了Python turtle的血脉。不仅如此，我还针对Python turtle存在的不足之处进行了改进与优化。例如，我精心设计了fill命令，角色通过使用fill命令，就可以在封闭区域进行洪水填充。在设定画笔颜色方面，不仅能够让角色的画笔颜色命令接受字符串作为参数，还能接受1个整数或多个整数作为参数。这是因为我对pencolor命令进行了多次重载，使其具有更高的灵活性和自由度。</p>\n<p>此外，我还为角色的画笔增添了许多实用的方法。比如，设计了设定阴影度的penshade方法，以及设定颜色饱和度的pensat方法和设定颜色明度的penvalue方法。后来又进一步设计了直接设定颜色的Hue、Saturation及Value的penhsv方法，还有修改颜色透明度的penalpha方法。不仅如此，还为角色设计了贝塞尔曲线与样条曲线等方法。这些精心设计的设定，对于审美能力强的美术生来说，无疑提供了极大的便利，使他们能够更加轻松地创作出具有艺术效果的图形。</p>\n<p>现在我们所看到的“C++精灵库”，本质上是基于logo计算机语言编程教育理念在C++世界的延伸并有所超越。它借鉴了Python turtle简洁的API，并针对教育场景进行了深入优化。这样一来，学生们就能够在一个更强大、更接近工业标准的语言环境中，充分体验到“海龟作图”的乐趣与智慧。我们可以把Python turtle和C++精灵库比作是亲兄弟，无论先学习哪一个，再去学习另一个，都会有一种“似曾相识燕归来”的熟悉感，这就是所谓的“双倍赋能”。因为编程的世界在底层本来就是相通的，当我把它们的外观也设计得相似的时候，请不要感到惊讶！</p>\n<p>更值得一提的是，由于C++精灵库是基于SDL2库进行开发的，它还能够完美融入SDL2库的命令，为学生提供更深入的编程学习机会。想象一下，SDL2库在各行各业中的广泛应用场景，C++精灵库无疑为学生的未来学习和职业发展赋予了其他类C++ turtle库无法比拟的优势。</p>\n<p>&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-01-22 11:17</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lixingqiu\">李兴球</a>&nbsp;\n阅读(<span id=\"post_view_count\">124</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Claude Code 支持重磅扩展 Skills —— 用最新 API 构建更靠谱的 AI 项目",
      "link": "https://www.cnblogs.com/bugshare/p/19515937",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/bugshare/p/19515937\" id=\"cb_post_title_url\" title=\"发布于 2026-01-22 10:55\">\n    <span>Claude Code 支持重磅扩展 Skills —— 用最新 API 构建更靠谱的 AI 项目</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在上一篇《<strong>Claude Code × 智谱 BigModel 实战集成指南</strong>》中，我们已经完成了一次完整的项目实战。项目<strong>可以正常运行</strong>，但在后续代码 Review 时，一个问题逐渐暴露出来：</p>\n<blockquote>\n<p><strong>生成的代码虽然能跑，但大量 API 和用法已经过时，与最新官方文档存在明显偏差。</strong></p>\n</blockquote>\n<p>这在 AI 辅助开发中其实非常常见——模型的训练数据更新速度，往往赶不上框架和 SDK 的迭代速度。</p>\n<p>正巧这时，一位朋友向我推荐了 <strong>Anthropic 最新发布的 Agent Skills</strong>，通过 <em>plugins</em> 的方式，让 Claude 在生成代码时 <strong>动态读取最新官方文档和工具能力</strong>，从而显著降低“写得像，但跑不通”的概率。</p>\n<p>本文就是这次探索的完整记录。</p>\n<hr />\n<h1 id=\"一agent-skills-是什么\">一、Agent Skills 是什么？</h1>\n<p>官方仓库地址：</p>\n<blockquote>\n<p><a href=\"https://github.com/anthropics/skills\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/anthropics/skills</a></p>\n</blockquote>\n<p><strong>Agent Skills</strong> 可以理解为：</p>\n<blockquote>\n<p>一套可插拔的“能力模块”，用于教会 Claude <strong>如何用正确的方法、最新的工具、可重复的流程</strong> 来完成特定任务。</p>\n</blockquote>\n<p>在技术层面上：</p>\n<ul>\n<li>\n<p>每个 Skill 本质上是一个文件夹</p>\n</li>\n<li>\n<p>内部包含：</p>\n<ul>\n<li>指令（instructions）</li>\n<li>脚本（scripts）</li>\n<li>资源文件（resources）</li>\n</ul>\n</li>\n<li>\n<p>Claude Code 会在运行时动态加载这些 Skills</p>\n</li>\n</ul>\n<h2 id=\"它能解决什么问题\">它能解决什么问题？</h2>\n<p>Agent Skills 的核心价值在于 <strong>“降低幻觉 + 提高一致性”</strong>，典型应用场景包括：</p>\n<ul>\n<li>按公司/团队的编码规范生成代码</li>\n<li>按最新官方文档调用 API（而不是靠模型记忆）</li>\n<li>执行固定的工程化流程（初始化项目、生成目录结构、部署脚本等）</li>\n<li>自动化个人或组织级任务</li>\n</ul>\n<p>简单来说：</p>\n<blockquote>\n<p><strong>Skills 不是让模型更聪明，而是让模型更“守规矩”。</strong></p>\n</blockquote>\n<hr />\n<h1 id=\"二在-claude-code-中安装-agent-skills\">二、在 Claude Code 中安装 Agent Skills</h1>\n<p>在 Claude Code 命令行中执行：</p>\n<pre><code class=\"language-bash\">/plugin marketplace add anthropics/skills\n</code></pre>\n<p>安装完成后，你就已经具备了使用官方 Skills 的能力。</p>\n<blockquote>\n<p>这一步相当于为 Claude Code 打开了“官方增强模式”。</p>\n</blockquote>\n<p><img alt=\"PixPin_2026-01-22_10-07-25.png\" class=\"lazyload\" /></p>\n<hr />\n<h1 id=\"三安装-context7-插件关键步骤\">三、安装 context7 插件（关键步骤）</h1>\n<p>接下来是本文的重点：<strong>context7</strong>。</p>\n<h2 id=\"1️⃣-打开插件管理\">1️⃣ 打开插件管理</h2>\n<p>在 Claude Code 中输入：</p>\n<pre><code class=\"language-shell\">/plugins\n</code></pre>\n<p>然后使用键盘 ➡️ 进入 <strong>Discover</strong>。</p>\n<h2 id=\"2️⃣-搜索并安装-context7\">2️⃣ 搜索并安装 context7</h2>\n<p>在搜索框中输入 <code>context7</code>，完成安装。</p>\n<blockquote>\n<p>context7 本质上是一个 MCP（Model Context Protocol）插件，<br />\n能让 Claude <strong>直接参考并对齐最新的官方文档内容</strong>。</p>\n</blockquote>\n<p><img alt=\"PixPin_2026-01-22_10-09-22.png\" class=\"lazyload\" /></p>\n<hr />\n<h1 id=\"四使用-context7-生成项目代码\">四、使用 context7 生成项目代码</h1>\n<p>安装完成后，就可以在 Prompt 中显式声明使用 <code>context7</code>。</p>\n<h2 id=\"示例-prompt\">示例 Prompt</h2>\n<pre><code class=\"language-markdown\">---\nname: context7\ndescription: 使用 Context7，基于框架最新的官方文档\n---\n\n# context7\n\n## 指南\n已使用以下技术栈生成企业级项目：\n- 使用 Context7，基于最新的官方文档\n- FastAPI 0.128.0，带 Token 认证\n  - 使用 sqlite 生成 token\n  - 不使用 JWT，仅做 Token 校验\n- langchain 1.2.6，使用 create_agent\n- langchain-ollama 1.0.1\n  - model：qwen3-vl:32b\n  - embedding：qwen3-embedding:8b\n- langgraph 1.0.6\n- Milvus（pymilvus）2.6.6\n- langfuse 3.12.0\n</code></pre>\n<p>通过这种方式，你是在<strong>明确告诉 Claude</strong>：</p>\n<blockquote>\n<p>不要靠“印象”写代码，而是<strong>以当前官方文档为准</strong>。</p>\n</blockquote>\n<p><img alt=\"PixPin_2026-01-22_10-29-45.png\" class=\"lazyload\" /></p>\n<hr />\n<h1 id=\"五实际体验与问题分析\">五、实际体验与问题分析</h1>\n<h2 id=\"真实结论只有一句话\">真实结论只有一句话：</h2>\n<blockquote>\n<p><strong>效果明显提升，但依然不能“一次生成直接可用”。</strong></p>\n</blockquote>\n<h2 id=\"优点\">优点</h2>\n<ul>\n<li>API 使用明显更接近最新文档</li>\n<li>过时参数、废弃方法显著减少</li>\n<li>工程结构更合理，思路更偏向“真实项目”</li>\n</ul>\n<h2 id=\"仍然存在的问题\">仍然存在的问题</h2>\n<ul>\n<li>复杂技术栈组合（LangChain + LangGraph + Milvus + Langfuse）</li>\n<li>仍然需要 <strong>多轮调试才能完全跑通</strong></li>\n<li>某些边界用法依然存在偏差</li>\n</ul>\n<h2 id=\"我的判断\">我的判断</h2>\n<blockquote>\n<p><strong>并不是 context7 不行，而是模型生成速度，依然落后于框架演进速度。</strong></p>\n</blockquote>\n<p>context7 做到的是：</p>\n<ul>\n<li>让 Claude <em>看得到</em> 最新文档</li>\n<li>但最终“怎么拼起来”，仍然依赖模型本身的推理与代码能力</li>\n</ul>\n<hr />\n<h1 id=\"六总结\">六、总结</h1>\n<p>如果你正在使用 Claude Code 做偏工程化、偏企业级的项目开发，我的建议是：</p>\n<p>✅ <strong>一定要上 Agent Skills</strong></p>\n<p>✅ <strong>能用 context7 就用 context7</strong></p>\n<p>❌ 不要再完全相信“模型记忆里的 API”</p>\n<p>但同时也要有一个清醒认知：</p>\n<blockquote>\n<p><strong>AI 辅助开发 = 更快的起点，而不是免调试的终点。</strong></p>\n</blockquote>\n<p>在当前阶段，最理想的模式依然是：</p>\n<blockquote>\n<p><strong>AI 生成 + 人类 Review + 多轮修正</strong></p>\n</blockquote>\n<p>后续我也会继续记录 Claude Code + MCP + 多模型协作 的实践经验，欢迎关注。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-22 10:55</span>&nbsp;\n<a href=\"https://www.cnblogs.com/bugshare\">BugShare</a>&nbsp;\n阅读(<span id=\"post_view_count\">71</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "绝望博弈！一众大模型加持的猜拳游戏，人类胜率竟不足10%？",
      "link": "https://www.cnblogs.com/greywen/p/19512202",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/greywen/p/19512202\" id=\"cb_post_title_url\" title=\"发布于 2026-01-22 08:29\">\n    <span>绝望博弈！一众大模型加持的猜拳游戏，人类胜率竟不足10%？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1>基于 LLM + Next.js 的博弈实战猜拳游戏</h1>\n<p><strong>摘要</strong>：当你以为自己在和随机数生成器玩游戏时，对面的 AI 正在阅读你所有的历史出拳记录，并写了一篇关于你心理状态的小作文。本文带你拆解这个基于 Next.js 16 + Tailwind v4 + LLM 的“过度设计”+“没啥技术含量”+”有那么点意思“项目。</p>\n<p>👉 <strong>先给老板们体验:（具体规则有手就能玩！）</strong></p>\n<p>优先地址：<a href=\"https://rps.anhejin.cn\" rel=\"noopener nofollow\" target=\"_blank\">https://rps.anhejin.cn</a></p>\n<p>有条件的：<a href=\"https://rps-eta-ten.vercel.app\" rel=\"noopener nofollow\" target=\"_blank\">https://rps-eta-ten.vercel.app<br /></a></p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"423\" width=\"752\" /></p>\n<hr />\n<p>最近闲着没事，突然想这用AI写点代码。作为一名要把“简单需求复杂化”刻在 DNA 里的老前端，我决定拿最简单的“剪刀石头布”开刀。</p>\n<p>在这个 AI 满天飞的时代，还在用 <code>Math.random()</code> 写对手逻辑未免太没追求了。于是，我基于最新的技术栈（Next.js 16 + React 19），接入了 OpenAI等一众大模型，搞出了一个会“读心”、会嘲讽，甚至懂博弈论的猜拳游戏。</p>\n<h2>为什么是剪刀石头布？</h2>\n<p>别笑，剪刀石头布其实是一个极佳的博弈论模型。</p>\n<ul>\n<li><strong>新手</strong>：完全随机（Chaos）。</li>\n<li><strong>普通人</strong>：赢了保持，输了变招（Win-Stay, Lose-Shift）。</li>\n<li><strong>高手</strong>：预判你的预判。</li>\n\n\n\n\n\n\n\n\n\n\n</ul>\n<p>我的目标是：<strong>构建一个能看穿你心理的 AI，并且用目前最前沿的前端技术栈把它跑起来。</strong></p>\n<h2>技术选型：这就叫“杀鸡用牛刀”</h2>\n<p>为了配得上这个“高智商”AI，我在技术栈上直接拉满，全部采用了目前（2025-2026）的最新稳定版：</p>\n<ol>\n<li><strong>Next.js 16.1 (App Router)</strong>：服务端组件（RSC）处理核心逻辑，隐藏 AI 的 Prompt，保证你没法通过 F12 偷看答案。</li>\n<li><strong>React 19</strong>：享受最新的 Hooks 和并发特性。</li>\n<li><strong>Tailwind CSS v4</strong>：对，就是那个不用配置构建工具、性能起飞的 v4 版本。关键是AI喜欢用这个</li>\n<li><strong>SQLite + LibSQL</strong>：轻量级数据库，用来记仇——啊不，记录你的胜负数据。</li>\n\n\n\n\n\n\n\n\n\n\n</ol>\n<h2>核心玩法：AI 是怎么“读心”的？</h2>\n<p>这个项目的核心不在于 UI 有多炫（虽然 Tailwind 4 确实很润），而在于 <code>/lib/ai-service.ts</code> 里的那段逻辑。</p>\n<p>传统的游戏 AI 往往是预设好的 <code>if-else</code>。但在我的设计里，每一轮游戏，我都会把你在这个 Session 里的所有历史记录打包，像讲故事一样发给 LLM（大语言模型）：</p>\n<pre><code class=\"language-typescript\">\n// lib/ai-service.ts\n\n// 构建游戏历史描述\nconst historyDescription = history.length &gt; 0\n  ? history.map((h) =&gt;\n      `第${h.round}轮: 玩家出${translateChoice(h.player_choice)}, \n       AI出${translateChoice(h.ai_choice)}, \n       结果: ${translateResult(h.result)}`\n    ).join(\"\\n\")\n  : \"这是第一轮，没有历史记录。\";\n\n// ...发送给 LLM\nconst response = await client.chat.completions.create({\n  messages: [\n    { role: \"system\", content: systemPrompt },\n    { role: \"user\", content: userPrompt }, // 这里包含了 historyDescription\n  ],\n  // ...\n});\n</code></pre>\n<blockquote>\n<p>System: 你是一个猜拳高手，你的对手是一个普通人类。<br />\nUser: 前几轮战况如下：第1轮玩家出剪刀，你出布（输）；第2轮玩家出石头，你出布（赢）。现在是第3轮，请分析玩家的心理，并给出你的出拳。</p>\n\n\n\n\n\n\n\n\n\n\n\n\n</blockquote>\n<p><strong>不仅如此，我给 AI 设定了两种模式：</strong></p>\n<ol>\n<li><strong>策略模式（Strategy）</strong>：降低模型的 <code>temperature</code>（随机性），让它进行严密的逻辑推理。比如它会分析：“玩家上一把输了，根据心理学，这把他大概率会出克制我上一把的招数，所以我预判他……”</li>\n<li><strong>混沌模式（Chaos）</strong>：拉高 <code>temperature</code>，让 AI 彻底放飞自我，主打一个乱拳打死老师傅。</li>\n\n\n\n\n\n\n\n\n\n\n\n\n</ol>\n<h2>优雅降级：当 GPT 脑干缺失时</h2>\n<p>作为老全栈，必须要考虑一种情况：<strong>如果 API 挂了，或者响应超时了怎么办？</strong></p>\n<p>难道让用户干等着转圈圈？绝对不行。</p>\n<p>我在后端实现了一套基于传统统计学的<strong>本地算法</strong>作为“备胎”。如果 LLM 在规定时间内没有响应，系统会无缝切换到本地逻辑。这个本地逻辑一点也不弱，它内置了经典的策略库（代码在 <code>lib/game.ts</code>）：</p>\n<pre><code class=\"language-typescript\">\n// lib/game.ts 里的心理学博弈逻辑\n\n// 1. 如果玩家上轮输了，倾向于出能克制AI上一招的选项 (Win-Stay, Lose-Shift的变种)\nif (lastResult === 'ai_win') {\n  const lastAIChoice = lastRound.ai_choice as Choice;\n  // 预测玩家会出克制我不上一把的牌\n  const predictedPlayerChoice = whatBeatsAI[lastAIChoice];\n  // 那我就预判你的预判\n  return counterMoves[predictedPlayerChoice];\n}\n\n// 2. 如果玩家上轮赢了，可能继续用同一招\nif (lastResult === 'player_win') {\n  // 玩家可能继续用同一招，直接克制它\n  return counterMoves[lastPlayerChoice];\n}\n</code></pre>\n<p>这些策略包括：</p>\n<ul>\n<li><strong>频率分析</strong>：如果你一直出石头，它就会疯狂出布。</li>\n<li><strong>反制连胜</strong>：如果你赢了，它会假设你会继续出一样的，直接克制你。</li>\n</ul>\n<p>在代码实现上，这只是一个简单的 <code>try-catch</code> 降级，但对用户体验来说是质的飞跃。用户根本感觉不到 AI 掉线了，只会感觉“这家伙怎么变风格了？”</p>\n<h2>全栈体验：Next.js App Router 的丝滑</h2>\n<p>在 Next.js 16 中，前后端的边界变得非常模糊（褒义）。本项目使用了 App Router 的 Route Handlers 来处理游戏逻辑。</p>\n<p>前端组件调用后端接口就像调用本地函数一样自然：</p>\n<pre><code class=\"language-typescript\">\n// src/app/game/[id]/page.tsx\nconst playRound = useCallback(async (choice: Choice | null, timeout: boolean = false) =&gt; {\n    // ...\n    const res = await fetch('/api/game/play', {\n        method: 'POST',\n        body: JSON.stringify({ /*...*/ }),\n    });\n    // ...\n}, []);\n</code></pre>\n<p>而在服务端 (<code>src/app/api/game/play/route.ts</code>)，我们完成了完整的业务闭环：</p>\n<pre><code class=\"language-typescript\">\n// src/app/api/game/play/route.ts\nexport async function POST(request: NextRequest) {\n    // 1. 身份校验与数据库读取\n    const { sessionId, playerChoice } = await request.json();\n    const baseSession = await db.execute(/*...*/);\n\n    // 2. 调用 AI (带超时降级)\n    // 如果 API 响应太慢，这里会自动切换到本地逻辑\n    const aiChoiceResult = await Promise.race([\n        getAIChoiceFromAPI(aiConfig, history, difficulty),\n        timeoutPromise // 设定的超时时间\n    ]);\n\n    // 3. 判定胜负 &amp; 写入数据库\n    const result = determineWinner(playerChoice, aiChoiceResult.choice);\n    // ...\n    \n    return NextResponse.json({ /*...*/ });\n}\n</code></pre>\n<p>这一套流程行云流水，类型安全虽然不如 Server Actions 极致，但通过共享类型定义（Shared Types），依然能保证前后端的一致性。不用写繁琐的 Swagger，不用搞复杂的 Redux，一把梭。</p>\n<h2>实际上手：由于太会嘲讽导致不想玩了</h2>\n<p>为了增加趣味性，我让 AI 不仅输出“石头/剪刀/布”，还要输出一段 <strong>Reasoning（推理过程）</strong> 和 <strong>Comment（赛后嘲讽）</strong>。</p>\n<p>当你输掉比赛时，你可能会看到这样的结算语：<br />\n<em>“我看你第一把犹豫了很久出了剪刀，我就知道你是个保守的人。下一把别这么明显了，人类。”</em></p>\n<p>说实话，代码写完后我自己测试了几把，胜率居然只有 40% 左右。看着屏幕上 AI 的嘲讽，我即使作为开发者也不禁怀疑：这玩意儿是不是真有意识？</p>\n<h2>体验地址</h2>\n<p>虽说代码没什么核心科技，但带来的博弈体验确实很有趣。我已经把项目部署上去了，欢迎来挑战（或者被虐）：</p>\n<p>👉 <strong>在线体验</strong></p>\n<p>优先地址：<a href=\"https://rps.anhejin.cn\" rel=\"noopener nofollow\" target=\"_blank\">https://rps.anhejin.cn</a></p>\n<p>有条件的：<a href=\"https://rps-eta-ten.vercel.app\" rel=\"noopener nofollow\" target=\"_blank\">https://rps-eta-ten.vercel.app<br /></a></p>\n<h2>总结</h2>\n<p>这个项目证明了一件事：<strong>技术是冰冷的，但通过简单的创意组合，可以创造出有温度（甚至有点烫手）的交互体验。</strong> Next.js 16 和 React 19 的组合让全栈开发的门槛进一步降低，让我们有更多精力去关注“玩法”本身，而不是被构建配置折磨。</p>\n<p>如果你对源码感兴趣，或者想改改 Prompt 把 AI 调教成“讨好型人格”，欢迎去 <a href=\"https://github.com/greywen/rps\" rel=\"noopener nofollow\">GitHub</a> 扒代码。</p>\n<hr />\n<p><em>注：</em></p>\n<ol>\n<li>本文仅供技术交流，玩游戏输给 AI 请勿用拳头击打显示器，开发者概不负责。</li>\n<li>这只是一个娱乐小游戏，结果具有随机性，不代表任何AI大模型的真实能力。</li>\n<li>游戏结果仅供娱乐，不应用于评估或比较AI模型的实际性能。</li>\n<li>网站不收集、存储或分享任何个人信息或用户数据。</li>\n\n\n\n\n\n\n\n\n\n\n\n\n</ol>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-22 08:29</span>&nbsp;\n<a href=\"https://www.cnblogs.com/greywen\">文过其实</a>&nbsp;\n阅读(<span id=\"post_view_count\">468</span>)&nbsp;\n评论(<span id=\"post_comment_count\">7</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "AspNetCore开发笔记：WebApi项目集成企业微信和公众号",
      "link": "https://www.cnblogs.com/deali/p/19514332",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/deali/p/19514332\" id=\"cb_post_title_url\" title=\"发布于 2026-01-21 23:16\">\n    <span>AspNetCore开发笔记：WebApi项目集成企业微信和公众号</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>很久没写文章了，现在有了AI，其实已经不怎么需要写文章，反正不懂就问AI嘛。</p>\n<p>不过AI总是有盲区的，就比如国内的微信开发。</p>\n<p>微信的文档是公认的烂，而且经常悄咪咪改接口又不更新文档，所以AI对微信开发的API其实不怎么熟悉，经常给出一些错误的回复。</p>\n<p>本文记录一下最近我使用 C# WebApi 项目接入企业微信和公众号的过程，主要是用到自动回复功能。</p>\n<h2 id=\"前置工作\">前置工作</h2>\n<h3 id=\"依赖库\">依赖库</h3>\n<p>我用到了 <strong>SKIT.FlurlHttpClient.Wechat</strong> 这个系列的库：<a href=\"https://github.com/fudiwei/DotNetCore.SKIT.FlurlHttpClient.Wechat\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/fudiwei/DotNetCore.SKIT.FlurlHttpClient.Wechat</a></p>\n<p>原本想直接用 Flurl 对接的，毕竟现在手里有了锤子（AI），看啥都是钉子，啥都想造轮子。</p>\n<p>不过搜了一下我的收藏夹，发现有这个项目，封装了微信的大部分接口，那还要啥自行车，直接用就完事儿了。</p>\n<p>其中：</p>\n<ul>\n<li>企业微信：SKIT.FlurlHttpClient.Wechat.Work</li>\n<li>公众号：SKIT.FlurlHttpClient.Wechat.Api</li>\n</ul>\n<h3 id=\"微信配置信息\">微信配置信息</h3>\n<p>需要准备这些配置信息：</p>\n<p>企业微信：</p>\n<pre><code class=\"language-c#\">public class WechatWorkOptions {\n    public string CorpId { get; set; } = string.Empty;\n    // 应用ID\n    public int AgentId { get; set; }\n    // 应用密钥\n    public string Secret { get; set; } = string.Empty;\n    // 回调 Token\n    public string CallbackToken { get; set; } = string.Empty;\n    // 回调 EncodingAESKey\n    public string CallbackEncodingAESKey { get; set; } = string.Empty;\n}\n</code></pre>\n<p>公众号：</p>\n<pre><code class=\"language-c#\">public class WechatApiClientOptions {\n    public string AppId { get; set; } = string.Empty;\n    public string AppSecret { get; set; } = string.Empty;\n    public string CallbackToken { get; set; } = string.Empty;\n    public string CallbackEncodingAESKey { get; set; } = string.Empty;\n}\n</code></pre>\n<h3 id=\"注册服务\">注册服务</h3>\n<pre><code class=\"language-c#\">// 企业微信\nbuilder.Services.AddSingleton&lt;WechatWorkClient&gt;(sp =&gt; {\n    var options = sp.GetRequiredService&lt;IOptions&lt;WechatWorkOptions&gt;&gt;().Value;\n    return WechatWorkClientBuilder.Create(options).Build();\n});\n\n// 公众号\nbuilder.Services.AddSingleton&lt;WechatApiClient&gt;(sp =&gt; {\n    var options = sp.GetRequiredService&lt;IOptions&lt;WechatMpOptions&gt;&gt;().Value;\n    return WechatApiClientBuilder.Create(options).Build();\n});\n</code></pre>\n<p>准备工作就搞定了。</p>\n<h2 id=\"管理token\">管理token</h2>\n<p>微信的接口都需要用 AccessToken 才能调用，但微信又不想开发者每次都去请求获取token，所以只能获取一次然后自己保存了。</p>\n<p>C# 可以用 IMemoryCache 组件，很方便的管理这些临时存储的数据；Django框架也有内置的cache机制，其他语言框架可以用Redis这类NoSQL数据库来存储。扯远了，本文还是介绍C#的。</p>\n<p>我用一个 <code>WechatWorkTokenService</code> 服务来管理企业微信的token（公众号、小程序这种也是同理）</p>\n<pre><code class=\"language-c#\">public class WechatWorkTokenService(\n    WechatWorkClient client,\n    IMemoryCache cache,\n    IOptions&lt;WechatWorkOptions&gt; options\n) : IWechatWorkTokenService {\n    private const string CacheKey = \"WechatWorkAccessToken\";\n\n    // 用于并发控制，防止瞬间高并发导致多次请求 Token 接口\n    private static readonly SemaphoreSlim Semaphore = new SemaphoreSlim(1, 1);\n\n    /// &lt;summary&gt;\n    /// 获取 AccessToken\n    /// &lt;/summary&gt;\n    public async Task&lt;string&gt; GetAccessTokenAsync(CancellationToken cancellationToken = default) {\n        // 1. 尝试从缓存获取\n        if (cache.TryGetValue(CacheKey, out string? accessToken) &amp;&amp; !string.IsNullOrEmpty(accessToken)) {\n            return accessToken;\n        }\n\n        // 2. 缓存未命中，加锁请求\n        await Semaphore.WaitAsync(cancellationToken);\n        try {\n            // 双重检查，防止排队等待的线程再次请求\n            if (cache.TryGetValue(CacheKey, out accessToken) &amp;&amp; !string.IsNullOrEmpty(accessToken)) {\n                return accessToken;\n            }\n\n            // 3. 调用接口获取 Token\n            var request = new CgibinGetTokenRequest();\n            var response = await client.ExecuteCgibinGetTokenAsync(request, cancellationToken);\n\n            if (!response.IsSuccessful()) {\n                throw new Exception($\"获取 AccessToken 失败: {response.ErrorMessage} (Code: {response.ErrorCode})\");\n            }\n\n            accessToken = response.AccessToken;\n\n            // 4. 设置缓存\n            // 提前 5 分钟过期，确保在过期前刷新\n            // 如果 ExpiresIn 小于 300 秒，则设为一半时间\n            var expirySeconds = response.ExpiresIn &gt; 300 ? response.ExpiresIn - 300 : response.ExpiresIn / 2;\n            var cacheEntryOptions = new MemoryCacheEntryOptions()\n                .SetAbsoluteExpiration(TimeSpan.FromSeconds(expirySeconds));\n\n            cache.Set(CacheKey, accessToken, cacheEntryOptions);\n\n            return accessToken;\n        }\n        finally {\n            Semaphore.Release();\n        }\n    }\n}\n</code></pre>\n<h2 id=\"企业微信\">企业微信</h2>\n<p>企业微信的限制比较少，可以主动给用户发信息，所以可以把接收和发送信息分开，例如调用LLM处理回复的时候，会比较慢，可以把回复放到异步任务队列里去实现。</p>\n<h3 id=\"验证回调\">验证回调</h3>\n<p>直接上接口代码。</p>\n<p>在配置企业微信应用URL的时候，微信服务器会发送一个GET请求到配置的URL进行验证，后端程序需要验证签名，解密后把内容复读给微信服务器。</p>\n<p>下面这个接口就实现了这个验证方法。</p>\n<p>这样实现之后填写 <code>https://example.com/api/wechat/work/callback</code> 这个地址就好了。</p>\n<pre><code class=\"language-c#\">[ApiController]\n[AllowAnonymous]\n[Route(\"api/wechat/work/callback\")]\npublic class WechatWorkController(\n    WechatWorkClient client,\n    IBackgroundTaskQueue queue,\n    ILogger&lt;WechatWorkController&gt; logger\n) : ControllerBase {\n    /// &lt;summary&gt;\n    /// 回调验证 (GET)\n    /// &lt;/summary&gt;\n    [HttpGet]\n    public IActionResult Echo(\n        [FromQuery(Name = \"msg_signature\")] string msgSignature,\n        [FromQuery(Name = \"timestamp\")] string timestamp,\n        [FromQuery(Name = \"nonce\")] string nonce,\n        [FromQuery(Name = \"echostr\")] string echoStr\n    ) {\n        // 验证签名\n        var verifyResult = client.VerifyEventSignatureForEcho(\n            timestamp, nonce, echoStr, msgSignature, out string? replyEcho\n        );\n\n        if (verifyResult.Result) {\n            logger.LogInformation(\"Echo verification successful. ReplyEcho: {ReplyEcho}\", replyEcho);\n            return Content(replyEcho ?? string.Empty);\n        }\n\n        logger.LogWarning(\"Echo verification failed. Error: {Error}\", verifyResult.Error?.Message);\n        return BadRequest($\"Verify signature failed: {verifyResult.Error?.Message}\");\n    }\n}\n</code></pre>\n<h3 id=\"接收信息\">接收信息</h3>\n<p>接收信息和上面的验证都是一个URL，区别是接收信息时，微信服务器会向URL发POST请求。</p>\n<p>代码里有详细注释了，应该不用解释太多。</p>\n<pre><code class=\"language-c#\">/// &lt;summary&gt;\n/// 接收消息 (POST)\n/// &lt;/summary&gt;\n[HttpPost]\npublic async Task&lt;IActionResult&gt; Callback(\n    [FromQuery(Name = \"msg_signature\")] string msgSignature,\n    [FromQuery(Name = \"timestamp\")] string timestamp,\n    [FromQuery(Name = \"nonce\")] string nonce\n) {\n    // 必须读取原始 Request Body 流，而不能使用 [FromBody] 绑定\n    // 原因：\n    // 1. 微信签名验证依赖于原始请求体，任何空格、换行符的差异都会导致签名校验失败\n    // 2. 推送内容通常是加密的 XML，需要先获取原始字符串传给 SDK 进行解密\n    using var reader = new StreamReader(Request.Body);\n    var xml = await reader.ReadToEndAsync();\n\n    logger.LogDebug(\"Callback Body (Length: {Length}): {Xml}\", xml.Length, xml);\n\n    // 1. 验证签名\n    // 虽然 DeserializeEventFromXml 内部可能会包含解密过程，但显式验证签名是更安全的做法\n    var verifyResult = client.VerifyEventSignatureFromXml(timestamp, nonce, xml, msgSignature);\n    if (!verifyResult.Result) {\n        logger.LogWarning(\"Callback signature verification failed. Error: {Error}\", verifyResult.Error?.Message);\n        return BadRequest($\"Verify signature failed: {verifyResult.Error?.Message}\");\n    }\n\n    // 2. 使用 SKIT 库提供的扩展方法自动解密并反序列化\n    // 注意：需要在 WechatWorkClientOptions 中配置 PushToken 和 PushEncodingAESKey\n    WechatWorkEvent wechatEvent;\n    try {\n        wechatEvent = client.DeserializeEventFromXml(xml);\n        logger.LogInformation(\"Callback deserialized successfully. MessageType: {MessageType}, FromUser: {FromUser}, ToUser: {ToUser}\", wechatEvent.MessageType, wechatEvent.FromUserName, wechatEvent.ToUserName);\n    } catch (Exception ex) {\n        // 反序列化失败（通常是因为签名验证失败或解密失败）\n        logger.LogError(ex, \"Callback deserialization failed.\");\n        return BadRequest($\"Deserialization failed: {ex.Message}\");\n    }\n\n    // 处理逻辑\n    if (string.Equals(wechatEvent.MessageType, \"TEXT\", StringComparison.OrdinalIgnoreCase)) {\n        // 再次反序列化为具体的文本消息事件以获取 Content\n        var textEvent = client.DeserializeEventFromXml&lt;TextMessageEvent&gt;(xml);\n        if (textEvent != null &amp;&amp; !string.IsNullOrEmpty(textEvent.Content) &amp;&amp;\n            !string.IsNullOrEmpty(textEvent.FromUserName)) {\n            logger.LogInformation(\"Processing TEXT message from {FromUser}: {Content}\", textEvent.FromUserName, textEvent.Content);\n            await ProcessTextMessageAsync(textEvent.FromUserName, textEvent.Content);\n        }\n    }\n    else if (string.Equals(wechatEvent.MessageType, \"IMAGE\", StringComparison.OrdinalIgnoreCase)) {\n        var imageEvent = client.DeserializeEventFromXml&lt;ImageMessageEvent&gt;(xml);\n        if (imageEvent != null &amp;&amp; !string.IsNullOrEmpty(imageEvent.MediaId) &amp;&amp;\n            !string.IsNullOrEmpty(imageEvent.FromUserName)) {\n            logger.LogInformation(\"Processing IMAGE message from {FromUser}: {MediaId}\", imageEvent.FromUserName, imageEvent.MediaId);\n            await ProcessImageMessageAsync(imageEvent.FromUserName, imageEvent.MediaId);\n        }\n    }\n    else {\n        logger.LogInformation(\"Ignored message type: {MessageType}\", wechatEvent.MessageType);\n    }\n\n    return Ok(\"success\");\n}\n\n</code></pre>\n<h3 id=\"异步处理信息\">异步处理信息</h3>\n<p>因为企业微信可以主动给用户发信息，所以可以把接收和发送信息分开，例如调用LLM处理回复的时候，会比较慢，可以把回复放到异步任务队列里去实现。</p>\n<h4 id=\"文本信息\">文本信息</h4>\n<p>纯文本处理起来还是比较简单的。</p>\n<pre><code class=\"language-c#\">/// &lt;summary&gt;\n/// 异步处理文本消息\n/// &lt;/summary&gt;\nprivate async Task ProcessTextMessageAsync(string toUser, string content) {\n    await queue.QueueBackgroundWorkItemAsync(async (serviceProvider, token) =&gt; {\n        // 在后台任务中解析 Scoped 服务\n        var chatBot = serviceProvider.GetRequiredService&lt;IChatBotService&gt;();\n        var logger = serviceProvider.GetRequiredService&lt;ILogger&lt;WechatWorkController&gt;&gt;();\n\n        try {\n            logger.LogInformation(\"Processing background task for user {ToUser}\", toUser);\n\n            // 1. 调用 ChatBot 获取回复\n            string reply = await chatBot.ProcessMessageAsync(content);\n\n            // 2. 发送回复\n            var accessToken = await _tokenService.GetAccessTokenAsync();\n            var request = new CgibinMessageSendRequest {\n                AccessToken = accessToken,\n                AgentId = _agentId,\n                ToUserIdList = [toUser],\n                MessageType = \"text\",\n                MessageContentAsText = new CgibinMessageSendRequest.Types.TextMessage {\n                    Content = content\n                }\n            };\n            var response = await _client.ExecuteCgibinMessageSendAsync(request);\n            if (!response.IsSuccessful()){\n                throw new Exception($\"发送企业微信消息失败: {response.ErrorMessage} (Code: {response.ErrorCode})\");\n            }\n\n            logger.LogInformation(\"Reply sent to {ToUser}: {ReplyContent}\", toUser, reply);\n        } catch (Exception ex) {\n            logger.LogError(ex, \"Failed to process message for {ToUser}\", toUser);\n        }\n    });\n}\n</code></pre>\n<h4 id=\"图片信息\">图片信息</h4>\n<p>图片麻烦一点，微信不会直接把图片数据发来，而是搞了个 mediaId，要我们手动去下载。</p>\n<p>C# 这里还是方便的，直接把图片下载放到内存里交给第三方服务处理（如OCR），然后再把结果发出来。</p>\n<pre><code class=\"language-c#\">/// &lt;summary&gt;\n/// 异步处理图片消息\n/// &lt;/summary&gt;\nprivate async Task ProcessImageMessageAsync(string toUser, string mediaId) {\n    await queue.QueueBackgroundWorkItemAsync(async (serviceProvider, token) =&gt; {\n        var chatBot = serviceProvider.GetRequiredService&lt;IChatBotService&gt;();\n        var wechatService = serviceProvider.GetRequiredService&lt;IWechatWorkService&gt;();\n        var tokenService = serviceProvider.GetRequiredService&lt;IWechatWorkTokenService&gt;();\n        var logger = serviceProvider.GetRequiredService&lt;ILogger&lt;WechatWorkController&gt;&gt;();\n        var wechatClient = serviceProvider.GetRequiredService&lt;WechatWorkClient&gt;();\n\n        try {\n            logger.LogInformation(\"Processing background image task for user {ToUser}\", toUser);\n\n            // 1. Download Image\n            var accessToken = await tokenService.GetAccessTokenAsync(token);\n            var request = new CgibinMediaGetRequest {\n                AccessToken = accessToken,\n                MediaId = mediaId\n            };\n            var resp = await wechatClient.ExecuteCgibinMediaGetAsync(request, cancellationToken: token);\n\n            if (!resp.IsSuccessful()) {\n                logger.LogError(\"Failed to download image: {Error}\", resp.ErrorMessage);\n                await wechatService.SendTextMessageAsync(toUser, \"抱歉，无法获取图片内容。\");\n                return;\n            }\n\n            var bytes = resp.GetRawBytes();\n            var mimeType = \"image/jpeg\";\n            if (bytes.Length &gt; 0 &amp;&amp; bytes[0] == 0x89 &amp;&amp; bytes[1] == 0x50 &amp;&amp; bytes[2] == 0x4E &amp;&amp; bytes[3] == 0x47) {\n                mimeType = \"image/png\";\n            }\n\n            var items = new ChatMessageContentItemCollection {\n                new ImageContent(bytes, mimeType)\n            };\n\n            // 2. Call ChatBot\n            var chatMessage = new ChatMessageContent(AuthorRole.User, items);\n            var reply = await chatBot.ProcessMessageAsync(chatMessage);\n\n            // 3. Send Reply\n            await wechatService.SendTextMessageAsync(toUser, reply);\n\n            logger.LogInformation(\"Reply sent to {ToUser}\", toUser);\n        } catch (Exception ex) {\n            logger.LogError(ex, \"Failed to process image message for {ToUser}\", toUser);\n        }\n    });\n}\n</code></pre>\n<h2 id=\"公众号\">公众号</h2>\n<p>好，企业微信搞定了。接下来看看公众号。</p>\n<p>公众号和企业微信不一样，无法主动发信息，所以在收到用户信息时，要返回XML格式的相应，作为回复内容，5秒内必须回复。</p>\n<p>验证回调这里就不重复了，和企业微信是一样的。</p>\n<pre><code class=\"language-c#\">/// &lt;summary&gt;\n/// 接收消息 (POST)\n/// &lt;/summary&gt;\n[HttpPost]\npublic async Task&lt;IActionResult&gt; Callback(\n    [FromQuery(Name = \"msg_signature\")] string? msgSignature,\n    [FromQuery(Name = \"signature\")] string? signature,\n    [FromQuery(Name = \"timestamp\")] string timestamp,\n    [FromQuery(Name = \"nonce\")] string nonce,\n    [FromQuery(Name = \"encrypt_type\")] string? encryptType\n) {\n    using var reader = new StreamReader(Request.Body);\n    var xml = await reader.ReadToEndAsync();\n\n    _logger.LogDebug(\"Callback Body (Length: {Length}): {Xml}\", xml.Length, xml);\n\n    // 1. 验证签名\n    // 如果是安全模式 (encryptType == \"aes\")，使用 VerifyEventSignatureFromXml (需要 msg_signature)\n    // 如果是明文模式，SDK 内部 DeserializeEventFromXml 也会做一些校验，但通常明文模式签名校验使用 signature (VerifyEventSignatureForEcho logic)\n    // 这里主要处理安全模式，因为明文模式下通常不需要复杂的解密验证\n    if (string.Equals(encryptType, \"aes\", StringComparison.OrdinalIgnoreCase)) {\n        if (string.IsNullOrEmpty(msgSignature)) {\n            return BadRequest(\"msg_signature is required for aes encryption\");\n        }\n\n        var verifyResult = _client.VerifyEventSignatureFromXml(timestamp, nonce, xml, msgSignature);\n        if (!verifyResult.Result) {\n            _logger.LogWarning(\"Callback signature verification failed. Error: {Error}\", verifyResult.Error?.Message);\n            return BadRequest($\"Verify signature failed: {verifyResult.Error?.Message}\");\n        }\n    }\n    else {\n        // 明文模式，可以使用 signature 验证 (可选)\n        // var verifyResult = _client.VerifyEventSignatureForEcho(timestamp, nonce, signature);\n    }\n\n    // 2. 使用 SKIT 库自动解密并反序列化\n    WechatApiEvent wechatEvent;\n    try {\n        wechatEvent = _client.DeserializeEventFromXml(xml);\n        _logger.LogInformation(\"Callback deserialized successfully. MessageType: {MessageType}, FromUser: {FromUser}, ToUser: {ToUser}\",\n                               wechatEvent.MessageType, wechatEvent.FromUserName, wechatEvent.ToUserName);\n    } catch (Exception ex) {\n        _logger.LogError(ex, \"Callback deserialization failed.\");\n        return BadRequest($\"Deserialization failed: {ex.Message}\");\n    }\n\n    switch (wechatEvent.MessageType?.ToLower()) {\n        case \"text\":\n            var textEvent = _client.DeserializeEventFromXml&lt;TextMessageEvent&gt;(xml);\n            if (!string.IsNullOrEmpty(textEvent.Content) &amp;&amp;\n                !string.IsNullOrEmpty(textEvent.FromUserName)) {\n                _logger.LogInformation(\"Processing TEXT message from {FromUser}: {Content}\", textEvent.FromUserName, textEvent.Content);\n\n                var isSafetyMode = string.Equals(encryptType, \"aes\", StringComparison.OrdinalIgnoreCase);\n\n                var textReply = new TextMessageReply {\n                    ToUserName = textEvent.FromUserName,\n                    FromUserName = textEvent.ToUserName,\n                    MessageType = \"text\",\n                    Content = \"这里是回复给用户的内容\",\n                    CreateTimestamp = DateTimeOffset.Now.ToUnixTimeSeconds()\n                };\n\n                var replyXml = _client.SerializeEventToXml(textReply, isSafetyMode);\n                return Content(replyXml, \"application/xml\");\n            }\n            break;\n\n        default:\n            _logger.LogInformation(\"Ignored message type: {MessageType}\", wechatEvent.MessageType);\n            break;\n    }\n\n    return Ok(\"success\");\n}\n</code></pre>\n<p>可以看到代码里判断是 text 类型后，构造了 TextMessageReply 类型的数据，然后调用 SKIT.FlurlHttpClient.Wechat 库提供的 XML 序列化方法。</p>\n<p>这个库封装了直接序列化被动回复事件的扩展方法，默认会序列化为安全模式。</p>\n<h2 id=\"接入登录\">接入登录</h2>\n<p>微信登录和大部分第三方单点认证流程差不多，已经写过好多次了。</p>\n<p>不再赘述这个流程，感兴趣的同学可以看这篇文章: <a href=\"https://blog.deali.cn/p/django-taro-wechat-work-login\" rel=\"noopener nofollow\" target=\"_blank\">Django+Taro项目实现企业微信登录</a></p>\n<p>本次我没有接入登录，而是用了另一种方式实现微信和平台用户的关联，就是平台上生成一个key，让用户在微信发送，感觉还挺有意思的，另辟蹊径。</p>\n<p>所以这里搬运一下我之前做的单点认证项目里的代码吧，详情可以看这篇文章: <a href=\"https://blog.deali.cn/p/almost-abandoned-project-open-source\" rel=\"noopener nofollow\" target=\"_blank\">IdentityServerLite项目和近期的开源计划</a></p>\n<pre><code class=\"language-c#\">/// &lt;summary&gt;\n/// 企业微信登录 - 使用回调的 code 登录\n/// &lt;/summary&gt;\n/// &lt;param name=\"code\"&gt;&lt;/param&gt;\n/// &lt;param name=\"state\"&gt;一些让微信转发传给后端的参数，这里是单点认证项目的session_id&lt;/param&gt;\n[HttpGet(\"wecom/login\")]\npublic async Task&lt;IActionResult&gt; WecomLogin(string code, string? state = null) {\n    logger.LogInformation(\"企业微信登录，code: {code}, state: {state}, crop: {cropTag}\", code, state, cropTag);\n\n    if (string.IsNullOrWhiteSpace(state)) {\n        return BadRequest(new ApiResponse { Message = \"企业微信登录的 state 为空，无法获取 session\" });\n    }\n\n    var session = await authService.GetSession(state);\n    if (session == null) {\n        return NotFound(new ApiResponse { Message = $\"session {state} 不存在！\" });\n    }\n\n    var userInfo = await wecomService.GetUserInfo(code);\n    if (userInfo == null) {\n        return BadRequest(new ApiResponse { Message = \"获取 userinfo 错误！\" });\n    }\n\n    if (userInfo.Errcode != 0) {\n        return BadRequest(new ApiResponse { Message = $\"获取用户信息失败，企微错误信息: {userInfo.Errmsg}\" });\n    }\n\n    var wechatUser = await wecomService.GetUser(userInfo.Userid);\n    if (wechatUser == null) {\n        return BadRequest(new ApiResponse { Message = \"获取 user 错误！\" });\n    }\n\n    var user = await userRepo.Where(a =&gt; a.PhoneNumber == wechatUser.Userid).FirstAsync();\n    // 用户不存在的话，自动创建用户\n    if (user == null) {\n        user = await accountService.CreateUser(\n            await accountService.GenerateUsername(wechatUser.Name),\n            wechatUser.Userid,\n            wechatUser.Name\n        );\n\n        logger.LogInformation(\"用户 {Phone} 不存在，已创建新用户 {UserId}\", \n                              wechatUser.Userid, user.Id);\n        // return NotFound(new ApiResponse { Message = $\"用户 {wechatUser.Userid} 不存在！\" });\n    }\n\n    try {\n        var url = await authService.LoginSessionAndGetUri(session, user, true);\n        logger.LogInformation(\"企业微信登录成功，跳转到链接: {url}\", url);\n        return Redirect(url);\n    }\n    catch (Exception ex) {\n        ex.ToExceptionless().Submit();\n        return Problem($\"企业微信登录失败: LoginSessionAndGetUri 失败 - {ex.Message}\");\n    }\n}\n</code></pre>\n<h2 id=\"小结\">小结</h2>\n<p>大概就是这些了，很繁琐，不过还挺好用的，这些代码写完后几乎是一次就对接通过，想起来以前反复调试的经历，感叹：日子也是好起来了呀！😄</p>\n<p>另一点感叹：Semantic Kernel真好用，我用了太久langchain，应该早点上semantic kernel的。</p>\n\n</div>\n<div id=\"MySignature\">\n    微信公众号：「程序设计实验室」\n专注于互联网热门新技术探索与团队敏捷开发实践，包括架构设计、机器学习与数据分析算法、移动端开发、Linux、Web前后端开发等，欢迎一起探讨技术，分享学习实践经验。\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-21 23:16</span>&nbsp;\n<a href=\"https://www.cnblogs.com/deali\">程序设计实验室</a>&nbsp;\n阅读(<span id=\"post_view_count\">319</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "探秘 AgentRun｜基于 Serverless 的 AI Agent 沙箱工程化之路",
      "link": "https://www.cnblogs.com/Serverless/p/19518412",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Serverless/p/19518412\" id=\"cb_post_title_url\" title=\"发布于 2026-01-22 17:28\">\n    <span>探秘 AgentRun｜基于 Serverless 的 AI Agent 沙箱工程化之路</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>阿里云函数计算 AgentRun 全新发布后，我们整理了“探秘 AgentRun”系列文章，本系列将梳理企业落地Agent 常见难题，给出具体解法，助力 Agentic AI 快速走进生产级环境。欢迎加入“函数计算 AgentRun 客户群”与我们交流，钉钉群号：134570017218。</p>\n<h2 id=\"ai-agent-时代的沙箱需求\">AI Agent 时代的沙箱需求</h2>\n<h3 id=\"从-copilot-到-agent执行能力的质变\">从 Copilot 到 Agent：执行能力的质变</h3>\n<p>在生成式 AI 的早期阶段，应用主要以“Copilot”形式存在，AI 仅作为辅助生成建议。然而，随着 AutoGPT、BabyAGI 以及 OpenAI Code Interpreter（现为 Advanced Data Analysis）的出现，AI 开始扮演“Agent”的角色。Agent 被赋予了目标，并能自主规划步骤、使用工具来达成目标。</p>\n<p>这种质变的核心在于<strong>代码执行（Code Execution）</strong>。为了回答“分析这层楼的销售数据并绘制趋势图”这样的请求，LLM 不再只是生成一段 Python 代码文本，而是需要在一个真实的 Python 环境中运行这段代码，并获取绘图结果。同样，为了“帮我预订一张去东京的机票”，Agent 可能需要在一个无头浏览器（Headless Browser）中模拟用户点击。</p>\n<h3 id=\"不可信代码的安全隐患\">不可信代码的安全隐患</h3>\n<p>当 LLM 生成代码并执行时，这段代码在本质上是<strong>不可信的（Untrusted）</strong>。如果直接在应用服务器或用户的本地设备上运行，将面临灾难性的安全风险：</p>\n<ul>\n<li><strong>系统破坏</strong>：AI 生成的代码可能无意或恶意地包含 rm -rf / 等破坏性指令，或者修改关键系统配置文件。</li>\n<li><strong>数据泄露</strong>：代码可能尝试读取环境变量中的 API Key，或者扫描内网数据库，将敏感数据发送到外部服务器。</li>\n<li><strong>资源耗尽</strong>：死循环或内存泄漏代码可能导致宿主机崩溃，影响其他租户的服务。</li>\n<li><strong>网络攻击</strong>：恶意 Prompt 注入（Prompt Injection）可能诱导 AI 将执行环境作为跳板（Jump Box），对内部网络发起 DDoS 攻击或端口扫描。</li>\n</ul>\n<h3 id=\"agent-场景面临的独特挑战\">Agent 场景面临的独特挑战</h3>\n<p>除了基础的安全性，AI Agent 的交互特性还给沙箱环境带来了前所未有的工程挑战，这也是传统沙箱（如简单的 Docker 容器或虚拟机）难以应对的：</p>\n<ul>\n<li><strong>状态保持</strong>：与传统的“请求-响应”模式不同，Agent 往往需要进行多轮对话。上一轮定义的变量（如 df = load_data()）需要在下一轮（df.plot()）中继续可用。这就要求沙箱环境必须具备<strong>上下文记忆能力</strong>，而非每次请求都重置环境。</li>\n<li><strong>极速启动</strong>：用户无法忍受每次交互都等待数秒甚至数十秒的虚拟机启动时间。为了保证流畅的对话体验（Time to First Token），沙箱必须具备毫秒级的冷启动能力。</li>\n<li><strong>环境依赖多样性</strong>：不同的 Agent 任务可能需要完全不同的依赖库（如 Pandas、Scipy 用于数据分析，Puppeteer 用于网页操作）。沙箱需要支持灵活的自定义镜像或动态依赖加载，同时不能影响启动速度。</li>\n<li><strong>资源成本控制</strong>：Agent 的调用往往具有稀疏性和突发性（例如一天只用几次，但一次用很久）。长期运行独占的虚拟机（VM）成本高昂且资源利用率低，而传统的 FaaS 虽然便宜但往往缺乏状态保持能力。如何在低成本和高性能之间找到平衡点，是一个巨大的挑战。<br />\n因此，构建一个<strong>沙箱</strong>（Sandbox）——一个与宿主机、内网以及其他用户数据严格隔离，同时具备高性能、低成本、有状态的封闭执行环境——成为了 AI Agent 沙箱落地的前提条件。</li>\n</ul>\n<h2 id=\"agentrun-sandbox专为-agent-设计的工程化方案\">AgentRun Sandbox：专为 Agent 设计的工程化方案</h2>\n<p>为了解决上述挑战，我们推出了 <strong>AgentRun Sandbox</strong>。这是一个<strong>以高代码为核心，开放生态、灵活组装</strong>的一站式 Agentic AI 基础设施平台。</p>\n<p>AgentRun 并非从零构建传统的虚拟机集群，而是<strong>基于阿里云函数计算（FC）这一强大的 Serverless 底座构建</strong>。通过充分利用 Serverless 的<strong>按需付费、极致弹性以及免运维（NoOps）</strong> 特性，AgentRun 解决了一直困扰沙箱领域的成本与效率难题，并在此基础上通过工程化封装，提供了面向 Agent 场景的专业能力。</p>\n<h3 id=\"为什么选择函数计算作为-sandbox-infra\">为什么选择函数计算作为 Sandbox Infra</h3>\n<p>在构建 Agent 沙箱时，我们坚定地选择了函数计算（FC）作为底层基础设施，这主要基于以下核心优势的考量：</p>\n<ul>\n<li><strong>强安全隔离</strong>： 沙箱的核心诉求是安全。函数计算底层采用神龙裸金属与 RunD 安全容器技术，每个执行环境都运行在独立的 MicroVM 中。这种基于虚拟化技术的内核级隔离，相比传统的 Docker 容器隔离具有更高的安全性，能有效防止恶意代码逃逸，为不可信代码执行提供了坚实屏障。</li>\n<li><strong>极致弹性与冷启动优化</strong>： Agent 的调用往往具有突发性。函数计算具备毫秒级的弹性伸缩能力，结合 RunD 技术对启动速度的极致优化，使得沙箱能够在数秒甚至毫秒内完成创建和启动。这不仅满足了高并发场景下的需求，也保证了 Agent 交互的流畅性，避免了传统虚拟机启动慢带来的延迟感。</li>\n<li><strong>成本效益</strong>：自建虚拟机集群通常需要为峰值流量预留资源，导致低谷期资源浪费。函数计算采用按需付费（Pay-as-you-go）模式，且 AgentRun 利用了 FC 的空闲自动回收机制，真正做到了“有请求才计费”。对于稀疏调用的 Agent 场景，这种模式能显著降低基础设施成本。</li>\n<li><strong>免运维</strong>： 基于 Serverless 架构，开发者无需关心底层服务器的操作系统补丁、网络配置及集群维护。AgentRun 团队可以将精力集中在沙箱的核心逻辑与业务体验上，而非底层基础设施的繁琐运维。</li>\n<li><strong>会话能力</strong>：函数计算围绕 AI Agent Sandbox 场景推出了会话亲和、隔离以及管理能力。在一次会话生命周期内，相同会话的请求均会被亲和路由到同一个实例中，并独占该实例，保证了会话交互的连续性、上下文完整性以及多租安全性，同时提供完整的管理接口来主动对会话生命周期进行控制，降低了开发门槛。</li>\n</ul>\n<h3 id=\"agentrun-的核心运行机制\">AgentRun 的核心运行机制</h3>\n<p>传统的 Serverless 通常是无状态的，难以满足 Code Interpreter 这类需要上下文保持的场景。AgentRun 借助函数计算的会话产品能力，在无状态的计算底座上构建了有状态、会话级的沙箱体验。</p>\n<h4 id=\"1-沙箱请求亲和\">1. 沙箱请求亲和</h4>\n<p>AgentRun 允许开发者显式地创建一个具有生命周期的执行环境，解决了传统 Serverless“用完即走”导致的上下文丢失问题。</p>\n<ul>\n<li>\n<p><strong>会话亲和</strong>：AgentRun 依赖函数计算会话亲和机制。当开发者创建沙箱后，AgentRun 会维护一个唯一的 SessionID。后续所有携带该 ID 的请求，都会被精准路由到同一个底层的计算实例。这意味着用户在第一步定义的 df = pd.read_csv(...) 对象，在第二步 df.plot() 时依然存在于内存中，完美复刻本地开发体验。</p>\n</li>\n<li>\n<p><strong>MCP 协议原生支持</strong>：针对模型上下文协议（Model Context Protocol, MCP），AgentRun 提供了 MCP SSE 及 MCP Streamable HTTP 会话亲和支持。AgentRun 可以直接作为 MCP 网关，让 LLM 与外部工具的交互更加顺滑。</p>\n</li>\n</ul>\n<h4 id=\"2-多层次安全隔离\">2. 多层次安全隔离</h4>\n<p>在多租户 SaaS 平台中，安全性是 AgentRun 的基石。</p>\n<ul>\n<li><strong>计算隔离</strong>：AgentRun 利用底层基础设施的神龙裸金属与 RunD 安全容器技术，确保每个沙箱实例在内核级别进行隔离。通过强制将会话并发度设置为 1，AgentRun 保证租户 A 的进程空间、内存数据与租户 B 物理分离，防止容器逃逸。</li>\n<li><strong>网络隔离</strong>：网络隔离完全由用户控制。用户可以根据安全需求灵活配置，选择开启或关闭沙箱的公网访问权限，或者将沙箱接入指定的 VPC 网络环境，从而在满足业务连通性的同时，防止恶意代码对内网发起攻击。</li>\n</ul>\n<h4 id=\"3-灵活的生命周期控制\">3. 灵活的生命周期控制</h4>\n<p>AgentRun 通过函数计算的会话能力，接管了底层计算资源的生命周期，为上层应用提供精细化管理：</p>\n<ul>\n<li><strong>自动闲置回收（Idle Timeout）</strong>：为了通过 Serverless 架构降低成本，AgentRun 支持设置空闲超时（例如 5 分钟）。如果 Agent 在这段时间内没有新指令，底层实例会自动销毁并停止计费，完美适配 AI 交互“突发性强、稀疏度高”的特点。</li>\n<li><strong>状态暂停与恢复（即将上线）</strong>：针对长时间的任务间歇，AgentRun 能够将沙箱的内存与磁盘状态快照保存，在用户回归时通过快照快速恢复现场，既节省成本又保留了上下文。</li>\n</ul>\n<h4 id=\"4-会话粒度存储隔离即将上线\">4. 会话粒度存储隔离（即将上线）</h4>\n<p>代码执行需要隔离，数据存储更需要隔离。AgentRun 创新性地规划了会话粒度存储粘性。</p>\n<ul>\n<li><strong>动态绑定</strong>：AgentRun 允许用户为每个沙箱环境中动态分配一个存储挂载点的专属子目录。</li>\n<li><strong>逻辑沙箱</strong>：通过底层的挂载技术，沙箱内部只能看到属于自己的 /workspace，物理上无法访问其他租户的文件（如 ../../tenant-b/secret.txt），从文件系统层面根除了数据交叉风险。</li>\n</ul>\n<h2 id=\"agentrun-开箱即用的沙箱能力\">AgentRun 开箱即用的沙箱能力</h2>\n<p>AgentRun 不仅提供了底层隔离环境，还预置了经过工程化调优的标准化模版，让开发者开箱即用：</p>\n<ul>\n<li><strong>Code Interpreter（代码解释器）</strong>：预装 Python/Node.js/Java 等环境，支持文件上传下载、数据分析、图表绘制及命令行操作。</li>\n<li><strong>Browser User（浏览器沙箱）</strong>：提供基于 CDP over WebSocket 协议的浏览器环境，兼容 Puppeteer / Playwright，让 Agent 能够安全地访问互联网进行网页操作。</li>\n<li><strong>All In One</strong>：集成了代码解释器与浏览器环境的全能型沙箱，满足复杂 Agent 任务需求。<br />\n这些模版镜像具备高度的灵活性，AgentRun 未来将开放镜像定义，允许用户基于标准镜像定制私有依赖库或安全策略。</li>\n</ul>\n<p>AgentRun 沙箱架构详解<br />\n<img alt=\"image.png\" class=\"lazyload\" /></p>\n<h3 id=\"agentrun-网关\">AgentRun 网关</h3>\n<p>这是 AgentRun 的门户，负责接收来自 AI Agent（如 LangChain 应用、ChatGPT Plugin）的 HTTP 请求，除了标准的身份验证、鉴权以及协议转换（如将 HTTP 转为 WebSocket）之外，其核心能力便是沙箱管理以及沙箱请求路由的功能，它屏蔽了底层 Serverless 基础设施的复杂性，实现了如下能力：</p>\n<ul>\n<li><strong>沙箱管理</strong>：管理沙箱资源，维护业务层沙箱 ID 与底层计算资源 SessionID 的映射关系</li>\n<li><strong>状态维护</strong>：监控沙箱的活跃状态，基于沙箱超时配置以及底层资源情况及时对状态进行更新</li>\n<li><strong>资源调度</strong>：根据用户指定的计算规格（CPU、Memory），向底层申请相应的资源。</li>\n</ul>\n<h3 id=\"函数计算沙箱环境\">函数计算沙箱环境</h3>\n<p>主要由函数计算作为底层算力来承载沙箱的运行。AgentRun 利用函数计算提供的极致弹性能力，实现在分钟内启动成三万个独立的沙箱环境，每个环境都运行在独立的 MicroVM 中，搭配自研开箱即用的沙箱镜像模版，在功能以及性能上为用户提供了双重保障。</p>\n<h3 id=\"典型工作流从指令到结果\">典型工作流：从指令到结果</h3>\n<p>以“用户让 Agent 根据上传的 Excel 文件绘制图表”为例，AgentRun 的工作流程如下。</p>\n<h4 id=\"阶段一模板创建\">阶段一：模板创建</h4>\n<ol>\n<li>用户请求：Agent 接收到用户指令后，由 LLM 决策使用 Python 来实现该需求。</li>\n<li>Agent 工具调用：AI Agent 会向 AgentRun 网关发送 Code Interpreter 沙箱模板的创建请求。</li>\n<li>模板创建：AgentRun 网关会调用函数计算接口创建一个 Code 沙箱模板函数，镜像配置为前文提到的自研 Code Interpreter 沙箱模板，该函数需要同时配置会话亲和以及会话隔离。</li>\n</ol>\n<h4 id=\"阶段二沙箱创建\">阶段二：沙箱创建</h4>\n<ol>\n<li>Agent 工具调用：模板创建完成后，Agent 继续进行沙箱创建，创建时传入已有的模板 ID，标识沙箱实例运行时的配置和镜像</li>\n<li>沙箱创建：AgentRun 收到沙箱创建请求后，会调用 FC 的 CreateSession 接口来创建一个沙箱实例，该沙箱会有一个合适的闲置超时时间，最长可存活 24h</li>\n<li>创建完成：AgentRun 会保存 FC 返回的会话 ID，并生成沙箱业务 ID 与之对应，最终将沙箱业务 ID 返回给用户</li>\n</ol>\n<h4 id=\"阶段三任务执行\">阶段三：任务执行</h4>\n<ol>\n<li>上传文件：Agent 通过 Code Interpreter 的文件上传接口，将 Excel 文件上传。若想将该文件持久化，可以在创建沙箱时配置持久化存储 NAS，将其挂到沙箱中，并将文件上传到 NAS 挂载的目录上。</li>\n<li>绘制图表：Agent 生成代码 import pandas as pd; df = pd.read_excel('data.xlsx')，并调用 Code Interpreter 的 run_code 接口执行代码。</li>\n<li>会话亲和：Agent 所有发往 Code Interpreter 的请求中，都必须带上对应的沙箱 ID 才能保证请求都路由到同一个沙箱实例。</li>\n<li>内存驻留：代码执行完毕，变量 df 驻留在内存中.</li>\n<li>二次代码执行：Agent 根据数据列名生成绘图代码 df.plot()。再次发送代码运行请求</li>\n<li>上下文复用：请求再次到达同一实例，直接使用内存中的 df 对象进行绘图，生成图片文件。</li>\n<li>结果回传：图片被写入 NAS，下载链接返回给 Agent。</li>\n</ol>\n<h4 id=\"阶段四资源销毁\">阶段四：资源销毁</h4>\n<ol>\n<li>空闲检测：Agent 完成任务，不再发送请求。</li>\n<li>自动回收：达到 SessionIdleTimeout（如 5 分钟）后，函数计算会自动销毁该沙箱实例，此时除了持久化到 NAS 上的数据，其余环境相关数据均被销毁。</li>\n<li>文件回收：如果 NAS 上的文件是会话隔离的，当用户会话结束后，NAS 上文件需要进行主动或者定时自动清除。</li>\n</ol>\n<h4 id=\"工作时序图\">工作时序图</h4>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<h2 id=\"agentrun-的核心设计原则\">AgentRun 的核心设计原则</h2>\n<p>AgentRun 的工程化实践遵循以下五大核心原则，这构成了其安全、高效、可扩展的基石：</p>\n<h3 id=\"原则一配置即代码\">原则一：配置即代码</h3>\n<p>AgentRun 将沙箱环境定义（环境变量、资源规格、健康检查等）封装为标准化模版。这种设计实现了沙箱配置的版本化管理，使得 Agent 环境可以像代码一样进行复制和回滚。</p>\n<h3 id=\"原则二会话即沙箱\">原则二：会话即沙箱</h3>\n<p>AgentRun 将“会话”作为沙箱的唯一实体。通过 SessionID 绑定底层的计算实例与上下文状态，实现了真正的按需分配与状态保持。沙箱的创建与销毁完全独立于底层物理设施，对用户透明。</p>\n<h3 id=\"原则三生命周期可编程\">原则三：生命周期可编程</h3>\n<p>AgentRun 不仅提供创建（Create）和删除（Delete）接口，还引入了“暂停”、“恢复”和“自动超时”机制。这种可编程性让上层应用能根据业务价值最大化资源利用率，实现成本与性能的最优平衡。</p>\n<h3 id=\"原则四网络接入标准化\">原则四：网络接入标准化</h3>\n<p>AgentRun 抹平了底层网络的差异，提供标准化的 HTTP/WebSocket 接口，并支持 Server-Sent Events（SSE）。无论底层如何升级，上层 Agent 沙箱始终通过标准的 Header 或 Cookie 携带 SessionID 进行交互，降低了集成复杂度。</p>\n<h3 id=\"原则五存储隔离细粒度化即将上线\">原则五：存储隔离细粒度化（即将上线）</h3>\n<p>AgentRun 不仅支持模版粒度的文件系统共享，同时也能够配置沙箱粒度目录级动态挂载。每个沙箱单独挂载一个目录，从根源上杜绝了多租户环境下的数据越权访问风险。</p>\n<h2 id=\"总结与展望\">总结与展望</h2>\n<p>AgentRun Sandbox 是 Serverless 技术在 AI Agent 领域的最佳工程化实践。</p>\n<p>通过将阿里云函数计算（FC）在 <strong>RunD 安全虚拟化</strong>（解决隔离与启动速度）、<strong>会话亲和性</strong>（解决状态保持）以及 <strong>动态 NAS 挂载</strong>（解决数据隔离）等方面的底层技术创新，封装为面向业务的 AgentRun 平台，我们成功降低了企业构建 AI Agent 的门槛。</p>\n<p>对于构建下一代智能体应用的企业而言，选择 AgentRun Sandbox 不仅是选择了一个沙箱工具，更是选择了一套兼顾安全性、用户体验与商业效率的弹性基础设施。未来，AgentRun Sandbox 将继续在启动延迟优化、状态秒级快照恢复以及更多样化的存储支持上深耕，致力于成为 AI Agent 时代最佳的沙箱基座。</p>\n<h2 id=\"立即体验函数计算-agentrun\">立即体验函数计算 AgentRun</h2>\n<p>函数计算 AgentRun 的无代码到高代码演进能力，现已开放体验：</p>\n<p><strong>查看更多产品详情</strong>：<a href=\"https://www.aliyun.com/product/fc/agentrun\" rel=\"noopener nofollow\" target=\"_blank\">https://www.aliyun.com/product/fc/agentrun</a></p>\n<p>1.<strong>快速创建</strong>：访问控制台（<a href=\"https://functionai.console.aliyun.com/cn-hangzhou/agent/explore\" rel=\"noopener nofollow\" target=\"_blank\">https://functionai.console.aliyun.com/cn-hangzhou/agent/explore</a>)，60秒创建你的第一个 Agent</p>\n<p>2.<strong>深度定制</strong>：当需要更复杂功能时，一键转换为高代码<br />\n3.<strong>持续演进</strong>：利用函数计算 AgentRun 的基础设施能力，持续优化你的 Agent</p>\n<p>从想法到上线，从原型到生产，函数计算 AgentRun 始终是你最好的伙伴。欢迎加入“函数计算 AgentRun 客户群”，钉钉群号：134570017218。</p>\n<h3 id=\"快速了解函数计算-agentrun\">快速了解函数计算 AgentRun</h3>\n<p>一句话介绍：函数计算 AgentRun 是一个以高代码为核心的一站式 Agentic AI 基础设施平台。秉持生态开放和灵活组装的理念，为企业级 Agent 应用提供从开发、部署到运维的全生命周期管理。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p>函数计算 AgentRun 架构图</p>\n<p>AgentRun 运行时基于阿里云函数计算 FC 构建，继承了 Serverless 计算极致弹性、按量付费、零运维的核心优势。通过深度集成 AgentScope、LangChain、RAGFlow、Mem0 等主流开源生态。函数计算 AgentRun 将 Serverless 的极致弹性、零运维和按量付费的特性与 AI 原生应用场景深度融合，助力企业实现成本与效率的极致优化，<strong>平均 TCO 降低 60%</strong>。</p>\n<p><strong>让开发者只需专注于 Agent 的业务逻辑创新，无需关心底层基础设施，让 Agentic AI 真正进入企业生产环境。</strong></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-22 17:28</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Serverless\">Serverless社区</a>&nbsp;\n阅读(<span id=\"post_view_count\">7</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "玩转 ZooKeeper",
      "link": "https://www.cnblogs.com/Marktowin/p/19518265",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Marktowin/p/19518265\" id=\"cb_post_title_url\" title=\"发布于 2026-01-22 17:22\">\n    <span>玩转 ZooKeeper</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p dir=\"auto\">Apache ZooKeeper 是一个开源的分布式协调服务，用于分布式系统中维护配置信息、命名、提供分布式同步和组服务。下面根据您的要求，详细说明 ZooKeeper 的产生原因、最初使用、最新的使用、不同版本的更新点、实现原理、部署和使用。内容基于官方文档和可靠来源整理，并包含 Java 代码片段示例（ZooKeeper 主要使用 Java API）。</p>\n<p dir=\"auto\">&nbsp;</p>\n<h3 dir=\"auto\">1. 产生原因</h3>\n<p dir=\"auto\">ZooKeeper 的产生是为了解决分布式系统中协调的复杂问题。在大规模分布式系统中，多个节点需要协调配置、状态同步、领导者选举等任务，但自行实现这些功能容易引入错误，如竞争条件（race conditions）和死锁（deadlock）。ZooKeeper 受 Google 的 Chubby lock service 启发，由 Yahoo! Research 团队开发，用于简化这些协调任务。它提供了一个可靠的、高性能的协调内核，让应用程序开发者专注于业务逻辑，而非重新发明分布式协调机制。最初是为了管理 Yahoo! 的大数据集群而创建，将状态存储在本地日志文件中，确保高可用性和一致性。</p>\n<p dir=\"auto\">&nbsp;</p>\n<h3 dir=\"auto\">2. 早期使用</h3>\n<p dir=\"auto\">ZooKeeper 最初在 Yahoo! 内部用于工业级应用，包括：</p>\n<ul dir=\"auto\">\n<li><strong>Yahoo! Message Broker</strong>：协调和故障恢复服务，用于管理数千个主题的可扩展发布-订阅系统。</li>\n<li><strong>Yahoo! Crawler 的 Fetching Service</strong>：用于故障恢复，确保爬虫任务的可靠执行。</li>\n<li><strong>Yahoo! 广告系统</strong>：提供可靠的服务协调，如命名服务、配置管理和数据同步。 典型早期用例包括命名服务（类似 DNS）、配置管理（集中存储配置）、数据同步（锁机制）、领导者选举（选主）和消息队列。ZooKeeper 被设计为读主导型（读写比约 10:1），适用于运行在数千台机器上的分布式环境。</li>\n</ul>\n<p>&nbsp;</p>\n<h3 dir=\"auto\">3. 当前使用</h3>\n<p dir=\"auto\">如今，ZooKeeper 广泛用于大数据和分布式系统中，作为协调内核。常见用例包括：</p>\n<ul dir=\"auto\">\n<li><strong>配置管理</strong>：集中存储和更新分布式应用的配置（如 Apache Kafka 用于存储消费者偏移量，直到 4.0 版本）。</li>\n<li><strong>领导者选举</strong>：在集群中选举主节点（如 Apache HBase 用于区域分配和主故障转移）。</li>\n<li><strong>分布式锁</strong>：实现互斥访问（如 Apache Accumulo 用于无单点故障架构）。</li>\n<li><strong>组成员管理</strong>：跟踪节点加入/离开（如 Apache Druid 用于集群状态管理）。</li>\n<li><strong>其他</strong>：用于 Apache Hadoop、HDFS、Solr、Kafka（早期版本）、Pulsar 等。最新趋势包括减少对 ZooKeeper 的依赖（如 Pulsar 通过 PIP-45 引入可插拔元数据框架，允许无 ZooKeeper 运行），但在传统系统中仍不可或缺。现代应用强调其在云环境中的高可用性，如在 Kubernetes 中协调微服务。</li>\n</ul>\n<p>&nbsp;</p>\n<h3 dir=\"auto\">4. 不同版本</h3>\n<p dir=\"auto\">ZooKeeper 的版本演进聚焦于性能、安全、兼容性和新功能。以下表格总结从 3.4.x 开始的主要版本更新（基于官方发布笔记，当前稳定版 3.8.x，当前版 3.9.x）。EoL（End-of-Life）版本不再接收社区支持。</p>\n<table>\n<thead>\n<tr><th>版本系列</th><th>首次发布日期</th><th>EoL 日期</th><th>主要更新点</th></tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>3.4.x</strong></td>\n<td>2011 年</td>\n<td>2016 年</td>\n<td>基础稳定版；支持基本 API、复制模式；性能优化；用于 Hadoop 子项目。</td>\n</tr>\n<tr>\n<td><strong>3.5.x</strong></td>\n<td>2019 年 5 月 (3.5.5 作为稳定版)</td>\n<td>2022 年 6 月</td>\n<td>添加动态重配置、本地会话、容器/TTL 节点、SSL 支持原子广播协议、可移除监视器、多线程提交处理器、升级 Netty 4.1、Maven 构建；最小 JDK 1.8；修复 CVE 和兼容性问题。</td>\n</tr>\n<tr>\n<td><strong>3.6.x</strong></td>\n<td>2020 年 3 月</td>\n<td>2022 年 12 月</td>\n<td>性能和安全改进；新 API（如永久递归监视）；移除 Log4j1，使用 reload4j；修复 CVE、快照和 SASL 问题；客户端兼容 3.5.x 服务器。</td>\n</tr>\n<tr>\n<td><strong>3.7.x</strong></td>\n<td>2021 年 3 月</td>\n<td>2024 年 2 月</td>\n<td>新 API（如启动服务器、whoami）；配额强制；主机名规范化；BCKFS 密钥/信任存储；必选认证方案；多 SASL superUsers；快速跟踪节流请求；安全指标；C/Perl SASL 支持；zkSnapshotComparer 工具；YCSB 基准测试说明；修复 64+ 个问题，包括 CVE。</td>\n</tr>\n<tr>\n<td><strong>3.8.x</strong> (当前稳定)</td>\n<td>2022 年 3 月</td>\n<td>-</td>\n<td>日志框架迁移到 LogBack；从文件读取密钥/信任存储密码；恢复 OSGI 支持；减少 Prometheus 指标性能影响；JDK17 支持；第三方依赖更新修复所有 CVE；修复同步、C 客户端测试等问题。</td>\n</tr>\n<tr>\n<td><strong>3.9.x</strong> (当前)</td>\n<td>2023 年 8 月</td>\n<td>-</td>\n<td>管理员服务器 API（快照和数据流出）；通信 Zxid 触发 WatchEvent；TLS 动态加载客户端信任/密钥存储；Netty-TcNative OpenSSL 支持；SSL 支持 Zktreeutil；改进 syncRequestProcessor 性能；第三方依赖更新修复 CVE。</td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">兼容性：3.5.x+ 客户端兼容 3.9.x 服务器；3.9.x 客户端兼容 3.5-3.8.x 服务器（不使用新 API）。</p>\n<p dir=\"auto\">&nbsp;</p>\n<h3 dir=\"auto\">5. 实现原理</h3>\n<p dir=\"auto\">ZooKeeper 的核心是提供一个简单、高可靠的分布式协调服务。其架构基于客户端-服务器模型，使用 ZAB（ZooKeeper Atomic Broadcast）协议（类似于 Paxos）实现一致性。</p>\n<ul dir=\"auto\">\n<li><strong>架构组件</strong>：\n<ul dir=\"auto\">\n<li><strong>Ensemble（集群）</strong>：由奇数个服务器组成（最小 3 个），确保多数派（quorum）可用。包括 Leader（领导者，处理写操作）、Follower（追随者，处理读操作并转发写到 Leader）和 Observer（观察者，只处理读，不参与选举/投票，提高读性能）。</li>\n<li><strong>数据模型</strong>：分层命名空间，像文件系统（znodes：节点，可存储数据和子节点）。支持持久节点（persistent）和临时节点（ephemeral，会话结束删除）。数据在内存中存储（高性能），并持久化到日志和快照。</li>\n<li><strong>一致性保证</strong>：顺序一致性（更新按发送顺序应用）、原子性（更新全成功或全失败）、单一系统映像（客户端无论连接哪个服务器，看到相同视图）、可靠性（更新持久化）、及时性（视图在界限内更新）。</li>\n<li><strong>工作流程</strong>：客户端连接任意服务器。写请求转发到 Leader，通过 ZAB 广播到 Follower（需多数同意）。读请求本地处理。使用监视（watches）通知变化（一次性触发，新版支持永久递归监视）。会话（sessions）通过心跳维护，断连自动重连。</li>\n<li><strong>领导者选举</strong>：使用快速 Paxos 变体，崩溃时快速选举新 Leader（&lt;200ms）。</li>\n<li><strong>性能原理</strong>：内存镜像 + 事务日志；读主导优化；原子消息协议防止副本分歧。</li>\n</ul>\n</li>\n</ul>\n<p dir=\"auto\">ZooKeeper 适用于读多写少场景，提供简单 API（如 create、delete、get、set）。</p>\n<p dir=\"auto\">&nbsp;</p>\n<h3 dir=\"auto\">6. 案例（选举leader执行任务）</h3>\n<p dir=\"auto\">在分布式系统中，ZooKeeper（ZK）常用于协调集群中的节点，确保高可用性和一致性。下面我给出一个详细的例子：一个简单的 <strong>分布式任务调度服务</strong>，部署在集群中，使用 ZooKeeper 实现 <strong>领导者选举（Leader Election）</strong>。这个服务模拟一个定时任务（如数据备份），但只有一个节点（Leader）执行任务，其他节点（Follower）待命。如果 Leader 宕机，Follower 会自动选举新 Leader。</p>\n<p dir=\"auto\"><strong>一个 3 节点集群的分布式任务调度服务</strong></p>\n<ul dir=\"auto\">\n<li>3 台服务器（物理机或虚拟机）：node1、node2、node3</li>\n<li>每个节点运行一个相同的 Java JAR 包</li>\n<li>使用 ZooKeeper 实现<strong>领导者选举</strong>：只有一个节点成为 Leader 执行定时任务，其他节点作为 Follower 待命</li>\n<li>Leader 宕机后，自动快速选举新 Leader</li>\n</ul>\n<p dir=\"auto\"><strong>环境准备（3 台服务器）</strong></p>\n<table>\n<thead>\n<tr><th>主机名</th><th>IP</th><th>角色</th><th>说明</th></tr>\n</thead>\n<tbody>\n<tr>\n<td>node1</td>\n<td>192.168.1.101</td>\n<td>ZooKeeper + Java 服务</td>\n<td>ZooKeeper myid=1</td>\n</tr>\n<tr>\n<td>node2</td>\n<td>192.168.1.102</td>\n<td>ZooKeeper + Java 服务</td>\n<td>ZooKeeper myid=2</td>\n</tr>\n<tr>\n<td>node3</td>\n<td>192.168.1.103</td>\n<td>ZooKeeper + Java 服务</td>\n<td>ZooKeeper myid=3</td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\"><strong>所有节点安装 Java</strong></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">sudo apt update\nsudo apt install openjdk</span>-11-jdk  # Ubuntu/<span style=\"color: rgba(0, 0, 0, 1);\">Debian# 或 CentOS\nsudo yum install java</span>-11-openjdk-devel</pre>\n</div>\n<p dir=\"auto\"><strong>所有节点安装 ZooKeeper 集群</strong></p>\n<div class=\"cnblogs_code\">\n<pre>wget https:<span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">downloads.apache.org/zookeeper/zookeeper-3.8.4/apache-zookeeper-3.8.4-bin.tar.gz</span>\ntar -zxvf apache-zookeeper-3.8.4-<span style=\"color: rgba(0, 0, 0, 1);\">bin.tar.gz\nsudo mv apache</span>-zookeeper-3.8.4-bin /opt/<span style=\"color: rgba(0, 0, 0, 1);\">zookeeper\ncd </span>/opt/zookeeper</pre>\n</div>\n<p dir=\"auto\"><strong>配置 conf/zoo.cfg（所有节点都相同）</strong></p>\n<div class=\"cnblogs_code\">\n<pre>cp conf/zoo_sample.cfg conf/<span style=\"color: rgba(0, 0, 0, 1);\">zoo.cfg\nvi conf</span>/zoo.cfg</pre>\n</div>\n<p><strong>内容如下</strong></p>\n<div class=\"cnblogs_code\">\n<pre>tickTime=2000<span style=\"color: rgba(0, 0, 0, 1);\">\ninitLimit</span>=10<span style=\"color: rgba(0, 0, 0, 1);\">\nsyncLimit</span>=5<span style=\"color: rgba(0, 0, 0, 1);\">\ndataDir</span>=/var/lib/<span style=\"color: rgba(0, 0, 0, 1);\">zookeeper\nclientPort</span>=2181<span style=\"color: rgba(0, 0, 0, 1);\">\n# 集群服务器列表\nserver.</span>1=192.168.1.101:2888:3888<span style=\"color: rgba(0, 0, 0, 1);\">\nserver.</span>2=192.168.1.102:2888:3888<span style=\"color: rgba(0, 0, 0, 1);\">\nserver.</span>3=192.168.1.103:2888:3888</pre>\n</div>\n<p dir=\"auto\"><strong>创建数据目录并设置 myid（每个节点不同）：</strong></p>\n<div class=\"cnblogs_code\">\n<pre>sudo mkdir -p /var/lib/<span style=\"color: rgba(0, 0, 0, 1);\">zookeeper\nsudo chown </span>-R $USER:$USER /var/lib/zookeeper</pre>\n</div>\n<p>　　node1:</p>\n<div class=\"cnblogs_code\">\n<pre>echo \"1\" &gt; /var/lib/zookeeper/myid</pre>\n</div>\n<p>　　node2:</p>\n<div class=\"cnblogs_code\">\n<pre>echo \"2\" &gt; /var/lib/zookeeper/myid</pre>\n</div>\n<p>　　node3:</p>\n<div class=\"cnblogs_code\">\n<pre>echo \"3\" &gt; /var/lib/zookeeper/myid</pre>\n</div>\n<p dir=\"auto\"><strong>启动 ZooKeeper（所有节点）：</strong></p>\n<div class=\"cnblogs_code\">\n<pre>/opt/zookeeper/bin/zkServer.sh start</pre>\n</div>\n<p dir=\"auto\"><strong>验证集群状态：</strong></p>\n<div class=\"cnblogs_code\">\n<pre>/opt/zookeeper/bin/zkServer.sh status</pre>\n</div>\n<p dir=\"auto\">应该看到一个 Leader 和两个 Follower。</p>\n<p dir=\"auto\">&nbsp;<strong>JAVA代码</strong></p>\n<p dir=\"auto\">LeaderElection.java（领导者选举核心），处理连接 ZooKeeper、创建节点、监视变化和选举逻辑。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">package</span><span style=\"color: rgba(0, 0, 0, 1);\"> com.example;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span> org.apache.zookeeper.*<span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> org.apache.zookeeper.data.Stat;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> org.slf4j.Logger;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> org.slf4j.LoggerFactory;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.io.IOException;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.util.Collections;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.util.List;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.util.concurrent.CountDownLatch;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span> LeaderElection <span style=\"color: rgba(0, 0, 255, 1);\">implements</span><span style=\"color: rgba(0, 0, 0, 1);\"> Watcher {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">final</span> Logger logger = LoggerFactory.getLogger(LeaderElection.<span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span><span style=\"color: rgba(0, 0, 0, 1);\"> ZooKeeper zk;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span><span style=\"color: rgba(0, 0, 0, 1);\"> String zkConnectString;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> sessionTimeout;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span><span style=\"color: rgba(0, 0, 0, 1);\"> String electionPath;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span><span style=\"color: rgba(0, 0, 0, 1);\"> String nodeId;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> String currentZnodePath;  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 当前节点的路径，如 /election/node-0000000001</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">private</span> CountDownLatch connectedLatch = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> CountDownLatch(1<span style=\"color: rgba(0, 0, 0, 1);\">);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> TaskService taskService;  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 任务服务引用</span>\n\n    <span style=\"color: rgba(0, 0, 255, 1);\">public</span> LeaderElection(String zkConnectString, <span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> sessionTimeout, String electionPath, String nodeId, TaskService taskService) {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">this</span>.zkConnectString =<span style=\"color: rgba(0, 0, 0, 1);\"> zkConnectString;\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">this</span>.sessionTimeout =<span style=\"color: rgba(0, 0, 0, 1);\"> sessionTimeout;\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">this</span>.electionPath =<span style=\"color: rgba(0, 0, 0, 1);\"> electionPath;\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">this</span>.nodeId =<span style=\"color: rgba(0, 0, 0, 1);\"> nodeId;\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">this</span>.taskService =<span style=\"color: rgba(0, 0, 0, 1);\"> taskService;\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span> connect() <span style=\"color: rgba(0, 0, 255, 1);\">throws</span><span style=\"color: rgba(0, 0, 0, 1);\"> IOException, InterruptedException {\n        zk </span>= <span style=\"color: rgba(0, 0, 255, 1);\">new</span> ZooKeeper(zkConnectString, sessionTimeout, <span style=\"color: rgba(0, 0, 255, 1);\">this</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        connectedLatch.await();  </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 等待连接成功</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    }\n\n    @Override\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> process(WatchedEvent event) {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (event.getState() ==<span style=\"color: rgba(0, 0, 0, 1);\"> Event.KeeperState.SyncConnected) {\n            connectedLatch.countDown();\n        } </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span> <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (event.getType() ==<span style=\"color: rgba(0, 0, 0, 1);\"> Event.EventType.NodeDeleted) {\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 前一个节点删除，重新检查是否成为 Leader</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">try</span><span style=\"color: rgba(0, 0, 0, 1);\"> {\n                checkIfLeader();\n            } </span><span style=\"color: rgba(0, 0, 255, 1);\">catch</span> (KeeperException |<span style=\"color: rgba(0, 0, 0, 1);\"> InterruptedException e) {\n                logger.error(</span>\"Error checking leader\"<span style=\"color: rgba(0, 0, 0, 1);\">, e);\n            }\n        }\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span> participateInElection() <span style=\"color: rgba(0, 0, 255, 1);\">throws</span><span style=\"color: rgba(0, 0, 0, 1);\"> KeeperException, InterruptedException {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 确保选举路径存在（持久节点）</span>\n        Stat stat = zk.exists(electionPath, <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (stat == <span style=\"color: rgba(0, 0, 255, 1);\">null</span><span style=\"color: rgba(0, 0, 0, 1);\">) {\n            zk.create(electionPath, </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> <span style=\"color: rgba(0, 0, 255, 1);\">byte</span>[0<span style=\"color: rgba(0, 0, 0, 1);\">], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n        }\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 创建临时顺序节点</span>\n        currentZnodePath = zk.create(electionPath + \"/\" + nodeId + \"-\", <span style=\"color: rgba(0, 0, 255, 1);\">new</span> <span style=\"color: rgba(0, 0, 255, 1);\">byte</span>[0<span style=\"color: rgba(0, 0, 0, 1);\">], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);\n        logger.info(</span>\"Created znode: {}\"<span style=\"color: rgba(0, 0, 0, 1);\">, currentZnodePath);\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 检查是否是 Leader</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">        checkIfLeader();\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span> checkIfLeader() <span style=\"color: rgba(0, 0, 255, 1);\">throws</span><span style=\"color: rgba(0, 0, 0, 1);\"> KeeperException, InterruptedException {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 获取所有子节点，按序号排序</span>\n        List&lt;String&gt; children = zk.getChildren(electionPath, <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        Collections.sort(children);\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 当前节点是序号最小的，就是 Leader</span>\n        String smallestChild = children.get(0<span style=\"color: rgba(0, 0, 0, 1);\">);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (currentZnodePath.endsWith(smallestChild)) {\n            logger.info(</span>\"I am the Leader: {}\"<span style=\"color: rgba(0, 0, 0, 1);\">, currentZnodePath);\n            taskService.startTask();  </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 开始执行任务</span>\n        } <span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\"> {\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 监视前一个节点</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">int</span> myIndex = children.indexOf(currentZnodePath.substring(electionPath.length() + 1<span style=\"color: rgba(0, 0, 0, 1);\">));\n            String previousChild </span>= children.get(myIndex - 1<span style=\"color: rgba(0, 0, 0, 1);\">);\n            zk.exists(electionPath </span>+ \"/\" + previousChild, <span style=\"color: rgba(0, 0, 255, 1);\">this</span>);  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 设置监视</span>\n            logger.info(\"I am Follower, watching: {}\"<span style=\"color: rgba(0, 0, 0, 1);\">, previousChild);\n            taskService.stopTask();  </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 停止任务（如果之前是 Leader）</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">        }\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span> close() <span style=\"color: rgba(0, 0, 255, 1);\">throws</span><span style=\"color: rgba(0, 0, 0, 1);\"> InterruptedException {\n        zk.close();\n    }\n}</span></pre>\n</div>\n<p dir=\"auto\">TaskService.java（任务执行服务），模拟一个定时任务。只有 Leader 执行。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">package</span><span style=\"color: rgba(0, 0, 0, 1);\"> com.example;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> org.slf4j.Logger;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> org.slf4j.LoggerFactory;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.util.concurrent.Executors;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.util.concurrent.ScheduledExecutorService;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.util.concurrent.TimeUnit;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> TaskService {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">final</span> Logger logger = LoggerFactory.getLogger(TaskService.<span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span><span style=\"color: rgba(0, 0, 0, 1);\"> ScheduledExecutorService executor;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">boolean</span> isRunning = <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> startTask() {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1);\">isRunning) {\n            executor </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> Executors.newSingleThreadScheduledExecutor();\n            executor.scheduleAtFixedRate(() </span>-&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> {\n                logger.info(</span>\"Executing task: Backup database...\");  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 模拟任务</span>\n            }, 0, 60, TimeUnit.SECONDS);  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 每分钟执行</span>\n            isRunning = <span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        }\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> stopTask() {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (isRunning &amp;&amp; executor != <span style=\"color: rgba(0, 0, 255, 1);\">null</span><span style=\"color: rgba(0, 0, 0, 1);\">) {\n            executor.shutdown();\n            isRunning </span>= <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            logger.info(</span>\"Stopped task\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        }\n    }\n}</span></pre>\n</div>\n<p dir=\"auto\">App.java（主入口）</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">package</span><span style=\"color: rgba(0, 0, 0, 1);\"> com.example;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.io.IOException;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.util.Properties;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> App {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span> main(String[] args) <span style=\"color: rgba(0, 0, 255, 1);\">throws</span><span style=\"color: rgba(0, 0, 0, 1);\"> IOException, InterruptedException, Exception {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 加载配置（实际可使用 Spring 或环境变量）</span>\n        Properties props = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> Properties();\n        props.load(App.</span><span style=\"color: rgba(0, 0, 255, 1);\">class</span>.getClassLoader().getResourceAsStream(\"application.properties\"<span style=\"color: rgba(0, 0, 0, 1);\">));\n\n        String zkConnect </span>= props.getProperty(\"zk.connectString\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span> sessionTimeout = Integer.parseInt(props.getProperty(\"zk.sessionTimeout\"<span style=\"color: rgba(0, 0, 0, 1);\">));\n        String electionPath </span>= props.getProperty(\"election.path\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        String nodeId </span>= props.getProperty(\"node.id\");  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 每个实例不同</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">\n        TaskService taskService </span>= <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> TaskService();\n        LeaderElection election </span>= <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> LeaderElection(zkConnect, sessionTimeout, electionPath, nodeId, taskService);\n\n        election.connect();\n        election.participateInElection();\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 保持运行（生产中用 Spring Boot 或 while(true)）</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">        Thread.sleep(Long.MAX_VALUE);\n\n        election.close();\n    }\n}</span></pre>\n</div>\n<p dir=\"auto\">application.properties</p>\n<div class=\"cnblogs_code\">\n<pre>zk.connectString=192.168.1.101:2181,192.168.1.102:2181,192.168.1.103:2181<span style=\"color: rgba(0, 0, 0, 1);\">\nzk.sessionTimeout</span>=5000<span style=\"color: rgba(0, 0, 0, 1);\">\nzk.connectionTimeout</span>=3000<span style=\"color: rgba(0, 0, 0, 1);\">\nelection.path</span>=/<span style=\"color: rgba(0, 0, 0, 1);\">election\n# 每个节点手动设置不同的 node.id\n# node1: node</span>-1<span style=\"color: rgba(0, 0, 0, 1);\">\n# node2: node</span>-2<span style=\"color: rgba(0, 0, 0, 1);\">\n# node3: node</span>-3<span style=\"color: rgba(0, 0, 0, 1);\">\nnode.id</span>=node-1   # 启动时根据节点修改</pre>\n</div>\n<p>项目大包部署到三台服务器指定目录下（/home/user）。</p>\n<p dir=\"auto\">在每台服务器上创建启动脚本（ nohup + 脚本）</p>\n<div class=\"cnblogs_code\">\n<pre>cd /home/<span style=\"color: rgba(0, 0, 0, 1);\">user\n\n</span>#<span style=\"color: rgba(0, 0, 0, 1);\"> 创建启动脚本 start.sh（node1 示例）\ncat </span>&gt; start.sh &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">EOF</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>\n#!/bin/<span style=\"color: rgba(0, 0, 0, 1);\">bash\n\n</span>#<span style=\"color: rgba(0, 0, 0, 1);\"> 节点 ID（每个服务器不同）\nNODE_ID</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">node-1</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>   # node2 改为 node-<span style=\"color: rgba(128, 0, 128, 1);\">2</span>，node3 改为 node-<span style=\"color: rgba(128, 0, 128, 1);\">3</span><span style=\"color: rgba(0, 0, 0, 1);\">\n\nnohup java </span>-<span style=\"color: rgba(0, 0, 0, 1);\">jar \\\n  </span>-Dnode.id=<span style=\"color: rgba(0, 0, 0, 1);\">${NODE_ID} \\\n  distributed</span>-task-service-<span style=\"color: rgba(128, 0, 128, 1);\">1.0</span>-<span style=\"color: rgba(0, 0, 0, 1);\">SNAPSHOT.jar \\\n  </span>&gt; service.log <span style=\"color: rgba(128, 0, 128, 1);\">2</span>&gt;&amp;<span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\"> &amp;\n\necho </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Started with node.id=${NODE_ID}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\nEOF\n\nchmod </span>+x start.sh</pre>\n</div>\n<p dir=\"auto\">每台服务器启动服务</p>\n<div class=\"cnblogs_code\">\n<pre>./start.sh</pre>\n</div>\n<p>日志查看</p>\n<div class=\"cnblogs_code\">\n<pre>tail -f service.log</pre>\n</div>\n<p dir=\"auto\">可以看到类似输出：</p>\n<ul dir=\"auto\">\n<li>一个节点会打印：I am the Leader: /election/node-1-0000000001</li>\n<li>另外两个节点：I am Follower, watching: node-?-0000000000</li>\n</ul>\n<p dir=\"auto\">只有 Leader 会每分钟打印：Executing task: Backup database...</p>\n<h4 dir=\"auto\">测试故障转移</h4>\n<p>查看当前 Leader（假设是 node1）：</p>\n<div class=\"cnblogs_code\">\n<pre>tail -f /home/user/service.log | grep <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">I am the Leader</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span></pre>\n</div>\n<p dir=\"auto\">杀掉 Leader 进程（node1）：</p>\n<div class=\"cnblogs_code\">\n<pre>ps -<span style=\"color: rgba(0, 0, 0, 1);\">ef | grep java\nkill </span>-<span style=\"color: rgba(128, 0, 128, 1);\">9</span> &lt;pid&gt;</pre>\n</div>\n<p>观察其他节点日志：</p>\n<ul dir=\"auto\">\n<li>几百毫秒内，其中一个 Follower 会成为新 Leader，并开始执行任务。</li>\n<li>原来的 Follower 继续监视新 Leader。</li>\n</ul>\n<h3 dir=\"auto\">总结</h3>\n<ul dir=\"auto\">\n<li><strong>操作流程</strong>：3 台机器 → 安装 ZK → 复制 JAR → 修改 node.id → 启动脚本</li>\n<li><strong>高可用</strong>：ZooKeeper 保证领导者选举快速、可靠</li>\n<li><strong>可扩展</strong>：想加更多节点，只需复制 JAR + 修改 node.id + 启动即可</li>\n</ul>\n<p dir=\"auto\">&nbsp;</p>\n<p>&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<p>&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-22 17:22</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Marktowin\">Marktowin</a>&nbsp;\n阅读(<span id=\"post_view_count\">5</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "在以往工作中遇到的不同 kubernetes 问题总结",
      "link": "https://www.cnblogs.com/manuscript/p/19518188",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/manuscript/p/19518188\" id=\"cb_post_title_url\" title=\"发布于 2026-01-22 16:53\">\n    <span>在以往工作中遇到的不同 kubernetes 问题总结</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"前言\">前言</h1>\n<p>本文基于对 <a href=\"https://hackernoon.com/hidden-kubernetes-bad-practices-learned-the-hard-way-during-incidents\" rel=\"noopener nofollow\" target=\"_blank\">Hidden Kubernetes Bad Practices Learned the Hard Way During Incidents</a> 的阅读后，在尊重原文内容的基础上进行了本地化翻译与整理，在语义表达上相较于机翻，更加贴近中文母语者的阅读习惯，提升整体的可读性与理解成本。</p>\n<p>在每个事件的原文翻译之后，都会补充我的个人注解，也算是对原作者没有提到的内容进行补充。<strong>所有个人注解均会明确标识，并独立于原文翻译部分呈现，不会穿插在原文内容之中，以避免对原意造成干扰。</strong></p>\n<p>原文一共 7 个故障，本文去掉了故障二的翻译解析，因为我没用过 ArgoCD...</p>\n<h1 id=\"kube-proxy-默认负载均衡机制导致-http2-流量热点问题\">Kube-proxy 默认负载均衡机制导致 HTTP/2 流量热点问题</h1>\n<h2 id=\"原文翻译\">原文翻译</h2>\n<p>本次事故发生在首次把 HTTP/2 流量引入 Kubernetes 时。我们发现 HTTP/2 流量在后端 Pod 之间的分布出现了异常负载。其表现为某个 Pod 持续出现 CPU 使用率和延迟都很高，但监控指标中同一服务下的其他 Pod 副本几乎完全处于空闲状态。</p>\n<p>我们错误地认为 HTTP/2 流量在 kube-proxy 中的行为会和 HTTP/1.x 一样，但事实并非如此。kube-proxy 对这两种协议的处理方式并不一样。默认情况下，kube-proxy 在四层（TCP 层）进行负载均衡，它是通过 <strong>连接级别</strong> 而不是 <strong>请求级别</strong> 分发流量：</p>\n<ul>\n<li>当客户端向 Kubernetes Service 建立一个 TCP 连接时，kube-proxy 会使用轮询算法选择一个后端 Pod。该 TCP 连接上的所有请求都会被转发到同一个 Pod 上。</li>\n</ul>\n<p>对于 HTTP/1.x 客户端来说，这种方式通常没有问题，因为客户端一般会建立多个短连接（生命周期较短），流量因此可以较为均匀地分布。但对于单个连接多路复用处理所有请求的 HTTP/2 客户端来说，这种机制会导致所有请求都被转发到同一个 Pod，其余 Pod 大多处于空闲状态。最终该 Pod 上的 CPU 使用率和请求延迟显著上升成为性能瓶颈。</p>\n<p>由于对 kube-proxy 连接处理机制理解有限，这个问题在最初阶只能通过调整应用层的 keep-alive 配置暂时缓解。但从长期来看，引入支持 HTTP/2 的服务网格，并通过七层负载均衡来解决才是最终方案。</p>\n<p><strong>关键结论：</strong><br />\n默认情况下，<strong>通过 Service 的流量，是由 kube-proxy 在 TCP 连接级别进行负载均衡的</strong>，在与 HTTP/2 的多路复用机制结合使用时，容易导致流量分布不均。如果没有七层路由能力，单个 Pod 可能会成为瓶颈，而其他 Pod 却处于空闲状态，从而引发性能下降。</p>\n<h2 id=\"个人注解\">个人注解</h2>\n<p>在注解前需要先明确几点：</p>\n<ol>\n<li>k8s svc 只是一个 <strong>转发规则</strong>，kube-proxy 才是将访问 svc 的流量转发到 Pod 的执行者</li>\n<li>以上都发生在 TCP 层（L4）</li>\n</ol>\n<p>这个问题的核心原因在于：</p>\n<ul>\n<li>kube-proxy 默认是四层负载均衡，只在 TCP 连接建立（SYN）时选择一个 Pod</li>\n<li>HTTP/2 一般使用单个连接多路复用处理所有请求</li>\n</ul>\n<div class=\"mermaid\">flowchart TB\n    Client[\"Client&lt;br/&gt;(HTTP/2 长连接)\"]\n\n    Service[\"k8s svc&lt;br/&gt;(虚拟 IP)\"]\n\n    KubeProxy[\"kube-proxy&lt;br/&gt;(L4 / TCP&lt;br/&gt;连接建立时选择 Pod)\"]\n\n    PodA[\"Pod A&lt;br/&gt;(导致高 CPU / 高延迟)\"]\n    PodB[\"Pod B&lt;br/&gt;(几乎空闲)\"]\n    PodC[\"Pod C&lt;br/&gt;(几乎空闲)\"]\n\n    Client --&gt;|1 个 TCP 连接| Service\n    Service --&gt; KubeProxy\n    KubeProxy --&gt;|连接绑定| PodA\n    KubeProxy -.-&gt; PodB\n    KubeProxy -.-&gt; PodC\n</div><p>所以他的正确解法应该是引入支持 HTTP/2 的七层负载均衡或服务网格：</p>\n<ul>\n<li>Ingress Controller</li>\n<li>Istio</li>\n</ul>\n<div class=\"mermaid\">flowchart TB\n    Client[\"Client&lt;br/&gt;(HTTP/2)\"]\n\n    L7[\"Ingress / Service Mesh&lt;br/&gt;(L7 按请求负载均衡)\"]\n\n    PodA[\"Pod A\"]\n    PodB[\"Pod B\"]\n    PodC[\"Pod C\"]\n\n    Client --&gt;|HTTP/2| L7\n    L7 --&gt;|请求 1| PodA\n    L7 --&gt;|请求 2| PodB\n    L7 --&gt;|请求 3| PodC\n</div><h1 id=\"cpu-限制导致不必要的降级\">CPU 限制导致不必要的降级</h1>\n<h2 id=\"原文翻译-1\">原文翻译</h2>\n<p>这是我在资源管理中遇到过最困惑的事件之一。乍一看，集群状态完全正常，节点监控面板显示 CPU 仍然充足，也没有任何资源耗尽的告警。然而从用户体验来看，应用却频繁出现延迟飙升和请求超时。</p>\n<p>最终定位到的根因是 Pod 级别配置了 CPU limit，这导致 CPU 被限流，从而拖慢了应用的执行。</p>\n<p>原因在于：与内存不同，CPU 并不是一种可被消耗殆尽的资源，它是可压缩的，并且在每一个调度周期都会重新分配。每个调度周期（CFS 调度周期）中，CPU 时间都会被分配、回收并重新分发。</p>\n<p>在配置了 CPU limit 的情况下，即使节点上仍然有空闲 CPU，但如果 Pod 达到了配置的 CPU limit 上限，也无法继续使用这些空闲的 CPU。</p>\n<p>当容器触及 CPU limit 时：</p>\n<ul>\n<li>内核会对容器进行限流（throttling）</li>\n<li>进程会被暂停，直到下一个 CPU 调度周期</li>\n<li>即使节点上存在空闲 CPU，容器也无法突破其限制进行突发使用</li>\n</ul>\n<p>CPU 限流相关的指标是定位该问题根因的关键信号，尤其是 <code>container_cpu_cfs_throttled_seconds_total</code> 和 <code>container_cpu_cfs_throttled_periods_total</code>。将这些指标与延迟曲线进行关联分析，可以清晰地看到延迟峰值与 CPU 限流之间的高度一致性。</p>\n<p>移除 CPU limit，仅保留 CPU request，就足以避免限流问题。这样既可以保证 Pod 按比例获得 CPU 资源，又能防止某些 Pod 过度抢占 CPU。</p>\n<p><strong>关键结论：</strong><br />\n配置 CPU limit 可能会出现节点 CPU 空闲的情况下，让 Pod 遇到性能瓶颈，使得延迟问题难以诊断。在大多数场景下，合理配置 CPU request 就已经足够，既允许工作负载在需要时进行突发使用，又能避免 CPU 限制问题。</p>\n<h2 id=\"个人注解-1\">个人注解</h2>\n<p>需要注意的是，当 Pod 达到了配置的 mem limit 上限时，会触发 oomkill 导致 Pod 重启。但 CPU limit 的本质是：</p>\n<ul>\n<li>一旦容器在某个 CFS 周期内用完了分配的 CPU 时间片，<strong>就会被内核直接暂停</strong></li>\n<li>这个暂停行为<strong>与节点是否还有空闲 CPU 无关</strong></li>\n</ul>\n<p>我的观点与作者结论一致，我认为 CPU limit 仅能作为<strong>隔离工具</strong>，而不是性能优化工具。除非你明确希望某些业务不希望占用过多 CPU。</p>\n<h1 id=\"关键业务未设置-priorityclass\">关键业务未设置 PriorityClass</h1>\n<h2 id=\"原文翻译-2\">原文翻译</h2>\n<p>试想一下，核心业务 Pod 在集群中被驱逐，且在短时间内无法重新调度，而一些不那么重要的工作负载却仍在正常运行。</p>\n<p>当你没有为关键部署设置 PriorityClass 时，在集群资源充足的情况下，一切看起来都很正常。但一旦集群遭遇资源压力(mem、cpu、disk），k8s 就会在节点中驱逐某些 Pod。</p>\n<p>Kubelet 会基于服务质量（QoS：Quality Of Service）来驱逐 Pod。如果多个 Pod 属于同一种 QoS 类别（这种情况非常常见），那么其中任何一个 Pod 都可能被驱逐。</p>\n<p>更糟糕的问题出现在后续的重新调度阶段。被驱逐的 Pod 可能会卡在 Pending 状态，并输出如下信息：</p>\n<pre><code class=\"language-bash\">preemption: No victims found for incoming pod\n</code></pre>\n<p>由于所有 Pod 拥有相同的优先级，抢占（preemption）机制无法生效，而此时所有节点又都被占满。</p>\n<p><strong>关键结论：</strong><br />\n仅设置 resource requests 和 limits 并不足以在资源压力下保证存活。它们只能延缓 Pod 被驱逐，但并不能保证调度优先级。对于关键工作负载，必须始终定义 PriorityClass。</p>\n<h2 id=\"个人注解-2\">个人注解</h2>\n<p>在集群资源紧张时，涉及两种不同阶段的决策：</p>\n<ul>\n<li>驱逐\n<ul>\n<li>通过 kubelet 根据不同服务质量（QoS：BestEffort/Burstable/Guaranteed）进行驱逐</li>\n<li>不同服务质量的定义可参考<a href=\"https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/\" rel=\"noopener nofollow\" target=\"_blank\">官网文档</a></li>\n</ul>\n</li>\n<li>调度\n<ul>\n<li>通过 scheduler 根据不同 PriorityClass / priority 资源值决定</li>\n</ul>\n</li>\n</ul>\n<p>简单来说 QoS 解决的是 \"谁能活下来\"，而 PriorityClass 则是 \"谁更重要\"。</p>\n<h1 id=\"由于-pod-卡在-terminating-状态导致的-eks-ip-耗尽问题\">由于 Pod 卡在 Terminating 状态导致的 EKS IP 耗尽问题</h1>\n<h2 id=\"原文翻译-3\">原文翻译</h2>\n<p>想象一下，有 100 多个 Pod 卡在 Terminating 状态，而新的 Pod 因为 IP 耗尽而无法被调度。</p>\n<p>在删除一个自定义 Operator 后，该 Operator 下所有带 finalizer 的 Pod 都卡在了 Terminating 状态。由于 EKS 会为 Pod 分配真实的 VPC IP 地址，这些正在终止的 Pod 仍然持续占用 IP，最终耗尽了子网中的 IP 资源，导致新的 Pod 无法被调度。</p>\n<p>通过定位被 finalizer 阻塞的 Pod，并谨慎地移除这些 finalizer，使 Pod 得以真正删除并释放 IP，从而缓解了这次事故。当子网的 IP 容量恢复后，调度重新开始，集群也恢复了稳定。</p>\n<p>批量移除 Pod 中 finalizer 的方法如下：</p>\n<pre><code class=\"language-bash\">kubectl get pods -n $NAMESPACE -o json |\njq -r '\n  .items[]\n  | select(.metadata.deletionTimestamp != null)\n  | select(.metadata.finalizers | index(\"$FINALIZER_NAME&gt;\"))\n  | \"kubectl patch pod \\(.metadata.name) -n $NAMESPACE -p '\\''{\\\"metadata\\\":{\\\"finalizers\\\":[]}}'\\'' --type=merge\"\n' | sh\n</code></pre>\n<p><strong>关键结论：</strong></p>\n<ul>\n<li>Finalizer 一旦添加，就会一直存在，除非被 operator 显式移除；</li>\n<li>operator 在其管理的资源被完全清理之前绝不能被删除；</li>\n<li>在 EKS 中，处于 Terminating 状态的 Pod 仍然会消耗真实的集群资源。</li>\n</ul>\n<h2 id=\"个人注解-3\">个人注解</h2>\n<p>Finalizer 可以理解为 k8s 中的 \"拦截删除器\"：在资源真正被删除之前，需要强制完成某些清理动作，只要他还存在，k8s 就不能将这个资源真正删除。</p>\n<p>在集群中删除资源时，k8s 的工作流程是这样的：</p>\n<ol>\n<li>标记删除：添加 <code>deletionTimestamp</code> 等标签，资源状态变为 <code>Terminating</code></li>\n<li>检查 Finalizer，如果有则等待完成后再删除，如果没有则直接删除\n<ol>\n<li>某个 Operator 清理后将 finalizer 从 metadata 中删掉</li>\n</ol>\n</li>\n<li>真正删除：资源从 etcd 中移除</li>\n</ol>\n<blockquote>\n<p>💡 需要注意的是，k8s 本身不会完成 finalizer 操作，真正执行的是某个 operator</p>\n</blockquote>\n<p>简单来讲，本次故障的根因在于资源清理顺序不当。在删除 Operator 后，其管理的 Pod 中 Finalizer 无人处理，导致这些 Pod 长期卡在 Terminating 状态无法被真正删除。处于该状态的 Pod 仍会占用 IP 资源，最终造成子网 IP 耗尽，影响新 Pod 调度。</p>\n<pre><code class=\"language-bash\">## 脚本解析\n\n## 通过命令查看 Pod 中有哪些 Finalizer\n## kubectl get pod &lt;pod-name&gt; -n &lt;ns&gt; -o yaml\nindex(\"$FINALIZER_NAME&gt;\")\n</code></pre>\n<h1 id=\"本地临时日志导致的磁盘压力\">本地临时日志导致的磁盘压力</h1>\n<h2 id=\"原文翻译-4\">原文翻译</h2>\n<p>我记得有次事故，是在某业务部署失败后出现的：调度过程中出现错误，同时触发了 Pod 异常驱逐，并且多个节点上出现磁盘压力（Disk Pressure）告警。</p>\n<p>通过磁盘空间用量的突增与各 Pod 资源消耗情况进行关联分析，最终发现一个 Pod 产生了异常高的日志量，很快耗尽了节点的磁盘，从而触发了 DiskPressure。随后 kubelet 开始驱逐无关的 Pod，并将节点状态设置为 NodeHasDiskPressure = True，新工作负载无法再被调度，报错如下：</p>\n<pre><code class=\"language-bash\">0/12 nodes are available: 12 node(s) had disk pressure.\n</code></pre>\n<p>最终的解决方式是：下线这个 Pod，在集群中新增 Node 来承载处于 Pending 的 Pod，并通过清理容器日志来释放受影响节点的磁盘空间。由于这些日志并非关键数据，因此 30 分钟的停机时间是可以接受的。永久性修复方案是在 Helm Chart 中将本地存储切换为持久化存储，确保日志写入外部存储，而不是节点本地磁盘。</p>\n<p><strong>关键结论：</strong><br />\n永远不要使用 emptyDir 卷在节点本地存储 Pod 数据，即便只是临时用途。应该使用外部的持久化存储来避免节点磁盘压力事件，或者必须设置 ephemeral-storage 限制，防止 Pod 无限制地消耗磁盘空间。</p>\n<h2 id=\"个人注解-4\">个人注解</h2>\n<p>这个没啥说的，Pod 数据默认也都是存在本地 <code>/var/lib/</code> 目录下。使用 emptyDir 或 stdout/stderr 本质上用的都是本地磁盘，使用时限制 limit 就好了。</p>\n<h1 id=\"缺失-configmap-重载器reloader\">缺失 ConfigMap 重载器（Reloader）</h1>\n<h2 id=\"原文翻译-5\">原文翻译</h2>\n<p>该事故始于一次数据库连接配置变更，这些配置是通过 ConfigMap 管理。但应用 Pod 并没有感知到这些新配置，原因很简单：在该 Deployment 中并没有配置 ConfigMap Reloader。</p>\n<p>Reloader 会监听 ConfigMap 和 Secret 变化。检测到变更时，会触发受影响 Pod 的滚动重启。如果缺少重载器，就需要手动重启 Pod 才能让其加载最新配置。</p>\n<p>当应用尝试使用过期的数据库连接配置运行时，故障发生了，最终导致数据库连接失败：</p>\n<pre><code class=\"language-bash\">ERROR Database connection failed: could not connect to server\nERROR Connection timeout while attempting to reach database endpoint\nERROR Failed to initialize database pool: invalid connection parameters\nERROR Database unavailable after retrying 5 times\n</code></pre>\n<p>在所有 Pod 被手动重启并加载了最新配置之前，该问题一直未能得到解决。</p>\n<p><strong>关键结论：</strong><br />\nConfigMap 的更新不会自动应用到正在运行的 Pod，依赖手动重启 Pod 存在较大的运维风险，也无法规模化。应始终在 Deployment 中添加 ConfigMap 重载器容器（例如 reloader）。</p>\n<h2 id=\"个人注解-5\">个人注解</h2>\n<p>这个问题本质上并不是 k8s 自身原因。文中提到的 Reloader 重载器是 k8s 生态中的一个<a href=\"https://github.com/stakater/Reloader\" rel=\"noopener nofollow\" target=\"_blank\">开源项目</a>，其作用是监听 ConfigMap 变更，检测到更新后自动触发相关 Pod 重启，让 Pod 重新加载最新的配置。</p>\n<p>实际上，k8s 早已支持 ConfigMap 的热更新机制。ConfigMap 更新后是否能够真正生效，关键在于 Pod 内部应用是否支持热加载：</p>\n<ul>\n<li>如果支持，就用不上该项目</li>\n<li>如果不支持，则可以使用该项目，或者手动重启业务 Pod 也一样</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-22 16:53</span>&nbsp;\n<a href=\"https://www.cnblogs.com/manuscript\">怎么还在写代码</a>&nbsp;\n阅读(<span id=\"post_view_count\">63</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}