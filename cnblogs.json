{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "韩国国民搜索 NAVER：使用 JuiceFS 打通 Hadoop 与 Kubernetes 存储实践",
      "link": "https://www.cnblogs.com/JuiceData/p/19607717",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/JuiceData/p/19607717\" id=\"cb_post_title_url\" title=\"发布于 2026-02-12 11:45\">\n    <span>韩国国民搜索 NAVER：使用 JuiceFS 打通 Hadoop 与 Kubernetes 存储实践</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>NAVER 是韩国领先的互联网科技公司，运营着韩国最大的搜索引擎，并在人工智能、自动驾驶等高科技领域积极布局。作者 Nam Kyung-wan 来自 NAVER Infra 团队，自 2023 年参与 JuiceFS 社区代码贡献 (GitHub: <a href=\"https://github.com/kyungwan-nam\" rel=\"noopener nofollow\" target=\"_blank\">kyungwan-nam</a>)，为 Hadoop 场景提出了多项改进。本文是作者继“ <a href=\"https://juicefs.com/zh-cn/blog/user-stories/naver-storage-solution-juicefs-ai-platforms\" rel=\"noopener nofollow\" target=\"_blank\">为 AI 平台引入存储方案 JuiceFS</a>”后的第二篇博客。</p>\n<p>NAVER Infra 团队负责运营公共 Hadoop 集群，使用 Spark、Hive、MapReduce 等 Hadoop 应用处理数据，并将数据存储在 HDFS 中。HDFS 在 Hadoop 生态系统中通过数据本地性支持高性能，具备优异的容错性和可扩展性。</p>\n<p><strong>随着人工智能服务的普及，数据规模急剧增长，对多样化数据存储的需求也日益增加。同时，如何高效地共享 Hadoop 集群外部 AI 平台（如 Kubernetes）中的数据，成为了一项重要挑战。在这一背景下，NAVER 探讨了对象存储是否可以替代 HDFS，并明确了 JuiceFS 结合对象存储的适用场景</strong>。</p>\n<h2 id=\"01-hdfs-的局限\">01 HDFS 的局限</h2>\n<p><strong>存储成本上升</strong></p>\n<p>AI 开发需要以高效且经济的方式存储不断增长的数据，并在某些情况下长期保留原始数据，以便进行模型改进和重新训练。</p>\n<p>然而，Hadoop 的计算和存储是紧密耦合的，导致存储扩展难以独立进行。当没有计算需求时，仅为扩展存储空间而增加节点会造成不必要的成本。此外，HDFS 默认保留三重副本，进一步增加了存储成本。</p>\n<p><strong>文件数量限制</strong></p>\n<p>AI 开发涉及数千万个小文件，如图像、音频和文本等。HDFS 存在著名的<a href=\"https://www.cloudera.com/blog/technical/the-small-files-problem.html\" rel=\"noopener nofollow\" target=\"_blank\">小文件问题</a>，因为所有文件和块的元数据都存储在 NameNode 的内存中。例如，管理 1000 万个文件大约需要 3GB 的内存。因此，HDFS 可管理的文件数量受到单个 NameNode 内存容量的限制。</p>\n<p><strong>数据中心容灾能力弱</strong></p>\n<p>HDFS 通常由单个数据中心的节点组成。为应对数据中心故障或灾难，需使用额外方案将数据复制到其他数据中心，从而产生增加成本。</p>\n<p><strong>运营成本增加</strong></p>\n<p>NAVER 由专业人员运营公共 Hadoop 集群，负担相对较小，但通常 Hadoop 集群的构建和运营非常复杂且成本高昂。若要单独构建和运营稳定的 Hadoop 环境，需要专业知识和较高的维护成本。</p>\n<p><strong>Kubernetes 中的生态兼容性差</strong></p>\n<p>NAVER AI 平台基于 Kubernetes 构建，并利用 Kubeflow、KServe 等多种 AI 开源工具及 GPU 支持。但 HDFS 不支持 POSIX API 和 CSI 驱动，无法作为 Kubernetes 常规存储方式（即 PersistentVolume）使用。因此，在 Kubernetes 中使用 HDFS 需在容器中准备 Hadoop 包、配置和认证信息，并编写 HDFS API 代码，非常繁琐且会降低 AI 开发效率。</p>\n<h2 id=\"02-对象存储的优势与劣势\">02 对象存储的优势与劣势</h2>\n<p>Hadoop 通过数据本地性提供高性能，但由于 HDFS 与计算节点耦合，计算和存储资源难以独立扩展。因此，扩展存储空间时，仍需增加额外的计算节点。</p>\n<p>相比之下，云环境支持计算和存储的独立扩展。通常，数据存储在对象存储中而非 HDFS，计算可以通过托管服务（如 AWS EMR、Google Dataproc）或基于 Kubernetes 的数据处理引擎进行，数据则存储在 S3、GCS 等对象存储中。这种架构支持灵活扩展计算和存储资源。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>此外，Hadoop 社区和云供应商提供了 <a href=\"https://hadoop.apache.org/docs/r3.4.1/hadoop-aws/tools/hadoop-aws/index.html\" rel=\"noopener nofollow\" target=\"_blank\">S3A</a>、<a href=\"https://hadoop.apache.org/docs/r3.4.1/hadoop-azure/index.html\" rel=\"noopener nofollow\" target=\"_blank\">Azure Blob</a>、<a href=\"https://hadoop.apache.org/docs/r3.4.1/hadoop-aliyun/tools/hadoop-aliyun/index.html\" rel=\"noopener nofollow\" target=\"_blank\">Aliyun OSS</a> 等 HDFS 兼容文件系统，使得对象存储可以像 HDFS 一样使用。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>对象存储作为远程存储，虽然难以实现数据本地性，但具有以下优势：</p>\n<ol>\n<li><strong>存储成本降低</strong>：计算和存储分离，可独立扩展。对象存储通常成本较低，并能根据需要选择不同的存储类别。例如，对于访问频率低但需长期保留的数据，可使用低成本存储类别（如 S3 Glacier）。</li>\n<li><strong>出色的扩展性和弹性</strong>：对象存储设计上支持近乎无限的扩展。对象数量和容量无限制，可根据工作负载变化轻松扩展或缩减。</li>\n<li><strong>数据中心灾难恢复支持</strong>：S3 等对象存储提供跨区域复制功能，可防止数据中心故障或灾难导致的数据丢失。</li>\n<li><strong>运营成本降低</strong>：避免 Hadoop 集群的构建和运营负担，从而降低运营成本。</li>\n</ol>\n<p>但对象存储替代 HDFS 是好的选择吗？</p>\n<p><strong>不支持目录</strong>：<br />\n在文件系统中，文件通过目录进行组织，列出目录下的文件是一项基本操作，通常速度较快。<br />\n而对象存储没有目录的概念，所有对象是独立的扁平结构。列出文件时需要通过对象前缀搜索，速度较慢。此外，为模拟目录结构而临时创建的 Directory Marker 对象也会影响性能。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p><strong>不支持重命名</strong>：<br />\n在文件系统中，重命名是基本操作，以 O(1) 级别的原子事务快速执行。但对象存储不支持重命名，需通过复制全部数据再删除原数据的方式处理，导致速度非常慢且可能中途失败。</p>\n<p>这一问题对于 MapReduce 和 Spark 等大数据框架影响尤为明显(<a href=\"https://hadoop.apache.org/docs/r3.4.1/hadoop-aws/tools/hadoop-aws/committers.html#Introduction:_The_Commit_Problem\" rel=\"noopener nofollow\" target=\"_blank\">Apache Hadoop Amazon Web Services support – Committing work to S3 with the S3A Committers</a>)。文件输出操作通常依赖重命名来保证一致性，FileOutputFormatCommitter 就是基于重命名实现的。因此，在对象存储中直接使用 FileOutputFormatCommitter 会显著降低性能。</p>\n<p>为了解决这一问题，可以使用 <a href=\"https://hadoop.apache.org/docs/r3.4.1/hadoop-aws/tools/hadoop-aws/committers.html#The_Magic_Committer\" rel=\"noopener nofollow\" target=\"_blank\">Magic Committer</a>，它避免了重命名操作，并针对对象存储进行了优化。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<ol start=\"3\">\n<li>\n<p><strong>不支持文件权限</strong>：<br />\nHDFS 支持 POSIX 权限体系，可以设置文件和目录的所有者、组以及其他用户的权限。而对象存储不提供此功能，因此文件的所有者和组通常被视为当前用户，所有文件和目录的权限默认为 666 和 777（即文件可读写，目录可读写并可执行）(参考: <a href=\"https://hadoop.apache.org/docs/r3.4.1/hadoop-project-dist/hadoop-common/filesystem/introduction.html#Object_Stores_vs._Filesystems\" rel=\"noopener nofollow\" target=\"_blank\">Object Stores vs. Filesystems</a>).。</p>\n</li>\n<li>\n<p><strong>数据访问速度慢</strong>：<br />\n对象存储作为远程存储，无法保证数据本地性，并且每次访问都涉及网络传输，因此相较于 HDFS，其数据访问速度较慢，性能受到网络延迟和带宽限制的影响。</p>\n</li>\n<li>\n<p><strong>Kubernetes 中的低可用性</strong>：<br />\n一些工具，如 Mountpoint for Amazon S3 和 s3fs，支持通过 POSIX API 将对象存储挂载为类似本地文件系统的方式。AWS S3 还通过 Mountpoint for Amazon S3 CSI 驱动 支持将对象存储作为 Kubernetes 卷使用。</p>\n</li>\n</ol>\n<p>然而，由于对象存储与传统文件系统存在根本差异，它无法完全兼容 POSIX API，且性能较低。因此，在使用这些工具时，需要充分了解它们的工作原理和局限性。最终，即使在 Kubernetes 环境中使用对象存储，低可用性问题仍然无法解决。</p>\n<ol start=\"6\">\n<li><strong>S3 兼容对象存储的 API 兼容性</strong>：<br />\nS3 已成为对象存储的事实标准，被多种应用广泛支持。因此，许多云供应商和开源项目提供 S3 兼容对象存储。然而，S3 兼容对象存储并不完全等同于原生 S3 服务。在使用时，需要确认其是否与 S3AFileSystem 或其他应用所使用的 S3 API 兼容。</li>\n</ol>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>综上，对象存储可以像 HDFS 一样使用，但需要充分理解其局限性。现有 Hadoop 应用难以直接迁移，仍需额外的开发和适配工作。对于直接使用 HDFS API 编写的代码，需要避免重命名操作，并减少文件列表操作，以适应对象存储的特性。为避免现有 Spark 应用性能下降，需考虑使用 Magic Committer，但它并非总是有效，特别是在不支持 Spark 动态分区覆盖的情况下。</p>\n<p>此外，虽然 Spark 和 Hadoop 社区持续改进对象存储相关问题，但更新软件包版本和解决问题仍然面临挑战。使用 S3 兼容的对象存储时，还需验证其与 S3 API 的兼容性。</p>\n<h2 id=\"03-在-hadoop-中使用-juicefs\">03 在 Hadoop 中使用 JuiceFS</h2>\n<p>JuiceFS 是一款分布式文件系统，架构由客户端、元数据引擎和数据存储组成。对象存储仅用于存储数据块，而文件系统所需的元数据则由数据库管理。</p>\n<p><strong>需注意 JuiceFS 是与 HDFS 类似的分布式文件系统。因此，与直接使用对象存储不同，JuiceFS 能完美支持 HDFS API、POSIX API 和 Kubernetes CSI 驱动</strong>。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>为了在速度慢且修改困难的对象存储上实现分布式文件系统，JuiceFS 引入了 chunk、slice 和 block 概念。</p>\n<ul>\n<li>chunk（64MB）：将文件分割为 64MB 单位，支持基于偏移的并行处理。</li>\n<li>slice：chunk 内的修改单位，写入时创建新 slice 并优先使用最新版本。</li>\n<li>block（默认 4MB）：实际存储在对象存储中的最小单位，通过并行处理缩短上传时间。</li>\n</ul>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>此外，从远程对象存储读取数据较慢，JuiceFS 支持多级缓存，以此弥补此性能不足。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>NAVER 内部 AI 平台已使用 JuiceFS。更多关于 JuiceFS 的详细信息及 AI 平台引入过程可参考<a href=\"https://juicefs.com/zh-cn/blog/user-stories/naver-storage-solution-juicefs-ai-platforms\" rel=\"noopener nofollow\" target=\"_blank\">为 AI 平台引入存储方案 JuiceFS</a>。</p>\n<p>JuiceFS 支持 Hadoop SDK，通过配置 JuiceFS 后，用户即可在 Hadoop 环境中使用它。</p>\n<h3 id=\"配置-juicefs\">配置 JuiceFS</h3>\n<p>为使 Hadoop 识别 JuiceFS 文件系统，需在 core-site.xml 文件中添加以下内容。其中 <a href=\"https://juicefs.com/docs/community/hadoop_java_sdk/#core-configurations\" rel=\"noopener nofollow\" target=\"_blank\">fs.jfs.impl、fs.AbstractFileSystem.jfs.impl 和 juicefs.meta</a> 是必需的。</p>\n<pre><code>&lt;!-- Configure JuiceFS to be available via jfs:// --&gt;    \n  &lt;property&gt;  \n    &lt;name&gt;fs.jfs.impl&lt;/name&gt;  \n    &lt;value&gt;io.juicefs.JuiceFileSystem&lt;/value&gt;  \n  &lt;/property&gt;  \n  &lt;property&gt;  \n    &lt;name&gt;fs.AbstractFileSystem.jfs.impl&lt;/name&gt;  \n    &lt;value&gt;io.juicefs.JuiceFS&lt;/value&gt;  \n  &lt;/property&gt;  \n&lt;!-- juicefs meta url --&gt;    \n  &lt;property&gt;  \n    &lt;name&gt;juicefs.meta&lt;/name&gt;  \n    &lt;value&gt;redis://:password@addr&lt;/value&gt;  \n  &lt;/property&gt;  \n&lt;!-- In this example, grant access permissions to all users to avoid permission issues. --&gt;    \n  &lt;property&gt;  \n    &lt;name&gt;juicefs.umask&lt;/name&gt;  \n    &lt;value&gt;000&lt;/value&gt;  \n  &lt;/property&gt;  \n&lt;!-- Cache up to 100 GiB. --&gt;    \n  &lt;property&gt;  \n    &lt;name&gt;juicefs.cache-size&lt;/name&gt;  \n    &lt;value&gt;102400&lt;/value&gt;  \n  &lt;/property&gt;  \n&lt;!-- Cache under the temporary path of YARN containers, so the cache is removed when the container terminates.    \nSince it's a shared Hadoop, caching is temporary only during job execution. --&gt;  \n  &lt;property&gt;  \n    &lt;name&gt;juicefs.cache-dir&lt;/name&gt;  \n    &lt;value&gt;${env.PWD}/tmp&lt;/value&gt;  \n  &lt;/property&gt;  \n&lt;!-- Prometheus remote write configuration for metrics collection --&gt;    \n  &lt;property&gt;  \n    &lt;name&gt;juicefs.push-remote-write&lt;/name&gt;  \n    &lt;value&gt;http://host:port&lt;/value&gt;  \n  &lt;/property&gt;  \n  &lt;property&gt;  \n    &lt;name&gt;juicefs.push-remote-write-auth&lt;/name&gt;  \n    &lt;value&gt;username:password&lt;/value&gt;  \n  &lt;/property&gt;  \n&lt;!-- Additionally collect Hadoop user and YARN container ID.    \nFor shared Hadoop to distinguish users and applications. --&gt;  \n  &lt;property&gt;  \n    &lt;name&gt;juicefs.push-labels&lt;/name&gt;  \n    &lt;value&gt;user:${env.USER};container_id:${env.CONTAINER_ID}&lt;/value&gt;  \n  &lt;/property&gt;  \n</code></pre>\n<p>以上为单文件系统的默认配置，但也可根据需要配置多个文件系统同时使用。<br />\n更多配置选项可参考“<a href=\"https://juicefs.com/docs/community/hadoop_java_sdk/#client-configurations\" rel=\"noopener nofollow\" target=\"_blank\">客户端配置</a>”。</p>\n<h3 id=\"hadoop-sdk\">Hadoop SDK</h3>\n<p>Hadoop SDK 的 JAR 文件可以通过下载预编译客户端或自行编译源代码获取。为了简化部署，通常可以在所有 Hadoop 节点的 Hadoop 发行版安装路径中预先安装。然而，在大规模 Hadoop 集群中，这种方法操作繁琐，尤其是对于公共 Hadoop 环境，它会限制所有用户使用特定版本。</p>\n<p>大多数 Hadoop 应用支持将所需 JAR 文件部署并添加到 classpath 中，用户可根据实际需要选择部署方式。以下是 HDFS CLI、MapReduce 和 Spark 中的具体部署方法。</p>\n<h3 id=\"hdfs-cli\">HDFS CLI</h3>\n<p>配置完上述 <code>core-site.xml</code> 文件后，需要在 <code>HADOOP_CLASSPATH</code> 环境变量中设置 Hadoop SDK 文件路径。完成此设置后，您可以使用 <code>hdfs</code> 命令操作 <code>hdfs://</code> 和 <code>jfs://</code> 文件系统。</p>\n<pre><code>$ export HADOOP_CLASSPATH=/home/juicefs/juicefs-hadoop-1.2.3.jar  \n$ hdfs dfs -ls hdfs://home/foo  \nFound 6 items    \n...  \ndrwx------   - foo users          0 2022-10-14 20:55 hdfs://home/foo/.Trash    \ndrwx------   - foo users          0 2022-01-06 10:18 hdfs://home/foo/dfsio    \ndrwx------   - foo users          0 2025-01-22 17:54 hdfs://home/foo/tpcds\n\n$ hdfs dfs -ls jfs://default/  \n2025-08-25 19:15:43,964 INFO fs.TrashPolicyDefault: Namenode trash configuration: Deletion interval = 60 minutes, Emptier interval = 60 minutes.    \nFound 8 items    \n...  \ndrwxrwxrwx   - 10000 hadoop-admins       4096 2025-06-10 18:06 jfs://default/nyc    \ndrwxrwxrwx   - 10000 hadoop-admins       4096 2025-05-15 19:42 jfs://default/subdir    \n</code></pre>\n<h3 id=\"mapreduce\">MapReduce</h3>\n<p>MapReduce 在 Hadoop 的多个节点上并行运行，因此所有分配任务的节点都需要部署 JAR 文件。推荐的方法是通过分布式缓存进行部署。使用此方法时，任务执行时会自动将 <code>mapreduce.application.framework.path</code> 中设置的 MapReduce 框架部署到任务节点。</p>\n<p>以下是 <code>mapred-site.xml</code> 文件的示例配置：</p>\n<ul>\n<li><code>mapreduce.application.framework.path</code>：指定包含 Hadoop SDK 的 MapReduce 框架的 HDFS 路径。</li>\n<li><code>mapreduce.application.classpath</code>：配置为包含 Hadoop SDK 的路径。</li>\n</ul>\n<pre><code>&lt;property&gt;  \n   &lt;name&gt;mapreduce.application.classpath&lt;/name&gt;  \n   &lt;value&gt;$PWD/mr-framework/hadoop/share/hadoop/mapreduce/*:$PWD/mr-framework/hadoop/share/hadoop/mapreduce/lib/*:$PWD/mr-framework/hadoop/share/hadoop/common/*:$PWD/mr-framework/hadoop/share/hadoop/common/lib/*:$PWD/mr-framework/hadoop/share/hadoop/yarn/*:$PWD/mr-framework/hadoop/share/hadoop/yarn/lib/*:$PWD/mr-framework/hadoop/share/hadoop/hdfs/*:$PWD/mr-framework/hadoop/share/hadoop/hdfs/lib/*:$PWD/mr-framework/hadoop/share/hadoop/tools/lib/*&lt;/value&gt;  \n &lt;/property&gt;  \n &lt;property&gt;  \n   &lt;name&gt;mapreduce.application.framework.path&lt;/name&gt;  \n   &lt;value&gt;hdfs://mapred/framework/hadoop-mapreduce-3.1.2-juicefs-1.2.3.tar.gz#mrframework&lt;/value&gt;  \n &lt;/property&gt;  \n</code></pre>\n<h3 id=\"spark\">Spark</h3>\n<p>Spark 的基本配置文件是 <code>spark-defaults.conf</code>。在该文件中，可以替代 <code>core-site.xml</code> 进行如下设置：</p>\n<ul>\n<li>任意 Hadoop 设置可以通过 <code>spark.hadoop.key=value</code> 形式添加。</li>\n<li><code>spark.jars</code>：指定要部署到 Spark driver 和 executor，并包含在 classpath 中的 JAR 文件。</li>\n</ul>\n<pre><code>spark.hadoop.fs.jfs.impl io.juicefs.JuiceFileSystem    \nspark.hadoop.fs.AbstractFileSystem.jfs.impl io.juicefs.JuiceFS    \nspark.hadoop.juicefs.meta redis://:password@addr    \nspark.hadoop.juicefs.umask 000    \nspark.hadoop.juicefs.push-remote-write http://host:port    \nspark.hadoop.juicefs.push-remote-write-auth username:password    \nspark.hadoop.juicefs.push-labels user:${env.USER};container_id:${env.CONTAINER_ID}    \nspark.hadoop.juicefs.cache-size 102400    \nspark.hadoop.juicefs.cache-dir ${env.PWD}/tmp    \nspark.jars hdfs://juicefs/juicefs-hadoop/juicefs-hadoop-1.2.3.jar  \n</code></pre>\n<h2 id=\"04-juicefs-改进事项\">04 JuiceFS 改进事项</h2>\n<p>JuiceFS 提供多种接口，支持跨平台的数据共享。例如，在 Hadoop 中使用 MapReduce 或 Spark 处理的数据存储到 JuiceFS 后，可以轻松在 Kubernetes 环境中访问和使用这些数据。</p>\n<p>为使 NAVER 公共 Hadoop 和基于 Kubernetes 的 AI 平台顺畅共享数据，需要进行一些改进。（已经全部贡献到社区版。）</p>\n<h3 id=\"支持-all-squash-挂载5394\"><a href=\"https://github.com/juicedata/juicefs/issues/5394\" rel=\"noopener nofollow\" target=\"_blank\">支持 all-squash 挂载</a>（#5394）</h3>\n<p>NAVER 公共 Hadoop 与 LDAP 集成管理用户账户，因此 Hadoop 中创建的数据由相应用户的 LDAP UID 和 GID 所有。然而，在 Kubernetes 中，容器可以使用任意 UID 和 GID 运行，这可能导致访问 Hadoop 创建的数据时产生权限问题。</p>\n<p>为了解决这个问题，我们增加了挂载选项 <code>--all-squash</code>。该选项使得访问挂载路径时，操作不会以当前账户的 UID 和 GID 进行，而是使用指定的 UID:GID。因此，设置 Hadoop 用户的 LDAP UID 和 GID 后，Kubernetes 中的容器可以无权限问题地访问数据。</p>\n<h3 id=\"改进-juicefsusers-和-juicefsgroup-设置方式4723\"><a href=\"https://github.com/juicedata/juicefs/issues/4723\" rel=\"noopener nofollow\" target=\"_blank\">改进 juicefs.users 和 juicefs.group 设置方式</a>（#4723）</h3>\n<p>如前所述，在 Hadoop 集群中执行任务时，数据归 Hadoop 用户的 LDAP UID 和 GID 所有。但在 Hadoop 集群外部使用 Hadoop SDK 时，数据归任意 UID 和 GID 所有。例如，在 Docker 容器中使用 HDFS 命令存储数据时，所有者为容器内部账户的 UID 和 GID。</p>\n<p>为了解决这个问题，用户需要通过 <code>juicefs.users</code> 和 <code>juicefs.groups</code> 设置指定所需的 UID 和 GID。之前，这要求用户编写 <code>&lt;用户名&gt;:&lt;UID&gt;</code> 和 <code>&lt;组名&gt;:&lt;GID&gt;</code> 格式的文件，并设置文件路径，这个过程非常繁琐。现在，我们增加了直接通过配置值来指定 UID 和 GID 的功能，简化了操作。</p>\n<h3 id=\"支持-subdir6096\"><a href=\"https://github.com/juicedata/juicefs/issues/6096\" rel=\"noopener nofollow\" target=\"_blank\">支持 subdir</a>（#6096）</h3>\n<p>在基于 Kubernetes 的 AI 平台中，JuiceFS 以动态供应方式使用。创建 PersistentVolumeClaim（PVC）时，会在 JuiceFS 文件系统内生成与该卷对应的子目录。若要在 Hadoop 中共享该 PVC，需仅安全地共享该卷对应的目录。</p>\n<p>然而，Hadoop SDK 并不提供类似 <code>--subdir</code> 的挂载选项，无法限制 Hadoop 仅访问 JuiceFS 的特定子路径。为了解决这个问题，我们在 Hadoop SDK 中增加了 <code>juicefs.subdir</code> 设置，使用此设置可以限制仅访问指定路径。</p>\n<h3 id=\"通过-hdfs-命令查看配额5937\"><a href=\"https://github.com/juicedata/juicefs/issues/5937\" rel=\"noopener nofollow\" target=\"_blank\">通过 hdfs 命令查看配额</a>（#5937）</h3>\n<p>JuiceFS 可以为整个文件系统或特定目录设置配额。在 Kubernetes 中，PVC 的 <code>spec.resources.requests.storage</code> 值将设置为该目录的配额。</p>\n<p>在 Hadoop 与 PVC 共享时，也需要查看配额信息。然而，原有的 HDFS 命令 <code>hdfs dfs -count -q</code> 无法查看 JuiceFS 的配额。为了解决这个问题，我们对该功能进行了改进，现在可以通过相同的命令查看 JuiceFS 的配额信息。</p>\n<h3 id=\"支持-prometheus-remote_write-协议6295\"><a href=\"https://github.com/juicedata/juicefs/issues/6295\" rel=\"noopener nofollow\" target=\"_blank\">支持 Prometheus remote_write 协议</a>（#6295）</h3>\n<p>使用 JuiceFS Hadoop SDK 时，可以将指标发送到 Pushgateway 和 Graphite。但 Pushgateway 需要定期清理指标，且 Graphite 格式独特，使用起来较为困难。</p>\n<p>许多系统支持 Prometheus <code>remote_write</code> 协议。为了解决这个问题，我们在 JuiceFS 中增加了通过该协议发送指标的功能。通过 <code>juicefs.push-remote-write</code> 和 <code>juicefs.push-remote-write-auth</code> 设置，用户可以指定 VictoriaMetrics  <code>vmagent</code> 或 Prometheus。这一功能不仅整合了跨平台数据，还能整合监控系统。</p>\n<h2 id=\"05-juicefs-的优势\">05 JuiceFS 的优势</h2>\n<h3 id=\"优势-1通过并行处理和缓存克服对象存储的性能瓶颈\">优势 1：通过并行处理和缓存克服对象存储的性能瓶颈</h3>\n<p>JuiceFS 需要通过网络与远程对象存储交换数据块，因此在性能上难以超越具有数据本地性优势的 HDFS。<strong>然而，通过将数据分块并行处理以及缓存已读取数据，可以克服这一性能瓶颈</strong>。我们通过性能测试验证了 HDFS 和 JuiceFS 在不同场景下的表现。</p>\n<h4 id=\"dfsio\">DFSIO</h4>\n<p>使用 10 个 map task，针对 100GB 文件测量 HDFS 和 JuiceFS 的顺序数据写入和读取的吞吐量。数值越高性能越好。为适应顺序写入/读取，将 JuiceFS 的块大小设为 16MB。</p>\n<ul>\n<li>写入：JuiceFS 的吞吐量是 HDFS 的 1.7 倍。这是因为数据被分割成小块并行上传。</li>\n<li>读取：JuiceFS 的吞吐量是 HDFS 的 0.75 倍。但如果数据已缓存，预期性能与 HDFS 相似。</li>\n</ul>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h4 id=\"tpc-ds\">TPC-DS</h4>\n<p>使用 Spark SQL 测量对存储在 HDFS 和 JuiceFS 的 100GB 规模表的查询响应时间。数值越低性能越好。</p>\n<ul>\n<li>JuiceFS 的响应时间是 HDFS 的 1.8 倍，这是由于数据本地性差异所致。</li>\n<li>已缓存的 JuiceFS 表现出与 HDFS 相似的性能。</li>\n</ul>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h3 id=\"优势-2与-hdfs-完全兼容无需修改现有-hadoop-应用即可使用\">优势 2：与 HDFS 完全兼容，无需修改现有 Hadoop 应用即可使用</h3>\n<p>NAVER 拥有稳定运营的公共 Hadoop 集群，运行着多种服务的 Hadoop 应用。如果仅将不常用的数据存储在对象存储中以降低存储成本，可能会出现问题。正如前所述，对象存储不是文件系统，无法保证现有 Hadoop 应用的性能和运行。为此，需要重写代码或检查数据处理引擎是否支持对象存储。此外，还需根据存储类型单独运行和管理 Hadoop 应用，增加了管理负担。</p>\n<p>与之相反，使用 JuiceFS 可以保持现有 Hadoop 应用不变。用户只需将输入输出路径指定为 <code>hdfs://</code> 或 <code>jfs://</code>，即可以相同方式运行应用。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>HDFS 基于数据本地性保证高性能，而对象存储则在低成本和扩展性方面具有优势。两者各有所长，难以完全替代，需要根据需求选择。使用 JuiceFS 可以在不修改现有 Hadoop 应用的情况下，同时利用 HDFS 和对象存储的优势。</p>\n<h3 id=\"优势-3支持多种接口可作为跨平台集成存储\">优势 3：支持多种接口，可作为跨平台集成存储</h3>\n<p>NAVER 使用多种平台进行服务开发和运营。例如，在开发/运营 AI 服务时，需要在数据处理平台中清洗数据，在 AI 平台中训练模型，并通过容器平台提供服务。</p>\n<p>在 NAVER，各个平台提供独立的存储，平台内部易于使用，但难以访问其他平台的存储。不同平台的存储隔离导致了数据孤岛现象，并容易造成数据重复和资源浪费。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>JuiceFS 不仅支持 HDFS，还完美兼容 POSIX 和 Kubernetes CSI 驱动，适合作为跨平台的集成存储。通过在多个平台间顺畅使用 JuiceFS 共享数据，可大幅提升 AI 服务开发效率，实现数据统一管理。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h2 id=\"06-结语\">06 结语</h2>\n<p>本文探讨了 JuiceFS 在 Hadoop 环境中的使用方法及其优势，而在部分业务场景下，直接采用 HDFS 或对象存储会是更适配的选择。例如，当业务需要依托数据本地性实现高效快速处理时，建议将数据存储于 HDFS 中；此外，针对访问频率较低的数据，或采用 Iceberg 等专为对象存储优化的数据格式时，直接使用对象存储则更为简便。</p>\n<p>而在以下场景中，JuiceFS 会是更优选择：</p>\n<ol>\n<li>需在 Kubernetes 与 Hadoop 环境之间实现数据共享时；</li>\n<li>希望在不修改现有 Hadoop 应用代码的前提下，与 HDFS 并行部署使用时；</li>\n<li>处理存在重复读取行为、可通过缓存显著提升效率的数据作业时；</li>\n<li>业务所用 S3 API 无法被底层 S3 兼容存储良好支持时。</li>\n</ol>\n<p>本文介绍了在 NAVER 内部本地环境中的应用案例，但在 AWS、Google Cloud 等公有云环境中同样适用。希望对有类似困扰的读者有所帮助。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-12 11:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/JuiceData\">JuiceFS</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "布谷鸟过滤器原理详解",
      "link": "https://www.cnblogs.com/lxl-233/p/19607712",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lxl-233/p/19607712\" id=\"cb_post_title_url\" title=\"发布于 2026-02-12 11:46\">\n    <span>布谷鸟过滤器原理详解</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<div>\n<div><span style=\"font-size: 18px;\"><strong>布谷鸟过滤器 vs 布隆过滤器 核心原理与特性解析</strong></span></div>\n</div>\n<p>与布隆过滤器一样,布谷鸟过滤器也是用来快速判断一个元素是否存在的,但是解决了布隆过滤器\"无法删除\"的痛点</p>\n<div>\n<div><span style=\"font-size: 16px;\"><strong>一、底层数据结构对比</strong></span></div>\n</div>\n<p>底层数据结构中,布隆过滤器采用的是一维bit数组,每个位只能存储01状态,通过若干hash函数命中多个位来判断元素是否存在,具有存在的误判风险<br />而布谷鸟过滤器采用的是一维桶数组,每个bucket存储元素的\"指纹\"fingerprint,也就是将元素值做了一边hash,是一个8位2进制数,而且只有两个hash函数,同样也具有存在误判风险</p>\n<div>\n<div><span style=\"font-size: 16px;\"><strong>二、布谷鸟过滤器核心操作</strong></span></div>\n</div>\n<p>1. 插入数据：“双哈希找巢，指纹占位置” 对要存入的任意值（比如字符串 “user123”）：<br />① 生成指纹：先通过哈希函数把值转化为短且固定长度的 “指纹”（比如把 “user123” 哈希成 8 位二进制数 “10110010”）—— 指纹是值的 “精简版”，比原值小得多，目的是节省内存； <br />② 双哈希定位桶：用两个独立的哈希函数（Hash1、Hash2），计算出这个值在 “桶数组” 里的两个候选桶位置（比如 Hash1 算出来是第 10 号桶，Hash2 算出来是第 25 号桶）； <br />③ 存入规则：把指纹放进任意一个候选桶（只要桶里还有空位）；如果两个桶都满了，就 “踢走” 其中一个桶里已有的指纹（类似布谷鸟占别的鸟的巢），被踢走的指纹再用它自己的另一个候选桶位置重新插入，直到找到空位（或重试上限，说明过滤器满了）。</p>\n<p>2. 查询数据：“双桶找指纹，有则判存在”（对应官方 “membership query”） 要判断 “值 x 是否存在”：<br />① 生成 x 的指纹（和插入时的规则一致）；<br />② 用 Hash1、Hash2 算出 x 的两个候选桶；<br />③ 只要其中一个桶里能找到和 x 完全匹配的指纹，就返回 “存在”；两个桶都没有，就返回 “不存在”。 关键特性：只有 “假阳性”，没有 “假阴性” 和布隆过滤器一样，布谷鸟过滤器的判断结果规则是： 说 “不存在”：100% 准确（绝对不存在）； 说 “存在”：可能误判（实际不存在，但指纹巧合匹配）—— 这就是 “假阳性（false positive）”。</p>\n<p>3. 删除数据:&nbsp; &nbsp;\"生成待删除元素指纹, 双哈希找巢, 找到两个候选桶, 桶中找到任意相同指纹,删除一个即可\"<br />为什么传统布隆过滤器无法删除呢? 因为布隆过滤器依靠bit数组hash命中,多个元素可能命中相同位置,那么这个位置实际包含了两个元素存在的信息,是\"共享\"的,删除一个元素,需要把对应位置置为0,就会影响到其他元素的判断<br />而布谷鸟过滤器不同,它使用的是桶数组,就算两个元素恰好计算的两个候选桶是相同的,恰好计算出的指纹也是相同的,且恰好存放指纹的实际桶也是同一个,也没关系,直接往桶里塞<br />因为桶是可以存放多个的,存放多个相同的指纹也没关系,天然支持存放相同指纹<br />删除的时候,直接找到候选桶,删除对应的一个指纹就行了<br />但也正因如此,只删除一个对应指纹,再去判断此元素是否存在时,有其他元素恰好指纹是相同的,且存于同一个桶中,这样可能会存在误判,官方论文中称为\"假阳性\"</p>\n<div>\n<div><span style=\"font-size: 16px;\"><strong>三、误判率：指纹长度的核心影响</strong></span></div>\n</div>\n<p>官方明确 “fingerprint size will directly determine the false positive rate”，意思是 指纹是值的 “精简标识”，长度越短（比如 4 位），不同值生成相同指纹的概率越高，误判率就越高； 指纹越长（比如 16 位），相同指纹的概率越低，误判率就越低，但每个元素生成的指纹越长,&nbsp; 占用的内存也越多。 <br />举个实际数值（Redis 中常用配置）：<br />8 位指纹：误判率≈1/256（0.39%），适合对误判率要求不高、追求内存极致节省的场景； <br />16 位指纹：误判率≈1/65536（0.0015%），适合对误判率敏感的场景（比如黑名单校验）。</p>\n<div>\n<div><span style=\"font-size: 16px;\"><strong>四、Redis 中布谷鸟过滤器的优劣势</strong></span></div>\n</div>\n<p>支持删除数据：布隆过滤器的位数组一旦置 1 无法回退，无法删除；布谷鸟过滤器只需删除对应桶里的指纹即可，适合需要动态更新的场景（比如黑名单新增 / 删除）；<br />空间效率更高：指纹是紧凑存储的，相比布隆过滤器的稀疏位数组(存在大量浪费) 相同误判率下，布谷鸟过滤器的内存占用约为布隆过滤器的 1/2~2/3；<br />哈希函数更少：固定 2 个哈希函数，计算开销比布隆过滤器（3-5 个）更低。<br />性能: 布谷鸟过滤器只需要计算一次找到hash桶,且各个桶的位置较为集中,内存上较为靠近,CPU的缓存命中率更高,查询速度快于布隆过滤器<br /><br />劣势:<br />在接近满时,布谷鸟过滤器插入元素可能会频繁占巢,导致后续指纹不得不移动自己的位置,导致插入性能大幅下降(由于布谷鸟过滤器的\"占巢\"特点,元素越多,越趋向于满时,插入数据的性能会越来越低,因为插入一个就要占别人的巢,别人又要去找另一个巢,重复如此,性能会越来越低)<br />而且布谷鸟过滤器的容量大小必须为2的幂<br />可惜的是现在的具体实现并不多,GitHub上只有零星几个Go,C++,Java的实现</p>\n<div>\n<div><span style=\"font-size: 16px;\"><strong>五、核心总结</strong></span></div>\n</div>\n<p>布谷鸟过滤器底层是桶数组 + 指纹，靠 2 个哈希函数定位桶，不同于布隆过滤器的 “位数组 + 多哈希”；<br />查询逻辑：双桶找匹配指纹，有则判存在，无则判不存在（仅可能假阳性）； <br />误判率核心：指纹长度越短，误判率越高，内存占用越少，可按需平衡；<br />核心优势：支持删除、内存效率高，是 Redis 中布隆过滤器的升级版, 但是插入性能略逊于传统布隆过滤器</p>\n<p>官方文档: <a href=\"https://redis.io/docs/latest/develop/data-types/probabilistic/cuckoo-filter/\" rel=\"noopener nofollow\" target=\"_blank\">https://redis.io/docs/latest/develop/data-types/probabilistic/cuckoo-filter/</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-12 11:46</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lxl-233\">风乐</a>&nbsp;\n阅读(<span id=\"post_view_count\">5</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "鸿蒙应用开发UI基础第六节:Want拉起应用跳转传参匹配规则实战",
      "link": "https://www.cnblogs.com/san-xiu/p/19607664",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/san-xiu/p/19607664\" id=\"cb_post_title_url\" title=\"发布于 2026-02-12 11:41\">\n    <span>鸿蒙应用开发UI基础第六节:Want拉起应用跳转传参匹配规则实战</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"学习目标\">【学习目标】</h2>\n<ol>\n<li>理解 Want 本质：掌握 Want 作为组件间信息传递载体的核心作用，明确显式/隐式 Want 的划分与适用场景；</li>\n<li>掌握显式启动：精通跨应用通过 <code>bundleName+abilityName</code> 精准启动组件；</li>\n<li>掌握隐式启动：吃透 <code>linkFeature</code>、<code>action</code>、<code>entities</code>、<code>uri</code>、<code>type</code> 的完整层级匹配规则；</li>\n<li>数据传递与校验：规范使用 <code>parameters</code> 传递数据，合理运用功能标识实现精准匹配。</li>\n</ol>\n<h2 id=\"内容铺垫\">【内容铺垫】</h2>\n<p>在 HarmonyOS 中，<strong>Want 是组件（Ability/Extension）间交互的标准信息载体</strong>，核心用于描述“操作目标”“操作意图”和“附加数据”，是应用内/跨应用组件通信的核心桥梁。无论是应用内页面跳转、跨应用功能调用（如打开文档、分享内容），本质都是通过传递 Want 对象实现的。</p>\n<p>在之前的章节中，我们已多次使用 Want 实现 Ability 拉起操作，本节将所有 Want 核心能力直接在 <code>Index</code> 页演示，无需额外跳转页面。</p>\n<blockquote>\n<p>核心规范提示：从 API 12 开始，已不再推荐三方应用使用指定 Ability 方式（即显式 Want）拉起其他应用，推荐使用指定应用链接方式（下一节讲），但作为开发者，我们仍需掌握显式/隐式 Want 的核心原理，以便应对各类组件通信场景。</p>\n</blockquote>\n<p>示意图如下：</p>\n<p><img alt=\"StartAbility调用原理\" class=\"lazyload\" /></p>\n<h2 id=\"一want-核心概念与结构\">一、Want 核心概念与结构</h2>\n<p>Want 是对象类型，核心字段决定组件匹配与启动逻辑，关键字段及约束如下：</p>\n<h3 id=\"1-核心字段解析\">1. 核心字段解析</h3>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>类型</th>\n<th>核心作用</th>\n<th>必选性</th>\n<th>核心说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>deviceId</code></td>\n<td>string</td>\n<td>目标设备ID</td>\n<td>否</td>\n<td>空字符串表示本机，跨设备场景需指定设备标识；隐式 Want 暂不支持跨设备调用</td>\n</tr>\n<tr>\n<td><code>bundleName</code></td>\n<td>string</td>\n<td>目标应用包名</td>\n<td>显式必选</td>\n<td>显式 Want 必须指定</td>\n</tr>\n<tr>\n<td><code>abilityName</code></td>\n<td>string</td>\n<td>目标组件名称</td>\n<td>显式必选</td>\n<td>显式 Want 核心字段；API 12+ 跨应用场景不推荐使用</td>\n</tr>\n<tr>\n<td><code>moduleName</code></td>\n<td>string</td>\n<td>目标模块名称</td>\n<td>否</td>\n<td>同一应用多模块存在重名组件时，需指定，否则默认匹配第一个模块</td>\n</tr>\n<tr>\n<td><code>uri</code></td>\n<td>string</td>\n<td>统一资源标识符</td>\n<td>隐式可选</td>\n<td>格式为 <code>scheme://host:port/path</code>；自定义 scheme 不可与系统应用重复（如 <code>ohos</code> 前缀）</td>\n</tr>\n<tr>\n<td><code>action</code></td>\n<td>string</td>\n<td>操作意图</td>\n<td>隐式核心</td>\n<td>常用值：<code>ohos.want.action.viewData</code>（查看数据）、<code>ohos.want.action.share</code>（分享）、<code>ohos.want.action.search</code>（搜索）</td>\n</tr>\n<tr>\n<td><code>entities</code></td>\n<td>Array</td>\n<td>组件类别约束</td>\n<td>隐式可选</td>\n<td>常用值：<code>entity.system.browsable</code>（浏览器类组件）、<code>entity.system.home</code>（桌面应用）</td>\n</tr>\n<tr>\n<td><code>type</code></td>\n<td>string</td>\n<td>数据MIME类型</td>\n<td>隐式可选</td>\n<td>如 <code>text/plain</code>（纯文本）、<code>image/png</code>（PNG图片），需与 <code>uri</code> 协同匹配</td>\n</tr>\n<tr>\n<td><code>parameters</code></td>\n<td>Object</td>\n<td>自定义附加数据</td>\n<td>否</td>\n<td>支持基础数据类型（字符串、数字、布尔值等）；可通过 <code>linkFeature</code> 字段标记功能类型（隐式匹配最高优先级）</td>\n</tr>\n<tr>\n<td><code>flags</code></td>\n<td>number</td>\n<td>启动模式标记</td>\n<td>否</td>\n<td>仅 <code>FLAG_START_WITHOUT_TIPS</code> 支持隐式 Want 取消“暂无可用打开方式”弹框；无法取消“是否允许跳转”系统弹框</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"2-want-的两种核心类型\">2. Want 的两种核心类型</h3>\n<ul>\n<li><strong>显式 Want</strong>：同时指定 <code>bundleName</code> 和 <code>abilityName</code>，直接定位目标组件，无需系统遍历匹配，匹配效率高、无系统开销。</li>\n<li><strong>隐式 Want</strong>：不指定 <code>abilityName</code>，通过 <code>linkFeature</code>、<code>action</code>、<code>entities</code>、<code>uri</code>、<code>type</code> 描述操作意图，由系统匹配声明对应 <code>skills</code> 的组件，<strong>适用于跨应用通用功能调用</strong>（如调用系统分享、打开浏览器）。</li>\n</ul>\n<h3 id=\"3-隐式-want-匹配规则核心重点\">3. 隐式 Want 匹配规则（核心重点）</h3>\n<h4 id=\"1匹配基础前提\">（1）匹配基础前提</h4>\n<p>隐式 Want 匹配的基础前提：若 <code>action</code>/<code>entities</code>/<code>uri</code>/<code>type</code>/<code>parameters(linkFeature)</code> 五个属性均未配置，系统直接判定匹配失败，无需后续校验。</p>\n<h4 id=\"2匹配优先级从高到低\">（2）匹配优先级（从高到低）</h4>\n<p><code>linkFeature（parameters 内置字段）</code> → <code>action</code> → <code>entities</code> → <code>uri + type</code></p>\n<blockquote>\n<p><code>linkFeature</code> 是 HarmonyOS API 11+ 新增的最高优先级匹配字段，通过 <code>parameters</code> 传递，专门解决传统隐式匹配范围过宽的问题，适用于跨应用固定功能的精准隐式调用。</p>\n</blockquote>\n<h4 id=\"3分步详细规则\">（3）分步详细规则</h4>\n<p>表格中 action 值如 <code>abc</code> 仅为表达匹配，工程中取值要规范。</p>\n<h5 id=\"-linkfeature-匹配最高优先级\">① linkFeature 匹配（最高优先级）</h5>\n<h6 id=\"核心匹配字段及校验逻辑精准匹配为唯一规则\">核心匹配字段及校验逻辑（精准匹配为唯一规则）</h6>\n<table>\n<thead>\n<tr>\n<th>校验字段</th>\n<th>触发校验条件</th>\n<th>匹配规则</th>\n<th>失败判定</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>linkFeature</td>\n<td>调用方传该参数则必校验</td>\n<td>需与 skills 配置值完全一致</td>\n<td>配置值≠调用方值（如 link≠errLink）</td>\n</tr>\n<tr>\n<td>scheme（URI）</td>\n<td>调用方传 uri 则必校验 scheme</td>\n<td>需与 uri 的 scheme 完全一致</td>\n<td>scheme≠uri 的 scheme（如 https≠file）</td>\n</tr>\n<tr>\n<td>type</td>\n<td>调用方传 type 则必校验</td>\n<td>需与调用方 type 完全一致</td>\n<td>type≠调用方值（如 text/plain≠image/png）</td>\n</tr>\n</tbody>\n</table>\n<h6 id=\"分场景匹配规则\">分场景匹配规则</h6>\n<ol>\n<li><strong>场景1（仅传 linkFeature）</strong>：仅校验 linkFeature，scheme/type 不参与，一致则成功，否则失败；</li>\n<li><strong>场景2（传 uri+linkFeature）</strong>：需同时满足 scheme 匹配 + linkFeature 匹配，任一不满足则失败；</li>\n<li><strong>场景3（传 type+linkFeature）</strong>：需同时满足 type 匹配 + linkFeature 匹配，任一不满足则失败；</li>\n<li><strong>场景4（传 uri+type+linkFeature）</strong>：需同时满足 scheme 匹配 + type 匹配 + linkFeature 匹配，任一不满足则失败。</li>\n</ol>\n<h6 id=\"补充说明\">补充说明</h6>\n<ul>\n<li>无通配符、前缀匹配等宽松规则，所有参与校验的字段均为<strong>精准完全匹配</strong>；</li>\n<li>调用方未传的字段（如 uri/type），skills 中对应字段不参与校验；</li>\n<li>无“部分匹配”“降级匹配”逻辑，任一需校验字段不匹配则整体失败。</li>\n</ul>\n<h5 id=\"-action-匹配规则\">② action 匹配规则</h5>\n<table>\n<thead>\n<tr>\n<th>调用方 <code>want</code> 的 <code>action</code></th>\n<th>目标方 <code>skills.actions</code></th>\n<th>匹配结果</th>\n<th>核心说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>空值 <code>action:\"\"</code></td>\n<td>空值 <code>actions: []</code></td>\n<td>失败</td>\n<td>双方均未声明操作意图，系统无法匹配</td>\n</tr>\n<tr>\n<td>空值 <code>action:\"\"</code></td>\n<td>非空值 <code>actions: [\"abc\"]</code></td>\n<td>成功</td>\n<td>调用方未指定意图，目标方声明了能力，默认匹配</td>\n</tr>\n<tr>\n<td>非空值 <code>action:\"abc\"</code></td>\n<td>空值 <code>actions: []</code></td>\n<td>失败</td>\n<td>调用方指定了意图，目标方未声明对应能力</td>\n</tr>\n<tr>\n<td>非空值 <code>action:\"abc\"</code></td>\n<td>包含调用方 <code>actions: [\"abc\"]</code></td>\n<td>成功</td>\n<td>目标方声明的能力包含调用方意图</td>\n</tr>\n<tr>\n<td>非空值 <code>action:\"abc\"</code></td>\n<td>不包含调用方 <code>actions: [\"bcd\"]</code></td>\n<td>失败</td>\n<td>目标方未声明调用方所需能力</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"-entities-匹配规则\">③ entities 匹配规则</h5>\n<table>\n<thead>\n<tr>\n<th>调用方 <code>entities</code></th>\n<th>目标方 <code>skills.entities</code></th>\n<th>匹配结果</th>\n<th>核心说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>空（<code>entities: []</code>）</td>\n<td>非空（<code>entities: [\"a\",\"b\"]</code>）</td>\n<td>成功</td>\n<td>调用方未限定组件类别，目标方无论是否声明类别均匹配</td>\n</tr>\n<tr>\n<td>空（<code>entities: []</code>）</td>\n<td>空（<code>entities: []</code>）</td>\n<td>成功</td>\n<td>调用方未限定组件类别，目标方无论是否声明类别均匹配</td>\n</tr>\n<tr>\n<td>非空（<code>entities: [\"a\"]</code>）</td>\n<td>空（<code>entities: []</code>）</td>\n<td>失败</td>\n<td>调用方限定了组件类别，目标方未声明任何类别</td>\n</tr>\n<tr>\n<td>非空（<code>entities: [\"a\",\"b\"]</code>）</td>\n<td>包含所有调用方（<code>entities: [\"a\",\"b\",\"c\"]</code>）</td>\n<td>成功</td>\n<td>目标方声明的类别完全包含调用方需求</td>\n</tr>\n<tr>\n<td>非空（<code>entities: [\"a\",\"b\"]</code>）</td>\n<td>未包含所有调用方（<code>entities: [\"a\",\"c\"]</code>）</td>\n<td>失败</td>\n<td>目标方声明的类别缺失调用方所需类别（如调用方要 <code>browsable</code>，目标方仅声明 <code>home</code>）</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"-uri--type-匹配规则协同校验\">④ uri + type 匹配规则（协同校验）</h5>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>调用方配置</th>\n<th>匹配规则</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>场景1</td>\n<td>uri 空 + type 空</td>\n<td>1. 目标方 <code>skills.uris</code> 为空 → 成功；<br />2. 目标方 <code>skills.uris</code> 存在「scheme 和 type 均空」的元素 → 成功；<br />3. 其他情况 → 失败</td>\n</tr>\n<tr>\n<td>场景2</td>\n<td>uri 非空 + type 空</td>\n<td>1. 目标方 <code>skills.uris</code> 为空 → 失败；<br />2. 目标方 <code>skills.uris</code> 存在「uri 匹配 + type 空」的元素 → 成功；<br />3. 前两步失败且 uri 为文件路径 → 按后缀推导 MIME 类型，匹配目标方 <code>type</code> → 成功/失败</td>\n</tr>\n<tr>\n<td>场景3</td>\n<td>uri 空 + type 非空</td>\n<td>1. 目标方 <code>skills.uris</code> 为空 → 失败；<br />2. 目标方 <code>skills.uris</code> 存在「scheme 空 + type 匹配」的元素 → 成功；<br />3. 其他情况 → 失败</td>\n</tr>\n<tr>\n<td>场景4</td>\n<td>uri 非空 + type 非空</td>\n<td>1. 目标方 <code>skills.uris</code> 为空 → 失败；<br />2. 目标方 <code>skills.uris</code> 存在「uri 匹配 + type 匹配」的元素 → 成功；<br />3. 其他情况 → 失败</td>\n</tr>\n</tbody>\n</table>\n<h6 id=\"type-单独匹配规则仅调用方-type-非空时生效\">Type 单独匹配规则（仅调用方 <code>type</code> 非空时生效）</h6>\n<p>Type 匹配核心为 <strong>MIME 媒体类型匹配</strong>，遵循 HarmonyOS 官方规范，无降级匹配逻辑，规则如下：</p>\n<ol>\n<li><strong>精准匹配（最高优先级）</strong>：调用方 <code>type</code> 与目标方 <code>skills.uris</code> 中 <code>type</code> 完全一致 → 匹配成功；</li>\n<li><strong>通配符匹配</strong>：仅支持「主类型/*」格式，目标方 <code>type</code> 为此格式且调用方 <code>type</code> 属于该主类型范畴 → 成功；不支持 <code>*/子类型</code> 格式；</li>\n<li><strong>匹配失败场景</strong>：\n<ul>\n<li>目标方 <code>type</code> 为具体值但与调用方 <code>type</code> 不一致；</li>\n<li>目标方 <code>type</code> 通配符格式不规范；</li>\n<li>调用方 <code>type</code> 为复合 MIME 类型，目标方无对应配置。</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>补充说明：Type 匹配仅在「调用方传递 type」且「进入 uri+type 协同校验环节」时触发；若目标方 <code>type</code> 为空，仅当调用方 <code>type</code> 也为空时匹配成功。</p>\n</blockquote>\n<h6 id=\"uri-匹配规则\">uri 匹配规则</h6>\n<p>URI 匹配以 <code>scheme → host → port → 路径</code> 为核心层级，仅当前一级匹配通过时触发下一级校验，任一层级失败则整体 URI 匹配失败，具体规则：</p>\n<ol>\n<li><strong>scheme 层级（首验层级）</strong>：\n<ul>\n<li>目标 URI 项 <code>scheme</code> 为空 → 仅调用方 <code>uri</code> 为空时匹配成功，否则失败；</li>\n<li>目标 URI 项 <code>scheme</code> 非空 → 调用方 <code>uri</code> 的 <code>scheme</code> 需与其完全一致（大小写敏感，官方建议全小写），否则失败。</li>\n</ul>\n</li>\n<li><strong>host 层级（仅 scheme 匹配成功后触发）</strong>：\n<ul>\n<li>目标 URI 项 <code>host</code> 为空 → 直接匹配成功；</li>\n<li>目标 URI 项 <code>host</code> 非空 → 调用方 <code>uri</code> 的 <code>host</code> 需与其完全一致，否则失败。</li>\n</ul>\n</li>\n<li><strong>port 层级（仅 scheme+host 匹配成功后触发）</strong>：\n<ul>\n<li>目标 URI 项 <code>port</code> 为空 → 直接匹配成功；</li>\n<li>目标 URI 项 <code>port</code> 非空 → 调用方 <code>uri</code> 的 <code>port</code> 需与其完全一致（数字格式），否则失败。</li>\n</ul>\n</li>\n<li><strong>路径层级（仅 scheme+host+port 匹配成功后触发）</strong>：<br />\n按 <code>path → pathStartWith → pathRegex</code> 优先级校验，任一规则匹配成功则终止校验，全部失败则 URI 匹配失败：\n<ul>\n<li><strong>path 精准匹配</strong>：目标 URI 项 <code>path</code> 非空 → 调用方 <code>uri</code> 全路径与其完全一致 → 成功，否则进入下一级；</li>\n<li><strong>pathStartWith 前缀匹配</strong>：目标 URI 项 <code>pathStartWith</code> 非空 → 调用方 <code>uri</code> 路径包含该前缀 → 成功，否则进入下一级；</li>\n<li><strong>pathRegex 正则匹配</strong>：目标 URI 项 <code>pathRegex</code> 非空 → 调用方 <code>uri</code> 路径符合该正则表达式 → 成功，否则 URI 匹配失败；</li>\n<li><strong>路径字段均为空</strong>：目标 URI 项 <code>path</code>、<code>pathStartWith</code>、<code>pathRegex</code> 均为空 → 直接匹配成功。</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>补充说明：</p>\n<ol>\n<li>最左 URI 匹配：仅当目标 URI 项仅配置 <code>scheme</code>/<code>scheme+host</code>/<code>scheme+host+port</code>（路径字段均为空）时生效，调用方 <code>uri</code> 需以目标配置为前缀；</li>\n<li>文件 URI 解析：<code>file://</code> 开头的 URI，系统自动解析文件后缀推导 MIME 类型，用于补充场景2的 type 匹配；</li>\n<li>URI 格式规范：自定义 <code>scheme</code> 不可与系统内置（<code>ohos</code>/<code>http</code>/<code>https</code>/<code>file</code>）重复。</li>\n</ol>\n</blockquote>\n<h4 id=\"4匹配结果说明\">（4）匹配结果说明</h4>\n<p>根据系统中待匹配应用组件的匹配情况不同，使用隐式 Want 启动应用组件时会出现以下三种情况：</p>\n<ul>\n<li>未匹配到满足条件的应用组件：启动失败。</li>\n<li>匹配到一个满足条件的应用组件：直接启动该应用组件。</li>\n<li>匹配到多个满足条件的应用组件（UIAbility）：弹出选择框让用户选择。</li>\n</ul>\n<h2 id=\"二本节工程\">二、本节工程</h2>\n<h3 id=\"一工程创建\">（一）工程创建</h3>\n<h4 id=\"1-调用方工程wantandlinkingdemo\">1. 调用方工程：WantAndLinkingDemo</h4>\n<ul>\n<li>基础配置：HarmonyOS 5.0+、API 18+、Stage 模型；</li>\n<li>核心用途：演示显式/隐式 Want 启动；</li>\n<li>包名：<code>com.example.wantandlinkingdemo</code>。</li>\n</ul>\n<h4 id=\"2-接收方工程implicitreceiverdemo\">2. 接收方工程：ImplicitReceiverDemo</h4>\n<ul>\n<li>基础配置：HarmonyOS 5.0+、API 18+、Stage 模型；</li>\n<li>核心用途：作为跨应用显式/隐式启动的目标应用，接收并展示传递的参数；</li>\n<li>包名：<code>com.example.implicitreceiverdemo</code>。</li>\n</ul>\n<h3 id=\"二调用方工程核心目录结构\">（二）调用方工程核心目录结构</h3>\n<pre><code>WantAndLinkingDemo/                  # 项目根目录（Want实战Demo）\n├─ AppScope/                        # 应用全局配置目录（多模块应用共享）\n│  ├─ resources/                    # 应用全局资源文件（如全局样式、多语言字符串）\n│  └─ app.json5                     # 应用级配置文件（应用名称、版本号等）\n├─ entry/                           # 主模块目录（核心代码所在）\n│  ├─ src/\n│  │  ├─ main/                      # 主代码目录（应用运行的核心代码）\n│  │  │  ├─ ets/                    # ArkTS代码目录（逻辑实现核心）\n│  │  │  │  ├─ entryability/        # 主Ability目录（应用入口）\n│  │  │  │  │  └─ EntryAbility.ets  # 应用入口Ability（处理启动初始化）\n│  │  │  │  └─ pages/               # 主Ability对应的页面目录\n│  │  │  │     └─ Index.ets          # 核心功能页（整合显式/隐式Want启动所有案例）\n│  │  │  ├─ resources/              # 模块级资源目录（页面布局、图片、局部样式）\n│  │  │  └─ module.json5            # 模块配置文件（核心！配置skills、exported等）\n│  ├─ build-profile.json5           # 模块构建配置文件（编译、打包参数）\n│  ├─ hvigorfile.ts                 # 模块构建脚本（hvigor构建任务配置）\n│  ├─ obfuscation-rules.txt         # 代码混淆规则文件（发布时加密代码，可选）\n│  └─ oh-package.json5              # 模块依赖配置文件（第三方库、工具依赖）\n</code></pre>\n<h3 id=\"三隐式显示拉起应用传参示例\">（三）隐式/显示拉起应用传参示例</h3>\n<h4 id=\"调用方wantandlinkingdemo-indexets\">调用方：WantAndLinkingDemo Index.ets</h4>\n<p>构造Want数据，演示显式/隐式不同模式拉起应用，通过不同匹配规则。</p>\n<pre><code class=\"language-javascript\">import { BusinessError } from '@ohos.base';\nimport { common, Want, wantConstant } from '@kit.AbilityKit';\nimport { hilog } from '@kit.PerformanceAnalysisKit';\nimport { promptAction } from '@kit.ArkUI';\n\nconst DOMAIN = 0xFF00;\nconst TAG = 'WantAndLinkingDemo';\n\n@Entry\n@Component\nstruct Index {\n  // 获取UIAbility上下文\n  private context = this.getUIContext().getHostContext() as common.UIAbilityContext;\n\n  build() {\n    Column({ space: 15 }) {\n      // 页面标题\n      Text('Want 显式/隐式启动实战（匹配规则修正版）')\n        .fontSize(30)\n        .fontWeight(FontWeight.Bold)\n        .margin({ bottom: 30 })\n\n      // 1. 显式Want（精准匹配，无规则问题）\n      Button('1. 显式Want跨应用拉起传参')\n        .width('80%')\n        .height(50)\n        .fontSize(18)\n        .backgroundColor('#1890ff')\n        .fontColor('#ffffff')\n        .onClick(() =&gt; {\n          this.crossAppExplicitStart();\n        })\n\n      // 2. 隐式Want - linkFeature（最高优先级，需精准匹配）\n      Button('2. 隐式Want-linkFeature匹配（最高优先级）')\n        .width('80%')\n        .height(50)\n        .fontSize(18)\n        .backgroundColor('#1890ff')\n        .fontColor('#ffffff')\n        .onClick(() =&gt; {\n          this.implicitStartShare();\n        })\n\n      // 3. 隐式Want - action单独匹配（核心：仅传action，无其他干扰字段）\n      Button('3. 隐式Want-action单独匹配')\n        .width('80%')\n        .height(50)\n        .fontSize(18)\n        .backgroundColor('#1890ff')\n        .fontColor('#ffffff')\n        .onClick(() =&gt; {\n          this.implicitStartActionMatch();\n        })\n\n      // 4. 隐式Want - entities单独匹配\n      Button('4. 隐式Want-entities单独匹配')\n        .width('80%')\n        .height(50)\n        .fontSize(18)\n        .backgroundColor('#1890ff')\n        .fontColor('#ffffff')\n        .onClick(() =&gt; {\n          this.implicitStartEntitiesMatch();\n        })\n\n      // 5. 隐式Want - uri+type协同匹配（核心：仅传uri+type，配通用action）\n      Button('5. 隐式Want-uri+type协同匹配')\n        .width('80%')\n        .height(50)\n        .fontSize(18)\n        .backgroundColor('#1890ff')\n        .fontColor('#ffffff')\n        .onClick(() =&gt; {\n          this.implicitStartUriTypeMatch();\n        })\n    }\n    .width('100%')\n    .height('100%')\n    .justifyContent(FlexAlign.Center)\n    .backgroundColor('#f5f5f5')\n  }\n\n  /**\n   * 场景1：显式Want\n   * 规则：指定bundleName+abilityName，无需匹配skills，仅需接收方设置 exported=true\n   */\n  private async crossAppExplicitStart() {\n    try {\n      const want: Want = {\n        bundleName: \"com.example.implicitreceiverdemo\", // 接收方包名（必须与实际一致）\n        abilityName: \"EntryAbility\", // 接收方组件名（必须与实际一致）\n        parameters: {\n          \"shareContent\": \"显式Want测试：跨应用精准传递内容\",\n          \"linkFeature\": \"Explicit\"\n        }\n      };\n\n      await this.context.startAbility(want);\n      hilog.info(DOMAIN, TAG, \"显式Want跨应用拉起成功\");\n    } catch (err) {\n      const businessErr = err as BusinessError;\n      promptAction.showToast({\n        message: `启动失败：${businessErr.message}`,\n        duration: 3000\n      });\n    }\n  }\n\n  /**\n   * 场景2：隐式Want - linkFeature（最高优先级）\n   * 规则：uri和type均为空时，仅校验linkFeature精准匹配\n   * 规则：uri或type不为空时，需同时满足linkFeature精准匹配 + uri的scheme匹配 + type精准匹配\n   */\n  private async implicitStartShare() {\n    const want: Want = {\n      uri: \"data://com.example.wantandlinkingdemo/share/text\", // scheme/host需匹配\n      type: \"text/plain\", // 必须精准匹配\n      parameters: {\n        shareContent: \"隐式Want测试：linkFeature匹配成功！\",\n        linkFeature: \"Share\" // 最高优先级，接收方必须精准配置\n      },\n    };\n\n    try {\n      await this.context.startAbility(want);\n      hilog.info(DOMAIN, TAG, \"隐式Want(linkFeature)跨应用拉起成功\");\n    } catch (error) {\n      const businessErr = error as BusinessError;\n      hilog.error(DOMAIN, TAG, `linkFeature匹配失败：${businessErr.message}`);\n      promptAction.showToast({\n        message: '启动失败，未匹配到支持分享的应用',\n        duration: 3000\n      });\n    }\n  }\n\n  /**\n   * 场景3：隐式Want - action单独匹配\n   * 规则：调用方action需匹配接收方skills中的action配置\n   */\n  private async implicitStartActionMatch() {\n    const want: Want = {\n      action: 'ohos.want.action.viewData',\n      parameters: {\n        \"shareContent\": \"隐式Want测试：action匹配成功！\",\n      }\n    };\n\n    try {\n      await this.context.startAbility(want);\n      hilog.info(DOMAIN, TAG, \"隐式Want(action)跨应用拉起成功\");\n    } catch (error) {\n      const businessErr = error as BusinessError;\n      hilog.error(DOMAIN, TAG, `action匹配失败：${businessErr.message}`);\n      promptAction.showToast({\n        message: '启动失败，未匹配到支持查看数据的应用',\n        duration: 3000\n      });\n    }\n  }\n  \n  /**\n   * 场景4：隐式Want - entities匹配\n   * entities匹配规则：调用方传递的所有entities值，需被目标方skills.entities完全包含才匹配成功（本示例为\"abc\"）\n   * 系统标准值参考：entity.system.browsable（浏览器类别，处理网页链接）、entity.system.home（应用主入口组件）\n   */\n  private async implicitStartEntitiesMatch() {\n    const want: Want = {\n      action: 'ohos.want.action.viewData', // 查看数据\n      entities: [\"abc\"],\n      parameters: {\n        \"shareContent\": \"隐式Want测试：entities匹配成功！\",\n      }\n    };\n\n    try {\n      await this.context.startAbility(want);\n      hilog.info(DOMAIN, TAG, \"隐式Want(entities)跨应用拉起成功\");\n    } catch (error) {\n      const businessErr = error as BusinessError;\n      hilog.error(DOMAIN, TAG, `entities匹配失败：${businessErr.message}`);\n      promptAction.showToast({\n        message: '启动失败，未匹配到浏览器类应用',\n        duration: 3000\n      });\n    }\n  }\n\n  /**\n   * 场景5：隐式Want - uri+type协同匹配\n   * 核心：需同时满足uri层级匹配（scheme→host→port→路径） + type精准匹配\n   */\n  private async implicitStartUriTypeMatch() {\n    const want: Want = {\n      action: 'ohos.want.action.viewData',\n      uri: \"data://com.implicitreceiverdemo:8080/detail/page123\",\n      type: \"text/plain\",\n      flags: wantConstant.Flags.FLAG_START_WITHOUT_TIPS // 取消失败弹窗提示\n    };\n\n    try {\n      await this.context.startAbility(want);\n      hilog.info(DOMAIN, TAG, \"隐式Want(uri+type)跨应用拉起成功\");\n    } catch (error) {\n      const businessErr = error as BusinessError;\n      hilog.error(DOMAIN, TAG, `uri+type匹配失败：${businessErr.message}`);\n      promptAction.showToast({\n        message: '启动失败，未匹配到符合uri+type规则的应用',\n        duration: 3000\n      });\n    }\n  }\n}\n</code></pre>\n<h5 id=\"2接收方implicitreceiverdemo\">（2）接收方：ImplicitReceiverDemo</h5>\n<p>跨应用接收调用方Want传递的参数（拉起组件内Ability接收参数同理，本节不做示例演示）</p>\n<pre><code class=\"language-javascript\">import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';\nimport { hilog } from '@kit.PerformanceAnalysisKit';\nimport { ConfigurationConstant } from '@kit.AbilityKit';\nimport { window } from '@kit.ArkUI';\n\nconst DOMAIN = 0x0000;\nconst TAG = 'ImplicitReceiverDemo';\n\nexport default class EntryAbility extends UIAbility {\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    hilog.info(DOMAIN, TAG, '%{public}s', 'ImplicitReceiverDemo onCreate 触发');\n    try {\n      // 解析 Want 中的参数（显式传递的 data + 隐式传递的 shareContent）\n      const parameters = want.parameters as Record&lt;string, Object&gt;;\n      // 存储参数到 AppStorage，供 UI 页面展示（默认值避免空显示）\n      AppStorage.setOrCreate(\"shareContent\", parameters[\"shareContent\"] || '未接收分享数据');\n\n      // 设置应用颜色模式（可选，保持系统默认）\n      this.context.getApplicationContext().setColorMode(ConfigurationConstant.ColorMode.COLOR_MODE_NOT_SET);\n    } catch (err) {\n      hilog.error(DOMAIN, TAG, 'Failed to set colorMode. Cause: %{public}s', JSON.stringify(err));\n    }\n  }\n\n  /**\n   * 已启动时接收新的 Want 参数（如隐式启动多次触发）\n   */\n  onNewWant(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    hilog.info(DOMAIN, TAG, '%{public}s', 'ImplicitReceiverDemo onNewWant 触发');\n    const parameters = want.parameters as Record&lt;string, Object&gt;;\n    // 更新参数（实时同步到 UI 页面）\n    AppStorage.setOrCreate(\"shareContent\", parameters[\"shareContent\"] || '未接收分享数据');\n    // 打印接收的参数\n    console.log(`ImplicitReceiverDemo 接收参数：${JSON.stringify(want.parameters)}`);\n  }\n\n  /**\n   * 加载 UI 页面\n   */\n  onWindowStageCreate(windowStage:  window.WindowStage): void {\n    windowStage.loadContent('pages/Index', (err) =&gt; {\n      if (err.code) {\n        hilog.error(DOMAIN, TAG, 'Failed to load the content. Cause: %{public}s', JSON.stringify(err));\n        return;\n      }\n      hilog.info(DOMAIN, TAG, 'Succeeded in loading the content: Index');\n    });\n  }\n}\n</code></pre>\n<h6 id=\"-接收方indexets展示跨应用接收的参数\">② 接收方：Index.ets（展示跨应用接收的参数）</h6>\n<pre><code class=\"language-javascript\">@Entry\n@Component\nstruct Index {\n  @StorageProp('shareContent') shareContent: string = '隐式/显式分享数据未接收';\n\n  build() {\n    Column({ space: 20 }) {\n      Text('ImplicitReceiverDemo（参数接收）')\n        .fontSize(25)\n        .fontWeight(FontWeight.Bold)\n        .margin({ bottom: 10 })\n\n      Text(`接收的内容：${this.shareContent}`)\n        .fontColor(Color.Red)\n        .fontSize(18)\n        .textWrap(true)\n        .padding(10)\n    }.justifyContent(FlexAlign.Center)\n    .height('100%')\n    .width('100%')\n    .padding(20)\n  }\n}\n</code></pre>\n<h6 id=\"-接收方modulejson5配置\">③ 接收方：module.json5配置</h6>\n<pre><code class=\"language-json\">{\n  \"module\": {\n    \"name\": \"entry\",\n    \"type\": \"entry\",\n    \"description\": \"$string:module_desc\",\n    \"mainElement\": \"EntryAbility\",\n    \"deviceTypes\": [\n      \"phone\"\n    ],\n    \"deliveryWithInstall\": true,\n    \"installationFree\": false,\n    \"pages\": \"$profile:main_pages\",\n    \"abilities\": [\n      {\n        \"name\": \"EntryAbility\",\n        \"srcEntry\": \"./ets/entryability/EntryAbility.ets\",\n        \"description\": \"$string:EntryAbility_desc\",\n        \"icon\": \"$media:layered_image\",\n        \"label\": \"$string:EntryAbility_label\",\n        \"startWindowIcon\": \"$media:startIcon\",\n        \"startWindowBackground\": \"$color:start_window_background\",\n        \"exported\": true, // 必须开启：允许外部应用调用（显式/隐式均需）\n        \"skills\": [\n          {\n            // 基础技能：桌面应用（默认配置）\n            \"entities\": [\"entity.system.home\"],\n            \"actions\": [\"ohos.want.action.home\"]\n          },\n          // 场景2：linkFeature匹配规则\n          {\n            \"uris\": [\n              {\n                \"scheme\": \"data\",\n                \"host\": \"com.example.wantandlinkingdemo\",\n                \"type\": \"text/plain\",\n                \"linkFeature\": \"Share\"\n              }\n            ]\n          },\n          // 场景3：action单独匹配规则\n          {\n            \"actions\": [\"ohos.want.action.viewData\"]\n          },\n          // 场景4：entities单独匹配规则\n          {\n            \"actions\": [\"ohos.want.action.viewData\"],\n            \"entities\": [\"abc\"]\n          },\n          // 场景5：uri+type协同匹配规则\n          {\n            \"actions\": [\"ohos.want.action.viewData\"],\n            \"uris\": [\n              {\n                \"scheme\": \"data\",                   // 协议必须完全一致\n                \"host\": \"com.implicitreceiverdemo\", // 域名需完整匹配\n                \"port\": \"8080\",                     // 端口不可省略\n                \"path\": \"detail/page123\",            // 路径需完全一致或使用通配符\n                \"type\": \"text/plain\"                // MIME类型需严格匹配\n              }\n            ]\n          }\n        ]\n      }\n    ],\n    \"extensionAbilities\": [\n      {\n        \"name\": \"EntryBackupAbility\",\n        \"srcEntry\": \"./ets/entrybackupability/EntryBackupAbility.ets\",\n        \"type\": \"backup\",\n        \"exported\": false,\n        \"metadata\": [\n          {\n            \"name\": \"ohos.extension.backup\",\n            \"resource\": \"$profile:backup_config\"\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre>\n<h4 id=\"运行结果\">运行结果</h4>\n<p><img alt=\"Want显式隐式拉起应用\" class=\"lazyload\" /></p>\n<p><img alt=\"Want显式/隐式拉起应用\" class=\"lazyload\" /></p>\n<h2 id=\"四开发核心规范与避坑指南\">四、开发核心规范与避坑指南</h2>\n<h3 id=\"1-核心约束\">1. 核心约束</h3>\n<ul>\n<li>所有对外提供调用的 Ability（显式/隐式），必须在 <code>module.json5</code> 中配置 <code>exported: true</code>，否则无法被外部调用；</li>\n<li>自定义 scheme 不可与系统内置 scheme（如 <code>ohos</code>、<code>http</code>、<code>https</code>、<code>file</code>）重复，建议采用“应用标识+功能”命名（如 <code>harmonydemo</code>）；</li>\n<li>隐式 Want 若使用 <code>linkFeature</code> 匹配，<code>actions</code> 字段可忽略；使用 <code>action/entities/uri+type</code> 匹配时，对应字段不可为空。</li>\n</ul>\n<h3 id=\"2-避坑指南\">2. 避坑指南</h3>\n<table>\n<thead>\n<tr>\n<th>问题现象</th>\n<th>排查/解决方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>隐式启动匹配失败</td>\n<td>检查 <code>linkFeature</code>、<code>action</code>、<code>entities</code>、<code>uri</code>、<code>type</code> 是否与接收方配置一致，尤其是 <code>scheme</code>、<code>host</code> 大小写（建议全小写）；</td>\n</tr>\n<tr>\n<td>参数传递失败</td>\n<td>确保传递的参数为基础数据类型（避免传递复杂对象），接收方通过 <code>want.parameters</code> 解析时需做类型断言；</td>\n</tr>\n<tr>\n<td>跨应用显式启动失败</td>\n<td>确认目标应用已安装、<code>bundleName</code> 和 <code>abilityName</code> 配置正确，且目标 Ability 已设置 <code>exported: true</code>；</td>\n</tr>\n<tr>\n<td>uri 匹配失败</td>\n<td>按 <code>scheme→host→port→路径</code> 层级逐一校验，路径匹配优先精准匹配，前缀/正则匹配需确保规则正确。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"五内容总结\">五、内容总结</h2>\n<ol>\n<li>核心载体：Want 是组件间通信的核心载体，显式 Want 用于跨应用精准启动，隐式 Want 用于跨应用通用功能调用；</li>\n<li>隐式匹配规则：按 <code>linkFeature→action→entities→uri+type</code> 优先级校验，前序字段匹配失败则整体失败，所有参与匹配的字段均为精准匹配（uri路径除外）；</li>\n<li>配置关键：对外调用的 Ability 需设 <code>exported: true</code>，隐式启动需保证调用方 Want 字段与接收方 <code>skills</code> 配置完全一致；</li>\n<li>实践原则：按场景选择匹配规则，重视异常处理和用户体验，遵循 API 12+ 规范（优先使用应用链接替代显式 Want）。</li>\n</ol>\n<h2 id=\"六代码仓库\">六、代码仓库</h2>\n<ul>\n<li>调用方工程：WantAndLinkingDemo</li>\n<li>接收方工程：ImplicitReceiverDemo</li>\n<li>仓库地址：<a href=\"https://gitee.com/HarmonyOS-UI-Basics/harmony-os-ui-basics.git\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/HarmonyOS-UI-Basics/harmony-os-ui-basics.git</a></li>\n</ul>\n<h2 id=\"七下节预告\">七、下节预告</h2>\n<p>下一节我们将学习 <strong>Deep Linking 与 App Linking 应用链接</strong> 的完整配置与调用，重点包括：</p>\n<ol>\n<li>掌握 Deep Linking 自定义 scheme 配置、<code>openLink</code> 调用及 <code>canOpenLink</code> 校验；</li>\n<li>掌握 App Linking HTTPS 域名配置、域名校验、参数解析及未安装应用的降级处理；</li>\n<li>明晰 Deep Linking 与 App Linking 的安全性、适用场景核心差异，能按需选型；</li>\n<li>掌握应用链接与 Want 结合的最佳实践，实现跨应用通信的解耦与高安全性。</li>\n</ol>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-12 11:41</span>&nbsp;\n<a href=\"https://www.cnblogs.com/san-xiu\">鸿蒙-散修</a>&nbsp;\n阅读(<span id=\"post_view_count\">5</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "认识区块链和比特币（一）：余额与小票",
      "link": "https://www.cnblogs.com/ofnoname/p/19592966",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ofnoname/p/19592966\" id=\"cb_post_title_url\" title=\"发布于 2026-02-12 11:07\">\n    <span>认识区块链和比特币（一）：余额与小票</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>这篇文章不谈价格涨跌和投资讨论。只做一件事：把比特币的基本原理讲清楚。读完你应该能看懂区块浏览器里一笔交易的“输入/输出”，能理解为什么在没有银行的情况下，比特币也能维护余额和支付。</p>\n<p>需要的前置知识不多，你只需要了解三件基础概念即可：<strong>公钥/私钥与数字签名（私钥像“签名章”，用来证明你有权花钱）</strong>、<strong>哈希（像数据指纹）</strong>、以及<strong>分布式系统的入门概念</strong>。这不是密码学课程，所以我们不会推导数学证明，只用直觉和例子把机制讲明白。</p>\n<h2 id=\"比特币是什么\">比特币是什么？</h2>\n<p>在完整理解<strong>比特币是一个去中心化的账本/交易数据库/支付系统</strong>之前，你可以先把比特币当成：<strong>一份公开的、全网同步的“历史记录”</strong>，上面只写两类信息——“哪些钱还没被花掉”和“这些钱未来需要满足什么条件才允许被花”。任何人都可以保存一份副本（运行节点），并用同一套公开规则检查：新来的记录有没有作弊、有没有双花、有没有伪造签名。它不像银行系统那样由某个机构维护“账户余额表”，更像一个班级共同维护的共享记账本：没有班长能单方面改分数，每个人都可以拿规则对照检查。不过这个“共享账本为什么不会乱、为什么最后大家能收敛到同一份版本、为什么有人愿意付出成本来维护它”，要到后面讲完网络规则与挖矿机制后，你才会彻底吃透——而今天我们先从最底层的“钱的形态”开始：UTXO。</p>\n<h2 id=\"比特币与区块链的关系\">比特币与区块链的关系</h2>\n<p><strong>区块链（blockchain）</strong>：从字面上看就是“区块组成的链”。它是一种数据组织方式：把一批记录打包成“区块”，再用哈希把新区块和前一个区块链接起来，让历史记录更难被悄悄篡改。你可以把它理解为一种“按时间顺序装订成册、每页都盖了前一页指纹”的账本结构。</p>\n<p>而 <strong>比特币（Bitcoin）</strong>：是一套运行在互联网上的系统（协议 + 软件 + 节点网络 + 规则），它<strong>用区块链来保存交易历史</strong>，并用一套公开规则让全网在“哪些交易有效、哪些区块算数”上达成一致。换句话说：<strong>区块链是比特币使用的一种账本结构，但比特币不仅仅是区块链</strong>——它还有交易格式、验证规则、网络传播、挖矿激励等一整套机制。在比特币系统里，词语 <strong>比特币（bitcoin / BTC）</strong>：这个词也是这个系统里的“记账单位/资产”。</p>\n<p>比特币是区块链思想最早的大规模成功落地之一，因此影响力最大、生态最成熟；但区块链后来被许多系统采用并拓展了用途（不止做转账，还尝试做更通用的“可验证记录”），如<strong>以太坊（Ethereum）</strong>。同时也出现了大量基于比特币技术理念衍生出来的其他币种与系统，如<strong>莱特币（Litecoin）</strong>、<strong>门罗币（Monero）</strong>。</p>\n<h2 id=\"utxo比特币里的钱\">UTXO：比特币里的“钱”</h2>\n<p>在比特币里，“你有多少钱”不是写在某张<strong>账户余额表</strong>上，而是散落在账本历史里的一堆“小票”。这些小票的正式名字叫：</p>\n<p><strong>UTXO（Unspent Transaction Output，未花费交易输出）</strong>：一笔交易产生的每个“输出（output）”，只要还没有被后续交易花掉，就处于“未花费”状态，它就是一个 UTXO。</p>\n<p>所以钱包里显示的“余额”，本质上是：</p>\n<blockquote>\n<p><strong>你所控制的私钥，能够解锁的一组 UTXO 的总和。</strong></p>\n</blockquote>\n<p>这里有一个非常关键但容易忽略的点：UTXO 不是“记在你名下的余额”，而是“带着使用条件的价值片段”。这份“使用条件”通常会指向某个公钥哈希（也就是我们日常看到的“地址”），意思是：<strong>未来想花这笔钱的人，必须拿出能满足条件的证明（通常就是签名）</strong>。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1545207/202602/1545207-20260212111529650-1331403071.png\" /></p>\n<h3 id=\"utxo-里到底包含了什么\">UTXO 里到底包含了什么</h3>\n<p>把 UTXO 当成“小票”，这张小票上至少写了两样最重要的东西：</p>\n<ol>\n<li><strong>金额（value）</strong>：比如 0.5 BTC</li>\n<li><strong>锁定条件（locking condition）</strong>：例如“能提供某个公钥对应的有效签名的人才能花”（在这个场景下，可以简单类比普通支付系统，理解为“钱属于谁”）。</li>\n</ol>\n<h3 id=\"utxo-从哪里来交易输出如何变成可花的小票\">UTXO 从哪里来：交易输出如何变成“可花的小票”</h3>\n<p>UTXO 的来源非常朴素：<strong>每一笔交易的每一个输出，都有可能变成未来的 UTXO</strong>。</p>\n<p>举个最简单的“收款”场景：</p>\n<ul>\n<li>\n<p>小明拥有自己的公钥和私钥，他把自己的公钥（即收款地址）给小红</p>\n</li>\n<li>\n<p>小红生成一笔交易，在交易里写一个输出：</p>\n<ul>\n<li>金额：0.5 BTC</li>\n<li>锁定条件：只能由“小明的公钥”对应的私钥花掉</li>\n</ul>\n</li>\n<li>\n<p>这笔交易一旦被网络接受并最终写进区块链历史里，这个输出就成了一个 UTXO</p>\n</li>\n<li>\n<p>小明的钱包之所以“看到余额增加”，是因为它扫描网络历史记录时发现：“有一张新的小票锁给我，而且还没被花掉”。钱包并不是从“某个中心服务器”读取余额，而是在本地（或通过服务）根据历史记录推导“哪些 UTXO 属于我”。之后，小明也可以花掉这个 UTXO（也只有他可以花，因为只有他有收款公钥对应的私钥）。</p>\n</li>\n</ul>\n<h2 id=\"utxo-的花费和找零\">UTXO 的花费和找零</h2>\n<p>你不能“从一个 UTXO 里只花一部分”。花它的方式只有一种：整张用掉。相比微信支付，这其实更类似现金支付：你用一张 100 去买 30 的东西，收银台不会“把纸币剪掉 30”，而是收走 100，再找你 70。</p>\n<p>比特币交易也是同样的逻辑：</p>\n<ul>\n<li><strong>输入（inputs）</strong>：你这次准备“用掉”的若干张旧小票（旧 UTXO）</li>\n<li><strong>输出（outputs）</strong>：这次交易“新生成”的若干张新小票（新的 UTXO）</li>\n</ul>\n<p>一个典型的简单支付几乎总会出现两个输出：</p>\n<ol>\n<li><strong>给收款人</strong>：比如给小红 0.7 BTC（锁给小红的条件）</li>\n<li><strong>找零给自己</strong>：比如找回 0.399 BTC（锁给小明自己的另一个地址）</li>\n</ol>\n<p>绝大多数时候，一笔支付总会有找零。你在区块浏览器里看到“一笔交易输出 2 个”时，十有八九就是“付款 + 找零”。</p>\n<p><img alt=\"典型的 UTXO 交易链条\" src=\"https://img2024.cnblogs.com/blog/1545207/202602/1545207-20260212104533493-1727523767.png\" /></p>\n<h3 id=\"手续费\">手续费</h3>\n<p>一笔支付合法的基本逻辑是：<strong>输入金额总和 &gt;= 输出金额总和</strong>，即你不能多花，当然你可以少花（不过没人会主动把自己的钱丢了）。</p>\n<p>更多的时候，输入输出的金额差被作为<strong>手续费</strong>。</p>\n<blockquote>\n<p><strong>手续费 = 输入金额总和 − 输出金额总和</strong></p>\n</blockquote>\n<p>它不是写在某个“手续费字段”里，而是由差额自然形成的。</p>\n<ul>\n<li>\n<p>小明手里有两张 UTXO：0.6 BTC 和 0.5 BTC（共 1.1 BTC）</p>\n</li>\n<li>\n<p>小明要付给小红 0.7 BTC</p>\n</li>\n<li>\n<p>小明创建交易：</p>\n<ul>\n<li>输入：0.6 + 0.5</li>\n<li>输出：0.7 给小红 + 0.399 给自己</li>\n</ul>\n</li>\n<li>\n<p>输入总额 1.1，输出总额 1.099，差额 0.001 BTC</p>\n</li>\n<li>\n<p>这 0.001 BTC 就是手续费。<strong>手续费本质上就是“你少找回来的那点零钱”</strong>。</p>\n</li>\n</ul>\n<p>为什么不全部找零给自己，而是要留一些手续费呢？这类似于现实消费的交税。留出一些钱作为交易费可以让矿工更愿意打包这次交易，有利于维护整个比特币网络的运行。</p>\n<h3 id=\"防双花节点维护-utxo-set\">防“双花”：节点维护 UTXO Set</h3>\n<p>没有银行，谁来防止同一笔钱被花两次？</p>\n<p>每个全节点都在检查各个想被确认的交易的合法性，<strong>都在维护一份“当前（所有人）仍然未花费的小票清单”——UTXO Set。</strong></p>\n<p>当节点收到一笔新交易时，它做的核心检查之一就是：</p>\n<ol>\n<li>这笔交易引用的每一个输入，对应的那张旧小票（旧 UTXO）真的存在吗？</li>\n<li>它还在 UTXO Set 里吗？（如果不在，说明早就被花过了，或者压根不存在）</li>\n<li>你是否提供了满足锁定条件的证明（签名等）？</li>\n<li>金额是否正确？（不能多花）</li>\n</ol>\n<p>一旦这笔交易被接受并最终进入区块，节点就会更新自己的 UTXO Set：</p>\n<ul>\n<li>把被花掉的旧 UTXO 从集合里移除</li>\n<li>把交易新产生的 outputs 加进集合里</li>\n</ul>\n<p>这里没有任何“中心裁判”。每个节点都在做同一套确定性的检查，所以“双花”不是靠“相信某个机构”解决的，而是靠“所有人按规则验算”解决的。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1545207/202602/1545207-20260212105542420-446956606.png\" /></p>\n<p>一个 UTXO 只能花费一次，因此有了交易 2 后，交易 3 就是非法的，不能被确认了（除非你直接丢弃交易 2，切换到交易 3）。</p>\n<h2 id=\"utxo-vs-余额账本\">UTXO vs 余额账本</h2>\n<p>通常理解的支付系统（包括银行、支付宝/微信）更像“账户模型”：维护一张表，写着“张三余额 100”。转账时就是把一个账户减、另一个账户加。</p>\n<p>比特币不这么做。它更像“票据模型”：账本不写“你有多少钱”，而是写“哪些票据还没用掉，以及每张票据的使用条件”。所谓“余额”，是你把“自己能解锁的所有未花费票据（UTXO）”加总出来的结果。</p>\n<p>这两种模型并没有绝对优劣，但对理解比特币来说很关键：</p>\n<ul>\n<li>\n<p>在账户模型里，“余额”是系统的显式字段；</p>\n</li>\n<li>\n<p>在 UTXO 模型里，“余额”是从历史记录推导出来的（因此钱包需要扫描/同步/索引）。</p>\n</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1545207/202602/1545207-20260212110631731-1587525664.png\" /></p>\n<h3 id=\"影响一utxo-越碎花钱越重\">影响一：UTXO 越碎，花钱越“重”</h3>\n<p>UTXO 模型有个很现实的副作用：如果你的 UTXO 很碎，付款时可能需要拼很多张“小票”。而每多用一个输入，就要在交易里多写一段“我引用的是哪张旧票据 + 我如何解锁它”的数据，交易体积通常会变大。体积变大，矿工打包的成本也更高，于是你往往需要付更高的手续费，交易才更容易被尽快确认。</p>\n<p>所以同样是“转 0.7 BTC”，有时你只需要 1 个输入（恰好有一张 0.7 的票据），有时却需要 10 个输入（十张 0.07 的碎票据）。<br />\n这就是为什么很多钱包会在合适的时候做“合并 UTXO”（把多张碎票据整合成更少的、面额更合适的票据），从体验上看就像“整理零钱”。</p>\n<h3 id=\"影响二隐私线索\">影响二：隐私线索</h3>\n<p>绝大多数交易都会存在找零。一笔“付款”常常会有两个输出——给对方 + 找零给自己。现实里这是常识，但在链上它会变成线索：旁观者可以尝试猜测哪个输出是找零，从而把多笔交易串成“同一个人/同一钱包”的行为轨迹。</p>\n<p>早期钱包之所以倾向于把找零打到一个“新地址”，部分原因就是为了减少“把所有行为都绑在同一个地址上”的明显痕迹——但注意，这并不等于真正匿名：交易本身是公开可查的，地址之间仍可能被启发式规则关联。因此，比特币的\"匿名与安全\"并不能让人高枕无忧。他更像“假名制”而不是“匿名制”：你不写姓名，但你写了可被分析的行为轨迹。其中的攻防逻辑门道很深，这里不讲。</p>\n<h2 id=\"查看一个典型的-utxo\">查看一个典型的 UTXO</h2>\n<p>有很多网站都可以查看比特币主链的信息。以 <a href=\"https://mempool.space\" rel=\"noopener nofollow\" target=\"_blank\">mempool.space</a> 为例子：</p>\n<p>我们随意选择一个已经确认的区块。向下滚动，就可以看到本区块确认的所有交易，每个交易引用一个或多个 UTXO，并生成新的 UTXO：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1545207/202602/1545207-20260211214405360-554665115.png\" /></p>\n<p>上图中我随手截取了两笔交易（上、下各一笔）。</p>\n<p>先看第一笔交易（交易哈希以 <code>fb2628a7…</code> 开头）。它只有 <strong>1 个输入</strong>：来自地址 <code>bc1qvtdvv…zdd70msz</code>，金额 0.03382740 BTC。这表示：此前账本里存在一张面额 0.03382740 BTC、锁给这个地址的“旧小票”，现在被这笔交易整张用掉了。然后它生成了 2 个输出：一个输出转到地址 <code>3NCU3KvX…W5tm3</code>，金额 0.00089565 BTC；另一个输出又回到了 <code>bc1qvtdvv…zdd70msz</code>，金额 0.03229910 BTC。这就是典型的“<strong>付款 + 找零</strong>”：前者是付给对方的金额，后者是找回给自己的零钱。页面右下角蓝色框显示这笔交易的 输出总额为 0.03319475 BTC（也就是两笔输出相加）。</p>\n<p>这笔交易的手续费：输入是 0.03382740，输出是 0.03319475，相减得到 0.00063265 BTC，换算成 satoshi 就是 63,265 sats（BTC 是比特币，而 Satoshi 是比特币系统的最小单位，1 BTC 等于 1亿 Satoshi）。交易里手续费往往不是一个单独的字段，而是由“少找回来的零钱”自然形成的。</p>\n<p>再看第二笔交易（交易哈希以 <code>d9195032…</code> 开头）。它有 2 个输入，而且两张旧小票都来自同一个地址 <code>bc1qvtdvv…zdd70msz</code>，金额分别是 0.00003777 BTC 和 0.00642833 BTC。两张加起来输入总额是 0.00646610 BTC。它同样产生了 2 个输出：一个输出到 <code>bc1qzgqf…njp90rhl</code>，金额 0.00004840 BTC（这是付款）；另一个输出回 <code>bc1qvtdvv…zdd70msz</code>，金额 0.00578845 BTC（这显然是找零）。输出总额 0.00583685 BTC（页面右下蓝框），因此手续费就是 0.00646610 − 0.00583685 = 0.00062925 BTC = 62,925 sats。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-12 11:07</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ofnoname\">Ofnoname</a>&nbsp;\n阅读(<span id=\"post_view_count\">38</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "扣子Coze实战：1分钟生成100篇爆款小红书养生笔记",
      "link": "https://www.cnblogs.com/tangshiye/p/19607340",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/tangshiye/p/19607340\" id=\"cb_post_title_url\" title=\"发布于 2026-02-12 10:44\">\n    <span>扣子Coze实战：1分钟生成100篇爆款小红书养生笔记</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>大家好，我是汤师爷，专注AI智能体分享，致力于帮助100W人用智能体创富~</p>\n<p>今天我要分享一个超实用的健康养生图文 Coze 工作流。</p>\n<p>只需输入一个简单的养生主题（比如湿气重吃什么好，或秋季养生食谱），智能体就能立刻为你生成一套包含10条专业养生知识点的内容，每条都配有精美插画，让你的养生号运营效率提升10倍！</p>\n<p>不再需要花时间查资料、找配图、排版了。</p>\n<p>这套工作流特别适合健康养生、医疗保健类自媒体创作者，尤其是在小红书、抖音、公众号等平台发布内容的朋友们。</p>\n<p>它能大大提升你的创作效率和内容质量，让你轻松实现日更甚至一日多更。</p>\n<p>最重要的是，生成的内容既专业又符合平台调性，很多测试用户反馈说，使用这套工作流后，互动量提升了50%以上！</p>\n<p>我们先来看看效果：</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<h2 id=\"1-工作流整体流程\">1. 工作流整体流程</h2>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<ol>\n<li>用户输入养生主题：用户只需输入一个养生主题，如\"湿气越吃越少10种食物\"</li>\n<li>AI生成专业养生内容：AI大模型自动生成10条专业的养生知识点，每条包含名称和详细说明</li>\n<li>批量生成精美配图：为每个养生知识点自动生成温暖治愈系插画，并进行背景透明化处理</li>\n<li>排版成精美图文：将生成的内容和图片组合成精美的图文内容，适合在小红书等平台发布</li>\n<li>转换为小红书风格：将专业内容转换为符合小红书等平台调性的文案，自动添加emoji表情</li>\n</ol>\n<h2 id=\"2-详细工作流节点\">2. 详细工作流节点</h2>\n<h3 id=\"21-开始节点\">2.1 开始节点</h3>\n<p>开始节点只需要1个输入变量：</p>\n<ul>\n<li>输入：养生主题（例如：湿气越吃越少10种食物）</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<h3 id=\"22-大模型内容生成\">2.2 大模型内容生成</h3>\n<p>这个节点使用DeepSeek-R1大模型，根据用户提供的主题自动生成健康养生内容。</p>\n<p>大模型节点配置：</p>\n<ul>\n<li>输入\n<ul>\n<li>topic：开始 - input（用户输入的主题）</li>\n</ul>\n</li>\n<li>系统提示词：设定AI扮演健康养生专家角色，根据主题生成养生内容</li>\n</ul>\n<pre><code class=\"language-json\"># 角色\n你是一个健康养生专家，你可以根据用户提供的【主题】自动生成健康养生的文案。\n\n例如：用户提供的主题是：湿气越吃越少10种食物。\n\n生成的内容以json格式输出，示例如下：\n\n===示例文案开始===\n[\n  {\n    \"name\": \"紫苏\",\n    \"description\": \"紫苏被称为'纯阳之草'，适合夏日食用，促进人体气血流通，赶走湿寒。\"\n  },\n  {\n    \"name\": \"绿豆\",\n    \"description\": \"绿豆具有清热解毒、利尿消肿的作用，可以帮助身体排出多余的水分和湿气。\"\n  },\n  {\n    \"name\": \"生姜\",\n    \"description\": \"生姜具有温中散寒、解表发汗的运用，能帮助人体排除寒湿之气，可以作为食材烹饪，也可以泡脚，祛湿效果好。\"\n  },\n  {\n    \"name\": \"陈皮\",\n    \"description\": \"陈皮具有理气健脾、燥湿化痰的功效，能促进体内湿气的运化和排出，泡水煲汤皆可，泡脚也可以添加。\"\n  },\n  {\n    \"name\": \"花椒\",\n    \"description\": \"花椒有排寒祛湿、杀菌消炎的运用。除了日常调味，也可泡水，泡脚加一些也对身体大有益处。\"\n  },\n  {\n    \"name\": \"山药\",\n    \"description\": \"山药是中药里的上品，滋阴利湿，健脾补肾。山药可以炖汤、煮粥，也可以炒菜。\"\n  },\n  {\n    \"name\": \"冬瓜\",\n    \"description\": \"冬瓜有利水、消肿、清热的作用，是果蔬里祛湿的佳品。冬瓜炒山药、冬瓜汤等都是很好的选择。\"\n  },\n  {\n    \"name\": \"苹果\",\n    \"description\": \"常吃苹果有助于调整身体代谢，有利于湿气排出。\"\n  },\n  {\n    \"name\": \"薏米\",\n    \"description\": \"薏米在中药里称为'薏苡仁'，它可以治湿痹，利肠胃，消水肿，健脾益胃。薏米和红豆一起煮粥，是经典的祛湿食谱。\"\n  },\n  {\n    \"name\": \"苦瓜\",\n    \"description\": \"苦瓜具有清热解毒、利尿消肿的作用，对于湿气重的人来说，适量食用苦瓜有助于减少湿气。\"\n  }\n]\n===示例文案结束===\n</code></pre>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<ul>\n<li>输出：\n<ul>\n<li>output：JSON格式，包含name（名称）和description（详细说明）两个字段</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<h3 id=\"23-文字优化节点\">2.3 文字优化节点</h3>\n<p>这个节点使用豆包大模型，根据健康养生内容转换为符合小红书调性的文字。</p>\n<p>大模型节点配置：</p>\n<ul>\n<li>输入\n<ul>\n<li>input：大模型 - output</li>\n</ul>\n</li>\n<li>系统提示词：</li>\n</ul>\n<pre><code class=\"language-markdown\">请把{{input}}json格式的内容转换为符合小红书调性的文字，文字中需根据语境添加Emoji表情，例如⛽⚓⛵⛴✈，书写案例如下：\n\n最让身体舒服的十个简单养生小动作🧐\n大家好呀！今天贺贺来分享十个简单有趣的养生小动作，每天只要十分钟，就能让身体舒舒服服的～\n\t\n①肾最喜欢踮脚\n◇中医认为足少阴肾经起于足底，踮脚可以刺激肾经上的穴位，调节肾脏气🩸，激发人体阳气。\n◇可早晚各踮一次脚，尽量抬高再缓慢放下，每次做50次，脚底发热即可。\n\t\n②头最喜欢梳头\n◇梳头可以刺激穴位，起到疏通经络、调节气🩸的作用，也能缓解疲劳和精神压力。\n◇从发际线开始，向后梳至颈部，然后再从两侧梳向头顶，每次可梳50次。\n\t\n③肝最喜欢伸懒腰\n◇伸懒腰可以通过促进🩸液循环，减少肝气郁结，有助于肝脏🩸液供应。\n◇也能缓解头晕、乏力，释放压力，拉伸肌肉和关节等。\n\t\n④胆最喜欢敲胆经\n◇敲胆经有助于疏泄肝胆之气，调节肝胆的功能，保证消化吸收，预防胆结石和脂肪肝。\n◇大腿外侧，屁股到膝盖这段，随时都能敲，两边各敲50次。\n\t\n⑤胃最喜欢揉肚子\n◇揉肚子有助于加快消化速度，减少食物在胃中的停留时间，降低消化不良和胃胀的风险。\n◇可以选择在空腹或饭后半小时，每次揉10~15分钟即可。\n\t\n⑥肺最喜欢深呼吸\n◇深呼吸能让身体自然地进入一种较为松弛的状态，缓解紧张的肌肉，减轻身体的疲劳感，也能提高肺功能。\n◇日常可以随时进行深呼吸，每次5~10次左右。\n\t\n⑦脾最喜欢拍腹股沟\n◇腹股沟是脾经循环部位，拍打腹股沟能疏通经络，促进脾的运化作用，祛除体内痰湿。\n◇每日早晚用手拍打50~100次左右。\n\t\n⑧心最喜欢拍肘窝\n◇拍打肘窝可以刺激心经和心包经，维持心脏气🩸平衡，使心脏更高效地工作，降低心脏疲劳和受损的风险。\n◇每天双手交替拍打50次。\n\t\n⑨眼睛最喜欢转圈\n◇转眼球可以活动眼球周围的肌肉，保护视力，缓解眼睛疲劳，减少眼部疾病的发生风险。\n◇每天可以进行2~3次转眼球练习，每次顺时针逆时针各30次。\n\t\n⑩耳朵最喜欢鸣天鼓\n◇鸣天鼓对于一些耳部不适症状，如耳鸣、耳闷、听力下降等有一定的缓解作用，也能减轻耳部的充🩸和水肿。\n◇两手掌心紧按两耳，食指、中指和无名指分别敲击脑后枕骨20~30次。\n</code></pre>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<h3 id=\"24-批量处理节点\">2.4 批量处理节点</h3>\n<p>批量处理节点负责将生成的养生内容列表拆分，为每个养生项目生成独立的图片。</p>\n<p>批量处理配置：</p>\n<ul>\n<li>批量大小：100（最多处理100个项目）</li>\n<li>并发大小：3（同时处理3个任务）</li>\n<li>输入：大模型节点输出的养生内容列表</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<h3 id=\"25-图像生成节点\">2.5 图像生成节点</h3>\n<p>在批处理内部，图像生成节点为每个养生项目生成精美插画。</p>\n<p>图像生成节点配置：</p>\n<ul>\n<li>输入：批量处理节点传入的养生项目名称</li>\n<li>图像尺寸：1024×1024</li>\n<li>模型：通用pro</li>\n<li>提示词模板：</li>\n</ul>\n<pre><code class=\"language-markdown\">根据{{prompt}}生成一个只有主体图案的内容，温暖治愈系插画，图像的主题位于一个正方形中央，背景留白。\n</code></pre>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<h3 id=\"26-抠图节点\">2.6 抠图节点</h3>\n<p>为了让生成的图片更加精美，使用抠图插件将图像主体提取出来，去除背景。</p>\n<p>抠图节点配置：</p>\n<ul>\n<li>输入：图像生成节点的输出</li>\n<li>输出模式：透明背景图</li>\n<li>产物尺寸：抠图结果尺寸</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<h3 id=\"27-画板节点\">2.7 画板节点</h3>\n<p>画板节点将抠好的图片和养生内容文字组合在一起，形成精美的图文卡片。</p>\n<p>画板节点配置：</p>\n<ul>\n<li>输入：\n<ul>\n<li>subject：主题</li>\n<li>description：养生项目描述</li>\n<li>image：抠图后的透明背景图</li>\n<li>name：养生项目名称</li>\n</ul>\n</li>\n<li>画板尺寸：1080×1920（适合手机屏幕竖向浏览）</li>\n<li>布局：顶部显示主题，中间是图片，底部是名称和描述</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<h3 id=\"28-结束节点\">2.8 结束节点</h3>\n<p>连接\"批处理\"节点到\"结束\"节点</p>\n<p>配置结束节点输出：</p>\n<ul>\n<li>output：文字优化节点的output</li>\n<li>output1：批处理节点的output（图文内容）</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<h2 id=\"3-总结\">3. 总结</h2>\n<p>通过这套健康养生图文生成器工作流，你可以轻松实现：</p>\n<ul>\n<li>一键生成专业的养生知识内容</li>\n<li>自动创建与内容匹配的精美插画</li>\n<li>将专业内容转换为小红书的风格</li>\n<li>生成排版精美的图文卡片</li>\n</ul>\n<p>在AI时代，掌握这些智能工具就等于抢占了内容创作的快车道。</p>\n<p>学会运用AI智能体，让你的养生号运营更轻松、更高效！</p>\n<blockquote>\n<p>对了，我整理了一份开源《智能体学习手册》，爆肝 10 万字，价值 999 元。限时开放领取👉：<a href=\"https://tangshiye.cn\" rel=\"noopener nofollow\" target=\"_blank\">tangshiye.cn</a></p>\n</blockquote>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/tangshiye/\" target=\"_blank\">AI架构师汤师爷</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/tangshiye/p/19607340\" target=\"_blank\">https://www.cnblogs.com/tangshiye/p/19607340</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-12 10:44</span>&nbsp;\n<a href=\"https://www.cnblogs.com/tangshiye\">AI架构师汤师爷</a>&nbsp;\n阅读(<span id=\"post_view_count\">30</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Docker Compose部署多.NET后端API+多Vue前端Web 完整记录（含多数据库扩展+实用场景，亲测无坑）",
      "link": "https://www.cnblogs.com/huyong/p/19607257",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/huyong/p/19607257\" id=\"cb_post_title_url\" title=\"发布于 2026-02-12 10:44\">\n    <span>Docker Compose部署多.NET后端API+多Vue前端Web 完整记录（含多数据库扩展+实用场景，亲测无坑）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"Docker Compose部署多.NET后端API+多Vue前端Web 完整记录（含多数据库扩展+实用场景，亲测无坑）\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/157572/202602/157572-20260212102740614-1259695947.png\" />\n        本文介绍在Linux 服务器上，基于 Docker Compose 部署多.NET 后端 API 与多 Vue 前端 Web 的方案，解决多服务端口冲突、配置混乱问题，适配个人测试、小型项目部署场景。\n先完成环境准备：安装配置 Docker CE、升级 Docker Compose 至 V2，配置镜像加速，整理服务器目录结构并上传本地打包文件。核心通过 docker-compose.yml 编排 MySQL/Redis/ 多后端 / 多前端 / Nginx 服务，借助 Nginx 实现前端代理和后端 API 分流，设置健康检查保障服务启动顺序。此外，提供 PostgreSQL、SQL Server 数据库替换方案，仅需修改编排文件和后端连接串，无需调整前端与 Nginx 配置，全程可复现，便于扩展服务数量。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>接上篇文章：<a href=\"http://www.rdiframework.net/article/detail/772191512834117\" rel=\"noopener nofollow\" target=\"_blank\">Linux Docker Compose 部署.NET+Vue+MySQL+Redis+Nginx 完整记录（亲测无坑）</a></p>\n<p>写在前面：在实际开发和测试中，经常会遇到需要在同一台服务器部署多个后端API（如主服务+附属服务、测试服务+生产服务）和多个前端Web（如管理端+用户端、PC端+移动端适配版）的场景。单纯靠docker run命令逐个启动容器，会面临端口冲突、配置混乱、维护困难等问题。</p>\n<p><img alt=\"封面\" src=\"https://img2024.cnblogs.com/blog/157572/202602/157572-20260212102640551-992507078.png\" /></p>\n<p>本文基于Docker Compose，实现「2个及以上.NET8后端API + 2个及以上Vue前端Web」的容器化部署，核心解决端口隔离、配置统一、Nginx分流等问题；同时扩展PostgreSQL、SQL Server两种数据库的替换方案，补充多个实用部署场景（如子域名访问、HTTPS、日志集中），全程亲测可复现，用于后期查阅，也希望能帮到有同样需求的同行。</p>\n<p>适用场景：个人测试、小型项目多服务部署、企业内部多环境（测试+开发）部署，可灵活扩展服务数量，无需重新搭建整体环境。</p>\n<h1 id=\"一部署环境准备提前确认避免兼容问题\">一、部署环境准备（提前确认，避免兼容问题）</h1>\n<h2 id=\"1-服务器环境通用测试小型生产均适用\">1. 服务器环境（通用，测试/小型生产均适用）</h2>\n<ul>\n<li>\n<p>系统：CentOS 7.9（最小化安装，已配置静态IP：192.168.1.100，替换为自身服务器真实IP）</p>\n</li>\n<li>\n<p>内存：8G（建议不低于4G，多服务同时运行需足够内存，避免卡顿）</p>\n</li>\n<li>\n<p>硬盘：100G（存放多个服务的镜像、打包文件、数据库数据，预留冗余）</p>\n</li>\n<li>\n<p>网络：能访问外网（前期拉取镜像、安装依赖，后期可断网运行；若内网服务器，提前准备离线镜像）</p>\n</li>\n<li>\n<p>权限：root用户（或具备Docker、目录操作权限的普通用户，生产环境建议用普通用户）</p>\n</li>\n</ul>\n<h2 id=\"2-软件版本全程统一避免兼容问题\">2. 软件版本（全程统一，避免兼容问题）</h2>\n<ul>\n<li>\n<p>Docker：Docker CE 24.0.7（CentOS7稳定版，兼容性强）</p>\n</li>\n<li>\n<p>Docker Compose：V2.27.1（支持新版配置，解决多服务依赖、健康检查兼容问题）</p>\n</li>\n<li>\n<p>后端：.NET 8（本地VS2022发布为publish文件夹，无源码，多后端需单独发布）</p>\n</li>\n<li>\n<p>前端：Vue3（本地yarn/npm打包为dist文件夹，无源码，多前端需单独打包）</p>\n</li>\n<li>\n<p>数据库（多版本可选）：MySQL 8.0、PostgreSQL 15、SQL Server 2022（Docker镜像，数据持久化）</p>\n</li>\n<li>\n<p>缓存：Redis 7-alpine（轻量版，占用资源少，适配多服务共享/隔离缓存）</p>\n</li>\n<li>\n<p>代理：Nginx alpine（轻量版，实现多前端代理、多后端分流）</p>\n</li>\n</ul>\n<h2 id=\"3-本地准备文件提前打包上传到服务器\">3. 本地准备文件（提前打包，上传到服务器）</h2>\n<p>所有文件统一放在本地易找到的目录（如桌面），后续用Xftp/WinSCP上传到服务器，避免混乱，文件清单如下：</p>\n<ul>\n<li>\n<p>后端文件：backend1-publish、backend2-publish（2个后端的.NET8发布文件，可新增backend3-publish等，命名区分）</p>\n</li>\n<li>\n<p>前端文件：frontend1-dist、frontend2-dist（2个前端的Vue打包文件，可新增，命名区分）</p>\n</li>\n<li>\n<p>镜像tar包（离线备用）：multi-service-images.tar（含所有所需镜像：后端运行时、前端代理、3种数据库、Redis，解决网络拉取超时）</p>\n</li>\n<li>\n<p>配置文件：</p>\n<ul>\n<li>\n<p>nginx.conf（Nginx核心配置，实现多前端/多后端分流）</p>\n</li>\n<li>\n<p>数据库配置：my.cnf（MySQL）、postgresql.conf（PostgreSQL）、sqlserver.conf（SQL Server，可选）</p>\n</li>\n<li>\n<p>数据库初始化SQL：init-mysql.sql、init-postgresql.sql、init-sqlserver.sql（对应不同数据库，创建库、表、初始化数据）</p>\n</li>\n<li>\n<p>docker-compose.yml（核心编排文件，管理所有服务，含多数据库可选配置）</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/157572/202602/157572-20260212102640244-1087151636.png\" /></p>\n<h1 id=\"二前期基础准备工作必做奠定部署基础\">二、前期基础准备工作（必做，奠定部署基础）</h1>\n<p>无论后续用哪种数据库、部署多少服务，这部分工作都是基础，一次性做好，避免后续重复操作。</p>\n<h2 id=\"1-centos7系统基础配置补充依赖避免报错\">1. CentOS7系统基础配置（补充依赖，避免报错）</h2>\n<p>最小化安装的CentOS7缺少很多基础工具，先安装必要依赖，确保Docker、命令执行正常：</p>\n<pre><code class=\"language-bash\"># 更新系统软件包（可选，建议执行，避免依赖版本过低）\nyum update -y\n\n# 安装基础工具（wget、vim、net-tools等，后续编辑配置、查看端口常用）\nyum install -y wget vim net-tools epel-release\n\n# 安装Docker依赖所需的额外工具（避免后续安装Docker失败）\nyum install -y curl policycoreutils-python-utils\n</code></pre>\n<h2 id=\"2-安装docker-ce稳定版步骤固定\">2. 安装Docker CE（稳定版，步骤固定）</h2>\n<pre><code class=\"language-bash\"># 1. 卸载旧版本Docker（如果之前装过，避免冲突，没装过可跳过）\nyum remove -y docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine\n\n# 2. 配置Docker官方源（CentOS7专属）\nyum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n\n# 3. 安装Docker CE 24.0.7（指定版本，避免自动更新到不稳定版本）\nyum install -y docker-ce-24.0.7 docker-ce-cli-24.0.7 containerd.io\n\n# 4. 启动Docker服务，并设置开机自启（关键，多服务需随Docker自动启动）\nsystemctl start docker\nsystemctl enable docker\n\n# 5. 验证Docker安装成功（输出版本号即成功）\ndocker --version\n</code></pre>\n<p>✅ 成功标识：<code>Docker version 24.0.7, build afdd53b</code></p>\n<h2 id=\"3-配置docker镜像加速国内必做避免镜像拉取超时\">3. 配置Docker镜像加速（国内必做，避免镜像拉取超时）</h2>\n<p>Docker默认拉取国外镜像源，国内访问极慢，甚至超时，配置阿里云专属加速（比公共源更稳定）。登录阿里云官网（<a href=\"https://www.aliyun.com/%EF%BC%89%EF%BC%8C%E6%90%9C%E7%B4%A2\" rel=\"noopener nofollow\" target=\"_blank\">https://www.aliyun.com/），搜索</a> “容器镜像服务”，进入 “镜像加速器”，复制自己的专属加速地址（示例：<a href=\"https://xxxxxx.mirror.aliyuncs.com\" rel=\"noopener nofollow\" target=\"_blank\">https://xxxxxx.mirror.aliyuncs.com</a>，替换成自己的）；</p>\n<p><img alt=\"镜像加速器\" src=\"https://img2024.cnblogs.com/blog/157572/202602/157572-20260212102640329-1145206426.png\" /></p>\n<pre><code class=\"language-bash\"># 1. 创建Docker配置目录（如果不存在）\nmkdir -p /etc/docker\n\n# 2. 写入加速配置（替换成自己的阿里云专属加速地址，获取方式：阿里云→容器镜像服务→镜像加速器）\ntee /etc/docker/daemon.json &lt;&lt;-'EOF'\n{\n  \"registry-mirrors\": [\"https://xxxxxx.mirror.aliyuncs.com\", \"https://mirror.ccs.tencentyun.com\"]\n}\nEOF\n\n# 3. 重新加载配置，重启Docker，让加速生效\nsystemctl daemon-reload\nsystemctl restart docker\n\n# 4. 验证加速配置是否生效（输出配置的加速地址即成功）\ndocker info | grep -A 2 \"Registry Mirrors\"\n</code></pre>\n<p>✅ 成功标识：输出中包含自己配置的阿里云加速地址，无报错。</p>\n<p><img alt=\"阿里云加速地址\" src=\"https://img2024.cnblogs.com/blog/157572/202602/157572-20260212102640225-1082113952.png\" /></p>\n<h2 id=\"4-升级docker-composev2版本支持多服务配置\">4. 升级Docker Compose（V2版本，支持多服务配置）</h2>\n<p>CentOS7默认安装的Docker Compose是1.x版本，不支持多服务的健康检查、依赖条件等配置，升级到V2版本：</p>\n<pre><code class=\"language-bash\"># 1. 删除旧版docker-compose（如果之前装过）\nrm -f /usr/local/bin/docker-compose\n\n# 2. 安装Docker Compose V2（插件形式，稳定，和Docker联动更好）\nyum install -y docker-compose-plugin\n\n# 3. 建立软链接，保持docker-compose命令可用（和旧版用法一致，无需改命令）\nln -s /usr/libexec/docker/cli-plugins/docker-compose /usr/local/bin/docker-compose\n\n# 4. 验证升级成功（输出V2版本号即成功）\ndocker-compose --version\n</code></pre>\n<p>✅ 成功标识：<code>Docker Compose version v2.27.1</code>（版本号可略有差异，只要是V2即可）</p>\n<h2 id=\"5-关闭防火墙测试环境-开放端口生产环境\">5. 关闭防火墙（测试环境）/ 开放端口（生产环境）</h2>\n<p>测试环境：直接关闭防火墙，避免端口被拦截，简化配置；生产环境：仅开放所需端口，提升安全性。</p>\n<pre><code class=\"language-bash\"># 测试环境：关闭防火墙并禁止开机自启\nsystemctl stop firewalld\nsystemctl disable firewalld\nsystemctl status firewalld  # 验证，输出inactive即成功\n\n# 生产环境：开放所需端口（示例，根据自己的端口修改）\n# 后端端口：58588、58589；前端端口：6866、6867；数据库端口：3306（MySQL）、5432（PostgreSQL）、1433（SQL Server）；Redis端口：6379\nfirewall-cmd --add-port=58588/tcp --permanent\nfirewall-cmd --add-port=58589/tcp --permanent\nfirewall-cmd --add-port=6866/tcp --permanent\nfirewall-cmd --add-port=6867/tcp --permanent\nfirewall-cmd --add-port=3306/tcp --permanent\nfirewall-cmd --add-port=5432/tcp --permanent\nfirewall-cmd --add-port=1433/tcp --permanent\nfirewall-cmd --add-port=6379/tcp --permanent\nfirewall-cmd --reload  # 生效配置\nfirewall-cmd --list-ports  # 验证，查看开放的端口清单\n</code></pre>\n<h2 id=\"6-服务器目录结构整理规范目录避免后期混乱\">6. 服务器目录结构整理（规范目录，避免后期混乱）</h2>\n<p>将本地准备的所有文件，上传到服务器的<code>/root/multi-service-docker</code>目录（自定义目录，方便记忆），最终目录结构如下（支持多后端、多前端、多数据库）：</p>\n<pre><code class=\"language-bash\">multi-service-docker/                # 项目根目录（所有文件都放在这里）\n├── docker-compose.yml               # 核心编排文件（管理所有服务，含多数据库配置）\n# 后端目录（2个，可扩展更多）\n├── backend1/                        # 第一个后端API服务\n│   └── publish/                     # 后端1的.NET8发布文件（含核心DLL、appsettings.json）\n├── backend2/                        # 第二个后端API服务\n│   └── publish/                     # 后端2的.NET8发布文件\n# 前端目录（2个，可扩展更多）\n├── frontend1/                       # 第一个前端Web（如管理端）\n│   └── dist/                        # 前端1的Vue打包文件（index.html、css、js）\n├── frontend2/                       # 第二个前端Web（如用户端）\n│   └── dist/                        # 前端2的Vue打包文件\n# Nginx配置目录\n├── nginx/\n│   └── nginx.conf                   # Nginx核心配置（多前端/多后端分流）\n# 数据库配置目录（3种数据库，按需使用）\n├── mysql/\n│   ├── my.cnf                       # MySQL配置文件\n│   └── init-mysql.sql               # MySQL初始化SQL\n├── postgresql/\n│   ├── postgresql.conf              # PostgreSQL配置文件\n│   └── init-postgresql.sql          # PostgreSQL初始化SQL\n├── sqlserver/\n│   ├── sqlserver.conf               # SQL Server配置文件（可选）\n│   └── init-sqlserver.sql           # SQL Server初始化SQL\n# 离线镜像包（备用）\n└── multi-service-images.tar         # 所有所需镜像的离线包\n</code></pre>\n<p>✅ 上传方法：用 MobaXterm/Xftp/WinSCP连接服务器（IP：服务器真实IP，账号：root，密码：自己的服务器密码），将本地准备的文件，按上述目录结构，拖到对应文件夹中即可。</p>\n<h1 id=\"三核心方案2个net8后端api--2个vue前端web-基础部署mysql版\">三、核心方案：2个.NET8后端API + 2个Vue前端Web 基础部署（MySQL版）</h1>\n<p>先实现最基础的多服务部署（2后端+2前端+MySQL+Redis+Nginx），掌握核心逻辑后，再扩展其他数据库和场景，新手建议先按此方案部署成功，再进行扩展。</p>\n<h2 id=\"1-编写docker-composeyml核心编排文件\">1. 编写docker-compose.yml（核心编排文件）</h2>\n<p>该文件是多服务部署的核心，管理所有容器的启动、依赖、端口、挂载等配置，注释详细，可直接复制使用，关键配置已标注：</p>\n<pre><code class=\"language-yaml\">version: '3.8'\n\n# 所有服务的集合（多后端、多前端、数据库、Redis、Nginx）\nservices:\n  # === 公共依赖服务：MySQL（基础版，后续可替换为PostgreSQL/SQL Server） ===\n  mysql:\n    image: mysql:8.0                  # 使用MySQL 8.0镜像\n    container_name: multi-mysql       # 自定义容器名，唯一，方便管理\n    restart: always                   # 容器异常退出/服务器重启后，自动重启\n    environment:\n      MYSQL_ROOT_PASSWORD: Root@123456  # MySQL root密码（自定义，建议复杂密码）\n      MYSQL_USER: appuser             # 项目访问MySQL的用户名（自定义）\n      MYSQL_PASSWORD: App@123456      # 项目访问MySQL的密码（自定义）\n      MYSQL_DATABASE: app_db1         # 后端1所用数据库名\n      MYSQL_DATABASE2: app_db2        # 后端2所用数据库名（分库部署，可选）\n      TZ: Asia/Shanghai               # 强制容器时区为东八区（解决时差问题）\n    ports:\n      - \"3306:3306\"                   # 端口映射：宿主机3306 → 容器内3306（本地工具可连接）\n    volumes:\n      - ./mysql/my.cnf:/etc/mysql/conf.d/my.cnf  # 挂载MySQL配置文件\n      - ./mysql/init-mysql.sql:/docker-entrypoint-initdb.d/init-mysql.sql  # 挂载初始化SQL\n      - mysql-data:/var/lib/mysql     # 数据卷：持久化MySQL数据（容器删除不丢失）\n      - /etc/localtime:/etc/localtime:ro  # 挂载宿主机时区文件，双重保障时差\n    command: --lower_case_table_names=1  # MySQL不区分大小写（避免表名大小写问题）\n    networks:\n      - multi-service-network         # 加入自定义网络，实现所有容器互通\n    # 健康检查：检测MySQL是否真正就绪，避免后端启动早于MySQL，导致连接失败\n    healthcheck:\n      test: [\"CMD\", \"mysqladmin\", \"ping\", \"-h\", \"localhost\", \"-uappuser\", \"-pApp@123456\"]\n      interval: 5s                    # 每5秒检测一次\n      timeout: 30s                    # 超时时间30秒\n      retries: 10                     # 重试10次，失败则认为容器未就绪\n      start_period: 20s               # 容器启动后，延迟20秒开始检测\n\n  # === 公共依赖服务：Redis（缓存，多后端可共享/隔离） ===\n  redis:\n    image: redis:7-alpine             # 轻量版Redis，占用资源少\n    container_name: multi-redis       # 唯一容器名\n    restart: always                   # 自动重启\n    ports:\n      - \"6379:6379\"                   # 端口映射：宿主机6379 → 容器内6379\n    volumes:\n      - redis-data:/data              # 数据卷：持久化Redis数据\n    command: redis-server --requirepass \"Redis@123456\"  # Redis密码（自定义）\n    networks:\n      - multi-service-network         # 加入自定义网络\n    environment:\n      TZ: Asia/Shanghai               # 同步东八区时区\n    # Redis健康检查（可选，优化多后端依赖）\n    healthcheck:\n      test: [\"CMD\", \"redis-cli\", \"ping\", \"-a\", \"Redis@123456\"]\n      interval: 3s\n      timeout: 10s\n      retries: 5\n\n  # === 后端API 1（第一个服务，如管理端后端） ===\n  backend1:\n    image: mcr.microsoft.com/dotnet/aspnet:8.0  # .NET8运行时镜像（无需构建，直接运行发布文件）\n    container_name: multi-backend1    # 唯一容器名，区分其他后端\n    restart: always                   # 自动重启\n    ports:\n      - \"58588:58588\"                 # 唯一端口，避免和其他后端冲突\n    depends_on:\n      mysql:\n        condition: service_healthy    # 仅在MySQL健康检查通过（真正就绪）后，才启动后端1\n      redis:\n        condition: service_healthy    # Redis就绪后，启动后端1\n    volumes:\n      - ./backend1/publish:/app       # 挂载后端1的发布目录（核心，容器直接运行发布文件）\n      - /wwwroot/Resources1:/wwwroot/Resources  # 挂载后端1的文件目录（如用户头像，按需挂载）\n    environment:\n      TZ: Asia/Shanghai               # 同步时区\n      ASPNETCORE_URLS: \"http://*:58588\"  # 强制后端1监听58588端口（解决端口不通问题）\n      ASPNETCORE_ENVIRONMENT: Production  # .NET环境（生产环境）\n      # 后端1的MySQL连接字符串（连接MySQL的app_db1库，server用容器名mysql）\n      ConnectionStrings__MySQL: \"server=mysql;port=3306;database=app_db1;user=appuser;password=App@123456;charset=utf8mb4;AllowPublicKeyRetrieval=True;SslMode=None\"\n      # 后端1的Redis连接字符串（server用容器名redis，密码对应上面的Redis密码）\n      ConnectionStrings__Redis: \"redis:6379,password=Redis@123456,defaultDatabase=0,ssl=false,abortConnect=false\"\n    working_dir: /app                 # 容器工作目录，指向挂载的发布目录\n    entrypoint: [\"dotnet\", \"Backend1.WebHost.dll\"]  # 启动后端1的核心DLL（替换为自己的DLL名）\n    networks:\n      - multi-service-network         # 加入自定义网络，可访问MySQL/Redis/其他后端\n\n  # === 后端API 2（第二个服务，如用户端后端） ===\n  backend2:\n    image: mcr.microsoft.com/dotnet/aspnet:8.0  # 和后端1共用.NET8运行时镜像\n    container_name: multi-backend2    # 唯一容器名，区分后端1\n    restart: always                   # 自动重启\n    ports:\n      - \"58589:58589\"                 # 唯一端口，避免和后端1冲突（不可重复）\n    depends_on:\n      mysql:\n        condition: service_healthy    # 依赖MySQL就绪\n      redis:\n        condition: service_healthy    # 依赖Redis就绪\n    volumes:\n      - ./backend2/publish:/app       # 挂载后端2的发布目录（独立目录，避免代码覆盖）\n      - /wwwroot/Resources2:/wwwroot/Resources  # 后端2的文件目录（独立挂载，避免文件混乱）\n    environment:\n      TZ: Asia/Shanghai\n      ASPNETCORE_URLS: \"http://*:58589\"  # 强制后端2监听58589端口\n      ASPNETCORE_ENVIRONMENT: Production\n      # 后端2的MySQL连接字符串（可连接不同库app_db2，实现分库部署）\n      ConnectionStrings__MySQL: \"server=mysql;port=3306;database=app_db2;user=appuser;password=App@123456;charset=utf8mb4;AllowPublicKeyRetrieval=True;SslMode=None\"\n      # 后端2的Redis连接字符串（可指定不同数据库defaultDatabase=1，实现缓存隔离）\n      ConnectionStrings__Redis: \"redis:6379,password=Redis@123456,defaultDatabase=1,ssl=false,abortConnect=false\"\n    working_dir: /app\n    entrypoint: [\"dotnet\", \"Backend2.WebHost.dll\"]  # 后端2的核心DLL（替换为自己的）\n    networks:\n      - multi-service-network\n\n  # === Nginx服务（核心：多前端代理+多后端分流） ===\n  nginx:\n    image: nginx:alpine               # 轻量版Nginx\n    container_name: multi-nginx       # 唯一容器名\n    restart: always                   # 自动重启\n    ports:\n      - \"6866:6866\"                   # 前端1访问端口（唯一）\n      - \"6867:6867\"                   # 前端2访问端口（唯一，避免冲突）\n    volumes:\n      - ./nginx/nginx.conf:/etc/nginx/nginx.conf  # 挂载Nginx分流配置\n      - ./frontend1/dist:/usr/share/nginx/html/web1  # 挂载前端1的静态文件\n      - ./frontend2/dist:/usr/share/nginx/html/web2  # 挂载前端2的静态文件\n    depends_on:\n      - backend1                      # 后端1启动后，再启动Nginx（避免前端访问后端失败）\n      - backend2                      # 后端2启动后，再启动Nginx\n    networks:\n      - multi-service-network\n    environment:\n      TZ: Asia/Shanghai\n\n# 数据卷：持久化MySQL、Redis数据（容器删除、docker-compose down不会删除数据）\nvolumes:\n  mysql-data:\n  redis-data:\n\n# 自定义网络：所有服务加入同一网络，容器间可通过「容器名」直接通信，无需配置IP\nnetworks:\n  multi-service-network:\n    driver: bridge\n</code></pre>\n<h2 id=\"2-编写nginx配置nginxconf多服务分流核心\">2. 编写Nginx配置（nginx.conf，多服务分流核心）</h2>\n<p>Nginx的核心作用是：代理多个前端静态文件，将前端的API请求，按路径前缀分流到对应后端，避免端口混乱，配置如下（注释详细）：</p>\n<pre><code class=\"language-nginx\">worker_processes 1;  # 按服务器CPU核心数调整，1核用1，2核用2\n\nevents {\n    worker_connections 1024;  # 最大连接数，足够多服务使用\n}\n\nhttp {\n    include       /etc/nginx/mime.types;  # 引入MIME类型（支持前端静态文件）\n    default_type  application/octet-stream;\n\n    sendfile        on;  # 开启高效文件传输\n    keepalive_timeout  65;  # 连接超时时间\n\n    # === 前端1配置（访问端口：6866，对应管理端） ===\n    server {\n        listen       6866;  # 前端1的访问端口（和docker-compose.yml中Nginx的端口映射一致）\n        server_name  localhost;  # 测试环境用localhost，生产环境可改为域名\n\n        # 前端1的静态文件代理（加载Vue打包后的index.html、css、js）\n        location / {\n            root   /usr/share/nginx/html/web1;  # 对应前端1的dist目录（docker-compose.yml中挂载的路径）\n            index  index.html index.htm;\n            try_files $uri $uri/ /index.html;  # 解决Vue路由刷新404问题（关键）\n        }\n\n        # 前端1调用的后端1API（路径前缀：/api1/，分流到backend1）\n        location /api1/ {\n            proxy_pass http://multi-backend1:58588/;  # 转发到后端1容器（容器名+端口）\n            # 转发请求头，确保后端能获取客户端真实IP、请求地址等信息\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n        }\n\n        # 前端1如需调用后端2API（可选，按需配置）\n        location /api2/ {\n            proxy_pass http://multi-backend2:58589/;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n        }\n    }\n\n    # === 前端2配置（访问端口：6867，对应用户端） ===\n    server {\n        listen       6867;  # 前端2的访问端口（唯一，不重复）\n        server_name  localhost;\n\n        # 前端2的静态文件代理\n        location / {\n            root   /usr/share/nginx/html/web2;  # 对应前端2的dist目录\n            index  index.html index.htm;\n            try_files $uri $uri/ /index.html;  # Vue路由兼容\n        }\n\n        # 前端2调用的后端2API（路径前缀：/api2/，分流到backend2）\n        location /api2/ {\n            proxy_pass http://multi-backend2:58589/;  # 转发到后端2容器\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n        }\n\n        # 前端2如需调用后端1API（可选，按需配置）\n        location /api1/ {\n            proxy_pass http://multi-backend1:58588/;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n        }\n    }\n}\n</code></pre>\n<h2 id=\"3-启动所有服务并验证\">3. 启动所有服务并验证</h2>\n<p>所有配置完成后，一键启动所有服务，然后逐个验证，确保所有服务正常运行。</p>\n<pre><code class=\"language-bash\"># 1. 进入项目根目录（必须在docker-compose.yml所在目录执行命令）\ncd /root/multi-service-docker\n\n# 2. 后台启动所有服务（-d：后台运行，无需手动值守）\ndocker-compose up -d\n\n# 3. 查看所有服务运行状态（关键，确认所有服务都启动成功）\ndocker-compose ps\n</code></pre>\n<p>✅ 成功标识：<code>docker-compose ps</code>输出中，multi-mysql、multi-redis、multi-backend1、multi-backend2、multi-nginx 5个服务的State列，均为<code>Up (healthy)</code>或<code>Up</code>，无Exited状态。</p>\n<h3 id=\"31-逐个验证服务确保无问题\">3.1 逐个验证服务（确保无问题）</h3>\n<ul>\n<li><strong>验证后端1</strong>：访问地址<code>http://服务器IP:58588/swagger</code>（如：<a href=\"http://192.168.1.100:58588/swagger%EF%BC%89\" rel=\"noopener nofollow\" target=\"_blank\">http://192.168.1.100:58588/swagger）</a></li>\n</ul>\n<p>​\t\t✅ 成功标识：浏览器能正常打开Swagger页面，无报错，能看到后端1的所有接口。</p>\n<ul>\n<li>\n<p><strong>验证后端2</strong>：访问地址 <code>http://服务器IP:58589/swagger</code><br />\n✅ 成功标识：正常打开Swagger页面，接口能正常显示。</p>\n</li>\n<li>\n<p><strong>验证前端1</strong>：访问地址 <code>http://服务器IP:6866</code><br />\n✅ 成功标识：能正常打开Vue页面，样式、图片正常，调用<code>/api1/xxx</code>接口能返回正常数据。</p>\n</li>\n<li>\n<p><strong>验证前端2</strong>：访问地址 <code>http://服务器IP:6867</code><br />\n✅ 成功标识：能正常打开Vue页面，调用<code>/api2/xxx</code>接口能返回正常数据。</p>\n</li>\n<li>\n<p><strong>验证MySQL</strong>：用Navicat/DBeaver连接服务器IP:3306，用户名appuser，密码App@123456，能正常连接，能看到app_db1、app_db2两个数据库，以及初始化的表和数据。</p>\n</li>\n<li>\n<p><strong>验证Redis</strong>：用Redis客户端连接服务器IP:6379，密码Redis@123456，能正常执行set、get命令，后端1/2的缓存能正常生效。</p>\n</li>\n</ul>\n<p>❌ 失败排查：若某个服务启动失败或访问不通，执行<code>docker-compose logs -f 服务名</code>（如<code>docker-compose logs -f multi-backend1</code>），查看实时日志，根据日志提示排查问题（如端口冲突、连接串错误、目录挂载失败）。</p>\n<h1 id=\"四扩展方案1替换数据库postgresql--sql-server\">四、扩展方案1：替换数据库（PostgreSQL / SQL Server）</h1>\n<p>实际项目中，可能会用到PostgreSQL（开源、适合复杂查询）或SQL Server（微软生态、适合.NET项目），以下是完整的替换方案，只需修改docker-compose.yml和后端连接串，无需修改前端和Nginx配置。</p>\n<h2 id=\"1-替换为postgresql开源首选适配net6\">1. 替换为PostgreSQL（开源首选，适配.NET6+）</h2>\n<p>PostgreSQL是开源的高性能数据库，兼容性强，适合大多数.NET项目，替换步骤如下：</p>\n<h3 id=\"11-修改docker-composeyml替换mysql为postgresql\">1.1 修改docker-compose.yml（替换MySQL为PostgreSQL）</h3>\n<p>删除原有的mysql服务，新增postgresql服务，其他服务（后端1/2、前端1/2、Redis、Nginx）无需修改，仅修改后端的连接串：</p>\n<pre><code class=\"language-yaml\">version: '3.8'\n\nservices:\n  # === 替换为PostgreSQL服务（替换原有的MySQL） ===\n  postgresql:\n    image: postgres:15                # PostgreSQL 15镜像（稳定版，适配.NET8）\n    container_name: multi-postgresql  # 唯一容器名\n    restart: always\n    environment:\n      POSTGRES_USER: appuser          # 项目访问PostgreSQL的用户名\n      POSTGRES_PASSWORD: App@123456   # 密码（和之前MySQL一致，方便记忆）\n      POSTGRES_DB: app_db1            # 后端1所用数据库\n      POSTGRES_DB2: app_db2           # 后端2所用数据库（分库部署）\n      TZ: Asia/Shanghai               # 同步东八区时区\n    ports:\n      - \"5432:5432\"                   # PostgreSQL默认端口5432\n    volumes:\n      - ./postgresql/postgresql.conf:/var/lib/postgresql/data/postgresql.conf  # 挂载配置文件\n      - ./postgresql/init-postgresql.sql:/docker-entrypoint-initdb.d/init-postgresql.sql  # 挂载初始化SQL\n      - postgresql-data:/var/lib/postgresql/data  # 数据卷：持久化数据\n      - /etc/localtime:/etc/localtime:ro\n    networks:\n      - multi-service-network\n    # 健康检查：检测PostgreSQL是否就绪\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U appuser -d app_db1\"]\n      interval: 5s\n      timeout: 30s\n      retries: 10\n      start_period: 20s\n\n  # === Redis服务（不变） ===\n  redis:\n    image: redis:7-alpine\n    container_name: multi-redis\n    restart: always\n    ports:\n      - \"6379:6379\"\n    volumes:\n      - redis-data:/data\n    command: redis-server --requirepass \"Redis@123456\"\n    networks:\n      - multi-service-network\n    environment:\n      TZ: Asia/Shanghai\n    healthcheck:\n      test: [\"CMD\", \"redis-cli\", \"ping\", \"-a\", \"Redis@123456\"]\n      interval: 3s\n      timeout: 10s\n      retries: 5\n\n  # === 后端1服务（仅修改MySQL连接串为PostgreSQL连接串） ===\n  backend1:\n    image: mcr.microsoft.com/dotnet/aspnet:8.0\n    container_name: multi-backend1\n    restart: always\n    ports:\n      - \"58588:58588\"\n    depends_on:\n      postgresql:  # 依赖改为postgresql，而非mysql\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n    volumes:\n      - ./backend1/publish:/app\n      - /wwwroot/Resources1:/wwwroot/Resources\n    environment:\n      TZ: Asia/Shanghai\n      ASPNETCORE_URLS: \"http://*:58588\"\n      ASPNETCORE_ENVIRONMENT: Production\n      # 后端1的PostgreSQL连接串（替换原有的MySQL连接串）\n      ConnectionStrings__PostgreSQL: \"Host=postgresql;Port=5432;Database=app_db1;Username=appuser;Password=App@123456;Pooling=true;Timeout=30;\"\n      # Redis连接串（不变）\n      ConnectionStrings__Redis: \"redis:6379,password=Redis@123456,defaultDatabase=0,ssl=false,abortConnect=false\"\n    working_dir: /app\n    entrypoint: [\"dotnet\", \"Backend1.WebHost.dll\"]\n    networks:\n      - multi-service-network\n\n  # === 后端2服务（仅修改连接串） ===\n  backend2:\n    image: mcr.microsoft.com/dotnet/aspnet:8.0\n    container_name: multi-backend2\n    restart: always\n    ports:\n      - \"58589:58589\"\n    depends_on:\n      postgresql:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n    volumes:\n      - ./backend2/publish:/app\n      - /wwwroot/Resources2:/wwwroot/Resources\n    environment:\n      TZ: Asia/Shanghai\n      ASPNETCORE_URLS: \"http://*:58589\"\n      ASPNETCORE_ENVIRONMENT: Production\n      # 后端2的PostgreSQL连接串\n      ConnectionStrings__PostgreSQL: \"Host=postgresql;Port=5432;Database=app_db2;Username=appuser;Password=App@123456;Pooling=true;Timeout=30;\"\n      # Redis连接串（不变）\n      ConnectionStrings__Redis: \"redis:6379,password=Redis@123456,defaultDatabase=1,ssl=false,abortConnect=false\"\n    working_dir: /app\n    entrypoint: [\"dotnet\", \"Backend2.WebHost.dll\"]\n    networks:\n      - multi-service-network\n\n  # === Nginx服务（不变） ===\n  nginx:\n    image: nginx:alpine\n    container_name: multi-nginx\n    restart: always\n    ports:\n      - \"6866:6866\"\n      - \"6867:6867\"\n    volumes:\n      - ./nginx/nginx.conf:/etc/nginx/nginx.conf\n      - ./frontend1/dist:/usr/share/nginx/html/web1\n      - ./frontend2/dist:/usr/share/nginx/html/web2\n    depends_on:\n      - backend1\n      - backend2\n    networks:\n      - multi-service-network\n    environment:\n      TZ: Asia/Shanghai\n\n# 数据卷：替换为postgresql-data，删除mysql-data\nvolumes:\n  postgresql-data:\n  redis-data:\n\n# 自定义网络（不变）\nnetworks:\n  multi-service-network:\n    driver: bridge\n</code></pre>\n<h3 id=\"12-后端项目修改关键\">1.2 后端项目修改（关键）</h3>\n<ul>\n<li>\n<ol>\n<li>后端项目中，安装PostgreSQL依赖包：在VS2022中，右键项目→管理NuGet程序包，搜索并安装<code>Npgsql.EntityFrameworkCore.PostgreSQL</code>（适配.NET8的版本）；</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>修改appsettings.json：将原来的<code>ConnectionStrings:MySQL</code>，改为<code>ConnectionStrings:PostgreSQL</code>，对应docker-compose.yml中的连接串；</li>\n</ol>\n</li>\n<li>\n<ol start=\"3\">\n<li>\n<p>修改Program.cs：如使用EF Core的数据库提供器，从MySQL改为PostgreSQL，示例：</p>\n<blockquote>\n<p>// 原来的MySQL配置<br />\nbuilder.Services.AddDbContext(options =&gt; options.UseMySql(builder.Configuration.GetConnectionString(\"MySQL\"), new MySqlServerVersion(new Version(8, 0, 36))));</p>\n<p>// 改为PostgreSQL配置<br />\nbuilder.Services.AddDbContext(options =&gt; options.UseNpgsql(builder.Configuration.GetConnectionString(\"PostgreSQL\")));</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li>\n<ol start=\"4\">\n<li>重新发布后端1/2项目，将新的publish文件夹，上传到服务器对应目录，覆盖原来的文件。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"13-启动并验证\">1.3 启动并验证</h3>\n<pre><code class=\"language-bash\">cd /root/multi-service-docker\n# 停止并删除原有容器（避免冲突）\ndocker-compose down\n# 启动新服务\ndocker-compose up -d\n# 查看状态\ndocker-compose ps\n</code></pre>\n<p>✅ 验证：和基础方案一致，访问前端、后端、PostgreSQL（用Navicat连接服务器IP:5432），确认所有服务正常。</p>\n<h2 id=\"2-替换为sql-server微软生态适合net项目\">2. 替换为SQL Server（微软生态，适合.NET项目）</h2>\n<p>SQL Server是微软推出的关系型数据库，和.NET生态兼容性极佳，适合企业级.NET项目，替换步骤如下（类似PostgreSQL）：</p>\n<h3 id=\"21-修改docker-composeyml替换mysql为sql-server\">2.1 修改docker-compose.yml（替换MySQL为SQL Server）</h3>\n<pre><code class=\"language-yaml\">version: '3.8'\n\nservices:\n  # === 替换为SQL Server服务 ===\n  sqlserver:\n    image: mcr.microsoft.com/mssql/server:2022-latest  # SQL Server 2022镜像\n    container_name: multi-sqlserver  # 唯一容器名\n    restart: always\n    environment:\n      ACCEPT_EULA: \"Y\"                # 必须设置为Y，接受SQL Server许可协议\n      SA_PASSWORD: \"App@12345678\"     # SA密码（复杂度要求：至少8位，含字母+数字+特殊符号）\n      MSSQL_PID: \"Express\"            # 版本：Express（免费版，适合测试/小型项目）\n      TZ: Asia/Shanghai               # 同步时区\n    ports:\n      - \"1433:1433\"                   # SQL Server默认端口1433\n    volumes:\n      - ./sqlserver/sqlserver.conf:/var/opt/mssql/mssql.conf  # 挂载配置文件\n      - ./sqlserver/init-sqlserver.sql:/docker-entrypoint-initdb.d/init-sqlserver.sql  # 初始化SQL\n      - sqlserver-data:/var/opt/mssql  # 数据卷：持久化数据\n      - /etc/localtime:/etc/localtime:ro\n    networks:\n      - multi-service-network\n    # 健康检查：检测SQL Server是否就绪\n    healthcheck:\n      test: [\"CMD-SHELL\", \"/opt/mssql-tools/bin/sqlcmd -S localhost -U sa -P App@12345678 -Q 'SELECT 1'\"]\n      interval: 10s\n      timeout: 30s\n      retries: 10\n      start_period: 30s  # SQL Server启动较慢，延迟30秒开始检测\n\n  # === Redis服务（不变） ===\n  redis:\n    image: redis:7-alpine\n    container_name: multi-redis\n    restart: always\n    ports:\n      - \"6379:6379\"\n    volumes:\n      - redis-data:/data\n    command: redis-server --requirepass \"Redis@123456\"\n    networks:\n      - multi-service-network\n    environment:\n      TZ: Asia/Shanghai\n    healthcheck:\n      test: [\"CMD\", \"redis-cli\", \"ping\", \"-a\", \"Redis@123456\"]\n      interval: 3s\n      timeout: 10s\n      retries: 5\n\n  # === 后端1服务（仅修改连接串） ===\n  backend1:\n    image: mcr.microsoft.com/dotnet/aspnet:8.0\n    container_name: multi-backend1\n    restart: always\n    ports:\n      - \"58588:58588\"\n    depends_on:\n      sqlserver:  # 依赖改为sqlserver\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n    volumes:\n      - ./backend1/publish:/app\n      - /wwwroot/Resources1:/wwwroot/Resources\n    environment:\n      TZ: Asia/Shanghai\n      ASPNETCORE_URLS: \"http://*:58588\"\n      ASPNETCORE_ENVIRONMENT: Production\n      # 后端1的SQL Server连接串\n      ConnectionStrings__SQLServer: \"Server=sqlserver,1433;Database=app_db1;User ID=sa;Password=App@12345678;TrustServerCertificate=True;\"\n      # Redis连接串（不变）\n      ConnectionStrings__Redis: \"redis:6379,password=Redis@123456,defaultDatabase=0,ssl=false,abortConnect=false\"\n    working_dir: /app\n    entrypoint: [\"dotnet\", \"Backend1.WebHost.dll\"]\n    networks:\n      - multi-service-network\n\n  # === 后端2服务（仅修改连接串） ===\n  backend2:\n    image: mcr.microsoft.com/dotnet/aspnet:8.0\n    container_name: multi-backend2\n    restart: always\n    ports:\n      - \"58589:58589\"\n    depends_on:\n      sqlserver:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n    volumes:\n      - ./backend2/publish:/app\n      - /wwwroot/Resources2:/wwwroot/Resources\n    environment:\n      TZ: Asia/Shanghai\n      ASPNETCORE_URLS: \"http://*:58589\"\n      ASPNETCORE_ENVIRONMENT: Production\n      # 后端2的SQL Server连接串\n      ConnectionStrings__SQLServer: \"Server=sqlserver,1433;Database=app_db2;User ID=sa;Password=App@12345678;TrustServerCertificate=True;\"\n      # Redis连接串（不变）\n      ConnectionStrings__Redis: \"redis:6379,password=Redis@123456,defaultDatabase=1,ssl=false,abortConnect=false\"\n    working_dir: /app\n    entrypoint: [\"dotnet\", \"Backend2.WebHost.dll\"]\n    networks:\n      - multi-service-network\n\n  # === Nginx服务（不变） ===\n  nginx:\n    image: nginx:alpine\n    container_name: multi-nginx\n    restart: always\n    ports:\n      - \"6866:6866\"\n      - \"6867:6867\"\n    volumes:\n      - ./nginx/nginx.conf:/etc/nginx/nginx.conf\n      - ./frontend1/dist:/usr/share/nginx/html/web1\n      - ./frontend2/dist:/usr/share/nginx/html/web2\n    depends_on:\n      - backend1\n      - backend2\n    networks:\n      - multi-service-network\n    environment:\n      TZ: Asia/Shanghai\n\n# 数据卷：替换为sqlserver-data\nvolumes:\n  sqlserver-data:\n  redis-data:\n\n# 自定义网络（不变）\nnetworks:\n  multi-service-network:\n    driver: bridge\n</code></pre>\n<h3 id=\"22-后端项目修改\">2.2 后端项目修改</h3>\n<ul>\n<li>\n<p>安装SQL Server依赖包：在VS2022中，安装<code>Microsoft.EntityFrameworkCore.SqlServer</code>（适配.NET8的版本）；</p>\n</li>\n<li>\n<p>修改appsettings.json：将<code>ConnectionStrings:MySQL</code>改为<code>ConnectionStrings:SQLServer</code>，对应docker-compose.yml中的连接串；</p>\n</li>\n</ul>\n<h1 id=\"五相关参考\">五、相关参考</h1>\n<p>如果本文对你有一点点帮助，点个赞支持一下吧，你的每一个【赞】都是我创作的最大动力 _</p>\n<p>更多技术文章请往:</p>\n<p><a href=\"http://www.guosisoft.com/article\" rel=\"noopener nofollow\" target=\"_blank\">http://www.guosisoft.com/article</a></p>\n<p><a href=\"http://www.rdiframework.net/article\" rel=\"noopener nofollow\" target=\"_blank\">http://www.rdiframework.net/article</a></p>\n<p>大家一起共同交流和进步呀!!</p>\n\n\n</div>\n<div id=\"MySignature\">\n    <span style=\"font-size: 10pt;\">\n</span>\n<p>\n\t<br />\n</p>\n<p id=\"mySignature\">\n\t<span style=\"font-size: 10pt;\">作者：</span>\n\t<strong>\n\t\t<span style=\"color: red; font-size: 12px;\">\n\t\t\t<a href=\"http://www.guosisoft.com/\" target=\"_blank\">\n\t\t\t\t<span>\n\t\t\t\t\t<span style=\"font-size: 10pt;\">RDIF</span>\n\t\t\t\t</span>\n\t\t\t</a>\n\t\t</span>\n\t</strong>\n\t<br />\n\t<span style=\"font-size: 10pt;\">出处：</span>\n\t<a href=\"http://www.cnblogs.com/huyong/\" target=\"_blank\">\n\t\t<span style=\"font-size: 10pt;\">http://www.cnblogs.com/huyong/</span>\n\t</a>\n\t<br />\n\t<span style=\"font-size: 10pt;\">Email：</span>\n\t<a href=\"mailto:406590790@qq.com\" target=\"_blank\">\n\t\t<span style=\"font-size: 10pt;\">406590790@qq.com</span>\n\t</a>\n\t<br />\n\t<span style=\"font-size: 10pt;\">QQ：</span>\n\t<span style=\"font-size: 10pt;\">406590790</span>\n\t<br />\n\t<span style=\"font-size: 10pt;\">微信：</span>\n\t<span style=\"font-size: 10pt;\">13005007127(同手机号)</span>\n\t<br />\n\t<span style=\"font-size: 10pt;\">框架官网：</span>  \n   <a href=\"http://www.guosisoft.com/\" target=\"_blank\">\n\t\t<span style=\"font-size: 10pt;\">http://www.guosisoft.com/</span>\n\t</a>\n  &nbsp;&nbsp;&nbsp;\n\t<a href=\"http://www.rdiframework.net/\" target=\"_blank\">\n\t\t<span style=\"font-size: 10pt;\">http://www.rdiframework.net/</span>\n\t</a>\n\t<br />\n\t<span style=\"font-size: 10pt;\">框架其他博客：</span>\n\t<a href=\"http://blog.csdn.net/chinahuyong\" target=\"_blank\">\n\t\t<span style=\"font-size: 10pt;\">http://blog.csdn.net/chinahuyong</span>\n\t</a>\n\t<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n\t<a href=\"http://www.cnblogs.com/huyong\" target=\"_blank\">\n\t\t<span style=\"font-size: 10pt;\">http://www.cnblogs.com/huyong</span>\n\t</a>\n\t<br />\n\t<a href=\"http://www.guosisoft.com/\" target=\"_blank\">\n\t\t<span style=\"font-size: 10pt;\">国思RDIF开发框架</span>\n\t</a>，\n\t<span style=\"font-size: 10pt; color: #FFFFFF; background-color: #009900;\">给用户和开发者最佳的.Net框架平台方案，为企业快速构建跨平台、企业级的应用提供强大支持。</span>\n\t<br />\n\t<span style=\"font-size: 10pt;\">关于作者：系统架构师、信息系统项目管理师、DBA。专注于微软平台项目架构、管理和企业解决方案，多年项目开发与管理经验，曾多次组织并开发多个大型项目，在面向对象、面向服务以及数据库领域有一定的造诣。现主要从事基于</span>\n\t<a href=\"http://www.guosisoft.com/\" target=\"_blank\">\n\t\t<span style=\"font-size: 10pt;\">RDIF</span>\n\t</a>\n\t<span style=\"font-size: 10pt;\">框架的技术开发、咨询工作，主要服务于金融、医疗卫生、铁路、电信、物流、物联网、制造、零售等行业。</span>\n\t<br />\n\t<span style=\"font-size: 10pt;\">如有问题或建议，请多多赐教！</span>\n\t<br />\n\t<span style=\"font-size: 10pt;\">本文版权归作者和CNBLOGS博客共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，如有问题，可以通过微信、邮箱、QQ等联系我，非常感谢。</span>\n</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-12 10:44</span>&nbsp;\n<a href=\"https://www.cnblogs.com/huyong\">.NET快速开发框架</a>&nbsp;\n阅读(<span id=\"post_view_count\">63</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "AI到底聪明在哪——从手机人脸识别说起",
      "link": "https://www.cnblogs.com/wmyskxz/p/19607323",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wmyskxz/p/19607323\" id=\"cb_post_title_url\" title=\"发布于 2026-02-12 10:40\">\n    <span>AI到底聪明在哪——从手机人脸识别说起</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>这是 <strong>「AI是怎么回事」</strong> 系列的第 <code>1</code> 篇。我一直很好奇 AI 到底是怎么工作的，于是花了很长时间去拆这个东西——手机为什么换了发型还能认出你，ChatGPT 回答你的那三秒钟里究竟在算什么，AI 为什么能通过律师考试却会一本正经地撒谎。这个系列就是我的探索笔记，发现了很多有意思的东西，想分享给你。觉得不错的话，欢迎分享+关注。</p>\n</blockquote>\n<p><img alt=\"\" src=\"https://wmyskxz-blog.oss-cn-chengdu.aliyuncs.com/img20260211115803.png\" /></p>\n<p>每天早上，你拿起手机，看一眼屏幕，解锁。</p>\n<p>整个过程不到一秒。你从来没想过这件事有什么特别的。</p>\n<p>不过你可能注意过一个奇怪的事：在几年前，戴上口罩，手机往往就不认识你了。但换了个发型，它照样能解锁。为什么？</p>\n<p>先别急着回答。要理解这件事，我们得先搞清楚一个更基本的问题：<strong>手机到底是怎么\"人脸识别\"的？</strong></p>\n<p>答案要从一个让人意外的事实说起——</p>\n<p><strong>你的手机看到的不是一张脸，而是一堆数字。</strong></p>\n<h1 id=\"电脑眼中的照片\">电脑眼中的照片</h1>\n<p>要理解手机怎么\"人脸识别\"，得先回答一个基本问题：<strong>电脑看到的\"照片\"长什么样？</strong></p>\n<p>一张照片是由很多个小点组成的，这些小点叫<strong>像素</strong>——你把手机照片放大再放大，就能看到一个个小方块，那就是像素。一张 1000×1000 的照片，就有 100 万个像素。</p>\n<p><img alt=\"用自己的壁纸放大演示\" src=\"https://wmyskxz-blog.oss-cn-chengdu.aliyuncs.com/imgPixPin_2026-02-11_13-11-59_compressed.gif\" /></p>\n<p>每个像素都有一个颜色，而颜色在电脑里是用数字表示的。</p>\n<p>最简单的情况是黑白照片：纯黑是 0，纯白是 255，中间的灰色就是 1 到 254。数字越小越暗，越大越亮。</p>\n<p>比如下面这个 5×5 的小图：</p>\n<p><img alt=\"\" src=\"https://wmyskxz-blog.oss-cn-chengdu.aliyuncs.com/img20260211132858.png\" /></p>\n<p>在电脑里，它就是这样一张表格：</p>\n<pre><code>  0   0  200   0   0\n  0   0  200   0   0\n200 200  200 200 200\n  0   0  200   0   0\n  0   0  200   0   0\n</code></pre>\n<p>0 是黑色，200 是亮色（接近白色）。你能看出来这是一个十字形吗？——中间一横一竖的数字是 200（亮），其余全是 0（暗）。</p>\n<p><strong>这就是电脑\"看到\"的东西。不是图像，是数字。</strong></p>\n<p>彩色照片稍微复杂一点：每个像素需要三个数字，分别表示红色、绿色、蓝色的强度（也是 0 到 255）。但原理完全一样——归根到底还是数字。</p>\n<p>所以当你拿手机对着自己的脸，手机\"看到\"的是这样的东西：</p>\n<pre><code>142  98  87 134 156 178 ...\n 78  45  52  89 123 145 ...\n134 167 189 201 178 156 ...\n... (几百万个数字)\n</code></pre>\n<p><strong>手机要做的事情是：看这几百万个数字，判断\"这是不是主人的脸\"。</strong></p>\n<p>一堆数字，怎么可能认出一张脸？</p>\n<h1 id=\"第一个线索边缘\">第一个线索：边缘</h1>\n<p>什么是边缘？就是照片里颜色突然变化的地方。</p>\n<p><img alt=\"这个图的边缘就很明显，都是黑色线框\" src=\"https://wmyskxz-blog.oss-cn-chengdu.aliyuncs.com/img20260211133810.png\" /></p>\n<p>比如你的脸和背景之间——皮肤是浅色的，背景可能是深色的，这就形成了一条边缘，也就是你脸的轮廓。眼睛也是：眼白是浅色的，瞳孔是深色的，这也是边缘。</p>\n<p><strong>边缘勾勒出了图片里\"有东西\"的地方。</strong> 找到了边缘，你就找到了轮廓、五官、表情——这些让一张脸变得独特的要素。</p>\n<p>但电脑只看到数字啊，它不知道什么是\"脸\"、什么是\"眼睛\"。它怎么找到边缘？</p>\n<p>答案让我很惊讶：<strong>只用简单的加减乘除就能做到。</strong></p>\n<p>让我用一个具体例子来演示。</p>\n<h1 id=\"一道简单的数学题\">一道简单的数学题</h1>\n<p>假设我们有一小块图片，就 9 个像素，排成 3×3：</p>\n<pre><code>10  10  10\n10  10 200\n10 200 200\n</code></pre>\n<p>左上角是深色（数字 10，接近黑色），右下角是浅色（数字 200，接近白色）。中间有一条从左上到右下的分界线——这就是一条边缘。</p>\n<p>现在我用一个\"检测器\"来扫描它。所谓检测器，就是一组数字组成的小模板——把它叠到图片上，就能检测出图片里有没有某种特征。这个检测器也是 9 个数字：</p>\n<pre><code>-1  0  1\n-2  0  2\n-1  0  1\n</code></pre>\n<p>这个检测器有个名字，叫 <strong>Sobel 算子</strong>（\"算子\"就是\"计算工具\"的意思）。它专门用来检测垂直方向的边缘。为什么这几个数字能检测边缘？先看看它怎么用，你很快就会明白。</p>\n<p>怎么用呢？<strong>把检测器叠放到图片上，对应位置的数字相乘，然后全部加起来。</strong></p>\n<p>让我一步一步算给你看：</p>\n<pre><code>图片:          检测器:\n10  10  10     -1  0  1\n10  10 200     -2  0  2\n10 200 200     -1  0  1\n\n对应位置相乘，然后全部相加：\n(10×-1) + (10×0) + (10×1) +\n(10×-2) + (10×0) + (200×2) +\n(10×-1) + (200×0) + (200×1)\n\n= -10 + 0 + 10 +\n  -20 + 0 + 400 +\n  -10 + 0 + 200\n\n= 570\n</code></pre>\n<p>结果是 570，一个很大的正数。</p>\n<p><strong>这个数字的意思是：这里有一条明显的边缘，从左到右颜色在变亮。</strong> 数字越大，说明边缘越明显。</p>\n<p>如果我们换一块颜色完全相同、没有边缘的区域呢？</p>\n<pre><code>图片:          检测器:\n100 100 100    -1  0  1\n100 100 100    -2  0  2\n100 100 100    -1  0  1\n\n计算：\n(100×-1) + (100×0) + (100×1) +\n(100×-2) + (100×0) + (100×2) +\n(100×-1) + (100×0) + (100×1)\n\n= -100 + 0 + 100 +\n  -200 + 0 + 200 +\n  -100 + 0 + 100\n\n= 0\n</code></pre>\n<p>结果是 0。<strong>没有边缘。</strong></p>\n<p>你看，完全不需要知道什么是\"脸\"、什么是\"眼睛\"，只用加减乘除，就能找到图片里颜色变化的地方。</p>\n<p>实际使用时，这个检测器会在整张图片上一格一格地滑动，对每个位置都做一次这样的计算。这样就能得到一张新的\"边缘地图\"——原图中每个位置的数字，变成了\"这个位置有没有边缘\"的数字。数字大的地方，就是边缘。</p>\n<p><strong>这就是电脑\"看\"图片的第一步：找到所有颜色突变的位置。</strong></p>\n<h1 id=\"为什么这个检测器能工作\">为什么这个检测器能工作？</h1>\n<p>你可能会好奇：<code>-1, 0, 1, -2, 0, 2, -1, 0, 1</code> 这几个数字是怎么来的？为什么这样排列就能检测边缘？</p>\n<p>让我解释一下它的逻辑。</p>\n<p>仔细看这个检测器的结构：<strong>左边一列全是负数，右边一列全是正数，中间一列全是 0。</strong></p>\n<pre><code>-1  0  1\n-2  0  2\n-1  0  1\n</code></pre>\n<p>当它扫描图片的一个区域时，实际上在做这件事：</p>\n<ul>\n<li><strong>右边像素的亮度 × 正数</strong>（加分）</li>\n<li><strong>左边像素的亮度 × 负数</strong>（减分）</li>\n<li><strong>中间像素 × 0</strong>（不影响结果）</li>\n</ul>\n<p>所以最终的结果，本质上就是：<strong>右边的亮度 - 左边的亮度。</strong></p>\n<p><img alt=\"\" src=\"https://wmyskxz-blog.oss-cn-chengdu.aliyuncs.com/img20260211140537.png\" /></p>\n<ul>\n<li>如果左右两边颜色一样——正数和负数互相抵消，结果是 0（没有边缘）</li>\n<li>如果右边比左边亮——正数那边贡献更大，结果是正数（有一条从暗到亮的边缘）</li>\n<li>如果左边比右边亮——负数那边贡献更大，结果是负数（有一条从亮到暗的边缘）</li>\n</ul>\n<p><strong>差异越大，结果的数字越大（不管是正还是负），说明边缘越明显。</strong></p>\n<p>至于中间那列的系数（-2, 0, 2）比两侧的（-1, 0, 1）更大，是为了让检测器更关注正中间一行的变化，让检测结果更稳定。</p>\n<p>这个设计很聪明，但也很简单——本质就是\"比较左右两边的亮度差\"。</p>\n<p>顺便说一下这个检测器的来历：Sobel 算子是 <a href=\"https://en.wikipedia.org/wiki/Sobel_operator\" rel=\"noopener nofollow\" target=\"_blank\">1968 年由 Irwin Sobel 和 Gary Feldman 在斯坦福人工智能实验室的一次演讲中提出的</a>，至今已经用了半个多世纪。</p>\n<p>但你可能已经发现了一个问题：<strong>这个检测器只能找到垂直方向的边缘（左右亮度差）。如果边缘是水平的（上下亮度差）呢？</strong></p>\n<p>很简单——把检测器旋转 90°：</p>\n<pre><code>-1  -2  -1\n 0   0   0\n 1   2   1\n</code></pre>\n<p>看出来了吗？现在<strong>上面一行全是负数，下面一行全是正数，中间一行全是 0。</strong> 原理完全一样，只是方向变了：它比较的是\"下面的亮度 - 上面的亮度\"。</p>\n<ul>\n<li>如果上下颜色一样——结果是 0（没有水平边缘）</li>\n<li>如果下面比上面亮——结果是正数（有一条水平边缘）</li>\n</ul>\n<p>两个检测器配合使用——一个管左右，一个管上下——就能找到图片中任意方向的边缘。哪怕是一条 45° 的斜线，也会同时在左右和上下两个方向上产生亮度差，两个检测器都会给出非零结果。把两个结果综合起来，就能得到每个位置的\"边缘强度\"和\"边缘方向\"。</p>\n<h1 id=\"从边缘到形状ai-卡了几十年\">从边缘到形状：AI 卡了几十年</h1>\n<p>找到边缘之后呢？</p>\n<p>1968 年的 Sobel 算子能找到边缘，但边缘只是一堆线条。一堆线条还不能告诉我们\"这是一张脸\"。</p>\n<p><img alt=\"\" src=\"https://wmyskxz-blog.oss-cn-chengdu.aliyuncs.com/img20260211170203.png\" /></p>\n<p><strong>这就是 AI 在\"看\"这件事上卡住了几十年的地方。</strong></p>\n<p>科学家们尝试了很多方法：</p>\n<ul>\n<li>有人试着写规则：\"如果有两个圆形在上面，一个三角形在中间，下面有一条横线，那可能是一张脸\"</li>\n<li>有人试着提取更复杂的特征：\"检测眼睛的形状\"、\"测量鼻子的位置\"</li>\n</ul>\n<p>但这些方法都撞上了同一堵墙：<strong>需要人类告诉电脑什么是\"眼睛\"、什么是\"鼻子\"。</strong></p>\n<p>一个人的脸可以有无数种表情、无数种角度、无数种光线。侧脸怎么办？戴帽子怎么办？只露出半张脸怎么办？</p>\n<p>你怎么可能把所有情况都写成规则？</p>\n<p><strong>规则越写越多，但永远覆盖不了真实世界的复杂性。</strong></p>\n<p>这个困境持续了几十年，直到一个想法改变了一切：</p>\n<p><strong>不要人类来设计检测器，让电脑自己学。</strong></p>\n<h1 id=\"核心突破让电脑自己学\">核心突破：让电脑自己学</h1>\n<p>还记得前面的 Sobel 算子吗？</p>\n<pre><code>-1  0  1\n-2  0  2\n-1  0  1\n</code></pre>\n<p>这 9 个数字是人类设计的。人类知道\"要检测垂直边缘，就要比较左右两边的亮度\"，所以选择了这样的数字组合。</p>\n<p><strong>但如果让电脑自己来选呢？</strong></p>\n<p>假设我们不再指定这 9 个数字，而是把它们变成\"空的\"——可以填入任何数值：</p>\n<pre><code>?  ?  ?\n?  ?  ?\n?  ?  ?\n</code></pre>\n<p>一开始，随机填一组数字，比如：</p>\n<pre><code>0.1  -0.3   0.5\n0.2   0.1  -0.4\n0.3   0.2   0.1\n</code></pre>\n<p>用这个随机检测器去扫描图片，结果肯定是乱七八糟的。</p>\n<p><strong>但如果我们告诉电脑\"正确答案\"呢？</strong></p>\n<p>就像老师批改作业一样。我们先用一个更简单的任务来说明这个过程——区分猫和狗。别担心，人脸识别的学习过程完全一样。</p>\n<p>给电脑看 1000 张猫的照片和 1000 张狗的照片，每张都贴好标签——\"这是猫\"、\"这是狗\"。</p>\n<p>电脑用随机检测器算出一个结果，和正确答案对比：</p>\n<ul>\n<li>如果猜对了——不错，保持</li>\n<li>如果猜错了——<strong>调整那 9 个数字</strong>，让下次更可能猜对</li>\n</ul>\n<p>怎么调整？不是随机乱调，而是有一套精巧的方法能算出每个数字该往大了调还是往小了调。这个方法叫\"反向传播\"，我后面会专门讲。现在你只需要知道：电脑有办法算出调整的方向和幅度。</p>\n<p>重复这个过程几百万次。</p>\n<p><strong>神奇的事情发生了：那些原本随机的数字，会自己变成有意义的检测器。</strong></p>\n<p>有的变成了边缘检测器（类似 Sobel 算子——电脑自己\"发明\"了类似的东西）。<br />\n有的变成了颜色变化检测器。<br />\n有的变成了纹理检测器。<br />\n还有一些，检测的东西连人类都说不清楚——但它们确实对区分猫和狗有用。</p>\n<p><strong>电脑没有被告知\"要检测边缘\"。它自己发现了\"检测边缘有助于区分猫和狗\"。</strong></p>\n<p>这就是\"学习\"的本质：不是有人教了它规则，而是它从大量的对错反馈中，自己找到了有用的规律。</p>\n<h1 id=\"叠加从线条到人脸\">叠加：从线条到人脸</h1>\n<p>但一层检测器还不够。</p>\n<p>一个边缘检测器只能告诉你\"这里有一条线\"，不能告诉你\"这是一只眼睛\"。</p>\n<p><strong>解决方法是：叠加很多层。</strong></p>\n<p>想象这样一个过程：</p>\n<ul>\n<li><strong>第一层检测器</strong>：从原始像素中找到各种边缘——横线、竖线、斜线、曲线</li>\n<li><strong>第二层检测器</strong>：把第一层找到的边缘组合起来，识别简单形状——圆形、三角形、弧线</li>\n<li><strong>第三层检测器</strong>：把形状组合成部件——眼睛（两条弧线围成的椭圆）、鼻子（一个三角形轮廓）、嘴巴（两条曲线）</li>\n<li><strong>第四层检测器</strong>：把部件组合成整体——人脸、猫脸、汽车</li>\n</ul>\n<pre><code>像素 → 边缘 → 形状 → 部件 → 整体\n</code></pre>\n<p><img alt=\"\" src=\"https://wmyskxz-blog.oss-cn-chengdu.aliyuncs.com/img20260211170239.png\" /></p>\n<p>每一层都是在上一层的基础上，检测更复杂的东西。第一层只能看到线条，但叠加四五层之后，就能看到\"脸\"了。</p>\n<p><strong>这就是\"深度学习\"里\"深度\"的含义——很多层检测器叠加在一起。</strong> 层数越多，能识别的东西就越复杂。</p>\n<p>这种\"很多层检测器叠加\"的结构，有一个名字，叫<strong>神经网络</strong>。之所以叫这个名字，是因为它的工作方式有点像人脑中的神经元——每个神经元接收信号、处理一下、再传给下一个。</p>\n<p><img alt=\"\" src=\"https://wmyskxz-blog.oss-cn-chengdu.aliyuncs.com/img20260211171257.png\" /></p>\n<p>这个类比最早来自 <a href=\"https://en.wikipedia.org/wiki/Artificial_neuron\" rel=\"noopener nofollow\" target=\"_blank\">1943 年 McCulloch 和 Pitts 的论文</a>，他们第一次用数学来描述神经元的工作方式。不过你不需要把这个类比想得太深——它只是一种\"层层传递、层层加工\"的计算结构。层数很多的神经网络，就叫\"深度神经网络\"，用它来学习的方法，就是\"深度学习\"。</p>\n<p>而关键是：<strong>每一层的检测器里的数字，都不是人类设计的，是电脑自己从数据里学出来的。</strong></p>\n<p>2012 年，神经网络研究的先驱 Geoffrey Hinton 的学生 Alex Krizhevsky 用这种\"多层叠加\"的方法做了一个图像识别程序，取名 <a href=\"https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks\" rel=\"noopener nofollow\" target=\"_blank\">AlexNet</a>（Alex 的网络）。它有 8 层。其中前 5 层做的就是我们前面演示的操作——用检测器在图片上滑动、对应位置相乘再相加（这个操作的专业名称叫\"卷积\"，所以这几层叫\"卷积层\"）。后 3 层负责把前面提取到的所有信息汇总起来做最终判断（叫\"全连接层\"——你可以把它想象成\"汇总投票\"，把所有检测器发现的信息都汇集在一起，综合判断最终结果）。</p>\n<p>整个网络包含 <a href=\"https://en.wikipedia.org/wiki/AlexNet\" rel=\"noopener nofollow\" target=\"_blank\">6000 万个可调整的数字</a>。这些可调整的数字，在 AI 领域有一个专门的名称，叫\"参数\"。AlexNet 的 6000 万个参数震惊了整个计算机视觉领域。而今天的大型模型，动辄几十层、上百层，参数量更是以亿计。</p>\n<h1 id=\"训练电脑怎么知道该往哪调\">训练：电脑怎么知道该往哪调？</h1>\n<p>你可能还记得前面留下的那个问题：猜错的时候，电脑怎么知道该把那些数字往大了调还是往小了调？</p>\n<p>这是整个系统最精巧的部分，叫做<strong>反向传播</strong>——<a href=\"https://www.nature.com/articles/323533a0\" rel=\"noopener nofollow\" target=\"_blank\">1986 年由 Rumelhart、Hinton 和 Williams 发表在《Nature》（全球最权威的科学期刊之一）上的一篇论文</a>奠定了这个方法的基础。</p>\n<p>让我用一个简化的例子来说明。</p>\n<p>假设电脑要判断一张图是猫还是狗。经过层层计算，它输出\"60% 可能是猫\"，但正确答案是\"狗\"。</p>\n<p>它错了。错了多少？差了很多——它说 60% 是猫，但应该是 0%。</p>\n<p><strong>反向传播做的事情是：从最后的错误出发，一层一层往回追溯，算出每一个数字对这个错误的\"贡献\"有多大。</strong></p>\n<p>就像考试之后对答案：</p>\n<ul>\n<li>最终结果错了</li>\n<li>是因为最后一步的某个数字偏了</li>\n<li>那个数字偏了，是因为上一层的某个检测器输出偏了</li>\n<li>那个检测器偏了，是因为里面的某个数字该大一点</li>\n</ul>\n<p>电脑会计算：如果某个检测器里的某个数字<strong>稍微变大一点</strong>，最终的错误会<strong>变大还是变小</strong>？</p>\n<ul>\n<li>如果变小——好，把那个数字<strong>调大一点</strong></li>\n<li>如果变大——反过来，把那个数字<strong>调小一点</strong></li>\n</ul>\n<p>每次调整的幅度都很小（比如 0.001），但对所有数字同时做这种微调，重复几百万次之后，那些数字就会逐渐稳定下来，到达一个\"很少出错\"的状态。</p>\n<p><strong>这就是\"训练\"。</strong></p>\n<p>一个现代的人脸识别模型可能有几百万到上亿个参数。比如 Google 在 2015 年发表的 <a href=\"https://arxiv.org/abs/1503.03832\" rel=\"noopener nofollow\" target=\"_blank\">FaceNet</a>，旗舰模型超过 1 亿个参数，在人脸识别领域常用的测试集 <a href=\"https://vis-www.cs.umass.edu/lfw/\" rel=\"noopener nofollow\" target=\"_blank\">LFW</a>（Labeled Faces in the Wild，从互联网上收集的真实场景人脸照片，包含 5749 个人的 13000 多张照片）上达到了 <a href=\"https://arxiv.org/abs/1503.03832\" rel=\"noopener nofollow\" target=\"_blank\">99.63% 的准确率</a>。训练这样一个模型，需要给电脑看几百万张人脸照片，每一张都要把所有参数调整一遍。</p>\n<p>这需要大量的计算。</p>\n<h1 id=\"为什么-2012-年才成功\">为什么 2012 年才成功？</h1>\n<p>你可能会好奇：如果\"让电脑自己学\"这个想法这么好，为什么没有更早实现？</p>\n<p>事实上，神经网络的概念在 1940 年代就有了，反向传播算法在 <a href=\"https://www.nature.com/articles/323533a0\" rel=\"noopener nofollow\" target=\"_blank\">1986 年就发表了</a>。</p>\n<p><strong>那为什么到 2012 年才突然成功？</strong></p>\n<p>因为三个条件终于同时凑齐了：</p>\n<p><strong>1. 数据</strong></p>\n<p>2009 年，斯坦福大学的李飞飞教授团队发布了 <a href=\"https://www.image-net.org/static_files/papers/imagenet_cvpr09.pdf\" rel=\"noopener nofollow\" target=\"_blank\">ImageNet 数据集</a>。最终这个数据集包含了超过 <a href=\"https://en.wikipedia.org/wiki/ImageNet\" rel=\"noopener nofollow\" target=\"_blank\">1400 万张标注好的图片</a>，涵盖 2 万多个类别。</p>\n<p><img alt=\"\" src=\"https://wmyskxz-blog.oss-cn-chengdu.aliyuncs.com/img20260211172150.png\" /></p>\n<p>\"标注好\"的意思是：每张图片都有人告诉你\"这是猫\"、\"这是狗\"、\"这是汽车\"。这些\"正确答案\"是电脑学习的前提——没有答案，就无法判断对错，也就无法调整那些数字。</p>\n<p>在此之前，没有人花这么大力气去收集和标注这么多图片。为了建成 ImageNet，李飞飞团队通过亚马逊的众包平台（一种把任务拆成小块、分给大量网上工人完成的平台），动用了来自 167 个国家的近 <a href=\"https://qz.com/1034972/the-data-that-changed-the-direction-of-ai-research-and-possibly-the-world\" rel=\"noopener nofollow\" target=\"_blank\">5 万名标注工人</a>，从 1.6 亿张候选图片中筛选和标注。</p>\n<p><strong>2. 算力</strong></p>\n<p>训练一个模型，需要对几百万张图片、几千万个参数反复做计算。用普通电脑的 CPU（中央处理器，电脑的\"大脑\"，擅长一件一件地处理复杂任务），这可能要算好几个月甚至几年。</p>\n<p>2012 年的突破用了一个聪明的办法：<strong>用游戏显卡（GPU，Graphics Processing Unit，图形处理器）来算。</strong></p>\n<p><img alt=\"\" src=\"https://wmyskxz-blog.oss-cn-chengdu.aliyuncs.com/img20260211172426.png\" /></p>\n<p>GPU 原本是用来生成（渲染）游戏画面的。游戏画面需要同时计算屏幕上几百万个像素的颜色，所以 GPU 特别擅长\"同时做很多简单的计算\"。</p>\n<p>而训练神经网络恰好也是这种活——对几百万个数字做大量简单的乘法和加法。</p>\n<p>2009 年，斯坦福的吴恩达（Andrew Ng）团队就发表了一篇论文，证明在特定任务上，<a href=\"https://robotics.stanford.edu/~ang/papers/icml09-LargeScaleUnsupervisedDeepLearningGPU.pdf\" rel=\"noopener nofollow\" target=\"_blank\">GPU 训练神经网络比 CPU 快约 70 倍</a>。</p>\n<p>Alex Krizhevsky 正是用两块游戏显卡（<a href=\"https://videocardz.com/nvidia/geforce-500/geforce-gtx-580\" rel=\"noopener nofollow\" target=\"_blank\">NVIDIA GTX 580，当时售价 499 美元</a>），花了大约 5-6 天，训练出了 AlexNet。</p>\n<p><strong>3. 算法</strong></p>\n<p>AlexNet 还用了几个关键的技术改进。比如，一种让深层网络更容易训练的数学技巧（叫 ReLU），以及一种防止网络\"死记硬背\"训练数据的方法（叫 Dropout——随机\"关掉\"一部分检测器，逼网络学到更通用的规律，而不是死记每张图的细节）。这些技术让更深的网络变得可训练。</p>\n<p><strong>三个条件——海量数据、GPU 算力、算法改进——同时到位，才有了 2012 年的突破。</strong></p>\n<p>那次突破有多震撼？在 ImageNet 图像识别比赛中，AlexNet 将错误率从同年第二名的 <a href=\"https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks\" rel=\"noopener nofollow\" target=\"_blank\">26.2% 直接降到了 15.3%</a>（这里的\"错误率\"叫 top-5 错误率——给电脑 5 次机会猜图片内容，5 次都猜错才算错）——领先超过 10 个百分点。打个比方：所有人都在 74 分左右竞争，突然有人考了 85 分。</p>\n<h1 id=\"回到手机人脸识别\">回到手机人脸识别</h1>\n<p><img alt=\"\" src=\"https://wmyskxz-blog.oss-cn-chengdu.aliyuncs.com/img20260211172705.png\" /></p>\n<p>现在你知道手机是怎么认出你的了。</p>\n<p>让我把完整的过程串起来：</p>\n<ol>\n<li><strong>采集面部数据</strong>：手机用摄像头和传感器采集你的面部信息，变成几百万个数字（说明一下：现代手机的人脸解锁不只靠普通摄像头——比如 iPhone 的 Face ID 会用红外线在你脸上投射上万个不可见的小点，测量脸的立体形状，这样就不会被一张照片骗过去。但核心识别原理——把采集到的数据变成数字、层层提取特征——和我们前面讲的完全一样）</li>\n<li><strong>层层检测</strong>：这些数字经过很多层检测器——第一层找边缘，第二层找形状，第三层找五官部件，层层叠加</li>\n<li><strong>提取特征</strong>：最后一层输出一组数字——你可以把它理解为你这张脸的\"数字指纹\"（专业术语叫\"特征向量\"，就是一串能代表你长相特征的数字）</li>\n<li><strong>比较</strong>：把这个数字指纹和你第一次录入时存下的数字指纹做比较</li>\n<li><strong>判断</strong>：如果两组数字足够接近——解锁</li>\n</ol>\n<p><strong>整个过程没有任何\"理解\"。</strong></p>\n<p>手机不知道什么是眼睛、什么是鼻子。它只是在做加减乘除：把像素变成边缘，把边缘变成形状，把形状变成部件，把部件变成一组代表你这张脸的数字，然后比较两组数字有多接近。</p>\n<p>那些检测器里的数字，是从几百万张人脸照片中\"学\"出来的。没有人告诉电脑\"要检测眼睛\"，它自己在反复的\"猜对了/猜错了\"中发现了某些数字组合对区分不同人脸特别有用。</p>\n<p><strong>这就是 AI 的\"聪明\"：不是真的理解，而是从海量数据中找到了反复出现的模式——比如\"眼睛区域的像素通常呈现这样的数字组合\"。</strong></p>\n<p>现在可以回答文章开头的那个问题了：为什么戴口罩手机就不认识你，但换发型还能认出来？</p>\n<p>因为口罩遮住了脸的下半部分——嘴巴、下巴这些区域的面部特征被口罩挡住了，检测器提取出来的数字指纹和你录入时的差太远了。而发型属于脸的外围，检测器关注的主要是五官区域的特征——发型变了，但眼睛、鼻梁这些区域的数字模式没变，所以还能匹配上。</p>\n<p>不过你可能发现了，现在一些新手机即使戴口罩也能解锁——那是因为厂商后来专门用大量戴口罩的照片重新训练了模型，让检测器学会了只靠眼睛和眉毛区域的特征来识别你。</p>\n<h1 id=\"一个新的问题\">一个新的问题</h1>\n<p>理解了 AI 怎么\"认人\"之后，我产生了一个新的疑问：</p>\n<p>AI 能\"看\"了——图片在它眼里是数字矩阵，它通过层层检测器从数字中提取特征。</p>\n<p><strong>但文字呢？</strong></p>\n<p>当你对 ChatGPT 说\"苹果\"，它\"看到\"的是什么？不是一个水果的画面，不是咬一口的味道——那它\"看到\"的是什么？</p>\n<p>文字怎么变成数字？AI 又怎么\"理解\"这些数字的意思？</p>\n<p>下一篇，我们来聊这个问题。你会看到一个让我非常震撼的例子：\"国王\"减去\"男人\"，加上\"女人\"，等于什么？</p>\n<h1 id=\"参考资料\">参考资料</h1>\n<ol>\n<li><a href=\"https://en.wikipedia.org/wiki/Sobel_operator\" rel=\"noopener nofollow\" target=\"_blank\">Sobel operator - Wikipedia</a> — Sobel 算子由 Irwin Sobel 和 Gary Feldman 于 1968 年在斯坦福人工智能实验室提出</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Artificial_neuron\" rel=\"noopener nofollow\" target=\"_blank\">A logical calculus of the ideas immanent in nervous activity - McCulloch &amp; Pitts (1943)</a> — 第一个神经元数学模型，\"神经网络\"名称的起源</li>\n<li><a href=\"https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks\" rel=\"noopener nofollow\" target=\"_blank\">ImageNet Classification with Deep Convolutional Neural Networks - Krizhevsky, Sutskever, Hinton (2012)</a> — AlexNet 论文，8 层网络，6000 万参数，top-5 错误率 15.3%</li>\n<li><a href=\"https://en.wikipedia.org/wiki/AlexNet\" rel=\"noopener nofollow\" target=\"_blank\">AlexNet - Wikipedia</a> — AlexNet 架构细节与参数量</li>\n<li><a href=\"https://arxiv.org/abs/1503.03832\" rel=\"noopener nofollow\" target=\"_blank\">FaceNet: A Unified Embedding for Face Recognition and Clustering - Schroff, Kalenichenko, Philbin (2015)</a> — Google 的人脸识别模型，LFW 准确率 99.63%</li>\n<li><a href=\"https://vis-www.cs.umass.edu/lfw/\" rel=\"noopener nofollow\" target=\"_blank\">Labeled Faces in the Wild</a> — LFW 人脸识别测试集官方页面</li>\n<li><a href=\"https://www.nature.com/articles/323533a0\" rel=\"noopener nofollow\" target=\"_blank\">Learning representations by back-propagating errors - Rumelhart, Hinton, Williams (1986)</a> — 反向传播算法的奠基论文，发表于 Nature</li>\n<li><a href=\"https://www.image-net.org/static_files/papers/imagenet_cvpr09.pdf\" rel=\"noopener nofollow\" target=\"_blank\">ImageNet: A Large-Scale Hierarchical Image Database - Deng, Dong, Socher, Li, Li, Fei-Fei (2009)</a> — ImageNet 数据集论文，超过 1400 万张标注图片</li>\n<li><a href=\"https://qz.com/1034972/the-data-that-changed-the-direction-of-ai-research-and-possibly-the-world\" rel=\"noopener nofollow\" target=\"_blank\">The data that transformed AI research — and possibly the world - Quartz</a> — ImageNet 的建设过程，49000 名标注工人来自 167 个国家</li>\n<li><a href=\"https://robotics.stanford.edu/~ang/papers/icml09-LargeScaleUnsupervisedDeepLearningGPU.pdf\" rel=\"noopener nofollow\" target=\"_blank\">Large-scale Deep Unsupervised Learning using Graphics Processors - Raina, Madhavan, Ng (2009)</a> — GPU 训练神经网络比 CPU 快约 70 倍</li>\n<li><a href=\"https://videocardz.com/nvidia/geforce-500/geforce-gtx-580\" rel=\"noopener nofollow\" target=\"_blank\">NVIDIA GeForce GTX 580 - VideoCardz</a> — GTX 580 于 2010 年 11 月发布，建议零售价 $499</li>\n</ol>\n<h1 id=\"订阅\">订阅</h1>\n<p>如果觉得有意思，欢迎关注我，后续文章也会持续更新。同步更新在<a href=\"https://www.wmyskxz.cn/\" rel=\"noopener nofollow\" target=\"_blank\">个人博客</a>和<a href=\"https://weixin.sogou.com/weixin?type=1&amp;s_from=input&amp;query=wmyskxz&amp;ie=utf8&amp;_sug_=n&amp;_sug_type_=&amp;w=01019900&amp;sut=1861&amp;sst0=1612590375262&amp;lkt=8%2C1612590373961%2C1612590375161\" rel=\"noopener nofollow\" target=\"_blank\">微信公众号</a></p>\n<p>微信搜索\"我没有三颗心脏\"或者扫描二维码，即可订阅。</p>\n<p><img alt=\"\" src=\"https://wmyskxz-blog.oss-cn-chengdu.aliyuncs.com/img202211052051027.png\" /></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-12 10:40</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wmyskxz\">我没有三颗心脏</a>&nbsp;\n阅读(<span id=\"post_view_count\">69</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "为每个同事部署一个 OpenClaw，安全快速的体验 OpenClaw的魅力",
      "link": "https://www.cnblogs.com/xguo/p/19607199",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xguo/p/19607199\" id=\"cb_post_title_url\" title=\"发布于 2026-02-12 10:20\">\n    <span>为每个同事部署一个 OpenClaw，安全快速的体验 OpenClaw的魅力</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"为每个同事部署一个 OpenClaw，安全快速的体验 OpenClaw的魅力\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/57355/202602/57355-20260212101930780-112933356.png\" />\n        最快速度拉起 OpenClaw（Clawdbot, Moltbot）。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"agent-sandbox部署神器为你公司每个同事部署一个openclawclawdbot-moltbot快速体验openclawclawdbot-moltbot的魅力\">Agent-Sandbox部署神器，为你公司每个同事部署一个OpenClaw（Clawdbot, Moltbot），快速体验OpenClaw（Clawdbot, Moltbot）的魅力</h1>\n<p>名字变迁：Clawdbot -&gt; Moltbot -&gt; OpoenClaw</p>\n<p>用到的工具：<a href=\"https://github.com/agent-sandbox/agent-sandbox\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/agent-sandbox/agent-sandbox</a></p>\n<h2 id=\"效果\">效果：</h2>\n<p><img alt=\"20260130165008\" height=\"1020\" src=\"https://img2024.cnblogs.com/blog/57355/202602/57355-20260212101717131-648382280.png\" width=\"1300\" /></p>\n<p><img alt=\"20260130165103\" height=\"1020\" src=\"https://img2024.cnblogs.com/blog/57355/202602/57355-20260212101724909-1058470393.png\" width=\"1300\" /></p>\n<h2 id=\"一用agent-sandbox-中创建一个-openclaw-沙箱\">一，用Agent-Sandbox 中创建一个 OpenClaw 沙箱</h2>\n<p>在 Agent-Sandbox 中，所有沙箱的创建都通过同一个 RESTful API：<code>POST /api/v1/sandbox</code>。</p>\n<p>当你安装好 Agent-Sandbox，只需要一行 <code>curl</code> 就能在集群中拉起一个 OpenClaw 实例：</p>\n<pre><code class=\"language-shell\">curl --location 'http://agent-sandbox.your-host.com/api/v1/sandbox' \\\n  --header 'Content-Type: application/json' \\\n  --data '{\"name\":\"openclaw1\",\"template\":\"openclaw\"}'\n</code></pre>\n<pre><code class=\"language-json\">{\n  \"code\": \"0\",\n  \"data\": \"Sandbox openclaw-alice created successfully\"\n}\n</code></pre>\n<p>这一步，就已经在你的 Kubernetes 集群里为某位同事拉起了一个完整可用的 OpenClaw 实例。</p>\n<h2 id=\"他的访问地址会是\">他的访问地址会是：</h2>\n<p><a href=\"http://localhost:10000/sandbox/openclaw1\" rel=\"noopener nofollow\" target=\"_blank\">http://localhost:10000/sandbox/openclaw1</a></p>\n<h2 id=\"二openclaw-配置\">二、OpenClaw 配置</h2>\n<p>默认配置示例如下：</p>\n<pre><code class=\"language-json\">{\n  \"models\": {\n    \"providers\": {\n      \"custom-1\": {\n        \"baseUrl\": \"https://xxx.com/v1\",\n        \"apiKey\": \"fe87c9e9-f399-49ca-98da-2f2404a249c2\",\n        \"auth\": \"api-key\",\n        \"api\": \"openai-completions\",\n        \"models\": []\n      }\n    }\n  },\n  \"agents\": {\n    \"defaults\": {\n      \"model\": {\"primary\": \"custom-1/glm-4.7\" },\n      \"workspace\": \"/root/.openclaw/workspace\",\n      \"maxConcurrent\": 4,\n      \"subagents\": {\n        \"maxConcurrent\": 8\n      }\n    }\n  },\n  \"gateway\": {\n    \"port\": 18789,\n    \"mode\": \"local\",\n    \"bind\": \"lan\",\n    \"controlUi\": {\n      \"allowInsecureAuth\": true\n    }\n  }\n}\n</code></pre>\n<p>模板中的 <code>openclaw.json</code> 给出了一个默认配置示例，包括：</p>\n<ul>\n<li><strong>模型配置</strong>：示例中使用了名为 <code>custom-1/glm-4.7</code> 的模型，你可以根据公司内部模型网关进行调整。</li>\n<li><strong>网关参数</strong>：\n<ul>\n<li>端口：<code>18789</code></li>\n<li>绑定模式：<code>lan</code></li>\n<li>认证方式：密码登录（示例密码为 <code>1</code>）。</li>\n</ul>\n</li>\n</ul>\n<p>之后访问 <a href=\"http://localhost:10000/sandbox/openclaw1\" rel=\"noopener nofollow\" target=\"_blank\">http://localhost:10000/sandbox/openclaw1</a> 即可进入 OpenClaw 界面，修改大模型参数，</p>\n<h3 id=\"1修改大模型provider\">1，修改大模型Provider</h3>\n<p><img alt=\"img_1\" src=\"https://img2024.cnblogs.com/blog/57355/202602/57355-20260212101755519-621083252.png\" /></p>\n<h3 id=\"2修改agent默认大模型名称\">2，修改Agent默认大模型名称</h3>\n<p><img alt=\"img\" src=\"https://img2024.cnblogs.com/blog/57355/202602/57355-20260212101805822-1587622280.png\" /></p>\n<p>根据需要调整模型和网关配置，即可开始使用 OpenClaw 了！</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-12 10:20</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xguo\">i'm老土豆</a>&nbsp;\n阅读(<span id=\"post_view_count\">109</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "给 Claude 装个仪表盘，时刻监测Token消耗跟任务进度",
      "link": "https://www.cnblogs.com/bugshare/p/19607080",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/bugshare/p/19607080\" id=\"cb_post_title_url\" title=\"发布于 2026-02-12 09:51\">\n    <span>给 Claude 装个仪表盘，时刻监测Token消耗跟任务进度</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>最近，Anthropic 推出的命令行工具 <strong>Claude Code</strong> 简直火得一塌糊涂。很多程序员朋友都说，那种在终端里直接指挥 AI 改代码、跑测试的感觉，确实比网页端反复“复制粘贴”要爽得多。</p>\n<p>但用久了，大家普遍发现一个痛点：<strong>“看不见”</strong>。</p>\n<p>你不知道 Claude 现在到底处理了多少 Token，不知道它背地里偷偷读了多少文件，更不知道它那个“大脑”任务列表进行到哪一步了。</p>\n<p>这种感觉就像开夜车没仪表盘，心里总有点没底。</p>\n<p>直到我发现了 <strong>Claude HUD</strong>（作者：Jarrod Watts）。它给 Claude Code 穿上了一层“外骨架”，让它从一个简单的黑框对话框，瞬间变成了科幻感十足的<strong>开发者工作站</strong>。</p>\n<p>今天，咱们就聊聊这个让无数极客直呼“真香”的神器。</p>\n<p><img alt=\"claude-hud-preview-5-2.png\" class=\"lazyload\" /></p>\n<hr />\n<h1 id=\"一-什么是-claude-hud\">一、 什么是 Claude HUD？</h1>\n<p>HUD 原意是“平视显示器”，通常出现在战斗机飞行员的头盔或高端汽车的挡风玻璃上。</p>\n<p><strong>Claude HUD</strong> 干的也是这件事。它是一个专门为 Claude Code 设计的插件，会在你的终端底部常驻一个<strong>状态栏</strong>。</p>\n<p>有了它，你不再需要通过翻看长长的聊天记录去确认进度。它把 Claude 的运行状态、Token 消耗、正在使用的工具、甚至当前的 Git 分支，全都浓缩在屏幕最下方。</p>\n<p><strong>一句话总结：它让 Claude 从一个“黑盒”，变成了一个“透明盒”。</strong></p>\n<hr />\n<h1 id=\"二-为什么它比原版好用\">二、 为什么它比原版好用？</h1>\n<p>如果你还在犹豫要不要装，看这三个功能就够了：</p>\n<ol>\n<li><strong>Context 进度条（防“宕机”神器）</strong><br />\nClaude 虽然强，但上下文（Context Window）是有上限的。很多时候聊着聊着，AI 开始胡言乱语，往往是因为 Token 满了。<br />\nHUD 直接在底部给你一个<strong>电量条一样的视觉反馈</strong>。看到变红了？赶紧重启会话或者清理上下文，再也不用盲目猜测。</li>\n<li><strong>实时“动作监控”</strong><br />\n当 Claude 在执行复杂任务（比如重构整个文件夹）时，它会频繁调用 <code>read_file</code>、<code>grep</code>、<code>edit_file</code> 等工具。<br />\n在 HUD 里，你可以看到这些动作像流水灯一样闪过。它在读哪行代码？改了哪个文件？你一眼就能掌握全局，这种<strong>掌控感</strong>对开发者来说太重要了。</li>\n<li><strong>任务进度（Todo List）可视化</strong><br />\n给 Claude 下达一个大任务时，它会自动拆解成好几个步骤。HUD 会把这些步骤实时显示出来：<br />\n<code>▸ Fix auth bug (2/5)</code><br />\n这就好比进度条，让你知道它现在是卡住了，还是正在稳步推进。</li>\n</ol>\n<hr />\n<h1 id=\"三-手把手安装教程三步搞定\">三、 手把手安装教程（三步搞定）</h1>\n<p>安装过程非常顺滑，前提是你已经安装了 <code>claude-code</code>。</p>\n<h2 id=\"第一步添加插件市场\">第一步：添加插件市场</h2>\n<p>在你的 Claude 会话中输入：</p>\n<pre><code class=\"language-bash\"># 这一步可能需要FQ\n/plugin marketplace add jarrodwatts/claude-hud\n</code></pre>\n<h2 id=\"第二步安装插件\">第二步：安装插件</h2>\n<p>接着输入：</p>\n<pre><code class=\"language-bash\">/plugin install claude-hud\n</code></pre>\n<p><em>（Linux 用户如果遇到报错，记得先设置一下临时目录权限，官方文档里有贴心提示）</em></p>\n<pre><code class=\"language-bash\">#⚠️ 在 Linux 系统中，/tmp通常会使用单独的文件系统 (tmpfs)，这会导致插件安装失败，并出现以下错误：\n#EXDEV: cross-device link not permitted\n#解决方法：安装前设置 TMPDIR：\nmkdir -p ~/.cache/tmp &amp;&amp; TMPDIR=~/.cache/tmp claude\n</code></pre>\n<h2 id=\"第三步初始化配置\">第三步：初始化配置</h2>\n<p>运行设置命令：</p>\n<pre><code class=\"language-bash\">/claude-hud:setup\n# 执行后可以不进行额外配置（按ESC键取消），后续再配置\n</code></pre>\n<p>搞定！你会发现终端底部立刻亮起了一排整齐的状态栏，帅气程度瞬间提升几个档次。</p>\n<p><img alt=\"image-20260211162341964.png\" class=\"lazyload\" /></p>\n<hr />\n<h1 id=\"四你的仪表盘你说了算\">四、你的仪表盘，你说了算！</h1>\n<p>很多插件装完就那样了，但 Claude HUD 最骚的地方在于它的<strong>高度自定义</strong>。你只需要在 Claude 会话中输入一行神奇的命令：</p>\n<pre><code class=\"language-bash\">/claude-hud:configure\n</code></pre>\n<p>输入这个命令后，你会进入一个“图形化”的配置菜单（就在终端里），完全不需要你去手改代码或 JSON 文件。</p>\n<h2 id=\"1-选择喜欢的装修风格\">1. 选择喜欢的“装修风格”</h2>\n<ul>\n<li><strong>Full（全能模式）：</strong> 所有的信息全开，适合那种喜欢“掌控一切”的硬核玩家。</li>\n<li><strong>Essential（极简模式）：</strong> 只保留最核心的活动状态和 Git 信息，清爽不打扰。</li>\n<li><strong>Minimal（迷你模式）：</strong> 只有一个窄窄的 Model 名称和 Token 条，存在感极低。</li>\n</ul>\n<pre><code class=\"language-bash\"># 默认值（2 行）\n[Opus | Max] │ my-project git:(main*)\nContext █████░░░░░ 45% │ Usage ██░░░░░░░░ 25% (1h 30m / 5h)\n# 第 1 行— 模型、计划名称（或Bedrock）、项目路径、Git 分支\n# 第 2 行— 上下文栏（绿色 → 黄色 → 红色）和使用速率限制\n\n# 可选行（通过以下方式启用/claude-hud:configure）\n◐ Edit: auth.ts | ✓ Read ×3 | ✓ Grep ×2        ← Tools activity\n◐ explore [haiku]: Finding auth code (2m 15s)    ← Agent status\n▸ Fix authentication bug (2/5)                   ← Todo progress\n</code></pre>\n<p><img alt=\"PixPin_2026-02-11_16-26-36.png\" class=\"lazyload\" /></p>\n<h2 id=\"2-细节控的福音\">2. 细节控的福音</h2>\n<p>您也可以直接在以下位置编辑配置文件<code>~/.claude/plugins/claude-hud/config.json</code>：</p>\n<ul>\n<li><strong>想看 Git 变动？</strong> 开启 <code>showFileStats</code>，连改了几个文件、删了几行都能直接看到。</li>\n<li><strong>嫌路径太长占地方？</strong> 调一下 <code>pathLevels</code>，只显示最后 1-2 级目录。</li>\n<li><strong>想监控 Token 消耗？</strong> 开启 <code>showUsage</code>，实时盯着你的 Pro/Max 会员限额还剩多少。</li>\n</ul>\n<p><strong>配置完后，甚至不需要重启，仪表盘会根据你的选择实时变幻，这种丝滑感真的会上瘾。</strong></p>\n<p><img alt=\"PixPin_2026-02-11_16-12-24.png\" class=\"lazyload\" /></p>\n<hr />\n<h1 id=\"五-真实使用场景它能帮你省多少事\">五、 真实使用场景：它能帮你省多少事？</h1>\n<ul>\n<li><strong>场景 A：大规模重构代码</strong><br />\n当你让 AI 把一个旧项目的 CommonJS 全改成 ESM 时，你会看到 HUD 上的“工具活动”疯狂跳动。如果它读了不该读的 <code>.env</code> 或备份文件，你可以立刻中断，修正指令，避免浪费 Token 和时间。</li>\n<li><strong>场景 B：深陷 Debug 泥潭</strong><br />\n当你和 Claude 缠斗了半小时还没修好 Bug 时，看一眼 HUD 的 <strong>Context Health</strong>。如果进度条已经 90% 了，说明对话太长，AI 已经变笨了。这时候果断 <code>/clear</code>，重新开始，往往能秒解。</li>\n<li><strong>场景 C：多任务并行</strong><br />\n如果你同时在几个分支上反复横跳，HUD 的 <strong>Git Status</strong> 功能会提醒你当前在哪。配合它显示的 <code>pathLevels</code>，你绝不会在复杂的 Monorepo（大仓库）里迷路。</li>\n</ul>\n<hr />\n<h1 id=\"写在最后\">写在最后</h1>\n<p>在这个 AI 辅助开发的时代，工具的边界就是你能力的边界。</p>\n<p>Claude HUD 并不是改变了 Claude 的智商，它改变的是<strong>你与 AI 协作的交互体验</strong>。从“被动等待结果”到“主动监控过程”，这种转变带来的不仅是效率的提升，更是心智负担的减轻。</p>\n<p>如果你已经用上了 Claude Code，听我一句劝：<strong>这个 HUD 插件，必须安排上！</strong></p>\n<p><strong>如果您觉得这篇文章有帮助，欢迎点赞、转发，让更多小伙伴告别“盲打”时代！）</strong></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-12 09:51</span>&nbsp;\n<a href=\"https://www.cnblogs.com/bugshare\">BugShare</a>&nbsp;\n阅读(<span id=\"post_view_count\">102</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "为什么同样是\"学过C++\"，有人面试碾压，有人开口就怂？差距在这18个C++硬核项目",
      "link": "https://www.cnblogs.com/xiaokang-coding/p/19605989",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaokang-coding/p/19605989\" id=\"cb_post_title_url\" title=\"发布于 2026-02-11 21:05\">\n    <span>为什么同样是\"学过C++\"，有人面试碾压，有人开口就怂？差距在这18个C++硬核项目</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>嘿，各位C++er，我是小康👋</p>\n<p>今天这篇文章，我想写得和以往不太一样。</p>\n<p>不聊技术原理，不讲架构设计，就聊一个问题：</p>\n<p><strong>你学了那么久C++，为什么还是写不出一个拿得出手的项目？</strong></p>\n<h2 id=\"先看一条让我感触最深的私信\">先看一条让我感触最深的私信</h2>\n<p>前几天一个学员发给我这段话：</p>\n<p>\"康哥，我把内存池项目整理进简历，面试官问我'你这个内存池比malloc快7倍，怎么实现的'，我从ThreadCache讲到PageHeap，再讲到批量分配和无锁设计，面试官直接说'这个掌握得很扎实'。三年了，第一次在面试里感觉到底气。\"</p>\n<p>这不是段子，是真实发生的事。</p>\n<p>过去大半年，我陆续做了<strong>18个C++硬核项目实战课程</strong>，带了<strong>300多位同学</strong>从零开始实现这些项目——985、211有，普通本科有，工作3年换方向的有，应届生有，大家背景差距很大，但收获出奇地一致：</p>\n<p><strong>从\"看得懂别人代码\"升级成了\"自己能从0写出来\"。</strong></p>\n<p>这篇文章，我就把这18个项目完整介绍一遍。</p>\n<h2 id=\"先说说我对市面上那些c课程的看法\">先说说我对市面上那些C++课程的看法</h2>\n<p>直接说：大部分都是\"伪实战\"。</p>\n<p><strong>模式一：开源项目搬运工。</strong> 去GitHub找个高star项目，照着讲一遍。你看完知道\"这段代码在做什么\"，但根本不知道\"为什么这样设计\"，更不会自己从头写。</p>\n<p><strong>模式二：给你个完整代码自己啃。</strong> 扔一个3000行项目给你，说\"学完就行了\"。遇到问题找不到人问，踩了坑不知道怎么解。</p>\n<p><strong>模式三：只有玩具Demo。</strong> 核心功能一删再删，结果弄出来的东西根本上不了生产，面试一问细节就露馅。</p>\n<p>我的方式不一样：<strong>所有项目都是我本人从0到1设计实现的原创代码，用增量式教学带你一步步构建，每天都有可运行的版本，每个设计决策都会解释\"为什么这么做\"。</strong></p>\n<p><strong>不过在介绍项目之前，先说说这套课程更适合哪些人：</strong></p>\n<p><strong>① 正在求职、不知道简历上该写什么项目的同学</strong>——不是说你没能力，而是你缺少一个从0开始、能讲出来、经得起面试官追问的项目。这里面任何一个，都可以正大光明写进简历，而且面试官越问越有底气。</p>\n<p><strong>② 工作了几年、代码量一直上不去的开发者</strong>——你不是缺理论，是缺一次把工业级代码从零写出来的完整经历。很多人工作三年，写的代码逻辑复杂度没超过CRUD，这些项目可以帮你快速补上这段经历。</p>\n<p><strong>③ 想系统提升C++实战能力的同学</strong>——不管你是在校生还是转方向的，能独立实现一个高性能内存池、一个无锁队列、一个协程库，你的C++已经超过80%的同龄人了。</p>\n<p>用一句话概括：<strong>这套课程不是让你\"看懂别人的代码\"，而是带你快速实现项目，从零到一，真正写出来。</strong></p>\n<p>好了，废话少说，下面进入正题。</p>\n<h2 id=\"-18个项目完整介绍\">📦 18个项目完整介绍</h2>\n<h3 id=\"-基础设施篇6个项目\">🧵 基础设施篇（6个项目）</h3>\n<p><strong>1. 线程池 · 299元 · 7天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/10md6XvqpFug5S7LW8m29Q\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>几乎所有C++后台面试必问，但99%的候选人只背过答案，没实现过。</p>\n<p>这个项目不是那种\"几十行就完事\"的玩具。1700+行代码，从基础框架到完整的工业级线程池，包含：任务优先级调度、动态调整线程数、基于<code>std::future</code>的异步结果获取、任务取消与超时机制、完整的状态监控……</p>\n<p>7天渐进式实现，每天一个可运行版本。学完你能自信跟面试官说：这个我自己写过，来，我给你画架构图。</p>\n<p><strong>项目架构图:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>2. 高性能日志库 MiniSpdlog · 299元 · 8天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/Gt4dgmq8V6tbPZOgEqDlZg\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>spdlog源码有几万行，看不懂、改不动。MiniSpdlog用2500行核心代码，实现了spdlog的精华设计——同步/异步、多Sink、格式化、滚动文件、MPMC队列、线程池……</p>\n<p>实测下来性能可能不如开源日志库spdlog，但是代码完全可读可改，适合学习。这才是\"学完真的懂\"的项目。</p>\n<p><strong>项目架构图:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>3. 高性能内存池 · 299元 · 10天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/xpSUbVwRZuVoQpRorbpnqA\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>花了三周，做了一个让malloc\"破防\"的内存池。</p>\n<p>实测数据：2048B对象分配比malloc快<strong>7.37倍</strong>，16线程并发下<strong>9战9胜</strong>。</p>\n<p>核心是仿TCMalloc的三层架构：ThreadCache（无锁分配）+ CentralCache（桶锁，降低208倍锁竞争）+ PageHeap（批量申请，1次系统调用撑1000+次分配）。4000+行代码，每个优化决策都有perf数据支撑。</p>\n<p><strong>项目架构图:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>4. MySQL连接池 · 299元 · 8天</strong> <a href=\"https://mp.weixin.qq.com/s/b01e8Muwpgnd1jBgwB2fgg\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>数据库连接管理是后端开发的\"右臂\"。这个项目4200+行代码，包含：智能连接管理、自定义重连机制（比MySQL官方重连更智能）、三种负载均衡算法（随机/轮询/权重）、健康检查、完整事务支持、10+项性能监控指标……</p>\n<p>有学员学完直接用在公司项目优化上，拿了技术奖励。</p>\n<p><strong>项目架构图:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>5. 内存泄漏检测器 MemTracker · 299元 · 7天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/u7xa1rLz0kXD0cax84pxiw\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>Valgrind太重、ASan集成复杂、VS诊断工具只支持Windows……这些痛点，MemTracker都解决了。</p>\n<p>64段分段锁架构、16384哈希桶、静态变量检测（业界少有）、精确定位到文件名和行号，性能开销几乎可以忽略。800行核心代码，只需包含一个头文件就能用。</p>\n<p>面试官问\"如何检测内存泄漏\"的时候，你可以说：我自己实现过一个。</p>\n<p><strong>项目架构图:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>6. 死锁检测工具 DeadLock-Sentinel · 299元 · 6天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/kp2yiGupj1ei3M6XPnKeRQ\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>死锁是多线程开发者的噩梦。这个工具基于图论算法（拓扑排序）自动检测，集成backward-cpp实现堆栈追踪，报告直接显示死锁发生的文件名和行号，还集成spdlog自动保存日志。零侵入，只需把<code>std::mutex</code>换成<code>DeadlockMutex</code>即可启用，Release时一个宏关掉，零性能损耗。</p>\n<p><strong>项目架构图:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"-高性能组件篇5个项目\">⚡ 高性能组件篇（5个项目）</h3>\n<p><strong>7. ReactorX事件驱动引擎 · 299元 · 5天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/OpHbNeLvmTaXA4ZlRI785w\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>腾讯/字节面试官都在问的Reactor模式，终于有人教你从0到1实现了。</p>\n<p>2000行代码实现完整的Reactor引擎：epoll封装、EventLoop事件循环、基于timerfd的高精度定时器、eventfd跨线程通信、EventLoopThreadPool……实测支持50000+并发连接，QPS达50万+。这是后续网络库、HTTP服务器的基础。</p>\n<p><strong>项目架构图:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>8. 无锁栈 InfiniteStack · 299元 · 7天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/tjtNHV-_92r2Z-JA_3_q6A\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>无锁编程入门的最佳项目。从CAS原子操作原理讲起，到ABA问题的完整解决方案，再到工业级的Hazard Pointer(危险指针)内存回收机制，7天带你彻底搞懂无锁数据结构设计。性能比std::stack+mutex快2-3倍。</p>\n<p><strong>9. 无锁队列 SPSC LightningQueue · 100元 · 6天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/VXbGq_27nnnPgJQWhaFzbw\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>SPSC（单生产者单消费者）无锁队列，游戏引擎、音视频处理、金融交易系统的标配。实测比queue+mutex方案快2-4倍，延迟降低到2411ns。基于环形缓冲区，6天从原理到生产可用实现。</p>\n<p><strong>10. 无锁队列 MPMC Thunder Queue · 299元 · 6天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/Nk91RZ6RD4gYRRT7VWfNyg\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>无锁编程的\"珠穆朗玛峰\"。多生产者多消费者场景，lock+queue方案只有0.27Mops/s，Thunder Queue能达到4.85Mops/s，性能提升<strong>近20倍</strong>。基于Facebook Folly设计思想，包含turn机制、stride伪共享优化、自适应自旋+Futex阻塞等关键技术。</p>\n<p><strong>11. 工业级智能指针 CraftedPtr · 299元 · 7天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/kfG1VoH9eRnCE0YCuKAD5w\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>网上那些shared_ptr实现大多是玩具，CraftedPtr是真正对标std::shared_ptr的工业级实现。控制块分离、类型擦除、Hazard Pointer线程安全、weak_ptr完整支持、make_shared单次内存分配优化……部分性能指标超越标准库。7天完整实现，还你一个\"自己造的共享指针\"。</p>\n<p><strong>项目架构图:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"-综合实战篇7个项目\">🌐 综合实战篇（7个项目）</h3>\n<p><strong>12. 高性能网络库 NetCore · 499元 · 10天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/Y3713qRGGQgCO8btemWR_w\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>muduo几万行看不懂？NetCore用2200行核心代码完整实现了Multi-Reactor多线程网络库：Socket RAII封装、Acceptor连接接受、Buffer自动扩容、TcpConnection状态机、TcpServer负载均衡……完整的Echo Server演示，3行代码启动服务。</p>\n<p>已报名ReactorX的同学，补差价200元即可。</p>\n<p><strong>项目架构图:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>13. 高性能HTTP服务器 FlashHTTP · 699元 · 16天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/GGGDwi9VlXJKBk9cXlNbtw\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>3600+行代码，16天从Reactor到HTTP服务器。实测：<strong>45万QPS，P99延迟22.96ms，支持4万并发连接</strong>，压测结果吊打市面上大部分开源HTTP Server。支持GET/POST/PUT/DELETE、状态机解析、Keep-Alive、静态文件服务、大文件保护……写进简历就是硬货。</p>\n<p>已报名ReactorX的补差价400元，已报名网络库的补差价200元。</p>\n<p><strong>项目架构图:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>14. 高性能异步日志库 ZephyrLog · 299元 · 6天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/BdsY05V3OXzHAcrQoGbsGA\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>性能数据说话：单线程吞吐量<strong>1250万msg/s</strong>，是spdlog的6倍，是g3log的17倍；16线程极限并发下依然稳在<strong>1100万QPS</strong>，而spdlog直接崩盘。双模式设计（高性能模式/零丢失模式），800行核心代码，6天完整实现。</p>\n<p><strong>项目架构图:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>15. 多线程下载工具 FastDL · 299元 · 7天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/_Ldit_7qWYBS2kmasGiODA\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>32线程并发，速度提升10倍以上，真正能安装到系统使用的命令行下载神器。HTTP/2协议、定位写入零磁盘占用、JSON断点续传、信号处理优雅中断……2200+行代码，7天学完你就有了一个能跟朋友炫耀\"我自己写的\"的下载工具。</p>\n<p><strong>项目架构图:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>16. 高性能协程库 CoroForge · 399元 · 7天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/tuInQxfwqWHFQLU3tKIROA\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>微信libco同款技术，性能完全媲美——在2万并发下吞吐量与libco完全一致（实测）。从汇编上下文切换讲起，到共享栈设计（内存降低99%）、epoll事件驱动、Hook系统调用实现透明协程化……2000行代码搞定libco需要3000行才能做到的事。7天，从\"不懂协程\"到\"能写协程库\"。</p>\n<p><strong>项目架构图:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>17. HTTP压测工具（即将发布）· 299元</strong></p>\n<p>参考开源项目wrk实现，wrk支持的功能全部支持（多线程、Lua脚本、自定义请求、延迟统计等）。如果你做了网络库或HTTP服务器，有一个自己实现的压测工具是非常加分的。详情发布后会第一时间通知。</p>\n<p><strong>项目架构图:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>18. Redis核心实战 · 1200元（早鸟价）</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/qwcEFKVfeU66AghX__tW7A\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>这个项目体量最大：基于Redis 7.x版本，5大阶段、16个核心模块，从SDS/跳表/哈希表等基础数据结构，到事件驱动、主从复制、哨兵集群，从0到1手写Redis核心模块。</p>\n<p>目前课程制作中，早鸟价1200元，制作完毕后涨价到2000-2500元。注意：Redis项目不包含在打包套餐内，单独报名。</p>\n<h2 id=\"-300学员说什么\">💬 300+学员说什么</h2>\n<p><strong>先来看下部分学员的真实反馈和评价：</strong></p>\n<p><strong>学员1：</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>学员2：</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>学员3：</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>学员4：</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>学员5：</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>学员6：</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>学员7：</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>学员8：</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>学员9：</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>学员10：</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>学员11：</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>学员12：</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>学员13:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"-报名方式与定价\">💰 报名方式与定价</h2>\n<h3 id=\"单个项目购买\">单个项目购买</h3>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>价格</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>线程池</td>\n<td><strong>299元</strong></td>\n</tr>\n<tr>\n<td>高性能日志库 MiniSpdlog</td>\n<td><strong>299元</strong></td>\n</tr>\n<tr>\n<td>高性能内存池</td>\n<td><strong>299元</strong></td>\n</tr>\n<tr>\n<td>多线程下载工具 FastDL</td>\n<td><strong>299元</strong></td>\n</tr>\n<tr>\n<td>MySQL连接池</td>\n<td><strong>299元</strong></td>\n</tr>\n<tr>\n<td>内存泄漏检测器 MemTracker</td>\n<td><strong>299元</strong></td>\n</tr>\n<tr>\n<td>ReactorX 事件驱动引擎</td>\n<td><strong>299元</strong></td>\n</tr>\n<tr>\n<td>无锁栈 InfiniteStack</td>\n<td><strong>299元</strong></td>\n</tr>\n<tr>\n<td>无锁队列 SPSC LightningQueue</td>\n<td><strong>100元</strong></td>\n</tr>\n<tr>\n<td>无锁队列 MPMC ThunderQueue</td>\n<td><strong>299元</strong></td>\n</tr>\n<tr>\n<td>工业级智能指针 CraftedPtr</td>\n<td><strong>299元</strong></td>\n</tr>\n<tr>\n<td>高性能网络库 NetCore</td>\n<td><strong>499元</strong></td>\n</tr>\n<tr>\n<td>高性能异步日志库 ZephyrLog</td>\n<td><strong>299元</strong></td>\n</tr>\n<tr>\n<td>死锁检测工具 DeadLock-Sentinel</td>\n<td><strong>299元</strong></td>\n</tr>\n<tr>\n<td>高性能协程库 CoroForge</td>\n<td><strong>399元</strong></td>\n</tr>\n<tr>\n<td>Redis 7.x 源码实战（早鸟价）</td>\n<td><strong>1200元</strong> （不含在打包里）</td>\n</tr>\n<tr>\n<td>FlashHTTP HTTP服务器</td>\n<td><strong>699元</strong></td>\n</tr>\n<tr>\n<td>HTTP压测工具</td>\n<td><strong>299元</strong>（即将发布）</td>\n</tr>\n</tbody>\n</table>\n<p>单个购买总计约 <strong>4985 元</strong>。</p>\n<h3 id=\"春节限时特惠--全套打包\">春节限时特惠 · 全套打包</h3>\n<p>原价 4985 元 → <strong>春节特惠价 4200 元</strong>  直接省下近 <strong>800</strong> 元，相当于<strong>送 3 个项目</strong>。</p>\n<p>对于想系统提升 C++ 工程能力、备战面试的你，这可能是今年最划算的一笔投资。</p>\n<p>⏰<strong>活动时间</strong>：<strong>即日起至大年初七（2月23日）</strong>，过后恢复原价。</p>\n<p><strong>PS：</strong> 如果暂时只想从某几个方向入手，<strong>购买部分课程也有优惠</strong>，具体可以私聊我，会根据你的情况给出最合适的方案。</p>\n<h3 id=\"-redis-7x-源码实战单独定价\">🌟 Redis 7.x 源码实战（单独定价）</h3>\n<p>这门课体量独立、内容庞大，分5阶段16模块，与其他项目课定价逻辑不同，不含在打包价内。<a href=\"https://mp.weixin.qq.com/s/qwcEFKVfeU66AghX__tW7A\" rel=\"noopener nofollow\" target=\"_blank\">点击查看项目详情</a></p>\n<p>早鸟价：<strong>1200元</strong>（课程制作完成后涨至2000元-2500元，先报先得）</p>\n<h2 id=\"-如何报名\">🤝 如何报名？</h2>\n<ol>\n<li>扫描下方二维码添加我的微信，或直接搜索：<strong>jkfwdkf</strong></li>\n<li>备注「 <strong>项目实战</strong> 」</li>\n<li>确认后 <strong>微信/支付宝</strong> 付款</li>\n<li>当天加入专属学习群，获取全部资料</li>\n</ol>\n<p><strong>或者扫码加我微信</strong>:</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"最后说几句真心话\">最后说几句真心话</h2>\n<p>我做这些项目课程，有个不变的原则：<strong>所有代码都是我本人从零设计实现的，不从开源项目改造，不拼凑，不水。</strong></p>\n<p>因为我知道，一个真正能让学员受益的项目，必须让他们理解每一个设计决策背后的原因——不只是\"代码是什么\"，而是\"为什么这么写\"。</p>\n<p>这一年多，300多位同学跟着我做了这些项目。有人靠它拿了心仪的Offer，有人靠它在团队里赢得了认可，有人只是纯粹享受\"自己造出来了\"的成就感。</p>\n<p>不管你的出发点是什么，只要你真的想把C++学扎实，想拥有那种\"我能从0写出来\"的底气—— 那就赶紧来，我们一起做。</p>\n<p><strong>微信：jkfwdkf，备注 「项目实战」</strong></p>\n<p>期待你的加入 💪</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-11 21:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xiaokang-coding\">江小康</a>&nbsp;\n阅读(<span id=\"post_view_count\">133</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}