{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "SpringBoot-shiro-jwt-dubbo-redis分布式统一权限系统（完结）",
      "link": "https://www.cnblogs.com/alineverstop/p/19482539",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/alineverstop/p/19482539\" id=\"cb_post_title_url\" title=\"发布于 2026-01-14 15:51\">\n    <span>SpringBoot-shiro-jwt-dubbo-redis分布式统一权限系统（完结）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>分布式统一权限系统</p>\n<h1 id=\"设计\">设计</h1>\n<p><img alt=\"2026-1-14-1\" class=\"lazyload\" /></p>\n<p>shiro-mgt:用户、角色、资源的定义，资源对应网关的定义，动态链的定义</p>\n<p>shiro鉴权服务集群：会话信息、Realm信息</p>\n<p>dubbo-app集群：实际业务相关</p>\n<h1 id=\"模块依赖\">模块依赖</h1>\n<p><img alt=\"2026-1-14-2\" class=\"lazyload\" /></p>\n<p>Springboot-shiro-gateway-handler功能：</p>\n<ol>\n<li>dubbo业务服务转换http通讯</li>\n<li>认证与鉴权服务化消费者</li>\n<li>生成业务服务化消费者</li>\n</ol>\n<p>springboot-shiro-producer功能：</p>\n<ol>\n<li>认证与鉴权的服务化生成者</li>\n</ol>\n<p>springboot-shiro-mgt功能：</p>\n<ol>\n<li>认证与鉴权的服务化消费者</li>\n</ol>\n<p>springboot-shiro-dubbo-app-handler功能：</p>\n<ol>\n<li>生成业务服务化生产者</li>\n</ol>\n<h1 id=\"动态过滤器链\">动态过滤器链</h1>\n<p>实现动态过滤器链，我们需要保证以下几个特性：</p>\n<p>1、持久化：原有的properties内容放入数据库，</p>\n<p>2、有序性：因过滤器链有序加载的特性，读取过滤器链的时保证其有序性</p>\n<p>3、服务化：过滤器链的服务做成dubbo服务，做到集中式管理</p>\n<p>4、同步性：不同业务系统对于过滤器链的加载需要同步</p>\n<p>5、热加载：过滤器链修改之后，各个业务系统不需要重启服务，以达到热加载的目的</p>\n<h2 id=\"实现持久化有序化\">实现持久化、有序化</h2>\n<p>过滤器链包含的字段：</p>\n<pre><code class=\"language-java\">package com.itheima.shiro.vo;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\nimport java.io.Serializable;\n\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class FilterChainVo implements Serializable {\n    /**\n     * 主键\n     */\n    private String id;\n\n    /**\n     * 描述\n     */\n    private String urlName;\n\n    /**\n     * 路径\n     */\n    private String url;\n\n    /**\n     * 拦截器名称\n     */\n    private String filterName;\n\n    /**\n     * 所需角色，可省略，用逗号分隔\n     */\n    private String roles;\n\n    /**\n     * 所需权限，可省略，用逗号分隔\n     */\n    private String permissions;\n\n    /**\n     * 排序\n     */\n    private Integer sortNo;\n\n    private String enableFlag;\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public String toString() {\n        return ToStringBuilder.reflectionToString(this, ToStringStyle.SHORT_PREFIX_STYLE);\n    }\n}\n</code></pre>\n<h2 id=\"实现服务化\">实现服务化</h2>\n<p>目的：使所有的服务器链查询请求都通过这个服务来调用。</p>\n<pre><code class=\"language-java\">package com.itheima.shiro.face;\n\nimport com.itheima.shiro.vo.FilterChainVo;\n\nimport java.util.List;\n\n/**\n * @Description：过滤器链服务化接口\n */\npublic interface FilterChainFace {\n\n    /**\n     * @Description 查询所有有效的过滤器链\n     */\n    List&lt;FilterChainVo&gt; findFilterChainList();\n}\n</code></pre>\n<pre><code class=\"language-java\">package com.itheima.shiro.faceImpl;\n\nimport com.itheima.shiro.face.FilterChainFace;\nimport com.itheima.shiro.pojo.FilterChain;\nimport com.itheima.shiro.service.FilterChainService;\nimport com.itheima.shiro.utils.BeanConv;\nimport com.itheima.shiro.utils.EmptyUtil;\nimport com.itheima.shiro.vo.FilterChainVo;\nimport org.apache.dubbo.config.annotation.Service;\nimport org.springframework.beans.factory.annotation.Autowired;\n\nimport java.util.List;\n\n/**\n * @Description：过滤器链服务化接口\n */\n@Service(version = \"1.0.0\",retries = 3,timeout = 5000)\npublic class FilterChainFaceImpl implements FilterChainFace {\n\n    @Autowired\n    FilterChainService filterChainService;\n\n    @Override\n    public List&lt;FilterChainVo&gt; findFilterChainList() {\n        List&lt;FilterChain&gt; filterChainList = filterChainService.findFilterChainList();\n        if (!EmptyUtil.isNullOrEmpty(filterChainList)){\n            // 将数据库返回的数据结构转换成标准的过滤器链格式\n            return BeanConv.toBeanList(filterChainList, FilterChainVo.class);\n        }\n        return null;\n    }\n}\n</code></pre>\n<h2 id=\"实现同步性\">实现同步性</h2>\n<p>先读取数据库的过滤器链，调用上面filterChainFace服务</p>\n<ol>\n<li>FilterChainBridgeService:过滤器链桥接器service接口层</li>\n<li>FilterChainBridgeServiceImpl:过滤器链桥接器service接口层实现</li>\n</ol>\n<p>将过滤器链加载到shiro中</p>\n<ol>\n<li>ShiroFilerChainService:shiro过滤器链服务加载接口</li>\n<li>ShiroFilerChainService:shiro过滤器链服务加载接口实现</li>\n</ol>\n<pre><code class=\"language-java\">package com.itheima.shiro.core.bridge;\n\nimport com.itheima.shiro.vo.FilterChainVo;\n\nimport javax.servlet.FilterChain;\nimport java.util.List;\n\n/**\n * @Description：自定义过滤器桥接接口\n */\npublic interface FilterChainBridgeService {\n\n    /**\n     * @Description 查询所有有效的过滤器链\n     */\n    List&lt;FilterChainVo&gt; findFilterChainList();\n}\n</code></pre>\n<pre><code class=\"language-java\">package com.itheima.shiro.client;\n\nimport com.itheima.shiro.core.bridge.FilterChainBridgeService;\nimport com.itheima.shiro.face.FilterChainFace;\nimport com.itheima.shiro.vo.FilterChainVo;\nimport org.apache.dubbo.config.annotation.Reference;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n/**\n * @Description：自定义过滤器桥接接口实现\n */\n@Service(\"filterChainBridgeService\")\npublic class FilterChainBridgeServiceImpl implements FilterChainBridgeService {\n\n    @Reference(version = \"1.0.0\")\n    private FilterChainFace filterChainFace;\n\n    @Override\n    public List&lt;FilterChainVo&gt; findFilterChainList() {\n        return filterChainFace.findFilterChainList();\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">package com.itheima.shiro.service;\n\nimport com.itheima.shiro.vo.FilterChainVo;\n\nimport java.util.List;\n\n/**\n * @Description：过滤器同步接口\n */\npublic interface ShiroFilerChainService {\n\n    /**\n     * @Description 启动时，启动定时器，每隔2分钟动态加载数据库里面的过滤器链\n     */\n    void init();\n\n    /**\n     * @Description 使用DefaultFilterChainManager的addToChain方法构建过滤器链\n     */\n    void initFilterChains(List&lt;FilterChainVo&gt; filterChainVos);\n}\n</code></pre>\n<pre><code class=\"language-java\">package com.itheima.shiro.service.impl;\n\nimport com.itheima.shiro.core.bridge.FilterChainBridgeService;\nimport com.itheima.shiro.core.impl.CustomDefaultFilterChainManager;\nimport com.itheima.shiro.service.ShiroFilerChainService;\nimport com.itheima.shiro.vo.FilterChainVo;\nimport org.apache.shiro.web.filter.mgt.DefaultFilterChainManager;\nimport org.apache.shiro.web.filter.mgt.NamedFilterList;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport javax.annotation.PostConstruct;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @Description：过滤器同步接口实现\n */\n@Service(\"shiroFilerChainService\")\npublic class ShiroFilerChainServiceImpl implements ShiroFilerChainService {\n\n    //注入过滤器链管理者\n    @Autowired\n    private CustomDefaultFilterChainManager defaultFilterChainManager;\n\n    //使用桥接器读取数据库内的过滤器链\n    @Autowired\n    FilterChainBridgeService filterChainBridgeService;\n\n    private Map&lt;String, NamedFilterList&gt; defaultFilterChains;\n\n    //定时器\n    private ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);\n\n    // 每个服务器启动都会加载这个方法\n    @Override\n    @PostConstruct\n    public void init() {\n        defaultFilterChains = new LinkedHashMap&lt;&gt;();\n        // 延时为0，每120秒执行一次\n        executorService.scheduleAtFixedRate(new Runnable() {\n            @Override\n            public void run() {\n                initFilterChains(filterChainBridgeService.findFilterChainList()) ;\n            }\n        }, 0, 120, TimeUnit.SECONDS);\n    }\n\n    @Override\n    public void initFilterChains(List&lt;FilterChainVo&gt; filterChainVos) {\n\n        //1、首先删除以前老的filter，构建默认的过滤器链\n        defaultFilterChainManager.getFilterChains().clear();\n        //2、加载过滤器链\n        for (FilterChainVo urlFilterVo : filterChainVos) {\n            String url = urlFilterVo.getUrl();\n            String filterName = urlFilterVo.getFilterName();\n            String[] filterNames = filterName.split(\",\");\n            for (String name : filterNames) {\n                //注册所有filter，包含自定义的过滤器\n                switch(name){\n                    case \"anon\":\n                        defaultFilterChainManager.addToChain(url, name);\n                        break;\n                    case \"authc\":\n                        defaultFilterChainManager.addToChain(url, name);\n                        break;\n                    case \"roles\":\n                        defaultFilterChainManager.addToChain(url, name, urlFilterVo.getRoles());\n                        break;\n                    case \"perms\":\n                        defaultFilterChainManager.addToChain(url, name,urlFilterVo.getPermissions());\n                        break;\n                    case \"role-or\":\n                        defaultFilterChainManager.addToChain(url, name,urlFilterVo.getRoles());\n                        break;\n                    case \"kicked-out\":\n                        defaultFilterChainManager.addToChain(url, name);\n                        break;\n                    case \"jwt-authc\":\n                        defaultFilterChainManager.addToChain(url, name);\n                        break;\n                    case \"jwt-roles\":\n                        defaultFilterChainManager.addToChain(url, name, urlFilterVo.getRoles());\n                        break;\n                    case \"jwt-perms\":\n                        defaultFilterChainManager.addToChain(url, name,urlFilterVo.getPermissions());\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<h2 id=\"实现热加载\">实现热加载</h2>\n<p>为了实现热加载我们需要定义以下3个类：</p>\n<ul>\n<li>CustomDefaultFilterChainManager:自定义的默认过滤器链管理者</li>\n<li>CustomPathMatchingFilterChainResolver:自定义的路径匹配过滤器链解析器</li>\n<li>CustomShiroFilterFactoryBean:自定义shiro过滤器工厂bean</li>\n</ul>\n<p><strong>CustomDefaultFilterChainManager：主要是把原来对象的创建交于spring容器，同时指定过滤器，然后构建过滤器链</strong></p>\n<pre><code class=\"language-java\">package com.itheima.shiro.core.impl;\n\nimport org.apache.shiro.util.StringUtils;\nimport org.apache.shiro.web.filter.AccessControlFilter;\nimport org.apache.shiro.web.filter.authc.AuthenticationFilter;\nimport org.apache.shiro.web.filter.authz.AuthorizationFilter;\nimport org.apache.shiro.web.filter.mgt.DefaultFilterChainManager;\nimport org.apache.shiro.web.filter.mgt.NamedFilterList;\n\nimport javax.annotation.PostConstruct;\nimport javax.servlet.Filter;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * @Description：自定义过滤器链管理者\n */\npublic class CustomDefaultFilterChainManager extends DefaultFilterChainManager {\n\n    //登录地址\n    private String loginUrl;\n    //登录成功之后跳转地址\n    private String successUrl;\n    //未授权跳转地址\n    private String unauthorizedUrl;\n\n    /**\n     * @Description 构建过滤器和过滤器链的map对象，加载默认的过滤器链\n     */\n    public CustomDefaultFilterChainManager() {\n        setFilters(new LinkedHashMap&lt;String, Filter&gt;());\n        setFilterChains(new LinkedHashMap&lt;String, NamedFilterList&gt;());\n        addDefaultFilters(true);\n    }\n\n    @PostConstruct\n    public void init(){\n        Map&lt;String, Filter&gt; defaultFilters = getFilters();\n        //apply global settings if necessary:\n        for (Filter filter : defaultFilters.values()) {\n            applyGlobalPropertiesIfNecessary(filter);\n        }\n    }\n\n    private void applyGlobalPropertiesIfNecessary(Filter filter) {\n        applyLoginUrlIfNecessary(filter);\n        applySuccessUrlIfNecessary(filter);\n        applyUnauthorizedUrlIfNecessary(filter);\n    }\n\n    private void applyLoginUrlIfNecessary(Filter filter) {\n        String loginUrl = getLoginUrl();\n        if (StringUtils.hasText(loginUrl) &amp;&amp; (filter instanceof AccessControlFilter)) {\n            AccessControlFilter acFilter = (AccessControlFilter) filter;\n            //only apply the login url if they haven't explicitly configured one already:\n            String existingLoginUrl = acFilter.getLoginUrl();\n            if (AccessControlFilter.DEFAULT_LOGIN_URL.equals(existingLoginUrl)) {\n                acFilter.setLoginUrl(loginUrl);\n            }\n        }\n    }\n\n    private void applySuccessUrlIfNecessary(Filter filter) {\n        String successUrl = getSuccessUrl();\n        if (StringUtils.hasText(successUrl) &amp;&amp; (filter instanceof AuthenticationFilter)) {\n            AuthenticationFilter authcFilter = (AuthenticationFilter) filter;\n            //only apply the successUrl if they haven't explicitly configured one already:\n            String existingSuccessUrl = authcFilter.getSuccessUrl();\n            if (AuthenticationFilter.DEFAULT_SUCCESS_URL.equals(existingSuccessUrl)) {\n                authcFilter.setSuccessUrl(successUrl);\n            }\n        }\n    }\n\n    private void applyUnauthorizedUrlIfNecessary(Filter filter) {\n        String unauthorizedUrl = getUnauthorizedUrl();\n        if (StringUtils.hasText(unauthorizedUrl) &amp;&amp; (filter instanceof AuthorizationFilter)) {\n            AuthorizationFilter authzFilter = (AuthorizationFilter) filter;\n            //only apply the unauthorizedUrl if they haven't explicitly configured one already:\n            String existingUnauthorizedUrl = authzFilter.getUnauthorizedUrl();\n            if (existingUnauthorizedUrl == null) {\n                authzFilter.setUnauthorizedUrl(unauthorizedUrl);\n            }\n        }\n    }\n\n    /**\n     * @Description 加载自定义过滤器的对象\n     * @param customFilters 自定义过滤器的map架构\n     * @return\n     */\n    public void setCustomFilters(Map&lt;String,Filter&gt; customFilters){\n        for (Map.Entry&lt;String, Filter&gt; entry : customFilters.entrySet()) {\n            addFilter(entry.getKey(), entry.getValue(), false);\n        }\n\n    }\n\n    /**\n     * @Description 不再使用shiro容器去构建，而是交于spring去构建\n     */\n    @Override\n    protected void initFilter(Filter filter) {\n\n    }\n\n    public String getLoginUrl() {\n        return loginUrl;\n    }\n\n    public void setLoginUrl(String loginUrl) {\n        this.loginUrl = loginUrl;\n    }\n\n    public String getSuccessUrl() {\n        return successUrl;\n    }\n\n    public void setSuccessUrl(String successUrl) {\n        this.successUrl = successUrl;\n    }\n\n    public String getUnauthorizedUrl() {\n        return unauthorizedUrl;\n    }\n\n    public void setUnauthorizedUrl(String unauthorizedUrl) {\n        this.unauthorizedUrl = unauthorizedUrl;\n    }\n}\n</code></pre>\n<p>CustomPathMatchingFilterChainResolver这里主要核心内容是：指定使用过滤器链管理器为自己定的过滤器管理器</p>\n<pre><code class=\"language-java\">package com.itheima.shiro.core.impl;\n\nimport lombok.extern.log4j.Log4j2;\nimport org.apache.shiro.web.filter.mgt.FilterChainManager;\nimport org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver;\n\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\n\n/**\n * @Description：自定义路径解析器\n */\n@Log4j2\npublic class CustomPathMatchingFilterChainResolver extends PathMatchingFilterChainResolver {\n\n    private CustomDefaultFilterChainManager defaultFilterChainManager;\n\n    public CustomDefaultFilterChainManager getDefaultFilterChainManager() {\n        return defaultFilterChainManager;\n    }\n\n    public void setDefaultFilterChainManager(CustomDefaultFilterChainManager defaultFilterChainManager) {\n        this.defaultFilterChainManager = defaultFilterChainManager;\n    }\n\n    public FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain) {\n        //不在使用默认的过滤器链管理者，而是使用自定义的过滤器管理者\n        FilterChainManager filterChainManager = getDefaultFilterChainManager();\n        if (!filterChainManager.hasChains()) {\n            return null;\n        }\n\n        String requestURI = getPathWithinApplication(request);\n\n        //the 'chain names' in this implementation are actually path patterns defined by the user.  We just use them\n        //as the chain name for the FilterChainManager's requirements\n        for (String pathPattern : filterChainManager.getChainNames()) {\n\n            // If the path does match, then pass on to the subclass implementation for specific checks:\n            if (pathMatches(pathPattern, requestURI)) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Matched path pattern [\" + pathPattern + \"] for requestURI [\" + requestURI + \"].  \" +\n                            \"Utilizing corresponding filter chain...\");\n                }\n                return filterChainManager.proxy(originalChain, pathPattern);\n            }\n        }\n\n        return null;\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">package com.itheima.shiro.core.impl;\n\nimport lombok.extern.log4j.Log4j2;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.spring.web.ShiroFilterFactoryBean;\nimport org.apache.shiro.web.filter.mgt.FilterChainManager;\nimport org.apache.shiro.web.filter.mgt.FilterChainResolver;\nimport org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver;\nimport org.apache.shiro.web.mgt.WebSecurityManager;\nimport org.apache.shiro.web.servlet.AbstractShiroFilter;\nimport org.springframework.beans.factory.BeanInitializationException;\n\n/**\n * @Description：重写shirod过滤器工厂\n */\n@Log4j2\npublic class CustomShiroFilterFactoryBean extends ShiroFilterFactoryBean {\n\n    PathMatchingFilterChainResolver chainResolver ;\n\n    public void setChainResolver(PathMatchingFilterChainResolver chainResolver) {\n        this.chainResolver = chainResolver;\n    }\n\n    protected AbstractShiroFilter createInstance() throws Exception {\n\n        log.debug(\"Creating Shiro Filter instance.\");\n\n        SecurityManager securityManager = getSecurityManager();\n        if (securityManager == null) {\n            String msg = \"SecurityManager property must be set.\";\n            throw new BeanInitializationException(msg);\n        }\n\n        if (!(securityManager instanceof WebSecurityManager)) {\n            String msg = \"The security manager does not implement the WebSecurityManager interface.\";\n            throw new BeanInitializationException(msg);\n        }\n\n        FilterChainManager manager = createFilterChainManager();\n\n        return new SpringShiroFilter((WebSecurityManager) securityManager, chainResolver);\n    }\n\n    private static final class SpringShiroFilter extends AbstractShiroFilter {\n\n        protected SpringShiroFilter(WebSecurityManager webSecurityManager, FilterChainResolver resolver) {\n            super();\n            if (webSecurityManager == null) {\n                throw new IllegalArgumentException(\"WebSecurityManager property cannot be null.\");\n            }\n            setSecurityManager(webSecurityManager);\n            if (resolver != null) {\n                setFilterChainResolver(resolver);\n            }\n        }\n    }\n}\n</code></pre>\n<h3 id=\"shiroconfig修改\">shiroConfig修改</h3>\n<pre><code class=\"language-java\">package com.itheima.shiro.config;\n\n\nimport com.itheima.shiro.constant.SuperConstant;\nimport com.itheima.shiro.core.ShiroDbRealm;\nimport com.itheima.shiro.core.filter.*;\nimport com.itheima.shiro.core.impl.*;\nimport com.itheima.shiro.properties.PropertiesUtil;\nimport lombok.extern.log4j.Log4j2;\nimport org.apache.shiro.authc.credential.HashedCredentialsMatcher;\nimport org.apache.shiro.session.mgt.eis.SessionDAO;\nimport org.apache.shiro.spring.LifecycleBeanPostProcessor;\nimport org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;\nimport org.apache.shiro.spring.web.ShiroFilterFactoryBean;\nimport org.apache.shiro.web.mgt.DefaultWebSecurityManager;\nimport org.apache.shiro.web.servlet.SimpleCookie;\nimport org.redisson.Redisson;\nimport org.redisson.api.RedissonClient;\nimport org.redisson.config.Config;\nimport org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.DependsOn;\n\nimport javax.servlet.Filter;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @Description 权限配置类\n */\n@Configuration\n@ComponentScan(basePackages = {\"com.itheima.shiro.core\"})\n@EnableConfigurationProperties({ShiroRedisProperties.class})\n@Log4j2\npublic class ShiroConfig {\n\n    @Autowired\n    private ShiroRedisProperties shiroRedisProperties;\n\n    @Autowired\n    JwtTokenManager jwtTokenManager;\n\n    /**\n     * @Description redission客户端\n     */\n    @Bean(\"redissonClientForShiro\")\n    public RedissonClient redissonClient() {\n        log.info(\"=====初始化redissonClientForShiro开始======\");\n        String[] nodeList = shiroRedisProperties.getNodes().split(\",\");\n        Config config = new Config();\n        if (nodeList.length == 1) {\n            config.useSingleServer().setAddress(nodeList[0])\n                    .setConnectTimeout(shiroRedisProperties.getConnectTimeout())\n                    .setConnectionMinimumIdleSize(shiroRedisProperties.getConnectionMinimumidleSize())\n                    .setConnectionPoolSize(shiroRedisProperties.getConnectPoolSize()).setTimeout(shiroRedisProperties.getTimeout());\n        } else {\n            config.useClusterServers().addNodeAddress(nodeList)\n                    .setConnectTimeout(shiroRedisProperties.getConnectTimeout())\n                    .setMasterConnectionMinimumIdleSize(shiroRedisProperties.getConnectionMinimumidleSize())\n                    .setMasterConnectionPoolSize(shiroRedisProperties.getConnectPoolSize()).setTimeout(shiroRedisProperties.getTimeout());\n        }\n        RedissonClient redissonClient =  Redisson.create(config);\n        log.info(\"=====初始化redissonClientForShiro完成======\");\n        return redissonClient;\n    }\n\n    /**\n     * @Description 创建cookie对象\n     */\n    @Bean(name=\"sessionIdCookie\")\n    public SimpleCookie simpleCookie(){\n        SimpleCookie simpleCookie = new SimpleCookie();\n        simpleCookie.setName(\"ShiroSession\");\n        return simpleCookie;\n    }\n\n    /**\n     * @Description 权限管理器\n     * @param\n     * @return\n     */\n    @Bean(name=\"securityManager\")\n    public DefaultWebSecurityManager defaultWebSecurityManager(){\n        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n        securityManager.setRealm(shiroDbRealm());\n        securityManager.setSessionManager(shiroSessionManager());\n        return securityManager;\n    }\n\n    /**\n     * @Description 密码比较器\n     */\n    @Bean\n    public HashedCredentialsMatcher hashedCredentialsMatcher (){\n        RetryLimitCredentialsMatcher matcher = new RetryLimitCredentialsMatcher(SuperConstant.HASH_ALGORITHM,redissonClient());\n        matcher.setHashIterations(SuperConstant.HASH_INTERATIONS);\n        return matcher;\n    }\n    /**\n     * @Description 自定义RealmImpl\n     */\n    @Bean(name=\"shiroDbRealm\")\n    public ShiroDbRealm shiroDbRealm(){\n        ShiroDbRealm shiroDbRealm =new ShiroDbRealmImpl();\n        shiroDbRealm.setCredentialsMatcher(hashedCredentialsMatcher());\n        return shiroDbRealm;\n    }\n\n\n    /**\n     * @Description 自定义session会话存储的实现类 ，使用Redis来存储共享session，达到分布式部署目的\n     */\n    @Bean(\"redisSessionDao\")\n    public SessionDAO redisSessionDao(){\n        RedisSessionDao sessionDAO =   new RedisSessionDao();\n        sessionDAO.setGlobalSessionTimeout(shiroRedisProperties.getGlobalSessionTimeout());\n        return sessionDAO;\n    }\n\n    /**\n     * @Description 会话管理器\n     */\n    @Bean(name=\"sessionManager\")\n    public ShiroSessionManager shiroSessionManager(){\n        ShiroSessionManager sessionManager = new ShiroSessionManager();\n        sessionManager.setSessionDAO(redisSessionDao());\n        sessionManager.setSessionValidationSchedulerEnabled(false);\n        sessionManager.setSessionIdCookieEnabled(true);\n        sessionManager.setSessionIdCookie(simpleCookie());\n        sessionManager.setGlobalSessionTimeout(shiroRedisProperties.getGlobalSessionTimeout());\n        return sessionManager;\n    }\n\n    /**\n     * @Description 保证实现了Shiro内部lifecycle函数的bean执行\n     */\n    @Bean(name = \"lifecycleBeanPostProcessor\")\n    public static LifecycleBeanPostProcessor getLifecycleBeanPostProcessor() {\n        return new LifecycleBeanPostProcessor();\n    }\n\n    /**\n     * @Description AOP式方法级权限检查\n     */\n    @Bean\n    @DependsOn(\"lifecycleBeanPostProcessor\")\n    public DefaultAdvisorAutoProxyCreator getDefaultAdvisorAutoProxyCreator() {\n        DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator();\n        defaultAdvisorAutoProxyCreator.setProxyTargetClass(true);\n        return defaultAdvisorAutoProxyCreator;\n    }\n\n    /**\n     * @Description 配合DefaultAdvisorAutoProxyCreator事项注解权限校验\n     */\n    @Bean\n    public AuthorizationAttributeSourceAdvisor getAuthorizationAttributeSourceAdvisor() {\n        AuthorizationAttributeSourceAdvisor aasa = new AuthorizationAttributeSourceAdvisor();\n        aasa.setSecurityManager(defaultWebSecurityManager());\n        return new AuthorizationAttributeSourceAdvisor();\n    }\n\n    /**\n     * @Description 自定义过滤器定义\n     */\n    private Map&lt;String, Filter&gt; filters() {\n        Map&lt;String, Filter&gt; map = new HashMap&lt;String, Filter&gt;();\n        map.put(\"role-or\", new RolesOrAuthorizationFilter());\n        map.put(\"kicked-out\", new KickedOutAuthorizationFilter(redissonClient(), redisSessionDao(), shiroSessionManager()));\n        map.put(\"jwt-authc\", new JwtAuthcFilter(jwtTokenManager));\n        map.put(\"jwt-perms\", new JwtPermsFilter());\n        map.put(\"jwt-roles\", new JwtRolesFilter());\n        return map;\n    }\n\n\t// ===========================以下是修改部分================================\n\n    @Bean\n    public CustomDefaultFilterChainManager defaultFilterChainManager(){\n        CustomDefaultFilterChainManager defaultFilterChainManager = new CustomDefaultFilterChainManager();\n        defaultFilterChainManager.setCustomFilters(filters());\n        defaultFilterChainManager.setLoginUrl(\"/login\");\n        defaultFilterChainManager.setSuccessUrl(\"/home\");\n        defaultFilterChainManager.setUnauthorizedUrl(\"/login\");\n        return defaultFilterChainManager;\n    }\n\n    @Bean\n    public CustomPathMatchingFilterChainResolver chainResolver(){\n        CustomPathMatchingFilterChainResolver chainResolver = new CustomPathMatchingFilterChainResolver();\n        //指定过滤器管理者\n        chainResolver.setDefaultFilterChainManager(defaultFilterChainManager());\n        return chainResolver;\n    }\n    /**\n     * @Description Shiro过滤器\n     */\n    @Bean(\"shiroFilter\")\n    public ShiroFilterFactoryBean shiroFilterFactoryBean(){\n        CustomShiroFilterFactoryBean shiroFilter = new CustomShiroFilterFactoryBean();\n        shiroFilter.setChainResolver(chainResolver());\n        shiroFilter.setSecurityManager(defaultWebSecurityManager());\n        return shiroFilter;\n    }\n\n}\n</code></pre>\n<h1 id=\"shiro-client客户端\">shiro-client客户端</h1>\n<p>shiro-client作为jar的依赖，满足以下需求：</p>\n<p>1、非侵入式：使用者只需要对jar依赖和做少量的配置，就可以达到统一鉴权的目标</p>\n<p>2、可扩展性：用户除使用提供的过滤器外，可以轻松安自己的业务区定义过滤器</p>\n<p>3、集中式管理：依赖jar之后，shiro-mgt后台可以同时管控多个平台的权限的认证、鉴权、及动态配置过滤器链</p>\n<h2 id=\"依赖关系\">依赖关系</h2>\n<p><img alt=\"1582688991837\" class=\"lazyload\" /></p>\n<h2 id=\"原理分析\">原理分析</h2>\n<p>springboot-shiro-framework-client项目向上继承了springboot-shiro-framework-core项目，springboot-shiro-framework-core是主要实现认证、鉴权、过滤器定义、会话统一、realm缓存的核心项目。</p>\n<p>springboot-shiro-framework-client项目以jar的方式被需要做权限控制的gateway项目所依赖，再由gateway通过对springboot-shiro-producer的dubbo消费，以达到统一认证、鉴权</p>\n<p>springboot-shiro-framework-client模块实现了springboot-shiro-framework-core接口的3个类：</p>\n<p>UserBridgeServiceImpl:提供用户基本资源操作的业务实现<br />\nFilterChainBridgeServiceImpl:提供过滤器链接口的查询<br />\nResourceBridgeServiceImpl:提供资源查询</p>\n<pre><code class=\"language-java\">package com.itheima.shiro.client;\n\nimport com.itheima.shiro.core.bridge.FilterChainBridgeService;\nimport com.itheima.shiro.face.FilterChainFace;\nimport com.itheima.shiro.vo.FilterChainVo;\nimport org.apache.dubbo.config.annotation.Reference;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n/**\n * @Description：自定义过滤器桥接接口实现\n */\n@Service(\"filterChainBridgeService\")\npublic class FilterChainBridgeServiceImpl implements FilterChainBridgeService {\n\n    @Reference(version = \"1.0.0\")\n    private FilterChainFace filterChainFace;\n\n    @Override\n    public List&lt;FilterChainVo&gt; findFilterChainList() {\n        return filterChainFace.findFilterChainList();\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">package com.itheima.shiro.client;\n\nimport com.itheima.shiro.core.bridge.ResourceBridgeService;\nimport com.itheima.shiro.face.ResourceAdapterFace;\nimport com.itheima.shiro.vo.ResourceVo;\nimport org.apache.dubbo.config.annotation.Reference;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport java.util.List;\n\n/**\n * @Description：网关资源桥接器接口实现\n */\n@Component(\"resourceBridgeService\")\npublic class ResourceBridgeServiceImpl implements ResourceBridgeService {\n\n    @Value(\"${itheima.resource.systemcode}\")\n    private String systemCode;\n\n    @Reference(version = \"1.0.0\")\n    ResourceAdapterFace resourceAdapterFace;\n\n    @Override\n    public List&lt;ResourceVo&gt; findValidResourceVoAll(String systemCode) {\n        return resourceAdapterFace.findValidResourceVoAll(systemCode);\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">package com.itheima.shiro.client;\n\nimport com.itheima.shiro.constant.CacheConstant;\nimport com.itheima.shiro.core.SimpleCacheService;\nimport com.itheima.shiro.core.base.ShiroUser;\nimport com.itheima.shiro.core.base.SimpleMapCache;\nimport com.itheima.shiro.core.base.SimpleToken;\nimport com.itheima.shiro.core.bridge.UserBridgeService;\nimport com.itheima.shiro.face.UserAdapterFace;\nimport com.itheima.shiro.utils.BeanConv;\nimport com.itheima.shiro.utils.EmptyUtil;\nimport com.itheima.shiro.utils.ShiroUserUtil;\nimport com.itheima.shiro.vo.ResourceVo;\nimport com.itheima.shiro.vo.RoleVo;\nimport com.itheima.shiro.vo.UserVo;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.dubbo.config.annotation.Reference;\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.SimpleAuthenticationInfo;\nimport org.apache.shiro.authc.UnknownAccountException;\nimport org.apache.shiro.authz.SimpleAuthorizationInfo;\nimport org.apache.shiro.util.ByteSource;\nimport org.redisson.api.RBucket;\nimport org.redisson.api.RedissonClient;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\n\n/**\n * @Description 权限桥接器\n */\n@Slf4j\n@Component(\"userBridgeService\")\npublic class UserBridgeServiceImpl implements UserBridgeService {\n\n    @Reference(version = \"1.0.0\")\n    private UserAdapterFace userAdapterFace;\n\n    @Autowired\n    private SimpleCacheService simpleCacheService;\n\n    @javax.annotation.Resource(name = \"redissonClientForShiro\")\n    private RedissonClient redissonClient;\n\n    public AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authcToken,String realmName) {\n        SimpleToken token = (SimpleToken)authcToken;\n        UserVo user  = this.findUserByLoginName(token.getUsername());\n        if(EmptyUtil.isNullOrEmpty(user)){\n            throw new UnknownAccountException(\"账号不存在\");\n        }\n        ShiroUser shiroUser = BeanConv.toBean(user, ShiroUser.class);\n        String sessionId = ShiroUserUtil.getShiroSessionId();\n        String cacheKeyResourcesIds = CacheConstant.RESOURCES_KEY_IDS+sessionId;\n        shiroUser.setResourceIds(this.findResourcesIdsList(cacheKeyResourcesIds,user.getId()));\n        String salt = user.getSalt();\n        String password = user.getPassWord();\n        return new SimpleAuthenticationInfo(shiroUser, password, ByteSource.Util.bytes(salt), realmName);\n    }\n\n    @Override\n    public SimpleAuthorizationInfo getAuthorizationInfo(ShiroUser shiroUser) {\n        UserVo user = BeanConv.toBean(shiroUser, UserVo.class);\n        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();\n        String sessionId = ShiroUserUtil.getShiroSessionId();\n        //查询用户拥有的角色\n        String cacheKeyRole = CacheConstant.ROLE_KEY + sessionId;\n        info.addRoles(this.findRoleList(cacheKeyRole, user.getId()));\n\n        //查询用户拥有的资源\n        String cacheKeyResources = CacheConstant.RESOURCES_KEY + sessionId;\n        info.addStringPermissions(this.findResourcesList(cacheKeyResources, user.getId()));\n        return info;\n    }\n\n\n    @Override\n    public List&lt;String&gt; findRoleList(String cacheKeyRole, String userId) {\n        List&lt;RoleVo&gt; roles = new ArrayList&lt;RoleVo&gt;();\n        if (simpleCacheService.getCache(cacheKeyRole) != null) {\n            roles = (List&lt;RoleVo&gt;) simpleCacheService.getCache(cacheKeyRole).get(cacheKeyRole);\n        } else {\n            roles = userAdapterFace.findRoleByUserId(userId);\n            if (roles.size() &gt; 0) {\n                //用户角色存放到map\n                Map&lt;Object, Object&gt; mapRole = new HashMap&lt;Object, Object&gt;();\n                mapRole.put(cacheKeyRole, roles);\n                //新建SimpleMapCache实例并放入缓存管理器\n                SimpleMapCache cacheRole = new SimpleMapCache(cacheKeyRole, mapRole);\n                simpleCacheService.creatCache(cacheKeyRole, cacheRole);\n            }\n        }\n        List&lt;String&gt; rolesLabel = new ArrayList&lt;String&gt;();\n        for (RoleVo role : roles) {\n            rolesLabel.add(role.getLabel());\n        }\n        return rolesLabel;\n    }\n\n\n    @Override\n    public List&lt;String&gt; findResourcesList(String cacheKeyResources,String userId) {\n        List&lt;ResourceVo&gt; resourcesList = new ArrayList&lt;ResourceVo&gt;();\n        if (simpleCacheService.getCache(cacheKeyResources) != null) {\n            resourcesList = (List&lt;ResourceVo&gt;) simpleCacheService.getCache(cacheKeyResources).get(cacheKeyResources);\n        } else {\n            resourcesList = userAdapterFace.findResourceByUserId(userId);\n            if (resourcesList.size() &gt; 0) {\n                //用户资源存放到map\n                Map&lt;Object, Object&gt; mapResource = new HashMap&lt;Object, Object&gt;();\n                mapResource.put(cacheKeyResources, resourcesList);\n                //新建SimpleMapCache实例并放入缓存管理器\n                SimpleMapCache cacheResource = new SimpleMapCache(cacheKeyResources, mapResource);\n                simpleCacheService.creatCache(cacheKeyResources, cacheResource);\n            }\n        }\n        List&lt;String&gt; resourcesLabel = new ArrayList&lt;String&gt;();\n        for (ResourceVo resources : resourcesList) {\n            resourcesLabel.add(resources.getLabel());\n        }\n        return resourcesLabel;\n    }\n\n\n    @Override\n    public UserVo findUserByLoginName(String loginName) {\n        String key = CacheConstant.FIND_USER_BY_LOGINNAME+loginName;\n        RBucket&lt;UserVo&gt; rBucket = redissonClient.getBucket(key);\n        UserVo user = rBucket.get();\n        if (!EmptyUtil.isNullOrEmpty(user)) {\n            return user;\n        }else {\n            user = userAdapterFace.findUserByLoginName(loginName);\n            if (!EmptyUtil.isNullOrEmpty(user)) {\n                rBucket.set(user, 300, TimeUnit.SECONDS);\n                return user;\n            }\n        }\n        rBucket.set(new UserVo(), 3, TimeUnit.SECONDS);\n        return null;\n    }\n\n    @Override\n    public List&lt;String&gt; findResourcesIdsList(String cacheKeyResources,String userId) {\n        List&lt;ResourceVo&gt; resourcesList = new ArrayList&lt;ResourceVo&gt;();\n        if (simpleCacheService.getCache(cacheKeyResources) != null) {\n            resourcesList = (List&lt;ResourceVo&gt;) simpleCacheService.getCache(cacheKeyResources).get(cacheKeyResources);\n        } else {\n            resourcesList = userAdapterFace.findResourceByUserId(userId);\n            if (resourcesList.size() &gt; 0) {\n                //用户资源存放到map\n                Map&lt;Object, Object&gt; mapResource = new HashMap&lt;Object, Object&gt;();\n                mapResource.put(cacheKeyResources, resourcesList);\n                //新建SimpleMapCache实例并放入缓存管理器\n                SimpleMapCache cacheResource = new SimpleMapCache(cacheKeyResources, mapResource);\n                simpleCacheService.creatCache(cacheKeyResources, cacheResource);\n            }\n        }\n        List&lt;String&gt; resourcesLabel = new ArrayList&lt;String&gt;();\n        for (ResourceVo resources : resourcesList) {\n            resourcesLabel.add(resources.getId());\n        }\n        return resourcesLabel;\n    }\n\n    @Override\n    public void loadUserAuthorityToCache(ShiroUser user) {\n        String sessionId = user.getSessionId();\n        List&lt;RoleVo&gt; roles = userAdapterFace.findRoleByUserId(user.getId());\n        //创建角色cachaeKey\n        String cacheKeyRole = CacheConstant.ROLE_KEY + sessionId;\n        //用户角色存放到map\n        Map&lt;Object, Object&gt; mapRole = new HashMap&lt;Object, Object&gt;();\n        mapRole.put(cacheKeyRole, roles);\n        //新建SimpleMapCache实例并放入缓存管理器\n        SimpleMapCache cacheRole = new SimpleMapCache(cacheKeyRole, mapRole);\n        simpleCacheService.creatCache(cacheKeyRole, cacheRole);\n\n        List&lt;ResourceVo&gt; resourcesList = userAdapterFace.findResourceByUserId(user.getId());\n        if (resourcesList.size() &gt; 0) {\n            //创建资源cachaeKey\n            String cacheKeyResources = CacheConstant.RESOURCES_KEY + sessionId;\n            //用户资源存放到map\n            Map&lt;Object, Object&gt; mapResource = new HashMap&lt;Object, Object&gt;();\n            mapResource.put(cacheKeyResources, resourcesList);\n            //新建SimpleMapCache实例并放入缓存管理器\n            SimpleMapCache cacheResource = new SimpleMapCache(cacheKeyResources, mapResource);\n            simpleCacheService.creatCache(cacheKeyResources, cacheResource);\n        }\n    }\n}\n</code></pre>\n<h1 id=\"shiro-gateway网关\">shiro-gateway网关</h1>\n<h2 id=\"原理分析-1\">原理分析</h2>\n<p><img alt=\"1582880165581\" class=\"lazyload\" /></p>\n<p>​\t1、依赖springboot-shiro-framework-client实现认证、鉴权、过滤器定义、会话统一、realm缓存等功能</p>\n<p>​\t2、springboot-shiro-mgt管理后台持久化网关资源</p>\n<p>​\t3、springboot-shiro-handler实现网关资源查询服务化</p>\n<p>​\t4、gateway-service依据持久化的网关资源，动态创建消费端服务</p>\n<h2 id=\"代码实现\">代码实现</h2>\n<h3 id=\"网关资源持久化\">网关资源持久化</h3>\n<p>这里在原有资源的基础上，增加的网关资源的管理：</p>\n<p>​\t\t1、定义网关systemcode，用以区分不同网关系统</p>\n<p>​\t\t2、定义访问的路径</p>\n<p>​\t\t3、定义资源的唯一标识，作为权限控制的标识</p>\n<p>​\t\t4、定义业务端dubbo服务端接口、目标方法、传入阐述、轮训算法、超时时间、重试次数等参数，这些内容会在gateway-service项目中解析</p>\n<h3 id=\"网关资源服务化\">网关资源服务化</h3>\n<pre><code class=\"language-properties\">ResourceAdapterFace:网关资源服务接口\nResourceAdapterFaceImpl:网关资源服务接口实现\n\nResourceBridgeService:网关资源桥接器接口\nResourceBridgeServiceImpl:网关资源桥接器接口实现\n</code></pre>\n<pre><code class=\"language-java\">package com.itheima.shiro.face;\n\nimport com.itheima.shiro.vo.ResourceVo;\n\nimport java.util.List;\n\n/**\n * @Description：网关资源服务接口\n */\npublic interface ResourceAdapterFace {\n\n    /**\n     * @Description 获得当前系统是由有效的dubbo的资源\n     */\n    List&lt;ResourceVo&gt; findValidResourceVoAll(String systemCode);\n}\n</code></pre>\n<pre><code class=\"language-java\">package com.itheima.shiro.faceImpl;\n\nimport com.itheima.shiro.face.ResourceAdapterFace;\nimport com.itheima.shiro.pojo.Resource;\nimport com.itheima.shiro.service.ResourceService;\nimport com.itheima.shiro.utils.BeanConv;\nimport com.itheima.shiro.utils.EmptyUtil;\nimport com.itheima.shiro.vo.ResourceVo;\nimport org.apache.dubbo.config.annotation.Service;\nimport org.springframework.beans.factory.annotation.Autowired;\n\nimport java.util.List;\n\n/**\n * @Description：网关资源服务接口实现\n */\n@Service(version = \"1.0.0\", retries = 3,timeout = 5000)\npublic class ResourceAdapterFaceImpl implements ResourceAdapterFace {\n\n    // 网关资源的持久化服务\n    @Autowired\n    ResourceService resourceService;\n\n    @Override\n    public List&lt;ResourceVo&gt; findValidResourceVoAll(String systemCode) {\n        List&lt;Resource&gt; resourceList =  resourceService.findValidResourceVoAll(systemCode);\n        if (!EmptyUtil.isNullOrEmpty(resourceList)){\n            return BeanConv.toBeanList(resourceList, ResourceVo.class);\n        }\n        return  null;\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">package com.itheima.shiro.core.bridge;\n\nimport com.itheima.shiro.vo.ResourceVo;\n\nimport java.util.List;\n\n/**\n * @Description：网关资源桥接器接口\n */\npublic interface ResourceBridgeService {\n\n    /**\n     * @Description 查询当前系统所有有效的DUBBO类型的服务\n     * @param systemCode 系统编号：与mgt添加系统编号相同\n     * @return\n     */\n    public List&lt;ResourceVo&gt; findValidResourceVoAll(String systemCode);\n}\n</code></pre>\n<pre><code class=\"language-java\">package com.itheima.shiro.client;\n\nimport com.itheima.shiro.core.bridge.ResourceBridgeService;\nimport com.itheima.shiro.face.ResourceAdapterFace;\nimport com.itheima.shiro.vo.ResourceVo;\nimport org.apache.dubbo.config.annotation.Reference;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport java.util.List;\n\n/**\n * @Description：网关资源桥接器接口实现\n */\n@Component(\"resourceBridgeService\")\npublic class ResourceBridgeServiceImpl implements ResourceBridgeService {\n\n    @Value(\"${itheima.resource.systemcode}\")\n    private String systemCode;\n\n    @Reference(version = \"1.0.0\")\n    ResourceAdapterFace resourceAdapterFace;\n\n    @Override\n    public List&lt;ResourceVo&gt; findValidResourceVoAll(String systemCode) {\n        return resourceAdapterFace.findValidResourceVoAll(systemCode);\n    }\n}\n</code></pre>\n<h3 id=\"动态消费端\">动态消费端</h3>\n<p><img alt=\"1582882166870\" class=\"lazyload\" /></p>\n<p>CacheWare:缓存仓库</p>\n<p>CacheWareService:缓存仓库服务接口<br />\nCacheWareServiceImpl:缓存仓库服务接口实现</p>\n<p>CacheWareSyncService:缓存仓库同步服务接口<br />\nCacheWareSyncServiceImpl:缓存仓库同步服务接口实现</p>\n<p>LoginAction:登录相应接口<br />\nGateWayController:相应层的统一入口</p>\n<pre><code class=\"language-java\">package com.itheima.shiro.pojo;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\n\n/**\n * @Description 缓存仓库可执行类\n */\n@Data\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class CacheWare {\n\n    //执行类\n    private String serviceName;\n\n    //执行方法\n    private String methodName;\n\n    //方法对象\n    private Method method;\n\n    //参数类型\n    private Class&lt;?&gt; methodParamsClass;\n\n    //代理类\n    private Object proxy;\n\n\n}\n</code></pre>\n<h4 id=\"cachewareservice\">CacheWareService</h4>\n<p>其主要负责：</p>\n<p>1、缓存的清除</p>\n<p>2、向map容器中创建缓存</p>\n<p>3、获得缓存仓库执行对象</p>\n<pre><code class=\"language-java\">package com.itheima.shiro.cache;\n\nimport com.google.common.collect.Multimap;\nimport com.itheima.shiro.pojo.CacheWare;\n\n/**\n * @Description：缓存仓库服务\n */\npublic interface CacheWareService {\n\n    /**\n     * @Description 清除缓存\n     */\n    void clearCacheWare();\n\n    /**\n     * @Description 向map容器中创建缓存\n     * @param cacheWareMap\n     */\n    void createCacheWare(Multimap&lt;String, CacheWare&gt; cacheWareMap);\n\n    /**\n     * @Description 获得缓存仓库执行对象\n     * @param serviceName 服务名\n     * @param methodName  方法名\n     * @return {@link CacheWare}\n     *\n     */\n    CacheWare queryCacheWare(String serviceName, String methodName);\n\n\n}\n</code></pre>\n<pre><code class=\"language-java\">package com.itheima.shiro.cache.impl;\n\nimport com.google.common.collect.ArrayListMultimap;\nimport com.google.common.collect.Multimap;\nimport com.itheima.shiro.cache.CacheWareService;\nimport com.itheima.shiro.pojo.CacheWare;\nimport com.itheima.shiro.utils.EmptyUtil;\nimport org.springframework.stereotype.Service;\n\nimport java.util.Collection;\n\n/**\n * @Description：缓存仓库服务实现\n */\n@Service(\"cacheWareService\")\npublic class CacheWareServiceImpl implements CacheWareService {\n\n    private Multimap&lt;String, CacheWare&gt; cacheWareMap = ArrayListMultimap.create();\n\n    @Override\n    public void clearCacheWare() {\n        cacheWareMap.clear();\n    }\n\n    @Override\n    public void createCacheWare(Multimap&lt;String, CacheWare&gt; cacheWareMap) {\n        this.cacheWareMap = cacheWareMap;\n    }\n\n    @Override\n    public CacheWare queryCacheWare(String serviceName, String methodName) {\n        if (EmptyUtil.isNullOrEmpty(serviceName)||EmptyUtil.isNullOrEmpty(methodName)){\n            return null;\n        }\n        String key = serviceName+\":\"+methodName;\n        Collection&lt;CacheWare&gt; cacheWares =cacheWareMap.get(key);\n        return EmptyUtil.isNullOrEmpty(cacheWares)?null:cacheWares.iterator().next();\n    }\n}\n</code></pre>\n<h4 id=\"cachewaresyncservice\">CacheWareSyncService</h4>\n<p>其主要职责：</p>\n<p>1、启动时、调用CacheWareService的创建缓存方法初始化缓存仓库</p>\n<p>2、同步缓存仓库</p>\n<p>3、网关资源转化缓存仓库可执行对象</p>\n<p>4、从dubbo中，初始化代理对象</p>\n<p>注意：为了在多个网关系统下，接口转换的无干扰，读取的只是本网关所对应的资源</p>\n<pre><code class=\"language-java\">package com.itheima.shiro.cache;\n\nimport com.itheima.shiro.pojo.CacheWare;\nimport com.itheima.shiro.vo.ResourceVo;\n\n/**\n * @Description：缓存仓库同步接口\n */\npublic interface CacheWareSyncService {\n\n    /**\n     * @Description 初始化缓存仓库\n     */\n    void initCacheWare();\n\n    /**\n     * @Description 同步缓存仓库\n     */\n    void refreshCacheWare();\n\n    /**\n     * @Description 资源转换缓存仓库可执行对象\n     */\n    CacheWare resourceConvCacheWare(ResourceVo resource);\n\n    /**\n     * @Description 初始化代理对象\n     * @param interfaceClass 接口\n     * @param loadbalance 算法\n     * @param version 版本\n     * @param timeout 超时时间\n     * @param retries 重试次数\n     */\n    Object initProxy(Class&lt;?&gt; interfaceClass,\n                     String loadbalance,\n                     String version,\n                     Integer timeout,\n                     Integer retries);\n\n    /**\n     * @Description 回收资源\n     */\n    void destoryCacheWare();\n}\n</code></pre>\n<pre><code class=\"language-java\">package com.itheima.shiro.cache.impl;\n\nimport com.google.common.collect.ArrayListMultimap;\nimport com.google.common.collect.Multimap;\nimport com.itheima.shiro.cache.CacheWareService;\nimport com.itheima.shiro.cache.CacheWareSyncService;\nimport com.itheima.shiro.core.bridge.ResourceBridgeService;\nimport com.itheima.shiro.pojo.CacheWare;\nimport com.itheima.shiro.utils.EmptyUtil;\nimport com.itheima.shiro.vo.ResourceVo;\nimport lombok.extern.log4j.Log4j2;\nimport org.apache.dubbo.config.ApplicationConfig;\nimport org.apache.dubbo.config.ReferenceConfig;\nimport org.apache.dubbo.config.RegistryConfig;\nimport org.apache.dubbo.config.utils.ReferenceConfigCache;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\n\nimport javax.annotation.PostConstruct;\nimport javax.annotation.Resource;\nimport java.lang.reflect.Method;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @Description：缓存仓库同步服务接口实现\n */\n@Service(\"cacheWareSyncService\")\n@Log4j2\npublic class CacheWareSyncServiceImpl implements CacheWareSyncService {\n\n    @Value(\"${itheima.resource.systemcode}\")\n    private String systemCode;\n\n    @Autowired\n    CacheWareService cacheWareService;\n\n    @Autowired\n    ResourceBridgeService resourceBridgeService;\n\n    @Autowired\n    private ApplicationConfig applicationConfig;\n\n    @Autowired\n    private RegistryConfig registryConfig;\n\n    //线程池\n    private ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);\n\n    @Override\n    @PostConstruct\n    public void initCacheWare() {\n        executorService.scheduleAtFixedRate(new Runnable() {\n            @Override\n            public void run() {\n                refreshCacheWare();\n            }\n        }, 0, 2, TimeUnit.MINUTES);\n\n    }\n\n    @Override\n    public void refreshCacheWare() {\n        //获得网关资源\n        List&lt;ResourceVo&gt; resources = resourceBridgeService.findValidResourceVoAll(systemCode);\n        //判断网关资源是否为空，则清空所有map容器中的可执行对象\n        if (EmptyUtil.isNullOrEmpty(resources)){\n            cacheWareService.clearCacheWare();\n        }\n        Multimap&lt;String,CacheWare&gt; cacheWareMultimap = ArrayListMultimap.create();\n        //把网关资源转换为缓存仓库可执行对象\n        for (ResourceVo resource : resources) {\n            if (EmptyUtil.isNullOrEmpty(resource.getServiceName())||\n                EmptyUtil.isNullOrEmpty(resource.getMethodName())){\n                log.warn(\"网关资源定义不完整：{}\",resource.toString());\n                continue;\n            }\n            CacheWare cacheWare = resourceConvCacheWare(resource);\n            if (!EmptyUtil.isNullOrEmpty(cacheWare)){\n                String key = cacheWare.getServiceName()+\":\"+cacheWare.getMethodName();\n                cacheWareMultimap.put(key, cacheWare);\n            }\n        }\n\n        //放入map容器\n        cacheWareService.createCacheWare(cacheWareMultimap);\n    }\n\n    @Override\n    public CacheWare resourceConvCacheWare(ResourceVo resource) {\n        //网关资源服务接口\n        Class&lt;?&gt; serviceClass = null;\n        try {\n            serviceClass = Class.forName(resource.getServiceName());\n        } catch (ClassNotFoundException e) {\n            log.error(\"为在容器中发现{}接口类\",resource.getServiceName());\n            return null;\n        }\n        String serviceNameAll = resource.getServiceName();\n        // 获得类名\n        String serviceName = serviceNameAll.substring(serviceNameAll.lastIndexOf(\".\")+1).toLowerCase();\n        //对应的执行方法\n        Method[] methods = serviceClass.getDeclaredMethods();\n        Method methodTarget = null;\n        for (Method method : methods) {\n            if (method.getName().equals(resource.getMethodName())){\n                methodTarget = method;\n                break;\n            }\n        }\n        //如果方法获取失败\n        if (EmptyUtil.isNullOrEmpty(methodTarget)){\n            log.error(\"为在容器中发现{}方法\",resource.getMethodName());\n            return null;\n        }\n        //获得方法上的传入参数\n        Class&lt;?&gt;[] parameterTypes = methodTarget.getParameterTypes();\n        Class&lt;?&gt; methodParamsClassTarget = null;\n        for (Class&lt;?&gt; parameterType : parameterTypes) {\n            if (parameterType.getName().equals(resource.getMethodParam())){\n                methodParamsClassTarget = parameterType;\n                break;\n            }\n        }\n        //构建服务代理类\n        Object proxy = initProxy(serviceClass, resource.getLoadbalance(), resource.getDubboVersion(), resource.getTimeout(), resource.getRetries());\n        //构建缓存仓库可执行对象\n        CacheWare cacheWare = CacheWare.builder()\n                .serviceName(serviceName)\n                .methodName(resource.getMethodName())\n                .method(methodTarget)\n                .methodParamsClass(methodParamsClassTarget)\n                .proxy(proxy).build();\n        return cacheWare;\n    }\n\n    // 获取代理类\n    @Override\n    public Object initProxy(Class&lt;?&gt; interfaceClass, String loadbalance, String version, Integer timeout, Integer retries) {\n        // 构建消费端\n        ReferenceConfig&lt;Object&gt; referenceConfig = new ReferenceConfig&lt;&gt;();\n        referenceConfig.setApplication(applicationConfig);\n        referenceConfig.setRegistry(registryConfig);\n        referenceConfig.setLoadbalance(EmptyUtil.isNullOrEmpty(loadbalance)?\"random\":loadbalance);\n        referenceConfig.setInterface(interfaceClass);\n        referenceConfig.setVersion(version);\n        referenceConfig.setTimeout(EmptyUtil.isNullOrEmpty(timeout)?20000:timeout);\n        referenceConfig.setCheck(false);\n        // 指定重试次数\n        referenceConfig.setRetries(EmptyUtil.isNullOrEmpty(retries)?0:retries);\n        ReferenceConfigCache cache = ReferenceConfigCache.getCache();\n        return cache.get(referenceConfig);\n    }\n\n    @Override\n    public void destoryCacheWare() {\n        executorService.shutdownNow();\n    }\n}\n</code></pre>\n<h3 id=\"网关资源解析\">网关资源解析</h3>\n<p>其主要负责：</p>\n<p>1、传入参数处理</p>\n<p>2、获得可执行缓存仓库</p>\n<p>3、执行远程服务</p>\n<p>4、处理返回结果</p>\n<pre><code class=\"language-java\">package com.itheima.shiro.web;\n\nimport com.alibaba.fastjson.JSONObject;\nimport com.itheima.shiro.base.BaseRequest;\nimport com.itheima.shiro.cache.CacheWareService;\nimport com.itheima.shiro.constant.GateWayConstant;\nimport com.itheima.shiro.pojo.CacheWare;\nimport com.itheima.shiro.response.MultiResponse;\nimport com.itheima.shiro.response.PageResponse;\nimport com.itheima.shiro.response.SingleResponse;\nimport com.itheima.shiro.utils.EmptyUtil;\nimport com.itheima.shiro.view.JsonResult;\nimport lombok.extern.log4j.Log4j2;\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.lang.reflect.Method;\n\n/**\n * @Description：网关统一入口\n */\n@Controller\n@Log4j2\npublic class GateWayController {\n\n    @Autowired\n    CacheWareService cacheWareService;\n\n    /**\n     * @Description 请求入口\n     * @param serviceName 服务名称\n     * @param methodName 目标方法\n     * @param baseRequest 请求对象\n     * @return\n     */\n    @RequestMapping(value = \"{serviceName}/{methodName}\",method = RequestMethod.POST)\n    @ResponseBody\n    public JsonResult postGateWay(@PathVariable(\"serviceName\") String serviceName,\n                                  @PathVariable(\"methodName\") String methodName,\n                                  @RequestBody BaseRequest baseRequest) throws Exception{\n        JsonResult jsonResult = null;\n        if (EmptyUtil.isNullOrEmpty(serviceName)||EmptyUtil.isNullOrEmpty(methodName)){\n            jsonResult = jsonResult.builder()\n                    .result(GateWayConstant.FAIL)\n                    .msg(\"参数缺失\")\n                    .code(GateWayConstant.PARAMETERS_MISSING)\n                    .build();\n                    return  jsonResult;\n        }\n        //传入参数处理\n        JSONObject jsonObject = null;\n        Object datas = baseRequest.getDatas();\n        if (!EmptyUtil.isNullOrEmpty(datas)){\n            jsonObject = JSONObject.parseObject(jsonObject.toJSONString(datas));\n        }\n        //获得缓存仓库可执行对象\n        CacheWare cacheWare = cacheWareService.queryCacheWare(serviceName, methodName);\n        //执行远程服务\n        Object proxy = cacheWare.getProxy();\n        Method method = cacheWare.getMethod();\n        Class&lt;?&gt; methodParamsClass = cacheWare.getMethodParamsClass();\n        Object result = null;\n        if (EmptyUtil.isNullOrEmpty(methodParamsClass)){\n            result = method.invoke(proxy);\n        }else {\n            Object arg = JSONObject.toJavaObject(jsonObject, methodParamsClass);\n            result = method.invoke(proxy,arg);\n        }\n        //处理放回结果\n        return  convResult(result);\n    }\n\n    /**\n     * @Description 处理请求结果\n     */\n    private JsonResult convResult(Object result) {\n        JsonResult jsonResult = JsonResult.builder()\n                .result(GateWayConstant.SUCCEED)\n                .msg(\"相应正常\")\n                .code(GateWayConstant.SUCCEED_CODE)\n                .build();\n        if (EmptyUtil.isNullOrEmpty(result)) {\n            jsonResult = JsonResult.builder()\n                    .result(GateWayConstant.FAIL)\n                    .msg(\"返回结果为空\")\n                    .code(GateWayConstant.RESULT_ISNULLOREMPTY)\n                    .build();\n            return jsonResult;\n        }\n        if (result instanceof SingleResponse) {\n            BeanUtils.copyProperties(result, jsonResult);\n            @SuppressWarnings(\"rawtypes\")\n            SingleResponse singleResponse = (SingleResponse) result;\n            jsonResult.setDatas(singleResponse.getValue());\n        } else if (result instanceof MultiResponse) {\n            BeanUtils.copyProperties(result, jsonResult);\n            @SuppressWarnings(\"rawtypes\")\n            MultiResponse multiResponse = (MultiResponse) result;\n            jsonResult.setDatas(multiResponse.getValues());\n        } else if (result instanceof PageResponse) {\n            BeanUtils.copyProperties(result, jsonResult);\n            PageResponse pageResponse = (PageResponse)result;\n            jsonResult.setDatas( pageResponse.getValues());\n        } else {\n            jsonResult = JsonResult.builder()\n                    .result(GateWayConstant.FAIL)\n                    .msg(\"返回结果格式不正确\")\n                    .code(GateWayConstant.RESULT_MISSING)\n                    .build();\n            return jsonResult;\n        }\n        return jsonResult;\n    }\n}\n</code></pre>\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/alineverstop/\" target=\"_blank\">NE_STOP</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/alineverstop/p/19482539\" target=\"_blank\">https://www.cnblogs.com/alineverstop/p/19482539</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-14 15:51</span>&nbsp;\n<a href=\"https://www.cnblogs.com/alineverstop\">NE_STOP</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "高德地图实现实时轨迹展示",
      "link": "https://www.cnblogs.com/lijinhuaboke/p/19457121",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lijinhuaboke/p/19457121\" id=\"cb_post_title_url\" title=\"发布于 2026-01-14 14:35\">\n    <span>高德地图实现实时轨迹展示</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"vue3--高德地图amap-实现平滑的实时轨迹回放与追踪\">Vue3 + 高德地图(AMap) 实现平滑的实时轨迹回放与追踪</h1>\n<h2 id=\"前言\">前言</h2>\n<p>在物联网、物流监控或安防调度系统中，实时展示设备（如无人机、车辆、手环）的移动轨迹是一个常见需求。如果仅仅是简单的更新标记点位置，视觉上会出现“跳变”现象，体验很不流畅。</p>\n<p>本文将分享如何在 <strong>Vue 3</strong> 项目中，利用 <strong>高德地图 (AMap) JS API</strong> 实现比较丝滑的实时轨效果。</p>\n<h2 id=\"核心痛点\">核心痛点</h2>\n<ol>\n<li><strong>平滑移动</strong>：点位更新时，Marker 需要从旧位置平滑过渡到新位置，而不是瞬间跳过去。</li>\n<li><strong>轨迹跟随</strong>：随着 Marker 的移动，轨迹线（Polyline）需要实时“生长”，紧跟在 Marker 后面。</li>\n<li><strong>增量更新</strong>：后端通常返回完整的历史路径或当前状态，前端需要计算出“新增的路径段”进行动画播放。</li>\n</ol>\n<h2 id=\"实现逻辑解析\">实现逻辑解析</h2>\n<p>核心是利用高德地图 API 的轨迹回放功能。虽然官方文档提供了基础的轨迹回放示例（参考：<a href=\"https://lbs.amap.com/demo/javascript-api-v2/example/marker/replaying-historical-running-data\" rel=\"noopener nofollow\" target=\"_blank\">轨迹回放示例</a>），但官方示例通常是一次性加载完整路径（例如：先获取完整经纬度数组，渲染出浅蓝色背景线，再让小车沿着路径跑并画出浅绿色轨迹）。</p>\n<p><strong>我们的业务场景与官方示例的主要区别在于：</strong><br />\n我们的路径数据是<strong>实时增量更新</strong>的。前端并没有一开始就拿到完整的路径，而是通过 WebSocket 或轮询实时获取后端返回的最新路径数据。因此，我们需要自行设计逻辑，计算出每次更新的“增量片段”，并让 Marker 平滑地走完这一段。</p>\n<h3 id=\"核心思路\">核心思路：</h3>\n<ol>\n<li>\n<p><strong>前后端数据约定</strong>：</p>\n<ul>\n<li>理想情况下，后端最好直接返回“增量路径”（即上一次位置到当前位置的坐标集合）。</li>\n<li>但在实际项目中（比如本案例），后端接口返回的是<strong>当前时刻的完整累积路径</strong>。因此，前端需要自行比对缓存的“上一次路径”和“最新路径”，计算出增量部分。</li>\n</ul>\n</li>\n<li>\n<p><strong>状态管理 (缓存实例)</strong>：</p>\n<ul>\n<li>使用 <code>Map</code> 数据结构来缓存每个设备（如无人机、手环）的 <code>Marker</code>（图标）和 <code>Polyline</code>（轨迹线）实例。</li>\n<li>确保每个设备 ID 对应唯一的地图实例，避免数据刷新时重复创建导致内存泄漏或闪烁。</li>\n</ul>\n</li>\n<li>\n<p><strong>计算增量路径</strong>：</p>\n<ul>\n<li>当新数据到达时，通过对比新旧路径长度，截取出<strong>新增的路径段</strong>。</li>\n<li>这段新增路径就是 Marker 接下来需要“平滑移动”的轨迹。</li>\n</ul>\n</li>\n<li>\n<p><strong>平滑动画 (<code>moveAlong</code>)</strong>：</p>\n<ul>\n<li>调用高德地图的 <code>marker.moveAlong()</code> 方法，让 Marker 沿着新增路径平滑移动，而不是瞬间跳变。</li>\n</ul>\n</li>\n<li>\n<p><strong>实时绘制轨迹 (<code>moving</code> 事件)</strong>：</p>\n<ul>\n<li>监听 Marker 的 <code>moving</code> 事件。在移动过程中，实时更新轨迹线（Polyline）的路径，从而实现“边走边画”的效果。</li>\n<li><strong>关键点</strong>：为什么要在 <code>moving</code> 事件中更新总轨迹，而不是在动画结束 (<code>moveend</code>) 后更新？\n<ul>\n<li>这是为了防止数据推送频率过快。如果等到动画结束再更新，可能会出现“新的数据推送来了，但上一次动画还没结束，导致轨迹数据丢失或衔接不上”的问题。在 <code>moving</code> 过程中实时将 <code>passedPath</code>（已走过的路径）拼接到总轨迹中，是最稳妥的方式。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>动画结束清理</strong>：</p>\n<ul>\n<li>动画结束时 (<code>moveend</code>)，清理临时绘制的辅助线，移除监听器，防止内存泄漏。</li>\n</ul>\n</li>\n</ol>\n<hr />\n<h3 id=\"代码详解\">代码详解</h3>\n<h4 id=\"1-状态管理与初始化\">1. 状态管理与初始化</h4>\n<p>我们使用 <code>Map</code> 来管理地图上的 Marker 和 Polyline 实例。</p>\n<pre><code class=\"language-javascript\">// 存储 Marker 实例 (Key: 设备ID, Value: AMap.Marker)\nconst uavMarkers = ref(new Map());\n// 存储轨迹线 Polyline 实例 (Key: 设备ID, Value: AMap.Polyline)\nconst uavPaths = ref(new Map());\n</code></pre>\n<h4 id=\"2-核心处理函数-refreshtemppoint\">2. 核心处理函数 <code>refreshTempPoint</code></h4>\n<p>这个函数负责处理单条设备数据的更新逻辑。</p>\n<pre><code class=\"language-javascript\">// 刷新设备点位与轨迹\n// item: 后端返回的设备数据对象\n// position: 当前最新的坐标点\n// type: 更新类型（'init' 为初始化，其他为增量更新）\nconst refreshTempPoint = async (item, position, type, marker, tempOverlay, pathOverlay) =&gt; {\n  // 1. 清理上一轮的临时覆盖物（如临时路线、距离文本）\n  tempOverlay?.clearOverlays();\n\n  if (item.coordinatesLine) {\n    const coordinatesLine = JSON.parse(item.coordinatesLine); // 解析后端返回的完整路径数组\n\n    // --- A. 初始化起点 Marker ---\n    let tempMarker = tempUavMarkers.value.get(item.id);\n    if (!tempMarker) {\n      // 如果是第一次出现，渲染起点\n      tempMarker = renderPoint(coordinatesLine[0], item, \"\", pathOverlay);\n      tempUavMarkers.value.set(item.id, tempMarker);\n    }\n\n    // --- B. 获取或创建历史轨迹线 (Polyline) ---\n    let polyline = uavPaths.value.get(item.id);\n    if (!polyline) {\n      polyline = trajectoryLine(item, pathOverlay); // 创建新的线实例\n      uavPaths.value.set(item.id, polyline);\n    }\n\n    // 获取当前地图上已有的路径（缓存的旧路径）\n    const existingPath = polyline.getPath() || [];\n\n    if (type != \"init\") {\n      // --- C. 增量更新逻辑 ---\n      \n      // 1. 计算增量路径：从已有路径的最后一个点开始截取，直到最新路径的末尾\n      const newPathSegment = coordinatesLine.slice(\n        existingPath.length ? existingPath.length - 1 : 0\n      );\n\n      // 2. 创建一条临时的“隐形”线段，用于辅助计算或展示（视需求而定）\n      const newPolyline = trajectoryLine(item, tempOverlay);\n\n      // 3. 如果有新增路径，开始动画\n      if (newPathSegment &amp;&amp; newPathSegment.length &gt; 0) {\n        \n        // 监听移动过程\n        marker.on(\"moving\", function (e) {\n          // e.passedPath 是 Marker 在当前动画片段中已经走过的路径\n          newPolyline.setPath(e.passedPath);\n          \n          // [关键] 实时将走过的路径拼接到历史总轨迹中\n          // 这样即使 WebSocket 推送频率很快，也能保证轨迹数据的连续性\n          polyline.setPath([...existingPath, ...e.passedPath]);\n        });\n\n        // 开始平滑移动\n        marker.moveAlong(newPathSegment, {\n          duration: 1000,    // 动画时长，需根据 WebSocket 推送频率调整\n          autoRotation: true, // 车头自动对准路径方向\n        });\n\n        // 监听移动结束\n        marker.on(\"moveend\", function () {\n          // 动画结束，清理临时覆盖物\n          tempOverlay?.clearOverlays();\n          \n          // 更新距离文本等信息\n          if (item.distance) {\n            renderText(\n              coordinatesLine[Math.ceil(coordinatesLine.length - 2)],\n              `${item.distance}米`,\n              tempOverlay\n            );\n          }\n          \n          // 移除监听器，防止重复绑定\n          marker.off(\"moveend\");\n        });\n      } else {\n        // 如果没有新增路径（位置没变），仅更新文字信息\n        if (item.distance) {\n          renderText(..., `${item.distance}米`, tempOverlay);\n        }\n      }\n\n    } else {\n      // --- D. 初始化逻辑 ---\n      // 如果是初始化加载，直接设置完整路径，不进行动画回放\n      if (item.distance) {\n         renderText(..., `${item.distance}米`, tempOverlay);\n      }\n      polyline.setPath(coordinatesLine);\n    }\n  } else {\n    // --- E. 无轨迹数据时的降级处理 ---\n    // 如果后端没有返回路径数据，直接跳变到最新位置\n    marker.setPosition(position);\n    \n    // 清理相关的轨迹实例和缓存\n    let tempMarker = tempUavMarkers.value.get(item.id);\n    if (tempMarker) {\n      tempMarker.setMap(null);\n      pathOverlay &amp;&amp; pathOverlay.removeOverlay(tempMarker);\n      tempUavMarkers.value.delete(item.id);\n    }\n    \n    let polyline = uavPaths.value.get(item.id);\n    if (polyline) {\n      polyline.setMap(null);\n      pathOverlay &amp;&amp; pathOverlay.removeOverlay(polyline);\n      uavPaths.value.delete(item.id);\n    }\n  }\n};\n</code></pre>\n<p>}<br />\n};</p>\n<pre><code class=\"language-javascript\">\n// 无人机和手环轨迹暂时\nconst refreshAirMap = async (type, data) =&gt; {\n  const res = await getUavElement();\n  // console.log(\"无人机数据\", res.result);\n  res.result.map(async (item) =&gt; {\n    // data.map(async (item) =&gt; {\n    if (item.type == \"1\") {\n      let position = JSON.parse(item.coordinates);\n      // 获取或创建无人机标记\n      let marker = uavMarkers.value.get(item.id);\n      if (!marker) {\n        // 创建无人机、手环点位。\n        marker = renderPoint(position, item, \"\", overlayGroups.value);\n        uavMarkers.value.set(item.id, marker);\n      }else{\n        \n        if (item.elementType == \"2\") {\n          // 已有点位且是手环点位就更新电量\n          marker.setLabel({\n            content: `&lt;div class=\"marker-label-container\"&gt;\n              &lt;div class=\"info-name\"&gt;${item.name}&lt;/div&gt;\n              &lt;div class=\"icon-placeholder\"&gt;&lt;/div&gt;\n              ${batteryHtml(item)}\n            &lt;/div&gt;`,\n            offset: new AMaps.value.Pixel(0, 0),\n            direction: \"center\",\n          });\n        }\n      }\n\n      if (item.elementType == \"1\") {\n        // 无人机轨迹\n        refreshTempPoint(\n          item,\n          position,\n          type,\n          marker,\n          pathOverlayGroups.value,\n          pathsStartPointOverlayGroups.value\n        );\n      } else if (item.elementType == \"2\") {\n        // 手环轨迹\n        refreshTempPoint(\n          item,\n          position,\n          type,\n          marker,\n          rescuePathsOverlayGroups.value,\n          rescueOverlayGroups.value\n        );\n      }\n      // 轨迹部分，判断是否有轨迹\n    }\n  });\n  // });\n};\n</code></pre>\n<p>说明一下哦，我的项目中还需要实现其他功能像是手环电量展示，点击按钮可隐藏无人机轨迹，点击按钮可隐藏手环轨迹，无人机和手环轨迹起始点也需要展示一个点位图标，轨迹线上显示距离，还考虑了第一次进入项目，如无轨迹就只更新点位坐标等等这些，无关的轨迹展示逻辑的各位观众老爷略过就好，这篇文章主要是分享一下实时轨迹实现的逻辑，把轨迹相关逻辑抽出来重新写一份代码，我嫌麻烦嘻嘻。</p>\n<h2 id=\"总结\">总结</h2>\n<p>通过结合 增量路径计算<code>moveAlong</code> 轨迹回放 以及 <code>moving</code> 事件监听，我们实现了一个高性能且视觉流畅的实时轨迹追踪功能。这种方案特别适合无人机巡航、车辆实时定位等需要高频更新位置的场景。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-14 14:35</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lijinhuaboke\">此颜差矣。</a>&nbsp;\n阅读(<span id=\"post_view_count\">147</span>)&nbsp;\n评论(<span id=\"post_comment_count\">3</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "PHP 8.5 升级生存指南：避免凌晨两点回滚的检查清单",
      "link": "https://www.cnblogs.com/catchadmin/p/19479967",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19479967\" id=\"cb_post_title_url\" title=\"发布于 2026-01-14 07:43\">\n    <span>PHP 8.5 升级生存指南：避免凌晨两点回滚的检查清单</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"php-85-升级生存指南避免凌晨两点回滚的检查清单\">PHP 8.5 升级生存指南：避免凌晨两点回滚的检查清单</h1>\n<h2 id=\"升级-php-不难被坑才难\">升级 PHP 不难，被坑才难</h2>\n<p>一月初是做那种\"你永远不想赶工\"的工作的好时机：运行时升级。</p>\n<p>大多数 PHP 8.x 小版本升级很顺利，但\"顺利\"不等于\"零风险\"。真正的问题通常来自：</p>\n<ul>\n<li>隐藏的平台约束（扩展、系统库、SAPI），</li>\n<li>能编译但行为不同的依赖，</li>\n<li>被忽略多年的警告/弃用突然淹没日志，</li>\n<li>假设回滚\"很简单\"的上线计划（实际上很少简单）。</li>\n</ul>\n<p>这篇文章侧重实操。我不会重新讲 PHP 8.5 的新特性，比如管道操作符或 URI 处理。新特性只会作为兼容性检查点简单提及。目标是像成年人一样发布 PHP 8.5：有计划、有防护、有监控、有真正能用的回滚路径。</p>\n<p>PHP 8.5 的稳定版于 2025 年 11 月 20 日发布，遵循正常的 PHP 支持周期。</p>\n<p><a href=\"https://catchadmin.com/post/2026-01/php85-upgrade-survival-guide-checklist\" rel=\"noopener nofollow\" target=\"_blank\">原文 PHP 8.5 升级生存指南：避免凌晨两点回滚的检查清单</a></p>\n<h2 id=\"确定目标版本定义内部支持策略\">确定目标版本，定义内部支持策略</h2>\n<p>在动 CI 或 Composer 之前，先回答一个问题：</p>\n<p><strong>在你的组织里，这次升级\"完成\"意味着什么？</strong></p>\n<h3 id=\"确定目标和截止日期\">确定目标和截止日期</h3>\n<p>PHP 分支有两年的活跃支持，然后是两年的安全修复。</p>\n<p>官方支持表：</p>\n<ul>\n<li>PHP 8.5：2025 年 11 月 20 日初始发布</li>\n<li>活跃支持至 2027 年 12 月 31 日</li>\n<li>安全支持至 2029 年 12 月 31 日</li>\n</ul>\n<p>支持窗口很宽裕——但你的内部截止日期通常由以下因素驱动：</p>\n<ul>\n<li>合规要求，</li>\n<li>托管镜像 / 基础容器，</li>\n<li>框架支持窗口，</li>\n<li>停留在\"仅安全修复\"阶段的成本。</li>\n</ul>\n<h3 id=\"定义范围升级常常在这里无声失败\">定义范围（升级常常在这里无声失败）</h3>\n<p>写下什么包含、什么不包含：</p>\n<p><strong>包含：</strong></p>\n<ul>\n<li>运行时版本升级（FPM/CLI），</li>\n<li>Composer 依赖调整，</li>\n<li>CI 矩阵更新，</li>\n<li>生产环境上线策略，</li>\n<li>升级后验证。</li>\n</ul>\n<p><strong>不包含（除非你明确加进去）：</strong></p>\n<ul>\n<li>重构代码以使用 PHP 8.5 新特性，</li>\n<li>与 PHP 8.5 无关的主要框架升级，</li>\n<li>\"顺手改\"的重写。</li>\n</ul>\n<p>如果不定义范围，\"升级\"会变成\"重写\"，然后就会停滞。</p>\n<h3 id=\"提前决定兼容性策略\">提前决定兼容性策略</h3>\n<p>如果代码库需要在旧版 PHP 和 8.5 上同时运行一段时间：</p>\n<ul>\n<li>用 CI 强制双版本兼容，</li>\n<li>在生产环境切到 8.5 之前，不要合并 8.5 专属语法（比如 <code>|&gt;</code>）。</li>\n</ul>\n<p>如果做硬切换：</p>\n<ul>\n<li>确保上线/回滚方案万无一失，</li>\n<li>接受功能分支可能更早开始使用 8.5 专属语法。</li>\n</ul>\n<h2 id=\"初始审计当前-php扩展和依赖约束\">初始审计：当前 PHP、扩展和依赖约束</h2>\n<p>大多数\"PHP 升级\"bug 不是语言 bug，而是环境不匹配。</p>\n<h3 id=\"快照实际运行的运行时\">快照实际运行的运行时</h3>\n<p>在生产环境运行这些命令，不是你的笔记本：</p>\n<pre><code class=\"language-bash\">php -v\nphp -m\nphp --ini\nphp -i | head -n 50\n</code></pre>\n<p>如果用 PHP-FPM，还要捕获：</p>\n<ul>\n<li>FPM pool 配置，</li>\n<li>ini 覆盖，</li>\n<li>传给 FPM 的环境变量，</li>\n<li>opcache/JIT 设置（这些在不同环境可能不同）。</li>\n</ul>\n<h3 id=\"创建可复用的平台快照脚本\">创建可复用的\"平台快照\"脚本</h3>\n<p>把这样一个脚本放到 <code>tools/php-platform-snapshot.php</code>，在每个环境（开发/预发/生产）运行。提交脚本本身，不要让它成为口口相传的知识。</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\nfunction ext_version(string $ext): ?string {\n    $v = phpversion($ext);\n    return $v === false ? null : $v;\n}\n$snapshot = [\n    'php_version' =&gt; PHP_VERSION,\n    'php_version_id' =&gt; PHP_VERSION_ID,\n    'sapi' =&gt; PHP_SAPI,\n    'os' =&gt; PHP_OS_FAMILY . ' ' . php_uname('r'),\n    'ini_loaded' =&gt; php_ini_loaded_file(),\n    'ini_scanned' =&gt; php_ini_scanned_files(),\n    'extensions' =&gt; [],\n];\n$exts = get_loaded_extensions();\nsort($exts);\nforeach ($exts as $ext) {\n    $snapshot['extensions'][$ext] = ext_version($ext);\n}\necho json_encode($snapshot, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES) . PHP_EOL;\n</code></pre>\n<p>这能给你两个有用的东西：</p>\n<ul>\n<li>测试 8.5 时可以 diff 的\"什么变了\"记录，</li>\n<li>快速发现\"预发能跑生产不能跑\"问题的方法——往往是生产多了一个扩展或 ini 不同。</li>\n</ul>\n<h3 id=\"盘点-composer-平台要求\">盘点 Composer 平台要求</h3>\n<p>Composer 把你的 PHP 运行时和扩展当作\"平台包\"，依赖可以 require 它们。</p>\n<p>有用的命令：</p>\n<pre><code class=\"language-bash\">composer show --platform\ncomposer check-platform-reqs\n</code></pre>\n<ul>\n<li><code>composer show --platform</code> 列出 Composer 看到的平台包。</li>\n<li><code>composer check-platform-reqs</code> 验证你的真实服务器是否满足已安装包的 PHP/ext 要求（它会故意忽略 <code>config.platform</code>）。</li>\n</ul>\n<p>这是在部署前发现\"生产缺 ext-intl\"最快的方法。</p>\n<h2 id=\"构建-ci-矩阵在旧版-php-和-85-上运行测试把警告当信号\">构建 CI 矩阵：在旧版 PHP 和 8.5 上运行测试（把警告当信号）</h2>\n<p>CI 是让升级变得可预测的地方。</p>\n<h3 id=\"规则在生产稳定运行-85-之前保留旧运行时在-ci-中\">规则：在生产稳定运行 8.5 之前，保留旧运行时在 CI 中</h3>\n<p>即使你计划硬切换，短暂的重叠期也能帮你避免\"我们在生产准备好之前合并了 8.5 专属代码\"。</p>\n<h3 id=\"github-actions-矩阵示例旧版-php--php-85\">GitHub Actions 矩阵示例（旧版 PHP + PHP 8.5）</h3>\n<p>如果用 GitHub Actions，shivammathur/setup-php 支持直接指定 <code>'8.5'</code>。</p>\n<pre><code class=\"language-yaml\">name: CI\non:\n  push:\n  pull_request:\njobs:\n  tests:\n    runs-on: ubuntu-latest\n    strategy:\n      fail-fast: false\n      matrix:\n        php: ['8.3', '8.5'] # 调整为你的当前版本 + 目标版本\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup PHP\n        uses: shivammathur/setup-php@v2\n        with:\n          php-version: ${{ matrix.php }}\n          tools: composer:v2\n          coverage: none\n      - name: Install dependencies\n        run: composer install --no-interaction --prefer-dist\n      - name: Run tests\n        run: vendor/bin/phpunit\n</code></pre>\n<h3 id=\"区分错误警告和弃用\">区分\"错误\"、\"警告\"和\"弃用\"</h3>\n<p>不要立刻把所有东西都当失败。先分类：</p>\n<ul>\n<li><strong>解析错误 / 致命错误</strong>：阻止升级。</li>\n<li><strong>行为变更</strong>：通常需要测试 + 代码修复。</li>\n<li><strong>弃用</strong>：不一定阻止升级，但它们预示未来会坏——而且可能很快淹没日志。</li>\n</ul>\n<p>PHPUnit 本身就区分 outcomes（failed/errored）和 issues（warnings、risky tests 等）。</p>\n<p>一个实用的升级策略：</p>\n<ul>\n<li>即使存在弃用，也让测试在 8.5 上通过，</li>\n<li>但加一个单独的 CI job 来统计弃用数量并强制执行预算（比如\"弃用不能超过 N 条\"）。</li>\n</ul>\n<p>这通常比一夜之间打开\"任何弃用都失败\"更现实。</p>\n<h2 id=\"弃用和行为变更像处理故障一样分类而非当重构\">弃用和行为变更：像处理故障一样分类，而非当重构</h2>\n<p>PHP 8.5 新增了一批弃用特性和几个可能让人意外的不兼容变更。官方迁移指南对此有详细说明。</p>\n<h3 id=\"一个有效的分类工作流\">一个有效的分类工作流</h3>\n<ol>\n<li>\n<p><strong>暴露</strong>：在 CI 和预发环境启用 E_ALL。</p>\n</li>\n<li>\n<p><strong>分组</strong>：按消息签名聚类（相同文件/行/消息）。</p>\n</li>\n<li>\n<p><strong>排序</strong>：按风险优先：</p>\n<ul>\n<li>安全相关，</li>\n<li>运行时正确性，</li>\n<li>日志量 / 运维噪音，</li>\n<li>未来破坏可能性。</li>\n</ul>\n</li>\n<li>\n<p><strong>修复</strong>：最小的安全变更。</p>\n</li>\n<li>\n<p><strong>防止回归</strong>：添加针对性测试或静态规则。</p>\n</li>\n</ol>\n<h3 id=\"到处都会冒出来的常见弃用\">到处都会冒出来的常见弃用</h3>\n<p>这些是让团队说\"等等，这以前居然允许？\"的问题：</p>\n<p><strong>非规范的类型转换名称已弃用</strong>：<code>(boolean)</code>、<code>(integer)</code>、<code>(double)</code>、<code>(binary)</code> → 用 <code>(bool)</code>、<code>(int)</code>、<code>(float)</code>、<code>(string)</code>。</p>\n<p>快速搜索：</p>\n<ul>\n<li>grep 搜 <code>\\(integer\\)</code> / <code>\\(boolean\\)</code> 等，</li>\n<li>应用 codemod（或 Rector——后面会讲）。</li>\n</ul>\n<p><strong>case 语句用分号结尾已弃用</strong>（用 <code>:</code>）。</p>\n<p>这常出现在\"一直能跑\"的老 switch 块里。</p>\n<p><strong>用 null 作为数组偏移（或在 array_key_exists 中）已弃用</strong>；PHP 建议用空字符串代替。</p>\n<p>这通常指向输入规范化 bug——修根本原因，不只是修警告。</p>\n<p><strong>递增非数字字符串已弃用</strong>；用 <code>str_increment()</code> 代替。</p>\n<p>如果你有代码用 <code>$s++</code> 做字母递增，会看到这个。</p>\n<p><strong>反引号操作符已弃用</strong>（它是 shell_exec 的别名）。</p>\n<p>即使你接受安全风险，也不想让弃用警告风暴淹没生产日志。</p>\n<p><strong><code>__sleep()</code> 和 <code>__wakeup()</code> 软弃用</strong>；优先用 <code>__serialize()</code> / <code>__unserialize()</code>（或在过渡期同时支持两者）。</p>\n<h3 id=\"运维相关的弃用扩展ini空操作函数\">运维相关的弃用（扩展、ini、\"空操作\"函数）</h3>\n<p>有些弃用是\"你不再需要这个了\"，但仍可能让你措手不及：</p>\n<ul>\n<li><code>curl_close()</code> 和 <code>curl_share_close()</code> 已弃用，因为句柄会自动释放。</li>\n<li><code>imagedestroy()</code> 已弃用，因为 GdImage 会自动释放。</li>\n<li><code>finfo_close()</code> 已弃用，因为 finfo 对象会自动释放。</li>\n<li><code>MHASH_*</code> 常量已弃用。</li>\n<li>PDO <code>\"uri:\"</code> DSN scheme 因安全原因已弃用。</li>\n</ul>\n<p>如果你运维大型应用，这些很重要，因为它们可能：</p>\n<ul>\n<li>日志爆炸（噪音），</li>\n<li>掩盖真正的错误，</li>\n<li>或指示值得审查的安全敏感行为（远程 URI 的 PDO DSN）。</li>\n</ul>\n<h3 id=\"值得尽早检查的不兼容变更\">值得尽早检查的不兼容变更</h3>\n<p>来自官方列表：</p>\n<ul>\n<li><code>class_alias()</code> 不能再用 \"array\" 或 \"callable\" 作为别名。</li>\n<li>对象到布尔的松散比较被统一为与 <code>(bool)$object</code> 行为一致。</li>\n<li>Trait 在父类之前绑定（微妙的行为变更）。</li>\n<li>某些 attribute 目标验证错误现在在编译期发生（有选项可以延迟）。</li>\n</ul>\n<p>你可能永远不会遇到这些。但如果遇到，你希望它们在 CI 立刻失败——而不是在生产环境。</p>\n<h2 id=\"composer-策略lock-文件平台要求和分阶段更新\">Composer 策略：lock 文件、平台要求和分阶段更新</h2>\n<p>依赖管理是升级出问题的地方。</p>\n<h3 id=\"理解-composer-在检查什么\">理解 Composer 在检查什么</h3>\n<p>Composer 把当前 PHP 版本建模为平台包（<code>php</code>），并据此检查你的依赖。</p>\n<p>所以你有两个相关的问题：</p>\n<ol>\n<li>\"我的依赖图能在 PHP 8.5 上解析吗？\"</li>\n<li>\"我的生产环境真的满足解析出的依赖图吗？\"</li>\n</ol>\n<h3 id=\"分阶段更新依赖不要一次性搞定\">分阶段更新依赖（不要\"一次性搞定\"）</h3>\n<p>一个实用的分阶段方法：</p>\n<p><strong>阶段 A：不改变运行时，解析依赖</strong></p>\n<ul>\n<li>在当前 PHP 版本上更新依赖（如果可能）。</li>\n<li>目标：减少同时出现的未知数。</li>\n</ul>\n<p><strong>阶段 B：假设在 PHP 8.5 上解析依赖</strong></p>\n<ul>\n<li>在 <code>composer.json</code> 中用 <code>config.platform.php</code> 模拟 PHP 8.5 进行依赖解析（临时的，在分支上）。</li>\n<li>然后可控地运行 <code>composer update</code>。</li>\n</ul>\n<p><strong>阶段 C：在真实 PHP 8.5 运行时上安装</strong></p>\n<ul>\n<li>在 CI/预发环境的真实 8.5 上运行完整测试套件。</li>\n</ul>\n<h3 id=\"正确使用-composer-的平台检查\">正确使用 Composer 的平台检查</h3>\n<ul>\n<li><code>platform-check</code> 控制在 Composer 的 autoloader bootstrap 中生成 <code>platform_check.php</code>。</li>\n<li><code>composer check-platform-reqs</code> 验证真实运行时是否匹配已安装包的要求。</li>\n</ul>\n<p>换句话说：</p>\n<ul>\n<li>用 <code>config.platform</code> 来模拟和解析。</li>\n<li>用 <code>check-platform-reqs</code> 来确保生产实际兼容。</li>\n</ul>\n<h3 id=\"升级期间会反复使用的安全更新命令\">升级期间会反复使用的安全更新命令</h3>\n<p>常见模式：</p>\n<pre><code class=\"language-bash\"># 保守地更新依赖\ncomposer update --no-interaction --with-all-dependencies\n\n# 严格按 lock 文件安装\ncomposer install --no-interaction --prefer-dist\n</code></pre>\n<p>如果需要追查一个有问题的包：</p>\n<ul>\n<li>显式更新它（加依赖），</li>\n<li>在 CI 的两个运行时上重新运行。</li>\n</ul>\n<p>避免把\"忽略平台要求\"当成解决方案。它能让你本地脱困，但不是迁移策略。</p>\n<h2 id=\"部署前添加可观测性这样你能证明升级是健康的\">部署前添加可观测性（这样你能证明升级是健康的）</h2>\n<p>如果不能度量，就会争论。</p>\n<h3 id=\"基线化健康的含义\">基线化\"健康\"的含义</h3>\n<p>在部署 PHP 8.5 之前，捕获：</p>\n<ul>\n<li>错误率（HTTP 5xx + 未捕获异常），</li>\n<li>慢请求率（p95/p99），</li>\n<li>内存使用趋势（FPM worker），</li>\n<li>队列延迟（如果你跑 worker），</li>\n<li>日志量（尤其是警告/弃用）。</li>\n</ul>\n<h3 id=\"临时增加日志信号但不要让日志变成垃圾场\">临时增加日志信号（但不要让日志变成垃圾场）</h3>\n<p>在升级窗口期间，加一个短期的\"升级视角\"是合理的：</p>\n<ul>\n<li>在进程启动时记录 PHP 版本（FPM/CLI worker），</li>\n<li>给错误打上运行时标签（旧版 vs 8.5），</li>\n<li>按端点/worker 类型统计弃用数量。</li>\n</ul>\n<p>在 PHP 中，你可以在前端控制器（或框架 bootstrap）里为预发环境添加一个最小的错误处理器：</p>\n<pre><code class=\"language-php\">set_error_handler(static function (int $severity, string $message, string $file, int $line): bool {\n    if (!(error_reporting() &amp; $severity)) {\n        return false;\n    }\n    // 示例：把弃用/警告路由到专用 logger channel\n    if ($severity === E_DEPRECATED || $severity === E_USER_DEPRECATED) {\n        error_log(\"[DEPRECATED] {$message} in {$file}:{$line}\");\n        return true; // 已处理\n    }\n    return false; // 让正常处理器运行\n});\n</code></pre>\n<p>保持临时性。目标是上线期间的清晰度，不是一个永久的自定义错误框架。</p>\n<h3 id=\"确保绕过处理器的警告不会让你措手不及\">确保\"绕过处理器的警告\"不会让你措手不及</h3>\n<p>PHP 8.5 弃用了在用户输出处理器内部产生输出的行为，并指出警告会绕过处理器以确保可见性。</p>\n<p>如果你做自定义输出缓冲的骚操作，在预发环境用真实流量模式测试它们。</p>\n<h2 id=\"上线策略金丝雀或蓝绿部署加上实际能用的回滚\">上线策略：金丝雀或蓝绿部署，加上实际能用的回滚</h2>\n<p>这是运维升级成败的关键。</p>\n<h3 id=\"金丝雀基础最小可行的安全上线\">金丝雀基础（最小可行的安全上线）</h3>\n<ol>\n<li>先把 PHP 8.5 部署到小比例的流量。</li>\n<li>对比错误率和延迟与基线。</li>\n<li>保持金丝雀足够长的时间以覆盖真实业务流程（不只是健康检查）。</li>\n</ol>\n<p>实现取决于你的技术栈：</p>\n<ul>\n<li>负载均衡器后面的两个 FPM pool，</li>\n<li>Kubernetes deployment 加权重路由，</li>\n<li>两个 ASG / 两个 service 加渐进流量切换。</li>\n</ul>\n<h3 id=\"蓝绿部署适合大爆炸式组织\">蓝绿部署适合\"大爆炸\"式组织</h3>\n<p>如果你的组织偏好硬切换：</p>\n<ul>\n<li>保持新旧环境都在线，</li>\n<li>切换流量，</li>\n<li>保持旧环境热备以便快速回滚。</li>\n</ul>\n<h3 id=\"回滚计划必须包含依赖和缓存\">回滚计划必须包含依赖和缓存</h3>\n<p>回滚不只是\"指回旧的 PHP 二进制\"。</p>\n<p>回滚现实性检查清单：</p>\n<ul>\n<li>保留之前的容器镜像（或包）。</li>\n<li>保留之前的 <code>composer.lock</code> 制品。</li>\n<li>知道切换运行时时 opcache/APCu 或框架缓存是否需要清理。</li>\n<li>确保数据库迁移是向后兼容的（或明确排除在升级范围外）。</li>\n</ul>\n<p>如果回滚需要三个人和一份 wiki 页面，在压力下它会失败。</p>\n<h2 id=\"升级后检查清单先验证正确性再验证性能然后清理\">升级后检查清单：先验证正确性，再验证性能，然后清理</h2>\n<p>一旦 PHP 8.5 开始服务真实流量，你的工作还没完。现在进入\"验证和稳定\"模式。</p>\n<h3 id=\"即时检查第一小时\">即时检查（第一小时）</h3>\n<ul>\n<li>扫描错误日志查找新的致命错误/异常。</li>\n<li>观察日志量是否突然增长（通常是弃用）。</li>\n<li>在生产主机上验证 <code>composer check-platform-reqs</code>。</li>\n<li>用合成检查验证核心流程（登录、结账、上传、定时任务端点）。</li>\n</ul>\n<h3 id=\"首日检查\">首日检查</h3>\n<ul>\n<li>对比 p95/p99 延迟与基线。</li>\n<li>检查内存使用：\n<ul>\n<li>FPM worker RSS 增长，</li>\n<li>worker 回收频率，</li>\n<li>队列 worker 内存泄漏。</li>\n</ul>\n</li>\n<li>验证后台任务：\n<ul>\n<li>worker 在新运行时上已重启，</li>\n<li>没有\"卡住\"的队列，</li>\n<li>没有静默失败。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"首周清理\">首周清理</h3>\n<ul>\n<li>移除你为上线视角添加的临时额外日志。</li>\n<li>把高频弃用转成跟踪的工单并逐步消灭。</li>\n<li>再次收紧 CI：\n<ul>\n<li>提高弃用的标准，</li>\n<li>确认稳定后从矩阵中移除旧 PHP 版本。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"关于-php-85-特性的快速兼容性说明不展开教程\">关于 PHP 8.5 特性的快速兼容性说明（不展开教程）</h2>\n<p>PHP 8.5 引入了新的语言和运行时特性，如管道操作符、URI 扩展、clone-with 等。</p>\n<p>升级期间不需要采用它们。但你应该：</p>\n<ul>\n<li>确保你的 linter/formatter 识别 PHP 8.5 语法，</li>\n<li>确保 CI 在 PHP 8.5 上运行后再合并任何 8.5 专属语法，</li>\n<li>把特性采用和运行时迁移分开（范围控制）。</li>\n</ul>\n<h2 id=\"结论把升级当部署来对待就会顺利\">结论：把升级当部署来对待，就会顺利</h2>\n<p>升级到 PHP 8.5 通常不是\"重写\"问题。是纪律问题：</p>\n<ul>\n<li>定义范围，</li>\n<li>审计真实平台，</li>\n<li>运行 CI 矩阵，</li>\n<li>系统地分类弃用和不兼容，</li>\n<li>有意识地管理依赖，</li>\n<li>上线前添加可观测性，</li>\n<li>带着策略和回滚路径部署，</li>\n<li>切换后验证和稳定。</li>\n</ul>\n<p>如果你遵循这个顺序，PHP 升级就不再可怕——它只是另一个常规的运维变更。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-14 07:43</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">10</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "LangChain、LangFlow、LangGraph：一文讲清三大 LLM 框架的定位与差异",
      "link": "https://www.cnblogs.com/jyzhao/p/19479470/langchainlangflowlanggraph-yi-wen-jiang-qing-san-d",
      "published": "",
      "description": "<a name=\"top\"></a>\n    <h2><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/jyzhao/p/19479470/langchainlangflowlanggraph-yi-wen-jiang-qing-san-d\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 23:25\">\n    <span>LangChain、LangFlow、LangGraph：一文讲清三大 LLM 框架的定位与差异</span>\n    \n\n</a>\n</h2>\n    <small>\n<span id=\"post-date\">2026-01-13 23:25</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jyzhao\">AlfredZhao</a>&nbsp;\n阅读(<span id=\"post_view_count\">163</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</small>\n    <div class=\"entry\">\n        <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>随着大模型（LLM）进入工程化落地阶段，<strong>“如何把模型变成真正可用的应用”</strong> 成了很多从业者绕不开的问题。<br />\n围绕这个目标，社区里逐渐形成了一批成熟的开源框架，其中被讨论最多的就是 <strong>LangChain、LangFlow、LangGraph</strong>。</p>\n<p>它们名字相似，但<strong>解决的问题并不相同</strong>。本文笔者将基于官方文档与开源实践，从<strong>定位、能力、使用场景和差异</strong>几个角度，帮你一次性理清。</p>\n<hr />\n<h2 id=\"01--langchainllm-应用的基础设施层\">01 | LangChain：LLM 应用的“基础设施层”</h2>\n<h3 id=\"-langchain-是什么\">① LangChain 是什么？</h3>\n<p>LangChain 是一个<strong>用于构建 LLM 应用的通用框架</strong>，核心目标只有一句话：</p>\n<blockquote>\n<p>把「大模型 + 外部工具 + 数据源 + Prompt」系统化地组织起来。</p>\n</blockquote>\n<p>它并不是一个“产品”，而是一套 <strong>开发范式和组件库</strong>。</p>\n<hr />\n<h3 id=\"-langchain-解决什么问题\">② LangChain 解决什么问题？</h3>\n<p>在没有 LangChain 之前，开发者通常需要自己处理：</p>\n<ul>\n<li>Prompt 拼接</li>\n<li>模型调用</li>\n<li>上下文管理</li>\n<li>工具调用（SQL、搜索、API）</li>\n<li>RAG（检索增强生成）</li>\n</ul>\n<p>LangChain 把这些抽象成了标准组件，例如：</p>\n<ul>\n<li>LLM / ChatModel</li>\n<li>PromptTemplate</li>\n<li>Chain</li>\n<li>Tool / Agent</li>\n<li>Memory</li>\n</ul>\n<hr />\n<h3 id=\"-典型应用场景\">③ 典型应用场景</h3>\n<ul>\n<li>RAG 问答系统</li>\n<li>NL2SQL</li>\n<li>AI 助手 / Copilot</li>\n<li>工具型 Agent</li>\n</ul>\n<p><strong>一句话总结</strong>：<br />\n<strong>LangChain = 写 LLM 应用的“后端开发框架”</strong></p>\n<hr />\n<h2 id=\"02--langflowlangchain-的可视化低代码入口\">02 | LangFlow：LangChain 的可视化“低代码入口”</h2>\n<h3 id=\"-langflow-是什么\">① LangFlow 是什么？</h3>\n<p>LangFlow 是一个 <strong>基于 LangChain 的可视化编排工具</strong>。</p>\n<p>你可以理解为：</p>\n<blockquote>\n<p>用“拖拽流程图”的方式来搭 LangChain 应用。</p>\n</blockquote>\n<p>它本质上是：</p>\n<ul>\n<li>前端可视化</li>\n<li>后端仍然运行 LangChain 逻辑</li>\n</ul>\n<hr />\n<h3 id=\"-langflow-的核心价值\">② LangFlow 的核心价值</h3>\n<p>LangFlow 并没有引入新的模型能力，它的优势在于：</p>\n<ul>\n<li><strong>降低学习门槛</strong></li>\n<li>快速原型验证</li>\n<li>Prompt / Chain 可视化调试</li>\n</ul>\n<p>对不熟悉 Python 或刚接触 LLM 的人非常友好。</p>\n<hr />\n<h3 id=\"-典型应用场景-1\">③ 典型应用场景</h3>\n<ul>\n<li>产品经理 / 咨询顾问做 Demo</li>\n<li>Prompt 调优与流程验证</li>\n<li>教学与分享演示</li>\n<li>小型 PoC 项目</li>\n</ul>\n<p><strong>一句话总结</strong>：<br />\n<strong>LangFlow = LangChain 的“可视化操作台”</strong></p>\n<hr />\n<h2 id=\"03--langgraph为复杂-agent-而生的状态机框架\">03 | LangGraph：为复杂 Agent 而生的“状态机框架”</h2>\n<h3 id=\"-langgraph-是什么\">① LangGraph 是什么？</h3>\n<p>LangGraph 是 LangChain 官方推出的一个<strong>新框架</strong>，专门解决一个问题：</p>\n<blockquote>\n<p>当 Agent 逻辑变复杂，Chain 已经不够用了，怎么办？</p>\n</blockquote>\n<p>LangGraph 引入的是：</p>\n<ul>\n<li><strong>Graph（图）</strong></li>\n<li><strong>State（状态）</strong></li>\n<li><strong>节点 + 边 + 循环</strong></li>\n</ul>\n<p>本质上是：<br />\n<strong>把 LLM Agent 当成一个“有状态的工作流/状态机”来建模</strong>。</p>\n<hr />\n<h3 id=\"-langgraph-为什么出现\">② LangGraph 为什么出现？</h3>\n<p>在真实项目中，Agent 往往需要：</p>\n<ul>\n<li>多轮决策</li>\n<li>条件分支</li>\n<li>回退 / 重试</li>\n<li>人工介入（Human-in-the-loop）</li>\n</ul>\n<p>这些用传统 Chain 非常别扭，而 LangGraph 天然支持：</p>\n<ul>\n<li>循环</li>\n<li>分支</li>\n<li>并行</li>\n<li>可恢复执行</li>\n</ul>\n<hr />\n<h3 id=\"-典型应用场景-2\">③ 典型应用场景</h3>\n<ul>\n<li>多 Agent 协作系统</li>\n<li>复杂业务流程自动化</li>\n<li>长任务 AI 助手</li>\n<li>需要“可控行为”的智能体</li>\n</ul>\n<p><strong>一句话总结</strong>：<br />\n<strong>LangGraph = 面向复杂 Agent 的“流程与状态控制层”</strong></p>\n<hr />\n<h2 id=\"04--三者核心差异一图读懂\">04 | 三者核心差异一图读懂</h2>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>LangChain</th>\n<th>LangFlow</th>\n<th>LangGraph</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>核心定位</td>\n<td>LLM 应用框架</td>\n<td>可视化编排工具</td>\n<td>Agent 状态机框架</td>\n</tr>\n<tr>\n<td>抽象模型</td>\n<td>Chain / Agent</td>\n<td>Flow</td>\n<td>Graph / State</td>\n</tr>\n<tr>\n<td>使用方式</td>\n<td>写代码</td>\n<td>拖流程</td>\n<td>写图结构代码</td>\n</tr>\n<tr>\n<td>适合人群</td>\n<td>工程师</td>\n<td>初学者 / 产品</td>\n<td>高级工程师</td>\n</tr>\n<tr>\n<td>复杂逻辑</td>\n<td>一般</td>\n<td>一般</td>\n<td>非常强</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h2 id=\"05--应该如何选择\">05 | 应该如何选择？</h2>\n<p>笔者给你一个<strong>不踩坑的选择建议</strong>：</p>\n<ul>\n<li><strong>想系统做 LLM 应用</strong> → 先学 <strong>LangChain</strong></li>\n<li><strong>想快速出 Demo / 学概念</strong> → 用 <strong>LangFlow</strong></li>\n<li><strong>Agent 逻辑开始变复杂</strong> → 上 <strong>LangGraph</strong></li>\n</ul>\n<p>现实项目中，<strong>三者是可以组合使用的</strong>：</p>\n<blockquote>\n<p>LangFlow 画流程 → LangChain 落代码 → LangGraph 控复杂控制</p>\n</blockquote>\n<hr />\n<h2 id=\"06--写在最后\">06 | 写在最后</h2>\n<p>LangChain 生态的演进，本质上反映了一件事：</p>\n<blockquote>\n<p>LLM 应用，正在从“Prompt 工程”，走向真正的软件工程。</p>\n</blockquote>\n<p>理解这三者的边界，比死记 API 更重要。<br />\n如果你正在做 <strong>RAG、NL2SQL、AI Agent</strong>，这套认知几乎是绕不开的基础。</p>\n<p>希望这篇文章，能帮你少走一些弯路。</p>\n\n</div>\n<div id=\"MySignature\">\n    <a href=\"https://www.cnblogs.com/jyzhao/\" target=\"_blank\">AlfredZhao</a>©版权所有「从Oracle起航，领略精彩的IT技术。」<br />\n转载请注明原文链接：<a href=\"https://www.cnblogs.com/jyzhao/p/19479470/langchainlangflowlanggraph-yi-wen-jiang-qing-san-d\" target=\"_blank\">https://www.cnblogs.com/jyzhao/p/19479470/langchainlangflowlanggraph-yi-wen-jiang-qing-san-d</a>\n<hr />\n<div style=\"text-align: center; margin-top: 30px;\">\n  <p style=\"font-size: 14px; color: #555;\">\n    👋 感谢阅读，欢迎关注我的公众号 <b>「赵靖宇」</b>\n  </p>\n  <img src=\"https://images.cnblogs.com/cnblogs_com/jyzhao/824234/o_250208075013_qrcode-zjy.jpg\" style=\"border: 1px solid #ddd; border-radius: 8px;\" width=\"160\" />\n</div>\n</div>\n<div class=\"clear\"></div>\n\n        <div class=\"clear\"></div>\n        \n</div>\n    <ul class=\"postmetadata\">\n        \n    </ul>"
    },
    {
      "title": "浅聊算法竞赛中维护中位数的小技巧",
      "link": "https://www.cnblogs.com/GroundhogKing/p/19479345",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/GroundhogKing/p/19479345\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 23:13\">\n    <span>浅聊算法竞赛中维护中位数的小技巧</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>首先来看暑假杭电多校的一道题目：</p>\n<hr />\n<p>对于一个长度为 <span class=\"math inline\">\\(L\\)</span>(<span class=\"math inline\">\\(L\\)</span>为奇数) 的数组 <span class=\"math inline\">\\(a\\)</span>，定义它的中位数 <span class=\"math inline\">\\(median(a)\\)</span> 为 <span class=\"math inline\">\\(a\\)</span> 中第 <span class=\"math inline\">\\(\\frac{L+1}{2}\\)</span> 大的数。现在给你一个长度为 <span class=\"math inline\">\\(n\\)</span> 的排列，对于每对满足 <span class=\"math inline\">\\(1\\leq i \\leq j \\leq n\\)</span> 且 <span class=\"math inline\">\\(j-i \\equiv 0 (mod 2)\\)</span> 的 <span class=\"math inline\">\\((i,j)\\)</span>，你需要计算 <span class=\"math inline\">\\(i*j*median(p[i,j])\\)</span>。输出所有值的和。</p>\n<p>多测数 <span class=\"math inline\">\\(T \\leq 20\\)</span>，排列长度 <span class=\"math inline\">\\(n \\leq 2000\\)</span>。</p>\n<hr />\n<p>对于这道题，首先想到的是枚举所有 <span class=\"math inline\">\\([i,j]\\)</span>，通过数据结构(对顶堆等)维护中位数。由于这些方法都带log，并且本题多测数据不保证 <span class=\"math inline\">\\(n\\)</span> 的总和。因此复杂度 <span class=\"math inline\">\\(O(n^2lognT)\\)</span>，无法通过本题。</p>\n<p>换个思路，枚举区间不行，就计算每个位置的贡献。想想一个位置能成为一个区间的中位数，需要满足什么条件？该区间中大于它和小于它的数的数量相等。</p>\n<p>一个很经典的处理就是，将小于 <span class=\"math inline\">\\(x\\)</span> 的数赋-1，将大于 <span class=\"math inline\">\\(x\\)</span> 的数赋1，我们对这个数组做前缀和，记作 <span class=\"math inline\">\\(pre\\)</span>。于是问题就转换为，在 <span class=\"math inline\">\\(x\\)</span> 的左边找到 <span class=\"math inline\">\\(pre_i\\)</span>，在 <span class=\"math inline\">\\(x\\)</span> 的右边找到 <span class=\"math inline\">\\(pre_j\\)</span>，使得 <span class=\"math inline\">\\(pre_i = pre_j\\)</span>。那么 <span class=\"math inline\">\\(pre_j - pre_i = 0\\)</span>，这就意味着，区间 <span class=\"math inline\">\\([l+1,r]\\)</span> 中大于 <span class=\"math inline\">\\(x\\)</span> 和小于 <span class=\"math inline\">\\(x\\)</span> 的数的数量相等。</p>\n<p>对于每个数处理一次这样的前缀和数组是 <span class=\"math inline\">\\(O(n)\\)</span> 的，因此可以在 <span class=\"math inline\">\\(O(n^2T)\\)</span> 的时间下通过本题。</p>\n<p><strong>Code:</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nusing ll = long long;\n\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; a(n+10);\n    for (int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; a[i];\n\n    ll ans = 0;\n    for (int i = 1 ; i &lt;= n ; i++) //枚举中位数\n    {\n        vector&lt;int&gt; pre(n+10);\n        vector&lt;int&gt; t(2*n+10); //桶,因为会出现负数，要带n的偏移\n        t[n]++;\n        for (int j = 1 ; j &lt;= n ; j++)\n        {\n            pre[j] = pre[j-1];\n            if (a[j] &gt; a[i]) pre[j]++;\n            else if (a[j] &lt; a[i]) pre[j]--;\n\n            if (j &lt; i) t[pre[j]+n] += j + 1;\n            else ans += (ll)a[i] * t[pre[j]+n] * j;\n        }\n    }\n\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int T;\n    cin &gt;&gt; T;\n    while (T--) solve();\n\n    return 0;\n}\n</code></pre>\n<p>基于本题，可以归纳一个维护中位数的小技巧：通过给大于 <span class=\"math inline\">\\(x\\)</span> 和 小于 <span class=\"math inline\">\\(x\\)</span> 的数分别赋值，并求前缀和，就可以把求中位数问题，转化成维护前缀和之差为0。</p>\n<p>以下再做个拓展：序列 <span class=\"math inline\">\\(a\\)</span> 的中位数 <span class=\"math inline\">\\(median(a) \\ge v\\)</span>，当且仅当 <span class=\"math inline\">\\(a\\)</span> 中 <span class=\"math inline\">\\(cnt_{a_i \\geq v} \\geq cnt_{a_i &lt; v}\\)</span>（式中是否取等号取决于题目怎么定义中位数）。也就是说，<span class=\"math inline\">\\(median(a) \\geq v\\)</span> 的充要条件是 <span class=\"math inline\">\\(a\\)</span> 中 <span class=\"math inline\">\\(\\geq v\\)</span> 的数的数量多于或等于 <span class=\"math inline\">\\(&lt; v\\)</span> 的数的数量。这个式子比较好理解，这里不做证明。</p>\n<p>这个式子给我们提供了一种二分的思路。</p>\n<p>看下面这道题<a href=\"https://codeforces.com/contest/2128/problem/E1\" rel=\"noopener nofollow\" target=\"_blank\">Submedians (Easy Version)</a>：</p>\n<hr />\n<p>对于长度为 <span class=\"math inline\">\\(m\\)</span> 的数组 <span class=\"math inline\">\\(b\\)</span>，整数 <span class=\"math inline\">\\(v\\)</span> 是 <span class=\"math inline\">\\(b\\)</span> 的中位数，当且仅当：</p>\n<ul>\n<li><span class=\"math inline\">\\(v\\)</span> 至少大于等于数组中 <span class=\"math inline\">\\(\\lceil \\frac{m}{2} \\rceil\\)</span> 个元素，并且</li>\n<li><span class=\"math inline\">\\(v\\)</span> 至少小于等于数组中 <span class=\"math inline\">\\(\\lceil \\frac{m}{2} \\rceil\\)</span> 个元素。</li>\n</ul>\n<p>现在给定一个整数 <span class=\"math inline\">\\(k\\)</span> 和一个由 <span class=\"math inline\">\\(1\\)</span> 到 <span class=\"math inline\">\\(n\\)</span> 之间的整数构成的数组 <span class=\"math inline\">\\(a_1, \\ldots, a_n\\)</span>。</p>\n<p>如果存在至少一对下标 <span class=\"math inline\">\\((l, r)\\)</span> 满足：</p>\n<ul>\n<li><span class=\"math inline\">\\(1 \\leq l \\leq r \\leq n\\)</span>，</li>\n<li><span class=\"math inline\">\\(r - l + 1 \\geq k\\)</span>，</li>\n<li><span class=\"math inline\">\\(v\\)</span> 是子数组 <span class=\"math inline\">\\([a_l, \\ldots, a_r]\\)</span> 的中位数，</li>\n</ul>\n<p>则称 <span class=\"math inline\">\\(1\\)</span> 到 <span class=\"math inline\">\\(n\\)</span> 之间的整数 <span class=\"math inline\">\\(v\\)</span> 是一个子中位数。</p>\n<p>可以证明，至少存在一个子中位数。请你找出最大的子中位数 <span class=\"math inline\">\\(v_{\\max}\\)</span>，以及任意一组对应的下标对 <span class=\"math inline\">\\((l, r)\\)</span>。</p>\n<hr />\n<p>考虑二分：当 <span class=\"math inline\">\\(v\\)</span> 越大，<span class=\"math inline\">\\(cnt_{a_i\\geq v}\\)</span> 越少，反之 <span class=\"math inline\">\\(cnt_{a_i &lt; v}\\)</span> 越大，因此越大的数越不可能作为中位数。</p>\n<p>同样将 <span class=\"math inline\">\\(\\geq v\\)</span> 的数赋1，<span class=\"math inline\">\\(&lt; v\\)</span> 的数赋-1，做前缀和维护即可。</p>\n<p><strong>Code:</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvoid solve()\n{\n    int n,k;\n    cin &gt;&gt; n &gt;&gt; k;\n    vector&lt;int&gt; a(n+10);\n    for (int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; a[i];\n\n    int ansl, ansr;\n    auto check = [&amp;](int mid)\n    {\n        vector&lt;int&gt; sum(n+10);\n        for (int i = 1 ; i &lt;= n ; i++)\n        {\n            sum[i] = sum[i-1];\n            if (a[i] &gt;= mid) sum[i]++;\n            else sum[i]--;\n        }\n\n        int minn = 2e9;\n        int l;\n        for (int i = k ; i &lt;= n ; i++)\n        {\n            if (sum[i-k] &lt; minn)\n            {\n                minn = sum[i-k];\n                l = i - k + 1;\n            }\n            if (sum[i]-minn &gt;= 0)\n            {\n                ansl = l;\n                ansr = i;\n                return true;\n            }\n        }\n\n        return false;\n    };\n\n    int l = 0;\n    int r = n + 1;\n    while (l+1 != r)\n    {\n        int mid = (l+r) &gt;&gt; 1;\n        if (check(mid)) l = mid;\n        else r = mid;\n    }\n\n    check(l);\n    cout &lt;&lt; l &lt;&lt; \" \" &lt;&lt; ansl &lt;&lt; \" \" &lt;&lt; ansr &lt;&lt; endl;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int T;\n    cin &gt;&gt; T;\n    while (T--) solve();\n\n    return 0;\n}\n</code></pre>\n<p>一道与上题几乎一样的题目<a href=\"https://codeforces.com/contest/1486/problem/D\" rel=\"noopener nofollow\" target=\"_blank\">Max Median</a>：</p>\n<p>题目很短，这里不做题意概述。需要注意的是，由于本题定义中位数为第 <span class=\"math inline\">\\(\\lfloor \\frac{L+1}{2} \\rfloor\\)</span> 大的数，因此本题 <span class=\"math inline\">\\(median(a) \\geq v\\)</span> 的条件为：<span class=\"math inline\">\\(cnt_{a_i \\geq v} &gt; cnt_{a_i &lt; v}\\)</span>。</p>\n<p><strong>Code:</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvoid solve()\n{\n    int n,k;\n    cin &gt;&gt; n &gt;&gt; k;\n    vector&lt;int&gt; a(n+10);\n    for (int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; a[i];\n\n    int ansl, ansr;\n    auto check = [&amp;](int mid)\n    {\n        vector&lt;int&gt; sum(n+10);\n        for (int i = 1 ; i &lt;= n ; i++)\n        {\n            sum[i] = sum[i-1];\n            if (a[i] &gt;= mid) sum[i]++;\n            else sum[i]--;\n        }\n\n        int minn = 2e9;\n        int l;\n        for (int i = k ; i &lt;= n ; i++)\n        {\n            if (sum[i-k] &lt; minn)\n            {\n                minn = sum[i-k];\n                l = i - k + 1;\n            }\n            if (sum[i]-minn &gt; 0)\n            {\n                ansl = l;\n                ansr = i;\n                return true;\n            }\n        }\n\n        return false;\n    };\n\n    int l = 0;\n    int r = n + 1;\n    while (l+1 != r)\n    {\n        int mid = (l+r) &gt;&gt; 1;\n        if (check(mid)) l = mid;\n        else r = mid;\n    }\n\n    check(l);\n    cout &lt;&lt; l &lt;&lt; endl;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int T = 1;\n    while (T--) solve();\n\n    return 0;\n}\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 23:13</span>&nbsp;\n<a href=\"https://www.cnblogs.com/GroundhogKing\">GroundhogKing</a>&nbsp;\n阅读(<span id=\"post_view_count\">51</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "当条形图遇上极坐标：径向与圆形条形图的视觉革命",
      "link": "https://www.cnblogs.com/wang_yb/p/19479454",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wang_yb/p/19479454\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 23:10\">\n    <span>当条形图遇上极坐标：径向与圆形条形图的视觉革命</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>想象一下，你正站在一个圆形广场的中心，周围均匀排列着12根高度不同的灯柱，这就是<strong>径向条形图</strong>带给我们的视觉体验。</p>\n<p>在数据可视化领域，我们常常满足于传统的直角坐标系条形图，但当数据具有周期性或比较性时，<strong>径向条形图</strong>和<strong>圆形条形图</strong>为我们打开了新的可能性。</p>\n<h1 id=\"1-设计原理\">1. 设计原理</h1>\n<p>这两种图表把传统的<strong>笛卡尔坐标系</strong>换成<strong>极坐标系</strong>：角度表示类别，半径或角度长度表示数值。</p>\n<h2 id=\"11-径向条形图\">1.1. 径向条形图</h2>\n<p><strong>径向条形图</strong>本质上是将传统条形图的直角坐标系转换为极坐标系。</p>\n<p>在极坐标系中，每个数据点不再由<code>(x, y)</code>定位，而是由<strong>(角度, 半径)</strong>确定，条形的高度（或长度）由半径值表示，而条形的排列则沿着圆周方向。</p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260113230907077-321355021.png\" /></p>\n<p><strong>设计灵感</strong>：如同钟表的指针或雷达的扫描线，径向条形图借鉴了自然界和人工制品中常见的圆形布局，利用了人类对角度和对称性的天然感知能力。</p>\n<h2 id=\"12-圆形条形图\">1.2. 圆形条形图</h2>\n<p><strong>圆形条形图</strong>是径向条形图的一种特殊形式，它固定了起点和终点，使所有条形都在同一圆周上开始，只在半径方向上延伸。</p>\n<p>这种设计解决了完全径向布局可能导致的<strong>数据比较困难</strong>问题，因为所有条形的基准线是一致的。</p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260113230907250-2040360098.png\" /></p>\n<p><strong>设计比喻</strong>：想象一组跳高运动员，他们都从同一高度起跳，只是跳跃的高度不同——圆形条形图就是这样公平的\"竞技场\"。</p>\n<h1 id=\"2-应用示例\">2. 应用示例</h1>\n<p>下面通过示例来演示这两种图在实际场景中的应用。</p>\n<h2 id=\"21-径向条形图\">2.1. 径向条形图</h2>\n<pre><code class=\"language-python\"># --- 1. 构造测试数据 ---\n# 假设我们想比较一年中每个月的平均降水量\n月份 = [\n    \"一月\",\n    \"二月\",\n    \"三月\",\n    \"四月\",\n    \"五月\",\n    \"六月\",\n    \"七月\",\n    \"八月\",\n    \"九月\",\n    \"十月\",\n    \"十一月\",\n    \"十二月\",\n]\n# 生成模拟的降水量数据 (单位: mm)\nnp.random.seed(42)  # 为了结果可复现\n降水量 = np.random.uniform(30, 150, size=len(月份))  # 随机生成30-150mm的数据\n\n# --- 2. 创建图形 ---\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 7), facecolor=\"white\")\n\n# --- 2.1 绘制传统条形图 ---\n# ... 省略 ...\n\n# --- 2.2 绘制径向条形图 ---\n# 计算每个条形的角度位置\n# ... 省略 ...\n\n# 使用极坐标子图\nax2 = plt.subplot(122, projection=\"polar\")\n# 关键：设置 'bottom' 参数为 inner_radius，这样条形就从 inner_radius 开始画，长度为 radii\nbars = ax2.bar(\n    theta,\n    radii,\n    width=0.4,\n    bottom=inner_radius,\n    color=\"lightcoral\",\n    edgecolor=\"darkred\",\n    alpha=0.7,\n)\n\n# 添加数值标签 (在条形内部，靠近外侧)\nfor angle, radius, month in zip(theta, radii, 月份):\n    ax2.text(\n        angle,\n        inner_radius + radius / 2,\n        f\"{radius:.1f}\",\n        ha=\"center\",\n        va=\"center\",\n        fontsize=8,\n        color=\"black\",\n    )\n\n# 添加月份标记 (在条形外部)\n# ... 省略 ...\n\n# --- 3. 显示图形 ---\nplt.tight_layout()\nplt.show()\n</code></pre>\n<p>这段代码首先生成了模拟的月度降水量数据，然后在同一个图形窗口中创建了两个子图。</p>\n<p>左侧是使用 <code>plt.bar</code> 创建的传统条形图，右侧是使用 <code>plt.subplot(..., projection='polar')</code> 和 <code>ax.bar</code> 创建的径向条形图。</p>\n<p><strong>径向条形图</strong>利用了极坐标系，将类别（月份）分布在圆周上，将数值（降水量）映射到径向长度上。</p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260113230907232-60855079.png\" /></p>\n<p><strong>径向条形图</strong>是一种在极坐标系上绘制的图表，可以提供比传统条形图更具视觉吸引力的替代方案。它通过弧长来表示数值，并且可以有效地利用空间，尤其是在处理类别较多或需要强调周期性模式（例如按月份或季度分组的数据）时。</p>\n<h2 id=\"22-圆形条形图\">2.2. 圆形条形图</h2>\n<pre><code class=\"language-python\">from matplotlib import cm\nfrom math import log10\n\nlabels = list(\"ABCDEFG\")\ndata = [21, 57, 88, 14, 76, 91, 26]\n# ... 省略 ...\n\n#create colors along a chosen colormap\ncolors = [cm.terrain(i / n) for i in range(n)]\n\n#create figure, axis\nfig, ax = plt.subplots()\n\n#create rings of donut chart\nfor i in range(n):\n    current_outer_radius = r - i * w\n    innerring, _ = ax.pie([m - data[i], data[i]], \n                          radius = current_outer_radius, \n                          startangle = 90, \n                          colors = [\"white\", colors[i]])\n\n    # 添加标签\n    # ... 省略 ...\n\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260113230907034-1742470964.png\" /></p>\n<p><strong>圆形条形图</strong>从同一基准线开始，避免了<strong>径向条形图</strong>中不同角度起始点不同的问题，更加便于比较。</p>\n<h1 id=\"3-总结\">3. 总结</h1>\n<p><strong>径向条形图</strong>和<strong>圆形条形图</strong>代表了数据可视化从纯功能向功能美学平衡的演进。</p>\n<p>它们不是要完全取代传统条形图，而是为我们提供了更多视觉叙事的工具。</p>\n<p>就像一位熟练的厨师拥有多种刀具一样，优秀的数据分析师也应该掌握多种可视化技术，根据数据特性和沟通目标选择最合适的\"刀具\"。</p>\n<p>当你的数据讲述着周期性的故事，或需要在有限空间内进行多维度比较时，不妨尝试这些圆形可视化方法。它们不仅能更有效地传达信息，还能为你的报告或仪表板增添独特的视觉魅力。</p>\n<p>最好的可视化不是最复杂的，而是最能清晰传达数据故事的。</p>\n<p><strong>径向</strong>和<strong>圆形条形图</strong>正是这样一种工具：在传统与现代之间，在功能与美学之间，找到了优雅的平衡点。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 23:10</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wang_yb\">wang_yb</a>&nbsp;\n阅读(<span id=\"post_view_count\">47</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Spring 的西西弗斯之石：理解 BeanFactory、FactoryBean 与 ObjectFactory",
      "link": "https://www.cnblogs.com/xzqcsj/p/19479429",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xzqcsj/p/19479429\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 22:46\">\n    <span>Spring 的西西弗斯之石：理解 BeanFactory、FactoryBean 与 ObjectFactory</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"Spring 的西西弗斯之石：理解 BeanFactory、FactoryBean 与 ObjectFactory\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3703499/202601/3703499-20260113224556329-1020363253.png\" />\n        今天，代码又报错了。或者也许是昨天，我不清楚。\n不管怎样，Spring 容器抛出了一个 BeanCreationException。为了解决它，我被迫潜入框架的深处，去注视那些平时被 @Autowired 掩盖的齿轮。\n在 Spring 的世界里，存在着一种必然的复杂性。这种复杂性并非设计者的恶趣味，而是为了在一个静态的语言中构建动态世界所付出的代价。\n在这个庞大的机器中，有三个名字极其相似的概念经常被混淆：BeanFactory、FactoryBean 和 ObjectFactory。这并不是命名的贫瘠，而是它们在本质上确实存在着微妙的纠缠。\n今天，我们剥离掉那些花哨的比喻和无用的糖衣，用一种冷静的、近乎解剖学的视角，去审视这三个概念的本质。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>今天，代码又报错了。或者也许是昨天，我不清楚。<br />\n不管怎样，Spring 容器抛出了一个 <code>BeanCreationException</code>。为了解决它，我被迫潜入框架的深处，去注视那些平时被 <code>@Autowired</code> 掩盖的齿轮。</p>\n<p>在 Spring 的世界里，存在着一种必然的复杂性。这种复杂性并非设计者的恶趣味，而是为了在一个静态的语言中构建动态世界所付出的代价。</p>\n<p>在这个庞大的机器中，有三个名字极其相似的概念经常被混淆：<code>BeanFactory</code>、<code>FactoryBean</code> 和 <code>ObjectFactory</code>。这并不是命名的贫瘠，而是它们在本质上确实存在着微妙的纠缠。</p>\n<p>今天，我们剥离掉那些花哨的比喻和无用的糖衣，用一种冷静的、近乎解剖学的视角，去审视这三个概念的本质。</p>\n<hr />\n<h2 id=\"一beanfactory存在的容器\">一、BeanFactory：存在的容器</h2>\n<p><strong>让我们首先纠正一个观念：BeanFactory 名为工厂，但其本质是容器（Container）。</strong></p>\n<p>当我们谈论 Spring 容器时，我们实际上是在谈论 <code>BeanFactory</code>。它是 Spring IoC 容器的根接口，是整个世界的物理法则。</p>\n<h3 id=\"11-唯一的职责\">1.1 唯一的职责</h3>\n<p>它的定义极其克制。它不关心业务逻辑，只关心一件事：<strong>管理对象的生命周期</strong>。</p>\n<pre><code class=\"language-java\">public interface BeanFactory {\n    Object getBean(String name) throws BeansException;\n    &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType);\n    boolean containsBean(String name);\n    // ...\n}\n</code></pre>\n<p>当你启动一个 Spring Boot 应用时，<code>ApplicationContext</code> 就像一个充满活力的城市，而 <code>BeanFactory</code> 则是支撑这座城市的地下管网。所有的 BeanDefinition（关于 Bean 应该如何创建的蓝图）都注册在这里。</p>\n<h3 id=\"12-残酷的现实\">1.2 残酷的现实</h3>\n<p>在大多数情况下，你不需要直接与 <code>BeanFactory</code> 对话。因为 <code>ApplicationContext</code> 已经为你封装好了一切。<br />\n但当你试图理解为什么你的 Bean 没有被正确初始化，或者为什么你的循环依赖失效时，你就必须意识到：<strong>你所有的 Bean，都只是 <code>BeanFactory</code> 中的 entries（条目）。</strong></p>\n<p>它是一个巨大的 <code>Map&lt;String, BeanDefinition&gt;</code> 和 <code>Map&lt;String, Object&gt;</code> 的管理者。它冷酷无情，只按照定义的规则（Scope, Lazy, Dependence）来实例化对象。</p>\n<hr />\n<h2 id=\"二factorybean必要的欺骗\">二、FactoryBean：必要的欺骗</h2>\n<p>如果说 <code>BeanFactory</code> 是宏观规则的制定者，那么 <code>FactoryBean</code> 就是微观规则的<strong>潜行者</strong>。</p>\n<h3 id=\"21-静态语言的困境\">2.1 静态语言的困境</h3>\n<p>想象这样一个场景：<strong>你需要注入一个接口的实现，但这个实现类并不存在于代码中，它是通过动态代理在运行时生成的。</strong><br />\n这在 RPC 框架（如 Dubbo、Feign）和 ORM 框架（如 MyBatis）中极其常见。</p>\n<p>你无法通过简单的 <code>&lt;bean class=\"...\"&gt;</code> 或 <code>@Component</code> 来描述一个“不存在的类”。<br />\n这时候，你需要一个中间人。这个中间人表面上是一个普通的 Bean，但实际上，它是一个工厂。</p>\n<h3 id=\"22-伪装的艺术以-mybatis-为例\">2.2 伪装的艺术：以 MyBatis 为例</h3>\n<p>为什么你只需要写一个 <code>UserMapper</code> 接口，就能直接 <code>@Autowired</code> 使用？<br />\n因为 Spring 容器里注册的那个 \"userMapper\" Bean，根本不是你的接口实现，而是一个 <code>MapperFactoryBean</code>。</p>\n<pre><code class=\"language-java\">// 简化的逻辑示意\npublic class MapperFactoryBean&lt;T&gt; implements FactoryBean&lt;T&gt; {\n    \n    private Class&lt;T&gt; mapperInterface;\n\n    @Override\n    public T getObject() throws Exception {\n        // 往里跟进，最终这里发生了魔法：通过 JDK 动态代理生成接口的实\n        return (T) Proxy.newProxyInstance(\n            mapperInterface.getClassLoader(), \n            new Class[] { mapperInterface }, \n            new MapperProxy&lt;&gt;()\n        );\n    }\n\n    @Override\n    public Class&lt;?&gt; getObjectType() {\n        return mapperInterface;\n    }\n\n    @Override\n    public boolean isSingleton() {\n        return true;\n    }\n}\n</code></pre>\n<h3 id=\"23-这里的真相\">2.3 这里的真相</h3>\n<p>当容器调用 <code>getBean(\"userMapper\")</code> 时，它发现这是一个 <code>FactoryBean</code>。于是，它不会返回 <code>FactoryBean</code> 实例本身，而是默默地调用 <code>getObject()</code>，并返回那个代理对象。</p>\n<p>这就是欺骗。<strong>你以为你拿到了一个 Bean，其实你拿到的是 Bean 生产的产品。</strong></p>\n<p>如果你渴望看到真相，看到那个操纵傀儡的幕后黑手，你需要在 Bean 名称前加上 <code>&amp;</code>：</p>\n<pre><code class=\"language-java\">// 获取的是 MapperProxy 代理对象\nObject product = context.getBean(\"userMapper\"); \n\n// 获取的是 FactoryBean 工厂本身\nObject factory = context.getBean(\"&amp;userMapper\");\n</code></pre>\n<hr />\n<h2 id=\"三objectfactory时间的延迟\">三、ObjectFactory：时间的延迟</h2>\n<p><code>BeanFactory</code> 负责掌控空间（容器），<code>FactoryBean</code> 负责掌控构造（逻辑），而 <code>ObjectFactory</code> 则是为了掌控<strong>时间</strong>。</p>\n<h3 id=\"31-循环的死结\">3.1 循环的死结</h3>\n<p>在 Spring 的世界里，有一个经典的荒谬：A 需要 B，B 需要 A。<br />\n如果是构造器注入，只需坦然承认失败。但如果是 Setter 注入，Spring 试图挽救这种死结。</p>\n<p>在 A 创建的过程中，需要注入 B。B 创建时，又需要注入 A。<br />\n此时 A 还在创建中，尚不是一个完整的 Bean。怎么办？<br />\nSpring 引入了三级缓存的概念。而第三级缓存，存放的就是一个 <code>ObjectFactory</code>。</p>\n<h3 id=\"32-回调的本质\">3.2 回调的本质</h3>\n<p><code>ObjectFactory</code> 在源码中简单得令人发指：</p>\n<pre><code class=\"language-java\">@FunctionalInterface\npublic interface ObjectFactory&lt;T&gt; {\n    T getObject() throws BeansException;\n}\n</code></pre>\n<p>它只是一个<strong>函数式接口</strong>，一个回调。<br />\n它存在的意义在于：<strong>我现在不想要这个对象，但我想要一个“在未来某个时刻能获取这个对象”的能力。</strong></p>\n<p>在循环依赖中，Spring 提前暴露了一个 <code>ObjectFactory</code>：</p>\n<pre><code class=\"language-java\">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));\n</code></pre>\n<p>当 B 需要 A 时，它通过这个 <code>ObjectFactory</code> 拿到了 A 的早期引用（Early Reference）。尽管 A 还没完全初始化好，但 B 已经可以持有它的引用了。死结解开了。</p>\n<h3 id=\"33-作用域的错位\">3.3 作用域的错位</h3>\n<p>另一个场景是：一个单例（Singleton）的 Service 需要使用一个 原型（Prototype）的 Bean。<br />\n如果你直接 <code>@Autowired</code>，原型的 Bean 只有在 Service 创建时被注入一次，之后也就是永远同一个对象了。这违背了原型的初衷。</p>\n<p>如何解决？使用 <code>ObjectFactory</code> 延迟获取。</p>\n<pre><code class=\"language-java\">@Service\npublic class ReportService {\n    \n    @Autowired\n    private ObjectFactory&lt;ReportBuilder&gt; builderFactory;\n\n    public void generate() {\n        // 每次调用 getObject()，容器都会创建一个全新的 ReportBuilder\n        ReportBuilder builder = builderFactory.getObject();\n        builder.build();\n    }\n}\n</code></pre>\n<p>在这里，<strong><code>ObjectFactory</code> 就像是一个通往容器的句柄，让你随时可以伸手进去拿一个新的对象，而不是守着陈旧的缓存。</strong></p>\n<hr />\n<h2 id=\"四审判与裁决\">四、审判与裁决</h2>\n<p>让我们在最后，用最客观的表格来审判这三者的区别。这不是为了背诵，而是为了理清混乱。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">维度</th>\n<th style=\"text-align: left;\">BeanFactory</th>\n<th style=\"text-align: left;\">FactoryBean</th>\n<th style=\"text-align: left;\">ObjectFactory</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>存在形式</strong></td>\n<td style=\"text-align: left;\"><strong>容器</strong> (Container)</td>\n<td style=\"text-align: left;\"><strong>Bean</strong> (Component)</td>\n<td style=\"text-align: left;\"><strong>接口</strong> (Interface/Callback)</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>底层逻辑</strong></td>\n<td style=\"text-align: left;\"><code>ApplicationContext</code> 的父级接口 / <strong>宏观工厂</strong></td>\n<td style=\"text-align: left;\">实现了 <code>FactoryBean</code> 接口的类 / <strong>微观工厂</strong></td>\n<td style=\"text-align: left;\">函数式接口 / <strong>延迟回调</strong></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>核心职责</strong></td>\n<td style=\"text-align: left;\">管理所有 Bean 的生命周期</td>\n<td style=\"text-align: left;\">此 Bean 负责<strong>生产</strong>另一个复杂的 Bean</td>\n<td style=\"text-align: left;\">封装对象的创建过程，提供<strong>延迟</strong>获取能力</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>获取方式</strong></td>\n<td style=\"text-align: left;\"><code>ApplicationContext</code> 是它的超集</td>\n<td style=\"text-align: left;\"><code>getBean(\"name\")</code> 拿产品<br /><code>getBean(\"&amp;name\")</code> 拿工厂</td>\n<td style=\"text-align: left;\">注入 <code>ObjectFactory&lt;T&gt;</code> 后调用 <code>getObject()</code></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>真实场景</strong></td>\n<td style=\"text-align: left;\">Spring 框架的基石</td>\n<td style=\"text-align: left;\">Mybatis <code>MapperFactoryBean</code>, <code>ProxyFactoryBean</code></td>\n<td style=\"text-align: left;\">解决循环依赖(三级缓存), Scope(原型模式)适配</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"五结语\">五、结语</h2>\n<p>在代码的荒原上，我们通过构建抽象来对抗混乱。</p>\n<ul>\n<li><strong>BeanFactory</strong> 是我们脚下的大地。<strong>它被称为工厂，但它实际是孕育万物的土壤（容器）。</strong></li>\n<li><strong>FactoryBean</strong> 是我们手中的精密机床。<strong>它是一个特殊的 Bean，存在的目的却是为了制造另一个 Bean。</strong></li>\n<li><strong>ObjectFactory</strong> 是我们预留的时间胶囊。<strong>它只是一个单纯的接口，为了应对循环与未来的不确定性。</strong></li>\n</ul>\n<p>理解它们，并不是为了通过面试，而是为了在下一次抛出异常时，你能冷静地凝视堆栈信息，知道机器的哪个齿轮发生了错位。</p>\n<p>既然我们选择了与机器共舞，就必须理解机器的逻辑。这或许就是作为开发者的西西弗斯式命运——<strong>我们需要一次又一次地将巨石推向山顶，以此证明我们对这个庞大系统的掌控</strong>。</p>\n<blockquote>\n<p><strong>本文通过 AI 润色（加缪风格），试图以一种冷静、客观甚至存在主义的视角，去解构这些在日常 Coding 中被我们习以为常的概念。希望这种独特的叙事风格，能让你对这些枯燥的技术概念有更深刻的“存在感”。</strong></p>\n</blockquote>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 22:46</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xzqcsj\">一旅人</a>&nbsp;\n阅读(<span id=\"post_view_count\">77</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "吴恩达深度学习课程五：自然语言处理  第一周：循环神经网络 （七）双向 RNN 与深层 RNN",
      "link": "https://www.cnblogs.com/Goblinscholar/p/19479253",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Goblinscholar/p/19479253\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 22:37\">\n    <span>吴恩达深度学习课程五：自然语言处理  第一周：循环神经网络 （七）双向 RNN 与深层 RNN</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>此分类用于记录吴恩达深度学习课程的学习笔记。<br />\n课程相关信息链接如下：</p>\n<ol>\n<li>原课程视频链接：<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?buvid=XU762317353676D786954061C192FE625463B&amp;from_spmid=playlist.playlist-detail.0.0&amp;is_story_h5=false&amp;mid=zqernykrmpf7XfIorMR%2FnA%3D%3D&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=ce0bc526-db69-428a-962e-c65ed8c267bc&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1713085655&amp;unique_k=DfBgvFW&amp;up_id=8654113&amp;vd_source=e035e9878d32f414b4354b839a4c31a4\" rel=\"noopener nofollow\" target=\"_blank\">[双语字幕]吴恩达深度学习deeplearning.ai</a></li>\n<li>github课程资料，含课件与笔记:<a href=\"https://github.com/robbertliu/deeplearning.ai-andrewNG\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习教学资料</a></li>\n<li>课程配套练习（中英）与答案：<a href=\"https://blog.csdn.net/u013733326/article/details/79827273\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习课后习题与答案</a></li>\n</ol>\n<p>本篇为第五课的第一周内容，<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=161\" rel=\"noopener nofollow\" target=\"_blank\">1.11</a>到<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=162\" rel=\"noopener nofollow\" target=\"_blank\">1.12</a>的内容，同时也是本周理论部分的最后一篇。</p>\n<hr />\n<p>本周为第五课的第一周内容，与 CV 相对应的，这一课所有内容的中心只有一个：<strong>自然语言处理（Natural Language Processing，NLP）</strong>。<br />\n应用在深度学习里，它是专门用来进行<strong>文本与序列信息建模</strong>的模型和技术，本质上是在全连接网络与统计语言模型基础上的一次“结构化特化”，也是人工智能中<strong>最贴近人类思维表达方式</strong>的重要研究方向之一。<br />\n<strong>这一整节课同样涉及大量需要反复消化的内容，横跨机器学习、概率统计、线性代数以及语言学直觉。</strong><br />\n语言不像图像那样“直观可见”，更多是抽象符号与上下文关系的组合，因此<strong>理解门槛反而更高</strong>。<br />\n因此，我同样会尽量补足必要的背景知识，尽可能用比喻和实例降低理解难度。<br />\n本篇的内容关于<strong>双向 RNN 与深层 RNN</strong>，是对基础 RNN 结构的一些补充。</p>\n<h1 id=\"1-双向-rnnbidirectional-rnn\">1. 双向 RNN（Bidirectional RNN）</h1>\n<p>在前面对 <strong><a href=\"https://www.cnblogs.com/Goblinscholar/p/19449622\" target=\"_blank\">RNN</a>、<a href=\"https://www.cnblogs.com/Goblinscholar/p/19463351\" target=\"_blank\">GRU</a> 与 <a href=\"https://www.cnblogs.com/Goblinscholar/p/19474433\" target=\"_blank\">LSTM</a></strong> 的讨论中，我们始终默认了一个前提：<strong>序列只能沿时间轴单向展开，模型在当前时刻只能利用已经出现的历史信息。</strong></p>\n<p>这种设定在一些简单任务中是合理的，但在大量<strong>序列理解与标注任务</strong>中，却隐藏着一个结构性限制：  <strong>当前时刻的语义或状态，往往同时依赖于过去和未来的上下文信息。</strong><br />\n举个课程里的例子：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260113211513804-150472822.png\" /><br />\n于是，问题出现了：<strong>如果未来信息才是判定当前状态的重要依据，该怎么办？</strong></p>\n<p>正是在这样的背景下，<strong>双向 RNN（Bidirectional Recurrent Neural Networks）</strong> 被提出。<br />\n早在 <strong>1997 年</strong>，<strong><a href=\"https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=650093\" rel=\"noopener nofollow\" target=\"_blank\">Bidirectional Recurrent Neural Networks</a></strong> 这篇论文中就指出：对于序列标注与整体理解任务，仅依赖过去上下文会造成信息利用上的先天不足，因此有必要在模型结构层面<strong>同时建模正向与反向的时间依赖关系</strong>。</p>\n<p>需要强调的是，双向 RNN 并不是一种新的循环单元设计。<br />\n它并不改变 RNN、LSTM 或 GRU 内部的计算形式，而是通过在时间维度上引入<strong>前向与后向两条独立的状态传播链路</strong>，使模型在每一个时间步都能够融合<strong>历史与未来的上下文信息</strong>。</p>\n<p>也正因为这种“结构独立于单元”的特性，双向 RNN 可以自然地与 LSTM、GRU 结合，形成 <strong>Bi-LSTM、Bi-GRU</strong>，成为提升上下文建模能力的标准配置。</p>\n<p>它的实现逻辑并不复杂，这里引用一张比较清晰易懂的传播图：（<a href=\"https://medium.com/@fraidoonomarzai99/bidirectional-rnn-in-depth-1efd32c3cf46\" rel=\"noopener nofollow\" target=\"_blank\">出处</a>）<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260113211514563-1603287401.png\" /><br />\n这样，你就会发现，同一序列被 <strong>正向（蓝色）</strong> 和 <strong>反向（绿色）</strong> 两条 RNN 同时建模，每个时间步 <span class=\"math inline\">\\(t\\)</span> 都能“看到”正向的历史上下文和反向的未来上下文，最终输出 <span class=\"math inline\">\\(\\hat y^{\\langle t\\rangle}\\)</span> 由两个方向的信息共同决定。</p>\n<p></p><div class=\"math display\">\\[h^{(t)}\n=\n\\operatorname{concat}\\!\\left(\n\\overrightarrow{{h}^{(t)}},\n\\overleftarrow{{h}^{(t)}}\n\\right)\n\\quad \\text{or} \\quad\n\\overrightarrow{{h}^{(t)}} + \\overleftarrow{{h}^{(t)}}\n\\]</div><p></p><p>在实践中，双向 RNN 更常采用<strong>拼接方式</strong>保留来自两个时间方向的完整信息，而<strong>逐元素相加</strong>则是一种更紧凑、但表达能力受限的折中选择。</p>\n<p>最后，再打个比方：把序列比作一座<strong>要建的桥</strong>，双向 RNN 就像是两队工人从两侧同时施工并不断交流进度，确保精准，但同时，施工队伍翻倍，整体成本也随之上升。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260113211553645-1826290875.png\" /></p>\n<h1 id=\"2-深层-rnn\">2. 深层 RNN</h1>\n<p>深层 RNN 的概念同样不难理解。<br />\n在最开始引入 <strong><a href=\"https://www.cnblogs.com/Goblinscholar/p/19449622\" target=\"_blank\">循环神经网络</a></strong> 时，我们说明过，默认使用<strong>单层 RNN</strong> 来进行演示：<br />\n在每一个时间步 <span class=\"math inline\">\\(t\\)</span>，输入 <span class=\"math inline\">\\(x^{(t)}\\)</span> 经过一次循环计算，得到对应的隐藏状态 <span class=\"math inline\">\\(a^{(t)}\\)</span>，并沿时间轴不断传递。</p>\n<p>但从模型表达能力的角度来看，这种结构存在限制：<strong>每个时间步内部，只进行了一次非线性变换。</strong><br />\n这意味着，无论序列本身有多复杂，在“同一时刻”对输入信息的处理深度都是有限的。<br />\n到这里，就和之前的全连接、卷积网络相通了：<br />\n<strong>如果我们希望模型在每一个时间步上，也具备类似深度前馈网络、卷积网络那样的层级表达能力，该怎么办？</strong><br />\n答案自然就是：<strong>在时间维度之外，再引入层级维度。</strong></p>\n<p>在深层 RNN 中，循环结构不再只有一层，而是<strong>在同一时间步上堆叠多层 RNN 单元</strong>。<br />\n它的传播图是这样的：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260113211513339-2004923823.png\" /><br />\n关于深度的逻辑和之前都是相同的，深层 RNN 通过在同一时间步上的堆叠，让模型可以进行更复杂的非线性变换，<strong>增强了其表达能力</strong>。但同样也会增加计算成本，<strong>带来梯度问题与过拟合风险</strong>，这些都是我们的老生常谈了。</p>\n<p>于此同时，和双向 RNN 类似，<strong>深层结构同样独立于具体的循环单元设计</strong>。  而且在工程实践中，<strong>深度、方向性和门控机制往往是可以同时叠加的</strong>，例如：</p>\n<ul>\n<li>多层 Bi-LSTM</li>\n<li>多层 Bi-GRU</li>\n</ul>\n<p>我们把各个组件组合或创新，便形成了深度学习 NLP 中纷繁复杂的诸多模型。</p>\n<p>最后，如果继续沿用前面的比喻：<br />\n<strong>双向 RNN</strong> 像是从桥的两端同时施工。<br />\n那么 <strong>深层 RNN</strong> 更像是： 每一个施工点上，不只是铺一层路面，而是<strong>一层层打地基、加结构、再铺表层。</strong> 这样结构更稳、表达更强，但施工流程更复杂，成本和训练难度也随之上升。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260113211517590-653078512.png\" /></p>\n<h1 id=\"3总结\">3.总结</h1>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>原理</th>\n<th>比喻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>双向 RNN（Bidirectional RNN）</td>\n<td>在时间维度上引入<strong>正向和反向两条独立状态链路</strong>，每个时间步同时利用过去和未来上下文信息。适用于序列标注与整体理解任务。可以与 RNN/LSTM/GRU 结合，形成 Bi-RNN、Bi-LSTM、Bi-GRU。</td>\n<td>序列比作桥，两队工人从两端同时施工并交流进度，确保精准，但施工队伍翻倍，成本增加。</td>\n</tr>\n<tr>\n<td>深层 RNN（Deep RNN）</td>\n<td>在同一时间步上<strong>堆叠多层 RNN 单元</strong>，增加每个时间步内部的非线性表达能力，从而增强模型的表示能力。可与门控机制和双向结构叠加，形成多层 Bi-LSTM、Bi-GRU 等。</td>\n<td>每个施工点上不是只铺一层路面，而是<strong>一层层打地基、加结构、再铺表层</strong>，结构更稳、表达更强，但施工流程复杂，成本和训练难度增加。</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 22:37</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Goblinscholar\">哥布林学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">24</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "synchronized关键字相关",
      "link": "https://www.cnblogs.com/xi-yongqi/p/19479394",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xi-yongqi/p/19479394\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 22:24\">\n    <span>synchronized关键字相关</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h5 id=\"synchronized是java中用于解决并发问题的核心关键字它通过确保多个线程对共享资源的互斥访问来避免线程安全问题如竞态条件数据不一致等\">synchronized是Java中用于解决并发问题的核心关键字，它通过确保多个线程对共享资源的互斥访问，来避免线程安全问题（如竞态条件、数据不一致等）。</h5>\n<h4 id=\"synchronized的核心特性\">synchronized的核心特性</h4>\n<ul>\n<li>原子性（Atomicity）：确保一个或多个操作要么全部执行成功，要么全部执行失败。在synchronized代码块中的代码是不可中断的，同一时刻只有一个线程能执行。</li>\n<li>可见性（Visibility）：保证一个线程对共享变量的修改，对于其他后续进入同步代码块的线程是可见的。当线程释放锁时，会将私有内存中的变量值刷新回主内存。</li>\n<li>有序性（Ordering）：虽然编译器和处理器为了优化会进行指令重排，但synchronized可以保证多线程程序在逻辑上的执行顺序，即“同步块内的代码在执行上具有先后顺序”。</li>\n<li>可重入性：可重入性是指一个线程已经获取到某个锁后，再次请求该锁时可以直接获取，无需重新竞争。synchronized是可重入锁，其内部通过计数器记录锁的持有次数（初始为0，获取锁时加1，释放锁时减1，计数器为0时锁才被真正释放）。这一特性避免了线程在递归调用同步方法/代码块时出现死锁。例如，一个同步方法A调用另一个同步方法B（两者锁对象相同），线程获取A的锁后，调用B时可直接获取锁。</li>\n</ul>\n<h4 id=\"synchronized的使用方式\">synchronized的使用方式</h4>\n<h5 id=\"synchronized的使用灵活可修饰不同的代码结构核心是明确锁对象线程竞争的是锁对象只有获取到锁对象的线程才能执行同步代码常见使用方式有3种\">synchronized的使用灵活，可修饰不同的代码结构，核心是明确“锁对象”——线程竞争的是锁对象，只有获取到锁对象的线程才能执行同步代码，常见使用方式有3种。</h5>\n<ol>\n<li>修饰实例方法（对象锁），语法：<code>public synchronized void methodName() { ... }</code></li>\n</ol>\n<ul>\n<li>锁对象：当前类的实例对象（this）。</li>\n<li>特点：不同实例对象的锁相互独立，即多个线程访问同一个实例的同步实例方法时会竞争锁；访问不同实例的同步实例方法时，因锁对象不同，不会竞争。</li>\n<li>示例：同一User实例的add()方法被多线程调用时互斥，不同User实例的add()方法可并行执行。</li>\n</ul>\n<ol start=\"2\">\n<li>修饰静态方法（类锁）语法：<code>public static synchronized void methodName() { ... }</code></li>\n</ol>\n<ul>\n<li>锁对象：当前类的Class对象（每个类在JVM中只有一个Class对象，是全局唯一的）。</li>\n<li>特点：类锁是全局锁，无论创建多少个类的实例，所有线程访问该类的同步静态方法时，都会竞争同一个Class对象锁。</li>\n<li>注意：类锁与对象锁相互独立，即同步静态方法和同步实例方法的锁对象不同，线程访问时不会竞争。</li>\n</ul>\n<ol start=\"3\">\n<li>修饰代码块（自定义锁对象），语法：<code>synchronized (锁对象) { ... 同步代码 ... }</code></li>\n</ol>\n<ul>\n<li>锁对象：可自定义，支持两种类型：① 实例对象（this或其他实例）；② Class对象（类名.class）。</li>\n<li>特点：粒度最细，可精准控制需要同步的代码片段（而非整个方法），减少锁竞争，提高程序性能。</li>\n<li>常见场景：\n<ul>\n<li>锁当前实例：<code>synchronized (this) { ... }</code>，效果与修饰实例方法一致，但仅同步代码块内的逻辑。</li>\n<li>锁Class对象：<code>synchronized (User.class) { ... }</code>，效果与修饰静态方法一致。</li>\n<li>锁自定义对象：<code>private Object lock = new Object(); synchronized (lock) { ... }</code>，通过独立的锁对象，避免与其他同步逻辑竞争锁，灵活性最高。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"synchronized的锁机制\">synchronized的锁机制</h4>\n<ul>\n<li>Java 6及以后对synchronized进行了大幅优化，引入了“偏向锁、轻量级锁、重量级锁”三种锁状态，目的是根据线程竞争的激烈程度动态切换锁状态，平衡性能与线程安全。锁机制的核心是“对象头”——Java对象在内存中的布局包括对象头、实例数据、对齐填充，其中对象头存储了锁的状态信息（Mark Word）、类元数据指针等。</li>\n<li>三种锁状态的优先级：无锁 &lt; 偏向锁 &lt; 轻量级锁 &lt; 重量级锁，随着线程竞争的加剧，锁会从低级别向高级别升级，且升级过程不可逆（一旦升级为重量级锁，无法回退为轻量级锁或偏向锁）。\n<ul>\n<li>无锁（No Lock）：初始状态。</li>\n<li>偏向锁（Biased Lock）：当只有一个线程访问同步块时，直接在对象头记录线程ID，下次该线程进入时无需CAS操作，性能极高。</li>\n<li>轻量级锁（Lightweight Lock）：当出现竞争，但竞争不激烈时，通过CAS自旋来尝试获取锁，避免线程阻塞。</li>\n<li>重量级锁（Heavyweight Lock）：当自旋超过一定次数或竞争非常激烈时，升级为重量级锁。此时未获取到锁的线程会进入阻塞（Blocked）状态，交给操作系统管理。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"锁优化补充\">锁优化补充</h5>\n<ul>\n<li><strong>锁消除</strong>：JVM的即时编译器（JIT）在运行时，会对一些“不可能存在竞争的锁”进行消除。例如，局部变量作为锁对象（每个线程都有独立的局部变量，无共享），JVM会直接删除该synchronized修饰，避免不必要的锁开销。</li>\n<li><strong>锁粗化</strong>：当多个连续的synchronized代码块使用同一个锁对象时，JVM会将这些代码块合并为一个大的同步代码块，减少锁的获取/释放次数（每次获取/释放锁都有开销）。例如，循环内多次调用同步方法，JVM可能将锁粗化到循环外部。</li>\n</ul>\n<hr />\n<h4 id=\"cas-compare-and-swap比较并交换-是并发编程中实现原子操作的核心算法是一种乐观锁的实现策略\">CAS (Compare And Swap，比较并交换) 是并发编程中实现原子操作的核心算法，是一种乐观锁的实现策略。</h4>\n<ol>\n<li>CAS的工作原理，包含三个核心参数：</li>\n</ol>\n<ul>\n<li>内存地址 V (Memory Location)：变量在内存中的实际值。</li>\n<li>期望值 A (Expected Value)：线程认为该变量当前应该是什么值。</li>\n<li>新值 B (New Value)：线程想要更新成的值。</li>\n<li>执行逻辑：当且仅当内存地址 V 的值等于期望值 A 时，处理器才会将 V 的值更新为 B。否则，说明该变量已被其他线程修改，当前线程什么都不做，通常会进入自旋（死循环重试）。</li>\n</ul>\n<ol start=\"2\">\n<li>CAS的优缺点<br />\n<strong>优点：</strong></li>\n</ol>\n<ul>\n<li>非阻塞性：CAS 是一种非阻塞算法（Non-blocking），它不需要像 synchronized 那样挂起和恢复线程。</li>\n<li>性能高：在低、中度竞争的情况下，由于减少了线程上下文切换的开销，效率远高于重量级锁。<br />\n<strong>缺点：</strong></li>\n<li>循环时间长（自旋开销）：如果高并发下竞争激烈，CAS 会频繁失败并不断自旋，这会给 CPU 带来巨大的计算压力。</li>\n<li>只能保证一个共享变量的原子操作：对于多个变量的操作，仍需使用 synchronized 或 ReentrantLock。</li>\n<li>ABA 问题（最经典的缺点）。</li>\n</ul>\n<ol start=\"3\">\n<li>什么是 ABA 问题？</li>\n</ol>\n<ul>\n<li>如果变量初始值为A，在线程1准备修改它的过程中，线程2快速地将其改成了B，然后又改回了A。 现象：线程1观察到值依然是A，认为它没变过，于是CAS成功。 风险：虽然数值没变，但变量的状态（或对象内部的属性）可能已经发生了变化，导致逻辑错误。</li>\n<li>Java提供了AtomicStampedReference类，通过引入版本号（Stamp）来解决： 每次变量更新时，不仅更新值，还增加一个版本号。只有值和版本号都一致，CAS才会成功。</li>\n<li>还可以设置时间戳来解决。</li>\n</ul>\n<ol start=\"4\">\n<li>CAS 在Java中的实现</li>\n</ol>\n<ul>\n<li>在Java中，CAS主要由 sun.misc.Unsafe 类提供支持。该类中的方法（如 compareAndSwapInt）是 native 的，直接调用硬件底层的指令。</li>\n</ul>\n<hr />\n<h4 id=\"reentrantlock可重入锁\">ReentrantLock（可重入锁）</h4>\n<ul>\n<li>ReentrantLock是 Java java.util.concurrent.locks 包下的可重入锁实现，基于 AQS（抽象队列同步器）构建，是 synchronized 的 “增强版”—— 既保留了 synchronized 的可重入特性，又提供了更灵活的同步控制能力。</li>\n</ul>\n<h5 id=\"两者对比\">两者对比:</h5>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>synchronized</th>\n<th>ReentrantLock</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>实现层面</td>\n<td>JVM 层面（关键字），由 C++ 实现</td>\n<td>JDK 层面（API），由 Java 编写（基于 AQS）</td>\n</tr>\n<tr>\n<td>锁的释放</td>\n<td>自动释放（代码执行完或异常后）</td>\n<td>手动释放（必须在 finally 中调用 unlock()）</td>\n</tr>\n<tr>\n<td>灵活性</td>\n<td>低（不可中断，无超时机制）</td>\n<td>高（支持尝试获取、超时获取、可中断获取）</td>\n</tr>\n<tr>\n<td>公平性</td>\n<td>只支持非公平锁</td>\n<td>支持公平锁与非公平锁（默认非公平）</td>\n</tr>\n<tr>\n<td>等待队列</td>\n<td>只能关联 1 个 等待队列（wait/notify）</td>\n<td>可以绑定 多个 Condition（精细化唤醒）</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"reentrantlock的特有高级功能\">ReentrantLock的特有高级功能</h5>\n<ol>\n<li>响应中断 (lockInterruptibly)</li>\n</ol>\n<ul>\n<li>synchronized一旦进入阻塞等待，除非拿到锁，否则无法被中断。而ReentrantLock允许线程在等待锁的过程中响应Thread.interrupt()，从而避免死等。</li>\n</ul>\n<ol start=\"2\">\n<li>超时机制 (tryLock)</li>\n</ol>\n<ul>\n<li>线程可以尝试获取锁，如果锁被占用，立即返回 false 或者等待一段时间后返回，而不是一直阻塞。这在预防死锁时非常有用。</li>\n</ul>\n<ol start=\"3\">\n<li>公平锁 (Fairness)</li>\n</ol>\n<ul>\n<li>公平锁：按照线程请求锁的顺序分配，先到先得。</li>\n<li>非公平锁（默认）：允许“插队”。如果新来的线程正好碰到锁释放，它可以直接抢占，性能通常比公平锁高。</li>\n</ul>\n<ol start=\"4\">\n<li>多个 Condition 对象</li>\n</ol>\n<ul>\n<li>通过lock.newCondition()，你可以创建多个等待集。例如在阻塞队列中，可以定义 notFull 和 notEmpty 两个条件，实现比 notifyAll 更精准的线程唤醒。</li>\n</ul>\n<h5 id=\"基本使用示例\">基本使用示例：</h5>\n<pre><code class=\"language-java\">import java.util.concurrent.locks.ReentrantLock;\n\npublic class ReentrantLockDemo {\n    // 创建非公平锁（默认），若需公平锁：new ReentrantLock(true)\n    private static final ReentrantLock lock = new ReentrantLock();\n\n    public static void doTask() {\n        // 1. 普通获取锁（不可中断）\n        lock.lock();\n        try {\n            // 临界区代码（线程安全）\n            System.out.println(Thread.currentThread().getName() + \" 执行任务\");\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        } finally {\n            // 必须在finally中释放锁，否则锁永远无法释放\n            lock.unlock();\n        }\n    }\n\n    // 超时获取锁示例\n    public static void tryLockWithTimeout() {\n        try {\n            // 尝试在2秒内获取锁，获取成功返回true，失败返回false\n            if (lock.tryLock(2, java.util.concurrent.TimeUnit.SECONDS)) {\n                try {\n                    System.out.println(Thread.currentThread().getName() + \" 超时获取锁成功\");\n                } finally {\n                    lock.unlock();\n                }\n            } else {\n                System.out.println(Thread.currentThread().getName() + \" 超时获取锁失败\");\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    public static void main(String[] args) {\n        // 测试普通获取锁\n        new Thread(ReentrantLockDemo::doTask, \"线程1\").start();\n        new Thread(ReentrantLockDemo::doTask, \"线程2\").start();\n        \n        // 测试超时获取锁\n        new Thread(ReentrantLockDemo::tryLockWithTimeout, \"线程3\").start();\n    }\n}\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 22:24</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xi-yongqi\">我会替风去</a>&nbsp;\n阅读(<span id=\"post_view_count\">26</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "从Shapefile到GeoJSON：用GDAL实现GIS矢量数据读写与空间分析",
      "link": "https://www.cnblogs.com/charlee44/p/19479143",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/charlee44/p/19479143\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 20:25\">\n    <span>从Shapefile到GeoJSON：用GDAL实现GIS矢量数据读写与空间分析</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"从Shapefile到GeoJSON：用GDAL实现GIS矢量数据读写与空间分析\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/1000410/202601/1000410-20260113202625252-636759511.png\" />\n        通过 GDAL/OGR 实现了 GIS 矢量数据的完整处理流程——从 Shapefile 读取、WGS84 到 Web 墨卡托坐标转换，到 GeoJSON 写入，并演示了点与多边形拓扑关系（如 Contains）的判断方法。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>本文节选自作者新书<a href=\"https://item.jd.com/14603137.html\" rel=\"noopener nofollow\" target=\"_blank\">《GIS基础原理与技术实践》</a>第4章，系统讲解矢量数据开发基础，涵盖 OGR/GDAL 使用、坐标转换、拓扑判断等实战内容。</p>\n</blockquote>\n<p><img alt=\"GIS基础原理与技术实践\" class=\"lazyload\" /></p>\n<h2 id=\"44-矢量数据开发基础\">4.4 矢量数据开发基础</h2>\n<p>通过之前的介绍，相信读者已经对于GIS的矢量数据有了一个全面的认识，尽管可能不是那么深入。但是没有关系，我们可以在实际的开发过程中加深对其的认识。</p>\n<h3 id=\"441-第三方开源库ogrgdal\">4.4.1 第三方开源库OGR/GDAL</h3>\n<p>在第3章的时候，我们小试牛刀，通过第三方开源库PROJ/GDAL很简单的就实现了地理空间参考系统的相互转换。在这里同样如此，我们可以通过GDAL的OGR组件，轻松实现GIS矢量数据的基础开发。</p>\n<p>OGR曾经是一个独立的矢量IO库，表示OpenGIS Simple Features Reference Implementation的意思，但其实OGR不完全符合OGC的Simple Feature标准规范，因此未被批准作为该规范的参考实现（当然也非常接近规范了）。从GDAL2.0开始，GDAL和OGR组件被集成在一起。</p>\n<p>OGR/GDAL提供了非常强大的矢量读写能力，支持市面上绝大多数矢量数据格式。在第3章我们介绍GDAL的时候就提到过，GDAL是一个GIS数据抽象库。所谓数据抽象，是指无论是哪一种具体的矢量数据格式，GDAL都会将其抽象成数据集对象（Dataset），从而可以支持读取、写出和处理操作。常用的矢量数据格式如下：</p>\n<ul>\n<li>DXF/DWG：应用最广泛的几何图形数据格式，在CAD领域内用的非常多，但是缺点是缺少地理信息。</li>\n<li>ESRI Shapefile：GIS中最常见的矢量数据格式，几乎所有的商业和开源GIS软件都支持。除了几何信息之外，还包含空间信息和属性信息。</li>\n<li>GeoJSON：一种通过JSON来表述要素的矢量数据格式，因而很容易被JavaScript解析和处理，适用于Web端的轻量化应用。</li>\n<li>KML：Google提出的一种基于XML标准来描述地理空间信息的数据格式（包括点、线、面、多边形和模型等），并且已经被OGC认定为开放地理信息编码标准。</li>\n</ul>\n<p>在GDAL中，对数据格式的支持被封装成驱动（dirver），包括上述格式在内的数据驱动要么内嵌在GDAL中，要么通过另外的第三方库来支持。当然这些我们可以暂时不用关心，直接使用本书Github主页代码仓库中的GDAL即可。</p>\n<h3 id=\"442-矢量数据的读取处理和写入\">4.4.2 矢量数据的读取、处理和写入</h3>\n<p>了解了第三方库OGR/GDAL，接下来我们就通过其实现关于GIS矢量数据的基础开发。一个很容易理解的常识是，包含GIS矢量数据在内的任何数据的操作都离不开三个过程：读取、处理和写入。因此，这里我们结合前面空间坐标参考转换的实践，实现一个简单的实例：读取一个面的矢量，然后对其进行空间参考的转换，最后重新写出一个矢量。具体的实现代码如下：</p>\n<pre><code class=\"language-cpp\">#include &lt;ogrsf_frmts.h&gt;\n\n#include &lt;Eigen/Eigen&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\nusing namespace Eigen;\n\nusing Point = Vector3d;\nusing Line = vector&lt;Point&gt;;\nusing Polygon = vector&lt;Line&gt;;\n\nvector&lt;Polygon&gt; polygonData;\n\nOGRSpatialReference srcFileSpatialReference;\nOGRSpatialReference dstFileSpatialReference;\n\nvoid OgrRing2Line(OGRLinearRing *ogrLinearRing, Line &amp;line) {\n  for (int i = 0; i &lt; ogrLinearRing-&gt;getNumPoints(); i++) {\n    line.emplace_back(ogrLinearRing-&gt;getX(i), ogrLinearRing-&gt;getY(i),\n                      ogrLinearRing-&gt;getZ(i));\n  }\n}\n\nvoid OgrPolygon2Polygon(OGRPolygon *ogrPolygon, Polygon &amp;polygon) {\n  //外环\n  Line line;\n  OgrRing2Line(ogrPolygon-&gt;getExteriorRing(), line);\n  polygon.push_back(line);\n\n  //内环\n  for (int ri = 0; ri &lt; ogrPolygon-&gt;getNumInteriorRings(); ri++) {\n    Line line;\n    OgrRing2Line(ogrPolygon-&gt;getInteriorRing(ri), line);\n    polygon.push_back(line);\n  }\n}\n\nbool ReadShp() {\n  string srcFile = getenv(\"GISBasic\");\n  srcFile = srcFile + \"/../Data/Vector/multipolygons.shp\";\n\n  GDALDataset *poDS = (GDALDataset *)GDALOpenEx(srcFile.c_str(), GDAL_OF_VECTOR,\n                                                NULL, NULL, NULL);\n  if (!poDS) {\n    printf(\"无法读取该文件，请检查数据是否存在问题！\");\n    return false;\n  }\n\n  if (poDS-&gt;GetLayerCount() &lt; 1) {\n    printf(\"该文件的层数小于1，请检查数据是否存在问题！\");\n    return false;\n  }\n\n  //原始数据空间参考\n  char *pszWKT = nullptr;\n  poDS-&gt;GetLayer(0)-&gt;GetSpatialRef()-&gt;exportToWkt(&amp;pszWKT);\n  srcFileSpatialReference.importFromWkt(pszWKT);\n  CPLFree(pszWKT);\n  pszWKT = nullptr;\n\n  for (int li = 0; li &lt; poDS-&gt;GetLayerCount(); li++) {\n    OGRLayer *poLayer = poDS-&gt;GetLayer(li);  //读取层\n    poLayer-&gt;ResetReading();\n\n    //输出字段名\n    OGRFeatureDefn *poFDefn = poLayer-&gt;GetLayerDefn();\n    int n = poFDefn-&gt;GetFieldCount();\n    for (int iField = 0; iField &lt; n; iField++) {\n      OGRFieldDefn *OGRFieldDefn = poFDefn-&gt;GetFieldDefn(iField);\n      cout &lt;&lt; OGRFieldDefn-&gt;GetNameRef() &lt;&lt; endl;\n    }\n\n    //遍历特征\n    OGRFeature *poFeature = nullptr;\n    while ((poFeature = poLayer-&gt;GetNextFeature()) != nullptr) {\n      OGRGeometry *geometry = poFeature-&gt;GetGeometryRef();\n      OGRwkbGeometryType geometryType = geometry-&gt;getGeometryType();\n\n      switch (geometryType) {\n        case wkbPolygon:\n        case wkbPolygonM:\n        case wkbPolygonZM: {\n          OGRPolygon *ogrPolygon = dynamic_cast&lt;OGRPolygon *&gt;(geometry);\n          if (!ogrPolygon) {\n            continue;\n          }\n\n          Polygon polygon;\n          OgrPolygon2Polygon(ogrPolygon, polygon);\n          polygonData.push_back(polygon);\n\n          break;\n        }\n        case wkbMultiPolygon:\n        case wkbMultiPolygonM:\n        case wkbMultiPolygonZM: {\n          OGRMultiPolygon *ogrMultiPolygon =\n              dynamic_cast&lt;OGRMultiPolygon *&gt;(geometry);\n          if (!ogrMultiPolygon) {\n            continue;\n          }\n\n          for (int gi = 0; gi &lt; ogrMultiPolygon-&gt;getNumGeometries(); gi++) {\n            OGRPolygon *ogrPolygon =\n                dynamic_cast&lt;OGRPolygon *&gt;(ogrMultiPolygon-&gt;getGeometryRef(gi));\n            if (!ogrPolygon) {\n              continue;\n            }\n\n            Polygon polygon;\n            OgrPolygon2Polygon(ogrPolygon, polygon);\n            polygonData.push_back(polygon);\n          }\n\n          break;\n        }\n        default: {\n          printf(\"未处理的特征类型\\n\");\n          break;\n        }\n      }\n\n      //输出每个字段的值\n      for (int iField = 0; iField &lt; n; iField++) {\n        cout &lt;&lt; poFeature-&gt;GetFieldAsString(iField) &lt;&lt; \"    \";\n      }\n      cout &lt;&lt; endl;\n\n      OGRFeature::DestroyFeature(poFeature);\n    }\n  }\n\n  GDALClose(poDS);\n  poDS = nullptr;\n\n  return true;\n}\n\nvoid Convert() {\n  dstFileSpatialReference.importFromEPSG(3857);\n  dstFileSpatialReference.SetAxisMappingStrategy(OAMS_TRADITIONAL_GIS_ORDER);\n  srcFileSpatialReference.SetAxisMappingStrategy(OAMS_TRADITIONAL_GIS_ORDER);\n\n  OGRCoordinateTransformation *src2DstTransformation =\n      OGRCreateCoordinateTransformation(&amp;srcFileSpatialReference,\n                                        &amp;dstFileSpatialReference);\n\n  if (!src2DstTransformation) {\n    return;\n  }\n\n  for (auto &amp;polygon : polygonData) {\n    for (auto &amp;line : polygon) {\n      for (auto &amp;point : line) {\n        src2DstTransformation-&gt;Transform(1, point.data(), point.data() + 1,\n                                         point.data() + 2);\n      }\n    }\n  }\n}\n\nbool CreateField(OGRLayer *poLayer) {\n  // 字符串\n  OGRFieldDefn oField1(\"Type\", OFTString);\n  oField1.SetWidth(8);\n  if (poLayer-&gt;CreateField(&amp;oField1) != OGRERR_NONE) {\n    printf(\"Creating Name field failed.\\n\");\n    return false;\n  }\n\n  // 浮点数\n  OGRFieldDefn oField2(\"Area\", OFTReal);\n  oField2.SetPrecision(3);\n  if (poLayer-&gt;CreateField(&amp;oField2) != OGRERR_NONE) {\n    printf(\"Creating Name field failed.\\n\");\n    return false;\n  }\n\n  // 整型\n  OGRFieldDefn oField3(\"VertexCount\", OFTInteger);\n  if (poLayer-&gt;CreateField(&amp;oField3) != OGRERR_NONE) {\n    printf(\"Creating Name field failed.\\n\");\n    return false;\n  }\n\n  return true;\n}\n\nbool WriteGeoJson() {\n  string dstFile = getenv(\"GISBasic\");\n  dstFile = dstFile + \"/../Data/Out.geoJson\";\n\n  //创建\n  GDALDriver *driver = GetGDALDriverManager()-&gt;GetDriverByName(\"GeoJSON\");\n  if (!driver) {\n    printf(\"Get Driver GeoJSON Error！\\n\");\n    return false;\n  }\n\n  GDALDataset *dataset =\n      driver-&gt;Create(dstFile.c_str(), 0, 0, 0, GDT_Unknown, NULL);\n  OGRLayer *poLayer = dataset-&gt;CreateLayer(\n      \"FirstLayer\", &amp;dstFileSpatialReference, wkbPolygon, NULL);\n\n  if (!CreateField(poLayer)) {\n    return false;\n  }\n\n  //创建特征\n  for (const auto &amp;polygon : polygonData) {\n    OGRFeature ogrFeature(poLayer-&gt;GetLayerDefn());\n\n    OGRPolygon ogrPolygon;\n\n    int vertexNum = 0;\n    for (const auto &amp;line : polygon) {\n      OGRLinearRing ogrRing;\n      for (const auto &amp;point : line) {\n        ogrRing.addPoint(point.x(), point.y(), point.z());\n        vertexNum++;\n      }\n      ogrPolygon.addRing(&amp;ogrRing);\n    }\n    ogrFeature.SetGeometry(&amp;ogrPolygon);\n\n    ogrFeature.SetField(\"Type\", \"Polygon\");\n    ogrFeature.SetField(\"Area\", ogrPolygon.get_Area());\n    ogrFeature.SetField(\"VertexCount\", vertexNum);\n\n    if (poLayer-&gt;CreateFeature(&amp;ogrFeature) != OGRERR_NONE) {\n      printf(\"Failed to create feature.\\n\");\n      return false;\n    }\n  }\n\n  //释放\n  GDALClose(dataset);\n  dataset = nullptr;\n\n  return true;\n}\n\nint main() {\n  GDALAllRegister();\n  CPLSetConfigOption(\"GDAL_FILENAME_IS_UTF8\", \"NO\");  //支持中文路径\n  CPLSetConfigOption(\"SHAPE_ENCODING\", \"\");           //解决中文乱码问题\n\n  if (!ReadShp()) {\n    return 1;\n  }\n\n  Convert();\n\n  WriteGeoJson();\n}\n</code></pre>\n<p>在这里，读取的矢量是一个Shapefile文件，包含的都是多边形的要素，空间参考为WGS84地理坐标系（EPSG：4326），显示如下图4.14所示：</p>\n<p><img alt=\"图4.14 处理前多边形矢量要素\" class=\"lazyload\" /></p>\n<p>经过空间参考转换后，空间参考为Web墨卡托投影坐标系（EPSG：3857），且生成的是一个GeoJson文件。如下图4.15所示，可以看到在空间坐标参考转换之后形状似乎“变窄”了一点，这是地图投影变换的特性决定的（参考第2章介绍的知识）。</p>\n<p><img alt=\"图4.15 处理后多边形矢量要素\" class=\"lazyload\" /></p>\n<p>这段代码的关键在于如下几点：</p>\n<ul>\n<li>\n<p>读取矢量时，矢量数据被读取成数据集对象GDALDataset，GDALDataset管理图层对象OGRLayer，OGRLayer管理特征类对象OGRFeature，OGRFeature则包含几何对象类OGRGeometry。OGRGeometry是一个抽象父类，有意义的是其表达具体的几何对象的子类，比如OGRPolygon代表多边形几何对象。OGRPolygon又是由1个外环和多个内环（环线：OGRLinearRing）组成。矢量就是这样一层层抽象组合表达出来的。</p>\n</li>\n<li>\n<p>在进行数据处理也就是空间参考转换之前，我们把读取的数据放到我们自己的数据容器中：</p>\n<pre><code class=\"language-cpp\">using Point = Vector3d;\nusing Line = vector&lt;Point&gt;;\nusing Polygon = vector&lt;Line&gt;;\n\nvector&lt;Polygon&gt; polygonData;\n</code></pre>\n<p>真实的GIS数据处理开发要求是千变万化的，操作的往往不是读取组件（这里指OGR）定义的数据结构对象。我们可以将其读取在成自定义的数据结构中，以方便我们进行更加通用的操作，或者进行并行优化。在这里我们遍历了自定义的数据结构对象中的顶点，逐点进行空间坐标参考的转换。进行其他的数据处理也是如此，根据自己的需要操作自己的数据结构容器。</p>\n</li>\n<li>\n<p>写出矢量时，将处理结束的自定义数据结构对象恢复成数据集对象GDALDataset（读取矢量的逆操作）。另外，需要关注的是GDAL的数据驱动GDALDriver，其是通过名称来创建对应格式的矢量文件，例如这里传入到名称是GeoJson:</p>\n<pre><code class=\"language-cpp\">GDALDriver *driver = GetGDALDriverManager()-&gt;GetDriverByName(\"GeoJSON\");\nif (!driver) {\n  printf(\"Get Driver GeoJSON Error！\\n\");\n  return false;\n}\n</code></pre>\n</li>\n<li>\n<p>矢量数据的属性表数据与数据库中的表结构比较类似，每个字段具有自己的定义属性，例如数据类型、长度、精度等。并且，每一个特征都对应了一行记录。因而属性表的操作还是挺复杂的，往往与业务操作相关联。这里仅仅只是输出显示了读取的属性表信息，写入了自己创建的字段与值。读取和写入的属性表数据如下图4.16、图4.17所示：</p>\n</li>\n</ul>\n<p><img alt=\"图4.16 读取的属性表信息\" class=\"lazyload\" /><br />\n<img alt=\"图4.17 写入的属性表信息\" class=\"lazyload\" /></p>\n<h3 id=\"443-空间拓扑关系的判断\">4.4.3 空间拓扑关系的判断</h3>\n<p>对矢量要素进行空间拓扑关系的判断也是GIS开发中常用的功能。在4.3.3节中介绍了OGC的Simple Feature标准规范中拓扑关系，OGR/GDAL对其做了具体的实现。任何继承了OGRGeometry的几何对象类（如OGRPoint、OGRPolygon）都可以调用标准中定义的接口（二元谓词），判断该几何对象与另外一个几何对象的拓扑关系。在如下实例中，判断了空间中某点与某多边形是否存在包含（Contains）关系：</p>\n<pre><code class=\"language-cpp\">#include &lt;ogrsf_frmts.h&gt;\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n  OGRLinearRing linearRing;\n  linearRing.addPoint(268.28, 784.75);\n  linearRing.addPoint(153.98, 600.60);\n  linearRing.addPoint(274.63, 336.02);\n  linearRing.addPoint(623.88, 401.64);\n  linearRing.addPoint(676.80, 634.47);\n  linearRing.addPoint(530.75, 822.85);\n  linearRing.closeRings();\n\n  OGRPolygon polygon;\n  polygon.addRing(&amp;linearRing);\n\n  cout &lt;&lt; \"点A是否在多边形内：\";\n  OGRPoint pointA(407.98, 579.43);  \n  cout &lt;&lt; polygon.Contains(&amp;pointA) &lt;&lt; endl;\n\n  cout &lt;&lt; \"点B是否在多边形内：\";\n  OGRPoint pointB(678.92, 482.07);  \n  cout &lt;&lt; polygon.Contains(&amp;pointB) &lt;&lt; endl;\n}\n</code></pre>\n<p>运行的结果如下所示：</p>\n<pre><code class=\"language-text\">点A是否在多边形内：1\n点B是否在多边形内：0\n</code></pre>\n<p>在4.3.3节中介绍过，包含(Contains)与内含(Within)是一对相反的关系。在这里我们当然也可以调用OGRPoint的内含(Within)接口，会返回与上述同样的结果。不止如此，其他空间拓扑关系的接口也是这样调用，读者可以根据自己的需求尝试一二，这里只是抛砖引玉。</p>\n<hr />\n<p>本文节选自作者新书《GIS基础原理与技术实践》第4章。书中系统讲解 GIS 核心理论与多语言实战，适合开发者与高校师生。</p>\n<p>📚 <strong>配套资源开源</strong>：<a href=\"https://github.com/fafa1899/GISBasic\" rel=\"noopener nofollow\" target=\"_blank\">GitHub</a> | <a href=\"https://gitcode.com/charlee44/GISBasic\" rel=\"noopener nofollow\" target=\"_blank\">GitCode</a></p>\n<p>🛒 <strong>支持正版</strong>：<a href=\"https://item.jd.com/14603137.html\" rel=\"noopener nofollow\" target=\"_blank\">京东</a>｜<a href=\"https://product.dangdang.com/29988568.html\" rel=\"noopener nofollow\" target=\"_blank\">当当</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 20:25</span>&nbsp;\n<a href=\"https://www.cnblogs.com/charlee44\">charlee44</a>&nbsp;\n阅读(<span id=\"post_view_count\">27</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}