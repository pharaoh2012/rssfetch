{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "开源自建，GPT 切换空间麻烦？一件帮你搞定",
      "link": "https://www.cnblogs.com/qxnm/p/19558462",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/qxnm/p/19558462\" id=\"cb_post_title_url\" title=\"发布于 2026-01-31 16:23\">\n    <span>开源自建，GPT 切换空间麻烦？一件帮你搞定</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p style=\"font-size: 0; line-height: 0; margin: 0;\">&nbsp;</p>\n<section>\n<blockquote>\n<p>字数 497，阅读大约需 3 分钟</p>\n</blockquote>\n<p>这几天给我忙的，最近写了一个Codex的TEAM 账号管理工具直接在本地运行<br />大概是下面这样肝了几天，能配合codex cli使用<br />有目前还有一些bug和不好用的地方，后面会逐步优化出来</p>\n<p>项目连接，需要的佬友希望能贡献一个start<br /><span>hongshungao/Codex-Manager: 一个Codex cli 账号管理与切换工具。为 Codex cli提供本地号池管理自动切换。<sup>[1]</sup></span></p>\n<h2 id=\"0\">ReadMe</h2>\n<p>本地桌面端 + 服务进程的 Codex 账号池管理器，用于统一管理账号、用量与平台 Key，并提供本地网关与服务能力。</p>\n<h2 id=\"1\">项目简介</h2>\n<ul>\n<li>• 桌面端（Tauri）负责账号管理、用量展示、授权登录与平台 Key 配置</li>\n<li>• 服务端（Rust）提供本地 RPC + Gateway，支持用量刷新、账号轮询与鉴权转发</li>\n<li>• 支持手动解析 OAuth 回调链接，避免端口冲突或回调失败</li>\n</ul>\n<h2 id=\"2\">功能亮点</h2>\n<ul>\n<li>• 账号池管理：分组/标签/排序/备注</li>\n<li>• 用量展示：5 小时 + 7 日用量快照</li>\n<li>• 授权登录：浏览器授权 + 手动回调解析</li>\n<li>• 平台 Key：生成/禁用/删除</li>\n<li>• 本地服务：自动启动、可自定义端口</li>\n<li>• 网关能力：为本地 CLI/工具提供统一入口</li>\n</ul>\n<h2 id=\"3\">技术栈</h2>\n<ul>\n<li>• 前端：Vite + 原生 JS + 自定义 UI</li>\n<li>• 桌面端：Tauri (Rust)</li>\n<li>• 服务端：Rust（本地 HTTP/RPC + Gateway）</li>\n</ul>\n<h2 id=\"4\">目录结构</h2>\n<pre class=\"language-plaintext highlighter-hljs\"><code>.\n├─&nbsp;apps/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;前端与&nbsp;Tauri&nbsp;桌面端\n│&nbsp;&nbsp;├─&nbsp;src/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;前端源码\n│&nbsp;&nbsp;├─&nbsp;src-tauri/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Tauri&nbsp;端源码\n│&nbsp;&nbsp;└─&nbsp;dist/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;前端构建产物\n├─&nbsp;crates/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Rust&nbsp;核心与服务端\n│&nbsp;&nbsp;├─&nbsp;gpttools-core\n│&nbsp;&nbsp;└─&nbsp;gpttools-service\n├─&nbsp;portable/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;便携版输出目录\n├─&nbsp;rebuild.ps1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;打包脚本\n└─&nbsp;README.md</code></pre>\n<h2 id=\"5\">快速开始</h2>\n<ol>\n<li>1. 启动桌面端后，点击“启动服务”</li>\n<li>2. 进入“账号管理”添加账号并完成授权</li>\n<li>3. 需要时粘贴回调链接完成手动解析</li>\n<li>4. 刷新用量，检查状态与配额</li>\n</ol>\n</section>\n<p style=\"font-size: 0; line-height: 0; margin: 0;\">&nbsp;</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-31 16:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/qxnm\">高宏顺</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "硬核科普：为何小米任天堂封杀 Root？揭秘操作系统从启动到“夺权”的底层游戏",
      "link": "https://www.cnblogs.com/kaiux/p/19558207",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/kaiux/p/19558207\" id=\"cb_post_title_url\" title=\"发布于 2026-01-31 15:40\">\n    <span>硬核科普：为何小米任天堂封杀 Root？揭秘操作系统从启动到“夺权”的底层游戏</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"硬核科普：为何小米任天堂封杀 Root？揭秘操作系统从启动到“夺权”的底层游戏\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/1158182/202601/1158182-20260131154106142-1968484472.png\" />\n        小米锁BL、任天堂反破解，厂商在怕什么？本文硬核拆解从开机到“夺权”的底层逻辑。穿越UEFI权力交接，揭秘Ring0物理防线与Root本质，深度剖析Switch硬破的“电压故障注入”原理。带你深入微观世界，看懂这场芯片深处的信任链攻防战。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>最近机圈最热闹的两件事：一是小米彻底收紧了 Bootloader 解锁权限，二是任天堂又起诉了几个卖 Switch 破解芯片的商家。</p>\n<p>很多兄弟可能会觉得：“我花钱买的硬件，凭什么不让我完全控制？”</p>\n<p>但在厂商的逻辑里，<strong>一旦你拿到了最高权限，你就打破了我们辛苦建立的“商业围墙”。</strong></p>\n<p>为了看懂这场关于“控制权”的战争，我们不需要去啃枯燥的《操作系统导论》，只需要把视角缩小到纳秒级别，看看当你按下电源键的那一惊心动魄的瞬间，计算机内部到底上演了一场怎样的“权力交接”。</p>\n<h2 id=\"一蛮荒时代的地图\">一、蛮荒时代的地图</h2>\n<p>在 CPU 刚刚醒来的那一刻，它面对的是一片漆黑的存储荒原——硬盘。要把庞大的操作系统装进脑子（内存）里，首先得有一张地图。</p>\n<p><strong>1. MBR：上一代的老地图</strong></p>\n<p>在以前，我们使用的是 <strong>MBR (Master Boot Record)</strong>。它的样子非常寒酸，只占据硬盘最开头的 <strong>512 字节</strong>。</p>\n<p>哪怕你现在的硬盘有 10TB，MBR 也只有这点地盘。这就导致了它先天不足：因为记录地址的空间太小，它最大只能识别 <strong>2TB</strong> 的硬盘，而且最多只能分 <strong>4 个主分区</strong>。它就像一本只有一页目录的老旧笔记本，既写不下太多东西，也指引不了通往大城市的路。</p>\n<p><strong>2. GPT：新世界的全息导航</strong></p>\n<p>现在的电脑几乎都标配 <strong>UEFI</strong> 启动，与之搭配的是 <strong>GPT (GUID Partition Table)</strong> 分区表。</p>\n<p>它的优势显而易见：彻底打破了容量和分区数量的限制，想分多少就分多少。更重要的是它具备了<strong>容灾机制</strong>——MBR 坏了，整块硬盘的数据可能就读不出来了；但 GPT 聪明地在硬盘的“车头”和“车尾”各存了一份，坏了还能救。</p>\n<p>为了照顾那些老旧的软件，现在的 GPT 硬盘还会在开头保留一个“假装的 MBR”。它的唯一作用就是告诉老软件：“这块硬盘已经有主了，别乱动。”</p>\n<p><img alt=\"mbrvsgpt\" src=\"https://img2024.cnblogs.com/blog/1158182/202601/1158182-20260131153816610-848754645.jpg\" /></p>\n<h2 id=\"二第一棒火炬手\">二、第一棒火炬手</h2>\n<p>当你按下电源键，电流涌入主板，CPU 做的第一件事是“硬编码”写死的：强制读取一段“绝对权威”的代码。</p>\n<p>这里住着硬件的灵魂——<strong>固件 (Firmware)</strong>。不过，根据设备类型的不同，这里的管家也分为两派。</p>\n<p><strong>1. PC 界的管家：从 BIOS 到 UEFI</strong></p>\n<p>在漫长的 PC 发展史中，管家换了一届。</p>\n<ul>\n<li><strong>老管家叫 BIOS</strong>。它是个守旧派，只懂 16 位汇编语言，只能呆板地读取硬盘头部的 MBR，干活慢且效率低。</li>\n<li><strong>新管家叫 UEFI</strong>。它本质上已经是一个<strong>微型操作系统</strong>了。它能读懂文件系统（比如 FAT32），能直接运行后缀为 <code>.efi</code> 的可执行程序，甚至能联网。这也是为什么现在的 BIOS 界面能用鼠标、能截图，甚至做得花里胡哨的原因。</li>\n</ul>\n<p><img alt=\"bios\" src=\"https://img2024.cnblogs.com/blog/1158182/202601/1158182-20260131153830288-1861685661.jpg\" /></p>\n<p><strong>2. 嵌入式界的管家：BootROM</strong></p>\n<p>对于<strong>小米手机</strong>或 <strong>Switch</strong> 这种嵌入式设备（通常是 ARM 架构），虽然它们没有像电脑那样可以按 <code>Del</code> 键进入的图形化 UEFI 界面，但核心逻辑是一样的。</p>\n<p>它们依靠的是芯片出厂时就在内部烧录死的一小段代码——<strong>BootROM</strong>。它是硬件苏醒后执行的第一段代码，比任何软件都早，且无法被修改。它的职责单一而神圣：初始化最基本的硬件，然后去寻找并验证下一棒接力者。</p>\n<h2 id=\"三灵活的中间人\">三、灵活的中间人</h2>\n<p>当 UEFI 或 BootROM 自检完硬件，准备把权力移交给操作系统时，它不会直接唤醒 Windows 或 Linux 的内核，而是先唤醒一位中间人——<strong>Bootloader</strong>（在 Linux PC 世界里通常是 GRUB，在安卓/手机世界里通常是 U-Boot 或厂商自研的 Bootloader）。</p>\n<p><strong>为什么要绕一圈，不能直接加载内核吗？</strong></p>\n<p>原因在于操作系统内核（Kernel）太“娇贵”了：</p>\n<ol>\n<li>它可能需要特殊的启动参数（比如你需要进入安全模式，或者开启调试）。</li>\n<li>它可能躺在固件读不懂的文件系统里（比如 Linux 的 Ext4 格式，UEFI 原生可能只认 FAT）。</li>\n<li>你可能安装了双系统，需要有人来问你到底进哪一个。</li>\n</ol>\n<p>所以，Bootloader 就像是一个专业的“领路人”。它负责把内核文件（<code>vmlinuz</code>）和初始化文件系统（<code>initrd</code>）搬运到内存里，一切准备就绪后，执行一个信仰之跃（Jump 指令），将 CPU 的控制权彻底移交给内核。</p>\n<p><img alt=\"bootloader\" src=\"https://img2024.cnblogs.com/blog/1158182/202601/1158182-20260131153843749-1017464152.jpg\" /></p>\n<h2 id=\"四阶级森严\">四、阶级森严</h2>\n<p>内核（Kernel）一旦接管了 CPU，做的第一件事就是利用 CPU 的硬件特性，建立起森严的等级制度。这是系统安全的基石。</p>\n<p><strong>1. 消失的 Ring 1 和 Ring 2</strong></p>\n<p>Intel x86 架构在设计之初，其实定义了 4 个特权级：<strong>Ring 0</strong>（内核，最高权限）、<strong>Ring 1 &amp; 2</strong>（原本给驱动）、<strong>Ring 3</strong>（应用程序，最低权限）。</p>\n<p><strong>但在现代操作系统（Windows/Linux）中，Ring 1 和 Ring 2 几乎被废弃了，只剩下了两极分化的 Ring 0 和 Ring 3。</strong></p>\n<p>这最核心的原因是<strong>移植性（Portability）</strong>。当年的 Linux 和 Windows NT 为了能跑在不同的 CPU 架构上（比如 MIPS、ARM），遇到了一个大难题：很多非 x86 的 RISC 架构硬件设计上非常精简，<strong>只支持两个层级</strong>（内核态 Kernel Mode 和用户态 User Mode）。为了保证代码通用，操作系统设计者索性决定：“好，那我们也只用两层，把中间的砍掉。”</p>\n<p><strong>2. 物理层面的防线</strong></p>\n<p>现在的 CPU 内部，有一个 <strong>CS 寄存器</strong> 明确记录了当前的身份：</p>\n<ul>\n<li><strong>0 (上帝模式)</strong>：你可以执行所有指令，开关中断、读写任意内存、直接操作硬盘 IO。</li>\n<li><strong>3 (平民模式)</strong>：你只能做数学运算，严禁直接触碰硬件。</li>\n</ul>\n<p>如果你的 App（运行在 Ring 3）试图执行一条“读取硬盘”的汇编指令，CPU 硬件在解码阶段就会发现：“你只有 3 级权限，却想执行 0 级指令？” 于是直接抛出异常，内核捕获后会直接把这个 App 杀掉——这就是程序<strong>崩溃（Crash）</strong>的本质。</p>\n<p><strong>3. 唯一的通道：Syscall</strong></p>\n<p>那平民（App）想办事（比如读文件、联网）怎么办？必须去敲衙门的鼓——这叫<strong>系统调用（Syscall）</strong>。</p>\n<ol>\n<li>App 执行 <code>SYSCALL</code> 指令。</li>\n<li>CPU 瞬间切换到 Ring 0，跳转到内核预设好的代码位置。</li>\n<li><strong>换栈（Stack Switching）</strong>：这是关键一步，CPU 会自动把栈指针从“用户栈”切换到“内核栈”。这是为了防止黑客在栈里埋雷，确保内核在一个绝对干净的环境下工作。</li>\n<li>内核替你办完事，把结果拷回用户内存，然后退回 Ring 3。</li>\n</ol>\n<p><img alt=\"rings\" src=\"https://img2024.cnblogs.com/blog/1158182/202601/1158182-20260131153901587-891608174.jpg\" /></p>\n<h2 id=\"五真假美猴王\">五、真假美猴王</h2>\n<p>这是很多技术爱好者最容易搞混的地方：<strong>“我手机 Root 了，是不是就意味着我的 App 运行在 Ring 0 了？”</strong></p>\n<p><strong>答案是：NO。即使你 Root 了，你的 App 依然运行在 Ring 3。</strong></p>\n<p><strong>1. Root 只是一个“通行证”</strong></p>\n<p>我们需要区分两个概念：</p>\n<ul>\n<li><strong>Root (User ID = 0)</strong>：这是<strong>软件层面</strong>的概念。它只是 Linux 系统里的一条用户记录。它的权力在于：<strong>内核被设计为“无条件听从 Root 用户的请求”。</strong></li>\n<li><strong>Ring 0</strong>：这是<strong>硬件层面</strong>的概念。只有内核代码本身运行在这里。</li>\n</ul>\n<p><strong>2. 皇帝与刽子手</strong></p>\n<p>当你获取了 Root 权限，运行一个命令 <code>rm -rf /</code>（删库跑路）时，过程是这样的：</p>\n<ol>\n<li><strong>Root 用户</strong> 发起删除文件的请求。</li>\n<li><strong>内核</strong> 检查发起者：哟，是 ID 为 0 的大哥啊。虽然删除系统文件很危险，但既然大哥说了，我就照做。</li>\n<li><strong>内核（Ring 0）</strong> 驱动硬盘磁头，物理擦除数据。</li>\n</ol>\n<p><strong>总结一下</strong>：Root 用户就像是拿着“圣旨”的钦差大臣，但他本身还是个人（运行在 Ring 3）；而 Ring 0 才是那个真正持刀动手的刽子手。<strong>Root 拿到了最高行政权，但没有拿到最高物理执行权。</strong></p>\n<p><img alt=\"rootvsring\" src=\"https://img2024.cnblogs.com/blog/1158182/202601/1158182-20260131153913727-1769032851.jpg\" /></p>\n<h2 id=\"六打破枷锁\">六、打破枷锁</h2>\n<p>理解了上面的“信任链”和“权限墙”，我们终于可以看懂黑客是如何一步步攻破系统的。这个过程，本质上就是一场精密的外科手术。</p>\n<p><strong>1. 撕开封条：手机解锁 BL (Bootloader)</strong></p>\n<p>正常的手机启动链条是严丝合缝的：<strong>BootROM (硬件)</strong> → <strong>验证 Bootloader 签名</strong> → <strong>验证 Kernel (系统内核) 签名</strong>。</p>\n<p>所谓的 <strong>BL 锁</strong>，就是厂商让 Bootloader 严格查验下一级（Kernel）是不是官方原厂的。如果是官方的，放行；如果被人动过手脚（比如为了 Root），拒绝启动。</p>\n<p>而<strong>解锁 BL</strong>，就是用官方给的工具（或者利用漏洞），给 Bootloader 下达一道指令：“别查签名了，不管我刷进去什么烂七八糟的内核，你都给我跑。”</p>\n<p><em>注意代价：解锁 BL 虽然让你获得了自由，但也<strong>破坏了完整的信任链</strong>（Android Verified Boot）。此时，系统里的 TEE（可信执行环境）会感知到环境不安全，从而导致银行 App 闪退、微信/支付宝指纹支付失效等后果。</em></p>\n<p><strong>2. 植入假肢：从解锁到获取 Root 的全过程</strong></p>\n<p>很多小白以为解了 BL 就自动 Root 了，其实不是。解锁只是打开了大门，房间（系统）还是空的。要拿到 Root，必须进行一场<strong>“器官移植”</strong>。</p>\n<p>以 Android 上最流行的 Magisk 为例，它的核心魔法叫做 <strong>\"Systemless\"（不触动 System 分区）</strong>，标准流程是：</p>\n<ol>\n<li><strong>提取器官</strong>：从官方刷机包里提取出 <strong><code>boot.img</code></strong>。</li>\n<li><strong>手术改造</strong>：Magisk 会像病毒一样，把自己的核心代码（<code>su</code> 文件和守护进程）<strong>注入</strong> 到这个镜像里，而完全不去修改原本的 System 分区。</li>\n<li><strong>移植手术</strong>：因为你之前<strong>解锁了 BL</strong>，Bootloader 看到这个被篡改过的镜像，虽然签名不对，但它耸耸肩：“反正你解锁了，你开心就好”，然后把它刷进了硬盘。</li>\n<li><strong>夺舍</strong>：手机重启，内核加载。Magisk 的守护进程随之启动，接管了权限管理。</li>\n</ol>\n<p><img alt=\"刷机\" src=\"https://img2024.cnblogs.com/blog/1158182/202601/1158182-20260131153926524-1349870764.jpg\" /></p>\n<p><strong>3. 终极破解：Switch 与芯片硬破</strong></p>\n<p>如果说手机 Root 还是软件层面的博弈，那么 Switch 的破解就是物理层面的暴力美学。Switch 破解的核心动力非常朴素：<strong>因为穷，不想买游戏，所以必须绕过游戏签名验证。</strong></p>\n<p><strong>(1) 上古时代的“软破”</strong></p>\n<p>最早的一批 Switch（2018 年前出厂），芯片（Tegra X1）里的 <strong>BootROM</strong> 代码写挫了。黑客不仅需要用一根回形针<strong>短接手柄滑轨</strong>进入 RCM（恢复）模式，还需要配合<strong>电脑或注入器通过 USB 接口发送一段 Payload</strong>，利用缓冲区溢出漏洞欺骗 CPU。这属于“老天爷赏饭吃”，任天堂除了出新硬件，软件层面根本修补不了。</p>\n<p><strong>(2) 现代的“硬破” (Modchip 芯片破解)</strong></p>\n<p>任天堂后来修复了漏洞。现在的破解必须<strong>拆机</strong>，在主板上极其精细地<strong>焊接一颗第三方芯片</strong>。这玩意的原理叫 <strong>“电压故障注入” (Voltage Glitching)</strong>。</p>\n<ul>\n<li><strong>【原理】</strong> Switch 启动时，CPU 会读取官方 Bootloader 并进行签名校验。</li>\n<li><strong>【攻击】</strong> 焊在主板上的破解芯片像狙击手一样，死死盯着 CPU。当 CPU 准备执行“校验签名”这一行代码的<strong>纳秒级瞬间</strong>，破解芯片突然<strong>拉低 CPU 的核心电压 (VCC)</strong>。</li>\n<li><strong>【结果】</strong> 电压骤降导致 CPU 就像被电击了一下，脑子“懵”了那么一瞬间。它刚好<strong>跳过了校验指令</strong>，或者将寄存器里校验失败的 <code>False</code> 错误地读成了 <code>True</code>。</li>\n</ul>\n<p>这就好比保安拦住你要查身份证，你没带。但在保安张嘴问你“身份证呢？”的一瞬间，你突然在他耳边敲了一记锣。保安脑子一片空白，下意识地摆摆手：“行行行，进去吧。”</p>\n<p><strong>(3) 鸠占鹊巢：Atmosphere (大气层)</strong></p>\n<p>既然通过“电击”保安混进了大门，我们就不加载任天堂官方系统了，而是加载 <strong>Atmosphere</strong>。它本质上是一个<strong>定制的 Bootloader + 系统补丁集</strong>。它接管了启动流程，并且在内存中实时修改任天堂的 OS，欺骗系统说：“这张盗版卡是通过验证的”。</p>\n<p><img alt=\"switch\" src=\"https://img2024.cnblogs.com/blog/1158182/202601/1158182-20260131153938657-967507878.jpg\" /></p>\n<h2 id=\"七猫鼠游戏\">七、猫鼠游戏</h2>\n<p>Root 成功了，并不代表你可以高枕无忧。事实上，这才是你和 App 开发商（尤其是银行、游戏）之间“猫鼠游戏”的开始。</p>\n<p><strong>1. App 是怎么发现你 Root 的？</strong></p>\n<p>App 也是运行在 Ring 3 的平民，它不能直接问 CPU “我是不是被 Root 了”。但它有很多间接手段：</p>\n<ul>\n<li><strong>查户口（文件扫描）</strong>：App 会偷偷扫描你的 <code>/bin</code> 或 <code>/sbin</code> 目录，看看有没有 <code>su</code> 这个文件，或者有没有安装 <code>Magisk Manager</code> 这个 App。</li>\n<li><strong>打电话问家长（Play Integrity API）</strong>：这是最狠的一招。App 会发起一个请求，通过 Google 的服务去询问你的底层硬件。Google 会检查你的 Bootloader 状态。如果你解锁了，硬件层面的 <strong>TEE (可信执行环境)</strong> 就会老实交待：“是的，我的大门被打开了。”</li>\n</ul>\n<p><strong>2. Magisk 的隐身术：命名空间隔离 (Namespace Isolation)</strong></p>\n<p>既然 App 会查文件，那我们在它查房的时候，把违禁品藏起来不就好了？这就是 Magisk Hide（现在进化为 Zygisk/Shamiko）的核心原理。</p>\n<p>Linux 内核有一个强大的功能叫 <strong>Mount Namespace</strong>。它可以让每个进程看到完全不同的文件系统视图。</p>\n<ul>\n<li><strong>平时</strong>：你的文件系统里确实有 Root 相关的文件。</li>\n<li><strong>当你打开银行 App 时</strong>：Magisk 会立刻拦截这个启动过程，为这个银行 App 单独创建一个“平行宇宙”。</li>\n<li><strong>在那个宇宙里</strong>：Magisk 会利用 <code>unmount</code> 指令，把 <code>su</code> 文件、Magisk 相关的模块全部“卸载”掉。</li>\n<li><strong>结果</strong>：银行 App 睁开眼，看到的是一个干干净净、仿佛从未被 Root 过的官方系统。它满意地点点头，让你通过了。</li>\n</ul>\n<p><strong>3. 道高一尺，魔高一丈</strong></p>\n<p>现在，这场战争已经进化到了<strong>硬件层面</strong>。</p>\n<p>像 <strong>KernelSU</strong> 这种新一代 Root 方案，直接把自己藏进了内核里（Ring 0），让运行在 Ring 3 的 App 根本无从查起。而 App 厂商则开始联合手机厂商，试图通过<strong>硬件密钥证明 (Key Attestation)</strong> 让你在解锁 Bootloader 的那一刻起，就永远失去通过“安全验证”的资格。</p>\n<p>只要你为了自由解开了锁，你就注定要一直在这个猫鼠游戏里通过不断的“伪装”生存下去。</p>\n<h2 id=\"八总结心智模型\">八、总结：心智模型</h2>\n<p>看完全文，你应该在脑海里建立起这样一张图：</p>\n<ol>\n<li><strong>地图 (MBR 与 GPT)</strong>：决定了地盘怎么分。</li>\n<li><strong>接力 (BootROM/UEFI → Bootloader → Kernel)</strong>：是一场从硬件到软件的信任接力赛。</li>\n<li><strong>高墙 (Ring 0 vs Ring 3)</strong>：是为了防止平民（App）瞎搞硬件。</li>\n<li><strong>Root</strong>：是 Ring 3 世界里的皇帝，他可以命令 Ring 0 办事，但他自己依然在墙外。</li>\n<li><strong>破解</strong>：无论是 Root 手机还是破解 Switch，本质都是想方设法<strong>打断信任链的传递</strong>。</li>\n<li><strong>攻防</strong>：Root 之后，是一场利用“平行宇宙”（Namespace）欺骗 App 的猫鼠游戏。</li>\n</ol>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-31 15:40</span>&nbsp;\n<a href=\"https://www.cnblogs.com/kaiux\">念风零壹</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "AA游戏脚本规范（AA Game Script）",
      "link": "https://www.cnblogs.com/ygluu/p/19550578",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ygluu/p/19550578\" id=\"cb_post_title_url\" title=\"发布于 2026-01-31 15:21\">\n    <span>AA游戏脚本规范（AA Game Script）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<font color=\"#002FA5\">\n<h2 id=\"1-前述\">1 前述</h2>\n<p>中文名：AA游戏脚本（命名无任何含义仅是标识符）<br />\n英文名：AA Game Script<br />\n简  称：AA脚本（AAGS）<br />\n作  者：ygluu（码客）<br />\nWeChat: 48092788</p>\n<p><strong>AA脚本旨为：为游戏提供一种更加简单而又灵活的配置方式</strong>。</p>\n<p><strong>注</strong>：<br />\n1、本人在其他博文中提到的数据名，在本文中统称为变量名，两者等效<br />\n2、本文亦是本人过去博客知识点的系统化总结（相关参考见附录3）<br />\n3、恕作者见识有限，如有雷同纯属巧合，请留言必删之</p>\n<p>附图 条件系统原理：<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<h2 id=\"2-on-do模型\">2 ON-DO模型</h2>\n<p>在游戏开发当中，多数策划配置需求不外乎：当什么条件满足时做什么事情，而游戏有他独有的数据形态从而造就了一种既定模式，所以本文将这种模式抽象为ON-DO模型。<br />\n<strong>ON-DO模型概念词汇</strong>：</p>\n<blockquote style=\"color: rgba(102, 102, 102, 1); border-left-color: rgba(255, 102, 0, 1);\">\nOn：在某种条件达成的时候<br />\nDo：做什么事情<br />\n<br />\nCond：条件表达式，如：(A&gt;10)&amp;(B&lt;0)<br />\nAct：动作表达式，如：A+11;B-10<br />\n</blockquote>\n<p><strong>ON-DO模型三步骤</strong>：<br />\n1、定义变量<br />\n2、完善条件函数和编写条件表达式<br />\n3、完善动作函数和编写动作表达式</p>\n<h2 id=\"3-条件表达式规范\">3 条件表达式规范</h2>\n<p><strong>四则运算</strong>：+ - * /<br />\n<strong>比较运算</strong>：&gt; =&gt; = &lt; &lt;=<br />\n<strong>逻辑运算</strong>：&amp; | and or<br />\n<strong>优先级</strong>：( )<br />\n<strong>变量</strong>: 见附录变量表<br />\n<strong>函数</strong>: 见附录函数库<br />\n<strong>常量</strong>：abc 123 ...<br />\n<strong>消耗动作</strong>(减号)：-<br />\n注：减号表示能够扣减指定的物品或数据，如：玩家等级&gt;=10 &amp; 入场卷-10 &amp; 金币-20</p>\n<p><strong>示例</strong>：</p>\n<blockquote style=\"color: rgba(102, 102, 102, 1); border-left-color: rgba(255, 102, 0, 1);\">\n示例1：日期&gt;=2023-01-01 &amp; 时间&gt;18:00:00 &amp; 事件(进入地图) &amp; 地图(名称，花山)<br />\n示例2：等级&gt;=10 &amp; 金币-10 &amp; 上山卡-20<br />\n示例3：等级&gt;=20 &amp; (金币-30 | 上山卡-30)<br />\n示例4：当前地图=花山 &amp; 杀恶犬&gt;=100<br />\n</blockquote>\n<h2 id=\"4-动作表达式规范\">4 动作表达式规范</h2>\n<p><strong>四则运算</strong>：+ - * /<br />\n<strong>累计运算</strong>：+ - * / += -= *= /=<br />\n<strong>赋值</strong>(等于号或冒号均可)：= :<br />\n<strong>分隔符</strong>(分号)：;<br />\n<strong>优先级</strong>：( )<br />\n<strong>函数</strong>：见附录函数库</p>\n<p><strong>示例</strong>:</p>\n<blockquote style=\"color: rgba(102, 102, 102, 1); border-left-color: rgba(255, 102, 0, 1);\">\n示例1：攻击+100;防御+20<br />\n示例2: 金币+20;灵芝+20<br />\n示例3：消耗(金币:100,银币:200);跳转(南天门,103,304) // 函数参数规范由函数定义<br />\n示例4：奖励(金币:100,银币:200);奖励(1001) // 奖励包里的配置ID<br />\n示例6: 充值=188;事件(充值) // 设置充值变量，触发充值事件<br />\n示例6: 地图=Map.Name;怪物=Mon.Name;怪物类型=红怪;事件(杀怪) // 设置杀怪数据，触发杀怪事件<br />\n</blockquote>\n<h2 id=\"5-流程控制表达式规范活动系统设计规范\">5 流程控制表达式规范（活动系统设计规范）</h2>\n<p>流程控制是ON-DO表达式对组合的文本文件，如：ctrl.aa，默认逐对执行。ON-OR和DO-OR表达式对是或关系，两对或多对时表示任意一对满足即可，单对则还是与关系。<br />\n示例：活动表达式</p>\n<blockquote style=\"color: rgba(102, 102, 102, 1); border-left-color: rgba(255, 102, 0, 1);\">\nName：每日BOSS\n<p>ON: 时间&gt;=18:25<br />\nDO:<br />\n创建地图(花山, 安全地图=1)  // 地图设置为非战斗状态<br />\n刷怪(巨兽, x, y, z)<br />\n入口图标(花山); 跑马灯(巨兽出来捣乱了，快来击杀它吧！)<br />\n聊天(世界频道, 巨兽出来捣乱了，快来击杀它吧！)</p>\n<p>ON: 时间&gt;=18:30<br />\nDO:<br />\n地图变量(花山, 安全地图=0)  // 18:30开始战斗<br />\n跑马灯(巨兽出来捣乱了，快来击杀它吧！)<br />\n聊天(世界频道, 巨兽出来捣乱了，快来击杀它吧！)</p>\n<p>// 如果超时则<br />\nON-OR: 时间&gt;=19:00<br />\nDO-OR: GOTO(清场)</p>\n<p>// 如果死亡则<br />\nON-OR: 死亡怪物=巨兽<br />\nDO-OR: 奖励(金币:100,药水1000);GOTO(清场)</p>\n<p>Label：清场<br />\n// label之后无条件的可以不写表达式, 也可以不写ON:<br />\nON:<br />\nDO: 清场()</p>\n</blockquote>\n<h2 id=\"7-养成线系统设计规范\">7 养成线系统设计规范</h2>\n<p>事实上任务系统是比较复杂的养成线系统，养成线有一个特征是逐级升阶，且养成线一般有属性加成（上线重算）和物品奖励（一次性）。<br />\n用两对ON—DO表达式和一个属性加成表达式描述，用模块名+“等级”作为等级变量，每次升级则自增，如下表所示：<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<h2 id=\"8-变量定义规范\">8 变量定义规范</h2>\n<p>变量表：var.xlsx<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<p><strong>CfgId</strong> : 变量ID，如果不填则使用CfgName计算CRC64，碰撞则提示改名<br />\n<strong>CfgName</strong> : 变量名，用于配置描述，全局唯一<br />\n<strong>ShowName</strong> : 显示名，用于UI等，不填默认等于CfgName<br />\n<strong>Reset</strong> : 重置周期，不同和0表示不重置，1：每日重置，2：每周重置，3：每月重置，4：每年重置<br />\n<strong>Valid</strong> : 有效期，不填表示永久有效，如“10月1~10月7日”表示每年国庆有效<br />\n<strong>Cond</strong> ：条件表达式，非空则系统会依据条件执行Act动作表达式<br />\n<strong>Act</strong> : 动作表达式<br />\n<strong>Init</strong> : 初始值，默认0，整形值有效<br />\n<strong>Min</strong> : 最小值，默认0，整形值有效<br />\n<strong>Max</strong> : 最大值，默认int64的最大值，整形值有效</p>\n<p><strong>注</strong>：<br />\n变量类型有string、int64、obj，无需定义设定，以最后一次赋值的类型为准。</p>\n<h2 id=\"9-函数定义规范\">9 函数定义规范</h2>\n<p>函数名(参数1,参数2,..)<br />\n<strong>注意</strong>：<br />\n1、所有函数默认返回int64，0表示失败，等于布尔值的false<br />\n2、函数参数规范由各函数定义</p>\n<h2 id=\"10-配置表规范\">10 配置表规范</h2>\n<h3 id=\"基础字段类型\">基础字段类型：</h3>\n<p><strong>int</strong> : 64位有符号整形<br />\n<strong>bool</strong> : 布尔型<br />\n<strong>string</strong> : 字符串型<br />\n<strong>Cond</strong> : 条件表达式<br />\n<strong>Act</strong> : 动作表达式</p>\n<h3 id=\"容器字段类型\">容器字段类型：</h3>\n<p><strong>arr</strong> : 数组, 类型由第一个元素的基础字段类型决定，可自嵌套，如：{{1,3},{3,4}}<br />\n<strong>map</strong> : 哈希表key-value键值对，key类型可为int和string，value类型位基本字段类型，可自嵌套和嵌套arr，如：{{a=1,b=2},{a=A,b=B},{a=3,b={1,2,3,4}}}</p>\n<h3 id=\"通用字段名\">通用字段名：</h3>\n<p><strong>CfgId</strong> : int，配置ID，全局唯一，int64可规划好各表的ID分段范围，表内自增，不填则系统默认使用CfgName字段的crc64值，碰撞则提示改名<br />\n如果需要分组设置的，每1万一个ID段，如2组ID：1000010000，3组ID：100001000010000,  即可根据分组信息获取配置内容<br />\n<strong>CfgName</strong> : string，配置名，全局唯一，必填，字符串型<br />\n<strong>CfgType</strong> : int，配置类型，如：药材、货币、武器、服装、红怪、<br />\n<strong>CfgFlag</strong> ：int，配置标志，即CfgType的细分<br />\n<strong>ShowName</strong> : string，显示名称，用于UI多国语言等，不填则默认使用CfgName，如果多国语言使用“/”分隔<br />\n<strong>Prop</strong> : map，该配置对象具有的自身属性，如地图表：{可穿人=false,可穿怪=false}<br />\n<strong>Attr</strong> : map，拥有者获得的属性加成，如物品表：{防御+100,攻击+200}<br />\n<strong>Cond</strong> : Cond，条件表示式<br />\n<strong>Act</strong> : Act，动作表达式，条件达成均执行<br />\n<strong>ActAtrr</strong> : Act，属性加成字段，每次上线获取合并<br />\n<strong>ActOnce</strong> : Act，单次执行的动作表达式，条件达成的时候仅执行一次的</p>\n<p>示例：<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<h2 id=\"11-系统支撑\">11 系统支撑</h2>\n<p>AA脚本的系统支撑实现原理参考附录5《万物皆ID、万事皆事件、万人皆数据》。<br />\n如果你的游戏是用Lua来实现业务逻辑的，可以在设计期使用工具将AA脚本的配置表按接口规范翻译成lua脚本（参考附录5 data-e的lua部分）。<br />\n如果你的游戏是用高级语言开发的，可以根据变量定义在系统启动时解析成使用ID符号识别的程序对象（参考附录5 data-e的golang部分）。</p>\n<h2 id=\"附录1-变量库\">附录1 变量库</h2>\n<p>•时间<br />\n•日期<br />\n•时间日期<br />\n•年<br />\n•月<br />\n•日<br />\n•天<br />\n•星期<br />\n•时<br />\n•分<br />\n•秒<br />\n•地图 // 当前所在地图<br />\n•X // 当前位置X坐标<br />\n•Y // 当前位置Y坐标<br />\n•Z // 当前位置Z坐标<br />\n•充值 // 当前充值变量，亦即最后一次充值</p>\n<p>可自行补充完善中...</p>\n<h2 id=\"附录2-事件库\">附录2 事件库</h2>\n<p>•年 // 时间信息改变<br />\n•月<br />\n•日<br />\n•天<br />\n•星期<br />\n•时<br />\n•分<br />\n•秒<br />\n•上线<br />\n•下线<br />\n•断线<br />\n•进入地图<br />\n•离开地图<br />\n•死亡 // 被对手杀死<br />\n•杀死 // 刚刚杀死一个对手<br />\n•复活<br />\n•走<br />\n•跑<br />\n•跳<br />\n•飞<br />\n•路过 // 从对方x距离走过<br />\n•碰、对话 // 碰到对方、对话<br />\n•踩、穿 // 踩到或穿过对方</p>\n<p>可自行补充完善中...</p>\n<h2 id=\"附录3-条件函数库\">附录3 条件函数库</h2>\n<p>•事件(A,B,...) // 判断事件是否包含所列值<br />\n•消耗(A:100,B:200,...)<br />\n•对方(名字, 伏地魔)、对方(类型, 怪物) // 判断PK对方指定的变量是否等于预期值<br />\n•地图(名字, 南天门)、地图(类型, 天界) // 判断地图指定的变量是否等于预期值</p>\n<p>可自行补充完善中...</p>\n<h2 id=\"附录4-动作函数库\">附录4 动作函数库</h2>\n<p>•事件(A,B,...) // 依次触发所列事件<br />\n•消耗(A:100,B:200,...)<br />\n•奖励(A:100,B:200,...)、奖励(10003) // 调用ID指定的奖励包设定实现<br />\n•刷怪(伏地魔,1,203,235)、刷怪(80001) // 调用ID指定的帅怪设定实现<br />\n•跳转(南天门,304,208)、跳转(南天门,304,208,10)// 指定范围随机<br />\n•复活(南天门,304,208)、复活() // 原地复活<br />\n•走(304,256) // 由原点到目标点<br />\n•跑(304,256)<br />\n•跳(304,256)<br />\n•飞(304,256,503) // 由原点到目标3D点</p>\n<p>可自行补充完善中...</p>\n<h2 id=\"附录-5-相关参考链接\">附录 5 相关参考链接</h2>\n<p>游戏高度可配置化（一）通用数据引擎(data-e)及其在模块化游戏开发中的应用构想图解<br />\n<a href=\"https://blog.csdn.net/guestcode/article/details/139897257\" rel=\"noopener nofollow\" target=\"_blank\">https://blog.csdn.net/guestcode/article/details/139897257</a></p>\n<p>游戏高度可配置化（二）用“模型抽象”化解游戏策划和程序员的江湖恩怨<br />\n<a href=\"https://blog.csdn.net/guestcode/article/details/139897783\" rel=\"noopener nofollow\" target=\"_blank\">https://blog.csdn.net/guestcode/article/details/139897783</a></p>\n<p>游戏工厂：AI（AIGC/ChatGPT）与流程式游戏开发<br />\n<a href=\"https://blog.csdn.net/guestcode/article/details/139898182\" rel=\"noopener nofollow\" target=\"_blank\">https://blog.csdn.net/guestcode/article/details/139898182</a></p>\n<p>浅谈数学模型在UGC/AIGC游戏数值配置调参中的应用(AI智能体)<br />\n<a href=\"https://blog.csdn.net/guestcode/article/details/140398630\" rel=\"noopener nofollow\" target=\"_blank\">https://blog.csdn.net/guestcode/article/details/140398630</a></p>\n<p>【数据中台战略】可配置化数学建模的应用案例图解<br />\n<a href=\"https://blog.csdn.net/guestcode/article/details/127469191\" rel=\"noopener nofollow\" target=\"_blank\">https://blog.csdn.net/guestcode/article/details/127469191</a></p>\n<p>【图解】AIGC时代的游戏抽象设计：万物皆ID、万事皆事件、万人皆数据<br />\n<a href=\"https://www.cnblogs.com/ygluu/p/19117836\" target=\"_blank\">https://www.cnblogs.com/ygluu/p/19117836</a></p>\n<p>注：上述链接中有相关的他站他博链接或帖子</p>\n</font>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-31 15:21</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ygluu\">码客-ygluu</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "以英博云为例介绍集群云服务器的使用",
      "link": "https://www.cnblogs.com/RunfarAI/p/19555772",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/RunfarAI/p/19555772\" id=\"cb_post_title_url\" title=\"发布于 2026-01-30 21:23\">\n    <span>以英博云为例介绍集群云服务器的使用</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">目录</div><ul><li><a href=\"#基本关系\" rel=\"noopener nofollow\">基本关系</a></li><li><a href=\"#开发机使用\" rel=\"noopener nofollow\">开发机使用</a></li><li><a href=\"#开创环境盘\" rel=\"noopener nofollow\">开创环境盘</a></li><li><a href=\"#环境配置\" rel=\"noopener nofollow\">环境配置</a><ul><li><a href=\"#更改conda的环境存放位置\" rel=\"noopener nofollow\">更改conda的环境存放位置</a></li><li><a href=\"#更改pip缓存的存放位置\" rel=\"noopener nofollow\">更改pip缓存的存放位置</a></li></ul></li><li><a href=\"#共享存储卷\" rel=\"noopener nofollow\">共享存储卷</a></li><li><a href=\"#通过huggingface_cli下载模型和数据集\" rel=\"noopener nofollow\">通过huggingface_cli下载模型和数据集</a></li><li><a href=\"#加速访问\" rel=\"noopener nofollow\">加速访问</a><ul><li><a href=\"#hfdaria2\" rel=\"noopener nofollow\">hfd+aria2</a></li><li><a href=\"#一步到位英博云内置加速服务\" rel=\"noopener nofollow\">一步到位——英博云内置加速服务</a></li></ul></li></ul></div><p></p>\n<h1 id=\"基本关系\">基本关系</h1>\n<p>集群下管理着多个开发机，开发机是用户使用计算资源的基本单位。每个集群有自己的共享存储卷、块存储卷以及对象存储卷。不同集群的存储不共享。</p>\n<p>共享存储卷一般存放数据集之类的大型训练数据，可挂载到多个开发机，块存储一般只挂载到一个开发机。对象存储主要是存海量非结构化数据，如图片、音频、视频、文本等。</p>\n<h1 id=\"开发机使用\">开发机使用</h1>\n<p>介绍两种常用的使用方式。方式一，开机后使用开发机自带的Jupyter，即点击JupyterLab。在JupyterLab里可以通过这个按钮上传文件：</p>\n<p><img alt=\"\" src=\"https://yunhdan.github.io/assets/yingboyun1.png\" /></p>\n<p>然后红框左边的按钮是创建新的目录，红框右边是刷新，蓝色加号是打开新的Jupyter页面。</p>\n<p>方式二，用ssh+VSCode连接。在VSCode搜索如下两个插件：</p>\n<p><img alt=\"\" src=\"https://yunhdan.github.io/assets/yingboyun2.png\" /></p>\n<p><img alt=\"\" src=\"https://yunhdan.github.io/assets/yingboyun3.png\" /></p>\n<p>安装完毕后重启VSCode，点击左侧的远程资源管理器打开ssh服务器选择栏：</p>\n<p><img alt=\"\" src=\"https://yunhdan.github.io/assets/yingboyun4.png\" /></p>\n<p>点中加号，增加远程服务器：</p>\n<p><img alt=\"\" src=\"https://yunhdan.github.io/assets/yingboyun5.png\" /></p>\n<p>打开英博云的开发机页面，点击开发机的远程连接，复制登陆方式命令：<br />\n<img alt=\"\" src=\"https://yunhdan.github.io/assets/yingboyun6.png\" /></p>\n<p>粘贴到弹窗：<br />\n<img alt=\"\" src=\"https://yunhdan.github.io/assets/yingboyun7.png\" /></p>\n<p>选择要更新的ssh配置文件，没有就自己创建一个：</p>\n<p><img alt=\"\" src=\"https://yunhdan.github.io/assets/yingboyun8.png\" /></p>\n<p>在弹出的配置页面中配置ssh：</p>\n<p><img alt=\"\" src=\"https://yunhdan.github.io/assets/yingboyun9.png\" /></p>\n<p>Host是远程服务器名字，可以自己取。假如我们复制的ssh登录方式是：<code>ssh -p 39000 root@ssh-cn-huabei1.ebcloud.com</code>，那么HostName就是@后面的内容，Port是ssh - p后面的数字，User是@前面的root。</p>\n<p>保存后退出，点击箭头进入连接：</p>\n<p><img alt=\"\" src=\"https://yunhdan.github.io/assets/yingboyun10.png\" /></p>\n<p>会要求选择远程平台类型，选择Linux，然后会弹出有指纹，点击继续后进入密码输入，复制英博云开发机远程连接的登录密码然后粘贴过去即可连接：</p>\n<p><img alt=\"\" src=\"https://yunhdan.github.io/assets/yingboyun12.png\" /></p>\n<h1 id=\"开创环境盘\">开创环境盘</h1>\n<p>系统盘默认挂载到root目录，进入root目录会看到miniconda3已经安装好，之后conda create的虚拟环境会安装到miniconda3/envs中，pip的缓存也在root目录下。</p>\n<p>然而系统盘只有30G，将来创建更多虚拟环境时，这点空间是肯定不够的。因此推荐将pip缓存以及虚拟环境的位置更改到其他地方。</p>\n<p>我们在英博云开一个块存储卷，专门放置环境：</p>\n<p><img alt=\"\" src=\"https://yunhdan.github.io/assets/yingboyun11.png\" /></p>\n<p>存储空间可以取大些，比如64G、128G。然后到开发机中更改实例配置，下滑到存储配置，在块存储卷中挂载你新开的存储卷，然后挂载路径自定，之后在这个路径放东西就相当于放到这个新盘。</p>\n<blockquote>\n<p>为什么要开一个新盘放环境已经讲清楚了。那么为什么选择块存储卷而不是共享存储卷放置环境？这是因为一个块存储卷只能挂载到一个开发机，也就是说如果你把这个新盘挂载到你的开发机，那么其他开发机就无法再访问这个盘的数据，就能够避免了环境被其他开发机删除的情况，而且允许了不同的开发机有不同的虚拟环境名。</p>\n</blockquote>\n<blockquote>\n<p>如果已经开过一个环境盘，还有空间的话，那就不用再开了，这里是针对新创建机器的。</p>\n</blockquote>\n<h1 id=\"环境配置\">环境配置</h1>\n<h2 id=\"更改conda的环境存放位置\">更改conda的环境存放位置</h2>\n<p>进入根目录下的conda目录（通常叫miniconda3或者anaconda3），在该级目录下找到<code>.condarc</code>这个文件，添加如下内容：</p>\n<pre><code class=\"language-raw\">envs_dirs:\n  - /data/envs\n</code></pre>\n<p>/data/envs是你自定义的存放虚拟环境的位置，一般是在前面新盘的挂载路径下。保存后，以后创建虚拟环境就能自动在这个目录下创建了。同时，你可以把虚拟环境env目录移动到这个自定义的位置，conda也会识别到虚拟环境。</p>\n<p>这样，多个虚拟环境就会安装到块存储卷中，避免了系统盘的臃肿。</p>\n<h2 id=\"更改pip缓存的存放位置\">更改pip缓存的存放位置</h2>\n<p>pip的缓存是全局的，也就是说所有的虚拟环境的pip缓存都将存放到一个地方，一般默认存放到根目录root下的<code>.cache</code>目录下。这时可以通过如下命令更改pip缓存的存放位置：</p>\n<pre><code class=\"language-bash\">pip config set global.cache-dir \"/home/your_path\"\n</code></pre>\n<p>或者进入根目录下的<code>.config/pip</code>目录，找到pip.conf文件，打开可以发现有如下内容：</p>\n<pre><code class=\"language-raw\">[global]\ncache-dir = /data/pip_cache\n</code></pre>\n<p>在cache-dir字段更改为自定义的路径位置即可。</p>\n<p>如果你想恢复默认设置，可以使用以下命令：</p>\n<pre><code class=\"language-bash\">pip config unset global.cache-dir\n</code></pre>\n<blockquote>\n<p>同样，如果之前已经更改过了配置的开发机，就没必要再更改了。</p>\n</blockquote>\n<h1 id=\"共享存储卷\">共享存储卷</h1>\n<p>确保你的开发机做好了共享存储卷的挂载，打开开发机的实例配置，下滑到存储配置：</p>\n<p><img alt=\"\" src=\"https://yunhdan.github.io/assets/yingboyun13.png\" /></p>\n<p>添加共享存储卷后，为其定义挂载路径，这样之后代码和数据集可以放到开发机的这个路径下。</p>\n<p>关于共享存储卷，建议每个人用自己的拼音名来命名自己的文件夹，然后在这个自己的文件夹下放自己的数据，这样便于查找，防止冲突。</p>\n<h1 id=\"通过huggingface_cli下载模型和数据集\">通过huggingface_cli下载模型和数据集</h1>\n<p>除了直接到网页端点击下载按钮之外，还可以在终端用命令行的方式下载数据集和模型。</p>\n<p>首先应该安装huggingface_hub工具：</p>\n<pre><code class=\"language-bash\">pip install -U huggingface_hub\n</code></pre>\n<p>huggingface-cli已经弃用，huggingface-cli已经更新为hf命令。关于hf命令有哪些变化，可以考虑学习这篇文章：<a href=\"https://zhuanlan.zhihu.com/p/663712983?s_r=0%E3%80%82\" rel=\"noopener nofollow\" target=\"_blank\">https://zhuanlan.zhihu.com/p/663712983?s_r=0。</a></p>\n<p>在Windows，你可以依次执行：</p>\n<pre><code class=\"language-bash\">$env:HF_ENDPOINT = \"https://hf-mirror.com\"\nhf download --resume-download [model name] --local-dir [save location]\n</code></pre>\n<p>在括号内替换为具体的内容。model name是huggingface某个仓库具体的名字，比如下面的<code>ShengbinYue/DISC-Law-SFT</code>。save location则是保存到本地的目录名。</p>\n<p><img alt=\"\" src=\"https://yunhdan.github.io/assets/huggingface1.png\" /></p>\n<p>下载数据集的命令则是在前面下载模型的命令增加<code>--repo-type dataset</code>参数。在Linux平台，你可以考虑把执行<code>$env:HF_ENDPOINT = \"https://hf-mirror.com</code>换成执行：</p>\n<pre><code class=\"language-bash\">export HF_ENDPOINT=\"https://hf-mirror.com\"\n</code></pre>\n<blockquote>\n<p>$env:HF_ENDPOINT = \"<a href=\"https://hf-mirror.com\" rel=\"noopener nofollow\" target=\"_blank\">https://hf-mirror.com</a>\" 和 export HF_ENDPOINT=\"<a href=\"https://hf-mirror.com\" rel=\"noopener nofollow\" target=\"_blank\">https://hf-mirror.com</a>\" 的目的就是在于解决国内访问huggingface服务器失败的问题。设置这命令就是提供一个镜像以便更快地访问，这个是官方的镜像，速度快。</p>\n</blockquote>\n<h1 id=\"加速访问\">加速访问</h1>\n<p>如果你发现上面的方法下载速度还是很慢，你可以参考下面的做法。</p>\n<h2 id=\"hfdaria2\">hfd+aria2</h2>\n<p>首先下载hfd和aria2c：</p>\n<pre><code class=\"language-bash\">wget https://hf-mirror.com/hfd/hfd.sh\nchmod a+x hfd.sh\n\nsudo apt-get install aria2\nsudo apt-get install git-lfs\n</code></pre>\n<p>hfd这玩意默认安装到当前路径下。</p>\n<p>设置环境变量：</p>\n<pre><code class=\"language-bash\">export HF_ENDPOINT=https://hf-mirror.com\n</code></pre>\n<p>下载模型/数据集：</p>\n<pre><code class=\"language-bash\">./hfd.sh [model/datasets] --tool aria2c -x 8\n</code></pre>\n<h2 id=\"一步到位英博云内置加速服务\">一步到位——英博云内置加速服务</h2>\n<p>确保安装好了hfd和aria2c，没有就看上面先安装好。</p>\n<p>此时<strong>不</strong>设置环境变量<code>export HF_ENDPOINT=https://hf-mirror.com</code>。在终端输入命令：</p>\n<pre><code class=\"language-bash\">source /public/bin/network_accelerate\n</code></pre>\n<p>这个命令可以在当前终端打开英博云的加速服务，支持访问github、huggingface、wandb等。</p>\n<p>取消加速的命令可参考：</p>\n<pre><code class=\"language-bash\">source /public/bin/network_accelerate_stop\n</code></pre>\n<p>设置了加速后，再输入下载命令：</p>\n<pre><code class=\"language-bash\">./hfd.sh [model/datasets] --tool aria2c -x 8\n</code></pre>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-30 21:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/RunfarAI\">RunfarAI</a>&nbsp;\n阅读(<span id=\"post_view_count\">30</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "stable_baseline3 快速入门(二): 训练自定义游戏，构建Gymnasium训练环境",
      "link": "https://www.cnblogs.com/ClownLMe/p/19554865",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ClownLMe/p/19554865\" id=\"cb_post_title_url\" title=\"发布于 2026-01-30 17:46\">\n    <span>stable_baseline3 快速入门(二): 训练自定义游戏，构建Gymnasium训练环境</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"简介\">简介</h1>\n<p><strong>Gymnasium</strong> 为强化学习提供了一个标准化的API，它定义了 Agent 应该如何观察世界、如何做出动作以及如何获得奖励，不管是游戏，还是工业设备，只需要满足<code>Gymnasium</code>标准都能使用同一套代码进行训练。</p>\n<h1 id=\"认识gymnasium\">认识Gymnasium</h1>\n<p>使用<code>stable_baseline3</code>只需要定义好<code>Gymnasium</code>环境，关注训练的奖励机制，将重点放在业务的开发上而不是复杂的算法。</p>\n<p><strong>Gymnasium</strong>提供了几个核心的api：</p>\n<table>\n<thead>\n<tr>\n<th><strong>方法</strong></th>\n<th><strong>功能</strong></th>\n<th><strong>返回值</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong><code>reset()</code></strong></td>\n<td>将环境重置为初始状态，开始新回合。</td>\n<td><code>obs, info</code></td>\n</tr>\n<tr>\n<td><strong><code>step(action)</code></strong></td>\n<td>环境向前推进一步，执行动作。</td>\n<td><code>obs, reward, terminated, truncated, info</code></td>\n</tr>\n<tr>\n<td><strong><code>render()</code></strong></td>\n<td>可视化环境（根据 <code>render_mode</code> 渲染图像或弹出窗口）。</td>\n<td>视配置而定（通常无或为 <code>np.array</code>）</td>\n</tr>\n<tr>\n<td><strong><code>close()</code></strong></td>\n<td>释放环境资源（关闭窗口、清理内存）。</td>\n<td>无</td>\n</tr>\n</tbody>\n</table>\n<p>其中的各个返回值的含义：</p>\n<ul>\n<li><strong><code>observation</code> (Object)</strong>: 当前状态的描述。例如敌人，玩家的位置，玩家的状态等</li>\n<li><strong><code>reward</code> (Float)</strong>: 上一步动作获得的奖励</li>\n<li><strong><code>terminated</code> (Bool)</strong>: 是否由于<strong>任务逻辑</strong>结束。例如：到达终点、掉进岩浆等</li>\n<li><strong><code>truncated</code> (Bool)</strong>: 是否由于<strong>外部限制</strong>结束。例如：达到最大步数 500 步</li>\n<li><strong><code>info</code> (Dict)</strong>: 辅助诊断信息，模型训练通常不用，用于用户自定义调试或记录额外统计。</li>\n</ul>\n<h1 id=\"手动构建环境\">手动构建环境</h1>\n<h3 id=\"案例\">案例</h3>\n<p>案例描述：利用pygame构建一个简单的游戏，躲避掉落方块，利用构建的奖励机制，进行强化学习。</p>\n<pre><code class=\"language-python\">import gymnasium as gym\nfrom gymnasium import spaces\nimport numpy as np\nimport pygame\nimport random\nimport cv2\nimport os\nfrom stable_baselines3 import PPO\nfrom stable_baselines3.common.callbacks import CheckpointCallback\nfrom stable_baselines3.common.env_checker import check_env\n\nclass MyEnv(gym.Env):\n    def __init__(self, render_mode=None):\n        super(MyEnv, self).__init__()\n\n        #初始化参数\n        self.width = 400\n        self.height = 300\n        self.player_size = 30\n        self.enemy_size = 30\n        self.render_mode = render_mode\n\n        self.action_space = spaces.Discrete(3)\n\n        self.observation_space = spaces.Box(\n            low=0, high=255, shape=(84, 84, 3), dtype=np.uint8\n        )\n\n        pygame.init()\n        if self.render_mode == \"human\":\n            self.screen = pygame.display.set_mode((self.width, self.height))\n        \n        self.canvas = pygame.Surface((self.width, self.height))\n        self.font = pygame.font.SysFont(\"monospace\", 15)\n\n    def reset(self, seed=None, options=None):\n        super().reset(seed=seed)\n\n        self.player_x = self.width // 2 - self.player_size // 2\n        self.player_y = self.height - self.player_size - 10\n        self.enemies = []\n        self.score = 0\n        self.frame_count = 0\n\n        self.current_speed = 5\n        self.spawn_rate = 30\n\n        return self._get_obs(), {}\n\n    def step(self, action):\n        reward = 0\n        terminated = False\n        truncated = False\n\n        move_speed = 8\n        if action == 1 and self.player_x &gt; 0: # \n            self.player_x -= move_speed\n            reward -= 0.05\n\n        if action == 2 and self.player_x &lt; self.width - self.player_size:\n            self.player_x += move_speed\n            reward -= 0.05\n\n        self.frame_count += 1\n\n        level = self.score // 5\n        self.current_speed = 5 + level\n        self.spawn_rate = 30 - level * 2\n        spawn_rate = max(10, 30 - level)\n\n        if self.frame_count &gt;= spawn_rate:\n            self.frame_count = 0\n            enemy_x = random.randint(0, self.width - self.enemy_size)\n            self.enemies.append([enemy_x, 0]) # [x, y]\n\n        for enemy in self.enemies:\n            enemy[1] += self.current_speed\n            \n            player_rect = pygame.Rect(self.player_x, self.player_y, self.player_size, self.player_size)\n            enemy_rect = pygame.Rect(enemy[0], enemy[1], self.enemy_size, self.enemy_size)\n            \n            if player_rect.colliderect(enemy_rect):\n                reward = -10 \n                terminated = True\n\n            elif enemy[1] &gt; self.height:\n                self.enemies.remove(enemy)\n                self.score += 1\n                reward = 1 \n        \n        if not terminated:\n            if self.score &gt; 100:\n                reward += 0.01\n            reward += 0.01\n\n        obs = self._get_obs()\n\n        if self.render_mode == \"human\":\n            self._render_window()\n\n        return obs, reward, terminated, truncated, {}\n\n    def _get_obs(self):\n        self.canvas.fill((0, 0, 0))\n        pygame.draw.rect(self.canvas, (50, 150, 255), (self.player_x, self.player_y, self.player_size, self.player_size))\n        \n        for enemy in self.enemies:\n            pygame.draw.rect(self.canvas, (255, 50, 50), (enemy[0], enemy[1], self.enemy_size, self.enemy_size))\n\n        img_array = pygame.surfarray.array3d(self.canvas)\n        img_array = np.transpose(img_array, (1, 0, 2))\n        obs = cv2.resize(img_array, (84, 84), interpolation=cv2.INTER_AREA)\n\n        return obs.astype(np.uint8)\n\n    def _render_window(self):\n        self.screen.blit(self.canvas, (0, 0))\n        text = self.font.render(f\"Score: {self.score}\", True, (255, 255, 255))\n        self.screen.blit(text, (10, 10))\n        pygame.display.flip()\n\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n\ndef train():\n    log_dir = \"logs/DodgeGame\"\n    os.makedirs(log_dir, exist_ok=True)\n\n    env = MyEnv()\n    check_env(env)\n    print(\"环境检查通过...\")\n\n    model_path = \"models/dodge_ai.zip\"\n    if not os.path.exists(model_path):\n        print(\"🆕 未发现旧模型，从头开始训练...\")\n        model = PPO(\n            \"CnnPolicy\", \n            env, \n            verbose=1,\n            tensorboard_log=log_dir,\n            learning_rate=0.0001,\n            n_steps=4096,\n            batch_size=256,\n            device=\"cuda\")\n        reset_timesteps = True\n    else:\n        print(\"发现旧模型，加载并继续训练...\")\n        model = PPO.load(\n            model_path, \n            env=env,      \n            device=\"cuda\",\n            custom_objects={\"learning_rate\": 0.0001, \"n_steps\": 4096, \"batch_size\": 256}\n        )\n        reset_timesteps = False\n   \n    print(\"开始训练...\")\n\n    model.learn(\n        total_timesteps=50000,\n        reset_num_timesteps=reset_timesteps\n    )\n\n    model.save(\"models/dodge_ai\")\n    print(\"模型已保存！\")\n    env.close()\n\ndef prodict():\n    env = MyEnv(render_mode=\"human\")\n    model = PPO.load(\"models/dodge_ai\", env=env, device=\"cuda\")\n    obs, _ = env.reset()\n\n    while True:\n        action, _states = model.predict(obs, deterministic=True)\n\n        obs, reward, terminated, truncated, info = env.step(action)\n\n        if terminated or truncated:\n            obs, _ = env.reset()\n        \n        pygame.time.Clock().tick(30)\n\nif __name__ == \"__main__\":\n    train()\n\n    prodict()\n\n</code></pre>\n<h3 id=\"代码解析\">代码解析</h3>\n<p>代码流程如下：<br />\n<strong>构建游戏环境-&gt;训练模型-&gt;模型预测</strong><br />\n本篇重点讲构<strong>建游戏环境</strong>，其中的<code>pygame</code>相关代码简略，另外两个流程参考之前文章。</p>\n<h4 id=\"构建游戏环境\">构建游戏环境</h4>\n<h5 id=\"初始化类\">初始化类</h5>\n<p>该类继承<code>gym.Env</code>类</p>\n<pre><code class=\"language-python\">class MyEnv(gym.Env):\n</code></pre>\n<h5 id=\"构造函数__init__\">构造函数__init__</h5>\n<pre><code class=\"language-python\">def __init__(self, render_mode=None):\n        super(MyEnv, self).__init__()\n\n        #初始化参数\n        self.width = 400\n        self.height = 300\n        self.player_size = 30\n        self.enemy_size = 30\n        self.render_mode = render_mode\n\n        self.action_space = spaces.Discrete(3)\n\n        self.observation_space = spaces.Box(\n            low=0, high=255, shape=(84, 84, 3), dtype=np.uint8\n        )\n\n        pygame.init()\n        if self.render_mode == \"human\":\n            self.screen = pygame.display.set_mode((self.width, self.height))\n        \n        self.canvas = pygame.Surface((self.width, self.height))\n        self.font = pygame.font.SysFont(\"monospace\", 15)\n</code></pre>\n<p>在构造函数中，我们主要完成的是声明训练的维度，和输入：</p>\n<ul>\n<li>输入：<code>self.action_space = spaces.Discrete(3)</code>其中的<code>self.action_space</code>是<strong>固定名称的父类变量</strong>。<code>spaces.Discrete(3)</code>声明输入的数量，例如：<code>向左 向右 和 不动</code>3个输入。</li>\n<li>观测维度：<code>self.observation_space</code>也是<strong>固定名称的父类变量</strong>。<code>spaces.Box</code>声明观测维度。</li>\n</ul>\n<pre><code class=\"language-python\">self.observation_space = spaces.Box(\n    low=0, high=255, shape=(84, 84, 3), dtype=np.uint8\n)\n</code></pre>\n<ol>\n<li><code>low</code>：观测参数的最小值</li>\n<li><code>high</code>：观测参数的最大值</li>\n<li><code>shape</code>：声明维度。例如：观测图片<code>shape(高，宽，RGB)</code>，观测一个平面，<code>shape(高,宽)</code></li>\n<li><code>dtype</code>：每个变量类型，这里选<code>np.uint8</code>能够节省训练成本，默认是浮点型的。</li>\n</ol>\n<h5 id=\"任务重置-reset\">任务重置 reset</h5>\n<p>相当于初始化游戏状态，游戏的重新开始。返回的是<strong>观测值</strong>和<strong>状态信息（用于调试日志）</strong></p>\n<pre><code class=\"language-python\">def reset(self, seed=None, options=None):\n        super().reset(seed=seed)\n\n        self.player_x = self.width // 2 - self.player_size // 2\n        self.player_y = self.height - self.player_size - 10\n        self.enemies = []\n        self.score = 0\n        self.frame_count = 0\n\n        self.current_speed = 5\n        self.spawn_rate = 30\n\n        return self._get_obs(), {}\n</code></pre>\n<p><strong>观测值 <code>_get_obs</code>：</strong><br />\n通过<code>pygame</code>画出的画面，然后用<code>opencv</code>进行简单处理：</p>\n<ol>\n<li>转换坐标轴（由于<code>opencv</code>坐标xy轴跟<code>pygame</code>的xy是颠倒的）</li>\n<li>将画面缩放到<code>84 * 84</code>（可以提高训练效率）</li>\n</ol>\n<pre><code class=\"language-python\">def _get_obs(self):\n        self.canvas.fill((0, 0, 0))\n        pygame.draw.rect(self.canvas, (50, 150, 255), (self.player_x, self.player_y, self.player_size, self.player_size))\n        \n        for enemy in self.enemies:\n            pygame.draw.rect(self.canvas, (255, 50, 50), (enemy[0], enemy[1], self.enemy_size, self.enemy_size))\n\n        img_array = pygame.surfarray.array3d(self.canvas)\n        img_array = np.transpose(img_array, (1, 0, 2))\n        obs = cv2.resize(img_array, (84, 84), interpolation=cv2.INTER_AREA)\n\n        return obs.astype(np.uint8)\n</code></pre>\n<h5 id=\"步-step重要\">步 step（重要）</h5>\n<p>这个函数是强化训练的<strong>核心</strong>，规定了在<code>一帧</code>或者<code>一步</code>，我们给AI的分数。<br />\n分数的设置至关重要，这直接决定了训练出来AI的质量<br />\n根据下面代码（大部分都是游戏逻辑），主要讲设置<strong>奖励分数</strong>：</p>\n<ol>\n<li>在AI进行移动时 惩罚 0.05 分</li>\n<li>在AI存活时 奖励 0.01分，游戏分数大于100时 存活奖励 0.02分</li>\n<li>在障碍物完全下落时 奖励 1 分</li>\n<li>在与障碍物碰撞时 惩罚 10 分</li>\n</ol>\n<pre><code class=\"language-python\">def step(self, action):\n        reward = 0\n        terminated = False\n        truncated = False\n\n        move_speed = 8\n        if action == 1 and self.player_x &gt; 0: # \n            self.player_x -= move_speed\n            reward -= 0.05\n\n        if action == 2 and self.player_x &lt; self.width - self.player_size:\n            self.player_x += move_speed\n            reward -= 0.05\n\n        self.frame_count += 1\n\n        level = self.score // 5\n        self.current_speed = 5 + level\n        self.spawn_rate = 30 - level * 2\n        spawn_rate = max(10, 30 - level)\n\n        if self.frame_count &gt;= spawn_rate:\n            self.frame_count = 0\n            enemy_x = random.randint(0, self.width - self.enemy_size)\n            self.enemies.append([enemy_x, 0]) # [x, y]\n\n        for enemy in self.enemies:\n            enemy[1] += self.current_speed\n            \n            player_rect = pygame.Rect(self.player_x, self.player_y, self.player_size, self.player_size)\n            enemy_rect = pygame.Rect(enemy[0], enemy[1], self.enemy_size, self.enemy_size)\n            \n            if player_rect.colliderect(enemy_rect):\n                reward = -10 \n                terminated = True\n\n            elif enemy[1] &gt; self.height:\n                self.enemies.remove(enemy)\n                self.score += 1\n                reward = 1 \n        \n        if not terminated:\n            if self.score &gt; 100:\n                reward += 0.01\n            reward += 0.01\n\n        obs = self._get_obs()\n\n        if self.render_mode == \"human\":\n            self._render_window()\n\n        return obs, reward, terminated, truncated, {}\n</code></pre>\n<h5 id=\"展示游戏画面\">展示游戏画面</h5>\n<p>下面完全是<code>pygame</code>代码，用于显示游戏画面，这里就不解释了。</p>\n<pre><code class=\"language-python\">def _render_window(self):\n        self.screen.blit(self.canvas, (0, 0))\n        text = self.font.render(f\"Score: {self.score}\", True, (255, 255, 255))\n        self.screen.blit(text, (10, 10))\n        pygame.display.flip()\n\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n</code></pre>\n<p><strong>你成功成为了一名调参侠了，快来试试吧！</strong></p>\n<p><strong>如果❤喜欢❤本系列教程，就点个关注吧，后续不定期更新~</strong></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-30 17:46</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ClownLMe\">ClownLMe</a>&nbsp;\n阅读(<span id=\"post_view_count\">36</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "节前巡检，推荐一个redis健康检查工具",
      "link": "https://www.cnblogs.com/sdts/p/19554639",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sdts/p/19554639\" id=\"cb_post_title_url\" title=\"发布于 2026-01-30 17:05\">\n    <span>节前巡检，推荐一个redis健康检查工具</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        redis内存分析工具rdr，支持redis7+\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>马上春节，各位同学都完成节前巡检了吗？今天给大家推荐一个redis内存分析工具</p>\n<p>RDR(redis data Reveal)是一个用于离线分析 redis rdb 文件的工具。通过它，可以快速发现实例中的bigkey，帮助您掌握Key在内存中的占用和分布情况、得知哪些key在无限增长等。能为您的优化操作提供数据支持，帮助您避免因Key倾斜（导致集群内存分布不均）引发的内存不足、性能下降等问题。</p>\n<p>工具开源地址：<a href=\"https://github.com/919927181/rdr\" rel=\"noopener nofollow\" target=\"_blank\" title=\"https://github.com/919927181/rdr\">https://github.com/919927181/rdr</a></p>\n<p dir=\"auto\"><strong>1、功能</strong></p>\n<ul dir=\"auto\">\n<li>统计信息展示（command:show）：以网页形式展示RDB文件的统计报告（例如 Top 300 大Key列表、key名前缀统计分析等）。</li>\n<li>统计信息保存(command:dump2file)：除了在线网页展示外，还可以将统计信息保存到文件。</li>\n<li>获取所有key（command:keys）：从RDB文件中解析出全部键名以及属性信息（数据类型、内存大小、元素数量、过期时间、所属db等），保存到文件，以便自行分析。</li>\n</ul>\n<p dir=\"auto\">备注：如果想知道集合类中最大元素是谁，则保存到文件，LargestKeys&gt;FieldOfLargestElem字段就是。</p>\n<p dir=\"auto\"><strong>2、特点</strong></p>\n<ul dir=\"auto\">\n<li>安全无扰：分析过程完全在 RDB 备份文件上进行，对线上Redis实例零影响。</li>\n<li>使用方便：提供了linux和windows下的可执行文件，不需要安装；一键生成内存健康报告，在线图形化展示更直观。</li>\n<li>高效解析：RDR由golang实现，解析速度比较快，一个10G的rdb文件，用时不到4分钟。</li>\n<li>结果精准：结果反映的是RDB快照生成时刻的精确状态。</li>\n<li>庖丁解牛：深入RDB文件结构与LRU元数据原理，犹如为缓存做了一次精准的“核磁共振”检查。</li>\n</ul>\n<p>&nbsp; 支持redis7+，<strong>支持redis7+</strong>，支持redis rdb 文件版本为 1 &lt;= version &lt;= 12</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>&nbsp;</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-30 17:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sdts\">泰山李工</a>&nbsp;\n阅读(<span id=\"post_view_count\">170</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "2天，我用函数计算 AgentRun 爆改一副赛博朋克眼镜",
      "link": "https://www.cnblogs.com/Serverless/p/19554481",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Serverless/p/19554481\" id=\"cb_post_title_url\" title=\"发布于 2026-01-30 16:47\">\n    <span>2天，我用函数计算&nbsp;AgentRun&nbsp;爆改一副赛博朋克眼镜</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"背景\">背景</h1>\n<p>一年前，我购入了 Meta Ray-ban 眼镜，Meta 对于眼镜本体的开发及 App 更新很快，但由于没有中文支持和开放的SDK 导致对国内用户非常不友好。2025 年 11 月，Meta 终于放出了 Device Access Toolkit 让社区看到了点意思，前两天逛 GitHub 刷到了名为<a href=\"https://github.com/Turbo1123/turbometa-rayban-ai/blob/main/README_EN.md\" rel=\"noopener nofollow\" target=\"_blank\">turbometa-rayban-ai</a> 开源项目，项目作者开发了直连中文 App + 百炼 API，实现了几个支持有趣功能（例如中文多模态对话、卡路里检测等）。</p>\n<p>路都铺好了：能截流、能传图、能搞 AI 交互。看着 Repo 里的调用代码，似乎加一个服务端的功能不是什么难事？正好前段时间刷短视频，看到某地交警配备了那种“黑科技眼镜”，看一眼车牌就能识别是不是违章车，科技瞬间变成人间烟火。当时我就在想：这玩意儿虽然看起来高大上，但核心逻辑不就是 <strong>OCR + 查库 + 规则判断</strong> 吗？</p>\n<table>\n<thead>\n<tr>\n<th>吃灰的 AI 眼镜 -（ ？？？？）-&gt; 交警 Copilot</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n</tr>\n</tbody>\n</table>\n<p>既然有了 turbometa-rayban-ai 解决了样板间问题，我又略懂一些 Agent 架构，<strong>能不能用阿里云函数计算 AgentRun功能，把这个原型给“Hack”出来？</strong></p>\n<h1 id=\"端管云协同框架\">“端管云”协同框架</h1>\n<p>首先我们来梳理一个整体架构图，眼镜本身算力有限，所以我们的策略是：<strong>端侧只负责看，云端负责想与处理。</strong> 我设计了经典的 <strong>“端-管-云”</strong> 三层架构：</p>\n<p>1.<strong>端 (Client)</strong>：<strong>AI 眼镜 + iOS App</strong>。负责“抽帧”和“传图”，做一个无情的传输机器。</p>\n<p>2.<strong>脑 (Brain)</strong>：<strong>阿里云函数计算 AgentRun</strong>。负责思考“今天是单号还是双号？”、“这车是不是VIP？”。</p>\n<p>3.<strong>手 (Tools)</strong>：<strong>阿里云 FC - 函数工具</strong>。负责脏活累活，比如查数据库、写日志。</p>\n<p>整体的数据流向如下：</p>\n<ul>\n<li>看 (See): 眼镜看到车牌 -&gt; 蓝牙传输 -&gt; iOS App。</li>\n<li>(Upload): iOS App 抽帧 -&gt; HTTP POST -&gt; 阿里云函数计算FC。</li>\n<li>想 (Think): FC 注入日期规则 -&gt; AgentRun 思考 -&gt; 决定查库。</li>\n<li>查 (Action): AgentRun 调度 FC 工具 -&gt; 读写数据库 -&gt; 返回结果。</li>\n<li>说 (Speak): AgentRun 生成人性化回复话-&gt; FC 返回 -&gt; iOS 转语音 -&gt; 眼镜播放（规划中，暂未实现）。</li>\n</ul>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h1 id=\"动手让想法照进现实\">动手，让想法照进现实</h1>\n<h2 id=\"客户端开发\">客户端开发</h2>\n<p>在我们的架构设计中，iOS 客户端的角色被设计为一个 “克制的中继”。我们不希望手机成为计算瓶颈，因此端侧只负责 I/O，不负责 AI 推理，这套逻辑确保了端侧的极致轻量化。由于客户端开发不是重点，所以我直接基于 turbometa 项目用 Vibe Coding + XCode 编译缝合了一个转发功能。</p>\n<table>\n<thead>\n<tr>\n<th>架构图</th>\n<th>核心架构与流程逻辑</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img alt=\"image\" class=\"lazyload\" /></td>\n<td>●链路建立：App 通过 turbometa 协议或 SDK 与眼镜建立蓝牙/Wi-Fi 高速通道，实时获取摄像头的画面数据。●抽帧：我们不上传连续视频流，而是每隔 1~2 秒截取一帧画面。直接调VL模型估计吃不消。●云端交互：将筛选出的高清图片进行 Base64 编码，打包当前时间戳（用于 Agent 判断单双号）和 GPS（位置） 信息，发送 HTTP POST 请求直连阿里云 FC 网关。●眼镜播放：一旦收到云端 Agent 返回的 JSON 指令（例如 {\"text\": \"双号限行，拦截\"}），App 立即调用 iOS 原生的 TTS 引擎合成语音，音频流会自动路由回眼镜的开放式扬声器播放。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"服务端开发\">服务端开发</h2>\n<p>服务端有 4 个组件，全部通过阿里云函数计算（FC 构建），分别是：</p>\n<ul>\n<li>\n<p>接入点：负责鉴权并处理客户端调用。Context 注入：计算“今天是单号还是双号”，将这个环境信息（Context）塞入 Prompt，再传给 Agent。</p>\n</li>\n<li>\n<p>AgentRun：核心决策者。它不碰数据库，只负责“想”。判断：“车牌是双号，今天是单号，违规了 -&gt; 应该调用查白名单工具。”</p>\n<ul>\n<li>FunModel（AgentRun 背后模型）：通过阿里云百炼API、调用 Qwen 模型。</li>\n</ul>\n</li>\n<li>\n<p>工具（FC Tools）：连接 RDS (MySQL) 查白名单，连接 SLS 写违章日志。</p>\n<ul>\n<li>log_traffic_all：把车牌、时间等信息记录下来</li>\n<li>query_history：通过车牌查询历史库，过去 7 天、30 天是否有出现</li>\n<li>check_whitelist：查询车牌是否在报备白名单中</li>\n<li>log_illegal：记录日志，后台处理</li>\n</ul>\n</li>\n<li>\n<p>存储层：</p>\n<ul>\n<li>阿里云日志服务（SLS）：用于存储记录数据，开箱即用，几乎无使用成本</li>\n<li>阿里云 RDS（Mysql）：用来存储报备白名单</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h3 id=\"21-函数计算-agentrun\">2.1 函数计算 AgentRun</h3>\n<p>定义“大脑”的逻辑 (Prompt Engineering)我们没有写复杂的 Python 逻辑判断单双号，而是写了一段 <strong>Prompt</strong>。在 AgentRun 里，自然语言就是代码。</p>\n<p><strong>System Prompt 核心片段：</strong></p>\n<pre><code class=\"language-plaintext\">你是一个智能交通管控 Agent。\n当前日期信息：{{current_date_info}} (由网关注入，例如：今天是1号，单号)\n\n处理流程：\n1. 必须执行：先调用 `log_traffic_all` 记录流水。\n2. 规则判断：\n   - 单号日仅允许尾号单数通行；双号日仅允许尾号双数。\n   - 如果满足，直接“放行”。\n3. 违规处理：\n   - 违反单双号规则时，别急着开罚单！\n   - 先调用 `check_whitelist` 查白名单。\n   - 如果没报备，再调用 `query_plate_history` 查查是不是惯犯。\n   - 最后生成简短回复。\n</code></pre>\n<p>逻辑看起来很简单，如果老板明天说“周三改为尾号 3 限行”，我只需要改 Prompt，不用重新部署代码。</p>\n<h3 id=\"22-fc-tool打造手脚\">2.2 FC Tool：打造“手脚”</h3>\n<p>Agent 再聪明也无法直接连数据库。我们用 <strong>FC (Python Runtime)</strong> 封装了几个原子能力工具。</p>\n<p>这里的代码核心是 “只做执行，不带脑子”。</p>\n<pre><code class=\"language-plaintext\"># tools.py (部署在 FC 上)\ndef handler(event, context):\n    # AgentRun 会把要调用的函数名传过来\n    tool_name = json.loads(event).get('function')\n    \n    if tool_name == 'check_whitelist':\n        # 纯粹的 SQL 查询\n        return db.query(\"SELECT count(*) FROM whitelist WHERE plate=%s\", plate)\n        \n    elif tool_name == 'log_illegal_notice':\n        # 写入 SLS 日志服务，甚至把违章照片存进去\n        return sls.put_log(plate, image_base64, \"violation\")\n        \n    # ... 其他工具\n</code></pre>\n<p>我们把这个 FC 函数绑定到 AgentRun 的工具列表里，并在 AgentRun 中选上，Agent 拥有了操作真实世界的能力。</p>\n<h3 id=\"23连接客户端-the-gateway\">2.3连接客户端 (The Gateway)</h3>\n<p>最后，我们需要一个 HTTP 入口来接收 iOS 传来的照片，并把“当前日期”告诉 Agent。</p>\n<pre><code class=\"language-plaintext\"># main.py (入口网关)\ndef handler(event, context):\n    # 1. 算一下今天是单号还是双号\n    is_odd = (datetime.now().day % 2 != 0)\n    date_context = f\"今天是{'单号' if is_odd else '双号'}\"\n    \n    # 2. 组装 Prompt，把图片和日期一起丢给 Agent\n    prompt = f\"{date_context}，请处理这张图片里的车：{image_url}\"\n    \n    # 3. 调用 AgentRun 接口\n    reply = call_agent_run(prompt)\n    \n    # 4. 返回结果\n    return {\"voice_feedback\": reply}\n</code></pre>\n<h1 id=\"灵魂拷问小题大做还是降维打击\">灵魂拷问：小题大做，还是降维打击？</h1>\n<p>可能很多人在问，这么小一个应用，半年前都已经在全国铺开了，有必要再用 Agent架构 + 函数计算（FaaS） 造一遍轮子吗？想了想还真有点区别：</p>\n<h2 id=\"拷问一几行-if-else搞定的事为什么用-agent-架构\">拷问一：几行 if-else搞定的事，为什么用 Agent 架构？</h2>\n<p>你可能会问：“不就是查个车牌吗？我在 Python 里写几行 <code>if-else</code> 不也一样跑？”</p>\n<p>这就到了本项目的精髓所在。用 AgentRun（Agent 架构）取代传统后端逻辑，不仅仅是为了蹭 AI 的热度，而是为了解决现实世界中 <strong>“需求总在变”和“数据总是不完美”</strong> 这两个死穴。相比于传统硬编码（Hard-coding），Agent 方案展现了降维打击般的优势：</p>\n<h3 id=\"逻辑解耦prompt-即业务\">逻辑解耦：Prompt 即业务</h3>\n<p>在传统开发中，业务逻辑是“焊死”在代码里的。一旦交规从“单双号限行”变成“周五尾号 4 和 9 限行”，你得修改代码、重新测试、重新部署上线。</p>\n<p>而在 Agent 架构中，<strong>代码只负责“能力”（查库、写日志），Prompt 负责“逻辑”。举个例子（规则突变），</strong> 明天突然要严查“皮卡车”，禁止皮卡进入。</p>\n<ul>\n<li><strong>传统做法</strong>：改代码，加一个 <code>if vehicle_type == 'pickup'</code>，重新发版。</li>\n<li><strong>Agent 做法</strong>：只需在后台 System Prompt 里加一句话——<em>“注意，从现在起，所有皮卡车一律拦截。”</em> Agent 会自动调用 OCR 识别车型（如果 VLM 支持）并执行拦截逻辑，代码一行不用动。</li>\n</ul>\n<h3 id=\"动态编排省钱又高效\">动态编排：省钱又高效</h3>\n<p>传统代码通常是“流水线”式的：先 OCR -&gt; 再查库 -&gt; 再记日志。不管需不需要，流程都要走一遍。</p>\n<p>Agent 拥有 “自主决策权”，它知道什么时候该省事，什么时候该深究。例如：<strong>来了一辆车，但 OCR 识别结果是一串乱码（可能是树叶遮挡）。</strong></p>\n<ul>\n<li><strong>传统做法</strong>：拿着乱码去数据库 <code>SELECT * FROM ...</code>，浪费一次数据库查询，最后报错。</li>\n<li><strong>Agent 做法</strong>：Agent 看到乱码会思考：<em>“这显然不是一个有效的车牌格式，查库也是浪费时间。”</em> 它会<strong>跳过</strong>查库工具，直接反馈：“车牌模糊，请重拍。” —— <strong>它懂得“止损”。</strong></li>\n</ul>\n<h3 id=\"语义级扩展\">语义级扩展</h3>\n<p>Agent 可以理解复杂的、非结构化的指令。比如：你想找一辆特定的车，但忘了车牌，只记得是“红色的宝马”。</p>\n<ul>\n<li><strong>Agent 做法</strong>：你可以直接对眼镜说：“帮我留意一下红色的宝马。” Agent 会将“红色宝马”这个特征加入到它的<strong>短期记忆</strong>中。当后续图片流中出现红色车身+宝马标时，哪怕你没写专门的“颜色识别代码”，Agent (如果是多模态) 也能理解并触发警报。</li>\n</ul>\n<p>总结一下：传统程序是 “你让它干啥它干啥”<strong>（就算前面是坑也往下跳，抛出异常人工处理）；Agent 架构是</strong>“你告诉它目标，它自己找路”（遇到坑它知道绕过去，甚至还能帮你填上）。对于像交警执法这样充满变数和非标准情况的场景，Agent 才是那个最聪明的“副驾”。</p>\n<h2 id=\"拷问二为什么选-faas\">拷问二：为什么选 FaaS？</h2>\n<p>在设计这套系统时，我毫不犹豫地选择了 <strong>阿里云函数计算 (FC)</strong> 作为后端运行时。这不仅仅是因为我懒得维护服务器，更是因为在 <strong>Agent + IoT</strong> 这种场景下，Serverless 简直是“天选之子”。</p>\n<h3 id=\"极致的抠门艺术\">极致的“抠门”艺术</h3>\n<p>交通场景的流量是极其不均匀的。早晚高峰车水马龙，半夜三更鬼影都没一个。</p>\n<ul>\n<li><strong>传统服务器</strong>：你得按<strong>最高峰</strong>的配置买机器。半夜没车时，CPU 在空转，你的钱在燃烧。</li>\n<li><strong>FaaS 模式</strong>：<strong>有车来才干活，没车来就睡觉。</strong></li>\n</ul>\n<p>当眼镜没传照片时，实例缩容到 0，<strong>一分钱不扣</strong>。当早高峰突然来了 100 辆车，FC 瞬间拉起 100 个实例并行处理。这种“用完即走”的特性，对于我这种钱包不鼓的开发者来说，简直是救命稻草。</p>\n<h3 id=\"tools-as-functions\">Tools as Functions</h3>\n<p>在 Agent 架构中，大模型需要调用各种 Tools（工具）。 你仔细想一下，<strong>一个 Tool 的定义，是不是天生就长得像一个 Function？</strong></p>\n<ul>\n<li><strong>Tool 定义</strong>：输入车牌 -&gt; 查库 -&gt; 输出结果。</li>\n<li><strong>FaaS 定义</strong>：Event Trigger -&gt; Python Handler -&gt; Return JSON。</li>\n</ul>\n<p>这两者是 <strong>1:1 完美映射</strong>的。我不需要在一个庞大的 Spring Boot 或 Django 项目里写一堆接口，我只需要写一个个<strong>独立、原子化</strong>的小函数：<code>check_whitelist</code>、<code>log_to_sls</code>。 Agent 想用哪个，就唤醒哪个。这种类<strong>微服务化</strong>的架构，让给 AI 增加新技能变得异常简单——写个新函数，一挂载，搞定。</p>\n<h3 id=\"胶水-的力量\">“胶水” 的力量</h3>\n<p>AgentRun 只是大脑，数据都在云产品里（RDS, SLS, OSS）。FaaS 就像是强力胶水，它<strong>原生集成</strong>了阿里云的各种 SDK。</p>\n<ul>\n<li>你想存照片？FC 几行代码转存 OSS。</li>\n<li>你想记日志？FC 原生对接 SLS。</li>\n<li>你想发通知？FC 触发短信网关。</li>\n</ul>\n<p><strong>FaaS 屏蔽了底层基础设施的复杂性</strong>，让我能专注于写那几行核心的“胶水代码”，而不是去折腾数据库连接池或者网络配置。﻿如果说 AgentRun 是我请来的 “天才指挥官”<strong>，那 FaaS 就是一支</strong>“特种部队”——平时隐身不花钱，一声令下，千军万马，使命必达。</p>\n<h1 id=\"写在最后\">写在最后</h1>\n<p>借助 Vibe Coding、云计算产品、及 GitHub 开源项目，一个从未写过 IOS 小白解锁了 Meta Ray-Ban 眼镜的开发，构建了一个 “端-管-云” 协同的智能原型：眼镜负责第一视角采集，iOS App 负责抽帧中继，云端 AgentRun 充当“大脑”进行意图理解与决策，指挥 FC 函数 完成查库、违章记录等实操。2天零碎时间，把一副消费级眼镜勉强魔改成“交警副驾”：）</p>\n<p>当然 Demo 只是在 Mock 数据上勉强跑通，离 Production 还是有很大距离，还有很多优化的地方，比如：</p>\n<ul>\n<li>端侧减负：在 iOS 端引入视觉算法检测画面清晰度，模糊帧直接丢弃，大幅节省 5G 上传流量。</li>\n<li>降本提速：在 FC 部署 GPU 版 OCR小模型 做预处理，只将提取后的“车牌文本”传给 Agent，将 Token 消耗降低 90%，速度提升一倍。可以借助 Redis 缓存，把邻近（例如 1 分钟内）车牌去重，减少重复数据和调用。</li>\n<li>完善体验：引入 全链路流式交互 (Streaming TTS)，让 AI 边想边说，将语音反馈的等待感压至毫秒级。</li>\n</ul>\n<p>在开发的过程中，也发现作为微服务、Agent 应用调试工具、注册工具和 Debug 也是挺折腾的，相关建议也正在整理反馈给产品方。等各方体验完善后，我也计划把项目打包成一个 Demo 项目上架，让更多人来体验“科技的人间烟火”。</p>\n<h2 id=\"文中提及产品及项目\">文中提及产品及项目</h2>\n<ol>\n<li>阿里云函数计算 FC：<a href=\"https://www.aliyun.com/product/fc\" rel=\"noopener nofollow\" target=\"_blank\">https://www.aliyun.com/product/fc</a></li>\n<li>函数计算 AgentRun： <a href=\"https://www.aliyun.com/product/fc/agentrun\" rel=\"noopener nofollow\" target=\"_blank\">https://www.aliyun.com/product/fc/agentrun</a></li>\n<li>阿里云百炼大模型服务 (Bailian)： <a href=\"https://www.aliyun.com/product/bailian\" rel=\"noopener nofollow\" target=\"_blank\">https://www.aliyun.com/product/bailian</a></li>\n<li>阿里云日志服务 (SLS)： <a href=\"https://www.aliyun.com/product/sls\" rel=\"noopener nofollow\" target=\"_blank\">https://www.aliyun.com/product/sls</a></li>\n<li>阿里云关系型数据库 (RDS for MySQL)： <a href=\"https://www.aliyun.com/product/rds/mysql\" rel=\"noopener nofollow\" target=\"_blank\">https://www.aliyun.com/product/rds/mysql</a></li>\n<li>阿里云对象存储 (OSS)： <a href=\"https://www.aliyun.com/product/oss\" rel=\"noopener nofollow\" target=\"_blank\">https://www.aliyun.com/product/oss</a></li>\n<li>阿里云云数据库 Redis： <a href=\"https://www.aliyun.com/product/kvstore\" rel=\"noopener nofollow\" target=\"_blank\">https://www.aliyun.com/product/kvstore</a></li>\n<li>turbometa-rayban-ai Github项目：<a href=\"https://github.com/Turbo1123/turbometa-rayban-ai/blob/main/README_EN.md\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/Turbo1123/turbometa-rayban-ai/blob/main/README_EN.md</a></li>\n</ol>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-30 16:47</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Serverless\">Serverless社区</a>&nbsp;\n阅读(<span id=\"post_view_count\">86</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "数据“显微镜”：蜂群图让每个数据点都发声",
      "link": "https://www.cnblogs.com/wang_yb/p/19557785",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wang_yb/p/19557785\" id=\"cb_post_title_url\" title=\"发布于 2026-01-31 14:22\">\n    <span>数据“显微镜”：蜂群图让每个数据点都发声</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>想象一下夏日的花丛中，成群的蜜蜂围绕着花朵忙碌地飞舞。每只蜜蜂都是一个独立的数据点，它们既保持群体聚集的形态，又不会完全重叠在一起。</p>\n<p>这就是<strong>蜂群图</strong>（<code>Swarm Plot</code>）的<strong>核心理念</strong>——在有限的空间内展示所有数据点，让每个点都能被清晰看见。</p>\n<p><strong>蜂群图</strong>是一种特殊的数据可视化图表，它将分类数据与数值数据结合起来，展示数据的分布情况。</p>\n<p>与传统的条形图或箱线图不同，蜂群图不进行任何数据聚合，而是展示每一个原始数据点，避免了信息丢失。</p>\n<h1 id=\"1-蜂群图核心特点\">1. 蜂群图核心特点</h1>\n<p><strong>蜂群图</strong>最巧妙的地方在于它的布局算法。</p>\n<p>当多个数据点具有相似数值时，它们不会简单地重叠在一起，而是像有“排斥力”一样，在垂直方向（或水平方向）上轻微偏移，形成一个类似蜂群的分布。</p>\n<p>比如，下面是<strong>同一组数据</strong>在<strong>散点图</strong>和<strong>蜂群图</strong>中展示的效果。</p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260131142128895-781019092.png\" /></p>\n<p>从中可以看出蜂群图的核心特点有：</p>\n<ol>\n<li><strong>绝不重叠</strong>： 它通过算法检测数据点的重叠情况，一旦发现两个点数值相近，就会自动把它们向水平方向推开。</li>\n<li><strong>保留分布形态</strong>： 散开后的形状，天然形成了一种类似“小提琴”或“山峰”的轮廓，直观地展示了数据的密度。</li>\n<li><strong>参数调整</strong>： 我们可以调整点的大小（marker size）和排列的紧密程度。点越大，视觉冲击力越强，但需要的水平空间也越多。</li>\n</ol>\n<h1 id=\"2-蜂群图-vs-条形图从摘要到细节\">2. 蜂群图 vs. 条形图：从摘要到细节</h1>\n<p><strong>条形图</strong>就像是一份数据摘要报告，它告诉我们每个类别的平均值或总计值，但隐藏了数据内部的分布细节。</p>\n<p>而<strong>蜂群图</strong>则像是一次数据点的全员大会，每个数据点都有发言的机会。</p>\n<p>下面针对同一组数据，我们分别绘制了<strong>条形图</strong>、<strong>箱线图</strong>和<strong>蜂群图</strong>，一起来感受一下它们之间不同的展示效果。</p>\n<pre><code class=\"language-python\"># 生成示例数据\nnp.random.seed(123)\ncategories = [\"产品A\", \"产品B\", \"产品C\", \"产品D\"]\ndata_comparison = []\nfor category in categories:\n    n_points = 40\n    if category == \"产品A\":\n        values = np.random.normal(75, 8, n_points)\n    elif category == \"产品B\":\n        values = np.random.normal(82, 12, n_points)\n    elif category == \"产品C\":\n        values = np.random.normal(65, 5, n_points)\n    else:  # 产品D\n        # 创建一个双峰分布\n        values1 = np.random.normal(55, 6, n_points // 2)\n        values2 = np.random.normal(85, 7, n_points // 2)\n        values = np.concatenate([values1, values2])\n\n    for value in values:\n        data_comparison.append({\"产品\": category, \"用户评分\": value})\n\n# 1. 条形图（平均值）\nmeans = []\nfor category in categories:\n    cat_data = [d[\"用户评分\"] for d in data_comparison if d[\"产品\"] == category]\n    means.append(np.mean(cat_data))\n\nbars = axes[0].bar(\n    categories, means, color=[\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\"]\n)\n\n\n# 在条形上标注平均值\n# 省略...\n\n# 2. 箱线图\nbox_data = []\nfor category in categories:\n    cat_data = [d[\"用户评分\"] for d in data_comparison if d[\"产品\"] == category]\n    box_data.append(cat_data)\n\nboxplot = axes[1].boxplot(\n    box_data, tick_labels=categories, patch_artist=True, boxprops=dict(facecolor=\"lightblue\")\n)\n# 省略...\n\n# 3. 蜂群图\ndata_df = pd.DataFrame(data_comparison)\nsns.swarmplot(\n    x=\"产品\",\n    y=\"用户评分\",\n    hue=\"产品\",\n    data=data_df,\n    ax=axes[2],\n    size=5,\n    palette=\"Set2\",\n    edgecolor=\"black\",\n    linewidth=0.5,\n)\n# 省略...\n\nplt.tight_layout()\nplt.show()\n\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260131142128894-2129735776.png\" /></p>\n<p>绘制蜂群图可以用<code>seaborn</code>这个库中的<code>swarmplot</code>函数。</p>\n<p>从上面的对比可以看出：</p>\n<ul>\n<li><strong>条形图</strong>告诉我们产品D的平均分约为70分</li>\n<li><strong>箱线图</strong>提示产品D的数据分布范围很广</li>\n<li>但只有<strong>蜂群图</strong>清晰地揭示了产品D实际上有两个明显的用户群体：一个低评分群体和一个高评分群体</li>\n</ul>\n<h1 id=\"3-蜂群图-vs-散点图从混乱到有序\">3. 蜂群图 vs. 散点图：从混乱到有序</h1>\n<p>传统<strong>散点图</strong>在处理分类数据时，常常导致数据点大量重叠，形成\"黑团\"，我们无法看清数据点的真实分布。</p>\n<p><strong>蜂群图</strong>通过智能布局算法解决了这个问题。</p>\n<p>下面构造一个不同密度的数据，看看蜂群图和散点图的展示效果。</p>\n<pre><code class=\"language-python\"># 比较散点图与蜂群图的视觉效果\nfig, axes = plt.subplots(1, 2, figsize=(14, 6))\n\n# 生成具有不同密度的数据\nnp.random.seed(42)\ndensity_data = []\ncategories = [\"低密度\", \"中等密度\", \"高密度\"]\nfor i, category in enumerate(categories):\n    n_points = 20 + i * 30  # 不同密度\n    if category == \"低密度\":\n        values = np.random.normal(50, 15, n_points)\n    elif category == \"中等密度\":\n        values = np.random.normal(50, 8, n_points)\n    else:  # 高密度\n        values = np.random.normal(50, 4, n_points)\n\n    for value in values:\n        density_data.append({\"类别\": category, \"数值\": value})\n\n# 左侧：传统散点图\nfor i, category in enumerate(categories):\n    cat_data = [d[\"数值\"] for d in density_data if d[\"类别\"] == category]\n    x_positions = np.full(len(cat_data), i)\n    axes[0].scatter(x_positions, cat_data, alpha=0.6, s=60, label=category)\n\n#省略...\n\n# 右侧：蜂群图\ndensity_data_df = pd.DataFrame(density_data)\nsns.swarmplot(\n    x=\"类别\",\n    y=\"数值\",\n    hue=\"类别\",\n    data=density_data_df,\n    ax=axes[1],\n    size=6,\n    palette=\"coolwarm\",\n    edgecolor=\"black\",\n    linewidth=0.5,\n)\n#省略...\n\nplt.tight_layout()\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260131142128896-1164818687.png\" /></p>\n<p><strong>蜂群图</strong>解决了 <strong>“重叠（Overplotting）”</strong> 的问题。在数据量适中（几百到几千个点）时，它是展示分布密度的最佳选择。</p>\n<h1 id=\"4-蜂群图的适用场景\">4. 蜂群图的适用场景</h1>\n<p><strong>蜂群图</strong>并不是为了取代<strong>条形图</strong>或<strong>散点图</strong>，它有自己的适用场景和局限性。</p>\n<p>适合使用<strong>蜂群图</strong>的场景：</p>\n<ul>\n<li>样本量适中（通常少于几百个点）时，展示完整数据分布</li>\n<li>需要同时看到整体趋势和个体数据点</li>\n<li>数据有多个分类变量，需要比较不同类别分布</li>\n<li>希望发现异常值或特殊模式（如双峰分布）</li>\n</ul>\n<p><font style=\"color: rgba(15, 17, 21, 1);\"></font></p>\n<p><strong>蜂群图</strong>的<strong>局限性</strong>主要有：</p>\n<ol>\n<li>大数据集可能导致图表过于拥挤</li>\n<li>对于非常大规模数据，箱线图或小提琴图可能更合适</li>\n<li>精确的数值比较不如条形图直观</li>\n</ol>\n<h1 id=\"5-总结\">5. 总结</h1>\n<p><strong>蜂群图</strong>就像数据可视化领域的\"显微镜\"，它让我们既能观察到数据的整体分布形态，又能看到每一个数据点的具体位置。</p>\n<p>与只能显示摘要信息的<strong>条形图</strong>和容易产生重叠的<strong>散点图</strong>相比，<strong>蜂群图</strong>在显示中小型数据集的完整分布信息方面具有独特优势。</p>\n<p>在数据可视化实践中，选择正确的图表类型就像选择正确的工具一样重要。</p>\n<p>当下一次你需要展示分类数据的分布时，不妨尝试一下蜂群图，它可能会揭示出你从未注意到的数据秘密。</p>\n<p>文中的完整代码共享在：<a href=\"https://url11.ctfile.com/f/45455611-8639900394-9a109f?p=6872\" rel=\"noopener nofollow\" target=\"_blank\">蜂群图.ipynb</a> (访问密码: 6872)</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-31 14:22</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wang_yb\">wang_yb</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "C++ 封装 C FFI 接口最佳实践：以 Hugging Face Tokenizer 为例",
      "link": "https://www.cnblogs.com/charlee44/p/19557586",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/charlee44/p/19557586\" id=\"cb_post_title_url\" title=\"发布于 2026-01-31 13:36\">\n    <span>C++ 封装 C FFI 接口最佳实践：以 Hugging Face Tokenizer 为例</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        详细介绍了如何通过 Rust 的 C FFI 封装 Hugging Face tokenizers，并在 C++ 中利用 RAII 和智能指针实现安全、简洁、高效的资源管理，最终遵循现代 C++ 的“零法则”完成工业级封装。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"1-引入\">1. 引入</h1>\n<p>在现代 AI 工程中，Hugging Face 的 tokenizers 库已成为分词器的事实标准。不过 Hugging Face 的 tokenizers 是用 Rust 来实现的，官方只提供了 python 和 node 的绑定实现。要实现与 Hugging Face tokenizers 相同的行为，最好的办法就是自己封装 Hugging Face tokenizers 的 C 绑定，从而可以被 C++ / C# / Java 这些高级编程语言调用。</p>\n<h1 id=\"2-封装-c-接口\">2. 封装 C 接口</h1>\n<p>首先要说明的是，要做的不是完整的封装 Hugging Face tokenizers 的 C 的 FFI（Foreign Function Interface）接口，而是封装自己需要的接口就可以了。比如执行分词接口和计算Token的接口：</p>\n<pre><code class=\"language-rust\">use std::ffi::CStr;\nuse std::os::raw::c_char;\nuse tokenizers::{PaddingParams, Tokenizer, TruncationParams};\n\n// === 1. 定义 C 兼容的返回结构体 ===\n#[repr(C)]\npub struct TokenizerResult {\n    pub input_ids: *mut i64,\n    pub attention_mask: *mut i64,\n    pub token_type_ids: *mut i64,\n    pub length: u64,\n}\n\n// === 2. 内部状态：包装 Tokenizer ===\nstruct TokenizerHandle {\n    tokenizer: Tokenizer,     // 用于 encode（带 padding）\n    raw_tokenizer: Tokenizer, // 用于 count（无 padding）\n}\n\n// === 3. 辅助函数：将 Rust Vec 转为 C 可拥有的指针 ===\nfn vec_to_c_ptr(vec: Vec&lt;i64&gt;) -&gt; *mut i64 {\n    let mut boxed = vec.into_boxed_slice();\n    let ptr = boxed.as_mut_ptr();\n    std::mem::forget(boxed); // 防止 Rust 自动释放\n    ptr\n}\n\n// === 4. 创建 tokenizer ===\n#[unsafe(no_mangle)] // 禁用 name mangling，让 C 能找到符号\npub extern \"C\" fn tokenizer_create(tokenizer_json_path: *const c_char) -&gt; *mut std::ffi::c_void {\n    if tokenizer_json_path.is_null() {\n        return std::ptr::null_mut();\n    }\n\n    let path_cstr = unsafe { CStr::from_ptr(tokenizer_json_path) };\n    let path_str = match path_cstr.to_str() {\n        Ok(s) =&gt; s,\n        Err(_) =&gt; return std::ptr::null_mut(),\n    };\n\n    let mut tokenizer = match Tokenizer::from_file(path_str) {\n        Ok(t) =&gt; t,\n        Err(_) =&gt; return std::ptr::null_mut(),\n    };\n\n    // 设置 padding/truncation 到 512（BGE 默认）\n    tokenizer.with_padding(Some(PaddingParams {\n        strategy: tokenizers::PaddingStrategy::Fixed(512),\n        ..Default::default()\n    }));\n\n    if tokenizer\n        .with_truncation(Some(TruncationParams {\n            max_length: 512,\n            ..Default::default()\n        }))\n        .is_err()\n    {\n        return std::ptr::null_mut();\n    }\n\n    let mut raw_tokenizer = tokenizer.clone();\n    raw_tokenizer.with_padding(None);\n    raw_tokenizer.with_truncation(None).ok();\n\n    let handle = TokenizerHandle {\n        tokenizer,\n        raw_tokenizer,\n    };\n    Box::into_raw(Box::new(handle)) as *mut std::ffi::c_void\n}\n\n//计算句子token\n#[unsafe(no_mangle)] // 禁用 name mangling，让 C 能找到符号\npub extern \"C\" fn tokenizer_count(handle: *mut std::ffi::c_void, text: *const c_char) -&gt; u64 {\n    if handle.is_null() || text.is_null() {\n        return 0;\n    }\n\n    let handle_ref = unsafe { &amp;*(handle as *mut TokenizerHandle) };\n\n    let text_cstr = unsafe { CStr::from_ptr(text) };\n    let text_str = match text_cstr.to_str() {\n        Ok(s) =&gt; s,\n        Err(_) =&gt; return 0,\n    };\n\n    match handle_ref.raw_tokenizer.encode(text_str, true) {\n        Ok(encoding) =&gt; encoding.len() as u64,\n        Err(_) =&gt; 0,\n    }\n}\n\n// === 5. 销毁 tokenizer ===\n#[unsafe(no_mangle)]\npub extern \"C\" fn tokenizer_destroy(handle: *mut std::ffi::c_void) {\n    if !handle.is_null() {\n        unsafe {\n            let _ = Box::from_raw(handle as *mut TokenizerHandle);\n            // Drop 自动调用\n        }\n    }\n}\n\n// === 6. 执行分词 ===\n#[unsafe(no_mangle)]\npub extern \"C\" fn tokenizer_encode(\n    handle: *mut std::ffi::c_void,\n    text: *const c_char,\n) -&gt; TokenizerResult {\n    let default_result = TokenizerResult {\n        input_ids: std::ptr::null_mut(),\n        attention_mask: std::ptr::null_mut(),\n        token_type_ids: std::ptr::null_mut(),\n        length: 0,\n    };\n\n    if handle.is_null() || text.is_null() {\n        return default_result;\n    }\n\n    let handle_ref = unsafe { &amp;*(handle as *mut TokenizerHandle) };\n\n    let text_cstr = unsafe { CStr::from_ptr(text) };\n    let text_str = match text_cstr.to_str() {\n        Ok(s) =&gt; s,\n        Err(_) =&gt; return default_result,\n    };\n\n    let encoding = match handle_ref.tokenizer.encode(text_str, true) {\n        Ok(e) =&gt; e,\n        Err(_) =&gt; return default_result,\n    };\n\n    let input_ids: Vec&lt;i64&gt; = encoding.get_ids().iter().map(|&amp;x| x as i64).collect();\n    let attention_mask: Vec&lt;i64&gt; = encoding\n        .get_attention_mask()\n        .iter()\n        .map(|&amp;x| x as i64)\n        .collect();\n    let token_type_ids: Vec&lt;i64&gt; = encoding.get_type_ids().iter().map(|&amp;x| x as i64).collect();\n    // BGE 不需要，但 C++ 代码传了\n    // let token_type_ids: Vec&lt;u32&gt; = vec![0u32; input_ids.len()];\n\n    let len = input_ids.len(); // 应该是 512，但更通用\n\n    TokenizerResult {\n        input_ids: vec_to_c_ptr(input_ids),\n        attention_mask: vec_to_c_ptr(attention_mask),\n        token_type_ids: vec_to_c_ptr(token_type_ids),\n        length: len as u64,\n    }\n}\n\n// === 7. 释放结果内存 ===\n#[unsafe(no_mangle)]\npub extern \"C\" fn tokenizer_result_free(result: TokenizerResult) {\n    if !result.input_ids.is_null() {\n        unsafe {\n            let _ = Vec::from_raw_parts(\n                result.input_ids,\n                result.length as usize,\n                result.length as usize,\n            );\n        }\n    }\n\n    if !result.attention_mask.is_null() {\n        unsafe {\n            let _ = Vec::from_raw_parts(\n                result.attention_mask,\n                result.length as usize,\n                result.length as usize,\n            );\n        }\n    }\n\n    if !result.token_type_ids.is_null() {\n        unsafe {\n            let _ = Vec::from_raw_parts(\n                result.token_type_ids,\n                result.length as usize,\n                result.length as usize,\n            );\n        }\n    }\n}\n</code></pre>\n<p>对应的 C 接口如下：</p>\n<pre><code class=\"language-c\">// tokenizer_result.h\n#pragma once\n\nstruct TokenizerResult {\n  int64_t* input_ids;\n  int64_t* attention_mask;\n  int64_t* token_type_ids;\n  uint64_t length;\n};\n\n#ifdef __cplusplus\nstatic_assert(std::is_standard_layout_v&lt;TokenizerResult&gt; &amp;&amp;\n                  std::is_trivially_copyable_v&lt;TokenizerResult&gt;,\n              \"TokenizerResult must be C ABI compatible\");\n#endif\n</code></pre>\n<pre><code class=\"language-c\">// hf_tokenizer_ffi.h\n#pragma once\n\n#include &lt;stdint.h&gt;\n\n#include \"tokenizer_result.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid* tokenizer_create(const char* tokenizer_json_path);\nvoid tokenizer_destroy(void* handle);\nTokenizerResult tokenizer_encode(void* handle, const char* text);\nuint64_t tokenizer_count(void* handle, const char* text);\nvoid tokenizer_result_free(TokenizerResult result);\n\n#ifdef __cplusplus\n}\n#endif\n</code></pre>\n<p>具体的封装细节笔者就不多说了，因为与本文的主题无关。不过可以稍稍了解一下其中的原理，也就是说，操作系统大多数是由 C 实现的，或者提供了 C 的接口。因此，绝大多数比 C 高级的编程语言都提供了与 C 交互的能力，当然前提是必须得按照 C 得规范组织数据和封装接口。比如这里的<code>struct TokenizerResult</code>就是一个兼容 C 的结构体，<code>#[unsafe(no_mangle)]</code>则表明这是一个 C 语言形式的函数接口。</p>\n<h1 id=\"3-经典-c-封装\">3. 经典 C++ 封装</h1>\n<p>如上接口是一个标准的 C 风格式的接口：将分词器封装成一个 Handle ，也就是俗称的句柄。而后续具体的分词操作就通过这个句柄来进行，包括最后对资源的释放。在 C++ 中，当然也可以直接使用这种形式的接口，不过这样就需要遵循 C 的资源控制规则：资源申请和释放必须成对出现——比如这里的 <code>tokenizer_create</code> 和 <code>tokenizer_destroy</code>。</p>\n<h2 id=\"31-raii-机制\">3.1 RAII 机制</h2>\n<p>不过这样就会有一个问题，过程式的流程中很难保证 <code>tokenizer_create</code> 和 <code>tokenizer_destroy</code> 能够成对调用，例如：</p>\n<pre><code class=\"language-c\">tokenizer_create()\n\nif(...){\n    return;\n}\n\ntokenizer_destroy()\n</code></pre>\n<p>只要在 <code>tokenizer_create</code> 和 <code>tokenizer_destroy</code> 之间出现分支，程序提前返回，就会导致资源没有释放而内存泄漏。为了避免这个问题，就需要在每次 <code>return</code> 之前，都调用 <code>tokenizer_destroy()</code>——这当然是非常不优雅的，既容易忘掉又是冗余代码。</p>\n<p>为了解决这种资源管理难题，C++ 提供了一种强大而优雅的机制：RAII（Resource Acquisition Is Initialization，资源获取即初始化）。它的核心思想是：将资源的生命周期绑定到对象的生命周期上。具体来说，就是利用面向对象的思想，将资源控制的行为封装成一个类对象，并且保证资源在对象构造函数中获取，在析构函数中自动释放。由于 C++ 中栈对象在离开作用域时会自动调用析构函数，在离开作用域时会自动调用析构函数。因此这些资源总是可以被正确释放，从根本上杜绝内存泄漏或资源泄露。例如：</p>\n<pre><code class=\"language-cpp\">Tokenizer tokenizer;\n\n//...操作\n\nif(...){\n    return;\n}\n\n//...更多操作\n</code></pre>\n<h2 id=\"32-拷贝语义\">3.2 拷贝语义</h2>\n<p>复习一下 C++ 面向对象设计的经典五法则（Rule of Five），如果一个类自定义了以下任意一个函数：</p>\n<ol>\n<li>析构函数（Destructor）</li>\n<li>拷贝构造函数（Copy Constructor）</li>\n<li>拷贝赋值运算符（Copy Assignment Operator）</li>\n<li>移动构造函数（Move Constructor）</li>\n<li>移动赋值运算符（Move Assignment Operator）</li>\n</ol>\n<p>那么大概率也需要自定义另外四个函数，或者显式 = default / = delete 来控制行为。很多 C++ 程序员并不理解移动语义，但这并没有关系，我们可以先假定不定义移动构造函数和移动赋值运算符（或者显式 = default），此时移动操作就会退化为拷贝语义的行为。</p>\n<p>而关于拷贝语义，绝大多数 C++ 程序员应该都知道这个问题：当在类对象中管理资源时，编译器生成的默认拷贝行为是“浅拷贝”，可能导致双重释放、内存泄漏等问题，因此需要自定义拷贝构造函数和拷贝赋值运算符来实现“深拷贝”的行为。因此，这个链条就很明确了：因为类中需要定义析构函数，所以需要同时定义拷贝构造函数和拷贝赋值运算符。</p>\n<h2 id=\"33-移动语义\">3.3 移动语义</h2>\n<p>进一步讨论，反正移动语义可以默认，那么是不是只用定义拷贝语义就行了呢？这个要看资源的定义：如果只是管理内存资源，那么这样做是没有问题的，至少是安全的。但是资源管理不仅仅指的是内存资源，还可以是一些文件句柄、网络连接等等。这些资源往往是独占性的，进行深拷贝往往会出现问题。因此就出现了 C++ 11 开始规定的移动语义：可以安全得实现“浅拷贝”的行为。同时还可以解决“深拷贝”的性能问题。</p>\n<p>基于以上的思想，笔者封装的分词器对象如下：</p>\n<pre><code class=\"language-cpp\">// HfTokenizer.h\n#pragma once\n\n#include &lt;string&gt;\n\n#include \"hf_tokenizer_ffi.h\"\n\nnamespace hf {\nclass Tokenizer {\n public:\n  explicit Tokenizer(const std::string&amp; path);\n\n  // 析构函数\n  ~Tokenizer() noexcept;\n\n  // 禁止拷贝\n  Tokenizer(const Tokenizer&amp;) = delete;\n  Tokenizer&amp; operator=(const Tokenizer&amp;) = delete;\n\n  // 移动语义\n  Tokenizer(Tokenizer&amp;&amp; rhs) noexcept;\n  Tokenizer&amp; operator=(Tokenizer&amp;&amp; rhs) noexcept;\n\n  // 其他接口方法\n  // TokenizerResult Encode(const char* text) const;\n  // uint64_t Count(const char* text) const;\n\n private:\n  void* handle;  // 来自 tokenizer_create 的指针\n};\n\n}  // namespace hf\n</code></pre>\n<pre><code class=\"language-cpp\">// HfTokenizer.cpp\n#include \"HfTokenizer.h\"\n\n#include &lt;iostream&gt;\n\nnamespace hf {\nTokenizer::Tokenizer(const std::string&amp; path)\n    : handle(tokenizer_create(path.c_str())) {\n  if (!handle) {\n    throw std::runtime_error(\"Failed to create tokenizer from \" + path);\n  }\n}\n\nTokenizer::~Tokenizer() noexcept {\n  if (handle) {\n    tokenizer_destroy(handle);\n  }\n}\n\n// 移动语义\nTokenizer::Tokenizer(Tokenizer&amp;&amp; rhs) noexcept : handle(rhs.handle) {\n  rhs.handle = nullptr;\n}\n\nTokenizer&amp; Tokenizer::operator=(Tokenizer&amp;&amp; rhs) noexcept {\n  if (this != &amp;rhs) {\n    if (handle) {\n      tokenizer_destroy(handle);\n    }\n    handle = rhs.handle;\n    rhs.handle = nullptr;\n  }\n  return *this;\n}\n\n}  // namespace hf\n</code></pre>\n<p>如前所述，因为封装的是一个句柄，为了避免资源控制的麻烦，就禁止掉拷贝语义：</p>\n<pre><code class=\"language-cpp\">// 禁止拷贝\nTokenizer(const Tokenizer&amp;) = delete;\nTokenizer&amp; operator=(const Tokenizer&amp;) = delete;\n</code></pre>\n<p>进行<code>()</code>拷贝构造或者<code>=</code>赋值构造看起来似乎很简单，其实在代码层层嵌套之后，就可能很难分析出是不是调用了默认的拷贝的行为，比如函数传参、容器操作等等。当然深拷贝的实现也不是性能最优，因此干脆就直接删除掉拷贝构造函数和拷贝赋值运算符。</p>\n<p>没有拷贝语义，那么就需要移动语义来进行传递对象了。其实移动语义没那么难，我们只要把握住一点，移动语义的目的是安全地实现“浅拷贝”。以移动赋值运算符的实现来说，如果要实现如下移动赋值：</p>\n<pre><code class=\"language-cpp\">Tokenizer A();\nTokenizer B();\nB = std::move(A);\n</code></pre>\n<p>就需要以下的行为：</p>\n<ol>\n<li>释放掉B管理的资源。</li>\n<li>将A中的成员“浅拷贝”到B中，让B接管A的资源。</li>\n<li>将A中成员初始化。</li>\n</ol>\n<p>具体实现就是如下所示：</p>\n<pre><code class=\"language-cpp\">Tokenizer&amp; Tokenizer::operator=(Tokenizer&amp;&amp; rhs) noexcept {\n  if (this != &amp;rhs) {\n    if (handle) {\n      tokenizer_destroy(handle);\n    }\n    handle = rhs.handle;\n    rhs.handle = nullptr;\n  }\n  return *this;\n}\n</code></pre>\n<p>移动构造函数就更加简单了，因为B对象在移动构造之前成员并没有初始化：</p>\n<pre><code class=\"language-cpp\">Tokenizer A();\nTokenizer B(std::move(A));\n</code></pre>\n<p>因此可以省略掉释放自身资源的步骤，具体实现也就是如下所示：</p>\n<pre><code class=\"language-cpp\">Tokenizer::Tokenizer(Tokenizer&amp;&amp; rhs) noexcept : handle(rhs.handle) {\n  rhs.handle = nullptr;\n}\n</code></pre>\n<p>最后还有一个问题：A通过移动语义转移到B了，A还能使用吗？不能也没必要使用A了，无论是A对象和B对象其实是一个栈对象（当然内部管理的数据成员可能放在堆上），或者说是一个值对象；这跟引用对象或者地址对象完全不同。移动语义的本质是对象所有权的转移，转移之后原对象中资源所有权就不存在了，即使强行访问，要么访问不到，要么会程序崩溃。</p>\n<h1 id=\"4-高级-c-封装\">4. 高级 C++ 封装</h1>\n<h2 id=\"41-零法则\">4.1 零法则</h2>\n<p>使用 RAII 机制 + 经典五法则来设计一个类对象，还有一个优点，就是使用这个类对象作为数据成员的类，就不用再显式实现析构函数。不用显式实现析构函数，也就意味着不用实现拷贝语义和移动语义，完全可以依赖类对象拷贝和移动的默认行为。举例来说，一个<code>MyResource</code>对象，管理着一段内存 buffer ，它的类定义为：</p>\n<pre><code class=\"language-cpp\">class MyResource {\npublic:\n    // 构造：申请资源\n    MyResource() {\n        data = new int[100];\n    }\n\n    // 析构：释放资源\n    ~MyResource() {\n        delete[] data;\n    }\n\n    // 拷贝构造：深拷贝\n    MyResource(const MyResource&amp; other) {\n        data = new int[100];\n        copy(other.data, other.data + 100, data);\n    }\n\n    // 拷贝赋值\n    MyResource&amp; operator=(const MyResource&amp; other) {\n        if (this != &amp;other) {\n            delete[] data;\n            data = new int[100];\n            copy(other.data, other.data + 100, data);\n        }\n        return *this;\n    }\n\n    // 移动构造：接管资源\n    MyResource(MyResource&amp;&amp; other) noexcept {\n        data = other.data;\n        other.data = nullptr;\n    }\n\n    // 移动赋值\n    MyResource&amp; operator=(MyResource&amp;&amp; other) noexcept {\n        if (this != &amp;other) {\n            delete[] data;\n            data = other.data;\n            other.data = nullptr;\n        }\n        return *this;\n    }\n\nprivate:\n    int* data = nullptr;\n};\n</code></pre>\n<p>但是如果我使用 std 容器<code>vector</code> ，相应的代码就可以简写为：</p>\n<pre><code class=\"language-cpp\">#include &lt;vector&gt;\n\nclass MyResource {\npublic:\n    // 构造：自动分配内存\n    MyResource() : data(100) {}  // vector&lt;int&gt; 自动初始化为 100 个元素\n\n    // ✅ 无需显式定义析构函数\n    // ✅ 无需自定义拷贝构造 / 拷贝赋值\n    // ✅ 无需自定义移动构造 / 移动赋值\n\n    // 编译器自动生成的版本已正确、高效、异常安全\n\nprivate:\n    std::vector&lt;int&gt; data;  // RAII 自动管理内存\n};\n</code></pre>\n<p>这不是因为 <code>vector</code> 使用了什么魔法，而是 <code>vector</code> 本身就是使用了 RAII 机制 + 经典五法则来设计的一个模板类对象！在 <code>MyResource</code> 对象进行拷贝或者移动的时候，作为数据成员，<code>std::vector&lt;int&gt; data</code>也会采取同样的拷贝或者移动的行为，并且默认的、由编译器自动生成的版本就可以正确处理。</p>\n<p>以上这个思想，就是现代 C++ 更推荐的<strong>零法则（Rule of Zero）</strong>：尽量不要手动管理资源，而是使用 RAII 类型让编译器自动生成所有特殊成员函数。而这个 RAII 类型，可以是 std 的任何容器对象、智能指针，也可以是自己按照五法则实现的类对象。</p>\n<h2 id=\"42-智能指针\">4.2 智能指针</h2>\n<p>回到本文引入的问题，如果我的分词器实现不像写拷贝语义和移动语义怎么办呢？毕竟都是样板代码，写不好还容易出问题。此时我们就可以使用智能指针 <code>unique_ptr</code> 。常规意义上，我们都知道智能指针可以在没有任何其他对象引用的情况下自动 <code>delete</code> ，其实智能指针还可以自定义资源的释放行为：</p>\n<pre><code class=\"language-cpp\">#pragma once\n\n#include &lt;memory&gt;\n#include &lt;string&gt;\n\nnamespace hf {\nclass Tokenizer {\n public:\n  explicit Tokenizer(const std::string&amp; path);\n\n  // 编译器自动生成：\n  // - 析构函数\n  // - 移动构造 / 移动赋值\n  // - 禁止拷贝（因为 unique_ptr 不可拷贝）\n\n private:\n  std::unique_ptr&lt;void, void (*)(void*)&gt; handle;\n};\n\n}  // namespace hf\n</code></pre>\n<pre><code class=\"language-cpp\">#include \"HfTokenizer.h\"\n\n#include &lt;stdexcept&gt;\n\n#include \"hf_tokenizer_ffi.h\"\n\nnamespace hf {\n\nstatic void HandleDeleter(void* handle) noexcept {\n  if (handle) {\n    tokenizer_destroy(handle);\n  }\n}\n\nTokenizer::Tokenizer(const std::string&amp; path)\n    : handle(tokenizer_create(path.c_str()), HandleDeleter) {\n  if (!handle) {\n    throw std::runtime_error(\"Failed to create tokenizer from \" + path);\n  }\n}\n\n}  // namespace hf\n</code></pre>\n<p>如上实现所示，函数 <code>HandleDeleter</code> 就是 <code>std::unique_ptr&lt;void, void (*)(void*)&gt; handle</code> 的自定义析构行为，在类对象析构的时候就会自动调用这个函数释放资源。既然资源被智能托管了，那么自然就不用写析构函数；析构函数不用写，那么拷贝构造函数、拷贝赋值运算符、移动构造函数以及移动赋值运算符都可以不用实现，全部可以依赖编译器自动生成。当然，由于 <code>unique_ptr</code> 只能移动不能拷贝，<code>Tokenizer</code>也就只能移动不能拷贝。</p>\n<h1 id=\"5-总结\">5. 总结</h1>\n<p>最后，笔者就给出 C++ 封装 C FFI 接口的完整实现，如下所示：</p>\n<pre><code class=\"language-cpp\">// HfTokenizer.h\n#pragma once\n\n#include &lt;memory&gt;\n#include &lt;string&gt;\n\n#include \"tokenizer_result.h\"\n\nnamespace hf {\nclass Tokenizer {\n public:\n  explicit Tokenizer(const std::string&amp; path);\n\n  // 编译器自动生成：\n  // - 析构函数（调用 Deleter）\n  // - 移动构造 / 移动赋值\n  // - 禁止拷贝（因为 unique_ptr 不可拷贝）\n\n  // 其他接口方法\n  uint64_t Count(const std::string&amp; text) const;\n\n  // 向量化\n  using ResultPtr =\n      std::unique_ptr&lt;TokenizerResult, void (*)(TokenizerResult*)&gt;;\n  ResultPtr Encode(const std::string&amp; text) const;\n\n private:\n  std::unique_ptr&lt;void, void (*)(void*)&gt; handle;\n};\n\n}  // namespace hf\n</code></pre>\n<pre><code class=\"language-cpp\">// HfTokenizer.cpp\n#include \"HfTokenizer.h\"\n\n#include &lt;stdexcept&gt;\n\n#include \"hf_tokenizer_ffi.h\"\n\nnamespace hf {\n\nstatic void HandleDeleter(void* handle) noexcept {\n  if (handle) {\n    tokenizer_destroy(handle);\n  }\n}\n\nstatic void ResultDeleter(TokenizerResult* p) noexcept {\n  if (p) {\n    tokenizer_result_free(*p);\n    delete p;\n  }\n}\n\nTokenizer::Tokenizer(const std::string&amp; path)\n    : handle(tokenizer_create(path.c_str()), HandleDeleter) {\n  if (!handle) {\n    throw std::runtime_error(\"Failed to create tokenizer from \" + path);\n  }\n}\n\nuint64_t Tokenizer::Count(const std::string&amp; text) const {\n  return tokenizer_count(handle.get(), text.c_str());\n}\n\nTokenizer::ResultPtr Tokenizer::Encode(const std::string&amp; text) const {\n  auto result = std::make_unique&lt;TokenizerResult&gt;(\n      tokenizer_encode(handle.get(), text.c_str()));\n  return {result.release(), ResultDeleter};\n};\n\n}  // namespace hf\n</code></pre>\n<p>不仅是句柄，连传递的数据对象笔者都托管给智能指针，从而避免大量写特殊成员函数这些样板代码。不得不说，RAII 的设计思路非常精妙，同时保证了安全性与简洁性，给人一种回归编程原始状态的感觉。所谓“大道至简”，不是代码越繁复就越安全，也不是代码越抽象就越厉害；真正好的代码，是在正确性、可维护性与简洁性之间取得平衡，让资源管理如呼吸般自然，而非负担。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-31 13:36</span>&nbsp;\n<a href=\"https://www.cnblogs.com/charlee44\">charlee44</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "ä¸€å¤©ä¸€ä¸ªPythonåº“ï¼šmarkupsafe - è®©ä½ çš„å­—ç¬¦ä¸²å®‰å…¨åˆä¼˜é›",
      "link": "https://www.cnblogs.com/min2k/p/19557576",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/min2k/p/19557576\" id=\"cb_post_title_url\" title=\"发布于 2026-01-31 13:31\">\n    <span>一天一个Python库：markupsafe - 让你的字符串安全又优雅</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"markupsafe---让你的字符串安全又优雅\">markupsafe - 让你的字符串安全又优雅</h1>\n<h2 id=\"一什么是markupsafe\">一、什么是markupsafe？</h2>\n<p><strong>markupsafe</strong> 是一个用于处理标记语言（如HTML、XML）字符串的 Python 库。<br />\n它可以帮助你：</p>\n<ul>\n<li><strong>安全地转义字符串</strong>：防止跨站脚本（XSS）攻击，特别是当你需要将用户输入显示在网页上时。</li>\n<li><strong>标记安全字符串</strong>：将经过转义或信任的字符串标记为“安全”，避免重复转义，提高效率。</li>\n<li><strong>模板引擎集成</strong>：在像Jinja2这样的模板引擎中，markupsafe扮演了核心角色，确保渲染的HTML内容是安全的。</li>\n</ul>\n<h2 id=\"二应用场景\">二、应用场景</h2>\n<p><strong>markupsafe</strong> 广泛应用于以下实际场景：</p>\n<ul>\n<li><strong>Web开发框架</strong>: 在Flask、Jinja2等Web框架中，用于自动转义模板渲染的输出，防止注入攻击。</li>\n<li><strong>用户生成内容</strong>: 当你的网站允许用户输入并显示内容时（如评论、论坛帖子），markupsafe能确保这些内容在显示时是安全的。</li>\n<li><strong>构建动态HTML/XML</strong>: 在程序中动态生成HTML或XML片段时，需要确保所有插入的数据都经过了正确的转义。</li>\n</ul>\n<h2 id=\"三如何安装\">三、如何安装</h2>\n<ol>\n<li>使用 pip 安装</li>\n</ol>\n<pre><code class=\"language-bash\">pip install markupsafe\n\n# 如果安装慢的话，推荐使用国内镜像源\npip install markupsafe -i https://www.python64.cn/pypi/simple/\n</code></pre>\n<ol start=\"2\">\n<li>使用 <a href=\"https://www.min2k.com/tools/python-run/\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a> 在线运行代码（无需本地安装）</li>\n</ol>\n<h2 id=\"四示例代码\">四、示例代码</h2>\n<p>转义用户输入以防止XSS攻击</p>\n<pre><code class=\"language-python\">from markupsafe import escape, Markup\n\n# 用户输入，可能包含恶意脚本\nuser_input_raw = \"&lt;script&gt;alert('您被攻击了！')&lt;/script&gt;\"\nis_admin = True # 假设有一个条件判断用户是否是管理员\n\n# 使用escape转义用户输入\nsafe_output = escape(user_input_raw)\n\n# 打印转义后的结果\nprint(f\"转义后的内容: {safe_output}\")\n\n# 假设有一些信任的HTML内容，我们不希望它被转义\ntrusted_html = Markup(\"&lt;b&gt;这是加粗的文本&lt;/b&gt;\")\n\n# 如果是管理员，则直接显示原始输入（这里仅为演示，实际应用需极其谨慎）\nif is_admin:\n    print(f\"管理员显示（危险！）：{user_input_raw}\")\nelse:\n    # 否则显示安全的内容\n    print(f\"普通用户显示（安全！）：{safe_output}\")\n\n# 结合使用，Markup标记的内容不会被二次转义\nformatted_output = Markup(f\"&lt;p&gt;Hello, {safe_output}!&lt;/p&gt;\")\nprint(f\"组合后的安全HTML: {formatted_output}\")\n\n# 检查是否是Markup实例\nif isinstance(formatted_output, Markup):\n    print(\"formatted_output 是一个 Markup 实例，已被标记为安全。\")\nelse:\n    print(\"formatted_output 不是 Markup 实例。\")\n</code></pre>\n<p>使用 <a href=\"https://www.min2k.com/tools/python-run/?code=from%20markupsafe%20import%20escape%2C%20Markup%0A%0A%23%20%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%EF%BC%8C%E5%8F%AF%E8%83%BD%E5%8C%85%E5%90%AB%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%0Auser_input_raw%20%3D%20%22%3Cscript%3Ealert%28'%E6%82%A8%E8%A2%AB%E6%94%BB%E5%87%BB%E4%BA%86%EF%BC%81'%29%3C%2Fscript%3E%22%0Ais_admin%20%3D%20True%20%23%20%E5%81%87%E8%AE%BE%E6%9C%89%E4%B8%80%E4%B8%AA%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E7%94%A8%E6%88%B7%E6%98%AF%E5%90%A6%E6%98%AF%E7%AE%A1%E7%90%86%E5%91%98%0A%0A%23%20%E4%BD%BF%E7%94%A8escape%E8%BD%AC%E4%B9%89%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%0Asafe_output%20%3D%20escape%28user_input_raw%29%0A%0A%23%20%E6%89%93%E5%8D%B0%E8%BD%AC%E4%B9%89%E5%90%8E%E7%9A%84%E7%BB%93%E6%9E%9C%0Aprint%28f%22%E8%BD%AC%E4%B9%89%E5%90%8E%E7%9A%84%E5%86%85%E5%AE%B9%3A%20%7Bsafe_output%7D%22%29%0A%0A%23%20%E5%81%87%E8%AE%BE%E6%9C%89%E4%B8%80%E4%BA%9B%E4%BF%A1%E4%BB%BB%E7%9A%84HTML%E5%86%85%E5%AE%B9%EF%BC%8C%E6%88%91%E4%BB%AC%E4%B8%8D%E5%B8%8C%E6%9C%9B%E5%AE%83%E8%A2%AB%E8%BD%AC%E4%B9%89%0Atrusted_html%20%3D%20Markup%28%22%3Cb%3E%E8%BF%99%E6%98%AF%E5%8A%A0%E7%B2%97%E7%9A%84%E6%96%87%E6%9C%AC%3C%2Fb%3E%22%29%0A%0A%23%20%E5%A6%82%E6%9E%9C%E6%98%AF%E7%AE%A1%E7%90%86%E5%91%98%EF%BC%8C%E5%88%99%E7%9B%B4%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%8E%9F%E5%A7%8B%E8%BE%93%E5%85%A5%EF%BC%88%E8%BF%99%E9%87%8C%E4%BB%85%E4%B8%BA%E6%BC%94%E7%A4%BA%EF%BC%8C%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E9%9C%80%E6%9E%81%E5%85%B6%E8%B0%A8%E6%85%8E%EF%BC%89%0Aif%20is_admin%3A%0A%20%20%20%20print%28f%22%E7%AE%A1%E7%90%86%E5%91%98%E6%98%BE%E7%A4%BA%EF%BC%88%E5%8D%B1%E9%99%A9%EF%BC%81%EF%BC%89%EF%BC%9A%7Buser_input_raw%7D%22%29%0Aelse%3A%0A%20%20%20%20%23%20%E5%90%A6%E5%88%99%E6%98%BE%E7%A4%BA%E5%AE%89%E5%85%A8%E7%9A%84%E5%86%85%E5%AE%B9%0A%20%20%20%20print%28f%22%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E6%98%BE%E7%A4%BA%EF%BC%88%E5%AE%89%E5%85%A8%EF%BC%81%EF%BC%89%EF%BC%9A%7Bsafe_output%7D%22%29%0A%0A%23%20%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%EF%BC%8CMarkup%E6%A0%87%E8%AE%B0%E7%9A%84%E5%86%85%E5%AE%B9%E4%B8%8D%E4%BC%9A%E8%A2%AB%E4%BA%8C%E6%AC%A1%E8%BD%AC%E4%B9%89%0Aformatted_output%20%3D%20Markup%28f%22%3Cp%3EHello%2C%20%7Bsafe_output%7D!%3C%2Fp%3E%22%29%0Aprint%28f%22%E7%BB%84%E5%90%88%E5%90%8E%E7%9A%84%E5%AE%89%E5%85%A8HTML%3A%20%7Bformatted_output%7D%22%29%0A%0A%23%20%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E6%98%AFMarkup%E5%AE%9E%E4%BE%8B%0Aif%20isinstance%28formatted_output%2C%20Markup%29%3A%0A%20%20%20%20print%28%22formatted_output%20%E6%98%AF%E4%B8%80%E4%B8%AA%20Markup%20%E5%AE%9E%E4%BE%8B%EF%BC%8C%E5%B7%B2%E8%A2%AB%E6%A0%87%E8%AE%B0%E4%B8%BA%E5%AE%89%E5%85%A8%E3%80%82%22%29%0Aelse%3A%0A%20%20%20%20print%28%22formatted_output%20%E4%B8%8D%E6%98%AF%20Markup%20%E5%AE%9E%E4%BE%8B%E3%80%82%22%29\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a> 在线运行这段代码，结果如下：</p>\n<pre><code class=\"language-text\">转义后的内容: &amp;lt;script&amp;gt;alert(&amp;#39;您被攻击了！&amp;#39;)&amp;lt;/script&amp;gt;\n管理员显示（危险！）：&lt;script&gt;alert('您被攻击了！')&lt;/script&gt;\n组合后的安全HTML: &lt;p&gt;Hello, &amp;lt;script&amp;gt;alert(&amp;#39;您被攻击了！&amp;#39;)&amp;lt;/script&amp;gt;!&lt;/p&gt;\nformatted_output 是一个 Markup 实例，已被标记为安全。\n</code></pre>\n<p>使用 <a href=\"https://www.min2k.com/tools/mermaid/?code=flowchart%20TB%0A%20%20A%5B%E5%BC%80%E5%A7%8B%5D%20--%3E%20B%7B%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%92%8C%E7%AE%A1%E7%90%86%E5%91%98%E7%8A%B6%E6%80%81%7D%3B%0A%20%20B%20--%3E%20C%5B%E4%BD%BF%E7%94%A8escape%E8%BD%AC%E4%B9%89%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%5D%3B%0A%20%20C%20--%3E%20D%5B%E6%89%93%E5%8D%B0%E8%BD%AC%E4%B9%89%E5%90%8E%E7%9A%84%E5%86%85%E5%AE%B9%5D%3B%0A%20%20D%20--%3E%20E%7B%E5%A6%82%E6%9E%9C%20isAdmin%20%E4%B8%BA%20True%3F%7D%3B%0A%20%20E%20--%20%E6%98%AF%20--%3E%20F%5B%E6%89%93%E5%8D%B0%E5%8E%9F%E5%A7%8B%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%20%28%E5%8D%B1%E9%99%A9%29%5D%3B%0A%20%20E%20--%20%E5%90%A6%20--%3E%20G%5B%E6%89%93%E5%8D%B0%E5%AE%89%E5%85%A8%E7%9A%84%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%5D%3B%0A%20%20F%20--%3E%20H%5B%E5%88%9B%E5%BB%BA%E5%AE%89%E5%85%A8%E7%9A%84%20Markup%20%E5%AE%9E%E4%BE%8B%5D%3B%0A%20%20G%20--%3E%20H%3B%0A%20%20H%20--%3E%20I%5B%E6%89%93%E5%8D%B0%E7%BB%84%E5%90%88%E5%90%8E%E7%9A%84%E5%AE%89%E5%85%A8HTML%5D%3B%0A%20%20I%20--%3E%20J%7B%E6%A3%80%E6%9F%A5%20formatted_output%20%E6%98%AF%E5%90%A6%E4%B8%BA%20Markup%20%E5%AE%9E%E4%BE%8B%3F%7D%3B%0A%20%20J%20--%20%E6%98%AF%20--%3E%20K%5B%E6%89%93%E5%8D%B0%E6%98%AF%20Markup%20%E5%AE%9E%E4%BE%8B%5D%3B%0A%20%20J%20--%20%E5%90%A6%20--%3E%20L%5B%E6%89%93%E5%8D%B0%E4%B8%8D%E6%98%AF%20Markup%20%E5%AE%9E%E4%BE%8B%5D%3B%0A%20%20K%20--%3E%20M%5B%E7%BB%93%E6%9D%9F%5D%3B%0A%20%20L%20--%3E%20M%3B\" rel=\"noopener nofollow\" target=\"_blank\">MermaidGo</a> 绘制示例代码的流程图，结果如下：</p>\n<p><img alt=\"MermerGo的markupsafe流程图\" class=\"lazyload\" /></p>\n<h2 id=\"五学习资源\">五、学习资源</h2>\n<ol>\n<li>开源项目：<a href=\"https://github.com/pallets/markupsafe\" rel=\"noopener nofollow\" target=\"_blank\">markupsafe</a></li>\n<li>中文自述：<a href=\"https://www.python64.cn/readme/markupsafe/\" rel=\"noopener nofollow\" target=\"_blank\">REMDME</a></li>\n<li>在线运行：<a href=\"https://www.min2k.com/tools/python-run/\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a></li>\n</ol>\n<blockquote>\n<p>如果这篇文章对你有帮助，欢迎点赞、收藏、转发！<br />\n学习过程中有任何问题，欢迎在评论区留言交流～</p>\n</blockquote>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-31 13:31</span>&nbsp;\n<a href=\"https://www.cnblogs.com/min2k\">敏编程</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}