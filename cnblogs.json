{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "2026 年 PHP 的三大优势 这门\"老将\"为何依然重要",
      "link": "https://www.cnblogs.com/catchadmin/p/19454737",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19454737\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 08:16\">\n    <span>2026 年 PHP 的三大优势 这门\"老将\"为何依然重要</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"2026-年-php-的三大优势-这门老将为何依然重要\">2026 年 PHP 的三大优势 这门\"老将\"为何依然重要</h1>\n<p>PHP \"快死了\"这句话喊了这么多年，如果真有来世，它的简历应该已经相当可观了。</p>\n<p>你大概见过这些论调：\"PHP 过时了\"、\"现在没人用 PHP 做正经系统了\"、\"只有老项目还在用\"。这些说法也不算全错——确实有大量遗留 PHP 代码在运行。但还有另一个现实很少被提及：PHP 仍然在驱动大量生产环境的后端系统，新的 PHP 项目也在不断出现，因为团队想要的东西和五年、十年前一样：</p>\n<ul>\n<li>可预测的部署流程</li>\n<li>快速迭代</li>\n<li>成熟的生态</li>\n<li>能够经受多人协作、多年维护的可读代码</li>\n</ul>\n<p>我喜欢这类问题，因为它逼你把话说清楚。不是\"我喜欢用\"，不是\"它很流行\"，而是你在生产代码中能实际指出的工程优势。</p>\n<p>下面是我的回答，写给两类读者：</p>\n<ul>\n<li><strong>如果你刚接触后端开发</strong>：你会得到一个清晰的心智模型，理解 PHP 为何仍然适合 Web 系统。</li>\n<li><strong>如果你经验丰富</strong>：你会看到现代 PHP 实践（类型、静态分析、清晰边界、务实的 API 模式）如何把\"PHP 容易上手\"变成\"PHP 可靠\"。</li>\n</ul>\n<p>我会尽量用平实的语言，但不会回避技术细节。真实的系统本来就是技术性的。目标是让这些技术内容变得易懂且实用。</p>\n<p><a href=\"https://catchadmin.com/post/2026-01/php-3-biggest-strengths-2026\" rel=\"noopener nofollow\" target=\"_blank\">原文 2026 年 PHP 的三大优势 这门\"老将\"为何依然重要</a></p>\n<h2 id=\"什么是优势在真实后端工作中的定义\">什么是\"优势\"：在真实后端工作中的定义</h2>\n<p>开发者比较语言时，讨论经常跑偏到性能基准、语法偏好或者互联网文化。但当你在构建 API 或 Web 后端时，\"优势\"通常意味着一些更无聊——也更重要的东西：</p>\n<ul>\n<li>能否快速交付功能而不埋下维护陷阱？</li>\n<li>能否集成数据库、队列和第三方 API 而不从头造轮子？</li>\n<li>能否处理混乱的数据和边缘情况而不把代码变成鬼屋？</li>\n</ul>\n<p>这就是 PHP 最擅长的领域。不是因为它最优雅，而是因为它的形状刚好契合大多数 Web 后端。</p>\n<p>带着这个思路，来看 PHP 在 2026 年的三大优势。</p>\n<h2 id=\"优势一web-原生的生产力php-天然契合-http-世界\">优势一：Web 原生的生产力（PHP 天然契合 HTTP 世界）</h2>\n<p>大多数后端都是 HTTP 机器。这不是比喻，而是日常工作：</p>\n<ul>\n<li>请求进来</li>\n<li>校验并规范化</li>\n<li>调用服务 / 数据库 / 外部 API</li>\n<li>返回 JSON</li>\n<li>记录日志和追踪</li>\n<li>循环</li>\n</ul>\n<p>PHP 的第一个优势是它在这个循环里感觉很自然。你不需要在处理请求之前\"搭建世界\"。PHP 的默认模型就是面向 Web 的，这一点往往被低估了。</p>\n<h3 id=\"经典的-php-执行模型为何仍然有用\">经典的 PHP 执行模型为何仍然有用</h3>\n<p>PHP 传统的请求生命周期很简单：</p>\n<ol>\n<li>开始请求</li>\n<li>运行代码</li>\n<li>返回响应</li>\n<li>结束请求</li>\n</ol>\n<p>然后下一个请求从头开始。</p>\n<p>有人把这当成相对于长驻服务器的劣势，但在实践中它往往是优势：</p>\n<ul>\n<li>内存泄漏不会那么致命，因为进程会回收。</li>\n<li>每个请求天然隔离。</li>\n<li>不太可能意外依赖内存状态。</li>\n<li>调试往往更简单，因为每个请求有清晰的边界。</li>\n</ul>\n<p>你也可以用长驻模式跑 PHP（RoadRunner、Swoole 等），它们在特定场景下确实很好。但经典模型对许多 API 仍然是可靠的默认选择，因为它稳定且对运维友好。</p>\n<h3 id=\"一个纯-php的-api-入口展示基本形态\">一个\"纯 PHP\"的 API 入口（展示基本形态）</h3>\n<p>即使你在生产环境使用 Laravel 或 Symfony（大多数正经应用确实该用），看看 PHP 为何在 Web 工作中高效还是有帮助的。</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\nrequire __DIR__ . '/../vendor/autoload.php';\nheader('Content-Type: application/json; charset=utf-8');\n$method = $_SERVER['REQUEST_METHOD'] ?? 'GET';\n$path = parse_url($_SERVER['REQUEST_URI'] ?? '/', PHP_URL_PATH) ?: '/';\nfunction jsonResponse(array $payload, int $status = 200): void {\n    http_response_code($status);\n    echo json_encode($payload, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);\n    exit;\n}\nfunction readJsonBody(): array {\n    $raw = file_get_contents('php://input') ?: '';\n    $data = json_decode($raw, true);\n    return is_array($data) ? $data : [];\n}\nif ($method === 'GET' &amp;&amp; $path === '/health') {\n    jsonResponse(['ok' =&gt; true, 'time' =&gt; date(DATE_ATOM)]);\n}\nif ($method === 'POST' &amp;&amp; $path === '/users') {\n    $body = readJsonBody();\n    $email = strtolower(trim((string)($body['email'] ?? '')));\n    $name  = trim((string)($body['name'] ?? ''));\n    if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {\n        jsonResponse(['error' =&gt; 'Invalid email'], 422);\n    }\n    if ($name === '') {\n        jsonResponse(['error' =&gt; 'Name is required'], 422);\n    }\n    $id = random_int(1000, 9999);\n    jsonResponse(['id' =&gt; $id, 'email' =&gt; $email, 'name' =&gt; $name], 201);\n}\njsonResponse(['error' =&gt; 'Not found'], 404);\n</code></pre>\n<p>这不是\"最佳实践架构\"，但它演示了核心思想：PHP 的 Web 循环直接且易懂。这就是基础的生产力优势。</p>\n<h3 id=\"快与乱的区别薄-handler真服务\">\"快\"与\"乱\"的区别：薄 handler，真服务</h3>\n<p>PHP 的 Web 生产力要成为长期优势，前提是保持边界清晰。最容易失去这个优势的方式就是把所有东西都塞进控制器。</p>\n<p>一个可扩展的模式：</p>\n<ul>\n<li><strong>Handler / 控制器</strong>：解码请求、调用服务、编码响应</li>\n<li><strong>服务</strong>：业务逻辑 + 编排</li>\n<li><strong>Repository / Client</strong>：存储 + 外部 API 调用</li>\n</ul>\n<p>这是一个与框架无关的小例子：</p>\n<pre><code class=\"language-php\">final class CreateUserHandler\n{\n    public function __construct(\n        private readonly UserService $service\n    ) {}\n    public function __invoke(array $body): array\n    {\n        $input = CreateUserInput::fromArray($body);\n        $user  = $this-&gt;service-&gt;create($input);\n        return UserResource::toArray($user);\n    }\n}\n</code></pre>\n<p>Handler 读起来像一段叙述。这就对了。</p>\n<p>现在服务来做真正的决策：</p>\n<pre><code class=\"language-php\">final class UserService\n{\n    public function __construct(\n        private readonly UserRepository $users\n    ) {}\n    public function create(CreateUserInput $input): User\n    {\n        if ($this-&gt;users-&gt;existsByEmail($input-&gt;email)) {\n            throw new DomainException('Email already registered');\n        }\n        $user = User::register($input-&gt;email, $input-&gt;name);\n        $this-&gt;users-&gt;save($user);\n        return $user;\n    }\n}\n</code></pre>\n<p>这个结构并不花哨，但它能防止代码库在六个月内变成意大利面。</p>\n<h3 id=\"真实世界的-api-工作超时和重试是功能的一部分\">真实世界的 API 工作：超时和重试是功能的一部分</h3>\n<p>PHP 保持实用的一个原因是，做 PHP 后端的团队往往很早就被迫面对 Web 的现实。不是因为 PHP 特殊，而是因为 Web 本身就不宽容。</p>\n<p>如果你调用外部 API 却不设超时、不设重试策略，你就是在埋下未来的事故。</p>\n<p>下面是一个用 Guzzle 写的封装，在生产环境中能正经干活：</p>\n<pre><code class=\"language-php\">use GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\nfinal class ShippingClient\n{\n    private Client $http;\n    public function __construct(string $baseUrl, string $token)\n    {\n        $this-&gt;http = new Client([\n            'base_uri' =&gt; rtrim($baseUrl, '/') . '/',\n            'timeout' =&gt; 3.0,\n            'connect_timeout' =&gt; 1.0,\n            'headers' =&gt; [\n                'Authorization' =&gt; \"Bearer {$token}\",\n                'Accept' =&gt; 'application/json',\n            ],\n        ]);\n    }\n    public function createLabel(array $payload): array\n    {\n        $attempts = 0;\n        while (true) {\n            $attempts++;\n            try {\n                $resp = $this-&gt;http-&gt;post('labels', ['json' =&gt; $payload]);\n                $data = json_decode((string)$resp-&gt;getBody(), true);\n                return is_array($data) ? $data : [];\n            } catch (GuzzleException $e) {\n                if ($attempts &gt;= 3) {\n                    throw new RuntimeException('Shipping API failed after retries', 0, $e);\n                }\n                // small exponential backoff + jitter\n                usleep((int)(100_000 * $attempts) + random_int(0, 50_000));\n            }\n        }\n    }\n}\n</code></pre>\n<p>当互联网本身是你的依赖时，这种代码是必须的——而 PHP 很适应这个场景。</p>\n<p><strong>为什么这是优势一</strong>：PHP 契合 HTTP 工作的形状，让团队能快速构建功能而不用与平台对抗。</p>\n<h2 id=\"优势二生态成熟度composer--框架--标准降低风险\">优势二：生态成熟度（Composer + 框架 + 标准降低风险）</h2>\n<p>PHP 的第二个优势是杠杆。</p>\n<p>很多语言都能做 Web 开发。但能让\"无聊的部分\"以可复用的方式被解决、让团队能招到已经熟悉这些模式的人，这样的成熟生态并不多。</p>\n<p>当你选择 PHP，你选择的不只是语法，还有：</p>\n<ul>\n<li>Composer + Packagist</li>\n<li>Laravel / Symfony（以及其他框架）</li>\n<li>PSR 标准（互操作性）</li>\n<li>稳定的工具链（测试、静态分析、格式化、重构）</li>\n</ul>\n<p>生态的成熟度能降低风险。风险才是真正花钱的地方。</p>\n<h3 id=\"composer让结构化成为常态的安静基石\">Composer：让结构化成为常态的安静基石</h3>\n<p>Composer 不只是依赖管理——它推动你走向模块化的代码库，用自动加载和命名空间。</p>\n<p>一个最小的例子：</p>\n<pre><code class=\"language-json\">{\n  \"require\": {\n    \"php\": \"^8.2\",\n    \"monolog/monolog\": \"^3.0\",\n    \"guzzlehttp/guzzle\": \"^7.0\"\n  },\n  \"autoload\": {\n    \"psr-4\": {\n      \"App\\\\\": \"src/\"\n    }\n  }\n}\n</code></pre>\n<p>一旦你采用 PSR-4 自动加载，你的代码就不再是\"文件\"，而开始变成\"模块\"。这个转变是现代 PHP 比老刻板印象更易维护的重要原因。</p>\n<h3 id=\"框架用无聊的方案解决无聊的问题这正是重点\">框架：用无聊的方案解决无聊的问题（这正是重点）</h3>\n<p>框架可能被过度使用，但\"不用框架\"的做法在应用增长后往往更糟。</p>\n<p>Laravel 和 Symfony 为你不想重新发明的东西提供了可靠的默认方案：</p>\n<ul>\n<li>路由和中间件</li>\n<li>校验和请求处理</li>\n<li>DI 容器模式</li>\n<li>缓存和队列</li>\n<li>数据库迁移</li>\n<li>结构化的错误处理</li>\n</ul>\n<p>大多数生产事故不是来自精妙的业务逻辑，而是来自胶水代码：超时、重试、不一致的校验、部分失败、意外的 payload、不一致的错误响应。</p>\n<p>框架默认方案减少这些事故，因为你建立在已经经历过成千上万个生产系统考验的模式之上。</p>\n<h3 id=\"psr-标准让你的代码不再被锁死\">PSR 标准：让你的代码不再被锁死</h3>\n<p>标准在你集成库或者超出最初决策时最为重要。</p>\n<p>例如：PSR-3 日志。</p>\n<pre><code class=\"language-php\">use Psr\\Log\\LoggerInterface;\nfinal class BillingService\n{\n    public function __construct(private readonly LoggerInterface $logger) {}\n    public function charge(int $userId, int $amountCents): void\n    {\n        $this-&gt;logger-&gt;info('Charge request', [\n            'userId' =&gt; $userId,\n            'amountCents' =&gt; $amountCents,\n        ]);\n        // ...\n    }\n}\n</code></pre>\n<p>这个类不在乎你今天用 Monolog 还是明天换成别的日志库。这种解耦才能让系统演进。</p>\n<h3 id=\"工具链和-2015-年相比现代-php-像换了一门语言\">工具链：和 2015 年相比，现代 PHP 像换了一门语言</h3>\n<p>很多\"PHP 黑\"来自于对老代码库的体验：弱类型、不一致的模式、\"先上线再说\"的文化。</p>\n<p>现代 PHP 团队通常会用一套简单的质量工具链：</p>\n<ul>\n<li>严格类型</li>\n<li>静态分析（PHPStan / Psalm）</li>\n<li>测试（PHPUnit / Pest）</li>\n<li>格式化（PHP-CS-Fixer）</li>\n<li>自动重构（Rector）</li>\n</ul>\n<p>这套组合会改变你写代码的方式。目标不是完美，而是尽早暴露问题，让代码在迭代中保持可读。</p>\n<p>下面是一个小例子，静态分析帮你避免一个运行时 bug：</p>\n<pre><code class=\"language-php\">final class UserRepository\n{\n    public function findByEmail(string $email): User\n    {\n        // DB lookup...\n        return null; // bug\n    }\n}\n</code></pre>\n<p>配置好静态分析后，这会立即被标记出来。</p>\n<p>PHP 的测试也不必很重。一个聚焦的测试可以读起来像文档：</p>\n<pre><code class=\"language-php\">final class MoneyTest extends TestCase\n{\n    public function testItAddsMoneyInSameCurrency(): void\n    {\n        $a = Money::usd(1000);\n        $b = Money::usd(250);\n        $sum = $a-&gt;add($b);\n        $this-&gt;assertSame(1250, $sum-&gt;cents());\n        $this-&gt;assertSame('USD', $sum-&gt;currency());\n    }\n}\n</code></pre>\n<p><strong>为什么这是优势二</strong>：PHP 的生态让你能快速交付并安全构建，因为工具链和惯例都已成熟。</p>\n<h2 id=\"优势三务实的数据管道php-擅长乱进干净出\">优势三：务实的数据管道（PHP 擅长\"乱进、干净出\"）</h2>\n<p>如果你做过一段时间后端，你就知道真相：这份工作就是数据转换。</p>\n<p>请求进来格式奇怪。数据库行取出来格式奇怪。外部 API 返回的是\"差不多是你期望的\"。Webhook 在不方便的时候重试。边缘情况在周五发生。</p>\n<p>PHP 在这类工作上特别强，因为它在两种模式下都很自如：</p>\n<ul>\n<li>快速操作（字符串、数组、JSON）</li>\n<li>结构化代码（DTO、值对象、枚举、readonly 属性）</li>\n</ul>\n<p>为了说明我的意思，来构建一个现实的管道：处理来自支付提供商的 webhook。</p>\n<p>这是一个很好的测试，因为它结合了：</p>\n<ul>\n<li>安全验证</li>\n<li>幂等性（重试）</li>\n<li>载荷规范化</li>\n<li>状态变更</li>\n<li>优雅处理未知事件类型</li>\n</ul>\n<h3 id=\"步骤一保持载荷边界显式化dto-优于原始数组\">步骤一：保持载荷边界显式化（DTO 优于原始数组）</h3>\n<p>数组在边界处没问题，但在整个应用中传递原始数组会变得痛苦。所以：尽早解析，尽早结构化。</p>\n<pre><code class=\"language-php\">final class WebhookEvent\n{\n    public function __construct(\n        public readonly string $id,\n        public readonly string $type,\n        public readonly int $createdAtEpoch,\n        public readonly array $data\n    ) {}\n    public static function fromArray(array $payload): self\n    {\n        return new self(\n            id: (string)($payload['id'] ?? ''),\n            type: (string)($payload['type'] ?? ''),\n            createdAtEpoch: (int)($payload['created_at'] ?? 0),\n            data: is_array($payload['data'] ?? null) ? $payload['data'] : []\n        );\n    }\n}\n</code></pre>\n<p>这是务实的做法：我们依赖的字段用强类型，原始数据留着灵活性，新字段加进来也不会炸。</p>\n<h3 id=\"步骤二验证签名不要信任-json\">步骤二：验证签名（不要\"信任 JSON\"）</h3>\n<pre><code class=\"language-php\">final class WebhookSignatureVerifier\n{\n    public function __construct(private readonly string $secret) {}\n    public function verify(string $rawBody, string $signatureHeader): bool\n    {\n        $expected = hash_hmac('sha256', $rawBody, $this-&gt;secret);\n        return hash_equals($expected, $signatureHeader);\n    }\n}\n</code></pre>\n<p>这里 <code>hash_equals</code> 很重要，用于避免时序攻击。这是个小细节，但这类习惯正是区分业余代码和生产代码的地方。</p>\n<h3 id=\"步骤三幂等性因为-webhook-会重试\">步骤三：幂等性（因为 webhook 会重试）</h3>\n<p>如果你处理同一个事件两次，你可能会：</p>\n<ul>\n<li>重复更新订阅</li>\n<li>重复发送邮件</li>\n<li>重复给账户加款</li>\n</ul>\n<p>所以要存储已处理的事件 ID。</p>\n<pre><code class=\"language-php\">final class WebhookIdempotencyStore\n{\n    public function __construct(private readonly PDO $pdo) {}\n    public function hasProcessed(string $eventId): bool\n    {\n        $stmt = $this-&gt;pdo-&gt;prepare(\"SELECT 1 FROM processed_webhooks WHERE event_id = :id\");\n        $stmt-&gt;execute([':id' =&gt; $eventId]);\n        return (bool)$stmt-&gt;fetchColumn();\n    }\n    public function markProcessed(string $eventId): void\n    {\n        $stmt = $this-&gt;pdo-&gt;prepare(\n            \"INSERT INTO processed_webhooks (event_id, processed_at)\n             VALUES (:id, NOW())\"\n        );\n        $stmt-&gt;execute([':id' =&gt; $eventId]);\n    }\n}\n</code></pre>\n<h3 id=\"步骤四干净地映射事件类型枚举很有帮助\">步骤四：干净地映射事件类型（枚举很有帮助）</h3>\n<pre><code class=\"language-php\">enum PaymentEventType: string\n{\n    case PaymentSucceeded = 'payment.succeeded';\n    case PaymentFailed = 'payment.failed';\n}\n</code></pre>\n<h3 id=\"步骤五用事务型-handler-把它们组合起来\">步骤五：用事务型 handler 把它们组合起来</h3>\n<pre><code class=\"language-php\">final class PaymentWebhookHandler\n{\n    public function __construct(\n        private readonly WebhookSignatureVerifier $verifier,\n        private readonly WebhookIdempotencyStore $idem,\n        private readonly PaymentService $payments,\n        private readonly PDO $pdo\n    ) {}\n    public function handle(string $rawBody, string $signatureHeader): void\n    {\n        if (!$this-&gt;verifier-&gt;verify($rawBody, $signatureHeader)) {\n            throw new RuntimeException('Invalid webhook signature');\n        }\n        $payload = json_decode($rawBody, true);\n        if (!is_array($payload)) {\n            throw new RuntimeException('Invalid JSON');\n        }\n        $event = WebhookEvent::fromArray($payload);\n        if ($event-&gt;id === '' || $event-&gt;type === '') {\n            throw new RuntimeException('Missing event fields');\n        }\n        if ($this-&gt;idem-&gt;hasProcessed($event-&gt;id)) {\n            return; // safe no-op\n        }\n        $this-&gt;pdo-&gt;beginTransaction();\n        try {\n            $this-&gt;dispatch($event);\n            $this-&gt;idem-&gt;markProcessed($event-&gt;id);\n            $this-&gt;pdo-&gt;commit();\n        } catch (Throwable $e) {\n            $this-&gt;pdo-&gt;rollBack();\n            throw $e;\n        }\n    }\n    private function dispatch(WebhookEvent $event): void\n    {\n        $type = PaymentEventType::tryFrom($event-&gt;type);\n        if ($type === null) {\n            // unknown event type: ignore or log\n            return;\n        }\n        $paymentId = (string)($event-&gt;data['payment_id'] ?? '');\n        if ($paymentId === '') return;\n        match ($type) {\n            PaymentEventType::PaymentSucceeded =&gt; $this-&gt;payments-&gt;markSucceeded($paymentId),\n            PaymentEventType::PaymentFailed    =&gt; $this-&gt;payments-&gt;markFailed($paymentId),\n        };\n    }\n}\n</code></pre>\n<p>这是一个干净的管道：</p>\n<ol>\n<li>验证真实性</li>\n<li>解析载荷</li>\n<li>规范化为 DTO</li>\n<li>强制幂等性</li>\n<li>事务</li>\n<li>分发领域动作</li>\n<li>容忍未知事件</li>\n</ol>\n<p>这就是 PHP 擅长的\"Web 现实\"代码：处理那些真正重要的脏活，同时保持可读。</p>\n<p><strong>为什么这是优势三</strong>：大多数后端都是数据管道，而 PHP 在真实世界约束下构建可理解的管道方面很强。</p>\n<h2 id=\"额外内容游标分页的实践深入因为它把三个优势串在一起\">额外内容：游标分页的实践深入（因为它把三个优势串在一起）</h2>\n<p>分页是那种看起来简单、等用户翻到深页才暴露问题的功能。它也是个好例子，能说明 PHP 为何还没过时：它同时涉及 HTTP、SQL 性能和响应设计。</p>\n<h3 id=\"为什么-offset-会伤害你\">为什么 OFFSET 会伤害你</h3>\n<p>Offset 分页（<code>LIMIT 20 OFFSET 100000</code>）迫使数据库扫描并丢弃大量行。在大表上，深页会变慢。</p>\n<p>它在并发写入时也可能不一致：插入/删除可能导致\"窗口\"移动时出现跳过或重复。</p>\n<p>游标分页（keyset/seek）通过使用稳定的排序和代表\"你上次停在哪里\"的游标来避免这些问题。</p>\n<h3 id=\"规则一游标逻辑必须匹配排序方向\">规则一：游标逻辑必须匹配排序方向</h3>\n<p>如果你按最新优先排序：</p>\n<pre><code class=\"language-sql\">ORDER BY created_at DESC, id DESC\n</code></pre>\n<ul>\n<li>下一页应该获取\"更早\"的行</li>\n<li>所以条件用 <code>&lt;</code></li>\n</ul>\n<p>如果你的数据库支持元组比较：</p>\n<pre><code class=\"language-sql\">SELECT id, created_at, total_cents\nFROM orders\nWHERE (created_at, id) &lt; (?, ?)\nORDER BY created_at DESC, id DESC\nLIMIT ?\n</code></pre>\n<p>如果不支持，用显式逻辑：</p>\n<pre><code class=\"language-sql\">SELECT id, created_at, total_cents\nFROM orders\nWHERE created_at &lt; ?\n   OR (created_at = ? AND id &lt; ?)\nORDER BY created_at DESC, id DESC\nLIMIT ?\n</code></pre>\n<h3 id=\"规则二游标应该是不透明的且防篡改\">规则二：游标应该是不透明的且防篡改</h3>\n<p>游标通常是一个类似 <code>(created_at, id)</code> 的对，序列化给客户端。Base64 编码在传输时没问题——但不是安全措施。如果你想防止客户端伪造游标，就签名它。</p>\n<pre><code class=\"language-php\">final class Cursor\n{\n    public function __construct(\n        public readonly string $createdAtIso,\n        public readonly int $id\n    ) {}\n}\nfinal class CursorCodec\n{\n    public function __construct(private readonly string $secret) {}\n    public function encode(Cursor $cursor): string\n    {\n        $json = json_encode([\n            'created_at' =&gt; $cursor-&gt;createdAtIso,\n            'id' =&gt; $cursor-&gt;id\n        ], JSON_UNESCAPED_SLASHES);\n        $b64 = rtrim(strtr(base64_encode($json), '+/', '-_'), '=');\n        $sig = hash_hmac('sha256', $b64, $this-&gt;secret);\n        return $b64 . '.' . $sig;\n    }\n    public function decode(string $token): Cursor\n    {\n        $parts = explode('.', $token, 2);\n        if (count($parts) !== 2) {\n            throw new InvalidArgumentException('Invalid cursor');\n        }\n        [$b64, $sig] = $parts;\n        $expected = hash_hmac('sha256', $b64, $this-&gt;secret);\n        if (!hash_equals($expected, $sig)) {\n            throw new InvalidArgumentException('Cursor signature mismatch');\n        }\n        $json = base64_decode(strtr($b64, '-_', '+/'), true);\n        if ($json === false) {\n            throw new InvalidArgumentException('Invalid cursor encoding');\n        }\n        $data = json_decode($json, true);\n        if (!is_array($data)) {\n            throw new InvalidArgumentException('Invalid cursor payload');\n        }\n        return new Cursor(\n            createdAtIso: (string)($data['created_at'] ?? ''),\n            id: (int)($data['id'] ?? 0)\n        );\n    }\n}\n</code></pre>\n<h3 id=\"repository-方法返回条目--下一个游标\">Repository 方法：返回条目 + 下一个游标</h3>\n<pre><code class=\"language-php\">final class OrderRepository\n{\n    public function __construct(private readonly PDO $pdo) {}\n    /**\n     * @return array{items: list&lt;array&gt;, next: ?Cursor}\n     */\n    public function listPage(?Cursor $after, int $limit): array\n    {\n        $limit = max(1, min($limit, 100));\n        if ($after === null) {\n            $sql = \"SELECT id, created_at, total_cents\n                    FROM orders\n                    ORDER BY created_at DESC, id DESC\n                    LIMIT :limit\";\n            $stmt = $this-&gt;pdo-&gt;prepare($sql);\n            $stmt-&gt;bindValue(':limit', $limit, PDO::PARAM_INT);\n        } else {\n            $sql = \"SELECT id, created_at, total_cents\n                    FROM orders\n                    WHERE created_at &lt; :created_at\n                       OR (created_at = :created_at AND id &lt; :id)\n                    ORDER BY created_at DESC, id DESC\n                    LIMIT :limit\";\n            $stmt = $this-&gt;pdo-&gt;prepare($sql);\n            $stmt-&gt;bindValue(':created_at', $after-&gt;createdAtIso);\n            $stmt-&gt;bindValue(':id', $after-&gt;id, PDO::PARAM_INT);\n            $stmt-&gt;bindValue(':limit', $limit, PDO::PARAM_INT);\n        }\n        $stmt-&gt;execute();\n        $rows = $stmt-&gt;fetchAll(PDO::FETCH_ASSOC);\n        $items = array_map(fn($r) =&gt; [\n            'id' =&gt; (int)$r['id'],\n            'created_at' =&gt; (string)$r['created_at'],\n            'total_cents' =&gt; (int)$r['total_cents'],\n        ], $rows);\n        $next = null;\n        if ($items !== []) {\n            $last = $items[count($items) - 1];\n            $next = new Cursor($last['created_at'], $last['id']);\n        }\n        return ['items' =&gt; $items, 'next' =&gt; $next];\n    }\n}\n</code></pre>\n<p>现在你的 handler 可以解码 <code>after</code>、获取结果、编码 <code>next_cursor</code>——一个横跨 HTTP + SQL + JSON 响应的干净端到端管道。</p>\n<p>这就是实践中的最佳平衡点：PHP 的 Web 原生特性、生态工具和数据处理能力在这里汇合。</p>\n<h2 id=\"php-不是最佳默认选择的场景以及好团队怎么做\">PHP 不是最佳默认选择的场景（以及好团队怎么做）</h2>\n<p>PHP 不是万能的最佳工具：</p>\n<ul>\n<li>CPU 密集型工作负载（视频处理、大规模数值计算）</li>\n<li>将极高并发的 socket 服务器作为默认架构</li>\n<li>要求前后端用同一门语言共享严格类型的组织</li>\n</ul>\n<p>但大多数成功的团队不会把这当成重写一切的理由。他们做的是 Web 一直鼓励的事：组合系统。</p>\n<ul>\n<li>在 PHP 强的地方保留 API 表面。</li>\n<li>把重计算卸载给 worker 或专门的服务。</li>\n<li>用队列处理后台任务。</li>\n<li>在怪罪语言之前先优化数据库查询和缓存。</li>\n</ul>\n<p>这不是什么\"PHP 用户的自我安慰\"，这就是正常的系统设计。</p>\n<h2 id=\"结论\">结论</h2>\n<p>回到最初的问题——PHP 的三大优势：</p>\n<ul>\n<li><strong>Web 原生的生产力</strong>：PHP 天然契合 HTTP 工作，保持构建循环快速。</li>\n<li><strong>生态成熟度</strong>：Composer + 框架 + 标准 + 工具链给你杠杆并降低风险。</li>\n<li><strong>务实的数据管道</strong>：PHP 擅长把混乱的真实世界数据转换成干净、稳定的输出——同时不让代码变得不可读。</li>\n</ul>\n<p>如果你想让 PHP 感觉现代（而不是像那些刻板印象），方法始终如一：</p>\n<ul>\n<li>保持 handler/控制器薄</li>\n<li>用 DTO/值对象建模边界</li>\n<li>把超时、重试和幂等性当作一等功能</li>\n<li>按读取方式建索引（尤其是分页）</li>\n<li>用测试 + 静态分析保护重构</li>\n</ul>\n<p>PHP 不需要追热点。它只要继续做它擅长的事就够了：跑那些实用、好维护、能稳定上线的 Web 系统。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 08:16</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">33</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "LLM | ARC-AGI：有趣的 benchmark",
      "link": "https://www.cnblogs.com/moonout/p/19449723",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/moonout/p/19449723\" id=\"cb_post_title_url\" title=\"发布于 2026-01-07 19:57\">\n    <span>LLM | ARC-AGI：有趣的 benchmark</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        ARC-AGI benchmark 提供了基于视觉网格的谜题，它们是“对于人类简单、对于大模型困难”的问题。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<br />\n<p>ARC-AGI benchmark 提供了基于视觉网格的谜题，这些谜题是“对于人类简单、对于大模型困难”的问题。ARC-AGI 通过评测大模型解决这类问题的能力，来衡量大模型距通用智能的距离。</p>\n<p>每个谜题仅提供少量示例，大模型需要基于这些示例，通过抽象推理，理解谜题的含义。（另一方面，示例较少也意味着训练数据集较少，即，ARC-AGI benchmark 不容易通过专门训练来刷点。）该 benchmark 测试模型识别 pattern 并将其快速应用于新情况的能力。</p>\n<p>ARC-AGI 的主要评估指标是 Pass@2，它衡量模型在两次尝试内生成正确输出的能力。</p>\n<p>示例：</p>\n<p align=\"center\"><img align=\"center\" src=\"https://arcprize.org/media/images/arc-task-grids.jpg\" /></p>\n<p align=\"center\">(ARC-AGI-1)</p>\n<br />\n<p align=\"center\"><img align=\"center\" src=\"https://arcprize.org/media/images/v2-example.png\" /></p>\n<p align=\"center\">(ARC-AGI-2)</p>\n<p>如何解决 ARC-AGI 问题？ARC-AGI 团队在 Kaggle 上发布了相关竞赛，然而，由于训练数据过少，无法训出一个用于解决 ARC-AGI 问题的模型（这个思想也与考察模型通用推理能力的初衷相悖），因此在 2024 年 GPT 等模型兴起之前，基于深度学习的方法并未取得好的结果。</p>\n<p>根据 <a href=\"\" rel=\"noopener nofollow\">ARC Prize 2024: Technical Report</a>，在 2024 年度，ARC-AGI 的求解取得突破，主要使用了以下三种方法：</p>\n<ul>\n<li>深度学习引导的程序合成：利用深度学习模型，特别是专门的代码 LLMs，来生成解决任务的程序，或对搜索程序的过程进行指导。</li>\n<li>直推模型（transductive models）在测试时训练（test-time training，TTT）：在给定的 ARC-AGI 任务规范上对 LLM 进行微调，以便将 LLM 的先验知识重新组合成一个新的模型，适应当前的任务。直推模型指的是，接收输入后直接输出结果，而非输出一个程序。</li>\n<li>将程序合成与直推模型相结合：将上述两种方法合并为一个超级方法，因为据观察，这两种方法擅长解决不同类型的任务。</li>\n</ul>\n<hr />\n<p>ARC-AGI 任务的官网：<a href=\"https://arcprize.org/\" rel=\"noopener nofollow\" target=\"_blank\">https://arcprize.org/</a></p>\n<p>ARC-AGI-1/2/3 ：</p>\n<ul>\n<li><a href=\"https://arcprize.org/arc-agi/1/\" rel=\"noopener nofollow\" target=\"_blank\">https://arcprize.org/arc-agi/1/</a></li>\n<li><a href=\"https://arcprize.org/arc-agi/2/\" rel=\"noopener nofollow\" target=\"_blank\">https://arcprize.org/arc-agi/2/</a></li>\n<li><a href=\"https://arcprize.org/arc-agi/3/\" rel=\"noopener nofollow\" target=\"_blank\">https://arcprize.org/arc-agi/3/</a></li>\n</ul>\n<p>ARC-AGI-1/2 的榜单：<a href=\"https://arcprize.org/leaderboard\" rel=\"noopener nofollow\" target=\"_blank\">https://arcprize.org/leaderboard</a></p>\n<p>ARC Prize 2024: Technical Report：<a href=\"https://arxiv.org/html/2412.04604v1\" rel=\"noopener nofollow\" target=\"_blank\">https://arxiv.org/html/2412.04604v1</a></p>\n<p>相关博客：</p>\n<ul>\n<li>像 AI 写的神秘博客：<a href=\"https://labs.adaline.ai/p/what-is-the-arc-agi-benchmark-and\" rel=\"noopener nofollow\" target=\"_blank\">https://labs.adaline.ai/p/what-is-the-arc-agi-benchmark-and</a></li>\n<li>知乎 · 机器之心 |「压缩即智能」得到实验验证，无需预训练和大量数据就能解决 ARC-AGI 问题：<a href=\"https://zhuanlan.zhihu.com/p/30426666081\" rel=\"noopener nofollow\" target=\"_blank\">https://zhuanlan.zhihu.com/p/30426666081</a></li>\n<li>知乎 | ARC-AGI 测试集对人工智能来说难在哪里？<a href=\"https://www.zhihu.com/question/7955529556/answer/65269819236\" rel=\"noopener nofollow\" target=\"_blank\">https://www.zhihu.com/question/7955529556/answer/65269819236</a></li>\n</ul>\n<br />\n<br />\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-07 19:57</span>&nbsp;\n<a href=\"https://www.cnblogs.com/moonout\">MoonOut</a>&nbsp;\n阅读(<span id=\"post_view_count\">19</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "51单片机__LED相关",
      "link": "https://www.cnblogs.com/WIRO/p/19452806",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/WIRO/p/19452806\" id=\"cb_post_title_url\" title=\"发布于 2026-01-07 16:06\">\n    <span>51单片机__LED相关</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"51单片机__led相关\">51单片机__LED相关</h1>\n<h2 id=\"单片机介绍\">单片机介绍</h2>\n<p>单片机，英文Micro Controller Unit，简称MCU<br />\n内部集成了CPU、RAM、ROM、定时器、中断系统、通讯接口等一系列电脑的常用硬件功能<br />\n单片机的任务是信息采集（依靠传感器）、处理（依靠CPU）和硬件设备（例如电机，LED等）的控制<br />\n单片机跟计算机相比，单片机算是一个袖珍版计算机，一个芯片就能构成完整的计算机系统。但在性能上，与计算机相差甚远，但单片机成本低、体积小、结构简单，在生活和工业控制领域大有所用<br />\n同时，学习使用单片机是了解计算机原理与结构的最佳选择</p>\n<h2 id=\"单片机应用\">单片机应用</h2>\n<p>单片机的使用领域已十分广泛，如智能仪表、实时工控、通讯设备、导航系统、家用电器等。各种产品一旦用上了单片机，就能起到使产品升级换代的功效，常在产品名称前冠以形容词——“智能型”，如智能型洗衣机等。</p>\n<p><img alt=\"image-20260107113142288\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260107160519528-2082922721.png\" /></p>\n<h2 id=\"stc89c52单片机\">STC89C52单片机</h2>\n<p><img alt=\"image-20260107113244328\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260107160519123-1391531477.png\" /></p>\n<p><img alt=\"image-20260107113324739\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260107160519527-1511351430.png\" /></p>\n<p><img alt=\"image-20260107113519962\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260107160519188-402559776.png\" /></p>\n<p><img alt=\"image-20260107113540042\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260107160519297-1849899687.png\" /></p>\n<p><img alt=\"image-20260107113612706\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260107160519274-1889121421.png\" /></p>\n<h2 id=\"开发板原理图和复位单路\">开发板原理图和复位单路</h2>\n<p><img alt=\"image-20260107113715018\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260107160519312-2037859992.png\" /></p>\n<p><img alt=\"image-20260107114043371\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260107160519369-1523164322.png\" /></p>\n<p><img alt=\"image-20260107114127756\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260107160519480-912853277.png\" /></p>\n<h1 id=\"创建工程并实现led控制\">创建工程并实现LED控制</h1>\n<h2 id=\"1点亮led灯\">1）点亮LED灯</h2>\n<p><img alt=\"image-20260107115032547\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260107160519089-1326428079.png\" /></p>\n<p>观察原理图，LED灯低电平点亮，下面开始编写代码：</p>\n<pre><code class=\"language-c\">#include &lt;REGX52.H&gt;\n\nvoid main()\n{\n\tP2 = 0;\n}\n\n// 现象:所有LED灯均被点亮\n</code></pre>\n<h2 id=\"2实现led_1灯闪烁\">2）实现LED_1灯闪烁</h2>\n<p><strong>延时方法与实现：</strong></p>\n<p>通过单片机驱动外围显示电路，为了能够让人眼识别到所显示内容的变化，需要保证所显示的内容有所停留。在单片机中，实现这一效果有两种方式，一种是通过C语言编写一段延时效果的程序或者子程序，实现该目的。另一种是调用单片机自带的定式/计数器，这里暂时使用第一种方式。</p>\n<p>使用单片机烧录软件AiCube-ISP-v6.96A，生成一段500ms的延时函数。</p>\n<pre><code class=\"language-c\">// 延时500ms\nvoid Delay500ms(void)\t//@11.0592MHz\n{\n\tunsigned char data i, j, k;\n\n\t_nop_();\n\ti = 4;\n\tj = 129;\n\tk = 119;\n\tdo\n\t{\n\t\tdo\n\t\t{\n\t\t\twhile (--k);\n\t\t} while (--j);\n\t} while (--i);\n}\n</code></pre>\n<p><img alt=\"image-20260107120433086\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260107160519161-1654264043.png\" /></p>\n<pre><code class=\"language-c\">#include &lt;REGX52.H&gt;\n#include &lt;INTRINS.H&gt;  // 解决 _nop_ 报错\n\n// 延时500ms\nvoid Delay500ms(void)\t//@11.0592MHz\n{\n\tunsigned char data i, j, k;\n\n\t_nop_();\n\ti = 4;\n\tj = 129;\n\tk = 119;\n\tdo\n\t{\n\t\tdo\n\t\t{\n\t\t\twhile (--k);\n\t\t} while (--j);\n\t} while (--i);\n}\n\nvoid main()\n{\n\twhile(1)\n\t{\t\n\t\tP2 = 0xFE;     // 1111 1110\n\t\tDelay500ms();  // 延时0.5s\n\t\tP2 = 0xFF;     // 1111 1111\n\t\tDelay500ms();  // 延时0.5s\n\t}\n}\n\n// 现象: LED_1 闪烁，其他LED灯不亮\n</code></pre>\n<h2 id=\"3实现led流水灯\">3）实现LED流水灯</h2>\n<h3 id=\"第一种方式使用数组实现流水灯效果\"><strong>第一种方式：使用数组实现流水灯效果</strong></h3>\n<pre><code class=\"language-c\">#include &lt;REGX52.H&gt;\n#include &lt;INTRINS.H&gt;  // 解决 _nop_ 报错\n\n\n// 延时500ms\nvoid Delay500ms(void)\t//@11.0592MHz\n{\n\tunsigned char data i, j, k;\n\n\t_nop_();\n\ti = 4;\n\tj = 129;\n\tk = 119;\n\tdo\n\t{\n\t\tdo\n\t\t{\n\t\t\twhile (--k);\n\t\t} while (--j);\n\t} while (--i);\n}\n\n// 定义流水灯数组\nunsigned char LedCode[] = {0xFE,0xFD,0xFB,0xF7,0Xef,0xDF,0xBF,0x7F};\n\nvoid main()\n{\n\tunsigned char i;\n\twhile(1)\n\t{\t\n\t\tfor(i = 0;i &lt; 8;i ++)\n\t\t{\n\t\t\tP2 = LedCode[i];\n\t\t\tDelay500ms();\n\t\t}\n\t}\n}\n\n// 现象：LED灯从低到高依次点亮\n\n//附加内容：\n//0xFE  1111 1110\n//0xFD  1111 1101\n//0xFB  1111 1011\n//0xF7  1111 0111\n//0Xef  1110 1111\n//0xDF  1101 1111\n//0xBF  1011 1111\n//0x7F  0111 1111\n</code></pre>\n<h3 id=\"第二种方式左右移运算符实现\"><strong>第二种方式：左右移运算符实现</strong></h3>\n<pre><code class=\"language-c\">#include &lt;REGX52.H&gt;\n#include &lt;INTRINS.H&gt;  // 解决 _nop_ 报错\n\n\n// 延时500ms\nvoid Delay500ms(void)\t//@11.0592MHz\n{\n\tunsigned char data i, j, k;\n\n\t_nop_();\n\ti = 4;\n\tj = 129;\n\tk = 119;\n\tdo\n\t{\n\t\tdo\n\t\t{\n\t\t\twhile (--k);\n\t\t} while (--j);\n\t} while (--i);\n}\n\n\nvoid main() {\n    unsigned char Led = 0x01; // 0000 0001\n    \n    while(1) {\n        P2 = ~Led;      // 取反，输出到P2端口\n        Delay500ms();   // 延时500ms\n        \n        // 使用左移运算符\n        Led = Led &lt;&lt; 1;\n        \n        // 如果移到最右边，重新从最左边开始\n        if(Led == 0x00) {\n            Led = 0x01;\n        }\n    }\n}\n\n// 现象：LED灯从低到高依次点亮\n</code></pre>\n<h3 id=\"第三种方式循环左右移函数的调用\"><strong>第三种方式：循环左右移函数的调用</strong></h3>\n<h3 id=\"1-cror---循环右移函数\">1. <strong><em>cror</em>() - 循环右移函数</strong></h3>\n<p><strong>头文件：</strong> <code>#include &lt;intrins.h&gt;</code><br />\n<strong>原型：</strong> <code>unsigned char _cror_(unsigned char val, unsigned char n);</code></p>\n<p><strong>功能：</strong> 将 8 位数据循环右移 n 位，移出的位从左边补入</p>\n<p><strong>示例：</strong></p>\n<pre><code class=\"language-c\">unsigned char data = 0x81;  // 二进制：10000001\ndata = _cror_(data, 1);     // 结果：0xC0 (11000000)\n// 原：10000001 → 右移1位 → 11000000\n</code></pre>\n<p><img alt=\"image-20260107153044727\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260107160519436-108965670.png\" /></p>\n<h3 id=\"2-crol---循环左移函数\">2. <strong><em>crol</em>() - 循环左移函数</strong></h3>\n<p><strong>头文件：</strong> <code>#include &lt;intrins.h&gt;</code><br />\n<strong>原型：</strong> <code>unsigned char _crol_(unsigned char val, unsigned char n);</code></p>\n<p><strong>功能：</strong> 将 8 位数据循环左移 n 位，移出的位从右边补入</p>\n<p><strong>示例：</strong></p>\n<pre><code class=\"language-c\">unsigned char data = 0x81;  // 二进制：10000001\ndata = _crol_(data, 1);     // 结果：0x03 (00000011)\n// 原：10000001 → 左移1位 → 00000011\n</code></pre>\n<p><img alt=\"image-20260107153844168\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260107160519302-1190082079.png\" /></p>\n<p>流水灯应用示例：</p>\n<pre><code class=\"language-c\">#include &lt;REGX52.H&gt;\n#include &lt;INTRINS.H&gt;  // 解决 _nop_ 报错\n\n\n// 延时500ms\nvoid Delay500ms(void)\t//@11.0592MHz\n{\n\tunsigned char data i, j, k;\n\n\t_nop_();\n\ti = 4;\n\tj = 129;\n\tk = 119;\n\tdo\n\t{\n\t\tdo\n\t\t{\n\t\t\twhile (--k);\n\t\t} while (--j);\n\t} while (--i);\n}\n\n\nvoid main() \n\t{\n\t\tunsigned char aa;\n\t\taa = 0xFE;  // 1111 1110\n\t\t\n\t\twhile(1)\n\t\t{\n\t\t\tP2 = aa;\n\t\t\tDelay500ms();\n\t\t\taa = _crol_(aa,1);  // 循环左移函数\n\t\t}\n\n\t}\n\n// 现象：LED灯从低到高依次点亮\n</code></pre>\n<p><strong>注意：</strong> 这两个函数是 C51 编译器特有，仅适用于 51 单片机开发。</p>\n<h2 id=\"综合练习双向流水灯\">综合练习：双向流水灯</h2>\n<pre><code class=\"language-c\">#include &lt;REGX52.H&gt;\n#include &lt;INTRINS.H&gt;  // 包含移位函数头文件\n\n// 延时500ms\nvoid Delay500ms(void)\t//@11.0592MHz\n{\n\tunsigned char data i, j, k;\n\n\t_nop_();\n\ti = 4;\n\tj = 129;\n\tk = 119;\n\tdo\n\t{\n\t\tdo\n\t\t{\n\t\t\twhile (--k);\n\t\t} while (--j);\n\t} while (--i);\n}\n\nvoid main() \n{\n    unsigned char aa;\n    unsigned char direction = 0;  // 0:左移, 1:右移\n    unsigned char counter = 0;    // 计数左移/右移的次数\n    \n    aa = 0xFE;  // 1111 1110，第一个灯亮\n    \n    while(1)\n    {\n        P2 = aa;\n        Delay500ms();\n        \n        // 左移8次后改为右移\n        if(direction == 0)\n        {\n            aa = _crol_(aa, 1);  // 循环左移\n            counter++;\n            \n            if(counter &gt;= 7)  // 左移7次后（共8个状态）\n            {\n                direction = 1;  // 改为右移方向\n                counter = 0;    // 计数器清零\n            }\n        }\n        // 右移8次后改为左移\n        else\n        {\n            aa = _cror_(aa, 1);  // 循环右移\n            counter++;\n            \n            if(counter &gt;= 7)  // 右移7次后（共8个状态）\n            {\n                direction = 0;  // 改为左移方向\n                counter = 0;    // 计数器清零\n            }\n        }\n    }\n}\n\n// 现象：LED左右依次点亮\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-07 16:06</span>&nbsp;\n<a href=\"https://www.cnblogs.com/WIRO\">Q&amp;25</a>&nbsp;\n阅读(<span id=\"post_view_count\">104</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "XAML Studio 已正式开源",
      "link": "https://www.cnblogs.com/shanyou/p/19452660",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/shanyou/p/19452660\" id=\"cb_post_title_url\" title=\"发布于 2026-01-07 15:47\">\n    <span>XAML Studio 已正式开源</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>微软开发者博客于 2026 年 1 月 6 日正式宣布(<a href=\"https://devblogs.microsoft.com/ifdef-windows/xaml-studio-is-now-open-sourced/\" rel=\"noopener nofollow\" title=\"https://devblogs.microsoft.com/ifdef-windows/xaml-studio-is-now-open-sourced/\">https://devblogs.microsoft.com/ifdef-windows/xaml-studio-is-now-open-sourced/</a>)，<strong>XAML Studio 已正式开源</strong>，并成为了 .NET 基金会（.NET Foundation）旗下的一个种子项目。</p>\n<h5><span>1. 什么是 XAML Studio？</span></h5>\n<p><span>XAML Studio 是一款专为 <strong>WinUI</strong> 开发者打造的辅助工具，最初是 Microsoft Garage（微软车库）的一个项目。它允许开发者在不创建完整工程的情况下，快速进行 XAML 界面原型设计和交互调试。</span></p>\n<p><span>其核心功能包括：</span></p>\n<ul>\n<li>\n<p><span><span style=\"font-size: medium;\"><strong>实时编辑与预览</strong>：即时查看 XAML 代码的效果。</span></span></p>\n</li>\n<li>\n<p><span><span style=\"font-size: medium;\"><strong>绑定调试器 (Binding Debugger)</strong>：直观排查数据绑定问题。</span></span></p>\n</li>\n<li>\n<p><span><span style=\"font-size: medium;\"><strong>数据上下文编辑器</strong>：快速模拟测试数据。</span></span></p>\n</li>\n<li>\n<p><span><span style=\"font-size: medium;\"><strong>IntelliSense 与文档工具箱</strong>：提供代码补全和控件查阅。</span></span></p>\n</li>\n</ul>\n<h5><span>2. 开源背景与现状</span></h5>\n<ul>\n<li>\n<p><span><span style=\"font-size: medium;\"><strong>项目历程</strong>：该项目始于 8 年前，一直计划开源，如今终于实现。</span></span></p>\n</li>\n<li>\n<p><span><span style=\"font-size: medium;\"><strong>V2 版本</strong>：目前开源的是正在开发中的 <strong>XAML Studio v2</strong>。相比商店里的 1.1 版本，v2 采用了全新的界面，并针对 WinUI 3 进行了优化。</span></span></p>\n</li>\n<li>\n<p><span><span style=\"font-size: medium;\"><strong>社区贡献</strong>：XAML Studio 的许多核心组件早已回馈给社区，例如 <strong>Windows Community Toolkit (WCT)</strong> 中的 <code>SwitchPresenter</code>、<code>Sizer</code> 控件（如 <code>GridSplitter</code> 的改进版）以及实验性的 <strong>Adorners（装饰器）</strong> 功能，最初都源于 XAML Studio。</span></span></p>\n</li>\n</ul>\n<h5><span>3. 未来计划</span></h5>\n<ul>\n<li>\n<p><span><span style=\"font-size: medium;\"><strong>开发分支</strong>：开发者目前可以从 GitHub 的 <code>dev</code> 分支获取 v2 版本的源代码并自行构建。</span></span></p>\n</li>\n<li>\n<p><span><span style=\"font-size: medium;\"><strong>正式发布</strong>：开发团队计划在 2026 年晚些时候在 Microsoft Store 发布 v2 的正式稳定版。</span></span></p>\n</li>\n<li>\n<p><span><span style=\"font-size: medium;\"><strong>参与方式</strong>：微软鼓励开发者通过 GitHub 提交反馈、建议或直接贡献代码。</span></span></p>\n</li>\n</ul>\n<p><strong><span>相关资源：</span></strong></p>\n<ul>\n<li>\n<p><span><span style=\"font-size: medium;\"><strong>GitHub 仓库</strong>：</span></span><a href=\"https://github.com/dotnet/XAMLStudio\" rel=\"noopener nofollow\"><span>dotnet/XamlStudio</span></a>&nbsp;<span>。</span></p>\n</li>\n<li>\n<p><span><span style=\"font-size: medium;\"><strong>官方博客全文</strong>：</span></span><a href=\"https://devblogs.microsoft.com/ifdef-windows/xaml-studio-is-now-open-sourced/\" rel=\"noopener nofollow\"><span>XAML Studio is now Open Sourced</span></a></p>\n</li>\n</ul>\n<p>这对 WinUI 开发者来说是一个重要的里程碑，不仅工具本身变得透明、可定制，也预示着 WinUI 生态系统的进一步开放。</p>\n</div>\n<div id=\"MySignature\">\n    <p>欢迎大家扫描下面二维码成为我的客户，扶你上云</p>\n<img src=\"https://images.cnblogs.com/cnblogs_com/shanyou/57459/o_220125090408_%E9%82%80%E8%AF%B7%E4%BA%8C%E7%BB%B4%E7%A0%81-258px.jpeg\" width=\"170\" />\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-07 15:47</span>&nbsp;\n<a href=\"https://www.cnblogs.com/shanyou\">张善友</a>&nbsp;\n阅读(<span id=\"post_view_count\">503</span>)&nbsp;\n评论(<span id=\"post_comment_count\">4</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【终极踩坑指南】Windows 10上MsQuic证书加载失败？坑不在证书，而在Schannel！",
      "link": "https://www.cnblogs.com/haibindev/p/19452652",
      "published": "",
      "description": "<div class=\"postTitle\">\n\t\t<h1><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/haibindev/p/19452652\" id=\"cb_post_title_url\" title=\"发布于 2026-01-07 15:45\">\n    <span>【终极踩坑指南】Windows 10上MsQuic证书加载失败？坑不在证书，而在Schannel！</span>\n    \n\n</a>\n</h1>\n\t</div>\n\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        摘要：如果你在Windows 10上被 ConfigurationLoadCredential failed, 0x80070490 或 E_NOINTERFACE 错误折磨良久，试遍所有证书方案仍无解，那么恭喜，本文就是你的终点站。真正原因极可能是：新版MsQuic已默认放弃对Windows 10上Schannel的支持。无需再折腾证书，切换至OpenSSL后端即可一键解决。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"终极踩坑指南windows-10上msquic证书加载失败坑不在证书而在schannel\">【终极踩坑指南】Windows 10上MsQuic证书加载失败？坑不在证书，而在Schannel！</h1>\n<blockquote>\n<p><strong>摘要</strong>：如果你在Windows 10上被 <code>ConfigurationLoadCredential failed, 0x80070490</code> 或 <code>E_NOINTERFACE</code> 错误折磨良久，试遍所有证书方案仍无解，那么恭喜，本文就是你的终点站。真正原因极可能是：<strong>新版MsQuic已默认放弃对Windows 10上Schannel的支持</strong>。无需再折腾证书，切换至OpenSSL后端即可一键解决。</p>\n</blockquote>\n<h3 id=\"一问题现象一个极具迷惑性的错误\"><strong>一、问题现象：一个极具迷惑性的错误</strong></h3>\n<p>环境：Windows 10 22H2，使用GitHub主线版本MsQuic编译QUIC Server。</p>\n<p>在调用 <code>MsQuic-&gt;ConfigurationLoadCredential(...)</code> 时，稳定失败，返回错误：</p>\n<pre><code>ConfigurationLoadCredential failed, 0x80070490\n</code></pre>\n<p>或者：</p>\n<pre><code>E_NOINTERFACE\n</code></pre>\n<p><strong>所有迹象都指向证书问题</strong>，于是开始了漫长的“踩坑”之旅。</p>\n<h3 id=\"二排查弯路我被证书问题带偏的全过程\"><strong>二、排查弯路：我被“证书问题”带偏的全过程</strong></h3>\n<p>以下是我的排查流水账，几乎试遍了Windows下所有证书方案：</p>\n<ol>\n<li>\n<p><strong>证书哈希（官方推荐）</strong></p>\n<pre><code class=\"language-cpp\">QUIC_CERTIFICATE_HASH CertHash{};\nmemcpy(CertHash.ShaHash, hashbuf_.data(), 20);\nCredConfig.Type = QUIC_CREDENTIAL_TYPE_CERTIFICATE_HASH;\n</code></pre>\n<p><strong>结果</strong>：<code>HRESULT_FROM_WIN32(ERROR_NOT_FOUND)</code>。确认证书在本地计算机存储、有私钥、验证通过，但就是不行。</p>\n</li>\n<li>\n<p><strong>哈希存储（显式指定仓库）</strong></p>\n<pre><code class=\"language-cpp\">strcpy_s(CertHashStore.StoreName, \"LocalMachine\\\\My\");\nCredConfig.Type = QUIC_CREDENTIAL_TYPE_CERTIFICATE_HASH_STORE;\n</code></pre>\n<p><strong>结果</strong>：<code>E_INVALIDARG</code>。</p>\n</li>\n<li>\n<p><strong>怀疑证书生成方式</strong><br />\n怀疑OpenSSL生成的证书不行，换用PowerShell生成“纯正”的CNG证书：</p>\n<pre><code class=\"language-powershell\">New-SelfSignedCertificate -Provider \"Microsoft Software Key Storage Provider\" ...\n</code></pre>\n<p><strong>结果</strong>：失败依旧。</p>\n</li>\n<li>\n<p><strong>终极尝试：PFX文件</strong></p>\n<pre><code class=\"language-cpp\">CredConfig.Type = QUIC_CREDENTIAL_TYPE_CERTIFICATE_FILE_PROTECTED;\n</code></pre>\n<p><strong>结果</strong>：熟悉的 <code>E_NOINTERFACE</code>。</p>\n</li>\n<li>\n<p><strong>关键转折点：官方示例也挂了</strong><br />\n当怀疑人生时，直接测试MsQuic自带的 <code>quicsample.exe</code>：</p>\n<pre><code class=\"language-bash\">quicsample.exe -server -cert_hash:&lt;your_thumbprint&gt;\n</code></pre>\n<p><strong>同样失败！</strong> 这证明问题与我的代码无关，是<strong>环境或库本身的问题</strong>。</p>\n</li>\n</ol>\n<h3 id=\"三真相揭露不是证书的锅是schannel掉了链子\"><strong>三、真相揭露：不是证书的锅，是Schannel掉了链子</strong></h3>\n<p>所有排查都失效后，我将目光从证书移开，最终锁定核心矛盾：</p>\n<blockquote>\n<p><strong>当前较新版本的MsQuic，在Windows 10系统上，其默认的Schannel TLS后端可能已无法正常加载服务器证书。</strong></p>\n</blockquote>\n<p>这是一个<strong>官方文档未明确标注、但实际存在的兼容性断点</strong>。错误 <code>0x80070490</code> (找不到元素) 和 <code>E_NOINTERFACE</code> 极具误导性，让你在证书的迷宫里无限打转，而真正的出口是：<strong>更换TLS后端</strong>。</p>\n<h3 id=\"四一行命令解决切换到openssl后端\"><strong>四、一行命令解决：切换到OpenSSL后端</strong></h3>\n<p><strong>解决方案简单到令人发指：</strong></p>\n<ol>\n<li>\n<p><strong>使用OpenSSL后端重新编译MsQuic</strong>：</p>\n<pre><code class=\"language-bash\"># 在MsQuic仓库目录下执行\n.\\scripts\\build.ps1 -Config Debug -Arch x64 -Tls openssl\n</code></pre>\n</li>\n<li>\n<p><strong>使用OpenSSL生成的证书</strong>（如PEM或PFX格式）。</p>\n</li>\n<li>\n<p>再次运行你的程序或 <code>quicsample</code>：</p>\n<pre><code class=\"language-bash\">quicsample.exe -server -cert_file:server.pfx -key_file:key.pem\n</code></pre>\n<p><strong>✅ 服务器顺利启动，问题解决。</strong></p>\n</li>\n</ol>\n<h3 id=\"五为什么会有这个坑深度分析\"><strong>五、为什么会有这个坑？（深度分析）</strong></h3>\n<p>这个问题在 <strong>Windows 11 或 Windows Server 2022</strong> 上通常不会出现，因为它们内置了完整的、支持最新QUIC规范的Schannel实现。</p>\n<p>而 <strong>Windows 10</strong>（尤其是某些版本）的Schannel对MsQuic新版本所需功能的支持可能不完整或存在缺陷。MsQuic在更新过程中，可能默认启用了某些Windows 10上Schannel无法满足的特性或API，导致证书加载路径从根源上失败。</p>\n<p><strong>因此，这本质上是一个平台兼容性断档问题。</strong> 对于开发者而言，表象是证书错误，根因是系统组件落后于开发库的演进。</p>\n<h3 id=\"六总结与建议\"><strong>六、总结与建议</strong></h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">场景</th>\n<th style=\"text-align: left;\">推荐动作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>在Windows 10上开发/部署MsQuic</strong></td>\n<td style=\"text-align: left;\"><strong>直接使用OpenSSL后端</strong>，一劳永逸。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">遇到<code>0x80070490</code>或<code>E_NOINTERFACE</code>错误</td>\n<td style=\"text-align: left;\">首要怀疑<strong>TLS后端兼容性</strong>，而非证书本身。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">需要跨平台（Windows/Linux）一致性</td>\n<td style=\"text-align: left;\">选择OpenSSL后端更能保证行为一致。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>目标环境为Windows 11/Server 2022+</strong></td>\n<td style=\"text-align: left;\">可放心使用默认Schannel，性能更佳。</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<p><strong>拓展思考</strong>：对于从事<strong>视频流传输</strong>（如基于QUIC优化RTMP、HLS延迟）的开发者来说，理解底层网络库的这些平台细微差别至关重要。一次成功的协议升级，往往从顺利编译和部署开始。希望这篇踩坑记录能助你畅通无阻。</p>\n<p>（本文基于Windows 10 22H2家庭中文版、x64架构、MsQuic GitHub主线版本测试验证）</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/254714/202307/254714-20230701143418754-1351786962.jpg\" /></p>\n<p><strong>合作请加WX：hbstream</strong><br />\n<strong>合作请加作者hbstream（<a href=\"http://haibindev.cnblogs.com\" target=\"_blank\">http://haibindev.cnblogs.com</a>），转载请注明作者和出处</strong></p>\n\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-01-07 15:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/haibindev\">haibindev</a>&nbsp;\n阅读(<span id=\"post_view_count\">46</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "NIVIDIA高性能计算CUDA笔记（三） cuFFT的简介及实现案例",
      "link": "https://www.cnblogs.com/GeophysicsWorker/p/19452487",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/GeophysicsWorker/p/19452487\" id=\"cb_post_title_url\" title=\"发布于 2026-01-07 15:21\">\n    <span>NIVIDIA高性能计算CUDA笔记（三） cuFFT的简介及实现案例</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        cuFFT是NVIDIA提供的GPU加速的Fourier变换FFT库，能极大提升涉及FFT计算的科学计算、信号处理和深度学习等任务的速度。本笔记就cufft进行简单介绍并给出一个一维信号的fft变换示例\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"nividia高性能计算cuda笔记三-cufft的简介及实现案例\">NIVIDIA高性能计算CUDA笔记（三） cuFFT的简介及实现案例</h1>\n<h2 id=\"1-cufft库的简介introduction-of-cufft-libaray\">1. cuFFT库的简介（Introduction of cuFFT libaray）</h2>\n<p>​      Fourier变换是数字信号处理领域一个很重要的数学变换，它用来实现将信号实现将信号从时域到频域的变换，在物理学、数论、组合数学、信号处理、概率、统计、密码学、声学、光学等领域有广泛的应用。离散傅里叶变换(Discrete Fourier Transform，DFT)是连续傅里叶变换在离散系统中的表示形式，由于DFT的计算量很大，因此在很长一段时间内其应用受到了很大的限制。20世纪60年代（1965年）由Cooley和Tukey提出了快速傅里叶变换(Fast Fourier Transform，FFT)算法，它是DFT的快速算法，使得离散傅里叶变换和卷积这类难度很大的计算工作的复杂度从N2量级降到了Nlog2N量级，大大提高了DFT的运算速度，从而使DFT在实际应用中得到了广泛的应用。</p>\n<p>​       cuFFT是NVIDIA提供的GPU加速的Fourier变换FFT库，能极大提升涉及FFT计算的科学计算、信号处理和深度学习等任务的速度。下表概括了器主要特征和应用场景：</p>\n<table>\n<thead>\n<tr>\n<th>cuFFT的特征</th>\n<th>具体描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>基本功能</td>\n<td>提供GPU加速的1D、2D、3D复数/实数FFT计算</td>\n</tr>\n<tr>\n<td>核心优势</td>\n<td>相比CPU实现，利用GPU并行性可获得显著加速</td>\n</tr>\n<tr>\n<td>编程接口</td>\n<td>提供类似的FFTW的API，便于熟悉CPU FFT的用户迁移</td>\n</tr>\n<tr>\n<td>高级功能</td>\n<td>支持批量执行、流异步、半/单/双精度、多GPU计算</td>\n</tr>\n<tr>\n<td>主要应用领域</td>\n<td>深度学习、计算物理学、医学成像、信号处理等</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-基于cufft库的fourier变换步骤workflow-of-fourier-transform-based-cufft\">2. 基于cuFFT库的Fourier变换步骤（workflow of Fourier Transform based cuFFT）</h2>\n<p>在CUDA上进行傅里叶变换一般需要做以下几步工作：</p>\n<ol>\n<li>在主机端，准备输入数据；</li>\n<li>在GPU设备端上分配内存，并将数据从主机复制到设备；（<code>cudaMalloc</code>,<code>cudaMemcpy</code>的接口 ）</li>\n<li>创建一个<span class=\"math inline\">\\(plan\\)</span>, 调用函数<span class=\"math inline\">\\(cufftPlane1D/cufftPlane2D/cufftPlan3D\\)</span> 可以创建一个简单的Fourier变换。调用函数<span class=\"math inline\">\\(cufftPlanMany\\)</span> 则可以创建支持更多配置操作的变换计划。\n<ul>\n<li><span class=\"math inline\">\\(cufftPlan1d()\\)</span>: 针对单个1维信号</li>\n<li><span class=\"math inline\">\\(cufftPlan2d()\\)</span>:针对单个2维信号</li>\n<li><span class=\"math inline\">\\(cufftPlan3d()\\)</span>:针对单个3维信号</li>\n</ul>\n</li>\n<li>执行<span class=\"math inline\">\\(plane\\)</span>。这一步可以使用<span class=\"math inline\">\\(cufftExecC2C()\\)</span>、<span class=\"math inline\">\\(cufftExecR2C()\\)</span>或<span class=\"math inline\">\\(cufftExecC2R()\\)</span>等函数完成上一步完成<span class=\"math inline\">\\(plane\\)</span>的计算任务。</li>\n<li>执行完成以下若不再需要该<span class=\"math inline\">\\(plan\\)</span>，则调用<span class=\"math inline\">\\(cufftDestroy()\\)</span>函数销毁该<span class=\"math inline\">\\(plan\\)</span> 及为其分配的计算资源。</li>\n</ol>\n<h2 id=\"3-cufft的傅里叶变换api接口类型fourier-transform-types\">3. cuFFT的傅里叶变换API接口类型（Fourier Transform Types）</h2>\n<p>​        <span class=\"math inline\">\\(cuFFT\\)</span> 库实现了三种不同类型的Fourier变换接口分为：<span class=\"math inline\">\\(C2C\\)</span>(复数变换到复数)，<span class=\"math inline\">\\(C2R\\)</span>(复数到实数),  <span class=\"math inline\">\\(R2C\\)</span> (实数到复数)。本质上，这三种转换都可以被看做是复数域到复数域的变换，之所以这样划分，其最主要的考量是性能因素。例如，在一般的数字信号处理中，输入数据是一些离散的实数域上的采样点，这时候对它们做Fourier变换实际上就是<span class=\"math inline\">\\(R2C\\)</span>，根据埃尔米特对称性（Hermitian symmetry)，变换<span class=\"math inline\">\\(X_k=X_{N-k}^{*}\\)</span>, <span class=\"math inline\">\\(*\\)</span> 代表共轭复数。<span class=\"math inline\">\\(cuFFT\\)</span> 的傅里叶变换则利用了这些冗余，将计算量降到最低。</p>\n<p>​       变换执行函数的单精度和双精度版本分别定义如下：</p>\n<table>\n<thead>\n<tr>\n<th>API</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span class=\"math inline\">\\(cufftExecC2C()/cufftExecZ2Z()\\)</span></td>\n<td>单精度/双精度浮点数复数域到复数域的傅里叶变换</td>\n</tr>\n<tr>\n<td><span class=\"math inline\">\\(cufftExecR2C()/cufftExecD2Z()\\)</span></td>\n<td>单精度/双精度浮点数实数域到复数域的傅里叶变换（正变换）</td>\n</tr>\n<tr>\n<td><span class=\"math inline\">\\(cufftExecC2R()/cufftExecZ2D()\\)</span></td>\n<td>单精度/双精度浮点数复数域到实数域的傅里叶变换（逆变换）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"4-数据布局data-layout\">4. 数据布局(Data Layout)</h2>\n<p>​       <span class=\"math inline\">\\(CUFFT\\)</span>库保含若干种数据类型，对于复数有<span class=\"math inline\">\\(cufftComplex/cufftDoubleComplex\\)</span> 两种数据类型，对于实数则分别有<span class=\"math inline\">\\(cufftReal/cufftDouble\\)</span> 两种数据类型 。</p>\n<p>​         根据转换结果的存储位置不同，<span class=\"math inline\">\\(FFT\\)</span>变换可分为就地变换(<span class=\"math inline\">\\(in-place\\)</span>)和外部变换（<span class=\"math inline\">\\(out-place\\)</span>)，前者直接在输入数据进行变换，而后者则会将变换后结果存入新的存储器地址。</p>\n<p>​         就地转换(<span class=\"math inline\">\\(in-place\\)</span>) 支持数据的两种布局：<span class=\"math inline\">\\(native\\)</span> 和 <span class=\"math inline\">\\(padded\\)</span>，前者用于获取最佳性能，而后者则用于与FFTW兼容。</p>\n<p>​         在<span class=\"math inline\">\\(padded\\)</span>布局中输出信号的开始地址与输入信号一样，换句话说，实数域到复数域变换的输入数据和复数域到实数域的输出数据必须被填充。在native布局中则没有填入要求。</p>\n<p>​         输入数据和输出数据的尺寸总结如下：</p>\n<table>\n<thead>\n<tr>\n<th>FFT type</th>\n<th>input data size</th>\n<th>output data size</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span class=\"math inline\">\\(C2C\\)</span></td>\n<td><span class=\"math inline\">\\(X \\space cufftComplex\\)</span></td>\n<td><span class=\"math inline\">\\(X \\space cufftComplex\\)</span></td>\n</tr>\n<tr>\n<td><span class=\"math inline\">\\(C2R\\)</span></td>\n<td><span class=\"math inline\">\\([\\frac{X}{2}]+1 \\space cufftComplex\\)</span></td>\n<td><span class=\"math inline\">\\(X\\)</span> <span class=\"math inline\">\\(cufftReal\\)</span></td>\n</tr>\n<tr>\n<td><span class=\"math inline\">\\(R2C^{*}\\)</span></td>\n<td><span class=\"math inline\">\\(X\\)</span> <span class=\"math inline\">\\(cufftReal\\)</span></td>\n<td><span class=\"math inline\">\\([\\frac{X}{2}]+1 \\space cufftComplex\\)</span></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"5-单个一维信号的fft变换代码实现one-dimension-signal-fft-transfrom\">5. 单个一维信号的FFT变换代码实现（One Dimension SIgnal FFT Transfrom）</h2>\n<p>在本次测试代码中：首先生成一维的随机信号，利用cufft 先进行正变换，然后逆变换，并判定逆变换后结果与原输入信号判断是否相等。</p>\n<pre><code class=\"language-C\">#include &lt;iostream&gt;\n#include &lt;time.h&gt;\n#include \"cuda_runtime.h\"\n#include \"device_launch_parameters.h\"\n#include &lt;cufft.h&gt;\n\n#define NX 3335 // 有效数据个数\n#define N 5335 // 补0之后的数据长度\n#define BATCH 1\n#define BLOCK_SIZE 1024\nusing std::cout;\nusing std::endl;\n\n\n/**\n* 功能：判断两个 cufftComplex 数组的是否相等\n* 输入：idataA 输入数组A的头指针\n* 输入：idataB 输出数组B的头指针\n* 输入：size 数组的元素个数\n* 返回：true | false\n*/\nbool IsEqual(cufftComplex *idataA, cufftComplex *idataB, const int size)\n{\n    for (int i = 0; i &lt; size; i++)\n    {\n        if (abs(idataA[i].x - idataB[i].x) &gt; 0.000001 || abs(idataA[i].y - idataB[i].y) &gt; 0.000001)\n            return false;\n    }\n\n    return true;\n}\n\n\n\n/**\n* 功能：实现 cufftComplex 数组的尺度缩放，也就是乘以一个数\n* 输入：idata 输入数组的头指针\n* 输出：odata 输出数组的头指针\n* 输入：size 数组的元素个数\n* 输入：scale 缩放尺度\n*/\nstatic __global__ void cufftComplexScale(cufftComplex *idata, cufftComplex *odata, const int size, float scale)\n{\n    const int threadID = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (threadID &lt; size)\n    {\n        odata[threadID].x = idata[threadID].x * scale;\n        odata[threadID].y = idata[threadID].y * scale;\n    }\n}\n\nint main()\n{\n    cufftComplex *data_dev; // 设备端数据头指针\n    cufftComplex *data_Host = (cufftComplex*)malloc(NX*BATCH * sizeof(cufftComplex)); // 主机端数据头指针\n    cufftComplex *resultFFT = (cufftComplex*)malloc(N*BATCH * sizeof(cufftComplex)); // 正变换的结果\n    cufftComplex *resultIFFT = (cufftComplex*)malloc(NX*BATCH * sizeof(cufftComplex)); // 先正变换后逆变换的结果\n\n    // 初始数据\n    for (int i = 0; i &lt; NX; i++)\n    {\n        data_Host[i].x = float((rand() * rand()) % NX) / NX;\n        data_Host[i].y = float((rand() * rand()) % NX) / NX;\n    }\n\n\n    dim3 dimBlock(BLOCK_SIZE); // 线程块\n    dim3 dimGrid((NX + BLOCK_SIZE - 1) / dimBlock.x); // 线程格\n\n    cufftHandle plan; // 创建cuFFT句柄\n    cufftPlan1d(&amp;plan, N, CUFFT_C2C, BATCH);\n\n    // 计时\n    clock_t start, stop;\n    double duration;\n    start = clock();\n\n    cudaMalloc((void**)&amp;data_dev, sizeof(cufftComplex)*N*BATCH); // 开辟设备内存\n    cudaMemset(data_dev, 0, sizeof(cufftComplex)*N*BATCH); // 初始为0\n    cudaMemcpy(data_dev, data_Host, NX * sizeof(cufftComplex), cudaMemcpyHostToDevice); // 从主机内存拷贝到设备内存\n\n    cufftExecC2C(plan, data_dev, data_dev, CUFFT_FORWARD); // 执行 cuFFT，正变换\n    cudaMemcpy(resultFFT, data_dev, N * sizeof(cufftComplex), cudaMemcpyDeviceToHost); // 从设备内存拷贝到主机内存\n\n    cufftExecC2C(plan, data_dev, data_dev, CUFFT_INVERSE); // 执行 cuFFT，逆变换\n    cufftComplexScale &lt;&lt; &lt;dimGrid, dimBlock &gt;&gt; &gt; (data_dev, data_dev, N, 1.0f / N); // 乘以系数\n    cudaMemcpy(resultIFFT, data_dev, NX * sizeof(cufftComplex), cudaMemcpyDeviceToHost); // 从设备内存拷贝到主机内存\n\n    stop = clock();\n    duration = (double)(stop - start) * 1000 / CLOCKS_PER_SEC;\n    cout &lt;&lt; \"时间为 \" &lt;&lt; duration &lt;&lt; \" ms\" &lt;&lt; endl;\n\n    cufftDestroy(plan); // 销毁句柄\n    cudaFree(data_dev); // 释放空间\n\n    cout &lt;&lt; IsEqual(data_Host, resultIFFT, NX) &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>其中<code>cufftPlan1d()</code> :</p>\n<ul>\n<li>第一个参数就是要配置的<span class=\"math inline\">\\(cuFFT\\)</span>句柄；</li>\n<li>第二个参数就是要进行fft的信号的长度；</li>\n<li>第三个<code>CUFFT_C2C</code> 为要执行<span class=\"math inline\">\\(fft\\)</span> 的信号输入类型及输出类型复数；<code>CUFFT_C2R</code>表示输入复数，输出实数；<code>CUFFT_R2C</code>表示输入实数，输出复数；<code>CUFFT_R2R</code> 表示输入实数，输出实数；</li>\n<li>第四个参数<code>BATCH</code>表示要执行fft的信号的个数，新版的已经使用<code>cufftPlanMany()</code>来同时完成多个信号的fft；</li>\n</ul>\n<p><code>cufftExecC2C()</code>:</p>\n<ul>\n<li>第一个参数就是配置好的 cuFFT 句柄；</li>\n<li>第二个参数为输入信号的首地址；</li>\n<li>第三个参数为输出信号的首地址；</li>\n<li>第四个参数为<code>CUFFT_FORWARD</code>表示执行的是<span class=\"math inline\">\\(fft\\)</span>正变换；<code>CUFFT_INVERSE</code>表示执行<span class=\"math inline\">\\(fft\\)</span>逆变换</li>\n</ul>\n<p>需要注意的是，执行完<span class=\"math inline\">\\(fft\\)</span>之后，要对信号中的每个值乘以<span class=\"math inline\">\\(1/N\\)</span>;</p>\n<p>输出结果：</p>\n<p><img alt=\"cufft\" class=\"lazyload\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-07 15:21</span>&nbsp;\n<a href=\"https://www.cnblogs.com/GeophysicsWorker\">GeoFXR</a>&nbsp;\n阅读(<span id=\"post_view_count\">77</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "IQR四分位数法是什么？",
      "link": "https://www.cnblogs.com/sun-10387834/p/19386427",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sun-10387834/p/19386427\" id=\"cb_post_title_url\" title=\"发布于 2026-01-07 15:06\">\n    <span>IQR四分位数法是什么？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>IQR（Interquartile Range，四分位距）四分位数法是一种统计学中用于描述数据离散程度、识别异常值的重要工具。它通过数据的四分位数（Quartiles）来刻画数据的分布特征，尤其适用于非正态分布或存在离群点的场景。以下从核心概念、计算方法、应用场景和理解要点展开说明：</p>\n<h3 id=\"一核心概念四分位数与iqr\"><strong>一、核心概念：四分位数与IQR</strong></h3>\n<h4 id=\"1-四分位数quartiles\">1. 四分位数（Quartiles）</h4>\n<p>将一组有序数据（从小到大排列）划分为4个相等部分的三个关键分割点，分别记为：</p>\n<ul>\n<li><strong>Q1（第一四分位数，25%分位数）</strong>：数据中25%的数值小于或等于它（即第25百分位数）。</li>\n<li><strong>Q2（第二四分位数，中位数）</strong>：数据中50%的数值小于或等于它（即第50百分位数，Median）。</li>\n<li><strong>Q3（第三四分位数，75%分位数）</strong>：数据中75%的数值小于或等于它（即第75百分位数）。</li>\n</ul>\n<p>例如，数据集 [1, 3, 5, 7, 9, 11, 13] 的中位数是7（Q2）；前半部分 [1,3,5] 的中位数是3（Q1），后半部分 [9,11,13] 的中位数是11（Q3）。</p>\n<h4 id=\"2-iqr四分位距\">2. IQR（四分位距）</h4>\n<p><strong>IQR = Q3 - Q1</strong>，表示中间50%数据的分布范围（即数据在Q1到Q3之间的“宽度”）。它是衡量数据离散程度的稳健指标（不受极端值影响）。</p>\n<h3 id=\"二iqr四分位数法的核心作用识别异常值\"><strong>二、IQR四分位数法的核心作用：识别异常值</strong></h3>\n<p>IQR法最常用的是通过“箱线图（Box Plot）”或“Tukey’s Fences”规则识别异常值（Outliers）。具体步骤如下：</p>\n<h4 id=\"1-计算上下边界\">1. 计算上下边界</h4>\n<p>以IQR为基准，定义数据的“正常范围”：</p>\n<ul>\n<li><strong>下边界（Lower Bound）</strong>：Q1 - 1.5×IQR</li>\n<li><strong>上边界（Upper Bound）</strong>：Q3 + 1.5×IQR</li>\n</ul>\n<h4 id=\"2-判定异常值\">2. 判定异常值</h4>\n<ul>\n<li><strong>温和异常值（Mild Outliers）</strong>：小于下边界或大于上边界的数据点（通常用1.5×IQR界定）。</li>\n<li><strong>极端异常值（Extreme Outliers）</strong>：小于Q1 - 3×IQR 或大于Q3 + 3×IQR 的数据点（更严格的阈值）。</li>\n</ul>\n<p><strong>逻辑</strong>：正常数据应集中在中间50%（Q1到Q3），而超出1.5倍IQR的点被视为“偏离较远的异常”。1.5倍的选择是经验性的（基于正态分布假设下约覆盖99.3%的数据，剩余0.7%视为异常）。</p>\n<h3 id=\"三应用场景\"><strong>三、应用场景</strong></h3>\n<ol>\n<li><strong>数据清洗</strong>：识别并验证离群点（如传感器误差、输入错误）。</li>\n<li><strong>可视化分析</strong>：箱线图的核心组件（箱体表示Q1到Q3，触须延伸至非异常值的最远点，异常值单独标记）。</li>\n<li><strong>统计描述</strong>：替代标准差（SD）衡量离散程度（尤其当数据非正态时，IQR更稳健）。</li>\n</ol>\n<h3 id=\"四如何理解iqr法的优势与局限\"><strong>四、如何理解IQR法的优势与局限</strong></h3>\n<h4 id=\"优势\">优势：</h4>\n<ul>\n<li><strong>稳健性</strong>：仅依赖中间50%的数据，不受极端值干扰（标准差易受异常值影响）。</li>\n<li><strong>普适性</strong>：适用于任何分布（无需假设数据正态）。</li>\n<li><strong>直观性</strong>：通过四分位数直接反映数据的集中与分散趋势。</li>\n</ul>\n<h4 id=\"局限\">局限：</h4>\n<ul>\n<li><strong>主观性</strong>：1.5倍IQR是经验阈值，不同领域可能调整（如金融风控可能用3倍）。</li>\n<li><strong>小样本偏差</strong>：样本量过小时（如n&lt;10），四分位数估计可能不稳定。</li>\n<li><strong>无法反映分布形态</strong>：仅描述离散程度，不体现数据的对称性或峰度。</li>\n</ul>\n<h3 id=\"五示例说明\"><strong>五、示例说明</strong></h3>\n<p>假设数据集：[12, 15, 17, 19, 20, 22, 24, 28, 30, 35, 40, 100]（已排序）。</p>\n<ol>\n<li>\n<p>计算四分位数：</p>\n<ul>\n<li>n=12，中位数Q2是第6和第7个数的平均：(22+24)/2=23。</li>\n<li>Q1是前6个数的中位数：(17+19)/2=18（前6数：12,15,17,19,20,22）。</li>\n<li>Q3是后6个数的中位数：(30+35)/2=32.5（后6数：24,28,30,35,40,100）。</li>\n</ul>\n</li>\n<li>\n<p>计算IQR：IQR=Q3-Q1=32.5-18=14.5。</p>\n</li>\n<li>\n<p>确定边界：</p>\n<ul>\n<li>下边界=18 - 1.5×14.5=18-21.75=-3.75</li>\n<li>上边界=32.5 + 1.5×14.5=32.5+21.75=54.25</li>\n</ul>\n</li>\n<li>\n<p>识别异常值：数据中100&gt;54.25，因此100是异常值；其他数据点均在[-3.75, 54.25]范围内。</p>\n</li>\n</ol>\n<h3 id=\"总结\"><strong>总结</strong></h3>\n<p>IQR四分位数法通过“中间50%数据的范围”（IQR）量化离散程度，并通过1.5倍IQR的边界识别异常值。它的核心是<strong>关注数据的主体分布，忽略极端干扰</strong>，是探索性数据分析（EDA）中简单却强大的工具。理解其逻辑的关键在于把握“四分位数划分数据、IQR衡量主体波动、边界外视为异常”这一链条。</p>\n\n</div>\n<div id=\"MySignature\">\n    \n<p>❤️ 如果你喜欢这篇文章，请点赞支持！ 👍 同时欢迎关注我的博客，获取更多精彩内容！</p>\n\n<p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/sun-10387834/\" target=\"_blank\">佛祖让我来巡山</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/sun-10387834/p/19386427\" target=\"_blank\">https://www.cnblogs.com/sun-10387834/p/19386427</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-07 15:06</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sun-10387834\">佛祖让我来巡山</a>&nbsp;\n阅读(<span id=\"post_view_count\">53</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "SQL 性能避坑：为什么阿里强制禁用 ORDER BY RAND()？",
      "link": "https://www.cnblogs.com/xzqcsj/p/19452232",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xzqcsj/p/19452232\" id=\"cb_post_title_url\" title=\"发布于 2026-01-07 14:43\">\n    <span>SQL 性能避坑：为什么阿里强制禁用 ORDER BY RAND()？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"SQL 性能避坑：为什么阿里强制禁用 ORDER BY RAND()？\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3703499/202601/3703499-20260107144026422-1062364965.png\" />\n        如果你翻阅过《阿里巴巴 Java 开发手册》，在 MySQL 数据库规约中，一定见过这条醒目的“红线”：【强制】不得在 database 中使用 ORDER BY RAND() 进行随机排序。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p><a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzYyMzM2MjA2OA==&amp;action=getalbum&amp;album_id=4252891456433995787#wechat_redirect\" rel=\"noopener nofollow\" target=\"_blank\">MySQL专栏</a></p>\n<p>如果你翻阅过《阿里巴巴 Java 开发手册》，在 MySQL 数据库规约中，一定见过这条醒目的“红线”：</p>\n<blockquote>\n<p><strong>【强制】不得在 database 中使用 ORDER BY RAND() 进行随机排序。</strong></p>\n</blockquote>\n<p>很多人第一反应是：“不就随机查几条数据吗？MySQL 既然提供了这个内置函数，为什么不让用？”</p>\n<p>事实上，这可能是 MySQL 里最“坑爹”的内置函数之一。在数据量只有几百条时，它是省时省力的小甜甜；一旦数据量突破十万级，它立马变身吸干 CPU 的“牛夫人”，分分钟让你的数据库报警。</p>\n<p>今天我们就来扒一扒，为什么这个函数是性能杀手，以及在海量数据下，我们该如何<strong>优雅且高性能</strong>地实现“<strong>随机推荐</strong>”功能。</p>\n</blockquote>\n<p><img alt=\"874681b40ba63432d5615fd64ad878f4\" class=\"lazyload\" /></p>\n<h2 id=\"案发现场一条-sql-引发的血案\">案发现场：一条 SQL 引发的血案</h2>\n<p>那个让 DBA 暴跳如雷的 SQL 长这样：</p>\n<pre><code class=\"language-sql\">-- 看起来人畜无害，实则剧毒无比\nSELECT * FROM product ORDER BY RAND() LIMIT 3;\n</code></pre>\n<p>如果你的商品表只有几百条数据，怎么玩都行。但当数据量达到 <strong>几万、几十万甚至上百万</strong> 时，这条 SQL 就是一颗定时炸弹。</p>\n<h3 id=\"为什么它这么慢\">为什么它这么慢？</h3>\n<p>我在测试环境重现了一下，顺手敲了个 <code>EXPLAIN</code>。好家伙，<code>Extra</code> 字段里赫然写着：</p>\n<blockquote>\n<p><strong>Using temporary; Using filesort</strong></p>\n</blockquote>\n<p>这简直是 MySQL 性能杀手界的“卧龙凤雏”！</p>\n<p><code>ORDER BY RAND()</code> 的执行流程大致是这样的：</p>\n<ol>\n<li><strong>全表扫描</strong>：MySQL 需要为每一行数据生成一个随机值。</li>\n<li><strong>创建临时表</strong>：把<strong>查询列</strong>和<strong>对应的随机值</strong>塞进临时表（如果内存不够，还会用到磁盘临时表）。</li>\n<li><strong>全局排序</strong>：对临时表里的随机值进行排序。</li>\n<li><strong>取出前几条</strong>：这就好比你要从一袋米里随机挑 3 粒，却先把整袋米倒出来，给每粒米编个号，排个序，再挑前 3 个。</li>\n</ol>\n<p>这不崩谁崩？</p>\n<hr />\n<h2 id=\"深入剖析五种高性能替代方案\">深入剖析：五种高性能替代方案</h2>\n<p>既然 <code>ORDER BY RAND()</code> 不能用，那怎么实现“随机推荐”？其实思路很简单：<strong>把“计算随机”的压力从 Database 转移到 Application（应用层）</strong>，或者<strong>减少数据库的扫描行数</strong>。</p>\n<h3 id=\"方案一应用层随机法application-shuffle\">方案一：应用层随机法（Application Shuffle）</h3>\n<p><strong>适用场景</strong>：数据量不大（例如 &lt; 10万），内存不值钱。</p>\n<p><strong>核心思想</strong>：既然数据库随机排序慢，那我把 ID 全拿出来，在 Java 代码里洗牌行不行？</p>\n<h4 id=\"代码实现\">代码实现</h4>\n<pre><code class=\"language-java\">// 1. 查出所有商品ID（只查ID，速度飞快）\n// SQL: SELECT id FROM product;\nList&lt;Integer&gt; allProductIds = productMapper.selectAllIds();\n\n// 2. 利用 Java 的 Collections 工具类进行洗牌\nCollections.shuffle(allProductIds);\n\n// 3. 截取前3个\nList&lt;Integer&gt; randomIds = allProductIds.subList(0, 3);\n\n// 4. 回表批量查询详情\n// SQL: SELECT * FROM product WHERE id IN (..., ..., ...);\nList&lt;Product&gt; results = productMapper.selectByIds(randomIds);\n</code></pre>\n<h4 id=\"优缺点点评\">优缺点点评</h4>\n<ul>\n<li><strong>优点</strong>：真・随机，由于用了 <code>Collections.shuffle</code>，随机分布非常均匀；逻辑简单粗暴。</li>\n<li><strong>缺点</strong>：太占内存。如果表里有 1000 万条 ID，全拉到内存里，JVM 直接 OOM 教做人。</li>\n<li><strong>避坑</strong>：一定要给 ID 列表加缓存（Redis 或本地缓存），别每次请求都去查全量 ID，那跟直接攻击数据库没区别。</li>\n</ul>\n<hr />\n<h3 id=\"方案二limit-偏移法limit-offset\">方案二：Limit 偏移法（Limit Offset）</h3>\n<p><strong>适用场景</strong>：数据量大（百万级以上），对随机性要求没那么严苛。</p>\n<p><strong>核心思想</strong>：给所有数据编个号，随机生成一个“偏移量”，直接跳到那里去拿。</p>\n<h4 id=\"代码实现-1\">代码实现</h4>\n<pre><code class=\"language-java\">// 1. 先查询总数（可以走缓存）\n// SQL: SELECT COUNT(*) FROM product;\nint totalCount = productMapper.count();\n\n// 2. 随机生成一个偏移量\n// 注意：totalCount - 3 是为了防止 limit 越界，确保能取够3条\nint offset = new Random().nextInt(totalCount - 3);\n\n// 3. 直接利用 LIMIT 偏移量查询\n// SQL: SELECT * FROM product LIMIT #{offset}, 3;\nList&lt;Product&gt; results = productMapper.selectByOffset(offset, 3);\n</code></pre>\n<h4 id=\"优缺点点评-1\">优缺点点评</h4>\n<ul>\n<li><strong>优点</strong>：性能极佳！大部分情况下只需要扫描 <code>offset + 3</code> 行 ，count值可以放缓存中，定期更新。</li>\n<li><strong>缺点</strong>：\n<ol>\n<li><strong>伪随机</strong>：你取出来的 3 条数据是<strong>物理上连续</strong>的。比如正好取出了“iPhone 13, iPhone 14, iPhone 15”，看起来不够随机。</li>\n<li><strong>深分页问题</strong>：如果随机到的 <code>offset</code> 很大（比如 900万），<code>LIMIT 9000000, 3</code> 的性能也会下降，因为 MySQL 要先扫过前 900 万行扔掉。</li>\n</ol>\n</li>\n</ul>\n<hr />\n<h3 id=\"方案三多次查询法multiple-queries\">方案三：多次查询法（Multiple Queries）</h3>\n<p><strong>适用场景</strong>：数据量大，且要求高质量随机。</p>\n<p><strong>核心思想</strong>：既然方案二取出的数据是连续的，那我多随机几次，每次取 1 条，拼凑出 3 条不就行了？</p>\n<h4 id=\"代码实现-2\">代码实现</h4>\n<pre><code class=\"language-java\">// 1. 获取总数\nint total = productMapper.count();\n\n// 2. 生成3个不重复的随机下标（Java 8 Stream 写法）\nList&lt;Integer&gt; randomOffsets = new Random()\n        .ints(0, total) // 生成无限流\n        .distinct()     // 去重\n        .limit(3)       // 截取前3个\n        .boxed()\n        .collect(Collectors.toList());\n\n// 3. 循环查询（或者拼接 SQL 用 UNION ALL）\nList&lt;Product&gt; result = new ArrayList&lt;&gt;();\nfor (Integer offset : randomOffsets) {\n    // SQL: SELECT * FROM product LIMIT #{offset}, 1\n    result.add(productMapper.selectByLimit(offset, 1));\n}\n</code></pre>\n<p>其实这就是 <strong>MySQL 45讲</strong> 里推荐的优化思路。相比于方案二，它打散了连续性。</p>\n<h4 id=\"优缺点点评-2\">优缺点点评</h4>\n<ul>\n<li><strong>优点</strong>：既避免了全表排序，又保证了较好的随机性。</li>\n<li><strong>缺点</strong>：要与数据库交互多次（N 次查询）。不过对于高并发应用，一般都是多次查询 + 缓存，这点开销完全可以接受。</li>\n</ul>\n<h3 id=\"方案四主键范围法index-random\">方案四：主键范围法（Index Random）</h3>\n<p><strong>适用场景</strong>：ID 必须这是连续的（或空洞很少），追求极致性能。</p>\n<p><strong>核心思想</strong>：既然 <code>LIMIT N, M</code> 越往后越慢，那我直接算出随机 ID，用主键索引“跳”过去不就完事了？</p>\n<h4 id=\"代码实现-3\">代码实现</h4>\n<p><strong>Java 逻辑处理：</strong></p>\n<pre><code class=\"language-java\">// 1. 获取 ID 范围（minId 和 maxId）\n// SQL: SELECT MIN(id), MAX(id) FROM product;\nlong minId = productMapper.selectMinId();\nlong maxId = productMapper.selectMaxId();\n\n// 2. 计算随机起点\n// 注意：maxId - minId - 3 是为了保证起点的 id 后面至少还有 3 条数据（假设 ID 连续）\n// 如果 ID 极其稀疏，这个范围可能需要预留更大\nlong range = maxId - minId - 3; \nlong randomId = minId + (long)(Math.random() * range);\n\n// 3. 执行查询\nList&lt;Product&gt; products = productMapper.selectGtId(randomId, 3);\n</code></pre>\n<p><strong>SQL 实现：</strong></p>\n<pre><code class=\"language-sql\">SELECT * FROM product \nWHERE id &gt;= #{randomId} \nLIMIT 3;\n</code></pre>\n<h4 id=\"优缺点点评-3\">优缺点点评</h4>\n<ul>\n<li><strong>优点</strong>：速度快到飞起！复杂度直接降为 $O(\\log N)$（主键查找），完全没有 <code>LIMIT</code> 深分页的性能衰减。</li>\n<li><strong>缺点</strong>：<strong>非常挑食！</strong> 它假设 ID 是连续的。如果你的商品表里因为删删改改导致 ID 中间空洞很大，这类 SQL 会导致分布严重不均（空洞前的那条数据被选中的概率会暴增），甚至可能取不到数据。</li>\n</ul>\n<hr />\n<h3 id=\"方案五redis-预处理法redis-set\">方案五：Redis 预处理法（Redis Set）</h3>\n<p><strong>适用场景</strong>：高并发、高性能、大数据量，标准的互联网大厂打法。</p>\n<p><strong>核心思想</strong>：既然 MySQL 不擅长做随机，那就别难为它了，交给最擅长的 Redis。</p>\n<h4 id=\"代码实现-4\">代码实现</h4>\n<pre><code class=\"language-java\">// 1. 初始化（只需做一次）：把所有商品ID丢进 Redis Set\n// Redis Key: \"all_product_ids\"\n\n// 2. 利用 Redis 原生命令随机获取 ID\n// 命令：SRANDMEMBER key count\n// 时间复杂度：O(N)，N是你取的数量，极快\nList&lt;Integer&gt; randomIds = redisTemplate.opsForSet().randomMembers(\"all_product_ids\", 3);\n\n// 3. 回表 MySQL 查详情（这里全是主键查询，性能无压力）\nList&lt;Product&gt; products = productMapper.selectByIds(randomIds);\n</code></pre>\n<h4 id=\"优缺点点评-4\">优缺点点评</h4>\n<ul>\n<li><strong>优点</strong>：<strong>天花板级别的性能</strong>。无论你有多少数据，Redis 都基本能在几毫秒内吐出随机 ID。</li>\n<li><strong>缺点</strong>：架构变复杂了。你需要维护 Redis 和 MySQL 的数据同步（也就是经典的缓存一致性问题）。</li>\n</ul>\n<hr />\n<h2 id=\"最终总结选型指南\">最终总结：选型指南</h2>\n<p>那这几种方案怎么选？</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">你的场景</th>\n<th style=\"text-align: left;\">推荐方案</th>\n<th style=\"text-align: left;\">理由</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>数据量 &lt; 10W</strong></td>\n<td style=\"text-align: left;\"><strong>方案一（应用层 Shuffle）</strong></td>\n<td style=\"text-align: left;\">开发最快，逻辑最简单，随机性最完美。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>数据量 &gt; 10W，ID连续</strong></td>\n<td style=\"text-align: left;\"><strong>方案四（索引跳跃）</strong></td>\n<td style=\"text-align: left;\">既不用维护缓存，又能享受极致性能。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>数据量 &gt; 10W，允许连续</strong></td>\n<td style=\"text-align: left;\"><strong>方案二（Limit Offset）</strong></td>\n<td style=\"text-align: left;\">性能不错，通用性强，是个老实人。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>数据量 &gt; 10W，要求打散</strong></td>\n<td style=\"text-align: left;\"><strong>方案三（多次查询）</strong></td>\n<td style=\"text-align: left;\">在性能和随机性之间找到了平衡点。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>高并发 / 追求极致</strong></td>\n<td style=\"text-align: left;\"><strong>方案五（Redis Set）</strong></td>\n<td style=\"text-align: left;\">工业界标准答案，虽然稍微麻烦点，但真香。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>想被辞退</strong></td>\n<td style=\"text-align: left;\"><strong>ORDER BY RAND()</strong></td>\n<td style=\"text-align: left;\">只要你敢用，P0 故障随时带回家。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>最后多嘴一句</strong>：<br />\n如果你的业务可以接受“伪随机”（比如每个人看到的随机列表在 1 小时内是一样的），<strong>强烈建议把算好的随机结果丢进 Redis</strong>。毕竟，<strong>最好的 SQL 优化就是不执行 SQL</strong>。</p>\n<p>别让你写的代码，成为深夜报警的罪魁祸首。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-07 14:43</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xzqcsj\">一旅人</a>&nbsp;\n阅读(<span id=\"post_view_count\">254</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "三大 Agent-UI 协议深度剖析：AG-UI、A2UI 与 MCP-UI 的设计哲学与工程实践",
      "link": "https://www.cnblogs.com/madtom/p/19452209",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/madtom/p/19452209\" id=\"cb_post_title_url\" title=\"发布于 2026-01-07 14:36\">\n    <span>三大 Agent-UI 协议深度剖析：AG-UI、A2UI 与 MCP-UI 的设计哲学与工程实践</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        随着大模型从\"对话框\"演进为\"自主智能体\"，如何让 Agent 具备富交互能力成为关键挑战。本文基于项目实战，结合 AG-UI、A2UI、MCP-UI 三大协议的源码深度分析，系统阐述它们的设计哲学、核心机制、实现方案及对接方式，并探讨协议组合使用的最佳实践。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p><strong>摘要</strong>：随着大模型从\"对话框\"演进为\"自主智能体\"，如何让 Agent 具备富交互能力成为关键挑战。本文基于项目实战，结合 AG-UI、A2UI、MCP-UI 三大协议的源码深度分析，系统阐述它们的设计哲学、核心机制、实现方案及对接方式，并探讨协议组合使用的最佳实践。</p>\n</blockquote>\n<p><img alt=\"占位符：文章封面图 - 三大协议的技术架构全景图\" class=\"lazyload\" /></p>\n<hr />\n<h2 id=\"目录\">目录</h2>\n<ol>\n<li><a href=\"#1-%E5%BC%95%E8%A8%80%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-agent-ui-%E5%8D%8F%E8%AE%AE\" rel=\"noopener nofollow\">引言：为什么需要 Agent-UI 协议？</a></li>\n<li><a href=\"#2-ag-ui%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93%E4%BA%A4%E4%BA%92%E5%8D%8F%E8%AE%AE\" rel=\"noopener nofollow\">AG-UI：事件驱动的智能体交互协议</a></li>\n<li><a href=\"#3-a2ui%E5%A3%B0%E6%98%8E%E5%BC%8F-ui-%E7%9A%84%E9%9B%B6%E4%BF%A1%E4%BB%BB%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E\" rel=\"noopener nofollow\">A2UI：声明式 UI 的零信任渲染引擎</a></li>\n<li><a href=\"#4-mcp-uimcp-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E6%89%A9%E5%B1%95%E5%B1%82\" rel=\"noopener nofollow\">MCP-UI：MCP 协议的可视化扩展层</a></li>\n<li><a href=\"#5-%E5%8D%8F%E8%AE%AE%E7%BB%84%E5%90%88ag-ui--a2ui-%E7%9A%84%E5%8D%8F%E5%90%8C%E6%9E%B6%E6%9E%84\" rel=\"noopener nofollow\">协议组合：AG-UI + A2UI 的协同架构</a></li>\n<li><a href=\"#6-%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E5%86%B3%E7%AD%96%E6%A1%86%E6%9E%B6\" rel=\"noopener nofollow\">技术选型决策框架</a></li>\n<li><a href=\"#7-demo-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E8%A7%A3%E6%9E%90\" rel=\"noopener nofollow\">Demo 项目实战解析</a></li>\n<li><a href=\"#8-%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B1%95%E6%9C%9B\" rel=\"noopener nofollow\">总结与展望</a></li>\n</ol>\n<hr />\n<h2 id=\"1-引言为什么需要-agent-ui-协议\">1. 引言：为什么需要 Agent-UI 协议？</h2>\n<h3 id=\"11-传统-chatbot-的局限性\">1.1 传统 Chatbot 的局限性</h3>\n<p>传统的 AI 聊天机器人采用简单的 <strong>Request-Response</strong> 模式：用户输入文本，模型返回文本。这种模式在面对复杂业务场景时暴露出严重不足：</p>\n<pre><code>用户 → \"帮我订一家北京的川菜馆\"\n传统 Bot → \"好的，我找到了以下餐厅：1. 川办餐厅... 2. 眉州东坡...\"\n</code></pre>\n<p><strong>问题</strong>：</p>\n<ul>\n<li>❌ 无法展示餐厅图片、评分、价格等结构化信息</li>\n<li>❌ 用户需要手动复制餐厅名称再去搜索</li>\n<li>❌ 无法直接在对话中完成预订操作</li>\n</ul>\n<h3 id=\"12-agent-时代的新需求\">1.2 Agent 时代的新需求</h3>\n<p>当 AI 从 Chatbot 升级为 Agent 后，交互模式发生了本质变化：</p>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>Chatbot</th>\n<th>Agent</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>运行时间</strong></td>\n<td>短（毫秒级）</td>\n<td>长（秒/分钟级）</td>\n</tr>\n<tr>\n<td><strong>输出类型</strong></td>\n<td>纯文本</td>\n<td>文本 + 结构化数据 + UI 控制</td>\n</tr>\n<tr>\n<td><strong>状态管理</strong></td>\n<td>无状态</td>\n<td>复杂状态机</td>\n</tr>\n<tr>\n<td><strong>交互模式</strong></td>\n<td>单轮 Q&amp;A</td>\n<td>多轮工具调用 + 人机协作</td>\n</tr>\n</tbody>\n</table>\n<div class=\"mermaid\">flowchart TB\n    subgraph Chatbot[\"🤖 传统 Chatbot\"]\n        direction TB\n        U1[\"👤 用户\"] --&gt;|\"文本输入\"| B1[\"💬 Bot\"]\n        B1 --&gt;|\"文本输出\"| U1\n    end\n    \n    subgraph Agent[\"🦾 智能体 Agent\"]\n        direction TB\n        U2[\"👤 用户\"] --&gt;|\"多模态输入\"| A[\"🧠 Agent\"]\n        A --&gt;|\"状态事件\"| SM[\"📊 状态机\"]\n        SM --&gt;|\"UI 更新\"| UI[\"🖥️ 富交互 UI\"]\n        A &lt;--&gt;|\"工具调用\"| T[\"🔧 Tools\"]\n        UI --&gt;|\"用户操作\"| A\n    end\n    \n    Chatbot -.-&gt;|\"演进\"| Agent\n</div><h3 id=\"13-三种协议的定位\">1.3 三种协议的定位</h3>\n<p>业界给出了三种截然不同的解决方案：</p>\n<table>\n<thead>\n<tr>\n<th>协议</th>\n<th>来源</th>\n<th>核心定位</th>\n<th>一句话概括</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>AG-UI</strong></td>\n<td>CopilotKit</td>\n<td>事件驱动的状态同步协议</td>\n<td>\"让前端实时感知 Agent 的每一步思考\"</td>\n</tr>\n<tr>\n<td><strong>A2UI</strong></td>\n<td>Google</td>\n<td>声明式 UI 组件规范</td>\n<td>\"Agent 描述意图，客户端负责渲染\"</td>\n</tr>\n<tr>\n<td><strong>MCP-UI</strong></td>\n<td>社区</td>\n<td>MCP 工具的可视化扩展</td>\n<td>\"让工具调用结果具备可视化能力\"</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h2 id=\"2-ag-ui事件驱动的智能体交互协议\">2. AG-UI：事件驱动的智能体交互协议</h2>\n<h3 id=\"21-设计哲学\">2.1 设计哲学</h3>\n<p>AG-UI（Agent-User Interaction Protocol）的核心理念可以概括为：</p>\n<blockquote>\n<p><strong>\"UI 是前端的领域，Agent 只负责广播状态变化\"</strong></p>\n</blockquote>\n<p>AG-UI 认为：Agent 不应该知道\"按钮是圆的还是方的\"，不应该知道\"当前是 React 还是 Vue\"。Agent 只需要告诉前端：\"我正在调用搜索工具\"、\"搜索参数是 XXX\"、\"搜索结果是 YYY\"。至于如何渲染这些信息，完全由前端决定。</p>\n<p>这种设计带来了几个核心优势：</p>\n<ol>\n<li><strong>前端自由度最大化</strong>：同一个 Agent 可以对接 Web、Mobile、CLI 等不同客户端</li>\n<li><strong>实时性极强</strong>：基于流式事件，用户能看到 Agent 思考的每一步</li>\n<li><strong>与现有应用深度集成</strong>：Agent 可以驱动现有 UI 的状态变化</li>\n</ol>\n<div class=\"mermaid\">flowchart LR\n    subgraph Backend[\"🔙 Agent Backend\"]\n        LLM[\"🧠 LLM\"] --&gt; EP[\"Event Producer\"]\n        Tools[\"🔧 Tools\"] --&gt; EP\n    end\n    \n    subgraph Transport[\"📡 传输层\"]\n        EP --&gt;|\"SSE Stream\"| SSE[\"text/event-stream\"]\n    end\n    \n    subgraph Frontend[\"🖥️ Frontend\"]\n        SSE --&gt; Parser[\"Event Parser\"]\n        Parser --&gt; SM[\"State Machine\"]\n        SM --&gt; |\"TEXT_MESSAGE\"| Chat[\"💬 聊天区\"]\n        SM --&gt; |\"TOOL_CALL\"| TC[\"🔧 工具卡片\"]\n        SM --&gt; |\"STATE_DELTA\"| App[\"📊 应用状态\"]\n    end\n</div><h3 id=\"22-核心机制事件类型系统\">2.2 核心机制：事件类型系统</h3>\n<p>AG-UI 定义了一套完整的事件类型体系（约 20+ 种），按功能可分为四大类：</p>\n<h4 id=\"221-生命周期事件\">2.2.1 生命周期事件</h4>\n<pre><code class=\"language-typescript\">// 源码位置：ag-ui/sdks/typescript/packages/core/src/events.ts\n\nenum EventType {\n  // 运行生命周期\n  RUN_STARTED = \"RUN_STARTED\",      // Agent 开始执行\n  RUN_FINISHED = \"RUN_FINISHED\",    // Agent 执行完成\n  RUN_ERROR = \"RUN_ERROR\",          // Agent 执行出错\n  \n  // 步骤生命周期\n  STEP_STARTED = \"STEP_STARTED\",    // 开始执行某个步骤\n  STEP_FINISHED = \"STEP_FINISHED\",  // 步骤执行完成\n}\n</code></pre>\n<h4 id=\"222-消息流事件\">2.2.2 消息流事件</h4>\n<pre><code class=\"language-typescript\">enum EventType {\n  // 文本消息（流式）\n  TEXT_MESSAGE_START = \"TEXT_MESSAGE_START\",\n  TEXT_MESSAGE_CONTENT = \"TEXT_MESSAGE_CONTENT\",  // delta: 增量文本\n  TEXT_MESSAGE_END = \"TEXT_MESSAGE_END\",\n  TEXT_MESSAGE_CHUNK = \"TEXT_MESSAGE_CHUNK\",      // 批量模式\n  \n  // 思考过程（可选暴露）\n  THINKING_TEXT_MESSAGE_START = \"THINKING_TEXT_MESSAGE_START\",\n  THINKING_TEXT_MESSAGE_CONTENT = \"THINKING_TEXT_MESSAGE_CONTENT\",\n  THINKING_TEXT_MESSAGE_END = \"THINKING_TEXT_MESSAGE_END\",\n}\n</code></pre>\n<h4 id=\"223-工具调用事件\">2.2.3 工具调用事件</h4>\n<pre><code class=\"language-typescript\">enum EventType {\n  // 工具调用生命周期\n  TOOL_CALL_START = \"TOOL_CALL_START\",   // 包含 toolCallId, toolCallName\n  TOOL_CALL_ARGS = \"TOOL_CALL_ARGS\",      // 流式参数：delta 字段\n  TOOL_CALL_END = \"TOOL_CALL_END\",\n  TOOL_CALL_RESULT = \"TOOL_CALL_RESULT\",  // 工具执行结果\n  TOOL_CALL_CHUNK = \"TOOL_CALL_CHUNK\",    // 批量模式\n}\n</code></pre>\n<h4 id=\"224-状态同步事件\">2.2.4 状态同步事件</h4>\n<pre><code class=\"language-typescript\">enum EventType {\n  // 状态管理\n  STATE_SNAPSHOT = \"STATE_SNAPSHOT\",      // 完整状态快照\n  STATE_DELTA = \"STATE_DELTA\",            // 增量状态（JSON Patch RFC 6902）\n  MESSAGES_SNAPSHOT = \"MESSAGES_SNAPSHOT\", // 完整消息历史\n  \n  // 活动状态（用于 UI 展示）\n  ACTIVITY_SNAPSHOT = \"ACTIVITY_SNAPSHOT\",\n  ACTIVITY_DELTA = \"ACTIVITY_DELTA\",\n}\n</code></pre>\n<h3 id=\"23-实现方案传输层与客户端\">2.3 实现方案：传输层与客户端</h3>\n<h4 id=\"231-传输层sse--http-binary\">2.3.1 传输层：SSE + HTTP Binary</h4>\n<p>AG-UI 支持多种传输方式，其中 SSE（Server-Sent Events）是最常用的：</p>\n<pre><code class=\"language-typescript\">// 源码位置：ag-ui/sdks/typescript/packages/client/src/agent/http.ts\n\nexport class HttpAgent extends AbstractAgent {\n  protected requestInit(input: RunAgentInput): RequestInit {\n    return {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Accept: \"text/event-stream\",  // 关键：请求 SSE 格式\n      },\n      body: JSON.stringify(input),\n    };\n  }\n\n  run(input: RunAgentInput): Observable&lt;BaseEvent&gt; {\n    // 1. 发起 HTTP 请求获取 SSE 流\n    const httpEvents = runHttpRequest(this.url, this.requestInit(input));\n    // 2. 转换为 AG-UI 事件流\n    return transformHttpEventStream(httpEvents);\n  }\n}\n</code></pre>\n<p>传输层数据格式示例：</p>\n<pre><code>event: TEXT_MESSAGE_START\ndata: {\"type\":\"TEXT_MESSAGE_START\",\"messageId\":\"msg_001\",\"role\":\"assistant\"}\n\nevent: TEXT_MESSAGE_CONTENT\ndata: {\"type\":\"TEXT_MESSAGE_CONTENT\",\"messageId\":\"msg_001\",\"delta\":\"我来帮您\"}\n\nevent: TEXT_MESSAGE_CONTENT\ndata: {\"type\":\"TEXT_MESSAGE_CONTENT\",\"messageId\":\"msg_001\",\"delta\":\"搜索餐厅...\"}\n\nevent: TOOL_CALL_START\ndata: {\"type\":\"TOOL_CALL_START\",\"toolCallId\":\"call_001\",\"toolCallName\":\"search_restaurants\"}\n\nevent: TOOL_CALL_ARGS\ndata: {\"type\":\"TOOL_CALL_ARGS\",\"toolCallId\":\"call_001\",\"delta\":\"{\\\"cuisine\\\":\\\"川菜\\\"}\"}\n</code></pre>\n<h4 id=\"232-客户端observable--中间件架构\">2.3.2 客户端：Observable + 中间件架构</h4>\n<p>AG-UI 客户端采用 <strong>RxJS Observable</strong> 模式处理事件流，并支持中间件扩展：</p>\n<pre><code class=\"language-typescript\">// 源码位置：ag-ui/sdks/typescript/packages/client/src/agent/agent.ts\n\nexport abstract class AbstractAgent {\n  private middlewares: Middleware[] = [];\n  \n  // 订阅者模式：支持多个消费者\n  public subscribe(subscriber: AgentSubscriber) {\n    this.subscribers.push(subscriber);\n    return { unsubscribe: () =&gt; { /* ... */ } };\n  }\n  \n  // 中间件注册\n  public use(...middlewares: (Middleware | MiddlewareFunction)[]): this {\n    this.middlewares.push(...normalizedMiddlewares);\n    return this;\n  }\n  \n  // 抽象方法：具体 Agent 实现事件流\n  abstract run(input: RunAgentInput): Observable&lt;BaseEvent&gt;;\n}\n</code></pre>\n<h3 id=\"24-对接方式\">2.4 对接方式</h3>\n<h4 id=\"241-服务端对接python-示例\">2.4.1 服务端对接（Python 示例）</h4>\n<pre><code class=\"language-python\"># Demo 项目：demo-agent-ui-protocols/agents/ag-ui-agent/server.py\n\nfrom sse_starlette.sse import EventSourceResponse\n\nasync def generate_events() -&gt; AsyncGenerator[str, None]:\n    # 1. 发送 RUN_STARTED\n    yield create_event(EventType.RUN_STARTED, {\n        \"threadId\": thread_id,\n        \"runId\": run_id\n    })\n    \n    # 2. 流式调用 LLM\n    async for chunk in llm_stream:\n        if chunk.choices[0].delta.content:\n            yield create_event(EventType.TEXT_MESSAGE_CONTENT, {\n                \"messageId\": msg_id,\n                \"delta\": chunk.choices[0].delta.content\n            })\n        \n        if chunk.choices[0].delta.tool_calls:\n            # 处理工具调用...\n            yield create_event(EventType.TOOL_CALL_START, {...})\n    \n    # 3. 发送 RUN_FINISHED\n    yield create_event(EventType.RUN_FINISHED, {\n        \"threadId\": thread_id,\n        \"runId\": run_id\n    })\n\n@app.post(\"/run\")\nasync def run(request: RunRequest):\n    return EventSourceResponse(generate_events())\n</code></pre>\n<h4 id=\"242-前端对接react-示例\">2.4.2 前端对接（React 示例）</h4>\n<pre><code class=\"language-tsx\">// Demo 项目：demo-agent-ui-protocols/apps/web/src/app/ag-ui-demo/page.tsx\n\nconst handleSendMessage = async (content: string) =&gt; {\n  const response = await fetch('http://localhost:8001/run', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ messages: [{ role: 'user', content }] }),\n  });\n  \n  const reader = response.body.getReader();\n  const decoder = new TextDecoder();\n  \n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) break;\n    \n    // 解析 SSE 事件\n    const events = parseSSE(decoder.decode(value));\n    \n    for (const event of events) {\n      switch (event.type) {\n        case 'TEXT_MESSAGE_CONTENT':\n          // 更新消息内容（流式）\n          setMessages(prev =&gt; updateMessageContent(prev, event));\n          break;\n        case 'TOOL_CALL_START':\n          // 显示工具调用 UI\n          setMessages(prev =&gt; addToolCall(prev, event));\n          break;\n        case 'TOOL_CALL_RESULT':\n          // 渲染工具结果\n          setMessages(prev =&gt; updateToolResult(prev, event));\n          break;\n      }\n    }\n  }\n};\n</code></pre>\n<div class=\"mermaid\">stateDiagram-v2\n    [*] --&gt; Idle: 初始化\n    \n    Idle --&gt; Running: RUN_STARTED\n    \n    state Running {\n        [*] --&gt; Streaming\n        Streaming --&gt; ToolCalling: TOOL_CALL_START\n        ToolCalling --&gt; Streaming: TOOL_CALL_RESULT\n        Streaming --&gt; Streaming: TEXT_MESSAGE_CONTENT\n    }\n    \n    Running --&gt; Idle: RUN_FINISHED\n    Running --&gt; Error: RUN_ERROR\n    Error --&gt; Idle: 重试\n</div><hr />\n<h2 id=\"3-a2ui声明式-ui-的零信任渲染引擎\">3. A2UI：声明式 UI 的零信任渲染引擎</h2>\n<h3 id=\"31-设计哲学\">3.1 设计哲学</h3>\n<p>A2UI（Agent-to-User Interface）由 Google 推出，其核心理念是：</p>\n<blockquote>\n<p><strong>\"Safe like data, expressive like code\"</strong>（像数据一样安全，像代码一样有表现力）</p>\n</blockquote>\n<p>与 AG-UI 的\"前端主导\"不同，A2UI 采用\"<strong>后端主导</strong>\"的思路：Agent 不仅发送数据，还发送 <strong>UI 结构描述</strong>。但为了安全，A2UI 绝对不允许 Agent 发送可执行代码（HTML/JS），而是发送一种<strong>声明式的组件描述 JSON</strong>。</p>\n<h4 id=\"311-安全性设计\">3.1.1 安全性设计</h4>\n<p>A2UI 的安全模型基于\"白名单组件库\"（Catalog）机制：</p>\n<pre><code>Agent 只能说：\"我要渲染一个 Card 组件，ID 是 123，标题是 XXX\"\nAgent 不能说：\"&lt;script&gt;alert('XSS')&lt;/script&gt;\"\n</code></pre>\n<p>这种设计完全杜绝了 LLM 生成恶意代码的风险。</p>\n<h4 id=\"312-跨平台设计\">3.1.2 跨平台设计</h4>\n<p>由于 A2UI 发送的是抽象组件描述而非具体实现，同一套协议可以：</p>\n<ul>\n<li>在 <strong>Web</strong> 端渲染为 DOM 元素</li>\n<li>在 <strong>iOS</strong> 端渲染为 SwiftUI View</li>\n<li>在 <strong>Android</strong> 端渲染为 Compose 组件</li>\n<li>在 <strong>Flutter</strong> 中渲染为 Widget</li>\n</ul>\n<div class=\"mermaid\">flowchart TB\n    subgraph Agent[\"🧠 Agent\"]\n        LLM[\"LLM\"] --&gt; Gen[\"A2UI Generator\"]\n    end\n    \n    subgraph Protocol[\"📦 A2UI JSON\"]\n        Gen --&gt; JSON[\"{“updateComponents”: ...}\"]\n    end\n    \n    subgraph Renderers[\"🌐 各平台渲染器\"]\n        JSON --&gt; Web[\"🌐 Web\\nLit/React\"]\n        JSON --&gt; iOS[\"🍎 iOS\\nSwiftUI\"]\n        JSON --&gt; Android[\"🤖 Android\\nCompose\"]\n        JSON --&gt; Flutter[\"🐦 Flutter\\nWidget\"]\n    end\n    \n    subgraph Output[\"📱 原生 UI\"]\n        Web --&gt; O1[\"🖥️ DOM\"]\n        iOS --&gt; O2[\"📱 UIKit View\"]\n        Android --&gt; O3[\"📱 Compose UI\"]\n        Flutter --&gt; O4[\"📱 Widget Tree\"]\n    end\n</div><h3 id=\"32-核心机制邻接表组件模型\">3.2 核心机制：邻接表组件模型</h3>\n<h4 id=\"321-为什么不用嵌套-json\">3.2.1 为什么不用嵌套 JSON？</h4>\n<p>传统的 UI 描述通常采用嵌套结构：</p>\n<pre><code class=\"language-json\">// ❌ 传统嵌套结构 - 对 LLM 不友好\n{\n  \"type\": \"Column\",\n  \"children\": [\n    {\n      \"type\": \"Text\",\n      \"text\": \"Hello\"\n    },\n    {\n      \"type\": \"Button\",\n      \"children\": [{ \"type\": \"Text\", \"text\": \"Click\" }]\n    }\n  ]\n}\n</code></pre>\n<p><strong>问题</strong>：</p>\n<ul>\n<li>LLM 必须一次性生成完美嵌套，容易出错</li>\n<li>难以增量更新（需要重新发送整个树）</li>\n<li>深层嵌套难以流式生成</li>\n</ul>\n<h4 id=\"322-邻接表模型\">3.2.2 邻接表模型</h4>\n<p>A2UI 采用<strong>邻接表</strong>（Adjacency List）结构，将组件树\"拍平\"为列表：</p>\n<pre><code class=\"language-json\">// 源码位置：A2UI/docs/concepts/components.md\n\n// ✅ A2UI 邻接表结构 - LLM 友好\n{\n  \"surfaceUpdate\": {\n    \"surfaceId\": \"main\",\n    \"components\": [\n      {\"id\": \"root\", \"component\": {\"Column\": {\"children\": {\"explicitList\": [\"greeting\", \"buttons\"]}}}},\n      {\"id\": \"greeting\", \"component\": {\"Text\": {\"text\": {\"literalString\": \"Hello\"}}}},\n      {\"id\": \"buttons\", \"component\": {\"Row\": {\"children\": {\"explicitList\": [\"cancel-btn\", \"ok-btn\"]}}}},\n      {\"id\": \"cancel-btn\", \"component\": {\"Button\": {\"child\": \"cancel-text\", \"action\": {\"name\": \"cancel\"}}}},\n      {\"id\": \"cancel-text\", \"component\": {\"Text\": {\"text\": {\"literalString\": \"Cancel\"}}}},\n      {\"id\": \"ok-btn\", \"component\": {\"Button\": {\"child\": \"ok-text\", \"action\": {\"name\": \"ok\"}}}},\n      {\"id\": \"ok-text\", \"component\": {\"Text\": {\"text\": {\"literalString\": \"OK\"}}}}\n    ]\n  }\n}\n</code></pre>\n<p><strong>优势</strong>：</p>\n<ul>\n<li>✅ LLM 可以逐个生成组件，无需考虑嵌套</li>\n<li>✅ 增量更新：只发送变化的组件</li>\n<li>✅ 天然支持流式传输（JSONL 格式）</li>\n</ul>\n<h3 id=\"33-消息类型体系\">3.3 消息类型体系</h3>\n<p>A2UI 定义了四种核心消息类型：</p>\n<pre><code class=\"language-json\">// 源码位置：A2UI/specification/0.9/json/server_to_client.json\n\n{\n  \"oneOf\": [\n    { \"$ref\": \"#/$defs/CreateSurfaceMessage\" },     // 创建 UI 表面\n    { \"$ref\": \"#/$defs/UpdateComponentsMessage\" },  // 更新组件\n    { \"$ref\": \"#/$defs/UpdateDataModelMessage\" },   // 更新数据模型\n    { \"$ref\": \"#/$defs/DeleteSurfaceMessage\" }      // 删除 UI 表面\n  ]\n}\n</code></pre>\n<h4 id=\"331-createsurface初始化-ui-表面\">3.3.1 createSurface：初始化 UI 表面</h4>\n<pre><code class=\"language-json\">{\n  \"createSurface\": {\n    \"surfaceId\": \"restaurant-list\",\n    \"catalogId\": \"a2ui.dev:standard\"  // 声明使用的组件库\n  }\n}\n</code></pre>\n<h4 id=\"332-updatecomponents发送组件定义\">3.3.2 updateComponents：发送组件定义</h4>\n<pre><code class=\"language-json\">{\n  \"updateComponents\": {\n    \"surfaceId\": \"restaurant-list\",\n    \"components\": [\n      {\n        \"id\": \"root\",\n        \"component\": {\n          \"Column\": {\n            \"children\": {\"explicitList\": [\"header\", \"list\"]}\n          }\n        }\n      },\n      {\n        \"id\": \"header\",\n        \"component\": {\n          \"Text\": {\n            \"text\": {\"literalString\": \"推荐餐厅\"},\n            \"usageHint\": \"h1\"\n          }\n        }\n      }\n      // ... 更多组件\n    ]\n  }\n}\n</code></pre>\n<h4 id=\"333-updatedatamodel数据与-ui-分离\">3.3.3 updateDataModel：数据与 UI 分离</h4>\n<p>A2UI 的一个重要设计是<strong>数据模型与组件结构分离</strong>。组件可以通过 <code>path</code> 绑定数据：</p>\n<pre><code class=\"language-json\">// 1. 组件定义（结构）\n{\n  \"updateComponents\": {\n    \"surfaceId\": \"restaurant-list\",\n    \"components\": [{\n      \"id\": \"restaurant-name\",\n      \"component\": {\n        \"Text\": {\n          \"text\": {\"path\": \"/restaurants/0/name\"}  // 数据绑定\n        }\n      }\n    }]\n  }\n}\n\n// 2. 数据更新（内容）\n{\n  \"updateDataModel\": {\n    \"surfaceId\": \"restaurant-list\",\n    \"path\": \"/restaurants/0\",\n    \"op\": \"replace\",\n    \"value\": {\n      \"name\": \"川办餐厅\",\n      \"rating\": 4.8,\n      \"price\": \"$$\"\n    }\n  }\n}\n</code></pre>\n<p><strong>优势</strong>：</p>\n<ul>\n<li>更新数据无需重新发送组件结构</li>\n<li>多个组件可以绑定同一数据路径</li>\n<li>LLM 可以分步生成结构和数据</li>\n</ul>\n<h3 id=\"34-标准组件库catalog\">3.4 标准组件库（Catalog）</h3>\n<p>A2UI 定义了一套标准组件库，涵盖常见 UI 需求：</p>\n<pre><code class=\"language-json\">// 源码位置：A2UI/specification/0.9/json/standard_catalog_definition.json\n\n{\n  \"$defs\": {\n    \"anyComponent\": {\n      \"oneOf\": [\n        // 展示类\n        { \"$ref\": \"#/$defs/Text\" },\n        { \"$ref\": \"#/$defs/Image\" },\n        { \"$ref\": \"#/$defs/Icon\" },\n        { \"$ref\": \"#/$defs/Video\" },\n        { \"$ref\": \"#/$defs/AudioPlayer\" },\n        \n        // 布局类\n        { \"$ref\": \"#/$defs/Row\" },\n        { \"$ref\": \"#/$defs/Column\" },\n        { \"$ref\": \"#/$defs/List\" },\n        \n        // 容器类\n        { \"$ref\": \"#/$defs/Card\" },\n        { \"$ref\": \"#/$defs/Tabs\" },\n        { \"$ref\": \"#/$defs/Modal\" },\n        { \"$ref\": \"#/$defs/Divider\" },\n        \n        // 交互类\n        { \"$ref\": \"#/$defs/Button\" },\n        { \"$ref\": \"#/$defs/CheckBox\" },\n        { \"$ref\": \"#/$defs/TextField\" },\n        { \"$ref\": \"#/$defs/DateTimeInput\" },\n        { \"$ref\": \"#/$defs/ChoicePicker\" },\n        { \"$ref\": \"#/$defs/Slider\" }\n      ]\n    }\n  }\n}\n</code></pre>\n<h3 id=\"35-客户端渲染器renderer\">3.5 客户端渲染器（Renderer）</h3>\n<p>A2UI 提供了多种渲染器实现：</p>\n<pre><code class=\"language-typescript\">// 源码位置：A2UI/renderers/lit/src/0.8/core.ts\n\nexport * as Events from \"./events/events.js\";\nexport * as Types from \"./types/types.js\";\n\nimport { create as createSignalA2uiMessageProcessor } from \"./data/signal-model-processor.js\";\nimport { A2uiMessageProcessor } from \"./data/model-processor.js\";\n\nexport const Data = {\n  createSignalA2uiMessageProcessor,  // 响应式数据处理\n  A2uiMessageProcessor,               // 消息处理器\n  Guards,\n};\n</code></pre>\n<p>渲染流程：</p>\n<ol>\n<li><strong>解析消息</strong>：将 JSONL 解析为消息对象</li>\n<li><strong>构建组件树</strong>：根据邻接表重建树结构</li>\n<li><strong>数据绑定</strong>：将 dataModel 注入组件</li>\n<li><strong>原生渲染</strong>：调用平台原生组件库</li>\n</ol>\n<div class=\"mermaid\">flowchart LR\n    subgraph Input[\"📥 输入\"]\n        JSONL[\"JSONL Stream\"]\n    end\n    \n    subgraph Process[\"⚙️ 处理流程\"]\n        JSONL --&gt; Parse[\"1️⃣ 解析消息\"]\n        Parse --&gt; Build[\"2️⃣ 构建组件树\"]\n        Build --&gt; Bind[\"3️⃣ 数据绑定\"]\n        Bind --&gt; Render[\"4️⃣ 原生渲染\"]\n    end\n    \n    subgraph Output[\"📱 输出\"]\n        Render --&gt; UI[\"原生 UI 组件\"]\n    end\n    \n    subgraph DataFlow[\"📊 数据流\"]\n        DM[(\"DataModel\")] -.-&gt;|\"/path/to/data\"| Bind\n    end\n</div><h3 id=\"36-用户交互action-回传\">3.6 用户交互：Action 回传</h3>\n<p>当用户点击按钮等交互时，客户端发送 <code>userAction</code> 消息：</p>\n<pre><code class=\"language-json\">// 源码位置：A2UI/specification/0.9/json/client_to_server.json\n\n{\n  \"userAction\": {\n    \"name\": \"book_restaurant\",           // action 名称\n    \"surfaceId\": \"restaurant-list\",\n    \"sourceComponentId\": \"book-btn\",\n    \"timestamp\": \"2024-01-07T10:30:00Z\",\n    \"context\": {                         // 上下文数据\n      \"restaurantId\": \"rest_001\",\n      \"restaurantName\": \"川办餐厅\"\n    }\n  }\n}\n</code></pre>\n<h3 id=\"37-对接方式\">3.7 对接方式</h3>\n<h4 id=\"371-服务端对接python-示例\">3.7.1 服务端对接（Python 示例）</h4>\n<pre><code class=\"language-python\"># Demo 项目：demo-agent-ui-protocols/agents/a2ui-agent/server.py\n\nclass A2UIGenerator:\n    @staticmethod\n    def surface_update(surface_id: str, components: list) -&gt; dict:\n        return {\"surfaceUpdate\": {\"surfaceId\": surface_id, \"components\": components}}\n\n    @staticmethod\n    def data_model_update(surface_id: str, path: str, value: any) -&gt; dict:\n        return {\n            \"updateDataModel\": {\n                \"surfaceId\": surface_id,\n                \"path\": path,\n                \"op\": \"replace\",\n                \"value\": value\n            }\n        }\n\nasync def generate_ui(restaurants: list):\n    # 1. 创建 Surface\n    yield json.dumps({\"createSurface\": {\"surfaceId\": \"main\", \"catalogId\": \"standard\"}})\n    \n    # 2. 发送组件结构\n    components = create_restaurant_list_components()\n    yield json.dumps(A2UIGenerator.surface_update(\"main\", components))\n    \n    # 3. 发送数据\n    for i, restaurant in enumerate(restaurants):\n        yield json.dumps(A2UIGenerator.data_model_update(\n            \"main\", \n            f\"/restaurants/{i}\", \n            restaurant\n        ))\n</code></pre>\n<h4 id=\"372-前端对接react-示例\">3.7.2 前端对接（React 示例）</h4>\n<pre><code class=\"language-tsx\">// Demo 项目：demo-agent-ui-protocols/apps/web/src/app/a2ui-demo/A2UIRenderer.tsx\n\nconst A2UIRenderer = ({ messages }: { messages: A2UIMessage[] }) =&gt; {\n  const [components, setComponents] = useState&lt;Map&lt;string, ComponentDef&gt;&gt;();\n  const [dataModel, setDataModel] = useState&lt;Record&lt;string, any&gt;&gt;({});\n  \n  useEffect(() =&gt; {\n    for (const msg of messages) {\n      if (msg.updateComponents) {\n        // 更新组件 Map\n        msg.updateComponents.components.forEach(comp =&gt; {\n          setComponents(prev =&gt; new Map(prev).set(comp.id, comp));\n        });\n      }\n      if (msg.updateDataModel) {\n        // 更新数据模型\n        setDataModel(prev =&gt; ({\n          ...prev,\n          [msg.updateDataModel.path]: msg.updateDataModel.value\n        }));\n      }\n    }\n  }, [messages]);\n  \n  // 递归渲染组件树\n  const renderComponent = (id: string) =&gt; {\n    const comp = components.get(id);\n    if (!comp) return null;\n    \n    // 根据组件类型映射到 React 组件\n    switch (Object.keys(comp.component)[0]) {\n      case 'Text':\n        const textValue = resolveValue(comp.component.Text.text, dataModel);\n        return &lt;span key={id}&gt;{textValue}&lt;/span&gt;;\n      case 'Column':\n        return (\n          &lt;div key={id} className=\"flex flex-col\"&gt;\n            {comp.component.Column.children.explicitList.map(renderComponent)}\n          &lt;/div&gt;\n        );\n      // ... 其他组件\n    }\n  };\n  \n  return renderComponent('root');\n};\n</code></pre>\n<hr />\n<h2 id=\"4-mcp-uimcp-协议的可视化扩展层\">4. MCP-UI：MCP 协议的可视化扩展层</h2>\n<h3 id=\"41-设计哲学\">4.1 设计哲学</h3>\n<p>MCP-UI 是社区基于 Anthropic 的 <strong>Model Context Protocol (MCP)</strong> 开发的 UI 扩展。其核心理念是：</p>\n<blockquote>\n<p><strong>\"让工具调用结果具备可视化能力\"</strong></p>\n</blockquote>\n<p>与 AG-UI、A2UI 不同，MCP-UI 不试图定义新的协议，而是<strong>复用现有的 MCP 协议</strong>，在工具返回值中添加 <code>UIResource</code> 字段。</p>\n<h4 id=\"411-与-mcp-的关系\">4.1.1 与 MCP 的关系</h4>\n<pre><code>MCP 协议：\n  - Tool Definition（工具定义）\n  - Tool Call（工具调用）\n  - Tool Result（工具结果） ← MCP-UI 在这里扩展\n</code></pre>\n<p>MCP-UI 的创新在于：工具不仅可以返回文本/JSON 数据，还可以返回<strong>可交互的 UI 片段</strong>。</p>\n<h3 id=\"42-核心机制uiresource\">4.2 核心机制：UIResource</h3>\n<h4 id=\"421-uiresource-数据结构\">4.2.1 UIResource 数据结构</h4>\n<pre><code class=\"language-typescript\">// 源码位置：mcp-ui/sdks/typescript/server/src/types.ts\n\ninterface UIResource {\n  type: 'resource';\n  resource: {\n    uri: string;       // 唯一标识，如 ui://component/booking-form\n    mimeType: MimeType; // 内容类型\n    text?: string;      // 内联内容\n    blob?: string;      // Base64 编码内容\n    _meta?: Record&lt;string, unknown&gt;;\n  };\n}\n\ntype MimeType =\n  | 'text/html'                           // 内联 HTML\n  | 'text/uri-list'                       // 外部 URL\n  | 'application/vnd.mcp-ui.remote-dom+javascript; framework=react'\n  | 'application/vnd.mcp-ui.remote-dom+javascript; framework=webcomponents';\n</code></pre>\n<h4 id=\"422-三种渲染模式\">4.2.2 三种渲染模式</h4>\n<p>MCP-UI 支持三种不同的 UI 资源类型：</p>\n<p><strong>1. Raw HTML（内联 HTML）</strong></p>\n<pre><code class=\"language-typescript\">{\n  uri: \"ui://restaurant/card\",\n  mimeType: \"text/html\",\n  text: `\n    &lt;div class=\"restaurant-card\"&gt;\n      &lt;h2&gt;川办餐厅&lt;/h2&gt;\n      &lt;button onclick=\"window.parent.postMessage({type:'tool',payload:{toolName:'book'}},'*')\"&gt;\n        预订\n      &lt;/button&gt;\n    &lt;/div&gt;\n  `\n}\n</code></pre>\n<p><strong>2. External URL（外部页面）</strong></p>\n<pre><code class=\"language-typescript\">{\n  uri: \"ui://restaurant/detail\",\n  mimeType: \"text/uri-list\",\n  text: \"https://restaurant.example.com/embed/123\"\n}\n</code></pre>\n<p><strong>3. Remote DOM（远程 DOM）</strong></p>\n<p>这是 MCP-UI 最强大的模式，基于 Shopify 的 <a href=\"https://github.com/Shopify/remote-dom\" rel=\"noopener nofollow\" target=\"_blank\">remote-dom</a> 技术：</p>\n<pre><code class=\"language-typescript\">{\n  uri: \"ui://restaurant/form\",\n  mimeType: \"application/vnd.mcp-ui.remote-dom+javascript; framework=react\",\n  text: `\n    // 这段 JS 在沙箱中执行，通过 JSON 消息与宿主通信\n    const form = document.createElement('ui-form');\n    form.addEventListener('submit', (e) =&gt; {\n      window.postMessage({ type: 'tool', payload: { toolName: 'submit_booking', params: e.detail } });\n    });\n    document.body.appendChild(form);\n  `\n}\n</code></pre>\n<div class=\"mermaid\">flowchart TB\n    subgraph Server[\"🔧 MCP Server\"]\n        Tool[\"Tool Result\"] --&gt; UIRes[\"UIResource\"]\n    end\n    \n    UIRes --&gt; Type{\"mimeType?\"}\n    \n    subgraph Mode1[\"📄 Raw HTML\"]\n        Type --&gt;|\"text/html\"| HTML[\"iframe srcDoc\"]\n        HTML --&gt; Sandbox1[\"🔒 沙箱渲染\"]\n    end\n    \n    subgraph Mode2[\"🌐 External URL\"]\n        Type --&gt;|\"text/uri-list\"| URL[\"iframe src\"]\n        URL --&gt; Sandbox2[\"🔒 外部页面\"]\n    end\n    \n    subgraph Mode3[\"🖥️ Remote DOM\"]\n        Type --&gt;|\"remote-dom\"| Script[\"JS Script\"]\n        Script --&gt; Worker[\"🔒 沙箱执行\"]\n        Worker --&gt;|\"JSON Patch\"| Host[\"🏠 宿主渲染\"]\n    end\n    \n    Sandbox1 &amp; Sandbox2 &amp; Host --&gt; Actions[\"📤 postMessage\"]\n    Actions --&gt; Client[\"📱 客户端处理\"]\n</div><h3 id=\"43-客户端渲染器\">4.3 客户端渲染器</h3>\n<h4 id=\"431-uiresourcerenderer-组件\">4.3.1 UIResourceRenderer 组件</h4>\n<pre><code class=\"language-tsx\">// 源码位置：mcp-ui/sdks/typescript/client/src/components/UIResourceRenderer.tsx\n\nexport const UIResourceRenderer = (props: UIResourceRendererProps) =&gt; {\n  const { resource, onUIAction, supportedContentTypes } = props;\n  const contentType = getContentType(resource);\n\n  switch (contentType) {\n    case 'rawHtml':\n    case 'externalUrl':\n      // 使用 iframe 沙箱渲染\n      return &lt;HTMLResourceRenderer resource={resource} onUIAction={onUIAction} /&gt;;\n      \n    case 'remoteDom':\n      // 使用 Remote DOM 渲染（更安全、更灵活）\n      return &lt;RemoteDOMResourceRenderer resource={resource} onUIAction={onUIAction} /&gt;;\n      \n    default:\n      return &lt;p&gt;Unsupported resource type.&lt;/p&gt;;\n  }\n};\n</code></pre>\n<h4 id=\"432-remote-dom-渲染器\">4.3.2 Remote DOM 渲染器</h4>\n<p>Remote DOM 模式下，UI 逻辑在 iframe 沙箱中执行，但 DOM 变化通过 JSON 消息同步到宿主：</p>\n<pre><code class=\"language-tsx\">// 源码位置：mcp-ui/sdks/typescript/client/src/components/RemoteDOMResourceRenderer.tsx\n\nconst RemoteDOMResourceRenderer: React.FC&lt;RemoteDOMResourceProps&gt; = ({\n  resource, library, onUIAction\n}) =&gt; {\n  const iframeRef = useRef&lt;HTMLIFrameElement&gt;(null);\n  \n  // 1. 创建 Remote Receiver（接收 DOM 变化）\n  const { receiver, components } = useMemo(() =&gt; {\n    const reactReceiver = new RemoteReceiver();\n    // 将组件库映射为 Remote Components\n    // ...\n    return { receiver: reactReceiver, components: componentMap };\n  }, [library]);\n  \n  // 2. 监听 iframe 消息（UI Action）\n  useEffect(() =&gt; {\n    const handleMessage = (event: MessageEvent) =&gt; {\n      if (event.source === iframeRef.current?.contentWindow) {\n        onUIAction?.(event.data as UIActionResult);\n      }\n    };\n    window.addEventListener('message', handleMessage);\n    return () =&gt; window.removeEventListener('message', handleMessage);\n  }, [onUIAction]);\n  \n  // 3. iframe 加载后注入代码\n  const handleIframeLoad = () =&gt; {\n    const thread = new ThreadIframe&lt;SandboxAPI&gt;(iframeRef.current);\n    thread.imports.render({ code: resource.text, ... }, receiver.connection);\n  };\n  \n  return (\n    &lt;&gt;\n      &lt;iframe ref={iframeRef} srcDoc={IFRAME_SRC_DOC} onLoad={handleIframeLoad} /&gt;\n      {/* Remote DOM 渲染结果 */}\n      &lt;RemoteRootRenderer receiver={receiver} components={components} /&gt;\n    &lt;/&gt;\n  );\n};\n</code></pre>\n<h3 id=\"44-ui-action-系统\">4.4 UI Action 系统</h3>\n<p>MCP-UI 定义了五种 UI 交互类型：</p>\n<pre><code class=\"language-typescript\">// 源码位置：mcp-ui/sdks/typescript/client/src/types.ts\n\nexport type UIActionResult =\n  | { type: 'tool', payload: { toolName: string, params: Record&lt;string, unknown&gt; } }\n  | { type: 'prompt', payload: { prompt: string } }\n  | { type: 'link', payload: { url: string } }\n  | { type: 'intent', payload: { intent: string, params: Record&lt;string, unknown&gt; } }\n  | { type: 'notify', payload: { message: string } };\n</code></pre>\n<p><strong>使用场景</strong>：</p>\n<ul>\n<li><code>tool</code>：触发工具调用（如\"预订\"按钮）</li>\n<li><code>prompt</code>：发送新的用户消息</li>\n<li><code>link</code>：打开外部链接</li>\n<li><code>intent</code>：触发应用内意图</li>\n<li><code>notify</code>：显示通知消息</li>\n</ul>\n<h3 id=\"45-对接方式\">4.5 对接方式</h3>\n<h4 id=\"451-服务端对接python-示例\">4.5.1 服务端对接（Python 示例）</h4>\n<pre><code class=\"language-python\"># Demo 项目：demo-agent-ui-protocols/agents/mcp-ui-agent/server.py\n\ndef create_restaurant_card_ui(restaurants: list) -&gt; dict:\n    html = f\"\"\"\n    &lt;div class=\"restaurant-list\"&gt;\n        {''.join([f'''\n        &lt;div class=\"restaurant-card\" data-id=\"{r['id']}\"&gt;\n            &lt;img src=\"{r['image']}\" /&gt;\n            &lt;h3&gt;{r['name']}&lt;/h3&gt;\n            &lt;p&gt;评分: {r['rating']} | 价格: {r['price']}&lt;/p&gt;\n            &lt;button onclick=\"window.parent.postMessage({{\n                type: 'tool',\n                payload: {{\n                    toolName: 'show_booking_form',\n                    params: {{ restaurant_name: '{r['name']}' }}\n                }}\n            }}, '*')\"&gt;预订&lt;/button&gt;\n        &lt;/div&gt;\n        ''' for r in restaurants])}\n    &lt;/div&gt;\n    \"\"\"\n    \n    return {\n        \"type\": \"ui_resource\",\n        \"resource\": {\n            \"uri\": \"ui://restaurant/list\",\n            \"mimeType\": \"text/html\",\n            \"text\": html\n        }\n    }\n\n@app.post(\"/run\")\nasync def run(request: RunRequest):\n    if request.tool_call:\n        # 直接执行工具调用\n        result = execute_tool(request.tool_call.name, request.tool_call.params)\n        return result\n    else:\n        # 让 LLM 决定调用哪个工具\n        response = await call_llm_with_tools(request.messages)\n        return response\n</code></pre>\n<h4 id=\"452-前端对接react-示例\">4.5.2 前端对接（React 示例）</h4>\n<pre><code class=\"language-tsx\">// Demo 项目：demo-agent-ui-protocols/apps/web/src/app/mcp-ui-demo/page.tsx\n\nconst MCPUIDemo = () =&gt; {\n  const [currentUI, setCurrentUI] = useState&lt;UIResource | null&gt;(null);\n  \n  // 处理来自 UI 的 Action\n  useEffect(() =&gt; {\n    const handleMessage = async (event: MessageEvent) =&gt; {\n      const { type, payload } = event.data;\n      \n      if (type === 'tool') {\n        // 调用后端工具\n        const response = await fetch('http://localhost:8003/run', {\n          method: 'POST',\n          body: JSON.stringify({ tool_call: payload }),\n        });\n        const result = await response.json();\n        \n        if (result.type === 'ui_resource') {\n          setCurrentUI(result.resource);\n        }\n      }\n    };\n    \n    window.addEventListener('message', handleMessage);\n    return () =&gt; window.removeEventListener('message', handleMessage);\n  }, []);\n  \n  return (\n    &lt;div&gt;\n      {currentUI &amp;&amp; (\n        &lt;UIResourceRenderer \n          resource={currentUI.resource}\n          onUIAction={handleToolCallback}\n        /&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n</code></pre>\n<hr />\n<h2 id=\"5-协议组合ag-ui--a2ui-的协同架构\">5. 协议组合：AG-UI + A2UI 的协同架构</h2>\n<h3 id=\"51-为什么要组合使用\">5.1 为什么要组合使用？</h3>\n<p>三种协议并非互斥关系，它们可以<strong>协同工作</strong>，发挥各自优势。特别是 <strong>AG-UI + A2UI</strong> 的组合，在 A2UI 官方文档中被明确提及：</p>\n<blockquote>\n<p>\"AG UI translates from A2UI messages to AG UI messages, and handles transport and state sync automatically.\"</p>\n<p>— <a href=\"A2UI/docs/transports.md\" rel=\"noopener nofollow\" target=\"_blank\">A2UI Transports 文档</a></p>\n</blockquote>\n<h3 id=\"52-ag-ui-作为-a2ui-的传输层\">5.2 AG-UI 作为 A2UI 的传输层</h3>\n<p>在这种架构下：</p>\n<ul>\n<li><strong>A2UI</strong> 负责：UI 结构定义、组件规范、数据模型</li>\n<li><strong>AG-UI</strong> 负责：消息传输、状态同步、事件路由</li>\n</ul>\n<div class=\"mermaid\">flowchart TB\n    subgraph Frontend[\"🖥️ Frontend\"]\n        Client[\"AG-UI Client\\n(Events)\"] --&gt; A2UIMsg[\"A2UI Messages\\n(JSON)\"]\n        A2UIMsg --&gt; Renderer[\"A2UI Renderer\\n(Components)\"]\n    end\n    \n    subgraph Transport[\"📡 Transport\"]\n        Client &lt;-.-&gt;|\"SSE Events\"| Server\n    end\n    \n    subgraph Agent[\"🤖 Agent\"]\n        Server[\"AG-UI Server\\n(SSE Stream)\"] --&gt; Generator[\"A2UI Generator\\n(JSONL)\"]\n        Generator --&gt; LLM[\"LLM / Tools\"]\n    end\n    \n    style Frontend fill:#e3f2fd\n    style Transport fill:#fff3e0\n    style Agent fill:#f3e5f5\n</div><h3 id=\"53-实现方式将-a2ui-消息包装为-ag-ui-事件\">5.3 实现方式：将 A2UI 消息包装为 AG-UI 事件</h3>\n<pre><code class=\"language-typescript\">// 伪代码：AG-UI + A2UI 集成\n\n// 1. Agent 生成 A2UI 消息\nconst a2uiMessages = generateA2UIComponents(restaurants);\n\n// 2. 包装为 AG-UI 的 CUSTOM 或 ACTIVITY_SNAPSHOT 事件\nfor (const msg of a2uiMessages) {\n  yield {\n    type: EventType.ACTIVITY_SNAPSHOT,\n    messageId: `a2ui-${Date.now()}`,\n    activityType: \"a2ui\",  // 标记为 A2UI 消息\n    content: msg,          // A2UI 原始消息\n  };\n}\n\n// 3. 前端根据 activityType 路由到 A2UI 渲染器\nagent.subscribe({\n  onActivitySnapshot: (event) =&gt; {\n    if (event.activityType === \"a2ui\") {\n      a2uiRenderer.processMessage(event.content);\n    }\n  }\n});\n</code></pre>\n<h3 id=\"54-ag-ui--mcp-ui-的组合\">5.4 AG-UI + MCP-UI 的组合</h3>\n<p>AG-UI 官方提供了 <code>@ag-ui/mcp-apps-middleware</code>，可以将 MCP-UI 的 UI 资源集成到 AG-UI 事件流中：</p>\n<pre><code class=\"language-typescript\">// 源码位置：ag-ui/middlewares/mcp-apps-middleware/README.md\n\nimport { MCPAppsMiddleware } from \"@ag-ui/mcp-apps-middleware\";\n\nconst agent = new YourAgent().use(\n  new MCPAppsMiddleware({\n    mcpServers: [\n      { type: \"http\", url: \"http://localhost:3001/mcp\" }\n    ],\n  })\n);\n\n// 中间件自动：\n// 1. 发现 MCP Server 的 UI-enabled Tools\n// 2. 将工具注入 Agent 的工具列表\n// 3. 执行工具调用并获取 UIResource\n// 4. 发射 ACTIVITY_SNAPSHOT 事件（activityType: \"mcp-apps\"）\n</code></pre>\n<h3 id=\"55-三协议融合架构\">5.5 三协议融合架构</h3>\n<p>在复杂场景下，三种协议可以同时使用：</p>\n<div class=\"mermaid\">flowchart TB\n    subgraph Frontend[\"🖥️ Frontend\"]\n        subgraph Router[\"AG-UI Event Router\"]\n            TextR[\"📝 Text/Tool\\nRenderer\"]\n            A2UIR[\"📱 A2UI Renderer\\n(a2ui type)\"]\n            MCPR[\"🔧 MCP-UI Renderer\\n(mcp-apps type)\"]\n        end\n    end\n    \n    Router &lt;-.-&gt;|\"SSE Events\"| Server\n    \n    subgraph Agent[\"🤖 Agent\"]\n        subgraph ServerLayer[\"AG-UI Server + Middlewares\"]\n            LLMAdapter[\"LLM Adapter\"]\n            A2AMW[\"A2A Middleware\"]\n            MCPMW[\"MCP-Apps Middleware\"]\n        end\n        \n        LLMAdapter --&gt; LLM[(\"🧠 LLM\\n(OpenAI)\")]\n        A2AMW --&gt; SubAgents[(\"🤝 A2A Agents\\n(Sub-agents)\")]\n        MCPMW --&gt; MCPServers[(\"🔌 MCP Servers\\n(Tools+UI)\")]\n    end\n    \n    style Frontend fill:#e3f2fd\n    style Agent fill:#f3e5f5\n    style Router fill:#e8f5e9\n    style ServerLayer fill:#fff3e0\n</div><p><strong>各协议职责</strong>：</p>\n<ul>\n<li><strong>AG-UI</strong>：作为\"总线\"，负责事件路由和状态同步</li>\n<li><strong>A2UI</strong>：负责复杂的、跨平台的声明式 UI</li>\n<li><strong>MCP-UI</strong>：负责工具级别的快速 UI 扩展</li>\n</ul>\n<hr />\n<h2 id=\"6-技术选型决策框架\">6. 技术选型决策框架</h2>\n<h3 id=\"61-维度对比表\">6.1 维度对比表</h3>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>AG-UI</th>\n<th>A2UI</th>\n<th>MCP-UI</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>核心理念</strong></td>\n<td>事件驱动的状态同步</td>\n<td>声明式 UI 组件规范</td>\n<td>MCP 工具的 UI 扩展</td>\n</tr>\n<tr>\n<td><strong>UI 控制权</strong></td>\n<td>前端主导</td>\n<td>后端主导（结构）</td>\n<td>后端主导（内容）</td>\n</tr>\n<tr>\n<td><strong>安全模型</strong></td>\n<td>依赖前端实现</td>\n<td><strong>最高</strong>（白名单组件）</td>\n<td>中等（iframe 沙箱）</td>\n</tr>\n<tr>\n<td><strong>跨平台能力</strong></td>\n<td>弱（需各端适配）</td>\n<td><strong>最强</strong>（抽象组件）</td>\n<td>中等（Web 优先）</td>\n</tr>\n<tr>\n<td><strong>实时性</strong></td>\n<td><strong>最强</strong>（流式事件）</td>\n<td>中等（JSONL 流）</td>\n<td>弱（Request-Response）</td>\n</tr>\n<tr>\n<td><strong>开发复杂度</strong></td>\n<td>前端复杂</td>\n<td>架构复杂</td>\n<td><strong>最简单</strong></td>\n</tr>\n<tr>\n<td><strong>生态兼容性</strong></td>\n<td>CopilotKit 生态</td>\n<td>Google 生态</td>\n<td>MCP 生态</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"62-场景-协议匹配指南\">6.2 场景-协议匹配指南</h3>\n<h4 id=\"场景-a企业级-copilot-系统\">场景 A：企业级 Copilot 系统</h4>\n<p><strong>需求特征</strong>：</p>\n<ul>\n<li>需要与现有复杂业务系统深度集成</li>\n<li>Agent 需要操作现有 UI 状态（如高亮表格行、填写表单）</li>\n<li>需要实时展示 Agent 思考过程</li>\n</ul>\n<p><strong>推荐方案</strong>：<strong>AG-UI 为主</strong></p>\n<pre><code class=\"language-typescript\">// AG-UI 可以驱动现有 UI 状态\nagent.subscribe({\n  onStateDelta: (event) =&gt; {\n    // 增量更新应用状态\n    applyJsonPatch(appState, event.delta);\n  },\n  onToolCallStart: (event) =&gt; {\n    // 高亮相关 UI 区域\n    highlightUIRegion(event.toolCallName);\n  }\n});\n</code></pre>\n<h4 id=\"场景-b跨平台消费级-app\">场景 B：跨平台消费级 App</h4>\n<p><strong>需求特征</strong>：</p>\n<ul>\n<li>同时支持 Web、iOS、Android</li>\n<li>对安全性要求极高（防止 XSS、幻觉输出）</li>\n<li>需要统一的设计语言</li>\n</ul>\n<p><strong>推荐方案</strong>：<strong>A2UI 为主</strong></p>\n<pre><code class=\"language-json\">// A2UI 一次定义，多端渲染\n{\n  \"updateComponents\": {\n    \"components\": [\n      {\"id\": \"card\", \"component\": {\"Card\": {...}}}\n    ]\n  }\n}\n\n// Web 端：渲染为 &lt;div class=\"card\"&gt;\n// iOS 端：渲染为 SwiftUI Card\n// Android 端：渲染为 Compose Card\n</code></pre>\n<h4 id=\"场景-c开发者工具--ide-插件\">场景 C：开发者工具 / IDE 插件</h4>\n<p><strong>需求特征</strong>：</p>\n<ul>\n<li>需要快速为现有工具添加 UI</li>\n<li>希望第三方开发者能贡献 UI 插件</li>\n<li>不需要复杂的跨平台支持</li>\n</ul>\n<p><strong>推荐方案</strong>：<strong>MCP-UI 为主</strong></p>\n<pre><code class=\"language-typescript\">// MCP Server 返回 UI\nserver.tool(\"show_code_diff\", () =&gt; ({\n  type: \"ui_resource\",\n  resource: {\n    uri: \"ui://diff/viewer\",\n    mimeType: \"text/html\",\n    text: generateDiffHTML(changes)\n  }\n}));\n</code></pre>\n<h4 id=\"场景-d复杂多-agent-系统\">场景 D：复杂多 Agent 系统</h4>\n<p><strong>需求特征</strong>：</p>\n<ul>\n<li>多个 Agent 协作</li>\n<li>既需要实时状态同步，又需要丰富 UI</li>\n<li>需要调用外部 MCP 工具</li>\n</ul>\n<p><strong>推荐方案</strong>：<strong>AG-UI + A2UI + MCP-UI 组合</strong></p>\n<pre><code class=\"language-typescript\">const agent = new OrchestrationAgent()\n  .use(new A2AMiddleware({ agentUrls: [...] }))    // 连接子 Agent\n  .use(new MCPAppsMiddleware({ mcpServers: [...] })) // 连接 MCP 工具\n  .use(new A2UIMiddleware({ catalog: 'standard' })); // 支持 A2UI 渲染\n</code></pre>\n<h3 id=\"63-决策流程图\">6.3 决策流程图</h3>\n<div class=\"mermaid\">flowchart TB\n    Start([\"🚀 开始选型\"]) --&gt; Q1{\"是否需要&lt;br/&gt;跨平台原生渲染？\"}\n    \n    Q1 --&gt;|\"✅ Yes\"| A2UI[\"📱 A2UI 为主&lt;br/&gt;&lt;i&gt;统一定义，多端原生&lt;/i&gt;\"]\n    Q1 --&gt;|\"❌ No\"| Q2{\"是否需要&lt;br/&gt;实时状态同步？\"}\n    \n    Q2 --&gt;|\"✅ Yes\"| AGUI[\"⚡ AG-UI 为主&lt;br/&gt;&lt;i&gt;事件驱动，状态透明&lt;/i&gt;\"]\n    Q2 --&gt;|\"❌ No\"| Q3{\"是否复用&lt;br/&gt;MCP 生态？\"}\n    \n    Q3 --&gt;|\"✅ Yes\"| MCPUI[\"🔧 MCP-UI 为主&lt;br/&gt;&lt;i&gt;工具即 UI，渐进增强&lt;/i&gt;\"]\n    Q3 --&gt;|\"❌ No\"| Custom[\"🎨 自定义方案&lt;br/&gt;&lt;i&gt;根据需求定制&lt;/i&gt;\"]\n    \n    subgraph Combinations[\"💡 组合方案\"]\n        AGUI --&gt; Combo1[\"AG-UI + A2UI&lt;br/&gt;&lt;i&gt;事件传输 + 声明式UI&lt;/i&gt;\"]\n        AGUI --&gt; Combo2[\"AG-UI + MCP-UI&lt;br/&gt;&lt;i&gt;事件传输 + 工具UI&lt;/i&gt;\"]\n        A2UI --&gt; Combo1\n    end\n    \n    style Start fill:#e1f5fe\n    style A2UI fill:#c8e6c9\n    style AGUI fill:#fff3e0\n    style MCPUI fill:#f3e5f5\n    style Custom fill:#ffecb3\n</div><hr />\n<h2 id=\"7-demo-项目实战解析\">7. Demo 项目实战解析</h2>\n<h3 id=\"71-项目结构\">7.1 项目结构</h3>\n<p><code>demo-agent-ui-protocols</code> 项目通过一个统一的\"餐厅搜索\"场景，同时演示三种协议：</p>\n<pre><code>demo-agent-ui-protocols/\n├── apps/web/                 # Next.js 前端\n│   └── src/app/\n│       ├── ag-ui-demo/       # AG-UI 演示页面\n│       ├── a2ui-demo/        # A2UI 演示页面\n│       └── mcp-ui-demo/      # MCP-UI 演示页面\n│\n├── agents/\n│   ├── ag-ui-agent/          # AG-UI Python Agent (port 8001)\n│   ├── a2ui-agent/           # A2UI Python Agent (port 8002)\n│   └── mcp-ui-agent/         # MCP-UI Python Agent (port 8003)\n│\n└── packages/shared/          # 共享类型定义\n</code></pre>\n<h3 id=\"72-同一场景的三种实现对比\">7.2 同一场景的三种实现对比</h3>\n<h4 id=\"721-用户输入\">7.2.1 用户输入</h4>\n<blockquote>\n<p>\"帮我找一家北京的川菜馆\"</p>\n</blockquote>\n<h4 id=\"722-ag-ui-实现\">7.2.2 AG-UI 实现</h4>\n<pre><code>[SSE Stream]\nevent: RUN_STARTED\ndata: {\"runId\":\"run_001\",\"threadId\":\"thread_001\"}\n\nevent: TEXT_MESSAGE_START\ndata: {\"messageId\":\"msg_001\",\"role\":\"assistant\"}\n\nevent: TEXT_MESSAGE_CONTENT\ndata: {\"messageId\":\"msg_001\",\"delta\":\"好的，我来帮您\"}\n\nevent: TEXT_MESSAGE_CONTENT\ndata: {\"messageId\":\"msg_001\",\"delta\":\"搜索北京的川菜馆...\"}\n\nevent: TOOL_CALL_START\ndata: {\"toolCallId\":\"call_001\",\"toolCallName\":\"search_restaurants\"}\n\nevent: TOOL_CALL_ARGS\ndata: {\"toolCallId\":\"call_001\",\"delta\":\"{\\\"cuisine\\\":\\\"川菜\\\",\\\"location\\\":\\\"北京\\\"}\"}\n\nevent: TOOL_CALL_RESULT\ndata: {\"toolCallId\":\"call_001\",\"result\":\"[{\\\"name\\\":\\\"川办餐厅\\\",...}]\"}\n\nevent: TEXT_MESSAGE_CONTENT\ndata: {\"messageId\":\"msg_001\",\"delta\":\"为您找到以下餐厅：\"}\n\nevent: RUN_FINISHED\ndata: {\"runId\":\"run_001\"}\n</code></pre>\n<p><strong>前端效果</strong>：实时展示打字效果 + 工具调用卡片</p>\n<h4 id=\"723-a2ui-实现\">7.2.3 A2UI 实现</h4>\n<pre><code>[JSONL Stream]\n{\"createSurface\":{\"surfaceId\":\"results\",\"catalogId\":\"standard\"}}\n\n{\"updateComponents\":{\"surfaceId\":\"results\",\"components\":[\n  {\"id\":\"root\",\"component\":{\"Column\":{\"children\":{\"explicitList\":[\"header\",\"list\"]}}}},\n  {\"id\":\"header\",\"component\":{\"Text\":{\"text\":{\"literalString\":\"推荐餐厅\"},\"usageHint\":\"h1\"}}},\n  {\"id\":\"list\",\"component\":{\"List\":{\"children\":{\"template\":{\"dataBinding\":\"/restaurants\",\"componentId\":\"card-template\"}}}}}\n]}}\n\n{\"updateDataModel\":{\"surfaceId\":\"results\",\"path\":\"/restaurants\",\"value\":[\n  {\"name\":\"川办餐厅\",\"rating\":4.8,\"price\":\"$$\",\"image\":\"...\"},\n  {\"name\":\"眉州东坡\",\"rating\":4.5,\"price\":\"$$$\",\"image\":\"...\"}\n]}}\n</code></pre>\n<p><strong>前端效果</strong>：原生组件渲染的餐厅卡片列表</p>\n<h4 id=\"724-mcp-ui-实现\">7.2.4 MCP-UI 实现</h4>\n<pre><code class=\"language-json\">// Request\n{ \"messages\": [{ \"role\": \"user\", \"content\": \"帮我找一家北京的川菜馆\" }] }\n\n// Response\n{\n  \"role\": \"assistant\",\n  \"content\": \"好的，这是搜索结果：\",\n  \"ui_resource\": {\n    \"type\": \"resource\",\n    \"resource\": {\n      \"uri\": \"ui://restaurant/list\",\n      \"mimeType\": \"text/html\",\n      \"text\": \"&lt;div class='restaurant-list'&gt;...\"\n    }\n  }\n}\n</code></pre>\n<p><strong>前端效果</strong>：iframe 内嵌的 HTML 卡片</p>\n<h3 id=\"73-运行-demo\">7.3 运行 Demo</h3>\n<pre><code class=\"language-bash\"># 1. 克隆项目\ngit clone https://github.com/MadLongTom/demo-agent-ui-protocols\ncd demo-agent-ui-protocols\n\n# 2. 配置环境变量\ncp .env.example .env\n# 编辑 .env 填入 OPENAI_API_KEY 等\n\n# 3. 安装依赖\n./install.sh\n\n# 4. 启动所有服务\n./run.sh\n\n# 5. 访问 Demo\n# AG-UI:  http://localhost:3000/ag-ui-demo\n# A2UI:   http://localhost:3000/a2ui-demo\n# MCP-UI: http://localhost:3000/mcp-ui-demo\n</code></pre>\n<p><img alt=\"AG-UI\" class=\"lazyload\" /><br />\n<img alt=\"A2UI\" class=\"lazyload\" /><br />\n<img alt=\"MCP-UI\" class=\"lazyload\" /></p>\n<hr />\n<h2 id=\"8-总结与展望\">8. 总结与展望</h2>\n<h3 id=\"81-核心观点回顾\">8.1 核心观点回顾</h3>\n<ol>\n<li>\n<p><strong>AG-UI</strong> 是\"事件总线\"：它不关心 UI 长什么样，只负责把 Agent 的状态变化广播出去。适合需要<strong>深度集成</strong>和<strong>实时反馈</strong>的场景。</p>\n</li>\n<li>\n<p><strong>A2UI</strong> 是\"UI 契约\"：它定义了一套抽象的组件语言，让 Agent 能够\"描述 UI 意图\"而不是\"生成 UI 代码\"。适合<strong>跨平台</strong>和<strong>高安全性</strong>场景。</p>\n</li>\n<li>\n<p><strong>MCP-UI</strong> 是\"UI 插件\"：它让 MCP 工具能够直接返回可视化结果，无需修改宿主应用。适合<strong>快速扩展</strong>和<strong>插件生态</strong>场景。</p>\n</li>\n<li>\n<p><strong>组合使用</strong>是最佳实践：AG-UI 可以作为 A2UI 的传输层，MCP-UI 可以通过中间件集成到 AG-UI。</p>\n</li>\n</ol>\n<h3 id=\"82-未来展望\">8.2 未来展望</h3>\n<table>\n<thead>\n<tr>\n<th>趋势</th>\n<th>预期发展</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>协议融合</strong></td>\n<td>AG-UI 和 A2UI 可能会进一步整合，形成统一的 Agent-UI 标准</td>\n</tr>\n<tr>\n<td><strong>语音交互</strong></td>\n<td>多模态支持（语音输入、语音输出）将成为标配</td>\n</tr>\n<tr>\n<td><strong>边缘计算</strong></td>\n<td>轻量级协议支持设备端 Agent（手机、IoT）</td>\n</tr>\n<tr>\n<td><strong>安全增强</strong></td>\n<td>更完善的沙箱隔离、权限控制机制</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"83-参考资源\">8.3 参考资源</h3>\n<table>\n<thead>\n<tr>\n<th>协议</th>\n<th>官方仓库</th>\n<th>文档</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>AG-UI</td>\n<td><a href=\"https://github.com/ag-ui-protocol/ag-ui\" rel=\"noopener nofollow\" target=\"_blank\">github.com/ag-ui-protocol/ag-ui</a></td>\n<td><a href=\"https://docs.ag-ui.com\" rel=\"noopener nofollow\" target=\"_blank\">docs.ag-ui.com</a></td>\n</tr>\n<tr>\n<td>A2UI</td>\n<td><a href=\"https://github.com/google/A2UI\" rel=\"noopener nofollow\" target=\"_blank\">github.com/google/A2UI</a></td>\n<td><a href=\"https://a2ui.dev\" rel=\"noopener nofollow\" target=\"_blank\">a2ui.org</a></td>\n</tr>\n<tr>\n<td>MCP-UI</td>\n<td><a href=\"https://github.com/idosal/mcp-ui\" rel=\"noopener nofollow\" target=\"_blank\">github.com/idosal/mcp-ui</a></td>\n<td>[mcpui.dev]</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<p><em>本文基于 <code>demo-agent-ui-protocols</code> 项目源码分析，建议读者下载运行体验。如有问题或建议，欢迎交流讨论。</em></p>\n<p><a href=\"https://github.com/MadLongTom/demo-agent-ui-protocols\" rel=\"noopener nofollow\">https://github.com/MadLongTom/demo-agent-ui-protocols</a></p>\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/madtom/\" target=\"_blank\">MadLongTom</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/madtom/p/19452209\" target=\"_blank\">https://www.cnblogs.com/madtom/p/19452209</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-07 14:36</span>&nbsp;\n<a href=\"https://www.cnblogs.com/madtom\">MadLongTom</a>&nbsp;\n阅读(<span id=\"post_view_count\">117</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Java中String类（StringBuffer、StringBuilder）相关",
      "link": "https://www.cnblogs.com/xi-yongqi/p/19454295",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xi-yongqi/p/19454295\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 00:34\">\n    <span>Java中String类（StringBuffer、StringBuilder）相关</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h3 id=\"string是java中用于表示字符串的类位于javalang包下无需手动导入\">String是Java中用于表示字符串的类，位于java.lang包下（无需手动导入）。</h3>\n<h5 id=\"两个核心特性\">两个核心特性：</h5>\n<ol>\n<li>不可变性（Immutable）：String 对象一旦创建，其内部的字符序列就无法被修改。看似修改字符串的操作（如拼接、替换），本质都是创建了一个新的String对象。</li>\n<li>字符串常量池：直接赋值创建的String对象会存入JVM的字符串常量池，目的是复用相同内容的字符串，节省内存。</li>\n</ol>\n<h5 id=\"string对象的两种创建方式\">String对象的两种创建方式</h5>\n<pre><code class=\"language-java\">public class StringCreateDemo {\n    public static void main(String[] args) {\n        // 方式1：直接赋值（推荐）—— 从常量池获取/创建对象\n        String s1 = \"Hello\";\n        String s2 = \"Hello\";\n        // == 比较的是对象的内存地址，s1和s2指向常量池同一个对象\n        System.out.println(s1 == s2); // 输出：true\n\n        // 方式2：new关键字 —— 每次new都会在堆内存创建新对象\n        String s3 = new String(\"Hello\");\n        String s4 = new String(\"Hello\");\n        System.out.println(s3 == s4); // 输出：false\n\n        // 正确比较字符串内容：用equals()方法（String重写了Object的equals）\n        System.out.println(s1.equals(s3)); // 输出：true\n    }\n}\n</code></pre>\n<h5 id=\"string类的常用方法\">String类的常用方法</h5>\n<pre><code class=\"language-java\">public class StringMethodsDemo {\n    public static void main(String[] args) {\n        String str = \"  Hello Java!  \";\n\n        // 1. 获取字符串长度：length()\n        int len = str.length();\n        System.out.println(\"长度：\" + len); // 输出：14（包含首尾空格）\n\n        // 2. 获取指定索引的字符：charAt(int index)（索引从0开始）\n        char c = str.charAt(3);\n        System.out.println(\"索引3的字符：\" + c); // 输出：l\n\n        // 3. 去除首尾空格：trim()（JDK11+可用strip()）\n        String trimStr = str.trim();\n        System.out.println(\"去空格后：\" + trimStr); // 输出：Hello Java!\n\n        // 4. 大小写转换\n        String upperStr = trimStr.toUpperCase(); // 转大写\n        String lowerStr = trimStr.toLowerCase(); // 转小写\n        System.out.println(\"大写：\" + upperStr); // 输出：HELLO JAVA!\n        System.out.println(\"小写：\" + lowerStr); // 输出：hello java!\n\n        // 5. 判断是否包含指定子串：contains(CharSequence s)\n        boolean hasJava = trimStr.contains(\"Java\");\n        System.out.println(\"包含Java？\" + hasJava); // 输出：true\n\n        // 6. 截取子串：substring(int beginIndex[, int endIndex])\n        // 注意：endIndex是结束索引（不包含），左闭右开\n        String sub1 = trimStr.substring(6); // 从索引6截取到末尾\n        String sub2 = trimStr.substring(0, 5); // 截取0-4索引的字符\n        System.out.println(\"sub1：\" + sub1); // 输出：Java!\n        System.out.println(\"sub2：\" + sub2); // 输出：Hello\n\n        // 7. 分割字符串：split(String regex)\n        String[] splitArr = trimStr.split(\" \"); // 按空格分割\n        System.out.println(\"分割后数组：\" + Arrays.toString(splitArr)); // 输出：[Hello, Java!]\n\n        // 8. 替换字符/子串：replace(CharSequence old, CharSequence new)\n        String replaceStr = trimStr.replace(\"Java\", \"World\");\n        System.out.println(\"替换后：\" + replaceStr); // 输出：Hello World!\n\n        // 9. 判断字符串是否为空/空白：isEmpty()、isBlank()（JDK11+）\n        String emptyStr = \"\";\n        String blankStr = \"   \";\n        System.out.println(emptyStr.isEmpty()); // 输出：true\n        System.out.println(blankStr.isBlank()); // 输出：true（JDK11+）\n    }\n}\n</code></pre>\n<h5 id=\"string不可变性的影响\">String不可变性的影响</h5>\n<ul>\n<li>因为String不可变，频繁拼接字符串（如循环中str += \"xxx\"）会创建大量临时对象，效率极低。此时应使用StringBuilder（非线程安全，效率高）或StringBuffer（线程安全，效率稍低）</li>\n</ul>\n<hr />\n<h3 id=\"stringbuffer和stringbuilder\">StringBuffer和StringBuilder</h3>\n<ul>\n<li>它们是可变的字符序列，底层基于可扩容的字符数组实现，修改（拼接、插入、删除）时不会创建新对象，而是直接操作底层数组，效率大幅提升。</li>\n</ul>\n<h5 id=\"stringbuffer和stringbuilder的核心区别\">StringBuffer和StringBuilder的核心区别</h5>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>StringBuffer</th>\n<th>StringBuilder</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>线程安全</td>\n<td>线程安全（方法加了synchronized锁）</td>\n<td>非线程安全（无同步锁）</td>\n</tr>\n<tr>\n<td>执行效率</td>\n<td>稍低（锁的开销）</td>\n<td>更高（无锁的开销）</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>多线程环境（如多线程拼接字符串）</td>\n<td>单线程环境（日常开发绝大多数场景）</td>\n</tr>\n<tr>\n<td>诞生版本</td>\n<td>JDK 1.0</td>\n<td>JDK 1.5（为弥补 StringBuffer 效率问题）</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"常用方法\">常用方法</h5>\n<pre><code class=\"language-java\">import java.util.Arrays;\n\npublic class StringBuildBufferDemo {\n    public static void main(String[] args) {\n        // 1. 创建StringBuilder对象（初始容量16，可指定容量减少扩容次数）\n        StringBuilder sb = new StringBuilder(); // 空构造，初始容量16\n        // StringBuilder sb = new StringBuilder(32); // 指定初始容量，避免频繁扩容\n\n        // 2. 拼接内容：append()（核心方法，支持所有数据类型）\n        sb.append(\"Hello\");\n        sb.append(\" \");\n        sb.append(\"Java\");\n        sb.append(8); // 拼接数字\n        System.out.println(\"拼接后：\" + sb); // 输出：Hello Java8\n\n        // 3. 插入内容：insert(int offset, 内容)\n        sb.insert(6, \"My \"); // 在索引6的位置插入\"My \"\n        System.out.println(\"插入后：\" + sb); // 输出：Hello My Java8\n\n        // 4. 替换内容：replace(int start, int end, String str)（左闭右开）\n        sb.replace(6, 9, \"New\"); // 替换索引6-8的内容为\"New\"\n        System.out.println(\"替换后：\" + sb); // 输出：Hello New Java8\n\n        // 5. 反转字符串：reverse()\n        sb.reverse();\n        System.out.println(\"反转后：\" + sb); // 输出：8avaJ weN olleH\n\n        // 6. 删除内容：delete(int start, int end)\n        sb.delete(0, 1); // 删除索引0的字符（8）\n        System.out.println(\"删除后：\" + sb); // 输出：avaJ weN olleH\n\n        // 7. 转为String（最终使用时一般要转成String）\n        String finalStr = sb.toString();\n        System.out.println(\"最终String：\" + finalStr); // 输出：avaJ weN olleH\n\n        // 8. 获取长度：length()\n        System.out.println(\"当前长度：\" + sb.length()); // 输出：13\n\n        // ================== StringBuffer用法（仅创建方式不同） ==================\n        StringBuffer sbf = new StringBuffer(\"多线程场景\");\n        sbf.append(\"使用StringBuffer\");\n        System.out.println(\"StringBuffer结果：\" + sbf); // 输出：多线程场景使用StringBuffer\n    }\n}\n</code></pre>\n<h5 id=\"三者对比\">三者对比</h5>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>String</th>\n<th>StringBuffer</th>\n<th>StringBuilder</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>可变性</td>\n<td>不可变</td>\n<td>可变</td>\n<td>可变</td>\n</tr>\n<tr>\n<td>线程安全</td>\n<td>是</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>低（频繁操作时）</td>\n<td>中</td>\n<td>高</td>\n</tr>\n<tr>\n<td>引入版本</td>\n<td>JDK 1.0</td>\n<td>JDK 1.0</td>\n<td>JDK 1.5</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h3 id=\"总结\">总结</h3>\n<ul>\n<li>操作少量数据：用 String。</li>\n<li>单线程下操作大量字符串：用 StringBuilder。</li>\n<li>多线程下操作大量字符串：用 StringBuffer。</li>\n<li>判断内容相等：务必使用 equals() 而不是 ==。</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 00:34</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xi-yongqi\">我会替风去</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}