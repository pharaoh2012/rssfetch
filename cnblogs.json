{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "干掉 Claude Code，这个开源 AI 编程工具杀疯了？",
      "link": "https://www.cnblogs.com/yupi/p/19460549",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yupi/p/19460549\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 11:30\">\n    <span>干掉 Claude Code，这个开源 AI 编程工具杀疯了？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"干掉 Claude Code，这个开源 AI 编程工具杀疯了？\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/2225420/202601/2225420-20260109111409828-677596839.png\" />\n        最近我身边很多程序员朋友开始从 Claude Code 转向了另一个工具，正是突然大火的开源项目 OpenCode。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p class=\"md-end-block md-heading\"><span class=\"md-plain\">大家好，我是程序员鱼皮。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Claude Code 一直是大家公认的 AI 编程命令行工具 Top 1，在 AI 和程序员圈子里几乎是神一般的存在。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">但是，这狗玩意儿对中国用户可不太友好……</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">首先，如果你想要使用 Claude Code，就必须要有特殊的网络 + 官方账号，否则就会看到一片红。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">此外，2025 年 9 月，Anthropic 公司不知道抽什么风，突然宣布 <span class=\"md-pair-s \"><strong>全面禁止中国控股企业使用 Claude 服务</strong><span class=\"md-plain\">，不仅包括中国大陆企业，连海外中资控股超过 50% 的公司都在封禁范围内！</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">甚至 Anthropic 还特别点名了中国，把咱们称为 <span class=\"md-pair-s \"><strong>敌对国家</strong><span class=\"md-plain\">！</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">天下苦 Claude Code 久矣！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">但是最近我身边很多程序员朋友开始从 Claude Code 转向了另一个工具，正是突然大火的开源项目 OpenCode。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这玩意只用了半年的时间，就在 GitHub 上涨到了 5.2w Star！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这是个什么概念？比我在 GitHub 上开源的几十个项目的总和加起来都多！慕了慕了……</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">OpenCode 到底是什么？凭什么这么火？</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">啥是 OpenCode？</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://opencode.ai/\" rel=\"noopener nofollow\"><span class=\"md-plain\">OpenCode</span></a><span class=\"md-plain\"> 是一款 100% 开源的 AI 编程命令行工具，可以在 <span class=\"md-pair-s \"><strong>终端、IDE、甚至桌面应用</strong><span class=\"md-plain\"> 中使用。</span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你可能会问：这玩意儿跟 Claude Code 有啥区别？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">试试不就知道了？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">接下来我带大家实操一下，从零开始安装、配置、到实际写代码，一条龙服务~</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">从 0 开始上手 OpenCode</span></h2>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">1、安装运行 OpenCode</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">直接进入 OpenCode 官网，复制一行命令：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">命令如下：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span><span class=\"cm-builtin\">curl&nbsp;<span class=\"cm-attribute\">-fsSL&nbsp;https://opencode.ai/install |&nbsp;<span class=\"cm-builtin\">bash</span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后在终端中执行，就可以完成安装了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">安装完成之后，输入 <span class=\"md-pair-s\"><code>opencode</code><span class=\"md-plain\"> 进入程序，接下来你就可以愉快地使用了~</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">先来个经典的 Hello World，AI 成功给出了回复。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">恭喜，到这里你已经掌握了 OpenCode 的 70% 了。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">2、选择模式和模型</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">OpenCode 支持 2 种模式，默认是 Build 模式，用来构建应用、生成代码。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">按一下 Tab 键，就可以切换到 Plan 模式，用于生成执行计划。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">按一下 <span class=\"md-pair-s\"><code>Ctrl + p</code><span class=\"md-plain\"> 键，可以打开命令面板，里面有几十个内置命令。我们先来试着切换一下大模型：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">默认提供了 4 个免费模型：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">好家伙，连智谱最新的 GLM-4.7 竟然也免费？那我的 Coding Plan 套餐不是白开了？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">除了免费的模型外，OpenCode 支持超多的 AI 模型，你可以自由选择：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">选中模型后，配置自己的 API Key 就好了：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果你之前有 <span class=\"md-pair-s \"><strong>Claude Pro/Max 订阅账号</strong><span class=\"md-plain\">，可以直接登录使用，无缝从 Claude Code 迁移过来。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">3、快捷指令</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">OpenCode 支持斜杠命令，输入 <span class=\"md-pair-s\"><code>/</code><span class=\"md-plain\">，能看到很多操作，比如查看模型列表、查看 Agents、管理 MCP、切换主题等等：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">支持几十个不同的主题，颜值都挺高的，从这点也能看出来 OpenCode 很注重用户的体验：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">输入 <span class=\"md-pair-s\"><code>@</code><span class=\"md-plain\"> 可以快速关联目录文件，给 AI 添加上下文： </span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">4、交互体验</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">相比于 Claude Code，OpenCode 真是把命令行的交互体验拉满了，甚至我觉得它是一个伪装成命令行的桌面应用。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你可以点击某条消息，然后会弹出一个消息动作框，你可以撤回消息和 AI 的回复，也可以复制、或者基于当前对话新开一个对话框。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你可以通过鼠标上下滚动来切换选单，并且可以直接通过鼠标点击进入下一步。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你可以按 <span class=\"md-pair-s\"><code>Ctrl + p</code><span class=\"md-plain\"> 键打开命令面板，然后开启侧边栏：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后界面就变成了这样，你管这叫命令行？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">5、LSP 支持</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">细心的你一定看到了，右边的侧边栏有个 <span class=\"md-pair-s\"><code>LSP</code><span class=\"md-plain\">，这是什么鬼东西？老色批？</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">LSP（Language Server Protocol 语言服务器协议）是微软开发的一种通信协议，用于让代码编辑器和语言服务器之间进行通信。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">简单来说，<span class=\"md-pair-s \"><strong>LSP 就是让编辑器看懂代码的技术。</strong></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如你在 VS Code 里写代码，输入 <span class=\"md-pair-s\"><code>console.</code><span class=\"md-plain\"> 它会自动提示 <span class=\"md-pair-s\"><code>log</code><span class=\"md-plain\">、点击函数名能跳转到代码定义、写错代码会画红线提醒。这些代码编辑器的功能，背后都是 LSP 在干活。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">OpenCode 支持 LSP，意味着 AI 能真正理解你的代码结构，而不是把代码当普通文字瞎猜，改起来更精准。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如我让 AI 介绍我的 AI 答题平台项目中最有价值的代码，LSP 就派上用场了。它能帮 AI 快速定位某段代码在哪里被调用、引用了哪些变量，而不是让 AI 傻傻地全局搜索文本。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">6、回到之前的会话</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果你不小心关闭了 OpenCode，不用担心，可以打开命令面板，选中 “Switch session” 切换会话：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">就能回到之前的聊天了：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">桌面版 OpenCode</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">即使 OpenCode 支持了这么多改进用户体验的交互，但我估计大多数同学还是不喜欢小黑框的。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">没关系，OpenCode 还提供了桌面应用版本！macOS、Windows、Linux 全端支持，这是真的要卷死 Claude Code 的节奏啊……</span></p>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">指路：<span class=\"md-link md-pair-s\"><a href=\"https://opencode.ai/download\" rel=\"noopener nofollow\">https://opencode.ai/download</a></span></span></p>\n</blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不过当我怀着满腔热血安装并打开它时，竟然报错了！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">经过一番排查，发现原来是我开了代理，关闭之后就正常运行了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">但是用惯了 Cursor，这个交互体验真的有点敷衍了，不推荐大家使用。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">OpenCode 扩展能力</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">到目前为止，我觉得 OpenCode 在前端用户体验上全方面碾压 Claude Code，而且 OpenCode 完全兼容 Claude Code 的 Skills 系统！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Skills 是一种给 AI 准备的能力扩展包。你可以把它理解成给新同事准备的工作交接文档，里面包含任务执行方法、工具使用说明、模板素材等。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如你可以创建一个 <span class=\"md-pair-s\"><code>公司代码规范 Skill</code><span class=\"md-plain\">，把代码风格、命名规则、注释要求等写进去。之后 Claude Code 生成的代码就会自动遵循这些规范，不用每次都重复说明。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">根据官方文档，OpenCode 会自动搜索这些位置的 Skills：</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>.opencode/skill/&lt;name&gt;/SKILL.md</code><span class=\"md-plain\">（项目目录）</span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>~/.config/opencode/skill/&lt;name&gt;/SKILL.md</code><span class=\"md-plain\">（用户目录）</span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>.claude/skills/&lt;name&gt;/SKILL.md</code><span class=\"md-plain\">（Claude Code 兼容）</span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>~/.claude/skills/&lt;name&gt;/SKILL.md</code><span class=\"md-plain\">（Claude Code 兼容）</span></span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">也就是说，如果你之前给 Claude Code 创建过自定义 Skills，直接拿过来就能用！又是无缝迁移。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">Oh My OpenCode 开挂插件</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果你觉得 OpenCode 还不够强，可以试试 <span class=\"md-pair-s\"><code>Oh My OpenCode</code><span class=\"md-plain\"> 这个开源的 OpenCode 增强插件，已经 1w Star 了。</span></span></span></p>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">项目地址：<span class=\"md-link md-pair-s\"><a href=\"https://github.com/code-yeongyu/oh-my-opencode\" rel=\"noopener nofollow\">https://github.com/code-yeongyu/oh-my-opencode</a></span></span></p>\n</blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这个插件有多牛？看看用户评价：</span></p>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">\"It made me cancel my Cursor subscription.\"（它让我取消了 Cursor 订阅）</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">\"Knocked out 8000 eslint warnings with Oh My Opencode, just in a day\"（一天内用它解决了 8000 个 eslint 警告）</span></p>\n</blockquote>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Oh My OpenCode 的核心功能是引入了一个叫 <span class=\"md-pair-s \"><strong>Sisyphus</strong><span class=\"md-plain\"> 的智能体编排系统。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我特地去搜了一下：</span></p>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">西西弗斯（Sisyphus）是古希腊神话中一位因欺骗众神、挑战权威而被诸神惩罚的国王，他的惩罚是永无止境地将一块巨石推上山顶，而石头一到山顶便会滚落，如此周而复始，象征着徒劳无功、永无休止的任务，也代表着一种对荒诞命运的抗争精神。</span></p>\n</blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这个系统可以：</span></p>\n<ol class=\"ol-list\" start=\"\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">并行调度多个 AI 模型：比如让 GPT debug 的同时让 Gemini 写前端</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">自动任务管理：不完成任务不让停，像西西弗斯推石头一样锲而不舍</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">智能代码审查：自动检测并清理 AI 生成的冗余注释</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">LSP 深度集成：提供重命名、跳转定义等 IDE 级功能</span></p>\n</li>\n</ol>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">简单来说，Sisyphus 就是一个 AI 监工，它能同时指挥多个 AI 模型干活，还会盯着它们把任务做完。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">虽然官方说用一行命令就能完成安装，但我建议你先安装 bun，再执行 npx 来安装，否则可能会报错。</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span><span class=\"cm-builtin\">npm&nbsp;install bun&nbsp;<span class=\"cm-attribute\">-g<br /><span>npx oh-my-opencode install</span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">安装过程中，可能会问你有没有某些模型的订阅，我反正啥都没有，一直选 \"No\" 就行了：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">安装完成后，再次进入 OpenCode，之后只需要在你的提示词里加上 <span class=\"md-pair-s\"><code>ultrawork</code><span class=\"md-plain\">（或 <span class=\"md-pair-s\"><code>ulw</code><span class=\"md-plain\">）这个开挂咒语，就能激活全部增强功能。自动调度多个 AI 模型同时工作、深度探索代码库、锲而不舍地执行。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">下面我们试试看，正好来验证一下 OpenCode 做项目的能力如何？能不能把 Claude Code 一脚踹飞？</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">实战项目 - 用 OpenCode 做个 AI 健康助手</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">最近蚂蚁集团的 <span class=\"md-pair-s\"><code>蚂蚁阿福</code><span class=\"md-plain\"> AI 健康助手火了，地铁口、公司楼下的电视广告中随处可见何炅老师的身影。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">虽然我还没有用过它，但是听说它可以通过拍皮肤、拍报告提供 AI 初诊，还能智能回答医学科普和治疗建议。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">那我们也来做个类似的健康小助手网站吧！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">前有蚂蚁阿福，今有鱼皮阿坤。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">先分析一下，我们要做的是包含前端 + 后端的全栈项目，而且后端还需要调用 AI 大模型来生成内容。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这里我选择用 <span class=\"md-pair-s \"><strong>Vercel AI Gateway</strong><span class=\"md-plain\"> 来实现 AI 能力，这是一款简单易用的 AI 网关。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">什么是 AI 网关？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">简单来说，它就像是火车站的检票口，你的应用发来的请求先经过网关，网关帮你处理认证、限流、监控等一系列复杂的操作，然后把请求转发给 AI 大模型。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">而且 Vercel AI Gateway 支持对接 500 多个大模型，还有免费额度，非常适合学习和小项目。</span></p>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">指路：<span class=\"md-link md-pair-s\"><a href=\"https://vercel.com/ai-gateway\" rel=\"noopener nofollow\">https://vercel.com/ai-gateway</a></span></span></p>\n</blockquote>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">1）首先你需要注册登录 Vercel，然后在控制台创建 API Key，注意不要泄露哦：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">2）启动 OpenCode，切换模型到编程能力很强、并且免费的 GLM-4.7，然后输入这段提示词：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>你是一位专业的程序员，请帮我开发《每日健康小助手》网站，用户可以通过和 AI 聊天来记录和管理每日健康状态。<br /><span><span>​<br /><span><span class=\" cm-header cm-header2\">## 开发要求<br /><span><span>​<br /><span><span class=\"cm-block-start cm-variable-2\">1.&nbsp;<span class=\"cm-variable-2\">需要包含完整的前端和后端，后端使用 Node.js<br /><span><span class=\"cm-block-start cm-variable-2\">2.&nbsp;<span class=\"cm-variable-2\">使用 Vercel 的 AI Gateway 实现 AI 能力，需要先通过官方文档来获取用法：https://vercel.com/docs/ai-gateway/getting-started<br /><span><span class=\"cm-block-start cm-variable-2\">3.&nbsp;<span class=\"cm-variable-2\">以完成核心功能为目标，确保项目可以正常运行<br /><span><span class=\"cm-block-start cm-variable-2\">4.&nbsp;<span class=\"cm-variable-2\">整体网站界面采用清新的绿色健康风格，响应式适配各种尺寸的设备<br /><span><span class=\"cm-block-start cm-variable-2\">5.&nbsp;<span class=\"cm-variable-2\">AI 需要主动询问用户的健康状况，比如睡眠、运动、饮食等</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">点击发送后，OpenCode 会自动使用网页抓取工具读取 Vercel AI Gateway 的官方文档，学习最新的用法：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">大概 5 分钟左右，AI 就完成了全部代码的生成，并且自动安装了依赖。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">3）我直接把之前拿到的 Vercel 的 API Key 提供给 AI，让它帮我启动项目：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">4）启动项目成功后，打开浏览器访问 <span class=\"md-pair-s\"><code>localhost:3000</code><span class=\"md-plain\">，测试一下效果。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">结果报错了！无法调用 AI。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">可能是 AI 对 Vercel AI Gateway 文档的理解不到位，导致写错了调用 AI 的代码。于是我再次把文档输入给 AI，让它再战一次：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">结果又报错了，明明我已经给 AI 提供了 API Key，系统还是报错 “缺少 API Key”。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">于是我又调了一次 AI，告诉它 “这个 key 我之前已经提供给你了”。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">经过大概 5 次左右的报错和修复，仍然不能正常使用！我麻了啊……</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">于是，我有一个鬼点子：既然要跟 Claude Code 比较，那我不妨尝试用 Claude Code 修复这个 OpenCode 解决不了的问题？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">试试看！输入提示词：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>现在项目后端 AI 功能不可用<br /><span>请参考 https://vercel.com/docs/ai-gateway/getting-started 文档<br /><span>帮我修复后端，确保项目能正常运行</span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Claude Code 成功修复了问题，终于能够正常使用了：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">💡 注意，如果你遇到了调用 AI 网络超时的问题，可以让 AI 把调用的 baseURL 改为 <span class=\"md-link md-pair-s\"><a href=\"https://ai-gateway.vercel.sh/v1\" rel=\"noopener nofollow\">https://ai-gateway.vercel.sh/v1</a></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">之前类似的任务我用 Claude Code / Cursor + GLM，不到 10 分钟就搞定了。这次竟然花了 20 分钟左右，还要经过来回拉扯，才能正常使用。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这让我不得不怀疑 OpenCode 的能力了。而且感觉 GLM 大模型在 OpenCode 中好像变笨了，不知道是不是我的错觉…… </span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不行，大家把 OpenCode 吹得这么牛批，我得再试试，一定是我用法的问题！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">Ultrawork 模式</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">还记得前面提到的 <span class=\"md-pair-s\"><code>ultrawork</code><span class=\"md-plain\">（或 <span class=\"md-pair-s\"><code>ulw</code><span class=\"md-plain\">）开挂咒语么？搞起！</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">进入战斗状态了：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">可以查看子代理运行详情，先按 <span class=\"md-pair-s\"><code>Ctrl + x</code><span class=\"md-plain\"> 键，再按方向键来查看不同的代理。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">而且当后台任务完成时，会有一个提示。可以看到 “研究 Vercel AI SDK 对话模式” 的任务已经完成。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不过你猜怎么着？我等了将近 10 分钟，任务还没结束……</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">看看这个任务列表，需要这么复杂吗？连数据库都给我干出来了？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img alt=\"=\" class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我已经没耐心等下去了，毁灭吧！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">看来这种不算太复杂的工作并不能发挥出多代理的优势。就像你只是要打印一张纸，没必要发动全公司的人，有的研究打印的纸张类型、有的研究打印机的状态、有的研究怎么打印姿势更优雅。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">最后</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">经过上述简单的测试，我暂时对 OpenCode 保持观望状态。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">前端做的确实很不错，但后端的能力感觉跟 Claude Code 还有差距。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果只是追求前端使用方便，那我为什么不用 Cursor？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不过 OpenCode 的成功说明了一个道理：<span class=\"md-pair-s \"><strong>谁离用户近、谁能发现痛点，谁就有超越巨头的机会。</strong></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Claude Code 确实很强，但它对中国用户的封禁，给了开源社区一个绝佳的机会。OpenCode 抓住了这个痛点，用更开放的方式赢得了用户的心。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">虽然效果有待提高，但毕竟 OpenCode 完全开源免费，对于喜欢折腾的程序员来说，可定制性更强。你甚至可以 fork 一份自己魔改，想怎么玩就怎么玩。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">OK，就聊到这里。你用过 OpenCode 吗？欢迎评论区聊聊你的体验~</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">更多编程学习资源</span></h2>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course\" rel=\"noopener nofollow\"><span class=\"md-plain\">Java前端程序员必做项目实战教程+毕设网站</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费编程学习交流社区（自学必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course/cv\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员保姆级求职写简历指南（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.mianshiya.com/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费面试刷题网站工具（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640584449888772098\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Java零基础入门学习路线 + Java教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586673306091521\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Python零基础入门学习路线 + Python教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586014108303362\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新前端零基础入门学习路线 + 前端教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586867363954689\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据结构和算法零基础入门学习路线 + 算法教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1644279832026075138\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新C++零基础入门学习路线、C++教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641797333479903234\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据库零基础入门学习路线 + 数据库教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640589994284695553\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Redis零基础入门学习路线 + Redis教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641035880439271426\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机基础入门学习路线 + 计算机基础教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641366118197153793\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新小程序入门学习路线 + 小程序开发教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"http://sqlmother.yupi.icu/\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新SQL零基础入门学习路线 + SQL教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586295529324545\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Linux零基础入门学习路线 + Linux教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588753362108417\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Git/GitHub零基础入门学习路线 + Git教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640587909942099969\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新操作系统零基础入门学习路线 + 操作系统教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588119619551233\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机网络零基础入门学习路线 + 计算机网络教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588392073150465\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新设计模式零基础入门学习路线 + 设计模式教程</span></a></span></p>\n</li>\n<li class=\"md-list-item md-focus-container\">\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-meta-i-c md-link md-expand\"><a href=\"https://www.code-nav.cn/post/1640648711119892481\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新软件工程零基础入门学习路线 + 软件工程教程</span></a></span></p>\n</li>\n</ul>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 11:30</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yupi\">程序员鱼皮</a>&nbsp;\n阅读(<span id=\"post_view_count\">66</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "线程池和高并发",
      "link": "https://www.cnblogs.com/philry/p/19359433",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/philry/p/19359433\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 09:14\">\n    <span>线程池和高并发</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<div>\n<div><strong><span style=\"font-size: 18px;\">多线程</span></strong></div>\n<div><strong><span style=\"font-size: 16px;\">Java创建线程的几种方式有哪些？</span></strong></div>\n<div>常见有以下五种方式创建使用多线程：</div>\n<div><strong>1）实现&nbsp;Runnable&nbsp;接口：</strong></div>\n<ul>\n<li>\n<div>实现&nbsp;Runnable&nbsp;接口的&nbsp;run()&nbsp;方法，使用&nbsp;Thread&nbsp;类的构造函数传入&nbsp;Runnable&nbsp;对象，调用&nbsp;start()&nbsp;方法启动线程。</div>\n</li>\n<li>\n<div>例子：Thread thread = new Thread(new MyRunnable()); thread.start();</div>\n</li>\n</ul>\n<div><strong>2）继承&nbsp;Thread&nbsp;类：</strong></div>\n<ul>\n<li>\n<div>继承&nbsp;Thread&nbsp;类并重写&nbsp;run()&nbsp;方法，直接创建&nbsp;Thread&nbsp;子类对象并调用&nbsp;start()&nbsp;方法启动线程。</div>\n</li>\n<li>\n<div>例子：MyThread thread = new MyThread(); thread.start();</div>\n</li>\n</ul>\n<div><strong>3）使用&nbsp;Callable&nbsp;和&nbsp;FutureTask：</strong></div>\n<ul>\n<li>\n<div>实现&nbsp;Callable&nbsp;接口的&nbsp;call()&nbsp;方法，使用&nbsp;FutureTask&nbsp;包装&nbsp;Callable&nbsp;对象，再通过&nbsp;Thread&nbsp;启动。</div>\n</li>\n<li>\n<div>例子：FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(new MyCallable()); Thread thread = new Thread(task); thread.start();</div>\n</li>\n</ul>\n<div><strong>4）使用线程池（ExecutorService）：</strong></div>\n<ul>\n<li>\n<div>通过&nbsp;ExecutorService&nbsp;提交&nbsp;Runnable&nbsp;或&nbsp;Callable&nbsp;任务，不直接创建和管理线程，适合管理大量并发任务。</div>\n</li>\n<li>\n<div>例子：ExecutorService executor = Executors.newFixedThreadPool(10); executor.submit(new MyRunnable());</div>\n</li>\n</ul>\n<div><strong>5）CompletableFuture（本质也是线程池，默认 forkjoinpool）：</strong></div>\n<ul>\n<li>\n<div>Java 8 引入的功能，非常方便地进行异步任务调用，且通过&nbsp;thenApply、thenAccept&nbsp;等方法可以轻松处理异步任务之间的依赖关系。</div>\n</li>\n<li>\n<div>CompletableFuture&lt;Void&gt; future1 = CompletableFuture.runAsync(() -&gt; {});</div>\n</li>\n</ul>\n<div>\n<div>&nbsp;</div>\n<div><strong><span style=\"font-size: 18px;\">线程生命周期及五种状态</span></strong></div>\n<div><img class=\"lazyload\" width=\"476\" /></div>\n<h3>&nbsp;</h3>\n<h3>1、New(初始化状态)</h3>\n<div>&nbsp;&nbsp; &nbsp;用new语句创建的线程处于新建状态，此时它和其他Java对象一样，仅仅在堆区中被分配了内存。如：Thread t = new MyThread();</div>\n<div>2、Runnable(就绪状态)</div>\n<div>&nbsp;&nbsp; &nbsp;当调用线程对象的start()方法，线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，Java虚拟机会为它创建方法调用栈和程序计数器。处于这个状态的线程位于可运行池中，等待获得CPU的使用权，并不是说执行了start()此线程立即就会执行。</div>\n<h3>3、Running(运行状态)</h3>\n<div>&nbsp;&nbsp; &nbsp;当就绪状态中的线程获得了CUP执行资源，执行run()中的代码，这样的线程我们称为运行状态的线程。</div>\n<div>4、Blocked(阻塞状态)</div>\n<div>&nbsp; &nbsp; 处于运行中的线程，由于某种原因放弃对cpu的使用权，处于阻塞状态，直到其进入就绪状态，才有机会再次被cpu调用进入运行状态。</div>\n<div>根据阻塞原因不同，阻塞分为三种：</div>\n<div>等待阻塞：运行状态中的线程执行wait方法，进入等待队列，等待阻塞；Java虚拟机就会把线程放到这个对象的等待池中；</div>\n<div>同步阻塞：线程获取同步锁失败（因为锁被其他线程占用），Java虚拟机就会把这个线程放到这个对象的锁池中；</div>\n<div>其他阻塞：通过调用sleep方法或者join方法或者发出I/O请求时，线程会进入阻塞状态，当sleep()状态超时，或者join()等待线程终止或者超时，或者I/O处理完毕，线程重新转入就绪状态；</div>\n<h3>5、Terminated（终止状态)</h3>\n<div>\n<div>\n<div>&nbsp;&nbsp; &nbsp;正常结束，线程执行完</div>\n<div>&nbsp;&nbsp; &nbsp;异常退出</div>\n</div>\n</div>\n<div>\n<div>\n<div>&nbsp;&nbsp; &nbsp;异常退出，除了程序有问题导致的异常的退出，还可以使用共享变量的方式（定义个boolean标识等）退出，或者Interrupt中断线程,抛出异常，捕获异常break，跳出循环状态；</div>\n<div>&nbsp;&nbsp; &nbsp;调用stop()，会造成死锁，线程不安全，不建议使用</div>\n<div>&nbsp;</div>\n<div><strong><span style=\"font-size: 18px;\">线程基本方法</span></strong></div>\n<div>1、线程等待（wait）</div>\n<div>&nbsp; &nbsp;&nbsp;调用该方法，线程进入waiting状态，只有等待另外的线程通知或被中断才会返回，调用wait()后，会释放对象锁，因为wait方法一般用在同步方法或者同步代码块中。</div>\n<div>2、线程睡眠（sleep）</div>\n<div>强迫一线程睡 N毫秒，sleep不会释放当前锁，导致线程进入Timed-wating状态。</div>\n<div>3、线程让步（yield）</div>\n<div>&nbsp; &nbsp; yeild会使当前线程让出cpu执行时间片，与其他线程一起重新竞争cpu时间片，一般情况下，优先级高的先得到，但也不一定，有的系统对优先级不敏感。</div>\n<div>4、线程中断（interrupt）</div>\n<div>&nbsp; &nbsp; 在run内部根据thread.isIterrupted() 安全终止线程。调用一个线程的interrupt() 方法中断一个线程，并不是强行关闭这个线程，仅仅是改变了内部维护的中断标识位，是线程固有的一个标识位。可以调用static方法isIterrupted() 判定当前线程是否处于中断状态：</div>\n<div>&nbsp; &nbsp; 1）如果一个正常线程，调用interrupt() ，是不能被打断的，打印中断标志位置为true</div>\n<div>&nbsp; &nbsp; 2）如果一个sleep或者wait的线程，调用interrupt() ，方法则抛出InterruptedException( InterruptedException表示一个阻塞被中断了)，线程的中断标志位会被复位成false；相当于用异常响应了这个中断，所以释放中断标志位。</div>\n<div>5、join（等待其他线程终止）</div>\n<div>&nbsp; &nbsp; 当前线程调用join（），则线程转为阻塞状态，eg：A线程中插入了B.join()，则B先执行，执行完，A线程继续执行；常见的是主线程生成并启动了子线程，需要用到子线程返回结果的场景；</div>\n<div>6、线程唤醒（notify）</div>\n<div>&nbsp; &nbsp; Object类中的notify唤醒在此对象监视器上等待的单个线程；</div>\n<div>&nbsp; &nbsp; notifyAll唤醒在此对象监视器上等待的所有线程；</div>\n<div>7、其他常用方法</div>\n</div>\n<table><colgroup><col /><col /></colgroup>\n<tbody>\n<tr>\n<td>\n<div>方法功能</div>\n</td>\n<td>\n<div>方法名</div>\n</td>\n</tr>\n<tr>\n<td>\n<div>&nbsp;判断一个线程是否存活；</div>\n</td>\n<td>\n<div>isAlive()&nbsp;&nbsp;</div>\n</td>\n</tr>\n<tr>\n<td>\n<div>程序中活跃的线程数；</div>\n</td>\n<td>\n<div>activeCount()&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;</div>\n</td>\n</tr>\n<tr>\n<td>\n<div>得到当前线程；</div>\n</td>\n<td>\n<div>currentThread()&nbsp;&nbsp; &nbsp;</div>\n</td>\n</tr>\n<tr>\n<td>\n<div>设置一个线程的优先级；</div>\n</td>\n<td>\n<div>setPriority()&nbsp; &nbsp;</div>\n</td>\n</tr>\n<tr>\n<td>\n<div>获取一个线程的优先级；</div>\n</td>\n<td>\n<div>getPriority()&nbsp;&nbsp; &nbsp;&nbsp;</div>\n</td>\n</tr>\n<tr>\n<td>\n<div>线程是否为守护线程；</div>\n</td>\n<td>\n<div>isDaemon()&nbsp;&nbsp; &nbsp;&nbsp;</div>\n</td>\n</tr>\n</tbody>\n</table>\n<div>&nbsp;</div>\n</div>\n</div>\n<div>&nbsp;</div>\n<div>&nbsp;</div>\n<div><strong><span style=\"font-size: 18px;\">线程池</span></strong></div>\n<div>线程池的基本概念是，在应用程序启动时创建一定数量的线程，并将它们保存在线程池中。当需要执行任务时，从线程池中获取一个空闲的线程，将任务分配给该线程执行。当任务执行完毕后，线程将返回到线程池，可以被其他任务复用。</div>\n<div>线程池创建有两种方式，一种是Executors使用默认方法创建，另一种是通过ThreadPoolExecutor自定义，不推荐前者是因为前者的配置很多都是取得integer得最大值，很容易造成OOM。</div>\n<div>工作中就是需要以new ThreadPoolExecutor的方式创建线程池的，其余的不安全。&nbsp; &nbsp;&nbsp;</div>\n<div>\n<div><img class=\"lazyload\" width=\"692\" /></div>\n</div>\n<div>使用线程池的一般步骤如下：&nbsp;</div>\n<div>\n<div>1、创建线程池：使用ThreadPoolExecutor类来创建线程池。</div>\n<div>&nbsp;&nbsp; &nbsp;ExecutorService executor = Executors.newFixedThreadPool(5); // 创建固定大小的线程池&nbsp;</div>\n</div>\n<div>\n<div>2、提交任务：将任务提交给线程池。</div>\n<div>&nbsp;&nbsp; &nbsp;executor.execute(new MyRunnable()); // 提交Runnable任务</div>\n<div>&nbsp;&nbsp; &nbsp;Future&lt;String&gt; future = executor.submit(new MyCallable()); // 提交Callable任务，并返回Future对象</div>\n</div>\n<div>\n<div>3、关闭线程池：在不再需要线程池时，需要调用shutdown()方法来关闭线程池。这将停止接受新任务，并逐渐关闭线程池中的线程。</div>\n<div>&nbsp;&nbsp; &nbsp;executor.shutdown();</div>\n</div>\n<div>\n<div>&nbsp;&nbsp; &nbsp;<strong><span style=\"font-size: 16px;\">线程池核心概念：</span></strong></div>\n</div>\n<div>　&nbsp;&nbsp;int &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;corePoolSize　　　&nbsp;&nbsp; 核心线程数</div>\n<div>　　int &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;maximumPoolSize　最大线程数</div>\n<div>　　long&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;keepAliveTime　　&nbsp; &nbsp;空闲线程最大存活时间</div>\n<div>　　TimeUnit &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; unit　　　　　　&nbsp; &nbsp; &nbsp; &nbsp;时间单位，m，h，d</div>\n<div>　　BlockingQueue&lt;Runnable&gt; workQueue　　&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;阻塞任务队列</div>\n<div>　　ThreadFactory &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; threadFactory　　&nbsp; &nbsp; 创建线程工厂</div>\n<div>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; RejectedExecutionHandler &nbsp;&nbsp; handler　　&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;拒绝策略</div>\n<h3>ThreadPoolExecutor参数详解</h3>\n<div>我们可以通过下面的场景理解ThreadPoolExecutor中的各个参数;</div>\n<div>a客户(任务)去银行(线程池)办理业务,但银行刚开始营业,窗口服务员还未就位(相当于线程池中初始线程数量为0),</div>\n<div>于是经理(线程池管理者)就安排1号工作人员(创建1号线程执行任务)接待a客户(创建线程);</div>\n<div>在a客户业务还没办完时,b客户(任务)又来了,于是经理(线程池管理者)就安排2号工作人员(创建2号线程执行任务)接待b客户(又创建了一个新的线程);假设该银行总共就2个窗口(核心线程数量是2);</div>\n<div>紧接着在a,b客户都没有结束的情况下c客户来了,于是经理(线程池管理者)就安排c客户先坐到银行大厅的座位上(空位相当于是任务队列)等候,</div>\n<div>并告知他: 如果1、2号工作人员空出,c就可以前去办理业务;</div>\n<div>此时d客户又到了银行,(工作人员都在忙,大厅座位也满了)于是经理赶紧安排临时工(新创建的线程)在大堂站着,手持pad设备给d客户办理业务;</div>\n<div>假如前面的业务都没有结束的时候e客户又来了,此时正式工作人员都上了,临时工也上了,座位也满了(临时工加正式员工的总数量就是最大线程数),于是经理只能按《超出银行最大接待能力处理办法》(饱和处理机制)拒接接待e客户;</div>\n<div>最后,进来办业务的人少了,大厅的临时工空闲时间也超过了1个小时(最大空闲时间),经理就会让这部分空闲的员工人下班.(销毁线程)</div>\n<div>但是为了保证银行银行正常工作(有一个allowCoreThreadTimeout变量控制是否允许销毁核心线程,默认false),即使正式工闲着,也不得提前下班,所以1、2号工作人员继续待着(池内保持核心线程数量);</div>\n<div>2、详细解释</div>\n<div>　　1)、&nbsp;核心线程数</div>\n<div>　　　　当线程是IO密集型时，主要消耗磁盘的读写性能，可以设置为2*n，n为当前服务器核数（比如8核16G的服务器设置为16，Runtime.getRuntime().availableProcessors()获取）</div>\n<div>　　　　当线程是CPU密集型时，主要消耗cpu性能，设置为n+1</div>\n<div>　　2)、最大线程数</div>\n<div>　　　　当核心线程核消息队列都满了之后才会去创建最大线程，直到达到最大线程数，之后的线程就会执行拒绝策略</div>\n<div>　　3)、&nbsp;阻塞消息队列</div>\n<div>　　　　ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小，读写用一把锁，性能较差；</div>\n<div>　　　　LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；一般是用这个，指定了大小则限制具体大小，写核读分两把锁进行操作，所以性能较好</div>\n<div>　　　　synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。</div>\n<div>　　　　注意：当核心线程数满了之后，新线程会先存储在消息队列中，当消息队列也满了之后才会去创建最大线程，直到达到最大线程数，之后的线程就会执行拒绝策略</div>\n<div>　　4)、&nbsp;线程工厂</div>\n<div>　　　　创建线程的类，可以用默认工厂，也可以自定义线程工厂实现&nbsp;implements ThreadFactory类，实现newThread方法，自定义工厂的话可以设置线程名或者定义辅助线程</div>\n<div>　　5)、拒绝策略</div>\n<div>　　　　ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</div>\n<div>　　　　ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。</div>\n<div>　　　　ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务</div>\n<div>　　　　ThreadPoolExecutor.CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务</div>\n<div>&nbsp;</div>\n<div><strong>线程池的主要优点包括：</strong></div>\n<div>1、重用线程：线程池会在内部维护一组可重用的线程，避免了频繁地创建和销毁线程的开销，提高了线程的利用率。</div>\n<div>2、控制并发度：线程池可以限制并发执行的线程数量，防止系统过载。通过调整线程池的大小，可以控制并发度，避免资源消耗过大。</div>\n<div>3、提供线程管理和监控：线程池提供了一些管理和监控机制，例如线程池的创建、销毁、线程状态的监控等，方便开发人员进行线程的管理和调试。</div>\n<div>4、提供任务队列：线程池通常会使用任务队列来存储待执行的任务，这样可以实现任务的缓冲和调度。</div>\n<div>&nbsp;</div>\n<div><strong>线程池的一些缺点包括：</strong></div>\n<div>1、需要合理配置：线程池的性能和效果受到配置参数的影响，需要根据具体的应用场景和硬件环境来合理配置线程池的大小、任务队列的大小等参数。</div>\n<div>2、可能引发资源泄露：如果线程池中的线程长时间闲置而不被使用，可能会导致资源的浪费和泄露。</div>\n<div>3、可能引发死锁：在使用线程池时，如果任务之间存在依赖关系，可能会引发死锁问题，需要额外的注意和处理。</div>\n<div>&nbsp;</div>\n<div>\n<div>\n<div>\n<div><strong><span style=\"font-size: 16px;\">重点面试问题</span></strong></div>\n<div>1、sleep和wait的区别：</div>\n<div>&nbsp; &nbsp; 1)、sleep属于Thread类，让出cpu，但是监控状态依然保持者，指定时间到了，就会恢复运行；</div>\n<div>&nbsp; &nbsp; 2)、wait属于Object类方法，释放对象锁，进入等待锁定池，需要notify()才能重新进入运行状态；</div>\n<div>2、wait()、notify() 释放锁问题：</div>\n<div>&nbsp; &nbsp; 1)、wait()会立刻释放synchronized(obj)中的obj锁,以便其他线程可以执行obj.notify()</div>\n<div>&nbsp; &nbsp; <span>2)、</span>但是notify()不会立刻立刻释放sycronized(obj)中的obj锁,必须要等notify()所在线程执行完synchronized(obj)块中的所有代码才会释放这把锁.yield(),sleep()不会释放锁。</div>\n<div>&nbsp;</div>\n<div><span style=\"font-size: 15px;\"><strong>异步线程间数据同步传递的四种方式</strong></span></div>\n<div>手动设置、线程池设置TaskDecorator、使用InheritableThreadLocal、使用TransmittableThreadLocal</div>\n<div>主线程</div>\n</div>\n</div>\n<div>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> @description 用户上下文信息</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> OauthContext {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span>  <span style=\"color: rgba(0, 0, 255, 1);\">final</span>  ThreadLocal&lt;LoginVal&gt; loginValThreadLocal=<span style=\"color: rgba(0, 0, 255, 1);\">new</span> ThreadLocal&lt;&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span><span style=\"color: rgba(0, 0, 0, 1);\">  LoginVal get(){\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> loginValThreadLocal.get();\n    }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> set(LoginVal loginVal){\n        loginValThreadLocal.set(loginVal);\n    }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> clear(){\n        loginValThreadLocal.remove();\n    }\n}</span></pre>\n</div>\n<p>&nbsp;</p>\n</div>\n<div>1、手动设置</div>\n<div>每执行一次异步线程都要分为两步：</div>\n<div>&nbsp; &nbsp; 1)、获取父线程的值</div>\n<div>&nbsp; &nbsp; 2)、将值设置到子线程，达到复用， 代码如下：</div>\n<div>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> handlerAsync() {\n        LoginVal loginVal </span>= OauthContext.get();  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">1. 获取父线程的loginVal</span>\n        log.info(\"父线程的值：{}\"<span style=\"color: rgba(0, 0, 0, 1);\">,OauthContext.get());\n        CompletableFuture.runAsync(()</span>-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">{\n           OauthContext.set(loginVal);   </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">2. 设置子线程的值，复用</span>\n           log.info(\"子线程的值：{}\"<span style=\"color: rgba(0, 0, 0, 1);\">,OauthContext.get());\n        });\n    }</span></pre>\n</div>\n<p>&nbsp;</p>\n</div>\n<div><strong>2、线程池设置TaskDecorator</strong></div>\n<div>TaskDecorator是一个执行回调方法的接口，主要应用于传递上下文，或者提供任务的监控/统计信息。</div>\n<div>首先需要去实现它，代码如下：</div>\n</div>\n<div>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> @description 上下文装饰器</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span> ContextTaskDecorator <span style=\"color: rgba(0, 0, 255, 1);\">implements</span><span style=\"color: rgba(0, 0, 0, 1);\"> TaskDecorator {\n    @Override\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span><span style=\"color: rgba(0, 0, 0, 1);\"> Runnable decorate(Runnable runnable) {\n        LoginVal loginVal </span>= OauthContext.get();  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">获取父线程的loginVal</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">return</span> () -&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">try</span><span style=\"color: rgba(0, 0, 0, 1);\"> {\n                OauthContext.set(loginVal);  </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 将主线程的请求信息，设置到子线程中</span>\n                runnable.run();  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 执行子线程</span>\n            } <span style=\"color: rgba(0, 0, 255, 1);\">finally</span><span style=\"color: rgba(0, 0, 0, 1);\"> {\n                OauthContext.clear();  </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 线程结束，清空这些信息，否则可能造成内存泄漏</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">            }\n        };\n    }\n}</span></pre>\n</div>\n<p>这里我只是设置了LoginVal，实际开发中其他的共享数据，比如SecurityContext，RequestAttributes....</p>\n</div>\n<div>\n<div>TaskDecorator需要结合线程池使用，实际开发中异步线程建议使用线程池，只需要在对应的线程池配置一下，代码如下：</div>\n</div>\n<div>\n<div class=\"cnblogs_code\">\n<pre>@Bean(\"taskExecutor\"<span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 0, 255, 1);\">public</span><span style=\"color: rgba(0, 0, 0, 1);\"> ThreadPoolTaskExecutor taskExecutor() {\n        ThreadPoolTaskExecutor poolTaskExecutor </span>= <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ThreadPoolTaskExecutor();\n        poolTaskExecutor.setCorePoolSize(xx);\n        poolTaskExecutor.setMaxPoolSize(xx);\n        poolTaskExecutor.setKeepAliveSeconds(xx);   </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 设置线程活跃时间（秒）</span>\n        poolTaskExecutor.setQueueCapacity(xx);  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 设置队列容量</span>\n        poolTaskExecutor.setTaskDecorator(<span style=\"color: rgba(0, 0, 255, 1);\">new</span> ContextTaskDecorator()); <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">设置TaskDecorator，用于解决父子线程间的数据复用</span>\n        poolTaskExecutor.setRejectedExecutionHandler(<span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ThreadPoolExecutor.CallerRunsPolicy());\n        poolTaskExecutor.setWaitForTasksToCompleteOnShutdown(</span><span style=\"color: rgba(0, 0, 255, 1);\">true</span>);  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 等待所有任务结束后再关闭线程池</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> poolTaskExecutor;\n    }</span></pre>\n</div>\n<p>此时业务代码就不需要去设置子线程的值，直接使用即可，代码如下：</p>\n</div>\n<div>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> handlerAsync() {\n        log.info(</span>\"父线程的用户信息：{}\"<span style=\"color: rgba(0, 0, 0, 1);\">, OauthContext.get());\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">执行异步任务，需要指定的线程池</span>\n        CompletableFuture.runAsync(()-&amp;gt; log.info(\"子线程的用户信息：{}\"<span style=\"color: rgba(0, 0, 0, 1);\">, OauthContext.get()),taskExecutor);\n    }</span></pre>\n</div>\n<p>这里使用的是CompletableFuture执行异步任务，使用@Async这个注解同样是可行的。</p>\n</div>\n<div>\n<div>注意：无论使用何种方式，都需要指定线程池</div>\n<div>&nbsp;</div>\n</div>\n<div><strong><span style=\"font-size: 14px;\">3、使用InheritableThreadLocal</span></strong></div>\n<div>这种方案不建议使用，InheritableThreadLocal虽然能够实现父子线程间的复用，但是在线程池中使用会存在复用的问题，这种方案使用也是非常简单，直接用InheritableThreadLocal替换ThreadLocal即可，代码如下：</div>\n<div>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> @description 用户上下文信息</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> OauthContext {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span>  <span style=\"color: rgba(0, 0, 255, 1);\">final</span>  InheritableThreadLocal&lt;LoginVal&gt; loginValThreadLocal=<span style=\"color: rgba(0, 0, 255, 1);\">new</span> InheritableThreadLocal&lt;&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span><span style=\"color: rgba(0, 0, 0, 1);\">  LoginVal get(){\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> loginValThreadLocal.get();\n    }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> set(LoginVal loginVal){\n        loginValThreadLocal.set(loginVal);\n    }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> clear(){\n        loginValThreadLocal.remove();\n    }\n}</span></pre>\n</div>\n<p>&nbsp;</p>\n</div>\n<div><strong><span style=\"font-size: 15px;\">4、使用TransmittableThreadLocal</span></strong></div>\n<div><span>TransmittableThreadLocal是阿里开源的工具，弥补了InheritableThreadLocal的缺陷，在使用线程池等会池化复用线程的执行组件情况下，提供ThreadLocal值的传递功能，解决异步执行时上下文传递的问题。</span></div>\n<div>&nbsp;</div>\n<div><strong>TransmittableThreadLocal原理</strong></div>\n<div><span>TransimittableThreadLocal继承于InheritableThreadLocal，并实现TtlCopier接口，它里面只有一个copy方法。所以主要是对InheritableThreadLocal的扩展。</span></div>\n<div>\n<div><span>在TransimittableThreadLocal中添加holder属性。这个属性的作用就是被标记为具备线程传递资格的对象都会被添加到这个对象中。</span></div>\n<div>要标记一个类，可以给这个类新增一个Type字段，还有一个方法就是将具备这种类型的的对象都添加到一个静态全局集合中，之后使用时，这个集合里的所有值都具备这个标记。</div>\n<div>应用代码是通过TtlExecutors工具类对线程池对象进行包装。工具类只是简单的判断，输入的线程池是否已经被包装过、非空校验等，然后返回包装类ExecutorServiceTtlWrapper。根据不同的线程池类型，有不同和的包装类。</div>\n<div>进入包装类ExecutorServiceTtlWrapper。可以注意到不论是通过ExecutorServiceTtlWrapper#submit方法或者是ExecutorTtlWrapper#execute方法，都会将线程对象包装成TtlCallable或者TtlRunnable，用于在真正执行run方法前做一些业务逻辑。</div>\n</div>\n<div><span>所以，重点的核心逻辑应该是在TtlCallable#call()或者TtlRunnable#run()中。以下以TtlCallable为例，TtlRunnable同理类似。</span></div>\n<div><span>总的来说在创建TtlCallable对象是，调用capture()方法捕获调用方的本地线程变量，在call()执行时，将捕获到的线程变量，替换到线程池所对应获取到的线程的本地变量中，并且在执行完成之后，将其本地变量恢复到调用之前。</span></div>\n<div><span>&nbsp;</span></div>\n<div>&nbsp;</div>\n<div><strong><span style=\"font-size: 18px;\">高并发</span></strong></div>\n<div><img class=\"lazyload\" width=\"361\" /></div>\n<div><strong><span style=\"font-size: 16px;\">高并发系统系统指标</span></strong></div>\n<div><span>1、QPS（Queries Per Second</span>）</div>\n<div>QPS 是每秒请求数，是衡量信息系统在一秒钟内接收到的搜索流量的一种常见度量指标，被广泛应用在任何请求-响应的系统中。对于高并发的系统，必须要关注 QPS，这样你才能指导你的系统何时需要进行扩容。</div>\n<div>2、TPS（Transactions Per Second）</div>\n<div>TPS 是每秒的事务数量，是软件测试结果的测量单位，一个事务是指一个客户端向服务器发送请求然后服务器做出响应的过程。客户端在发送请求时开始计时，收到服务器响应后结束计时，用来计算使用的时间和完成的事务个数。</div>\n<div>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;QPS VS TPS</div>\n<div>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;QPS 基本可以理解为类似于 TPS，但不同的是，对于一个页面的一次访问，形成一个 TPS，但一次页面请求，可能会产生多次对服务器的请求，就是说会有多个 QPS。</div>\n<div>3、RT（Response-time）</div>\n<div>RT 即响应时间，是指一个请求从开始到最后收到响应数据结果所花费的总时间，它的数值大小直接反应了系统的快慢。</div>\n<div>4、并发数</div>\n<div><span>并发数是指系统同时能处理的请求数量，这个指标反应了系统的负载能力。并发意味着可以同时进行多个处理，并发在现代编程中无处不在。</span></div>\n<div>5、吞吐量</div>\n<div>系统的吞吐量和处理对 CPU 的消耗、外部接口、IO 等多个因素紧密相关，单个处理请求对 CPU 消耗越高，外部系统接口、IO 速度越慢，系统的吞吐能力越低，反之越高。系统吞吐量有几个重要指标参数：QPS/TPS、并发数、响应时间。</div>\n<div><span style=\"font-family: Arial;\">&nbsp;</span></div>\n<div>\n<div>&nbsp;&nbsp; &nbsp;QPS/TPS：每秒请求/事务数量。</div>\n<div>&nbsp;&nbsp; &nbsp;并发数： 系统同时处理的请求/事务数。</div>\n<div>&nbsp;&nbsp; &nbsp;响应时间： 一般取请求平均响应时间。</div>\n<div>理解了上面三个指标的意义之后，就能推算出它们之间的关系：</div>\n<div>QPS(TPS) = 并发数/平均响应时间</div>\n<div>并发数 = QPS*平均响应时间</div>\n<div>&nbsp;</div>\n<div><strong><span style=\"font-size: 18px;\">实际举例</span></strong></div>\n<div>某宝直播业务要求预估计算对应的各个指标。正常在进行流量估算的时候，会采用二八定律，如果每天 80% 的访问集中在 20% 的时间段里，那这个 20% 的时间就被称为峰值时间。</div>\n<div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>峰值时间的 QPS = （总 PV 数 * 80%）/（每天秒数 * 20%）</span></div>\n<div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>需要的机器数量 = 峰值时间的 QPS / 单台机器的 QPS</span></div>\n<div>每天300w PV 的在单台机器上，这台机器需要多少QPS？</div>\n<div>&nbsp; &nbsp;&nbsp;( 3000000 * 0.8 ) / (86400 * 0.2 ) = 139 (QPS)</div>\n<div>如果一台机器的QPS是58，需要几台机器来支持？</div>\n<div>&nbsp; &nbsp;&nbsp;139 / 58 = 3</div>\n<div>高并发系统的目标从系统层面看，有高性能、高可用和高扩展三个目标</div>\n</div>\n<div>&nbsp;</div>\n<div><strong><span style=\"font-size: 18px;\">高并发解决方案</span></strong></div>\n<div><span>使用分布式微服务架构模式、集群部署与负载均衡、用分布式缓存、使用消息队列、分库分表、读写分离、限流和熔断、动静分离、使用分布式数据库、数据库优化。</span></div>\n<div><strong>1、使用分布式微服务架构模式</strong></div>\n<div>将一个系统拆分为多个子系统。&nbsp;微服务架构拆分，最常见的就是Spring Cloud 和Spring Cloud Alibaba。然后每个系统连一个数据库，这样本来就一个库，现在多个数据库，这样就可以抗高并发。</div>\n<div><strong>2、集群部署与负载均衡</strong></div>\n<div>将系统部署在多台服务器上，通用负载均衡将用户请求均匀地分发到各个服务器进行处理， 分担单台服务器的压力，这种方式可以通过添加新的服务器或者服务节点来提高系统的整体处理能力， 提高系统的并发处理能力和整体性能。</div>\n<div>负载均衡（Load Balancing）是一种分布式系统架构中的技术，用于将网络请求或任务分散到多个服务器或资源上。</div>\n<div>比如：当系统面临大量用户访问，负载过高的时候，通常会使用增加服务器数量来进行横向扩展来提高整个系统的处理能力。</div>\n<div>负载均衡可以在不同的层次上实现，包括：</div>\n<div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;硬件负载均衡器：&nbsp;使用专门的硬件设备来实现负载均衡，如硬件负载均衡器。</div>\n<div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;软件负载均衡器：&nbsp;在应用层或网络层使用软件来实现负载均衡，如反向代理服务器、负载均衡算法。</div>\n<div>在负载均衡的设计中，有几种常见的负载均衡策略：</div>\n<div>&nbsp; &nbsp;&nbsp;1、轮询（Round Robin）：&nbsp;将请求依次分配给服务器列表中的每个服务器，每次请求后移动到下一个服务器。适用于服务器性能相近的情况。</div>\n<div>&nbsp; &nbsp; &nbsp; 2、加权轮询（Weighted Round Robin）：&nbsp;类似于轮询，但每个服务器有不同的权重，可以根据服务器性能调整权重。</div>\n<div>&nbsp; &nbsp; &nbsp; 3、最少连接（Least Connections）：&nbsp;将请求分配给当前连接数最少的服务器，以确保负载均衡。适用于长连接的情况。</div>\n<div>&nbsp; &nbsp; &nbsp; 4、加权最少连接（Weighted Least Connections）：&nbsp;类似于最少连接，但每个服务器有不同的权重，可以根据服务器性能调整权重。</div>\n<div>&nbsp; &nbsp; &nbsp; 5、随机（Random）：&nbsp;随机选择一个服务器来处理请求，适用于简单的负载均衡需求。</div>\n<div>&nbsp; &nbsp; &nbsp; 6、IP 哈希（IP Hash）：&nbsp;根据客户端 IP 地址的哈希值来选择服务器，可以确保同一客户端的请求始终发送到同一服务器。</div>\n<div><strong>3、分布式缓存</strong></div>\n<div>大部分的高并发场景，都是读多写少，那你完全可以在数据库和缓存里都写一份，然后读的时候大量走缓存不就得了。毕竟人家redis轻轻松松单机几万的并发啊。没问题的。所以你可以考的虑考虑你的项目里，那些承载主要请求读场景，怎么用缓存来抗高并发。（缓存你也可以考虑集群，不过前提就是你的服务器得支持怎么多高负荷的中间件。俗话说没有任何事物加一层解决不了的，如果一层不行，就在加一层解决）</div>\n<div>\n<div>一些常见的分布式缓存系统包括：；</div>\n<div>&nbsp;&nbsp; &nbsp;1)、Redis：&nbsp;Redis 是一种基于内存的键值存储系统，支持多种数据结构，如字符串、哈希、列表等，适用于快速读取和写入场景。&nbsp;&nbsp;</div>\n<div>&nbsp;&nbsp; &nbsp;2)、Memcached：&nbsp;Memcached 也是一种基于内存的键值存储系统，适用于分布式缓存和缓存共享。</div>\n<div>&nbsp; &nbsp; 3)、Hazelcast：&nbsp;Hazelcast 是一个开源的分布式数据存储和计算平台，支持分布式缓存、分布式计算等。</div>\n<div>&nbsp; &nbsp; 4)、Couchbase：&nbsp;Couchbase 是一个分布式缓存和数据库系统，结合了缓存和文档存储的功能。</div>\n<div>&nbsp; &nbsp; 5)、Ehcache：&nbsp;Ehcache 是一个 Java 缓存库，可以作为本地缓存或分布式缓存使用。</div>\n<div>当然，这里使用最多的还是Redis。</div>\n</div>\n<div><strong>4、MQ(消息队列)</strong></div>\n<div>可能你还是会出现高并发写的场景，比如说一个业务操作里要频繁搞数据库几十次，增删改增删改，疯了。那高并发绝对搞挂你的系统，人家是缓存你要是用redis来承载写那肯定不行，数据随时就被LRU(淘汰掉最不经常使用的)了，数据格式还无比简单，没有事务支持。所以该用mysql还得用mysql啊。那你咋办？用MQ吧，大量的写请求灌入MQ里，排队慢慢玩儿，后边系统消费后慢慢写，控制在mysql承载范围之内。所以你得考虑考虑你的项目里，那些承载复杂写业务逻辑的场景里，如何用MQ来异步写，提升并发性。MQ单机抗几万并发也是ok的。（这个是根据自己的业务来用的，一般中小型项目用rabbitmq就够了，建议日志用kafka，这样日志的数量多就可以很好的解决）</div>\n<div>&nbsp;</div>\n<div><strong>5、分库分表</strong></div>\n<div>可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来抗更高的并发；然后将一个表拆分为多个表，每个表的数据量保持少一点，提高sql跑的性能。（这个前提你的服务器得支持，不然弄得华丽花哨）</div>\n<div>1.什么是分库分表？</div>\n<div>1.1 分库</div>\n<div>\n<div>分库是指在表数量不变的情况下对库进行切分。</div>\n<div>举例：如下图，数据库A 中存放了 user 和 order 两张表，将两张表切分到两个数据库中，user表放到 database A，order表放到 database B</div>\n<div>1.2 分表</div>\n<div>分表是指在库数量不变的情况下对表进行切分。</div>\n<div>举例：如下图，数据库 A 中存放了 user表，将 user表切分成 user1 和 user2 两张表并放到 database A中。</div>\n<div>1.3 分库分表</div>\n<div>分库分表是指库和表都切分，数量都发生变化。</div>\n<div>举例：如下图，数据库 A 中存放了 user表，将 user表切分成 user1、user2、user3、user4 四张表，user1 和 user2 放到 database A中，user3 和 user4 放到 database B 中。</div>\n<div>2. 如何切分库和表？</div>\n<div><span>主流的切分方式有 3种：水平切分、垂直切分和混合切分。</span></div>\n<div>2.1 水平切分</div>\n<div>水平切分包含水平分库和水平分表。</div>\n<div>2.1.1 水平分表</div>\n<div><span>水平分表指的表结构不变，将单表数据切分成多表。切分后的结果：每个表的结构一样，数据不一样，所有表的数据并集为全量数据。</span></div>\n<div>举例：如下图，order表，按照 oder_id 的数据范围水平切分后变成了 order1 和 order2 表，两个表的结构一样，数据不同。</div>\n<div>2.1.2 水平分库</div>\n<div><span>水平分库是指，将表水平切分后分到不同的数据库，使得每个库具有相同的表，表中的数据不相同，水平分库一般是伴随水平分表。</span></div>\n<div>举例：如下图，order 表，水平切分后，分到 database A 和 database B 中，这样原来一个库就被拆分成 2个库。</div>\n<div>2.2 垂直切分</div>\n<div>垂直切分包含垂直分库和垂直分表。</div>\n<div>2.2.1 垂直分表</div>\n<div><span>垂直分表指将存在一张表中的字段切分到多张表。切分后的结果：每个表的结构不一样，数据也不一样，所有表的字段并集是原表的字段。</span></div>\n<div>举例：如下图，order 表，根据字段垂直切分，切分后 order_base表包含一部分字段的数据 和 order_info表包含另一部分字段的数据。</div>\n<div>2.2.2 垂直分库</div>\n<div>垂直分库指的是，将单个库中的表分到多个库，每个库包含的表不一样。</div>\n<div>举例：如下图，database A 中的 order 表 和 user表，垂直分库为 database A 包含 order表，database B 包含 user 表。</div>\n<div>2.3 混合切分</div>\n<div>混合切分其实就是水平切分和垂直切分的组合</div>\n</div>\n<div><strong>6、读写分离</strong></div>\n<div>这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。读流量太多的时候，还可以加更多的从库。</div>\n<div><strong>&nbsp;</strong></div>\n<div><strong>7、限流和熔断</strong></div>\n<div>限流（Rate Limiting）和熔断（Circuit Breaking）是分布式系统中常用的两种流量控制和容错机制。</div>\n<div>并发量高的情况下，利用SpringCloud的Hystrix组件(监控和熔断器)进行限流熔断处理， 首先保护核心系统的安全性，</div>\n<div><img class=\"lazyload\" width=\"382\" /></div>\n<div>&nbsp;</div>\n<div><strong>8、动静分离</strong></div>\n<div>将css、html、jpg、&nbsp;js&nbsp;等&nbsp;静态文件和动态页面区分开</div>\n<div>&nbsp;</div>\n<div><strong>9、使用分布式数据库</strong></div>\n<div>分布式数据库是一种数据库系统，将数据分散存储在多个物理节点或服务器上，以提高系统的性能、可扩展性和可用性。</div>\n<div>\n<div>分布式数据库分类：</div>\n<div>1.分布式关系型数据库</div>\n<div>这类数据库将关系型数据库的特性与分布式系统的优势相结合，提供了支持SQL查询和事务的能力。</div>\n<div>一些例子包括：Google Cloud Spanner、TiDB一种全球分布式的关系型数据库，提供了强一致性和水平扩展能力。</div>\n<div>2.分布式列式数据库</div>\n<div>这类数据库以列式存储方式存储数据，适用于大规模分析和查询需求。</div>\n<div>Apache Cassandra：一个分布式的NoSQL数据库，适用于高可用性和可扩展性的场景。</div>\n<div>HBase：一个基于Hadoop的分布式列式数据库，适用于大数据存储和实时查询。</div>\n<div><span>3.</span>分布式文档数据库</div>\n<div>这类数据库以文档为单位存储数据，适用于半结构化数据。</div>\n<div>MongoDB：一个面向文档的NoSQL数据库，支持分布式部署和水平扩展。</div>\n<div>Couchbase：一个分布式NoSQL数据库，支持文档和键值数据模型。</div>\n<div>使用分布式数据库系统，如分布式 NoSQL 数据库，来提高数据存储和查询的并发处理能力。</div>\n<div><strong>10、数据库优化</strong></div>\n<div>优化数据库的设计、索引、查询语句等，提高数据库的读写性能。</div>\n<div>综合运用上述高并发架构解决方案，都可以构建出具有高性能、高可用和可扩展性的系统，满足大量并发请求的需求。</div>\n</div>\n</div>\n<div>&nbsp;</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 09:14</span>&nbsp;\n<a href=\"https://www.cnblogs.com/philry\">大芒果2点0</a>&nbsp;\n阅读(<span id=\"post_view_count\">74</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "GIS中的“高度”到底指什么？一文厘清正高、正常高与大地高的区别",
      "link": "https://www.cnblogs.com/charlee44/p/19458808",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/charlee44/p/19458808\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 21:56\">\n    <span>GIS中的“高度”到底指什么？一文厘清正高、正常高与大地高的区别</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        深入解析 GIS 中高程参考系统的核心概念——大地水准面、似大地水准面与参考椭球面的关系，厘清正高、正常高与大地高的区别及转换方法，并介绍我国高程基准与全球重力模型。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p><strong>节选自《GIS基础原理与技术实践》第2章 地理空间参考系统</strong><br />\n作者原创内容，转载请注明出处。</p>\n</blockquote>\n<p><img alt=\"GIS基础原理与技术实践\" class=\"lazyload\" /></p>\n<h2 id=\"23-高程参考系统\">2.3 高程参考系统</h2>\n<p>使用经度和纬度表示的地理坐标系是一种水平坐标系统（这里的水平坐标系统并不表示其就是平面坐标系的意思，更准确的含义是其表达了三维空间坐标系的两个维度），缺少对于第三维度也就是高程的参考，也就是本节我们要介绍的：高程参考系统。高程参考系统是一种垂直坐标系。</p>\n<h3 id=\"231-大地水准面\">2.3.1 大地水准面</h3>\n<p>我们知道，参考椭球体是对地球表面的一种逼近。那么问题来了，参考椭球体是用喜马拉雅山所在的高度进行逼近，还是以马里亚纳海沟的高度进行逼近？答案肯定都不是。其实，这其中还隐藏了另一个逼地球自然表面的参考面，那就是本节我们要讲的——大地水准面（Geoid）。</p>\n<p>地理坐标系的第三维度通常使用海拔高度（Elevation），而不是到球心的距离。然而问题在于，高度的值是一个相对量，需要一个起算点。并且，这个高度必须沿着重力方向（铅锤方向）才有物理意义（想一想为什么建筑物总是要修的与地面垂直）。我们说到“海拔”这个名词，就会联想到高度的值应该是一个目标地物距离海平面的高差。事实也确实如此，我们可以定一个平均海平面作为高程的起算点，并且假设这个海平面完全静止，并且延伸到所有大陆下部，生成了一个密闭的曲面——这个曲面就是大地水准面。</p>\n<p>与参考椭球面不同的是，参考椭球面是数学模型得到的，处处平滑且平整；而大地水准面虽然平滑但不平整，是一个不规则但连续的闭合曲面。这其中的原因在于，地球质量分布不均匀，造成地球的引力场也是分布不均的。假设地球球体完全被水覆盖，水的高度也不会是完全一样：在地球局部密度更大的地方，地球施加的引力就会越大，造成水位越高。换句话说，大地水准面是一个重力等势面，重力方向（铅垂方向）在其任何地方都与其表面垂直；由于质量（引力）不均，每个位置的铅垂方向不一样，结果就是大地水准面并不平整。如下图2.8所示。</p>\n<p><img alt=\"图2.8 大地水准面与旋转椭球体\" class=\"lazyload\" /></p>\n<h3 id=\"232-三级逼近\">2.3.2 三级逼近</h3>\n<p>现在我们已经有了大地水准面、参考椭球面和大地基准面。那么它们的关系是如何呢？简单来说，它们共同组成了对地球自然表面的三级逼近。</p>\n<ul>\n<li>大地水准面是对地球自然表面的第一级逼近。大地水准面通过重力等势，确定了一个高程起算面，它远比地球自然表面平整得多，但是不是完全平整。地球自然表面具有从珠穆朗玛峰（+8800米）到马里亚纳海沟（-11,000米）的高差，但大地水准面与参考椭球面的偏差范围不超过200m（从+85米的冰岛到-106米的印度南部）。</li>\n<li>参考椭球面是对地球自然表面的第二级逼近。地球自然表面和大地水准面都是不规则的曲面，无法通过数学模型对其进行表达，这也意味着难以对其进行测算和分析。通过将大地水准面拟合成一个旋转椭球体，使我们可以对地球自然表面进行空间几何计算。参考椭球面是测量计算的基准面。</li>\n<li>大地基准面是对地球自然表面的第三极逼近。参考椭球体是对地球球体的抽象，但大地基准面解决的是这个参考椭球体如何摆放的问题：大地基准面要么与地球自然表面的局部区域具有较好的重合度，以便解决局部区域精度的问题；要么让椭球体中心位于地球质心，以便具有全球范围可使用的便捷性。</li>\n</ul>\n<h3 id=\"233-高程系统\">2.3.3 高程系统</h3>\n<h4 id=\"1-似大地水准面\">1 似大地水准面</h4>\n<p>如前所述，大地水准面确定了高程的起算面。那么，地球表面上一点到大地水准面必然有一个高度，这个高度就是正高（Orthometric Height）。正高就是我们通常意义上所说的海拔或者海拔高度，也叫做高程（Elevation）。这个高程系统就是正高系统。</p>\n<p>然而，大地水准面的问题是其仅仅只是一个理想化的模型，是不能准确测量的。客观地说，大地水准面所假想的大陆下部的海平面无法被量测，没有现实意义。为了解决这个问题，就引入了一个数学辅助面：似大地水准面（Quasi-geoid）。似大地水准面采用平均正常重力值来拟合水准面曲线（大地某一点的重力值无法精确求取），导致两者在海洋上完全重合，在大陆上有2 ~ 4米的微小差异。如果不能理解不要紧，我们可以定性的理解：似大地水准面是对大地水准面的数学近似，似大地水准面可以精确求得，大地水准面不可以精确求得。</p>\n<p>同样的，地球表面上一点到似大地水准面也有一个高度，我们把这个高度叫做正常高（Normal height），其高程就是正常高系统。正因为似大地水准面是大地水准面得近似且可求取，所以一般使用正常高来替代正高，正常高系统结果也可以称为海拔高度。我国目前采用的法定高程系统就是正常高系统。</p>\n<p>正高和正常高，大地水准面和似大地水准面的示意图如下图2.9所示：</p>\n<p><img alt=\"图2.9 正高、正常高与大地高\" class=\"lazyload\" /></p>\n<h4 id=\"2-高程系统\">2 高程系统</h4>\n<p>如图2.9中所示，除了正高系统和正常高系统，还有一类常用的高程系统就是大地高系统。所谓大地高，指的是以参考椭球面为基准面的高程系统，其值是地面上一点沿该点的椭球面法线到参考椭球面的距离。大地高也称为椭球高。</p>\n<p>虽然我们一般采用的高程系统是正常高系统，但在实际的使用过程中，有的时候知道正常高需要计算大地高，有的时候又需要通过大地高来计算正常高。一个很典型的例子就是，GPS（Global Positioning System，全球定位系统）获取的高程一般是大地高，那么如何得到我们想要的正常高呢？</p>\n<p>如下表2.4所述，对于高程系统中变量，我们有如下定义：</p>\n\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\">符号</th>\n<th style=\"text-align: center;\">名称</th>\n<th style=\"text-align: center;\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(H_n\\)</span></td>\n<td style=\"text-align: center;\">正常高（Normal Height）</td>\n<td style=\"text-align: center;\">地面上一点沿重力方向到似大地水准面的距离</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(H_o\\)</span></td>\n<td style=\"text-align: center;\">正高 （Orthometric Height）</td>\n<td style=\"text-align: center;\">地面上一点沿重力方向到大地水准面的距离</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(H_g\\)</span></td>\n<td style=\"text-align: center;\">大地高（Geodetic Height）</td>\n<td style=\"text-align: center;\">地面上一点沿椭球面法线方向到参考椭球面的距离</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(\\zeta\\)</span></td>\n<td style=\"text-align: center;\">高程异常（Height Anomaly）</td>\n<td style=\"text-align: center;\">似大地水准面到参考椭球面的距离</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(N\\)</span></td>\n<td style=\"text-align: center;\">大地水准面差距（Geoid Undulation）</td>\n<td style=\"text-align: center;\">大地水准面到参考椭球面的距离</td>\n</tr>\n</tbody>\n</table>\n<p>将它们在示意图中标识，如下图2.10所示：<br />\n<img alt=\"图2.10 正高、正常高与大地高\" class=\"lazyload\" /></p>\n<p>根据图示很显然可以得到如下公式：</p>\n<p></p><div class=\"math display\">\\[H_g = H_n + \\zeta \\tag{2.6}\n\\]</div><p></p><p></p><div class=\"math display\">\\[H_g = H_o + N \\tag{2.7}\n\\]</div><p></p><p>回到之前提到的问题，GPS获取的高程为大地高<span class=\"math inline\">\\(H_g\\)</span>，那么再通过大地测量的方法，可以精确确定高程异常<span class=\"math inline\">\\(\\zeta\\)</span>，根据公式2.6，大地高减去高程异常就可以得到正常高<span class=\"math inline\">\\(H_n\\)</span>，正常高可以用来代替正高，正高即最常用的海拔高度。在实际的应用中，有时需要大地高，有时需要正常高，可根据上述公式灵活转换。</p>\n<h4 id=\"3-高程基准\">3 高程基准</h4>\n<p>如2.3.1节所述，大地水准面使用一个假想的平均海平面作为高程起点（基准），这个平均海面可以通过在各地的验潮站观测、计算、综合得到。我国根据实际的观测结果之上，建立多个高程基准面，其中最常用的两个国家高程基准是：</p>\n<ul>\n<li>1956黄海高程基准，水准原点高程72.289米。</li>\n<li>1985国家高程基准，水准原点高程72.260米。</li>\n</ul>\n<p>目前，1985国家高程基准已经全部替代1956黄海高程基准，之前所有使用1956黄海高程基准的高程结果都需要通过下式2.8进行转换：</p>\n<p></p><div class=\"math display\">\\[H_{85} = H_{56} - 0.029\n\\]</div><p></p><p>此外，国际上通用的还有美国国家地理空间情报局（National Geospatial-Intelligence Agency，NGA）发布的EGM（Earth Gravitational Models，地球重力模型）大地水准面。这个大地水准面模型是综合利用现有全球大量重力数据计算出来的，适用于全球范围。目前已经发布了EGM84、EGM96、EGM2008和EGM2020四个版本。</p>\n<hr />\n<p>本文节选自作者新书《GIS基础原理与技术实践》第2章。书中系统讲解 GIS 核心理论与多语言实战，适合开发者与高校师生。</p>\n<p>📚 <strong>配套资源开源</strong>：<a href=\"https://github.com/fafa1899/GISBasic\" rel=\"noopener nofollow\" target=\"_blank\">GitHub</a> | <a href=\"https://gitcode.com/charlee44/GISBasic\" rel=\"noopener nofollow\" target=\"_blank\">GitCode</a></p>\n<p>🛒 <strong>支持正版</strong>：<a href=\"https://item.jd.com/14603137.html\" rel=\"noopener nofollow\" target=\"_blank\">京东</a>｜<a href=\"https://product.dangdang.com/29988568.html\" rel=\"noopener nofollow\" target=\"_blank\">当当</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 21:56</span>&nbsp;\n<a href=\"https://www.cnblogs.com/charlee44\">charlee44</a>&nbsp;\n阅读(<span id=\"post_view_count\">34</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "吴恩达深度学习课程五：自然语言处理  第一周：循环神经网络 （四）RNN 中的梯度现象",
      "link": "https://www.cnblogs.com/Goblinscholar/p/19458774",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Goblinscholar/p/19458774\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 21:37\">\n    <span>吴恩达深度学习课程五：自然语言处理  第一周：循环神经网络 （四）RNN 中的梯度现象</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>此分类用于记录吴恩达深度学习课程的学习笔记。<br />\n课程相关信息链接如下：</p>\n<ol>\n<li>原课程视频链接：<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?buvid=XU762317353676D786954061C192FE625463B&amp;from_spmid=playlist.playlist-detail.0.0&amp;is_story_h5=false&amp;mid=zqernykrmpf7XfIorMR%2FnA%3D%3D&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=ce0bc526-db69-428a-962e-c65ed8c267bc&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1713085655&amp;unique_k=DfBgvFW&amp;up_id=8654113&amp;vd_source=e035e9878d32f414b4354b839a4c31a4\" rel=\"noopener nofollow\" target=\"_blank\">[双语字幕]吴恩达深度学习deeplearning.ai</a></li>\n<li>github课程资料，含课件与笔记:<a href=\"https://github.com/robbertliu/deeplearning.ai-andrewNG\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习教学资料</a></li>\n<li>课程配套练习（中英）与答案：<a href=\"https://blog.csdn.net/u013733326/article/details/79827273\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习课后习题与答案</a></li>\n</ol>\n<p>本篇为第五课的第一周内容，<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=158\" rel=\"noopener nofollow\" target=\"_blank\">1.8</a>的内容以及一些相关基础的补充。</p>\n<hr />\n<p>本周为第五课的第一周内容，与 CV 相对应的，这一课所有内容的中心只有一个：<strong>自然语言处理（Natural Language Processing，NLP）</strong>。<br />\n应用在深度学习里，它是专门用来进行<strong>文本与序列信息建模</strong>的模型和技术，本质上是在全连接网络与统计语言模型基础上的一次“结构化特化”，也是人工智能中<strong>最贴近人类思维表达方式</strong>的重要研究方向之一。<br />\n<strong>这一整节课同样涉及大量需要反复消化的内容，横跨机器学习、概率统计、线性代数以及语言学直觉。</strong><br />\n语言不像图像那样“直观可见”，更多是抽象符号与上下文关系的组合，因此<strong>理解门槛反而更高</strong>。<br />\n因此，我同样会尽量补足必要的背景知识，尽可能用比喻和实例降低理解难度。<br />\n本篇的内容关于<strong>RNN 中的梯度现象</strong>，是对 RNN 中存在的问题的阐述，也是对之后的门控机制的引入内容。</p>\n<h1 id=\"1-rnn-中的梯度现象\">1. RNN 中的梯度现象</h1>\n<p>在很久之前，我们就介绍过深度学习训练中的<a href=\"https://www.cnblogs.com/Goblinscholar/p/19190303\" target=\"_blank\">梯度现象</a>，这种情况主要出现在深层神经网络中，在反向传播中随着层层的梯度计算导致梯度过大或过小，从而出现梯度爆炸或者梯度消失，导致网络无法训练。<br />\n而在 RNN 中，即使是我们演示过的单层 RNN ，也可能产生梯度现象，而且这一问题会显得<strong>更加隐蔽，却也更加严重</strong>，其原因就在于 RNN 的<strong>时间反向传播</strong>特性。</p>\n<h2 id=\"11-rnn-的深度\">1.1 RNN 的深度</h2>\n<p>首先，我们知道：<strong>RNN 的“深度”并不体现在空间结构上，而是体现在时间维度上。</strong><br />\n因此，虽然我们画出来的 RNN 看起来只有一层，但在训练时，RNN 会在时间维度上被“展开”为一个<strong>共享参数的深层网络</strong>，就像这样：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260108213552905-491823195.png\" /></p>\n<p>也就是说，如果序列长度为 <span class=\"math inline\">\\(T\\)</span>，那么在反向传播时，梯度就需要沿着时间轴，从第 <span class=\"math inline\">\\(T\\)</span> 个时刻一路反传回第 <span class=\"math inline\">\\(1\\)</span> 个时刻。<br />\n需要说明的是，这里时间展开的长度 <span class=\"math inline\">\\(T\\)</span> 指的是 <strong>RNN 在时间维度上的递推步数</strong>，在我们介绍的基础 RNN 场景下，通常等同于输入序列的长度 <span class=\"math inline\">\\(T_x\\)</span>，而非生成序列的长度 <span class=\"math inline\">\\(T_y\\)</span>。<br />\n最终，从效果上看，这相当于：  <strong>同一组权重矩阵被反复相乘了 <span class=\"math inline\">\\(T\\)</span> 次。</strong></p>\n<p>因此，在 RNN 中，我们同样有必要了解训练中出现梯度现象的处理方法。</p>\n<h2 id=\"12-梯度爆炸的处理梯度裁剪gradient-clipping\">1.2 梯度爆炸的处理：梯度裁剪（Gradient Clipping）</h2>\n<p>在 RNN 的梯度问题中，<strong>梯度爆炸通常是最先、也是最容易被观察到的现象</strong>。<br />\n其表现非常直观：损失函数在训练过程中剧烈震荡，甚至直接变为 NaN，参数更新完全失控，模型无法继续训练。<br />\n与梯度消失不同，梯度爆炸并不是“学不到”，而是 <strong>“学得太猛”</strong>。<br />\n因此，相比梯度消失，梯度爆炸问题更容易被控制和缓解。这很好理解：东西多了我们可以扔，但少了我们不能凭空创造出来。<br />\n而其中一种最常见、也最直接的方法，就是<strong>梯度裁剪（Gradient Clipping）</strong>。</p>\n<p>梯度裁剪的思想非常简单，可以概括为一句话：</p>\n<blockquote>\n<p><strong>当梯度过大时，不让它继续放大更新幅度。</strong></p>\n</blockquote>\n<p>也就是说，我们并不试图改变梯度的“方向”，而只是<strong>限制梯度的“大小”</strong>，从而避免一次参数更新步长过大，破坏训练稳定性。</p>\n<p>再打个比方：在下坡骑车时，我们的方向是对的，但速度太快容易摔，所以我们通过“刹车”来控制风险。<br />\n梯度裁剪，本质上就是反向传播阶段的“数值刹车”。</p>\n<p>在实际使用中，最常见的是<strong>基于梯度范数（norm）的裁剪方式</strong>。<br />\n设所有参数的梯度拼接成一个向量 <span class=\"math inline\">\\(g\\)</span>，其 <strong><span class=\"math inline\">\\(L_2\\)</span> 范数</strong>为：</p>\n<p></p><div class=\"math display\">\\[\\lVert g \\rVert_=\\sqrt{g_1^2 + g_2^2 + \\cdots + g_n^2}  \n\\]</div><p></p><p>我们用 <strong><span class=\"math inline\">\\(L_2\\)</span> 范数</strong>衡量梯度的<strong>整体大小</strong>，它反映的是<strong>这一次反向传播中，参数更新“总体有多激进”</strong>。</p>\n<p>下一步，给定一个<strong>阈值 <span class=\"math inline\">\\(c\\)</span></strong>，梯度裁剪的规则是：</p>\n<p></p><div class=\"math display\">\\[g =\n\\begin{cases}\ng, &amp; \\lVert g \\rVert \\le c \\\\\n\\dfrac{c}{\\lVert g \\rVert} \\, g, &amp; \\lVert g \\rVert &gt; c\n\\end{cases}\n\\]</div><p></p><p>也就是说：</p>\n<ul>\n<li>如果梯度范数在可接受范围内：<strong>不做任何处理。</strong></li>\n<li>如果梯度范数超过阈值：<strong>整体缩放，使其范数恰好等于 <span class=\"math inline\">\\(c\\)</span>。</strong></li>\n</ul>\n<p>这样操作下来，你会发现：<strong>梯度裁剪并不会改变梯度各分量之间的相对比例，只是统一缩放其大小到合适程度。</strong></p>\n<p>这样，在反向传播中，梯度裁剪就会<strong>阻断“指数级放大”的最坏情况</strong>， 保证参数更新始终处在一个稳定区间，从而让训练过程“至少可以继续进行下去”。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260108213603856-931372748.png\" /><br />\n要强调的是：在实际训练中时，<strong>梯度裁剪几乎是默认配置</strong>，而不是可选技巧。</p>\n<p>但是，梯度裁剪也有其局限性：<strong>梯度裁剪只能缓解梯度爆炸，无法解决梯度消失。</strong><br />\n原因很简单：</p>\n<ul>\n<li>梯度爆炸是“数值过大”的问题 → 可以强行压缩</li>\n<li>梯度消失是“信号本身接近于 0” → 裁剪无能为力</li>\n</ul>\n<p>因此，对于梯度消失这一更常见也更难缓解的梯度现象，我们需要别的解决方案，这也是我们下面要讨论的主要内容。</p>\n<h1 id=\"2-rnn-中的梯度消失长距离依赖问题\">2. RNN 中的梯度消失：长距离依赖问题</h1>\n<p>我们知道，<a href=\"https://www.cnblogs.com/Goblinscholar/p/19449622\" target=\"_blank\">RNN</a> 擅长处理序列数据，并能够逐步积累历史信息。然而，在长序列训练中，梯度消失会让早期时间步的影响被逐渐“抹掉”，这就导致了著名的 <strong>长距离依赖问题</strong>：模型难以捕捉序列中相隔较远的信息。<br />\n我们用之前的反向传播例子来演示一下这个问题：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260108213553401-1851089098.png\" /><br />\n注意我们标红的字体：<strong>当序列过长时，与结尾距离很远的最初几步信息很难实现有效更新。因此梯度已经在层层连乘中所剩无几了。</strong><br />\n这样带来的后果是什么？来看看：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260108213555854-2054969424.png\" /></p>\n<p>这就是 RNN 中的梯度消失现象，<strong>它直接导致 RNN 难以捕捉序列中相隔较远的依赖关系</strong>，显然，这对模型性能的影响是巨大的。</p>\n<p>那么如何缓解 RNN 中的梯度消失现象？<br />\n你可能想到了我们之前介绍过的<a href=\"https://www.cnblogs.com/Goblinscholar/p/19359236\" target=\"_blank\">残差网络</a>，即通过在 RNN 中引入<strong>残差连接</strong>，为梯度提供了一条直接传递的通路，可以在一定程度上缓解梯度消失问题，使深层或长序列的训练更加稳定。这的确是一种可行的改进方案。但残差路径虽然提供了梯度直通通道，但<strong>无法进行信息选择性控制</strong>，对于非常长序列仍然存在梯度衰减。<br />\n因此，在 RNN 中，我们有一种更好的技术：<strong>门控机制</strong>，这是在实际实验和部署中我们更常使用的方法，它不仅能保持梯度稳定传递，还能智能控制信息流。<br />\n其原理较为复杂，我们经过本篇的引用，在下一篇来详细展开它。</p>\n<h1 id=\"3-总结\">3. 总结</h1>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>原理</th>\n<th>比喻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>梯度现象（Gradient Phenomena）</strong></td>\n<td>在深层网络或 RNN 的反向传播中，梯度可能过大或过小，导致训练不稳定，即梯度爆炸或梯度消失</td>\n<td>就像水流管道，如果水压过大管道爆裂，水压过小又无法输送水</td>\n</tr>\n<tr>\n<td><strong>RNN 的“深度”</strong></td>\n<td>RNN 在时间维度上展开为共享参数的深层网络，梯度需要沿时间轴反向传播，连续乘以权重矩阵 <span class=\"math inline\">\\(T\\)</span> 次</td>\n<td>好比一个接力赛，每一棒都必须传递能量，接力棒越多，总能量损耗越大</td>\n</tr>\n<tr>\n<td><strong>梯度裁剪（Gradient Clipping）</strong></td>\n<td>当梯度范数超过阈值 <span class=\"math inline\">\\(c\\)</span> 时，对梯度整体缩放，使其范数等于 <span class=\"math inline\">\\(c\\)</span>；不改变梯度方向，只调整大小</td>\n<td>就像给过快下坡的车装刹车，保持安全速度</td>\n</tr>\n<tr>\n<td><strong>RNN 的长距离依赖问题</strong></td>\n<td>梯度在层层连乘或长序列反向传播中逐渐趋近 0，早期时间步的影响被“抹掉”，导致长距离依赖难以学习</td>\n<td>像传话游戏，信息经过太多人，最开始的话慢慢被模糊甚至忘掉</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 21:37</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Goblinscholar\">哥布林学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">79</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "20250702 - FPC Token 攻击事件：严格的限制，灵活的黑客",
      "link": "https://www.cnblogs.com/ACaiGarden/p/19458550",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ACaiGarden/p/19458550\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 19:56\">\n    <span>20250702 - FPC Token 攻击事件：严格的限制，灵活的黑客</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"背景\">背景</h1>\n<p>FPC 是 BPE-20 项目，实现了复杂的交易机制，包括<strong>买卖手续费、流动性池燃烧机制、限制交易频率、限制交易数量</strong>等功能。漏洞产生的原因是当用户卖出代币时，<strong>合约会从流动性池中燃烧代币（而非从卖出者余额中燃烧）</strong>，导致池子中 FPC 代币数量减少，价格抬高。</p>\n<blockquote>\n<p>项目方应该是为了加上流动性池燃烧机制，发现直接加上这不行呀，这个会被利用去套利的。然后打了限制交易频率和限制交易数量两个补丁。希望以此来限制代币持有者通过机制进行获利。</p>\n</blockquote>\n<p>攻击交易</p>\n<ul>\n<li><strong>攻击交易哈希</strong>: <code>0x3a9dd216fb6314c013fa8c4f85bfbbe0ed0a73209f54c57c1aab02ba989f5937</code></li>\n<li><strong>攻击者地址</strong>: <code>0xbf6e706d505e81ad1f73bbc0babfe2b414ba3eb3</code></li>\n</ul>\n<p>漏洞合约</p>\n<ul>\n<li><strong>FPC代币合约</strong>: <code>0xb192d4a737430aa61cea4ce9bfb6432f7d42592f</code></li>\n<li><strong>主要流动性池</strong>: <code>0xa1e08e10eb09857a8c6f2ef6cca297c1a081ed6b</code></li>\n</ul>\n<h1 id=\"trace-分析\">Trace 分析</h1>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260108195418546-1108887978.png\" /></p>\n<ol>\n<li>\n<p>攻击者通过闪电贷获得大量的 USDT</p>\n</li>\n<li>\n<p>在 [FPC, USDT] 池子中购买大量的 FPC</p>\n</li>\n<li>\n<p>把 FPC 转移到新的地址中</p>\n</li>\n<li>\n<p>出售所有的 FPC：先触发<strong>流动性池燃烧机制</strong>，推高了 FPC 的价格，然后再计算出售获得的 USDT，从而获得超额的利润。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260108195438039-1592352059.png\" /></p>\n</li>\n</ol>\n<h1 id=\"代码分析\">代码分析</h1>\n<p>在背景介绍了 FPC 代币实现了<strong>流动性池燃烧机制、限制交易频率、限制交易数量</strong>等功能，接下来将会通过代码实现以及攻击者的手法向读者展示。</p>\n<h2 id=\"在-fpc-usdt-池子中购买大量的-fpc\">在 [FPC, USDT] 池子中购买大量的 FPC</h2>\n<p>在黑客购买 FPC 的操作中，黑客没有通过 router 进行兑换，而是直接调用 pool 进行兑换。</p>\n<pre><code class=\"language-markdown\">CALLCake-LP.swap(**amount0Out=1,000,000,000,000,000,000**, amount1Out=790,178,970,489,172,772,916,652)\n</code></pre>\n<p>并且在购买大量 FPC 代币的同时，还换出了 1 USDT。很反常的操作，如果只是为了购买 FPC，这个amount0Out 的值应为为 0。</p>\n<blockquote>\n<p>黑客这样做的目的是为了绕开最大购买数量的限制</p>\n</blockquote>\n<p>在直接通过 pool 大量购买 FPC 时同时换出 1 个 USDT，目的就为了欺骗 _isLiquidity 函数的检查，伪装成移除流动性的操作，使得 isDel 的值为 true。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260108195457477-1676036854.png\" /></p>\n<p>如果  isDel 的值为 true，就会绕过 <code>value &lt;= _maxBuyAmount()</code> 的限额检查了。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260108195511387-780783212.png\" /></p>\n<h2 id=\"把-fpc-转移到新的地址中\">把 FPC 转移到新的地址中</h2>\n<p>在 FPC 代币中，如果用户进行 swap 操作，会被记录下操作的区块号，并且限制 3 个区块内不允许再次交易。但是它没有对转账操作进行限制，所以攻击者可以通过把 FPC 转移到没有进行过 swap 的地址进行出售，从而绕过这个限制。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260108195529422-1735776335.png\" /></p>\n<h2 id=\"出售所有的-fpc触发流动性池燃烧机制\">出售所有的 FPC：触发<strong>流动性池燃烧机制</strong></h2>\n<p>这一步是关键的步骤，卖出 FPC 代币，触发合约的燃烧机制</p>\n<pre><code class=\"language-markdown\">CALLPancakeSwap: Router v2.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n  amountIn=247,441,170,766,403,071,054,109)\n</code></pre>\n<p>在 sell 的逻辑分支中，会调用 burnLpToken 函数按照出售的数量 value 来销毁 FPC 代币。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260108195542694-2016383265.png\" /></p>\n<p>而在 burnLpToken 函数函数中，燃烧的是 pool 中的代币（不是燃烧 seller 提供的代币，而是直接燃烧 pool 中的代币）。这样会使得 pool 中 FPC 的价格被推高。使得黑客在卖出 FPC 代币时能够获取到更多的利润。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260108195628531-1501728881.png\" /></p>\n<h1 id=\"后记\">后记</h1>\n<p>这个代币在添加流动性池燃烧机制的初衷应该是希望在用户出售代币的时候，啊把池子里面的代币取出来一点，一个是收归项目方所有，第二个是抬高一点币价不要跌的这么快。</p>\n<p>但是，但是在 Pancake 和 Uniswap 的 V2/V3 版本中，都是遵循着“先转账，后结算”的模式去进行 swap 的。而代币设置的各种机制只能在转账的过程中触发，这就使得了这个燃烧机制始终都是发生在结算前的，这就给了黑客套利的空间。如果想要实现这种特殊机制，可以考虑一下通过 Uniswap V4 的 Hook 去实现，但是会对开发的技术与质量要求更高（不得不说后续更新的版本都不如 V2 的 x * y = k 来得简单直接，叽里咕噜又集中流动性又 Hook 说啥呢，我 V2 一把加完流动性就能用。也是为什么直至现在很多代币的发行方都钟爱在 V2 上部署池子）。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 19:56</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ACaiGarden\">ACai_sec</a>&nbsp;\n阅读(<span id=\"post_view_count\">36</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "云原生AI算力平台的架构解读",
      "link": "https://www.cnblogs.com/JulianHuang/p/19458390",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/JulianHuang/p/19458390\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 18:41\">\n    <span>云原生AI算力平台的架构解读</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>给近半年做的云原生AI算力平台做一个回顾， 思考和实践参考了云溪大会上的分享：<a href=\"https://developer.aliyun.com/article/1414573\" rel=\"noopener nofollow\" target=\"_blank\" title=\"为大模型工程提效，基于阿里云 ACK 的云原生 AI 工程化实践\">为大模型工程提效，基于阿里云 ACK 的云原生 AI 工程化实践</a>，全文很长，我这边做一个牵引和解读。</p>\n</blockquote>\n<h2 id=\"1-云计算迎来智算时代\">1. 云计算迎来“智算”时代</h2>\n<p>云计算是一种<strong>通过互联网的方式按需提供计算资源（如服务器、存储、数据库、网络、软件等）</strong>的服务模式， 用户可以像使用水电气一样,按需购买、灵活付费，无需购买和维护物理设备。</p>\n<p>特征是① 按需自助服务 ② 广泛的网络访问 ③ 资源池化  ④ 快速弹性伸缩  ⑤ 使用量计费</p>\n<blockquote>\n<p>为什么叫“云计算”？<br />\n在冯诺依曼体系中，计算资源是CPU，但我们还是以“计算机”来指代包含计算、存储、网络、软件形成的完整服务器；<br />\n在云计算领域，“计算”一次被沿用，将传统计算机核心组件拆开虚拟化、池化，并提供了“用于信息处理所有软硬件要素的总和抽象”。</p>\n</blockquote>\n<p>今天的云计算已经承载了web应用、数据库、大数据、机器学习和高性能计算等计算负载。</p>\n<p>面对LLM和GAI这类对算力和数据都有极高需求的新负载，云计算也迎来了“智算”时代，<br />\n一方面以服务化资源池的概念提供万卡算力、PB级存储、和单机TB级高速网络互联，另一方面以云原生标准化交付算力给大模型的生产者和使用者。</p>\n<h2 id=\"2-大模型带来的挑战\">2. 大模型带来的挑战</h2>\n<p>AI有工程化的要求，同时也对基础设施提出挑战。<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108183944896-1604958658.png\" /><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108183950488-1199602426.png\" /></p>\n<h2 id=\"3-云原生ai的能力\">3. 云原生AI的能力</h2>\n<p>最近在做的“AI大模型基础设施”， 宏观目标也是帮助AI工程从小作坊向端到端云原生解决方案演进。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108183959371-1234056611.png\" /></p>\n<h3 id=\"统一管理异构资源提供资源利用率\">统一管理异构资源，提供资源利用率</h3>\n<p>对idc内各种异构计算（GPU、CPU、NPU等）、存储（OSS、NAS、CPFS、HDFS）、网络（TCP、RDMA）资源进行抽象，统一管理和运维和分配，通过软硬协同优化，提供资源利用率。</p>\n<h3 id=\"通过统一工作流--统一调度-实现ai大数据等复杂任务的高效管理\">通过①统一工作流 ② 统一调度， 实现AI/大数据等复杂任务的高效管理</h3>\n<ul>\n<li>\n<p>从异构资源管理的角度，可一键部署、操作各种异构资源，在运维过程中，需要多维度的异构资源可观测性： 监控、健康检查、告警、自愈等自动化运维能力</p>\n</li>\n<li>\n<p>对于宝贵的GPU/NPU算力资源，使用各种调度、隔离、共享的方式提供资源利用率</p>\n</li>\n<li>\n<p>分钟级准备好开发和测试环境，帮助算法工程师把 ①执行深度学习任务②产出/评测模型③模型部署 以端到端的工作流串起来， 天然支持主流框架 tensorflow/pytorchjob/mpi<br />\n--  对于分布式任务，提供丰富的任务调度策略，如Gang scheduling、Capacity scheduling、Topology aware scheduling、优先级队列等。</p>\n</li>\n<li>\n<p>提供弹性训练和弹性推理服务， 建立统一的数据集管理，模型生命周期管理， 优化模型访问性能，通过标准API使推理能力易于被业务应用集成。</p>\n</li>\n</ul>\n<h2 id=\"4-云原生ai的架构实践\">4. 云原生AI的架构实践</h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108184015761-1427603173.png\" /></p>\n<p>我们的云原生AI算力平台， 有参考上面的实践，针对企业业务的现状和侧重， 技术调研上做了调整和裁剪。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108184025350-220307939.png\" /></p>\n<p>没有从0到1的使用kubeflow全家桶，使用了arena、 kubeflow  trainer。</p>\n<blockquote>\n<p><a href=\"https://www.kubeflow.org/docs/started/architecture/\" rel=\"noopener nofollow\" target=\"_blank\" title=\"kubeflow\">kubeflow</a>是一个包含多个开源项目的AI生态组合， kubeflow以Kubernetes为底座，目标是成为部署、扩展和管理AI平台的系统。</p>\n</blockquote>\n<p>在平台侧，我们统一纳管了集群资源，实现了统一调度能力和模型生命周期管理，关联了公司自有的数据存储（涉及数据集预热、模型存储），<br />\n这里有一个技术点：Go动态感知资源变更的技术实践，你指定用过！</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108184044867-660442933.png\" /></p>\n<p>用户行为的触发点是arena， 我们使用arena提交了训练任务。 ref:  Golang 文本模板，你指定没用过!</p>\n<p>在调度侧，使用tranning operator和kerve组件，tranning operator 提供统一的训练工作流， kserve提供了将模型以云原生方式部署、扩缩容的能力。</p>\n<p>arena产生训练任务/部署动作---&gt; 内部helm形成对应的CRD（pytorchjob、InferenceService)---&gt;控制器监听CRD的变更---&gt; 生成底层资源（deploy/service/network)</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108184107591-1084626310.png\" /></p>\n<p>各算法团队天然对应租户概念，也就是k8s命名空间， 我们给租户下面每一个用户颁发了一个<a href=\"https://blog.miniasp.com/post/2022/08/24/Understanding-Service-Account-in-Kubernetes-through-MicroK8s\" rel=\"noopener nofollow\" target=\"_blank\" title=\"serviceAccount\">serviceAccount</a>作为登录和操作凭据。</p>\n<p>为实现自动任务调度，我们引入了kueue这样的任务队列组件，在任务被k8s调度器调度之前做准入，kueue成为了异构资源池化多租户配额、任务排队的技术支撑。</p>\n<p>有关kueue的使用，请参考：🎉在k8s调度的花园里面挖呀挖 。<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108184122928-1792259600.png\" /></p>\n<p>为适配AI工程化的调度要求，我们使用Koordinator调度器支持了binpack装箱调度。</p>\n<p>什么叫binpack， 为什么AI训练需要binpack， 请参考:🎉卷不过AI算法， AI工程化或许是一个出路？<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108184133179-1065900826.png\" /></p>\n<p>最后平台需要管控多渠道的任务，我们使用 informer机制监听了多渠道任务并回显到页面， 这里有个技术点，值得参考。</p>\n<p>🚀糟糕，我实现的k8s informer好像是依托答辩<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108184141433-1556621842.png\" /></p>\n<p><img alt=\"\" src=\"https://files.mdnice.com/user/4236/528d857f-9d29-4937-8275-20accf704f4e.png\" /></p>\n\n</div>\n<div id=\"MySignature\">\n    <hr color=\"#987cb9\" size=\"3\" width=\"80%\" />\n<div style=\"text-align: center;\">\n<p>本文来自博客园，作者：{有态度的马甲}，转载请注明原文链接：<a href=\"https://www.cnblogs.com/JulianHuang/p/19458390\" target=\"_blank\">https://www.cnblogs.com/JulianHuang/p/19458390</a></p>\n<strong style=\"color: red;\">欢迎关注我的原创技术、职场公众号， 加好友谈天说地，一起进化</strong>\n<div><img src=\"https://blog-static.cnblogs.com/files/JulianHuang/QR.gif\" style=\"width: 250px; height: 250px;\" /> </div>\n\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 18:41</span>&nbsp;\n<a href=\"https://www.cnblogs.com/JulianHuang\">码甲哥不卷</a>&nbsp;\n阅读(<span id=\"post_view_count\">37</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "JVM 堆内存分代",
      "link": "https://www.cnblogs.com/yanshajiuzhou/p/19458321",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yanshajiuzhou/p/19458321\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 18:25\">\n    <span>JVM 堆内存分代</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        不同存活周期的对象放在不同区域，用不同算法回收，保证 GC 效率，这就是&nbsp;\"分代回收\" 的核心思想。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><span>​</span>今天我们一起来聊一聊 <strong>JVM 堆内存</strong>。</p>\n<p><img alt=\"Java Heap1\" src=\"https://img2024.cnblogs.com/blog/1171560/202601/1171560-20260108182258403-1042762825.png\" /></p>\n<p><strong>Java Heap</strong>（堆内存）由 <strong>Young Generation</strong>（新生代，约占 <strong>1/3&nbsp;</strong>）和&nbsp;<strong>Old Generation</strong>（老年代，约占 <strong>2/3</strong> ）组成。</p>\n<p><strong>Young Generation </strong>又由&nbsp;<strong>Eden Space</strong>（伊甸园区，占新生代 <strong>80%&nbsp;</strong>）、<strong>Survivor Space 0</strong>（幸存者区0，占新生代 <strong>10%&nbsp;</strong>）和 <strong>Survivor Space 1</strong>（幸存者区1，占新生代 <strong>10%&nbsp;</strong>）组成。</p>\n<p><strong>对象的生命周期</strong>：</p>\n<p><img alt=\"对象生命周期\" src=\"https://img2024.cnblogs.com/blog/1171560/202601/1171560-20260108182353974-1428015339.png\" /></p>\n<p><strong>Young Generation</strong>（新生代）：</p>\n<ul>\n<li>存储 <strong>新创建</strong>、<strong>存活周期极短</strong> 的对象，比如方法内的局部变量、临时对象。默认占堆总容量 <strong>1/3 </strong>。</li>\n<li>触发 <strong>Minor GC</strong>（新生代 GC），频率极高（毫秒 / 秒级），但耗时极短（几十毫秒）。</li>\n<li>Eden 区是 Minor GC 的 \"触发源头\"，调大 Eden 区可减少 Minor GC 次数。</li>\n</ul>\n<p><strong>Eden Space</strong>（伊甸园区）：新对象的 \"默认出生地\"，<strong>99% 的新对象&nbsp;</strong>都会优先分配到 Eden 区（除非是超大对象直接进入老年代）。占新生代 <strong>80%&nbsp;</strong>。</p>\n<p><strong>Survivor Space 0/1</strong>（幸存者区 0/1，简称 S0/S1，也叫 From 区 / To 区）：</p>\n<ul>\n<li>新生代 GC 后存活对象的 <strong>\"临时中转站\"</strong>，避免存活对象直接进入老年代。<strong>两个区会动态互换角色</strong>。各占新生代 <strong>10%</strong>，合计 20%。</li>\n<li>S0 和 S1&nbsp;<strong>永远有一个是空的</strong>（这是 JVM 的设计巧思）。</li>\n<li>每经历一次 Minor GC，存活对象的 <strong>\"年龄 + 1\"</strong>。</li>\n</ul>\n<p><strong>S0/S1 的交互</strong> 示例：</p>\n<ul>\n<li>① 初始状态：Eden 有对象，S0 有对象，S1 为空；</li>\n<li>② Eden 触发 Minor GC → 回收 Eden+S0 的垃圾对象，存活对象复制到 S1，清空 Eden+S0；</li>\n<li>③ 此时 S1 非空、S0 为空，两者角色互换（S0=To 区，S1=From 区）；</li>\n<li>④ 下次 Minor GC 重复上述过程，存活对象在 S0/S1 之间 <strong>\"来回复制\"</strong>。</li>\n</ul>\n<p><strong>Old Generation</strong>（老年代）：</p>\n<ul>\n<li>存储&nbsp;<strong>长期存活、体积较大&nbsp;</strong>的对象，比如单例对象、缓存对象、经历多次 Minor GC 仍存活的对象。默认占堆总容量 <strong>2/3</strong>。</li>\n<li>触发&nbsp;<strong>Major GC / Full GC</strong>，频率极低，但耗时极长。</li>\n<li>老年代大小决定 Full GC 频率 —— 老年代越大，Full GC 频率越低，但单次 Full GC 耗时越长。</li>\n</ul>\n<p><strong>对象进入老年代的条件</strong>：</p>\n<ul>\n<li><strong>年龄达标</strong>：对象在 S0/S1 之间复制次数达到阈值（默认 15 次，<code>-XX:MaxTenuringThreshold</code>调整）；</li>\n<li><strong>大对象</strong>：超过阈值的对象（<code>-XX:PretenureSizeThreshold</code>）直接进入老年代；</li>\n<li><strong>空间担保失败</strong>：Minor GC 后 Survivor 区放不下存活对象，多余对象直接晋升老年代；</li>\n<li><strong>动态年龄判断</strong>：Survivor 区中相同年龄对象总和超过 50%，该年龄及以上对象直接进入老年代。</li>\n</ul>\n<p>不同存活周期的对象放在不同区域，用不同算法回收，保证 <strong>GC</strong> 效率，这就是&nbsp;<strong>\"分代回收\" </strong>的核心思想。</p>\n<p style=\"text-align: right;\"><span style=\"color: rgba(53, 152, 219, 1);\">努力的意义，不在于追逐别人的高度，而是拼尽全力，为自己创造一个绝地反击的故事。-- 烟沙九洲</span></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 18:25</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yanshajiuzhou\">烟沙九洲</a>&nbsp;\n阅读(<span id=\"post_view_count\">35</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "你们如何运行Agent生成的代码？或许你也需要一个Agent-Sandbox，Agent-Sandbox开源首发",
      "link": "https://www.cnblogs.com/xguo/p/19457007",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xguo/p/19457007\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 15:41\">\n    <span>你们如何运行Agent生成的代码？或许你也需要一个Agent-Sandbox，Agent-Sandbox开源首发</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"你们如何运行Agent生成的代码？或许你也需要一个Agent-Sandbox，Agent-Sandbox开源首发\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/57355/202601/57355-20260108145436183-1755523701.png\" />\n        Manus的高价出售，让Sandbox再次进入人们的视野，它之前用的Sandbox是E2B，这是一个非常强大的Sandbox工具，它可以帮助Agent执行代码或命令，但它不方便我们使用，之前我们的办法是部署一个Python的执行代码的服务，或着部署一个Playwright的服务，各自提供MCP或普通API，来满足需求，但是遇到的问题也是显而易见的，那就是无法实现多次访问的隔离，例如一个Agent访问了A网站，另一个Agent访问了B网站，就会相互干扰，性能也是问题，除非你部署很多实例，那也浪费。那我们的选择是什么？\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<div style=\"text-align: center;\">\n\n<img height=\"381px\" src=\"https://img2024.cnblogs.com/blog/57355/202601/57355-20260108144423805-386973583.png\" width=\"255px\" />\n\n</div>\n<h2 id=\"开源地址\">开源地址：</h2>\n<p><strong>Agent-Sandbox</strong> <a href=\"https://github.com/agent-sandbox/agent-sandbox\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/agent-sandbox/agent-sandbox</a></p>\n<h2 id=\"效果预演\">效果预演：</h2>\n<p><img alt=\"gitdemo\" src=\"https://img2024.cnblogs.com/blog/57355/202601/57355-20260108144402352-314698307.gif\" /></p>\n<h2 id=\"1为什么需要agent-sandbox\">1，为什么需要Agent-Sandbox？</h2>\n<p>在我们的业务中，经常需要让Agent执行一些代码或者访问网站等，例如用户提供了一个excel文件，处理里面的一些数据，最终生成报告，或者用户提供了一个网站，让Agent访问网站，然后获取一些数据，最终生成报告。</p>\n<p>这些都是很常见的场景，例如最近非常受关注的Manus，卖了很多钱的那个（羡慕啊～）,它就是利用了各种工具来完成用户的复杂任务，你们知道的。</p>\n<p>但问题来了，我们如何让Agent执行这些代码或者访问网站呢？</p>\n<p>因此Manus把E2B带火了，E2B是一个非常强大的Sandbox工具，它可以帮助Agent执行代码或命令，但是E2B基本上是个商业的，不方便我们使用，之前我们的办法是部署一个Python的执行代码的服务，或着部署一个Playwright的服务，各自提供MCP或普通API，来满足需求，但是遇到的问题也是显而易见的，那就是无法实现多次访问的隔离，例如一个Agent访问了A网站，另一个Agent访问了B网站，就会相互干扰，性能也是问题，除非你部署很多实例，那也浪费。</p>\n<p>这个问题你们是怎么解决的？</p>\n<h2 id=\"2agent-sandbox\">2，Agent-Sandbox</h2>\n<p><img alt=\"sbarch\" height=\"649\" src=\"https://img2024.cnblogs.com/blog/57355/202601/57355-20260108203145347-977491529.jpg\" width=\"1071\" /></p>\n<p>没有选择，只能自己搞了，上半年我们拉了几个兄弟，按照以上的痛点，开发了一个Agent-Sandbox，是的，名字就叫<strong>Agent-Sandbox</strong>，是不是很技术流，</p>\n<p>目前已经在生产环境使用了，效果还不错，支持MCP和REST API，Agent可以在任何需要的时候创建一个Sandbox，然后执行代码，访问网站等，完事儿后自己删除Sandbox，非常方便。</p>\n<p>不过最近也发现市面上出现很多关于Agent Sandbox的工具和讨论，开源的包括<a href=\"https://github.com/kubernetes-sigs/agent-sandbox\" rel=\"noopener nofollow\" target=\"_blank\">kubernetes-sigs/agent-sandbox</a> 、 <a href=\"https://github.com/agent-infra/sandbox\" rel=\"noopener nofollow\" target=\"_blank\">AIO Sandbox</a> 等，说明大家也在解决这个问题，AIO Sandbox这个是火山的，只提供一个集成化的Sandbox环境，也就是一个Docker的Image，里面有各种工具，包括执行代码、浏览器、文件系统等，而kubernetes-sigs/agent-sandbox是个部署工具，可以部署各种Sandbox环境，例如他就支持部署AIO Sandbox，可以通过它拉起很多AIO Sandbox的实例，但功能还是太基础了，无法直接给Agent使用，安装也麻烦，要求的Kubernetes版本比较高，目前大家生产用的K8S的版本都比较滞后。</p>\n<p>像我们这样开源的Sandbox还是没有看到，我们就决定把我们这个开源给大家，也许大家跟我们希望的一样，那就可以用得上了。</p>\n<h2 id=\"3agent-sandbox有哪些特点\">3，Agent-Sandbox有哪些特点？</h2>\n<p>目前实现了主要的功能，包括通过MCP或REST API来CRUD Sandbox，指定Sandbox的Image等，后续会支持更多场景的Sandbox运行环境，支持各种SDK，来满足编程场景的Sandbox控制，更多Sandbox的管理功能，包括TTL回收、无调用回收等，以及管理UI，可以看到在创建的全部Sandbox和相关操作，也可以通过这个UI来创建Sandbox等，方便与治理。</p>\n<p><img alt=\"full-lifecycle-demo\" height=\"601\" src=\"https://img2024.cnblogs.com/blog/57355/202601/57355-20260108144446225-906065250.png\" width=\"1129\" /></p>\n<h3 id=\"特性\">特性：</h3>\n<ol>\n<li>Ai使用友好，可以直接让Agent控制Sandbox的全生命周期，而不一定得提前创建好，在给Agent去使用，Agent按需创建和回收；</li>\n<li>生态开放，部署的Sandbox运行环境可以与社区的兼容，列如可以直接拉起前面提到的AIO Sandbox、Code Server或Playwright等，方便大家利用现有的资源，当然，可以自定义运行环境；</li>\n<li>企业生产可用，当然，考虑前面提到的痛点，基于K8S开发，支持规模化使用，根据需要，可以大量创建Sandbox，相互之间隔离使用；</li>\n<li>轻量化，就一个组件，没有采用K8S的CRD来开发，这个后续用户按照和升级都比较麻烦，用户得接受一种新的资源类型，我们采用RS+Label的方式，尽量依赖K8S现有的特性来快速实现。</li>\n</ol>\n<h2 id=\"4如何使用agent-sandbox\">4，如何使用Agent-Sandbox？</h2>\n<p>所以怎么使用呢，过程非常简单，主要分两步：</p>\n<h3 id=\"1部署agent-sandbox\">1，部署Agent-Sandbox</h3>\n<p>要求 <strong>Kubernetes version 1.26</strong> 或以上， 在 <code>https://github.com/agent-sandbox/agent-sandbox</code> 下载 <code>install.yaml</code> 后，</p>\n<pre><code class=\"language-bash\">kubectl create namespace agent-sandbox\nkubectl apply -nagent-sandbox -f install.yaml\n</code></pre>\n<p>里面会安装deployment、service等，之后你应该是需要配置一个ingress，如：</p>\n<pre><code class=\"language-yaml\">apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: agent-sandbox\n  namespace: agent-sandbox\nspec:\n  ingressClassName: ingress-nginx\n  rules:\n    - host: agent-sandbox.your-host.com\n      http:\n        paths:\n          - backend:\n              service:\n                name: agent-sandbox\n                port:\n                  number: 80\n            path: /(.*)\n</code></pre>\n<p>主要是 <code>host</code> 需要你给出，其他可以直接使用。</p>\n<h3 id=\"2使用agent-sandbox\">2，使用Agent-Sandbox</h3>\n<h4 id=\"21通过agent-sandbox-mcp-server\">2.1，通过Agent-Sandbox MCP Server</h4>\n<p>Agent-Sandbox MCP Server 地址： <code>http://agent-sandbox.your-host.com/mcp</code> ，提供了Sandbox的CURD等Tools。</p>\n<p><strong>效果测试：</strong></p>\n<p>一个简单的Demo，Agent 写个斐波那契额函数，然后通过MCP Server创建一个Sandbox，来计算，最后删除Sandbox。<br />\n<em>是个Gif动画，如果不播放，可以新窗口打开。</em></p>\n<p><img alt=\"gitdemo\" src=\"https://img2024.cnblogs.com/blog/57355/202601/57355-20260108144402352-314698307.gif\" /></p>\n<h4 id=\"22通过agent-sandbox-restful-api\">2.2，通过Agent-Sandbox RESTful API</h4>\n<p>Agent-Sandbox提供RESTful API来管理Sandbox，典型的工作流程包括创建Sandbox、访问Sandbox、删除Sandbox。</p>\n<p><strong>a，创建一个Sandbox</strong></p>\n<pre><code class=\"language-shell\">curl --location '/api/v1/sandbox' \\\n--header 'Content-Type: application/json' \\\n--data '{\"name\":\"sandbox-01\"}'\n</code></pre>\n<p>默认会拉起AIO Sandbox，可以通过以下方式，指定国内镜像，</p>\n<pre><code class=\"language-shell\">curl --location '/api/v1/sandbox' \\\n--header 'Content-Type: application/json' \\\n--data '{\"name\":\"sandbox-01\",\"image\":\"enterprise-public-cn-beijing.cr.volces.com/vefaas-public/all-in-one-sandbox:latest\"}'\n</code></pre>\n<p><strong>b，访问Sandbox</strong><br />\n<code>/sandbox/{sandbox_name}</code> 通过这个地址可以访问Sandbox,</p>\n<p>例如刚才创建的 <strong>sandbox-01</strong> 访问地址是： <code>/sandbox/sandbox-01</code>.</p>\n<p>访问后你应该会看到：</p>\n<p><img alt=\"aio-demo\" height=\"956\" src=\"https://img2024.cnblogs.com/blog/57355/202601/57355-20260108144513435-1606524670.jpg\" width=\"1464\" /></p>\n<p>访问这个Sandbox的MCP地址是： <code>http://agent-sandbox.your-host.com/sandbox/sandbox-01/mcp</code> ，这种场景是先创建好Sandbox，然后让Agent去访问这个Sandbox。</p>\n<p><strong>c，删除Sandbox</strong></p>\n<p>删除API： <code>/api/v1/sandbox/{sandbox_name}</code> . 例如删除Sandbox <code>sandbox-01</code> :<br />\n<strong>Shell</strong></p>\n<pre><code class=\"language-shell\">curl --location --request DELETE '/api/v1/sandbox/sandbox-01'\n</code></pre>\n<p><strong>结果:</strong></p>\n<pre><code class=\"language-json\">{\n  \"code\": \"0\",\n  \"data\": \"Sandbox sandbox-01 deleted successfully\"\n}\n</code></pre>\n<h2 id=\"结尾\">结尾</h2>\n<p>以上就是Agent-Sandbox的简单介绍和使用方法，更多内容请关注<a href=\"https://github.com/agent-sandbox/agent-sandbox\" rel=\"noopener nofollow\" target=\"_blank\">Agent-Sandbox</a>项目，后续我们会持续更新更多功能和特性，包括提到的支持更多场景的Sandbox运行环境，支持各种SDK来满足编程场景的Sandbox控制，更多Sandbox的管理功能，包括TTL回收、无调用回收，并发弹性伸缩等，以及管理UI，可以看到和管理创建的全部Sandbox，也可以通过这个UI来创建和操作Sandbox，例如上传下载文件、查看日志、执行命令、查看状态等。</p>\n<p>最后欢迎大家Star、Issue和PR~</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 15:41</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xguo\">i'm老土豆</a>&nbsp;\n阅读(<span id=\"post_view_count\">122</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "为什么很多伟大的作品都是诞生在一些不起眼的地方",
      "link": "https://www.cnblogs.com/lixingqiu/p/19457141",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lixingqiu/p/19457141\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 15:23\">\n    <span>为什么很多伟大的作品都是诞生在一些不起眼的地方</span>\n    \n\n</a>\n</h1>\n\t<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>在历史的长河中，我们不难发现，许多震撼人心、改变世界的伟大作品，往往并非出自繁华喧嚣的大都市，而是诞生于一些看似平凡甚至有些偏僻的角落。</p>\n<p>比如，梵高的许多传世画作，是在法国南部那个宁静的小村庄阿尔勒创作出来的。那里没有巴黎的灯红酒绿与艺术圈的纷繁复杂，有的只是质朴的田园风光和淳朴的村民。正是在这样相对安静的环境中，梵高得以全身心地投入到绘画创作中，用他那独特的笔触和色彩，描绘出一幅幅充满生命力的作品，给后世留下了无尽的艺术瑰宝。</p>\n<p>再比如，美国作家马克·吐温，他的许多经典文学作品，灵感来源于他童年生活的密西西比河畔小镇。那个远离城市喧嚣的地方，有着独特的风土人情和社会风貌，为他的写作提供了丰富的素材。他在那片土地上，观察着形形色色的人物，体验着生活的酸甜苦辣，从而创作出了《汤姆·索亚历险记》《哈克贝利·费恩历险记》等不朽之作。</p>\n<p>还有，著名的数学家陈景润，在一个并不起眼小县城里，默默钻研哥德巴赫猜想。在那个条件相对艰苦的环境中，他凭借着对数学的热爱和执着，克服了重重困难，最终取得了举世瞩目的成就，为数学领域的发展做出了巨大贡献。</p>\n<p>而如今，我们要说的<strong>C++精灵库</strong>，它的诞生地同样是一个毫不起眼的地方——江西省萍乡市。这里曾经是江南煤都，然而随着煤炭资源的枯竭，这座城市逐渐失去了往日的辉煌。人口不断流出，街头巷尾充斥着麻将声和抖音里各种喧闹的声音。想象一下，在这样的五线小城市里，年轻人大多选择逃离，前往长沙、南昌、杭州等大城市，甚至是一线城市去追寻自己的梦想，留下的大多是一些安于现状或者因各种原因无法离开的人。</p>\n<p>但是，就是在这样的环境中，却诞生了如此优秀的<strong>C++精灵库</strong>。它的背后，有一位了不起的人物——李兴球老师。李老师可是上世纪的学霸，年轻时曾在充满机遇与挑战的一线城市深圳闯荡了7年。自2010年发现Scratch图形化计算机语言以来，他便扎根在萍乡，从事青少儿编程教育长达10多年。</p>\n<p>时间来到2019年末，这是一个具有特殊意义的节点。李老师开始着手Python精灵模块的开发。为什么要开发这个模块呢？这源于李老师那颗始终充满好奇的心。在教学过程中，他敏锐地发现了Python turtle功能上的不足。比如说，想要让角色的造型图片进行缩放，或者是进行像素级别的碰撞检测，这些功能在Python turtle中都没有。于是，李老师便深入研究python turtle库的源文件turtle.py，经过不懈的努力，最终成功编写出了Python精灵模块。这一段经历，其实为后来C++精灵库的诞生埋下了深厚的根基，因为任何伟大的创新都不是凭空而来的，都需要有前期的积累和探索。</p>\n<p>岁月流转，到了2025年8月，暑假课程结束了。李老师那颗探索的心再次萌动起来。在人们的传统观念中，C++是一门非常难学的编程语言，似乎只有那些所谓的“小天才”才能掌握。这种观念流传至今，几乎已经固化。但李老师却不这么想，他一直思考着如何降低C++的教学门槛。一个大胆的想法在他脑海中浮现：能不能把Python turtle的命令移植到C++中呢？这样一来，学生们在学习了Python turtle之后再学习C++，岂不是会容易很多？</p>\n<p>为了实现这个想法，李老师进行了多方面的调研。他深入研究底层技术，了解现有的库是否能够满足需求。经过深思熟虑，李老师最终决定采用SDL2库进行全新编写。这样做的好处是显而易见的，基于工业级别的SDL2库，不仅底层代码可以全程掌握，而且拓展性极强，为后续的开发和完善提供了广阔的空间。</p>\n<p>在这个小城市里，李老师已经实现了生活无忧，并且能够完全掌控自己的时间，没有绩效考核等繁琐的压力。所以，暑假过后，从周一到周五，他每天都全身心地投入到C++精灵库的开发与调试工作中。有时候，一个小小的问题可能需要花费好几天的时间来解决。如果是在一线城市，这样的时间和人力成本无疑是巨大的，但在五线小城市，相对来说就显得微不足道了。也许，只有在这种相对“休闲”的状态中，人才能静下心来，专注于一件事情，从而做出伟大的、革命性的产品。</p>\n<p>如今，C++精灵库已经实现了超越。就拿它的链式调用来说，这种设计让代码更加优雅，更接近自然语言，大大降低了学习和使用的难度。李老师还精心设计了许多画笔颜色的调节命令，如penshade、pentone、pensat以及penhsv等，这些在Python turtle中都是没有的。这些独特的命令，为美术生的艺术创造打开了方便之门，让他们能够在编程的世界里更加自由地发挥想象力和创造力。</p>\n<p>让我们来看下面的C++代码：</p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:cpp;gutter:true;\">#include \"sprites.h\"  //包含C++精灵库 \nSprite turtle;       //建立角色叫turtle \n\nint main(){        //主功能块 \n   turtle.bgcolor(\"black\");\n   turtle.pensize(4).speed(0);\n   for(int i=0;i&lt;36;i++)\n       turtle.fd(10).left(10);\n   for(int i=0;i&lt;36;i++)\n       turtle.fd(10).right(10); \n    \n   turtle.ht(); \n   turtle.done();  \n   return 0;\n}\n</pre>\n</div>\n<p>　　再看下对应的Python turtle代码：</p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:php;gutter:true;\">import turtle\nturtle.bgcolor(\"black\")\nturtle.pensize(4)\nturtle.speed(0)\nfor i in range(36):\n    turtle.fd(10)\n    turtle.left(10)\nfor i in range(36):\n    turtle.fd(10)\n    turtle.right(10)\n</pre>\n</div>\n<p>　　</p>\n<p>它们的本质是一样的！C++版本的核心逻辑代码，只需稍加修改，将C++的链式调用改成Python的单个命令调用，复制到Python IDLE中就能运行。不过，这一改，倒是把原本优雅的C++代码换成了传统的Python书写方式。</p>\n<p>所以说，为什么很多伟大的作品都是诞生在一些不起眼的地方呢？因为在这里，人们可以摆脱外界的干扰和压力，以最低的成本去追求自己的理想，同时又能将自己的价值最大化。就像C++精灵库一样，它在萍乡这个小城市里诞生，却有可能为整个编程教育领域带来深远的影响。</p>\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-01-08 15:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lixingqiu\">李兴球</a>&nbsp;\n阅读(<span id=\"post_view_count\">306</span>)&nbsp;\n评论(<span id=\"post_comment_count\">4</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "自适应可变速率ID生成器的设计与实践(视频)",
      "link": "https://www.cnblogs.com/Zongsoft/p/19457036/sequence",
      "published": "",
      "description": "<a name=\"top\"></a>\n    <h2><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Zongsoft/p/19457036/sequence\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 15:03\">\n    <span>自适应可变速率ID生成器的设计与实践(视频)</span>\n    \n\n</a>\n</h2>\n    <small>\n<span id=\"post-date\">2026-01-08 15:03</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Zongsoft\">Zongsoft</a>&nbsp;\n阅读(<span id=\"post_view_count\">102</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</small>\n    <div class=\"entry\">\n            <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        在分布式系统架构中，全局唯一ID生成器是支撑高并发、高可用系统的基石。市面上的常见方案（如Snowflake-ID、UUID、Redis自增）各有优劣，但往往难以兼顾高性能、无中心化与灵活的业务需求。\n本系列视频将带你深入剖析一个开源项目中的核心组件，重点解析如何设计一款能智能适应流量波动、兼顾全局唯一与趋势递增特性的高性能ID生成器。我们将从理论设计、性能压测到源码实现，全方位解读这套算法如何在保证极高吞吐量的同时，实现毫秒级的自适应与可变速率调节。\n无论你是架构师、后端开发工程师，还是对高性能算法感兴趣的爱好者，这个系列都将为你提供宝贵的实战经验和深度的技术洞察。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在分布式系统设计中，ID生成器 <em>(<strong>S</strong>equence)</em> 是看似基础却至关重要的组件。然而，一些常用解决方案 <em>(如 Snowflake-ID 算法)</em> 在高并发、弹性伸缩场景下，常面临机器节点分配、时钟回拨、序列号耗尽、跨机房容错等挑战。你是否也曾为这些问题困扰？</p>\n<p><a href=\"http://zongsoft.com\" rel=\"noopener nofollow\" target=\"_blank\"><em><strong>Z</strong>ongsoft</em></a> 开源项目中的 <a href=\"https://github.com/Zongsoft/framework/blob/master/Zongsoft.Core/src/Common/Sequence.cs\" rel=\"noopener nofollow\" target=\"_blank\"><em>自适应可变速率ID生成器</em></a>，或许能为你提供一种新的思路。</p>\n<p>我强烈推荐大家关注近期上线的 <strong>视频系列</strong>：《<a href=\"https://space.bilibili.com/20995572\" rel=\"noopener nofollow\" target=\"_blank\">自适应可变速率ID生成器的设计与实践</a>》。</p>\n<p>系列视频采取 “<strong>理论</strong>-<strong>实验</strong>-<strong>源码</strong>” 三层递进结构，涵盖从设计理念到性能验证再到实现细节的完整知识链，展示了如何设计并实现一个智能适应流量波动、兼顾全局唯一与高信息密度、高性能的解决方案。无论是分布式系统初学者还是资深工程师都能从中获益。其亮点在于：</p>\n<ol>\n<li>\n<p><strong>直面痛点，突破传统局限​</strong></p>\n<p>视频中对比了 Snowflake-ID、UUID、数据库自增等方案的优劣，并重点解析了如何通过动态速率调整和时钟回拨容错机制，避免序列号争用与时间同步问题。这种设计尤其适合流量突增场景 <em>（如秒杀、日志高频写入）</em>，显著提升系统的稳定性。</p>\n</li>\n<li>\n<p><strong>实验驱动，数据说话​</strong></p>\n<p>系列中通过 <strong>6</strong> 组严谨实验，验证了算法在性能、正确性、稳定性方面的表现，并与原生 Redis 生成器进行对比。结果清晰展示了其在高压下的吞吐量优势，为技术选型提供了可靠依据。</p>\n</li>\n<li>\n<p><strong>开源实战，源码级解读​</strong></p>\n<p>视频直接基于 <a href=\"https://github.com/Zongsoft/framework\" rel=\"noopener nofollow\" target=\"_blank\"><em><strong>Z</strong>ongsoft</em></a> 开源项目代码解析，从位运算设计到异常处理逻辑，逐行拆解实现细节。无论是学习分布式系统设计，还是需要二次开发，都具有极高参考价值。</p>\n</li>\n</ol>\n<blockquote>\n<p>无论你是架构师、后端开发工程师，还是对高性能算法感兴趣的爱好者，这个系列都将为你提供宝贵的实战经验和深度的技术洞察。又或者你正在构建高并发系统，或对分布式基础组件有深入探索的兴趣，这一系列视频将是不可多得的学习资源。<br />\n它不仅能帮助你理解ID生成器的本质，更能拓宽解决复杂问题的思路。</p>\n</blockquote>\n<hr />\n<h3 id=\"-视频-1自适应可变速率id生成器设计与实践上\">🎥 视频 1：自适应可变速率ID生成器设计与实践(上)</h3>\n<blockquote>\n<p>副标题： 从理论到架构：为什么我们需要新的ID生成方案？<br /><br />\n视频地址：<a href=\"https://www.bilibili.com/video/BV15fiSBXEW5\" rel=\"noopener nofollow\" target=\"_blank\">https://www.bilibili.com/video/BV15fiSBXEW5</a></p>\n</blockquote>\n<p>在本系列的第一部分，我们将首先对现有的常见分布式ID生成方案进行深度的横向对比与剖析。</p>\n<p>深入探讨 Snowflake ID 的机器节点分配和时钟回拨、时钟漂移问题、UUID 的无序性、时钟问题与存储浪费、数据库自增ID的性能瓶颈与各种限制，以及 Redis 递增方案的优缺点。</p>\n<p>详细阐述本算法的设计初衷与核心理念；在此基础上，视频深入阐述自适应可变速率ID生成器的设计目标与核心理念，重点讲解如何通过动态速率调整、时钟回拨容错等机制，解决传统方案在高并发场景下的序列号耗尽、时钟同步等痛点问题。该视频为理解后续实验与源码实现奠定理论基础。</p>\n<h3 id=\"-视频-2自适应可变速率id生成器设计与实践中\">🎥 视频 2：自适应可变速率ID生成器设计与实践(中)</h3>\n<blockquote>\n<p>副标题： 数据说话：性能、稳定性与正确性的硬核实测<br /><br />\n视频地址：<a href=\"https://www.bilibili.com/video/BV1EQiSBtE38\" rel=\"noopener nofollow\" target=\"_blank\">https://www.bilibili.com/video/BV1EQiSBtE38</a></p>\n</blockquote>\n<p>光有理论不够，数据才是硬道理。在本集中，我们将通过 <strong>6</strong> 个精心设计的实验，对算法进行全方位的压力测试与验证：</p>\n<ul>\n<li>核心指标：验证生成器在高并发场景下的吞吐量（TPS）与响应延迟。</li>\n<li>稳定性测试：模拟延迟环境中，算法在长时间高并发运行下的稳定性与正确性。</li>\n<li>横向对比：我们将本算法与原生 Redis 生成器进行同场景下的性能对比，直观展示其在资源消耗与生成效率上的优势。</li>\n</ul>\n<blockquote>\n<p>通过这些实验，你将看到这套算法在实际应用中表现出的卓越性能。</p>\n</blockquote>\n<p>视频特别设置了与原生 Redis 生成器的对比测试，通过量化数据展现自适应算法在可变负载场景下的性能优势。例如，在流量突增时，传统生成器可能因序列号快速耗尽而导致ID生成延迟或阻塞，而自适应算法能动态调整生成策略，保持高性能与稳定性。这些实验为开发者提供了客观的评估依据，帮助他们在技术选型时做出明智决策。</p>\n<h3 id=\"-视频-3自适应可变速率id生成器设计与实践下\">🎥 视频 3：自适应可变速率ID生成器设计与实践(下)</h3>\n<blockquote>\n<p>副标题： 源码深潜：揭秘核心逻辑与环境配置<br /><br />\n视频地址：即将发布，请关注微信公众号(<code>Zongsoft</code>)以获得及时发布通知。</p>\n</blockquote>\n<p>最后一集，我们将带你潜入代码深处，直面该算法的核心实现以及如何快速搭建开发与测试环境。</p>\n<p>逐行剖析 <a href=\"https://github.com/Zongsoft/framework/blob/master/Zongsoft.Core/src/Common/Sequence.cs\" rel=\"noopener nofollow\" target=\"_blank\">Sequence</a> 类的关键逻辑，解读代理模式封装、动态步长调整、本地无锁递增、边界保障机制、时序感知优化等核心代码块。<br />\n详细介绍算法运行所需的环境依赖与配置参数，帮助你快速将这套高性能组件集成到自己的项目中。</p>\n<p>通过本集，你将掌握从源码到部署的全链路能力——不仅 <em>“用得上”</em>，更能 <em>“懂透原理”</em>，在实际项目中快速构建出自适应、高可靠、零运维的ID生成服务，为高并发系统筑牢基石。</p>\n<hr />\n<ul>\n<li>Bilibili\n<blockquote>\n<p><a href=\"https://space.bilibili.com/20995572\" rel=\"noopener nofollow\" target=\"_blank\">https://space.bilibili.com/20995572</a></p>\n</blockquote>\n</li>\n<li>抖音\n<blockquote>\n<p><a href=\"https://www.douyin.com/user/MS4wLjABAAAA9NmpuYVoLopaB6XdHoQ1CcmDF5DIb5YgwKzBLjZZdyU\" rel=\"noopener nofollow\" target=\"_blank\">https://www.douyin.com/user/MS4wLjABAAAA9NmpuYVoLopaB6XdHoQ1CcmDF5DIb5YgwKzBLjZZdyU</a></p>\n</blockquote>\n</li>\n<li>微信公众号\n<blockquote>\n<p><img alt=\"Zongsoft 微信公众号\" class=\"lazyload\" /></p>\n</blockquote>\n</li>\n</ul>\n\n</div>\n<div id=\"MySignature\">\n    <div style=\"text-align: center;\">\n\t<img src=\"https://raw.githubusercontent.com/Zongsoft/Guidelines/master/zongsoft-qrcode%28wechat%29.png\" />\n</div>\n\n<hr style=\"margin-top: 2em; margin-bottom: 2em; margin-left: 0; margin-right: 0; padding: 0; height: 2px; border: 0; background-color: #e8e8e8;\" />\n\n<div id=\"license\">\n\t<img src=\"https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png\" width=\"\" />\n\t<p style=\"margin-top: 4px;\">\n本作品采用 <a class=\"bi-link\" href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" target=\"_blank\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a> 进行许可。欢迎转载、使用、重新发布，但必须保留本文的署名 <a class=\"bi-link\" href=\"https://github.com/zongsoft\" target=\"_blank\">钟峰</a>（包含链接：<a class=\"bi-link\" href=\"http://zongsoft.github.io/\" target=\"_blank\">http://zongsoft.github.io</a>），不得用于商业目的，基于本文修改后的作品务必以相同的许可发布。如有任何疑问或授权方面的协商，请致信给我 (zongsoft@qq.com)。\n\t</p>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n        <div class=\"clear\"></div>\n        \n</div>\n    <ul class=\"postmetadata\">\n        \n    </ul>"
    }
  ]
}