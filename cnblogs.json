{"title":"主页 - 博客园","link":"https://www.cnblogs.com/","description":"主页 - 博客园 RSS","language":"zh-cn","lastBuildDate":"2025-12-23T12:34:14.816Z","items":[{"title":"基于深度学习的安检危险品检测系统演示与介绍(YOLOv12/v11/v8/v5模型+Pyqt5界面+训练代码+数据集)","link":"https://www.cnblogs.com/codingtea/p/19389006","description":"<h1 class=\"postTitle\">\n                <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/codingtea/p/19389006\" title=\"发布于 2025-12-23 20:30\">\n    <span role=\"heading\" aria-level=\"2\">基于深度学习的安检危险品检测系统演示与介绍(YOLOv12/v11/v8/v5模型+Pyqt5界面+训练代码+数据集)</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none\">\n        <img src=\"https://img2024.cnblogs.com/blog/3687401/202512/3687401-20251223203000066-364490210.png\" alt=\"基于深度学习的安检危险品检测系统演示与介绍(YOLOv12/v11/v8/v5模型+Pyqt5界面+训练代码+数据集)\" class=\"desc_img\">\n        摘要：本文介绍了一个基于YOLO算法的智能安检危险品检测系统。该系统采用三栏式界面设计，支持图片、视频及实时摄像头检测，可识别枪支、刀具等危险品，检测结果可标注保存并导出Excel。系统内置YOLOv5/v8/v11/v12多种模型，其中YOLO12n精度最高(mAP40.6%)，YOLO11n速度最快(56.1ms)。通过7000张训练数据，系统在IoU阈值为0.5时达到90.6%的mAP准确率。项目采用Python3.10+PyQt5技术栈，提供完整的训练脚本和用户管理功能，实现安检流程的智能化升级。\n    </div>\n<div id=\"cnblogs_post_body\" class=\"blogpost-body blogpost-body-html\">\n<h2 id=\"%E8%A7%86%E9%A2%91%E6%BC%94%E7%A4%BA\">视频演示</h2>\n<p><a href=\"https://www.bilibili.com/video/BV1x32vBREyx\" target=\"_blank\" rel=\"noopener nofollow\">基于深度学习的安检危险品检测系统</a></p>\n<h2>1. 前言​</h2>\n<p><span style=\"font-size: 16px\">大家好，欢迎来到 Coding 茶水间。</span></p>\n<p><span style=\"font-size: 16px\">在公共交通与公共安全的日常守护中，安检是防止危险品流入人群的关键防线。传统依靠人工判图的安检方式，不仅工作强度大，还容易因疲劳或经验差异漏检风险物品。今天我们要分享的项目，就是基于 <strong>YOLO 算法</strong>​ 的<strong>安检危险品检测系统</strong>——它能自动分析安检通道拍摄的箱包图像，精准识别其中的枪支、刀具等危险品，把“人眼筛查”升级为高效、稳定、可追溯的智能检测流程。</span></p>\n<p><span style=\"font-size: 16px\">这套系统的主界面分为左、中、右三大功能区：左侧是操作入口，支持单图、视频、批量图片、摄像头实时检测，可切换模型与保存带标注的检测结果；中间是检测展示区，可调节置信度与交并比，实时显示检测耗时与目标数量，并用表格列出每个目标的详细信息；右侧负责统计与过滤，可按类别汇总危险品数量，聚焦查看某一类目标的置信度与坐标，还支持将检测结果导出为 Excel，方便后续核查与归档。</span></p>\n<p><span style=\"font-size: 16px\">除了可视化检测，我们加入了登录与个人中心，可对账号信息、密码、头像进行管理；同时提供脚本化检测方式，无需界面即可批量处理图片、视频或摄像头画面；更有训练脚本，可按需配置模型数量、批次大小与训练轮次，用自己的安检图像数据训练出更贴合实际场景的检测模型。训练结果会保存在指定目录，包含最佳权重文件、评估曲线与混淆矩阵，让模型表现透明可查。</span></p>\n<p><span style=\"font-size: 16px\">接下来，我们会从界面布局讲到功能演示，再到脚本检测与模型训练，完整呈现这套“能看、能用、能改”的安检危险品检测系统，希望它能让大家看到 YOLO 在公共安全智能化中的落地力量与应用潜力。</span></p>\n<h2 id=\"2.%20%E9%A1%B9%E7%9B%AE%E6%BC%94%E7%A4%BA\">2. 项目演示</h2>\n<h3 id=\"2.1%20%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2\">2.1&nbsp;<strong>用户登录界面</strong></h3>\n<p><span style=\"font-size: 16px\">登录界面布局简洁清晰，左侧展示系统主题，用户需输入用户名、密码及验证码完成身份验证后登录系统。</span></p>\n<p><img alt=\"ScreenShot_2025-12-02_120251_071\" data-src=\"https://img2024.cnblogs.com/blog/3687401/202512/3687401-20251223201733870-890755599.png\" class=\"lazyload\"></p>\n<h3 id=\"2.2%20%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C\">2.2&nbsp;<strong>新用户注册</strong></h3>\n<p><span style=\"font-size: 16px\">注册时可自定义用户名与密码，支持上传个人头像；如未上传，系统将自动使用默认头像完成账号创建。</span></p>\n<p><img alt=\"ScreenShot_2025-12-02_120312_056\" data-src=\"https://img2024.cnblogs.com/blog/3687401/202512/3687401-20251223201742516-415071628.png\" class=\"lazyload\"></p>\n<h3 id=\"2.3%20%E4%B8%BB%E7%95%8C%E9%9D%A2\">2.3&nbsp;<strong>主界面布局</strong></h3>\n<p><span style=\"font-size: 16px\">主界面采用三栏结构，左侧为功能操作区，中间用于展示检测画面，右侧呈现目标详细信息，布局合理，交互流畅。</span></p>\n<p><img alt=\"ScreenShot_2025-12-02_120345_617\" data-src=\"https://img2024.cnblogs.com/blog/3687401/202512/3687401-20251223201749341-356872392.png\" class=\"lazyload\"></p>\n<h3 id=\"2.4%20%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF\">2.4&nbsp;<strong>个人信息管理</strong></h3>\n<p><span style=\"font-size: 16px\">用户可在此模块中修改密码或更换头像，个人信息支持随时更新与保存。</span></p>\n<p><img alt=\"ScreenShot_2025-12-02_120353_461\" data-src=\"https://img2024.cnblogs.com/blog/3687401/202512/3687401-20251223201756297-1649964158.png\" class=\"lazyload\"></p>\n<h3 id=\"2.5%20%E6%A3%80%E6%B5%8B%E5%8A%9F%E8%83%BD%E5%B1%95%E7%A4%BA\">2.5&nbsp;<strong>多模态检测展示</strong></h3>\n<p><span style=\"font-size: 16px\">系统支持图片、视频及摄像头实时画面的目标检测。识别结果将在画面中标注显示，并在下方列表中逐项列出。点击具体目标可查看其类别、置信度及位置坐标等详细信息。</span></p>\n<p><img alt=\"ScreenShot_2025-12-02_120519_418\" data-src=\"https://img2024.cnblogs.com/blog/3687401/202512/3687401-20251223201803846-7776126.png\" class=\"lazyload\"></p>\n<h3>2.6 检测结果保存</h3>\n<p><span style=\"font-size: 16px\">可以将检测后的图片、视频进行保存，生成新的图片和视频，新生成的图片和视频中会带有检测结果的标注信息，并且还可以将所有检测结果的数据信息保存到excel中进行，方便查看检测结果。</span></p>\n<p>&nbsp;</p>\n<h3 id=\"2.6%20%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9\">2.7&nbsp;<strong>多模型切换</strong></h3>\n<p><span style=\"font-size: 16px\">系统内置多种已训练模型，用户可根据实际需求灵活切换，以适应不同检测场景或对比识别效果。</span></p>\n<p><img alt=\"ScreenShot_2025-12-02_120415_074\" data-src=\"https://img2024.cnblogs.com/blog/3687401/202512/3687401-20251223201814136-889908556.png\" class=\"lazyload\"></p>\n<h2 id=\"3.%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81\">3.模型训练核心代码</h2>\n<p><span style=\"font-size: 16px\">本脚本是YOLO模型批量训练工具，可自动修正数据集路径为绝对路径，从pretrained文件夹加载预训练模型，按设定参数（100轮/640尺寸/批次8）一键批量训练YOLOv5nu/v8n/v11n/v12n模型。</span></p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected\" data-cke-display-name=\"代码段\" data-cke-filter=\"off\" data-cke-widget-id=\"8\" data-cke-widget-wrapper=\"1\">\n<pre class=\"cke_widget_element highlighter-hljs\" data-cke-widget-data=\"%7B%22lang%22%3A%22python%22%2C%22code%22%3A%22%23%20-*-%20coding%3A%20utf-8%20-*-%5Cn%5C%22%5C%22%5C%22%5Cn%E8%AF%A5%E8%84%9A%E6%9C%AC%E7%94%A8%E4%BA%8E%E6%89%A7%E8%A1%8CYOLO%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AE%AD%E7%BB%83%E3%80%82%5Cn%5Cn%E5%AE%83%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%A4%84%E7%90%86%E4%BB%A5%E4%B8%8B%E4%BB%BB%E5%8A%A1%EF%BC%9A%5Cn1.%20%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E9%9B%86%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%20(data.yaml)%EF%BC%8C%E5%B0%86%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E6%9B%B4%E6%96%B0%E4%B8%BA%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%EF%BC%8C%E4%BB%A5%E7%A1%AE%E4%BF%9D%E8%AE%AD%E7%BB%83%E6%97%B6%E8%83%BD%E6%AD%A3%E7%A1%AE%E6%89%BE%E5%88%B0%E6%95%B0%E6%8D%AE%E3%80%82%5Cn2.%20%E4%BB%8E%20'pretrained'%20%E6%96%87%E4%BB%B6%E5%A4%B9%E5%8A%A0%E8%BD%BD%E6%8C%87%E5%AE%9A%E7%9A%84%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E3%80%82%5Cn3.%20%E4%BD%BF%E7%94%A8%E9%A2%84%E8%AE%BE%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%88%E5%A6%82epochs%2C%20imgsz%2C%20batch%EF%BC%89%E5%90%AF%E5%8A%A8%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B%E3%80%82%5Cn%5Cn%E8%A6%81%E5%BC%80%E5%A7%8B%E8%AE%AD%E7%BB%83%EF%BC%8C%E5%8F%AA%E9%9C%80%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8C%E6%AD%A4%E8%84%9A%E6%9C%AC%E3%80%82%5Cn%5C%22%5C%22%5C%22%5Cnimport%20os%5Cnimport%20yaml%5Cnfrom%20pathlib%20import%20Path%5Cnfrom%20ultralytics%20import%20YOLO%5Cn%5Cndef%20main()%3A%5Cn%20%20%20%20%5C%22%5C%22%5C%22%5Cn%20%20%20%20%E4%B8%BB%E8%AE%AD%E7%BB%83%E5%87%BD%E6%95%B0%E3%80%82%5Cn%20%20%20%20%5Cn%20%20%20%20%E8%AF%A5%E5%87%BD%E6%95%B0%E8%B4%9F%E8%B4%A3%E6%89%A7%E8%A1%8CYOLO%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AE%AD%E7%BB%83%E6%B5%81%E7%A8%8B%EF%BC%8C%E5%8C%85%E6%8B%AC%EF%BC%9A%5Cn%20%20%20%201.%20%E9%85%8D%E7%BD%AE%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E3%80%82%5Cn%20%20%20%202.%20%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84YAML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%8C%E7%A1%AE%E4%BF%9D%E8%B7%AF%E5%BE%84%E4%B8%BA%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E3%80%82%5Cn%20%20%20%203.%20%E5%8A%A0%E8%BD%BD%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E3%80%82%5Cn%20%20%20%204.%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%AE%9A%E5%8F%82%E6%95%B0%E5%BC%80%E5%A7%8B%E8%AE%AD%E7%BB%83%E3%80%82%5Cn%20%20%20%20%5C%22%5C%22%5C%22%5Cn%20%20%20%20%23%20---%201.%20%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%9E%8B%E5%92%8C%E8%B7%AF%E5%BE%84%20---%5Cn%20%20%20%20%5Cn%20%20%20%20%23%20%E8%A6%81%E8%AE%AD%E7%BB%83%E7%9A%84%E6%A8%A1%E5%9E%8B%E5%88%97%E8%A1%A8%5Cn%20%20%20%20models_to_train%20%3D%20%5B%5Cn%20%20%20%20%20%20%20%20%7B'name'%3A%20'yolov5nu.pt'%2C%20'train_name'%3A%20'train_yolov5nu'%7D%2C%5Cn%20%20%20%20%20%20%20%20%7B'name'%3A%20'yolov8n.pt'%2C%20'train_name'%3A%20'train_yolov8n'%7D%2C%5Cn%20%20%20%20%20%20%20%20%7B'name'%3A%20'yolo11n.pt'%2C%20'train_name'%3A%20'train_yolo11n'%7D%2C%5Cn%20%20%20%20%20%20%20%20%7B'name'%3A%20'yolo12n.pt'%2C%20'train_name'%3A%20'train_yolo12n'%7D%5Cn%20%20%20%20%5D%5Cn%20%20%20%20%5Cn%20%20%20%20%23%20%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E7%9A%84%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%EF%BC%8C%E4%BB%A5%E9%81%BF%E5%85%8D%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98%5Cn%20%20%20%20current_dir%20%3D%20os.path.abspath(os.getcwd())%5Cn%20%20%20%20%5Cn%20%20%20%20%23%20---%202.%20%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E9%9B%86YAML%E6%96%87%E4%BB%B6%20---%5Cn%20%20%20%20%5Cn%20%20%20%20%23%20%E6%9E%84%E5%BB%BA%E6%95%B0%E6%8D%AE%E9%9B%86yaml%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%5Cn%20%20%20%20data_yaml_path%20%3D%20os.path.join(current_dir%2C%20'train_data'%2C%20'data.yaml')%5Cn%20%20%20%20%5Cn%20%20%20%20%23%20%E8%AF%BB%E5%8F%96%E5%8E%9F%E5%A7%8Byaml%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%5Cn%20%20%20%20with%20open(data_yaml_path%2C%20'r'%2C%20encoding%3D'utf-8')%20as%20f%3A%5Cn%20%20%20%20%20%20%20%20data_config%20%3D%20yaml.safe_load(f)%5Cn%20%20%20%20%5Cn%20%20%20%20%23%20%E5%B0%86yaml%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%20'path'%20%E5%AD%97%E6%AE%B5%E4%BF%AE%E6%94%B9%E4%B8%BA%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9B%AE%E5%BD%95%E7%9A%84%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%5Cn%20%20%20%20%23%20%E8%BF%99%E6%98%AF%E4%B8%BA%E4%BA%86%E7%A1%AE%E4%BF%9Dultralytics%E5%BA%93%E8%83%BD%E6%AD%A3%E7%A1%AE%E5%AE%9A%E4%BD%8D%E5%88%B0%E8%AE%AD%E7%BB%83%E3%80%81%E9%AA%8C%E8%AF%81%E5%92%8C%E6%B5%8B%E8%AF%95%E9%9B%86%5Cn%20%20%20%20data_config%5B'path'%5D%20%3D%20os.path.join(current_dir%2C%20'train_data')%5Cn%20%20%20%20%5Cn%20%20%20%20%23%20%E5%B0%86%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E9%85%8D%E7%BD%AE%E5%86%99%E5%9B%9Eyaml%E6%96%87%E4%BB%B6%5Cn%20%20%20%20with%20open(data_yaml_path%2C%20'w'%2C%20encoding%3D'utf-8')%20as%20f%3A%5Cn%20%20%20%20%20%20%20%20yaml.dump(data_config%2C%20f%2C%20default_flow_style%3DFalse%2C%20allow_unicode%3DTrue)%5Cn%20%20%20%20%5Cn%20%20%20%20%23%20---%203.%20%E5%BE%AA%E7%8E%AF%E8%AE%AD%E7%BB%83%E6%AF%8F%E4%B8%AA%E6%A8%A1%E5%9E%8B%20---%5Cn%20%20%20%20%5Cn%20%20%20%20for%20model_info%20in%20models_to_train%3A%5Cn%20%20%20%20%20%20%20%20model_name%20%3D%20model_info%5B'name'%5D%5Cn%20%20%20%20%20%20%20%20train_name%20%3D%20model_info%5B'train_name'%5D%5Cn%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20print(f%5C%22%5C%5Cn%7B'%3D'*60%7D%5C%22)%5Cn%20%20%20%20%20%20%20%20print(f%5C%22%E5%BC%80%E5%A7%8B%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%3A%20%7Bmodel_name%7D%5C%22)%5Cn%20%20%20%20%20%20%20%20print(f%5C%22%E8%AE%AD%E7%BB%83%E5%90%8D%E7%A7%B0%3A%20%7Btrain_name%7D%5C%22)%5Cn%20%20%20%20%20%20%20%20print(f%5C%22%7B'%3D'*60%7D%5C%22)%5Cn%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%23%20%E6%9E%84%E5%BB%BA%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AE%8C%E6%95%B4%E8%B7%AF%E5%BE%84%5Cn%20%20%20%20%20%20%20%20pretrained_model_path%20%3D%20os.path.join(current_dir%2C%20'pretrained'%2C%20model_name)%5Cn%20%20%20%20%20%20%20%20if%20not%20os.path.exists(pretrained_model_path)%3A%5Cn%20%20%20%20%20%20%20%20%20%20%20%20print(f%5C%22%E8%AD%A6%E5%91%8A%3A%20%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E6%96%87%E4%BB%B6%E4%B8%8D%E5%AD%98%E5%9C%A8%3A%20%7Bpretrained_model_path%7D%5C%22)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20print(f%5C%22%E8%B7%B3%E8%BF%87%E6%A8%A1%E5%9E%8B%20%7Bmodel_name%7D%20%E7%9A%84%E8%AE%AD%E7%BB%83%5C%22)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20continue%5Cn%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20try%3A%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%23%20%E5%8A%A0%E8%BD%BD%E6%8C%87%E5%AE%9A%E7%9A%84%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20model%20%3D%20YOLO(pretrained_model_path)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%23%20---%204.%20%E5%BC%80%E5%A7%8B%E8%AE%AD%E7%BB%83%20---%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%20%20%20%20print(f%5C%22%E5%BC%80%E5%A7%8B%E8%AE%AD%E7%BB%83%20%7Bmodel_name%7D...%5C%22)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%23%20%E8%B0%83%E7%94%A8train%E6%96%B9%E6%B3%95%E5%BC%80%E5%A7%8B%E8%AE%AD%E7%BB%83%5Cn%20%20%20%20%20%20%20%20%20%20%20%20model.train(%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20data%3Ddata_yaml_path%2C%20%20%23%20%E6%95%B0%E6%8D%AE%E9%9B%86%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20epochs%3D100%2C%20%20%20%20%20%20%20%20%20%20%20%23%20%E8%AE%AD%E7%BB%83%E8%BD%AE%E6%AC%A1%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20imgsz%3D640%2C%20%20%20%20%20%20%20%20%20%20%20%20%23%20%E8%BE%93%E5%85%A5%E5%9B%BE%E5%83%8F%E5%B0%BA%E5%AF%B8%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20batch%3D8%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20%E6%AF%8F%E6%89%B9%E6%AC%A1%E7%9A%84%E5%9B%BE%E5%83%8F%E6%95%B0%E9%87%8F%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name%3Dtrain_name%2C%20%20%20%20%20%20%23%20%E6%A8%A1%E5%9E%8B%E5%90%8D%E7%A7%B0%5Cn%20%20%20%20%20%20%20%20%20%20%20%20)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%20%20%20%20print(f%5C%22%7Bmodel_name%7D%20%E8%AE%AD%E7%BB%83%E5%AE%8C%E6%88%90%EF%BC%81%5C%22)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20except%20Exception%20as%20e%3A%5Cn%20%20%20%20%20%20%20%20%20%20%20%20print(f%5C%22%E8%AE%AD%E7%BB%83%20%7Bmodel_name%7D%20%E6%97%B6%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%3A%20%7Bstr(e)%7D%5C%22)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20print(f%5C%22%E8%B7%B3%E8%BF%87%E6%A8%A1%E5%9E%8B%20%7Bmodel_name%7D%EF%BC%8C%E7%BB%A7%E7%BB%AD%E8%AE%AD%E7%BB%83%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9E%8B%5C%22)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20continue%5Cn%20%20%20%20%5Cn%20%20%20%20print(f%5C%22%5C%5Cn%7B'%3D'*60%7D%5C%22)%5Cn%20%20%20%20print(%5C%22%E6%89%80%E6%9C%89%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E5%AE%8C%E6%88%90%EF%BC%81%5C%22)%5Cn%20%20%20%20print(f%5C%22%7B'%3D'*60%7D%5C%22)%5Cn%5Cnif%20__name__%20%3D%3D%20%5C%22__main__%5C%22%3A%5Cn%20%20%20%20%23%20%E5%BD%93%E8%AF%A5%E8%84%9A%E6%9C%AC%E8%A2%AB%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C%E6%97%B6%EF%BC%8C%E8%B0%83%E7%94%A8main%E5%87%BD%E6%95%B0%5Cn%20%20%20%20main()%5Cn%22%2C%22classes%22%3Anull%7D\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-widget=\"codeSnippet\"><code># -*- coding: utf-8 -*-\n\"\"\"\n该脚本用于执行YOLO模型的训练。\n\n它会自动处理以下任务：\n1. 动态修改数据集配置文件 (data.yaml)，将相对路径更新为绝对路径，以确保训练时能正确找到数据。\n2. 从 'pretrained' 文件夹加载指定的预训练模型。\n3. 使用预设的参数（如epochs, imgsz, batch）启动训练过程。\n\n要开始训练，只需直接运行此脚本。\n\"\"\"\nimport os\nimport yaml\nfrom pathlib import Path\nfrom ultralytics import YOLO\n\ndef main():\n    \"\"\"\n    主训练函数。\n    \n    该函数负责执行YOLO模型的训练流程，包括：\n    1. 配置预训练模型。\n    2. 动态修改数据集的YAML配置文件，确保路径为绝对路径。\n    3. 加载预训练模型。\n    4. 使用指定参数开始训练。\n    \"\"\"\n    # --- 1. 配置模型和路径 ---\n    \n    # 要训练的模型列表\n    models_to_train = [\n        {'name': 'yolov5nu.pt', 'train_name': 'train_yolov5nu'},\n        {'name': 'yolov8n.pt', 'train_name': 'train_yolov8n'},\n        {'name': 'yolo11n.pt', 'train_name': 'train_yolo11n'},\n        {'name': 'yolo12n.pt', 'train_name': 'train_yolo12n'}\n    ]\n    \n    # 获取当前工作目录的绝对路径，以避免相对路径带来的问题\n    current_dir = os.path.abspath(os.getcwd())\n    \n    # --- 2. 动态配置数据集YAML文件 ---\n    \n    # 构建数据集yaml文件的绝对路径\n    data_yaml_path = os.path.join(current_dir, 'train_data', 'data.yaml')\n    \n    # 读取原始yaml文件内容\n    with open(data_yaml_path, 'r', encoding='utf-8') as f:\n        data_config = yaml.safe_load(f)\n    \n    # 将yaml文件中的 'path' 字段修改为数据集目录的绝对路径\n    # 这是为了确保ultralytics库能正确定位到训练、验证和测试集\n    data_config['path'] = os.path.join(current_dir, 'train_data')\n    \n    # 将修改后的配置写回yaml文件\n    with open(data_yaml_path, 'w', encoding='utf-8') as f:\n        yaml.dump(data_config, f, default_flow_style=False, allow_unicode=True)\n    \n    # --- 3. 循环训练每个模型 ---\n    \n    for model_info in models_to_train:\n        model_name = model_info['name']\n        train_name = model_info['train_name']\n        \n        print(f\"\\n{'='*60}\")\n        print(f\"开始训练模型: {model_name}\")\n        print(f\"训练名称: {train_name}\")\n        print(f\"{'='*60}\")\n        \n        # 构建预训练模型的完整路径\n        pretrained_model_path = os.path.join(current_dir, 'pretrained', model_name)\n        if not os.path.exists(pretrained_model_path):\n            print(f\"警告: 预训练模型文件不存在: {pretrained_model_path}\")\n            print(f\"跳过模型 {model_name} 的训练\")\n            continue\n        \n        try:\n            # 加载指定的预训练模型\n            model = YOLO(pretrained_model_path)\n            \n            # --- 4. 开始训练 ---\n            \n            print(f\"开始训练 {model_name}...\")\n            # 调用train方法开始训练\n            model.train(\n                data=data_yaml_path,  # 数据集配置文件\n                epochs=100,           # 训练轮次\n                imgsz=640,            # 输入图像尺寸\n                batch=8,             # 每批次的图像数量\n                name=train_name,      # 模型名称\n            )\n            \n            print(f\"{model_name} 训练完成！\")\n            \n        except Exception as e:\n            print(f\"训练 {model_name} 时出现错误: {str(e)}\")\n            print(f\"跳过模型 {model_name}，继续训练下一个模型\")\n            continue\n    \n    print(f\"\\n{'='*60}\")\n    print(\"所有模型训练完成！\")\n    print(f\"{'='*60}\")\n\nif __name__ == \"__main__\":\n    # 当该脚本被直接执行时，调用main函数\n    main()</code></pre>\n<span class=\"cke_reset cke_widget_drag_handler_container\"><img class=\"cke_reset cke_widget_drag_handler lazyload\" height=\"15\" width=\"15\" data-cke-widget-drag-handler=\"1\" data-src=\"https://img2024.cnblogs.com/blog/3687401/202508/3687401-20250822165457676-1808144825.gif\"></span></div>\n<h2 id=\"3.%20%E6%8A%80%E6%9C%AF%E6%A0%88\">4. 技术栈</h2>\n<ul>\n<li>\n<p><span style=\"font-size: 16px\">语言：Python 3.10</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 16px\">前端界面：PyQt5</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 16px\">数据库：SQLite（存储用户信息）</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 16px\">模型：YOLOv5、YOLOv8、YOLOv11、YOLOv12</span></p>\n</li>\n</ul>\n<h2 id=\"4.%20YOLO%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94%E4%B8%8E%E8%AF%86%E5%88%AB%E6%95%88%E6%9E%9C%E8%A7%A3%E6%9E%90\">5. YOLO模型对比与识别效果解析</h2>\n<h3 id=\"4.1%20YOLOv5%2FYOLOv8%2FYOLOv11%2FYOLOv12%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94\">5.1 YOLOv5/YOLOv8/YOLOv11/YOLOv12模型对比</h3>\n<p><span style=\"font-size: 16px\">基于Ultralytics官方COCO数据集训练结果：</span></p>\n<table>\n<thead>\n<tr>\n<th>\n<p><span style=\"font-size: 16px\">模型</span></p>\n</th>\n<th>\n<p><span style=\"font-size: 16px\">尺寸(像素)</span></p>\n</th>\n<th>\n<p><span style=\"font-size: 16px\">mAPval 50-95</span></p>\n</th>\n<th>\n<p><span style=\"font-size: 16px\">速度(CPU ONNX/毫秒)</span></p>\n</th>\n<th>\n<p><span style=\"font-size: 16px\">参数(M)</span></p>\n</th>\n<th>\n<p><span style=\"font-size: 16px\">FLOPs(B)</span></p>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<p><span style=\"font-size: 16px\">YOLO12n</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px\">640</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px\">40.6</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px\">-</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px\">2.6</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px\">6.5</span></p>\n</td>\n</tr>\n<tr>\n<td>\n<p><span style=\"font-size: 16px\">YOLO11n</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px\">640</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px\">39.5</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px\">56.1 ± 0.8</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px\">2.6</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px\">6.5</span></p>\n</td>\n</tr>\n<tr>\n<td>\n<p><span style=\"font-size: 16px\">YOLOv8n</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px\">640</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px\">37.3</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px\">80.4</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px\">3.2</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px\">8.7</span></p>\n</td>\n</tr>\n<tr>\n<td>\n<p><span style=\"font-size: 16px\">YOLOv5nu</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px\">640</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px\">34.3</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px\">73.6</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px\">2.6</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px\">7.7</span></p>\n</td>\n</tr>\n</tbody>\n</table>\n<p><span style=\"font-size: 16px\"><strong>关键结论</strong>：</span></p>\n<ol>\n<li>\n<p><span style=\"font-size: 16px\"><strong>精度最高</strong>：YOLO12n（mAP 40.6%），显著领先其他模型（较YOLOv5nu高约6.3个百分点）；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 16px\"><strong>速度最优</strong>：YOLO11n（CPU推理56.1ms），比YOLOv8n快42%，适合实时轻量部署；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 16px\"><strong>效率均衡</strong>：YOLO12n/YOLO11n/YOLOv8n/YOLOv5nu参数量均为2.6M，FLOPs较低（YOLO12n/11n仅6.5B）；YOLOv8n参数量（3.2M）与计算量（8.7B）最高，但精度优势不明显。</span></p>\n</li>\n</ol>\n<p><span style=\"font-size: 16px\"><strong>综合推荐</strong>：</span></p>\n<ul>\n<li>\n<p><span style=\"font-size: 16px\">追求高精度：优先选YOLO12n（精度与效率兼顾）；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 16px\">需高速低耗：选YOLO11n（速度最快且精度接近YOLO12n）；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 16px\">YOLOv5nu/YOLOv8n因性能劣势，无特殊需求时不建议首选。</span></p>\n</li>\n</ul>\n<h3 id=\"5.2%C2%A0%E6%95%B0%E6%8D%AE%E9%9B%86%E5%88%86%E6%9E%90\">5.2&nbsp;数据集分析</h3>\n<p><img alt=\"labels\" data-src=\"https://img2024.cnblogs.com/blog/3687401/202512/3687401-20251223201829047-1114898500.jpg\" class=\"lazyload\"></p>\n<p><span style=\"font-size: 16px\">数据集中训练集和验证集一共7000张图片，数据集目标类别两种：正常肾脏，肾结石<span style=\"font-family: &quot;PingFang SC&quot;, &quot;Smart Quotes&quot;, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif\">，</span>数据集配置代码如下：</span></p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected\" data-cke-display-name=\"代码段\" data-cke-filter=\"off\" data-cke-widget-id=\"6\" data-cke-widget-wrapper=\"1\">\n<pre class=\"language-xml highlighter-hljs\"><code>names:\n- Gun\n- Knife\n- Pliers\n- Scissors\n- Wrench\nnc: 5\npath: D:\\project\\python\\yolo_Security_Check_Hazardous_Materials_Detection\\train_data\ntest: ../test/images\ntrain: ../train/images\nval: ../valid/images</code></pre>\n</div>\n<p id=\"5.%20%E7%BB%93%E6%9D%9F%E8%AF%AD\">&nbsp;<img alt=\"train_batch0\" data-src=\"https://img2024.cnblogs.com/blog/3687401/202512/3687401-20251223201957233-1873529705.jpg\" class=\"lazyload\"></p>\n<p><img alt=\"train_batch1\" data-src=\"https://img2024.cnblogs.com/blog/3687401/202512/3687401-20251223202006414-79421839.jpg\" class=\"lazyload\"></p>\n<p><span style=\"font-size: 16px\">上面的图片就是部分样本集训练中经过数据增强后的效果标注。</span></p>\n<h3 id=\"5.3%20%E8%AE%AD%E7%BB%83%E7%BB%93%E6%9E%9C\">5.3 训练结果</h3>\n<p><img alt=\"confusion_matrix_normalized\" data-src=\"https://img2024.cnblogs.com/blog/3687401/202512/3687401-20251223202014608-191428620.png\" class=\"lazyload\"></p>\n<p><span style=\"font-size: 16px\">混淆矩阵显示中识别精准度显示是一条对角线，方块颜色越深代表对应的类别识别的精准度越高<span style=\"font-family: &quot;PingFang SC&quot;, &quot;Smart Quotes&quot;, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif\">。</span></span></p>\n<p><img alt=\"BoxF1_curve\" data-src=\"https://img2024.cnblogs.com/blog/3687401/202512/3687401-20251223202022480-1628698164.png\" class=\"lazyload\"></p>\n<p><span style=\"font-size: 16px\">F1指数（F1 Score）是统计学和机器学习中用于评估分类模型性能的核心指标，综合了模型的精确率（Precision）和召回率（Recall），通过调和平均数平衡两者的表现。&nbsp;</span></p>\n<p><span style=\"font-size: 16px\">当置信度为0.433时，所有类别的综合F1值达到了0.87（蓝色曲线）。</span></p>\n<p><img alt=\"BoxPR_curve\" data-src=\"https://img2024.cnblogs.com/blog/3687401/202512/3687401-20251223202037988-112684370.png\" class=\"lazyload\"></p>\n<p><span style=\"font-size: 16px\">mAP@0.5：是目标检测任务中常用的评估指标，表示在交并比（IoU）阈值为0.5时计算的平均精度均值（mAP）。其核心含义是：只有当预测框与真实框的重叠面积（IoU）≥50%时，才认为检测结果正确。</span></p>\n<p><span style=\"font-size: 16px\">图中可以看到综合mAP@0.5达到了0.906（90.6%），准确率非常高。</span></p>\n<h2 id=\"4.%20YOLO%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94%E4%B8%8E%E8%AF%86%E5%88%AB%E6%95%88%E6%9E%9C%E8%A7%A3%E6%9E%90\">6. 源码获取方式</h2>\n<p><span data-cke-copybin-end=\"1\"><a href=\"https://www.bilibili.com/video/BV1x32vBREyx\" target=\"_blank\" rel=\"noopener nofollow\">源码获取方式：https://www.bilibili.com/video/BV1x32vBREyx</a>​</span></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\" data-last-update-days=\"0\" data-date-updated=\"2025-12-23 20:30\">2025-12-23 20:30</span>&nbsp;\n<a href=\"https://www.cnblogs.com/codingtea\">Coding茶水间</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19389006);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19389006', targetLink: 'https://www.cnblogs.com/codingtea/p/19389006', title: '基于深度学习的安检危险品检测系统演示与介绍(YOLOv12/v11/v8/v5模型+Pyqt5界面+训练代码+数据集)' })\">举报</a>\n</div>","guid":{"value":"15f168c73d2fb6177458cf493c891d2f"}},{"title":"前端 TypeScript 入门2","link":"https://www.cnblogs.com/pengjiali/p/19387524","description":"<h1 class=\"postTitle\">\n                <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/pengjiali/p/19387524\" title=\"发布于 2025-12-23 18:31\">\n    <span role=\"heading\" aria-level=\"2\">前端 TypeScript 入门2</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\n<h1 id=\"前端-typescript-入门2\">前端 TypeScript 入门2</h1>\n<p>在<a href=\"https://www.cnblogs.com/pengjiali/p/18104072\" target=\"_blank\">上一篇</a>中，我们了解了 TS 常用语法，但是在Vue3项目实际开发中，会发现很多 TS 代码看不懂。本篇以实际 Vue3 项目为例，抽取出其中绝大多数 TS 常见写法，快速进入实战。</p>\n<h2 id=\"一api-层的-typescript-用法\">一、API 层的 TypeScript 用法</h2>\n<h3 id=\"11-定义接口数据结构interface\">1.1 定义接口数据结构（interface）</h3>\n<p>在项目中，我们使用 <code>interface</code> 定义后端返回的数据结构。</p>\n<pre><code class=\"language-typescript\">// src/api/system/user/profile.ts\nexport interface ProfileVO {\n  id: number\n  username: string\n  nickname: string\n  dept: {\n    id: number\n    name: string\n  }\n  // roles 是一个数组，数组里的每一项都是包含 id 和 name 两个字段的对象\n  roles: {\n    id: number\n    name: string\n  }[]\n  posts: {\n    id: number\n    name: string\n  }[]\n  email: string\n  sex: number\n  status: number\n  remark: string\n  createTime: Date\n}\n</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li><code>[]</code> 表示数组类型，如 <code>roles: {...}[]</code> 表示角色数组</li>\n<li>嵌套对象直接在 interface 中定义，如 <code>dept: { id: number; name: string }</code></li>\n<li><code>Date</code> 类型表示日期时间</li>\n</ul>\n<h3 id=\"12-可选属性与联合类型\">1.2 可选属性与联合类型</h3>\n<pre><code class=\"language-typescript\">// src/api/system/user/profile.ts\nexport interface UserProfileUpdateReqVO {\n  nickname?: string // ? 表示可选属性\n  email?: string\n  mobile?: string\n  sex?: number\n  avatar?: string\n}\n\n// src/api/system/sms/smsLog/index.ts\nexport interface SmsLogVO {\n  id: number | null // 联合类型：可以是 number 或 null\n  channelId: number | null\n  templateParams: Map&lt;string, object&gt; | null \n  sendStatus: number | null\n  sendTime: Date | null\n}\n</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li><code>?</code> 表示该属性可选，可以不传</li>\n<li><code>|</code> 表示联合类型，值可以是多种类型之一</li>\n<li><code>null</code> 和 <code>undefined</code> 常用于表示空值</li>\n<li><code> Map&lt;string, object&gt;</code>: 键是 string、值是 object 的 Map</li>\n</ul>\n<h3 id=\"13-接口继承extends\">1.3 接口继承（extends）</h3>\n<pre><code class=\"language-typescript\">// src/api/system/tenant/index.ts\nexport interface TenantPageReqVO extends PageParam {\n  name?: string\n  contactName?: string\n  contactMobile?: string\n  status?: number\n  createTime?: Date[]\n}\n</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li><code>extends PageParam</code> 继承了分页参数（pageNo, pageSize）</li>\n<li>继承后可以添加自己的属性</li>\n<li><code>PageParam</code> 是全局类型，定义在 <code>types/global.d.ts</code></li>\n</ul>\n<pre><code class=\"language-typescript\">// global.d.ts\nexport {}\ndeclare global {\n  interface PageParam {\n    pageSize?: number\n    pageNo?: number\n  }\n}\n</code></pre>\n<p>TypeScript 是如何找到这个 global.d.ts 的：</p>\n<pre><code class=\"language-json\">{\n  \"compilerOptions\": {\n    // 告诉 TS：类型声明文件的根目录在这两个地方：\n    \"typeRoots\": [\"./node_modules/@types/\", \"./types\"]\n  },\n  // 参与编译/类型检查的文件包括 types 目录下所有 .d.ts\n  \"include\": [\n    \"src\",\n    \"types/**/*.d.ts\",\n    \"src/types/auto-imports.d.ts\",\n    \"src/types/auto-components.d.ts\"\n  ]\n}\n</code></pre>\n<h3 id=\"14-api-函数的类型标注\">1.4 API 函数的类型标注</h3>\n<pre><code class=\"language-typescript\">// src/api/system/user/index.ts\n// 查询用户详情 - 参数和返回值都有类型\nexport const getUser = (id: number) =&gt; {\n  return request.get({ url: '/system/user/get?id=' + id })\n}\n\n// 新增用户 - data 参数类型为 UserVO\nexport const createUser = (data: UserVO) =&gt; {\n  return request.post({ url: '/system/user/create', data })\n}\n\n// 修改用户\nexport const updateUser = (data: UserVO) =&gt; {\n  return request.put({ url: '/system/user/update', data })\n}\n\n// 批量删除 - 参数是数字数组\nexport const deleteUserList = (ids: number[]) =&gt; {\n  return request.delete({ url: '/system/user/delete-list', params: { ids: ids.join(',') } })\n}\n</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li>参数类型写在参数名后面：<code>(id: number)</code></li>\n<li>对象类型参数用 interface：<code>(data: UserVO)</code></li>\n<li>数组类型：<code>ids: number[]</code></li>\n</ul>\n<h3 id=\"15-asyncawait-与-promise-类型\">1.5 async/await 与 Promise 类型</h3>\n<pre><code class=\"language-typescript\">// src/api/system/post/index.ts\n// 异步返回一个 Promise，这个 Promise 最终会 resolve 成 PostVO 对象组成的数组。\n// 返回 Promise&lt;PostVO[]&gt;。\nexport const getSimplePostList = async (): Promise&lt;PostVO[]&gt; =&gt; {\n  return await request.get({ url: '/system/post/simple-list' })\n}\n\n// 查询详情\nexport const getPost = async (id: number) =&gt; {\n  return await request.get({ url: '/system/post/get?id=' + id })\n}\n\n// 删除\nexport const deletePost = async (id: number) =&gt; {\n  return await request.delete({ url: '/system/post/delete?id=' + id })\n}\n</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li><code>async</code> 函数自动返回 Promise</li>\n<li><code>Promise&lt;PostVO[]&gt;</code> 明确返回的数据类型</li>\n<li><code>await</code> 等待异步操作完成</li>\n</ul>\n<h2 id=\"二storepinia层的-typescript-用法\">二、Store（Pinia）层的 TypeScript 用法</h2>\n<h3 id=\"21-定义-store-的-state-类型\">2.1 定义 Store 的 State 类型</h3>\n<pre><code class=\"language-typescript\">// src/store/modules/user.ts\nexport interface CompanyVO {\n  pid: string\n  companyName: string\n  isDefault: number\n}\n\ninterface UserVO {\n  id: number\n  avatar: string\n  nickname: string\n  deptId: number\n  companyList: CompanyVO[]\n  sex?: number\n  position?: string\n}\n\ninterface UserInfoVO {\n  permissions: Set&lt;string&gt; // Set 类型\n  roles: string[]\n  isSetUser: boolean\n  user: UserVO\n}\n\nexport const useUserStore = defineStore('admin-user', {\n  state: (): UserInfoVO =&gt; ({\n    permissions: new Set&lt;string&gt;(),\n    roles: [],\n    isSetUser: false,\n    user: {\n      id: 0,\n      avatar: '',\n      nickname: '',\n      deptId: 0,\n      companyList: []\n    }\n  })\n  // ... getters 和 actions\n})\n</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li><code>state: (): UserInfoVO =&gt; (...)</code> 定义 state 返回类型是 UserInfoVO。主要是为了类型检查和提示，不一定会被你显式“拿出来用”。</li>\n<li><code>Set&lt;string&gt;</code> 表示字符串集合。Set 中的值必须是 string 类型。</li>\n</ul>\n<h3 id=\"22-getters-的类型\">2.2 Getters 的类型</h3>\n<pre><code class=\"language-typescript\">// src/store/modules/user.ts\nexport const useUserStore = defineStore('admin-user', {\n  // ... state\n  getters: {\n    getPermissions(): Set&lt;string&gt; {\n      return this.permissions\n    },\n    getRoles(): string[] {\n      return this.roles\n    },\n    getIsSetUser(): boolean {\n      return this.isSetUser\n    },\n    getUser(): UserVO {\n      return this.user\n    }\n  }\n})\n</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li>getter 函数后面标注返回类型</li>\n<li>使用 <code>this</code> 访问 state</li>\n</ul>\n<h3 id=\"23-actions-的类型标注\">2.3 Actions 的类型标注</h3>\n<pre><code class=\"language-typescript\">// src/store/modules/user.ts\nexport const useUserStore = defineStore('admin-user', {\n  // ... state, getters\n  actions: {\n    async setUserInfoAction() {\n      if (!getAccessToken()) {\n        this.resetState()\n        return null\n      }\n      let userInfo = wsCache.get(CACHE_KEY.USER)\n      if (!userInfo) {\n        userInfo = await getInfo()\n      }\n      this.permissions = new Set(userInfo.permissions || [])\n      this.roles = userInfo.roles\n      this.user = userInfo.user\n    },\n\n    async setUserAvatarAction(avatar: string) {\n      const userInfo = wsCache.get(CACHE_KEY.USER)\n      this.user.avatar = avatar\n      userInfo.user.avatar = avatar\n      wsCache.set(CACHE_KEY.USER, userInfo)\n    },\n\n    async loginOut() {\n      try {\n        await loginOut()\n      } catch (error) {\n        console.error('登出接口调用失败:', error)\n      } finally {\n        removeToken()\n        deleteUserCache()\n        this.resetState()\n      }\n    }\n  }\n})\n</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li>action 函数参数需要类型：<code>(avatar: string)</code></li>\n<li>async action 返回 Promise</li>\n<li>通过 <code>this</code> 修改 state</li>\n</ul>\n<h3 id=\"24-map-类型的使用\">2.4 Map 类型的使用</h3>\n<pre><code class=\"language-typescript\">// src/store/modules/mall/kefu.ts\ninterface MallKefuInfoVO {\n  conversationList: KeFuConversationRespVO[]\n  conversationMessageList: Map&lt;number, KeFuMessageRespVO[]&gt; // Map 类型\n}\n\nexport const useMallKefuStore = defineStore('mall-kefu', {\n  state: (): MallKefuInfoVO =&gt; ({\n    conversationList: [],\n    conversationMessageList: new Map&lt;number, KeFuMessageRespVO[]&gt;()\n  }),\n  getters: {\n    // 返回函数的 getter\n    getConversationMessageList(): (conversationId: number) =&gt; KeFuMessageRespVO[] | undefined {\n      return (conversationId: number) =&gt; this.conversationMessageList.get(conversationId)\n    }\n    /*\n    等价：\n    type GetMsgFn = (conversationId: number) =&gt; KeFuMessageRespVO[] | undefined\n\n    getConversationMessageList(): GetMsgFn {\n      return (conversationId: number) =&gt; this.conversationMessageList.get(conversationId)\n    }\n    */\n  },\n  actions: {\n    saveMessageList(conversationId: number, messageList: KeFuMessageRespVO[]) {\n      this.conversationMessageList.set(conversationId, messageList)\n    }\n  }\n})\n</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li><code>Map&lt;number, KeFuMessageRespVO[]&gt;</code> 键是 number，值是数组</li>\n<li>getter 可以返回函数</li>\n<li>使用 <code>.get()</code> 和 <code>.set()</code> 操作 Map</li>\n<li><code>(conversationId: number) =&gt; KeFuMessageRespVO[] | undefined</code>: 类型是函数，返回值是KeFuMessageRespVO[]或undefined</li>\n</ul>\n<h3 id=\"25-复杂-state-定义\">2.5 复杂 State 定义</h3>\n<pre><code class=\"language-typescript\">// src/store/modules/app.ts\ninterface AppState {\n  breadcrumb: boolean\n  breadcrumbIcon: boolean\n  collapse: boolean\n  uniqueOpened: boolean\n  hamburger: boolean\n  screenfull: boolean\n  size: boolean\n  locale: boolean\n  message: boolean\n  tagsView: boolean\n  tagsViewImmerse: boolean\n  tagsViewIcon: boolean\n  logo: boolean\n  fixedHeader: boolean\n  greyMode: boolean\n  pageLoading: boolean\n  layout: LayoutType\n  title: string\n  userInfo: string\n  isDark: boolean\n  currentSize: ElementPlusSize\n  sizeMap: ElementPlusSize[]\n  mobile: boolean\n  footer: boolean\n  theme: ThemeTypes\n  fixedMenu: boolean\n}\n\nexport const useAppStore = defineStore('app', {\n  state: (): AppState =&gt; {\n    return {\n      userInfo: 'userInfo',\n      sizeMap: ['default', 'large', 'small'],\n      mobile: false,\n      title: import.meta.env.VITE_APP_TITLE,\n      pageLoading: false\n      // ... 其他属性\n    }\n  }\n})\n</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li>布尔类型属性集中定义</li>\n<li>自定义类型：<code>LayoutType</code>, <code>ElementPlusSize</code>, <code>ThemeTypes</code></li>\n<li>使用 <code>import.meta.env</code> 获取环境变量</li>\n</ul>\n<h2 id=\"三viewsvue-组件层的-typescript-用法\">三、Views（Vue 组件）层的 TypeScript 用法</h2>\n<h3 id=\"31-defineoptions-和-ref\">3.1 defineOptions 和 ref</h3>\n<pre><code class=\"language-typescript\">// src/views/system/role/index.vue\n&lt;script lang=\"ts\" setup&gt;\nimport * as RoleApi from '@/api/system/role'\n\ndefineOptions({ name: 'SystemRole' })\n\nconst message = useMessage() // 消息弹窗\nconst { t } = useI18n() // 国际化\n\nconst loading = ref(true)  // 布尔值\nconst total = ref(0)       // 数字\nconst list = ref([])       // 数组\n&lt;/script&gt;\n</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li><code>defineOptions</code> 定义组件选项</li>\n<li><code>ref</code> 自动推断类型</li>\n<li>不需要显式标注简单类型</li>\n</ul>\n<h3 id=\"32-明确-ref-类型\">3.2 明确 ref 类型</h3>\n<pre><code class=\"language-typescript\">// src/views/system/user/index.vue\n&lt;script lang=\"ts\" setup&gt;\nimport * as UserApi from '@/api/system/user'\n\nconst loading = ref(true)\nconst total = ref(0)\nconst list = ref([])  // 可以推断，但不明确\n\n// 更好的写法：明确类型\nconst loading = ref&lt;boolean&gt;(true)\nconst total = ref&lt;number&gt;(0)\nconst list = ref&lt;UserApi.UserVO[]&gt;([])  // 明确是 UserVO 数组\nconst companyTreeData = ref&lt;Tree[]&gt;([])  // Tree 是全局类型\n&lt;/script&gt;\n</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li><code>ref&lt;类型&gt;(初始值)</code> 明确类型</li>\n<li>数组类型：<code>ref&lt;UserVO[]&gt;([])</code></li>\n<li>使用导入的 API 类型</li>\n</ul>\n<h3 id=\"33-reactive-定义复杂对象\">3.3 reactive 定义复杂对象</h3>\n<pre><code class=\"language-typescript\">// src/views/system/user/index.vue\n&lt;script lang=\"ts\" setup&gt;\nconst queryParams = reactive({\n  pageNo: 1,\n  pageSize: 10,\n  username: undefined,\n  mobile: undefined,\n  status: undefined,\n  deptId: undefined,\n  createTime: []\n})\n&lt;/script&gt;\n</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li><code>reactive</code> 用于复杂对象</li>\n<li>自动推断类型</li>\n<li>适合查询参数对象</li>\n</ul>\n<h3 id=\"34-defineprops-类型定义\">3.4 defineProps 类型定义</h3>\n<pre><code class=\"language-typescript\">// src/views/system/user/UserForm.vue\n&lt;script lang=\"ts\" setup&gt;\n// 方式 1：使用 defineProps&lt;&gt;()\nconst props = defineProps&lt;{\n  companyTreeData?: any[]\n  fixedCompany?: { name: string; pid: number } | null\n}&gt;()\n\n// 访问 props\nconst companyTreeData = computed(() =&gt; props.companyTreeData || [])\nconst fixedCompany = computed(() =&gt; props.fixedCompany || null)\n&lt;/script&gt;\n</code></pre>\n<pre><code class=\"language-typescript\">// src/views/system/companyTree/detail.vue\n&lt;script setup lang=\"ts\"&gt;\nimport { ref, defineProps } from 'vue'\n\n// 方式 2：定义带默认值的 props\nconst props = defineProps({\n  title: {\n    type: String,\n    default: ''\n  }\n})\n&lt;/script&gt;\n</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li><code>defineProps&lt;{}&gt;()</code> 泛型方式定义 props</li>\n<li>可选属性用 <code>?</code></li>\n<li>联合类型：<code>{ name: string; pid: number } | null</code></li>\n<li><code>computed</code> 包装 props 进行计算</li>\n</ul>\n<p>defineProps语法：</p>\n<pre><code class=\"language-typescript\">// 孩子没脾气\ndefineProps(['persons'])\n\n// 接收+限制类型\ndefineProps&lt;{persons:Persons}&gt;()\n\n// 接收+限制类型+限制必要性 —— 可以不传\ndefineProps&lt;{persons?:Persons}&gt;()\n\n// 接收+限制类型+限制必要性+默认值\nimport {withDefaults} from 'vue'\nwithDefaults(defineProps&lt;{persons?:Persons}&gt;(), {\n  persons: () =&gt; []\n})\n</code></pre>\n<h3 id=\"35-defineemits-类型定义\">3.5 defineEmits 类型定义</h3>\n<pre><code class=\"language-typescript\">// src/views/system/user/CompanyTree.vue\n&lt;script lang=\"ts\" setup&gt;\n// 定义 emit 类型\nconst emits = defineEmits&lt;{\n  (e: 'node-click', row: any): void\n}&gt;()\n\n// 触发事件\nconst handleNodeClick = (row: any) =&gt; {\n  emits('node-click', row)\n}\n&lt;/script&gt;\n</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li><code>(e: '事件名', 参数: 类型): void</code></li>\n<li>可以定义多个事件</li>\n<li>使用 <code>emits('事件名', 参数)</code> 触发</li>\n</ul>\n<p>声明一个名为 'node-click'的事件的三种写法（区别是类型检查严格程度）：</p>\n<pre><code class=\"language-typescript\">defineEmits(['node-click'])\n\n// 定义一个名为 'node-click'​ 的事件。这是一个函数签名形式的定义\n(e: 'node-click', row: any): void\n\nconst emit = defineEmits&lt;{\n  // 新语法：'事件名': [参数1类型, 参数2类型?]\n  'node-click': [row: any]  \n}&gt;();\n</code></pre>\n<h3 id=\"36-formrules-表单验证类型\">3.6 FormRules 表单验证类型</h3>\n<pre><code class=\"language-typescript\">// src/views/system/user/ResetPasswordForm.vue\n&lt;script lang=\"ts\" setup&gt;\nimport { FormRules } from 'element-plus'\n\nconst formData = ref({\n  id: undefined as number | undefined,\n  username: '',\n  password: ''\n})\n\nconst formRules = reactive&lt;FormRules&gt;({\n  password: [\n    { required: true, message: '新密码不能为空', trigger: 'blur' },\n    { min: 6, max: 16, message: '密码长度为 6-16 位', trigger: 'blur' },\n    {\n      pattern: /^(...$/,\n      message: '密码需包含...',\n      trigger: 'blur'\n    }\n  ]\n})\n&lt;/script&gt;\n</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li><code>FormRules</code> 来自 element-plus</li>\n<li><code>reactive&lt;FormRules&gt;</code> 定义验证规则</li>\n<li><code>as number | undefined</code> 类型断言。手动告诉 TS 这个值的类型是 number | undefined（联合类型）。</li>\n<li><code>id: undefined as number | undefined</code> 初始值是 undefined，但后面可能会被赋值成 number，所以类型标注为 number | undefined</li>\n</ul>\n<h3 id=\"37-组件-ref-类型\">3.7 组件 ref 类型</h3>\n<pre><code class=\"language-typescript\">// src/views/system/user/index.vue\n&lt;script lang=\"ts\" setup&gt;\nimport { ElTree } from 'element-plus'\n\nconst treeRef = ref&lt;InstanceType&lt;typeof ElTree&gt;&gt;()\n\n// 调用组件方法\ntreeRef.value?.filter(val)\n&lt;/script&gt;\n</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li><code>InstanceType&lt;typeof ElTree&gt;</code> 获取组件实例类型\n<ul>\n<li>ref<t>()：创建一个响应式引用，类型是 T</t></li>\n<li>T 就是 InstanceType<typeof eltree=\"\"></typeof></li>\n<li>typeof ElTree：获取 ElTree 组件的构造函数类型</li>\n<li>InstanceType<typeof eltree=\"\">：从构造函数类型中提取实例类型</typeof></li>\n</ul>\n</li>\n<li><code>?.</code> 可选链操作符，避免 undefined 报错</li>\n</ul>\n<h3 id=\"38-computed-计算属性类型\">3.8 computed 计算属性类型</h3>\n<pre><code class=\"language-typescript\">// src/views/system/user/UserForm.vue\n&lt;script lang=\"ts\" setup&gt;\nconst props = defineProps&lt;{\n  companyTreeData?: any[]\n}&gt;()\n\n// 自动推断返回类型\nconst companyTreeData = computed(() =&gt; props.companyTreeData || [])\n\n// 明确返回类型\nconst isValid = computed&lt;boolean&gt;(() =&gt; {\n  return formData.value.password.length &gt;= 8\n})\n&lt;/script&gt;\n</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li><code>computed(() =&gt; {})</code> 自动推断</li>\n<li><code>computed&lt;类型&gt;(() =&gt; {})</code> 明确类型</li>\n</ul>\n<h2 id=\"四全局类型定义types\">四、全局类型定义（types）</h2>\n<h3 id=\"41-全局工具类型\">4.1 全局工具类型</h3>\n<pre><code class=\"language-typescript\">// types/global.d.ts\ndeclare global {\n  // 函数类型\n  interface Fn&lt;T = any&gt; {\n    (...arg: T[]): T\n  }\n\n  // 可空类型\n  /*\n  - type Xxx = ...：和 ype Message = number | string 一样，都是起一个类型别名\n  - T：是一个类型参数，占位的，不是具体类型\n  - 示例：\n    - type Nullable&lt;T&gt; = T | null\n    - type A = Nullable&lt;string&gt;   // string | null\n    - type B = Nullable&lt;number&gt;   // number | null\n  */\n  type Nullable&lt;T&gt; = T | null\n\n  // 元素引用类型。声明一个“可以为 null 的 DOM 引用类型”，T 必须是 HTMLElement 的子类型，默认用 HTMLDivElement。\n  type ElRef&lt;T extends HTMLElement = HTMLDivElement&gt; = Nullable&lt;T&gt;\n\n  // 记录类型（对象）\n  /*\n    如果不考虑 null/undefined 的边界情况，可以简化成：\n    type Recordable&lt;T = any, K = string&gt; = Record&lt;K, T&gt;\n\n    - Record&lt;K, V&gt; 是 TypeScript 内置的工具类型\n      - 一个对象，键的类型是 K，值的类型是 V\n      - 示例：\n        type User = Record&lt;string, any&gt;\n        // 等价于：{ [key: string]: any }\n\n        const user: User = {\n          name: '张三',\n          age: 18,\n          job: '工程师'\n        }\n    - 条件类型：K extends null | undefined ? string : K\n      - 如果 K 是 null 或 undefined → 键类型用 string\n      - 否则 → 键类型就用 K 本身\n    - 最终结果：Record&lt;键类型, T&gt;\n  */\n  type Recordable&lt;T = any, K = string&gt; = Record&lt;K extends null | undefined ? string : K, T&gt;\n\n  // 组件引用类型\n  /*\n    做一层语义封装，让代码更清晰。\n\n    不用别名：\n      const dialogRef = ref&lt;InstanceType&lt;typeof ElDialog&gt;&gt;()\n      const tableRef = ref&lt;InstanceType&lt;typeof ElTable&gt;&gt;()\n    用别名（用 ComponentRef）：\n      const dialogRef = ref&lt;ComponentRef&lt;typeof ElDialog&gt;&gt;()\n      const tableRef = ref&lt;ComponentRef&lt;typeof ElTable&gt;&gt;()\n  */\n  type ComponentRef&lt;T&gt; = InstanceType&lt;T&gt;\n\n  // 分页参数\n  interface PageParam {\n    pageSize?: number\n    pageNo?: number\n  }\n\n  // 分页结果\n  interface PageResult&lt;T&gt; {\n    list: T\n    total: number\n  }\n\n  // 树结构\n  interface Tree {\n    id: number\n    name: string\n    children?: Tree[] | any[]\n  }\n}\n</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li><code>declare global</code> 声明全局类型</li>\n<li>泛型类型：<code>Nullable&lt;T&gt;</code>, <code>PageResult&lt;T&gt;</code></li>\n<li>在任何文件中都可以直接使用</li>\n</ul>\n<h3 id=\"42-表单-schema-类型\">4.2 表单 Schema 类型</h3>\n<pre><code class=\"language-typescript\">// src/types/form.d.ts\nexport type FormValueType = string | number | string[] | number[] | boolean | undefined | null\n\nexport type FormItemProps = {\n  labelWidth?: string | number\n  required?: boolean\n  rules?: Recordable\n  error?: string\n  showMessage?: boolean\n  inlineMessage?: boolean\n  style?: CSSProperties\n}\n\nexport type FormSchema = {\n  field: string\n  label?: string\n  labelMessage?: string\n  colProps?: ColProps\n  /*\n    定义一个可选属性 componentProps，它的类型是两个类型的交叉\n      - componentProps?：可选属性\n      - { slots?: Recordable } &amp; ComponentProps：交叉类型（&amp;）\n      - 交叉示例：\n        type A = { name: string }\n        type B = { age: number }\n        type C = A &amp; B  // { name: string; age: number }\n\n        const obj: C = {\n          name: '张三',\n          age: 18\n        }\n      - { slots?: Recordable } &amp; ComponentProps\n        - 必须包含 ComponentProps 里的所有属性\n        - 同时可以有一个可选的 slots 属性，类型是 Recordable（也就是 Record&lt;string, any&gt;）\n  */\n  componentProps?: { slots?: Recordable } &amp; ComponentProps\n  formItemProps?: FormItemProps\n  component?: ComponentName\n  value?: FormValueType\n  hidden?: boolean\n  // 返回值是 AxiosPromise&lt;T&gt;（也就是 Promise&lt;AxiosResponse&lt;T&gt;&gt;），resolve 的值是 AxiosResponse&lt;T&gt;，而 response.data 的类型是 T。\n  api?: &lt;T = any&gt;() =&gt; AxiosPromise&lt;T&gt;\n}\n</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li><code>type</code> 定义类型别名</li>\n<li>联合类型：<code>string | number | boolean</code></li>\n<li>泛型函数：<code>&lt;T = any&gt;() =&gt; AxiosPromise&lt;T&gt;</code></li>\n</ul>\n<h2 id=\"五实用工具函数的-typescript\">五、实用工具函数的 TypeScript</h2>\n<h3 id=\"51-函数参数和返回值类型\">5.1 函数参数和返回值类型</h3>\n<pre><code class=\"language-typescript\">// src/utils/index.ts\n\n// 字符串转换\nexport const humpToUnderline = (str: string): string =&gt; {\n  return str.replace(/([A-Z])/g, '-$1').toLowerCase()\n}\n\n// 设置 CSS 变量\nexport const setCssVar = (prop: string, val: any, dom = document.documentElement) =&gt; {\n  dom.style.setProperty(prop, val)\n}\n\n// 数组查找（泛型函数）\nexport const findIndex = &lt;T = Recordable&gt;(ary: Array&lt;T&gt;, fn: Fn): number =&gt; {\n  if (ary.findIndex) {\n    return ary.findIndex(fn)\n  }\n  let index = -1\n  ary.some((item: T, i: number, ary: Array&lt;T&gt;) =&gt; {\n    const ret: T = fn(item, i, ary)\n    if (ret) {\n      index = i\n      return ret\n    }\n  })\n  return index\n}\n</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li><code>(参数: 类型): 返回类型 =&gt; {}</code></li>\n<li>泛型函数：<code>&lt;T = Recordable&gt;</code></li>\n<li>默认参数：<code>dom = document.documentElement</code></li>\n</ul>\n<h3 id=\"52-时间格式化函数\">5.2 时间格式化函数</h3>\n<pre><code class=\"language-typescript\">// src/utils/index.ts\nexport function formatTime(time: Date | number | string, fmt: string) {\n  if (!time) return ''\n  else {\n    const date = new Date(time)\n    const o = {\n      'M+': date.getMonth() + 1,\n      'd+': date.getDate(),\n      'H+': date.getHours(),\n      'm+': date.getMinutes(),\n      's+': date.getSeconds(),\n      'q+': Math.floor((date.getMonth() + 3) / 3),\n      S: date.getMilliseconds()\n    }\n    // ... 格式化逻辑\n    return fmt\n  }\n}\n</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li>联合类型参数：<code>Date | number | string</code></li>\n<li>对象字面量类型自动推断</li>\n</ul>\n<h3 id=\"53-数字和金额处理\">5.3 数字和金额处理</h3>\n<pre><code class=\"language-typescript\">// src/utils/index.ts\n\n// 数组求和\nexport const getSumValue = (values: number[]): number =&gt; {\n  return values.reduce((prev, curr) =&gt; {\n    const value = Number(curr)\n    if (!Number.isNaN(value)) {\n      return prev + curr\n    } else {\n      return prev\n    }\n  }, 0)\n}\n\n// 元转分\nexport const yuanToFen = (amount: string | number): number =&gt; {\n  return convertToInteger(amount)\n}\n\n// 分转元\nexport const fenToYuan = (price: string | number): string =&gt; {\n  return formatToFraction(price)\n}\n\n// ERP 格式化数字\nexport const erpNumberFormatter = (num: number | string | undefined, digit: number) =&gt; {\n  if (num == null) {\n    return ''\n  }\n  if (typeof num === 'string') {\n    num = parseFloat(num)\n  }\n  if (isNaN(num)) {\n    return ''\n  }\n  return num.toFixed(digit)\n}\n</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li>参数支持多种类型：<code>string | number</code></li>\n<li>返回值类型明确：<code>: number</code> 或 <code>: string</code></li>\n<li><code>undefined</code> 处理</li>\n</ul>\n<h2 id=\"六hooks组合式函数的-typescript\">六、Hooks（组合式函数）的 TypeScript</h2>\n<h3 id=\"61-usetable-hook\">6.1 useTable Hook</h3>\n<pre><code class=\"language-typescript\">// src/hooks/web/useTable.ts\ninterface ResponseType&lt;T = any&gt; {\n  list: T[]\n  total?: number\n}\n\ninterface UseTableConfig&lt;T = any&gt; {\n  getListApi: (option: any) =&gt; Promise&lt;T&gt;\n  delListApi?: (option: any) =&gt; Promise&lt;T&gt;\n  exportListApi?: (option: any) =&gt; Promise&lt;T&gt;\n  response?: ResponseType\n  defaultParams?: Recordable\n  props?: TableProps\n}\n\ninterface TableObject&lt;T = any&gt; {\n  pageSize: number\n  currentPage: number\n  total: number\n  tableList: T[]\n  params: any\n  loading: boolean\n  exportLoading: boolean\n  currentRow: Nullable&lt;T&gt;\n}\n/*\n  - reactive&lt;TableObject&lt;T&gt;&gt; 表示创建一个响应式对象，它的类型是 TableObject&lt;T&gt;\n  - 初始值是 { pageSize: 10, ... }，必须符合 TableObject&lt;T&gt; 的结构\n*/\nexport const useTable = &lt;T = any&gt;(config?: UseTableConfig&lt;T&gt;) =&gt; {\n  const tableObject = reactive&lt;TableObject&lt;T&gt;&gt;({\n    pageSize: 10,\n    currentPage: 1,\n    total: 10,\n    tableList: [],\n    params: {\n      ...(config?.defaultParams || {})\n    },\n    loading: true,\n    exportLoading: false,\n    currentRow: null\n  })\n\n  const paramsObj = computed(() =&gt; {\n    return {\n      ...tableObject.params,\n      pageSize: tableObject.pageSize,\n      pageNo: tableObject.currentPage\n    }\n  })\n\n  const methods = {\n    getList: async () =&gt; {\n      tableObject.loading = true\n      const res = await config?.getListApi(unref(paramsObj)).finally(() =&gt; {\n        tableObject.loading = false\n      })\n      if (res) {\n        // 不管 res 原本是什么类型，我强制把它当成 ResponseType 来用\n        tableObject.tableList = (res as unknown as ResponseType).list\n        tableObject.total = (res as unknown as ResponseType).total ?? 0\n      }\n    }\n    // ... 其他方法\n  }\n\n  return {\n    tableObject,\n    methods\n  }\n}\n</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li>泛型 Hook：<code>&lt;T = any&gt;</code></li>\n<li>接口定义配置和状态</li>\n<li><code>reactive&lt;类型&gt;</code> 定义响应式对象</li>\n<li>双重类型断言：<code>as unknown as ResponseType</code>，\n<ul>\n<li>先断言成 unknown</li>\n<li>再断言成 ResponseType</li>\n<li>用来强制转换原本不兼容的类型，绕过 TS 检查</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"62-组件引用类型\">6.2 组件引用类型</h3>\n<pre><code class=\"language-typescript\">// src/hooks/web/useTable.ts\nimport { ElTable } from 'element-plus'\n/*\n  它是Table 组件实例 + TableExpose 接口的交叉类型\n  既是 Table 组件的实例，又包含 TableExpose 里定义的方法。等价于：\n  type TableRef = InstanceType&lt;typeof Table&gt; &amp; TableExpose\n*/\nconst tableRef = ref&lt;typeof Table &amp; TableExpose&gt;()\nconst elTableRef = ref&lt;ComponentRef&lt;typeof ElTable&gt;&gt;()\n\nconst register = (ref: typeof Table &amp; TableExpose, elRef: ComponentRef&lt;typeof ElTable&gt;) =&gt; {\n  tableRef.value = ref\n  elTableRef.value = elRef\n}\n</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li><code>typeof</code> 获取类型</li>\n<li><code>&amp;</code> 交叉类型（同时满足多个类型）</li>\n<li><code>ComponentRef&lt;T&gt;</code> 组件实例类型</li>\n</ul>\n<p>typeof 用法：</p>\n<pre><code class=\"language-typescript\">function createUser(name: string, age: number) {\n  return {\n    name,\n    age,\n    sayHello() {\n      console.log(`Hi, I'm ${name}`)\n    }\n  }\n}\n\ntype CreateUserFn = typeof createUser\n\nconst myCreateUser: CreateUserFn = (n, a) =&gt; {\n  return { age: a, sayHello() {} }  // ❌ 报错。缺少name\n}\n</code></pre>\n<h2 id=\"七常见类型使用技巧\">七、常见类型使用技巧</h2>\n<h3 id=\"71-类型断言\">7.1 类型断言</h3>\n<pre><code class=\"language-typescript\">// 断言为特定类型\nconst value = someValue as string\n\n// 先断言为 unknown，再断言为目标类型\nconst data = res as unknown as ResponseType\n\n// 表单数据的类型断言\n/*\n  - formData.value.id：某个表单数据的 id 字段\n  - undefined：赋的值是 undefined\n  - as number | undefined：告诉 TS，这个 id 的类型是 number | undefined\n\n  如果直接写：formData.value.id = undefined，TS 可能推断 id 的类型是 undefined，后面你想给它赋数字时会报错\n\n  其实不用断言：id: number | undefined\n*/\nformData.value.id = undefined as number | undefined\n</code></pre>\n<h3 id=\"72-可选链和空值合并\">7.2 可选链和空值合并</h3>\n<pre><code class=\"language-typescript\">// 可选链：?.\ntreeRef.value?.filter(val)\nconfig?.getListApi(params)\n\n// 空值合并：??\nconst total = response.total ?? 0\nconst lang = wsCache.get(CACHE_KEY.LANG) || 'zh-CN'\n</code></pre>\n<h3 id=\"73-数组和对象的类型\">7.3 数组和对象的类型</h3>\n<pre><code class=\"language-typescript\">// 数组类型\nconst list: string[] = []\nconst roles: number[] = [1, 2, 3]\nconst users: UserVO[] = []\n\n// 对象类型\nconst obj: { [key: string]: any } = {}\nconst params: Recordable = {}\n\n// Map 和 Set\nconst map = new Map&lt;string, UserVO&gt;()\nconst set = new Set&lt;string&gt;()\n</code></pre>\n<h3 id=\"74-函数类型\">7.4 函数类型</h3>\n<pre><code class=\"language-typescript\">// 函数类型定义\n/*\n  Callback 是一个函数类型，这个函数接收一个 data 参数（任意类型），不返回任何值\n    - (data: any) =&gt; void：这是一个函数类型\n    - 示例：\n      type Callback = (data: any) =&gt; void\n\n      // 1. 定义一个符合 Callback 类型的函数\n      const handleSuccess: Callback = (data) =&gt; {\n        console.log('成功:', data)\n      }\n*/\ntype Callback = (data: any) =&gt; void\ntype ApiFunction = (params: any) =&gt; Promise&lt;any&gt;\n\n// 箭头函数\nconst handleClick = (id: number): void =&gt; {\n  console.log(id)\n}\n\n// async 函数\nconst fetchData = async (id: number): Promise&lt;UserVO&gt; =&gt; {\n  const res = await api.getUser(id)\n  return res\n}\n</code></pre>\n<h2 id=\"八项目中的高级-typescript-用法\">八、项目中的高级 TypeScript 用法</h2>\n<h3 id=\"81-泛型约束\">8.1 泛型约束</h3>\n<pre><code class=\"language-typescript\">// 约束泛型必须包含某些属性\n/*\n  K extends keyof T：K 必须是 T 的键之一。\n  - 不安全的写法：\n    function getPropertyUnsafe(obj: any, key: string) {\n      return obj[key]  // 返回值类型是 any，不安全\n    }\n\n    const value = getPropertyUnsafe(user, 'xxx')  // ✅ 不报错，但运行时可能 undefined\n*/\nfunction getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) {\n  return obj[key]\n}\n\n// 使用示例\nconst user = { name: '张三', age: 20 }\nconst name = getProperty(user, 'name') // OK\nconst gender = getProperty(user, 'gender') // 错误：gender 不在 user 中\n</code></pre>\n<h3 id=\"82-工具类型\">8.2 工具类型</h3>\n<pre><code class=\"language-typescript\">// Partial：所有属性变为可选\n/*\n  // 原始类型\n  interface UserVO {\n    id: number\n    name: string\n  }\n\n  // 使用 Partial\n  type PartialUser = Partial&lt;UserVO&gt;\n\n  // 等价于手动写：\n  type PartialUser = {\n    id?: number\n    name?: string\n  }\n*/\ntype PartialUser = Partial&lt;UserVO&gt;\n\n// Required：所有属性变为必填\ntype RequiredUser = Required&lt;UserVO&gt;\n\n// Pick：选择部分属性\ntype UserBasic = Pick&lt;UserVO, 'id' | 'username' | 'nickname'&gt;\n\n// Omit：排除部分属性\ntype UserWithoutPassword = Omit&lt;UserVO, 'password'&gt;\n\n// Record：创建对象类型\n/*\n  使用 TypeScript 内置工具类型 Record&lt;K, V&gt; 创建一个\"键值对映射\"类型\n    - Record&lt;K, V&gt;：创建一个对象类型\n    - Record&lt;number, UserVO&gt;\n    \n  等价于手动写：\n    type UserMap = {\n      [key: number]: UserVO\n    }\n\n  示例：\n    interface UserVO {\n      id: number\n      name: string\n      email: string\n    }\n\n    type UserMap = Record&lt;number, UserVO&gt;\n\n    // 使用\n    const users: UserMap = {\n      1: { id: 1, name: '张三', email: 'zhang@example.com' },\n      2: { id: 2, name: '李四', email: 'li@example.com' },\n      100: { id: 100, name: '王五', email: 'wang@example.com' }\n    }\n\n    // 访问\n    const user1 = users[1]      // UserVO 类型\n    const user2 = users[2]      // UserVO 类型\n\n    // ❌ 键必须是 number\n    const invalid: UserMap = {\n      'abc': { id: 1, name: '张三', email: 'zhang@example.com' }  // 报错\n    }\n*/\ntype UserMap = Record&lt;number, UserVO&gt;\n</code></pre>\n<h3 id=\"83-条件类型\">8.3 条件类型</h3>\n<pre><code class=\"language-typescript\">// 根据条件选择类型\ntype IsString&lt;T&gt; = T extends string ? true : false\n\n// 使用示例\ntype A = IsString&lt;string&gt; // true\ntype B = IsString&lt;number&gt; // false\n\n// 项目中的使用\ntype Recordable&lt;T = any, K = string&gt; = Record&lt;K extends null | undefined ? string : K, T&gt;\n</code></pre>\n<h3 id=\"84-模板字面量类型\">8.4 模板字面量类型</h3>\n<pre><code class=\"language-typescript\">// 动态生成类型\ntype EventName = 'click' | 'change' | 'input'\n// Capitalize&lt;T&gt; 是 TS 内置工具类型：type A = Capitalize&lt;'click'&gt;   // 'Click'\ntype EventHandler = `on${Capitalize&lt;EventName&gt;}`\n// 结果：'onClick' | 'onChange' | 'onInput'\n</code></pre>\n<h2 id=\"九实战案例\">九、实战案例</h2>\n<h3 id=\"案例-1用户管理页面\">案例 1：用户管理页面</h3>\n<pre><code class=\"language-typescript\">// src/views/system/user/index.vue\n&lt;script lang=\"ts\" setup&gt;\nimport * as UserApi from '@/api/system/user'\nimport * as CompanyApi from '@/api/system/company'\n\ndefineOptions({ name: 'SystemUser' })\n\nconst message = useMessage()\nconst { t } = useI18n()\n\n// 列表状态\nconst loading = ref&lt;boolean&gt;(true)\nconst total = ref&lt;number&gt;(0)\nconst list = ref&lt;UserApi.UserVO[]&gt;([])\nconst companyTreeData = ref&lt;Tree[]&gt;([])\n\n// 查询参数\nconst queryParams = reactive({\n  pageNo: 1,\n  pageSize: 10,\n  username: undefined as string | undefined,\n  mobile: undefined as string | undefined,\n  status: undefined as number | undefined,\n  deptId: undefined as number | undefined,\n  createTime: [] as Date[]\n})\n\n// 获取用户列表\nconst getList = async () =&gt; {\n  loading.value = true\n  try {\n    const data = await UserApi.getUserPage(queryParams)\n    list.value = data.list\n    total.value = data.total\n  } finally {\n    loading.value = false\n  }\n}\n\n// 删除用户\nconst handleDelete = async (id: number) =&gt; {\n  await message.delConfirm()\n  await UserApi.deleteUser(id)\n  message.success(t('common.delSuccess'))\n  await getList()\n}\n\n// 组件挂载后加载数据\nonMounted(() =&gt; {\n  getList()\n})\n&lt;/script&gt;\n</code></pre>\n<h3 id=\"案例-2表单组件\">案例 2：表单组件</h3>\n<pre><code class=\"language-typescript\">// src/views/system/user/UserForm.vue\n&lt;script lang=\"ts\" setup&gt;\nimport { FormRules } from 'element-plus'\nimport * as UserApi from '@/api/system/user'\nimport * as PostApi from '@/api/system/post'\n\nconst { t } = useI18n()\nconst message = useMessage()\n\n// Props\nconst props = defineProps&lt;{\n  companyTreeData?: any[]\n  fixedCompany?: { name: string; pid: number } | null\n}&gt;()\n\n// Emits\nconst emits = defineEmits&lt;{\n  (e: 'success'): void\n}&gt;()\n\n// 表单数据\nconst formData = ref&lt;UserApi.UserVO&gt;({\n  id: undefined,\n  username: '',\n  nickname: '',\n  password: '',\n  deptId: undefined,\n  postIds: [],\n  email: '',\n  mobile: '',\n  sex: undefined,\n  status: 0\n})\n\n// 表单验证规则\nconst formRules = reactive&lt;FormRules&gt;({\n  username: [{ required: true, message: '用户名不能为空', trigger: 'blur' }],\n  nickname: [{ required: true, message: '...', trigger: 'blur' }],\n  password: [\n    { required: true, message: '密码不能为空', trigger: 'blur' },\n    { min: 8, max: 16, message: '...', trigger: 'blur' }\n  ],\n  email: [\n    { required: true, message: '邮箱不能为空', trigger: 'blur' },\n    { type: 'email', message: '...', trigger: 'blur' }\n  ],\n  mobile: [\n    { required: true, message: '手机号不能为空', trigger: 'blur' },\n    { pattern: /^1[3-9]\\d{9}$/, message: '...', trigger: 'blur' }\n  ]\n})\n\nconst formRef = ref()\nconst dialogVisible = ref&lt;boolean&gt;(false)\nconst formLoading = ref&lt;boolean&gt;(false)\nconst formType = ref&lt;'create' | 'update'&gt;('create')\nconst postList = ref&lt;PostApi.PostVO[]&gt;([])\n\n// 打开表单\nconst open = async (type: 'create' | 'update', id?: number) =&gt; {\n  dialogVisible.value = true\n  formType.value = type\n  resetForm()\n\n  if (id) {\n    formLoading.value = true\n    try {\n      formData.value = await UserApi.getUser(id)\n    } finally {\n      formLoading.value = false\n    }\n  }\n\n  // 加载岗位列表\n  postList.value = await PostApi.getSimplePostList()\n}\n\n// 提交表单\nconst submitForm = async () =&gt; {\n  const form = unref(formRef)\n  if (!form) return\n\n  await form.validate()\n  formLoading.value = true\n  try {\n    const data = unref(formData)\n    if (formType.value === 'create') {\n      await UserApi.createUser(data)\n      message.success(t('common.createSuccess'))\n    } else {\n      await UserApi.updateUser(data)\n      message.success(t('common.updateSuccess'))\n    }\n    dialogVisible.value = false\n    emits('success')\n  } finally {\n    formLoading.value = false\n  }\n}\n\n// 重置表单\nconst resetForm = () =&gt; {\n  formData.value = {\n    id: undefined,\n    username: '',\n    nickname: '',\n    password: '',\n    deptId: undefined,\n    postIds: [],\n    email: '',\n    mobile: '',\n    sex: undefined,\n    status: 0\n  }\n  formRef.value?.resetFields()\n}\n\ndefineExpose({ open })\n&lt;/script&gt;\n</code></pre>\n<h3 id=\"案例-3pinia-store\">案例 3：Pinia Store</h3>\n<pre><code class=\"language-typescript\">// src/store/modules/dict.ts\nimport { defineStore } from 'pinia'\nimport { store } from '../index'\nimport { DictDataVO } from '@/api/system/dict/types'\nimport { CACHE_KEY, useCache } from '@/hooks/web/useCache'\nimport { getSimpleDictDataList } from '@/api/system/dict/dict.data'\n\nconst { wsCache } = useCache('sessionStorage')\n\nexport interface DictValueType {\n  value: any\n  label: string\n  clorType?: string\n  cssClass?: string\n}\n\nexport interface DictTypeType {\n  dictType: string\n  dictValue: DictValueType[]\n}\n\nexport interface DictState {\n  dictMap: Map&lt;string, any&gt;\n  isSetDict: boolean\n}\n\nexport const useDictStore = defineStore('dict', {\n  state: (): DictState =&gt; ({\n    dictMap: new Map&lt;string, any&gt;(),\n    isSetDict: false\n  }),\n\n  getters: {\n    getDictMap(): Recordable {\n      const dictMap = wsCache.get(CACHE_KEY.DICT_CACHE)\n      if (dictMap) {\n        this.dictMap = dictMap\n      }\n      return this.dictMap\n    },\n    getIsSetDict(): boolean {\n      return this.isSetDict\n    }\n  },\n\n  actions: {\n    async setDictMap() {\n      const dictMap = wsCache.get(CACHE_KEY.DICT_CACHE)\n      if (dictMap) {\n        this.dictMap = dictMap\n        this.isSetDict = true\n      } else {\n        const res = await getSimpleDictDataList()\n        const dictDataMap = new Map&lt;string, any&gt;()\n\n        res.forEach((dictData: DictDataVO) =&gt; {\n          const enumValueObj = dictDataMap[dictData.dictType]\n          if (!enumValueObj) {\n            dictDataMap[dictData.dictType] = []\n          }\n\n          dictDataMap[dictData.dictType].push({\n            value: dictData.value,\n            label: dictData.label,\n            colorType: dictData.colorType,\n            cssClass: dictData.cssClass\n          })\n        })\n\n        this.dictMap = dictDataMap\n        this.isSetDict = true\n        wsCache.set(CACHE_KEY.DICT_CACHE, dictDataMap, { exp: 60 })\n      }\n    },\n\n    getDictByType(type: string) {\n      if (!this.isSetDict) {\n        this.setDictMap()\n      }\n      return this.dictMap[type]\n    },\n\n    async resetDict() {\n      wsCache.delete(CACHE_KEY.DICT_CACHE)\n      await this.setDictMap()\n    }\n  }\n})\n\nexport const useDictStoreWithOut = () =&gt; {\n  return useDictStore(store)\n}\n</code></pre>\n<h2 id=\"十常见错误和解决方案\">十、常见错误和解决方案</h2>\n<h3 id=\"错误-1类型-xxx-上不存在属性-yyy\">错误 1：类型 \"xxx\" 上不存在属性 \"yyy\"</h3>\n<pre><code class=\"language-typescript\">// 错误示例\nconst user = { name: '张三' }\nconsole.log(user.age) // 错误：类型\"{name: string}\"上不存在属性\"age\"\n\n// 解决方案 1：定义完整类型\ninterface User {\n  name: string\n  age?: number // 可选属性\n}\nconst user: User = { name: '张三' }\nconsole.log(user.age) // OK\n\n// 解决方案 2：类型断言\nconsole.log((user as any).age) // OK，但不推荐\n</code></pre>\n<h3 id=\"错误-2类型-undefined-不能赋值给类型-xxx\">错误 2：类型 \"undefined\" 不能赋值给类型 \"xxx\"</h3>\n<pre><code class=\"language-typescript\">// 错误示例\nconst formData = ref&lt;UserVO&gt;({}) // 错误\n\n// 解决方案：属性设为可选或提供默认值\nconst formData = ref&lt;Partial&lt;UserVO&gt;&gt;({}) // 使用 Partial\n\n// 或者提供完整默认值\nconst formData = ref&lt;UserVO&gt;({\n  id: undefined,\n  username: '',\n  nickname: ''\n})\n</code></pre>\n<h3 id=\"错误-3参数-xxx-隐式具有-any-类型\">错误 3：参数 \"xxx\" 隐式具有 \"any\" 类型</h3>\n<pre><code class=\"language-typescript\">// 错误示例\nconst handleClick = (item) =&gt; {\n  // 错误\n  console.log(item.id)\n}\n\n// 解决方案：显式标注类型\nconst handleClick = (item: UserVO) =&gt; {\n  console.log(item.id)\n}\n</code></pre>\n<h3 id=\"错误-4无法调用可能是-undefined-的对象\">错误 4：无法调用可能是 \"undefined\" 的对象</h3>\n<pre><code class=\"language-typescript\">// 错误示例\nformRef.value.validate() // 错误：可能是 undefined\n\n// 解决方案 1：可选链\nformRef.value?.validate()\n\n// 解决方案 2：判断后调用\nif (formRef.value) {\n  formRef.value.validate()\n}\n\n// 解决方案 3：非空断言（确定不为空时使用）\n// 我向 TypeScript 保证：在这里 formRef.value 一定不是 null 或 undefined，你放心当成非空来用。\nformRef.value!.validate()\n</code></pre>\n<h2 id=\"十一最佳实践总结\">十一、最佳实践总结</h2>\n<h3 id=\"1-类型定义原则\">1. 类型定义原则</h3>\n<ul>\n<li>✅ 优先使用 <code>interface</code> 定义对象结构</li>\n<li>✅ 使用 <code>type</code> 定义联合类型、交叉类型</li>\n<li>✅ 简单类型可以让 TS 自动推断</li>\n<li>✅ 复杂类型明确标注</li>\n</ul>\n<h3 id=\"2-api-层\">2. API 层</h3>\n<ul>\n<li>✅ 为每个接口定义 VO/DTO 类型</li>\n<li>✅ API 函数参数和返回值标注类型</li>\n<li>✅ 使用 <code>async/await</code> 和 <code>Promise&lt;T&gt;</code></li>\n</ul>\n<h3 id=\"3-store-层\">3. Store 层</h3>\n<ul>\n<li>✅ 定义 State、Getters、Actions 的类型</li>\n<li>✅ 使用 <code>interface</code> 定义 State 结构</li>\n<li>✅ Getters 明确返回类型</li>\n<li>✅ Actions 参数标注类型</li>\n</ul>\n<h3 id=\"4-views-层\">4. Views 层</h3>\n<ul>\n<li>✅ 使用 <code>ref&lt;T&gt;()</code> 或 <code>reactive&lt;T&gt;()</code> 标注类型</li>\n<li>✅ <code>defineProps&lt;{}&gt;()</code> 定义 Props 类型</li>\n<li>✅ <code>defineEmits&lt;{}&gt;()</code> 定义 Emits 类型</li>\n<li>✅ 使用 <code>FormRules</code> 定义表单验证</li>\n</ul>\n<h3 id=\"5-工具函数\">5. 工具函数</h3>\n<ul>\n<li>✅ 参数和返回值都要标注类型</li>\n<li>✅ 复杂函数使用泛型</li>\n<li>✅ 联合类型处理多种输入</li>\n</ul>\n<h3 id=\"6-错误处理\">6. 错误处理</h3>\n<ul>\n<li>✅ 使用可选链 <code>?.</code> 避免 undefined 错误</li>\n<li>✅ 使用空值合并 <code>??</code> 提供默认值</li>\n<li>✅ 适时使用类型断言 <code>as</code></li>\n<li>⚠️ 避免过度使用 <code>any</code></li>\n</ul>\n<h2 id=\"附录常用类型速查表\">附录：常用类型速查表</h2>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>string</code></td>\n<td>字符串</td>\n<td><code>const name: string = '张三'</code></td>\n</tr>\n<tr>\n<td><code>number</code></td>\n<td>数字</td>\n<td><code>const age: number = 20</code></td>\n</tr>\n<tr>\n<td><code>boolean</code></td>\n<td>布尔值</td>\n<td><code>const loading: boolean = true</code></td>\n</tr>\n<tr>\n<td><code>array</code></td>\n<td>数组</td>\n<td><code>const list: string[] = []</code></td>\n</tr>\n<tr>\n<td><code>object</code></td>\n<td>对象</td>\n<td><code>const obj: { id: number } = { id: 1 }</code></td>\n</tr>\n<tr>\n<td><code>any</code></td>\n<td>任意类型</td>\n<td><code>const data: any = {}</code></td>\n</tr>\n<tr>\n<td><code>unknown</code></td>\n<td>未知类型</td>\n<td><code>const data: unknown = {}</code></td>\n</tr>\n<tr>\n<td><code>void</code></td>\n<td>无返回值</td>\n<td><code>const fn = (): void =&gt; {}</code></td>\n</tr>\n<tr>\n<td><code>null</code></td>\n<td>空</td>\n<td><code>const data: null = null</code></td>\n</tr>\n<tr>\n<td><code>undefined</code></td>\n<td>未定义</td>\n<td><code>const data: undefined = undefined</code></td>\n</tr>\n<tr>\n<td><code>never</code></td>\n<td>永不返回</td>\n<td><code>const fn = (): never =&gt; { throw new Error() }</code></td>\n</tr>\n<tr>\n<td><code>Promise&lt;T&gt;</code></td>\n<td>Promise</td>\n<td><code>const fn = (): Promise&lt;string&gt; =&gt; {}</code></td>\n</tr>\n<tr>\n<td><code>Ref&lt;T&gt;</code></td>\n<td>Vue Ref</td>\n<td><code>const count = ref&lt;number&gt;(0)</code></td>\n</tr>\n<tr>\n<td><code>ComputedRef&lt;T&gt;</code></td>\n<td>Vue Computed</td>\n<td><code>const double = computed&lt;number&gt;(() =&gt; count.value * 2)</code></td>\n</tr>\n<tr>\n<td><code>Nullable&lt;T&gt;</code></td>\n<td>可空类型</td>\n<td><code>const id: Nullable&lt;number&gt; = null</code></td>\n</tr>\n<tr>\n<td><code>Recordable</code></td>\n<td>对象</td>\n<td><code>const obj: Recordable = {}</code></td>\n</tr>\n<tr>\n<td><code>PageParam</code></td>\n<td>分页参数</td>\n<td><code>const params: PageParam = { pageNo: 1, pageSize: 10 }</code></td>\n</tr>\n</tbody>\n</table>\n<p><strong>结束语</strong></p>\n<p>本文档覆盖了项目中 <code>绝大多数</code> 的 TypeScript 使用场景。建议：</p>\n<ol>\n<li>先理解基础概念（interface、type、泛型）</li>\n<li>在实际编写代码时参考对应章节</li>\n<li>遇到错误时查看\"常见错误和解决方案\"</li>\n<li>多看项目代码，模仿学习</li>\n</ol>\n<p>TypeScript 的核心是<strong>类型安全</strong>，合理使用类型可以：</p>\n<ul>\n<li>✅ 减少运行时错误</li>\n<li>✅ 提升代码可维护性</li>\n<li>✅ 提供更好的 IDE 智能提示</li>\n<li>✅ 让代码更加规范</li>\n</ul>\n\n</div>\n<div id=\"MySignature\" role=\"contentinfo\">\n    <section class=\"m-reprintStatement\" style=\"white-space:normal;/* 防止break-all与nowrap矛盾 */word-break:break-all;\">\n    作者：<a href=\"https://www.cnblogs.com/pengjiali/\" target=\"_blank\">彭加李</a><br>\n    出处：<a href=\"https://www.cnblogs.com/pengjiali/p/19387524\" target=\"_blank\">https://www.cnblogs.com/pengjiali/p/19387524</a><br>\n    本文版权归作者和博客园共有,欢迎转载,但未经作者同意必须保留此段声明,且在文章页面明显位置给出原文连接。\n</section>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\" data-last-update-days=\"0\" data-date-updated=\"2025-12-23 18:31\">2025-12-23 18:31</span>&nbsp;\n<a href=\"https://www.cnblogs.com/pengjiali\">彭加李</a>&nbsp;\n阅读(<span id=\"post_view_count\">7</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19387524);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19387524', targetLink: 'https://www.cnblogs.com/pengjiali/p/19387524', title: '前端 TypeScript 入门2' })\">举报</a>\n</div>","guid":{"value":"df9fd7c6255c638659648393e00cf2a6"}},{"title":"Oracle数据库初始化参数深度解析：部分说明与隐藏参数实战","link":"https://www.cnblogs.com/liuziyi1/p/19387152","description":"<h2>\n\t\t\t<a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/liuziyi1/p/19387152\" title=\"发布于 2025-12-23 15:02\">\n    <span role=\"heading\" aria-level=\"2\">Oracle数据库初始化参数深度解析：部分说明与隐藏参数实战</span>\n    \n\n</a>\n\n\t\t</h2>\n\t\t<div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\n<h2 id=\"引言\">引言</h2>\n<p>Oracle数据库的初始化参数是配置实例运行特性的核心，直接影响数据库的安全性、性能、可用性等关键指标。在庞大的参数体系中，部分参数仅在文档中得到部分说明，另有大量隐藏参数（以下划线开头）未被官方文档详细记载。这些参数往往包含Oracle数据库的“底层机密”，合理运用能解决常规配置无法处理的问题——从精细化审计到内存优化，从故障诊断到测试环境搭建。</p>\n<h2 id=\"一部分说明的初始化参数\">一、部分说明的初始化参数</h2>\n<h3 id=\"11-audit_syslog_level安全审计的进阶配置\">1.1 AUDIT_SYSLOG_LEVEL：安全审计的进阶配置</h3>\n<h4 id=\"核心功能\">核心功能</h4>\n<p>AUDIT_SYSLOG_LEVEL参数用于将数据库审计日志写入操作系统的syslog（UNIX）或事件日志（Windows），核心价值是避免特权用户删除审计记录——syslog日志默认由root用户所有，DBA无法篡改，能有效追踪特权操作与入侵行为。</p>\n<h4 id=\"文档说明的局限性\">文档说明的局限性</h4>\n<p>官方文档存在三点不准确描述：</p>\n<ul>\n<li>错误宣称该参数依赖AUDIT_TRAIL设置，实际即使AUDIT_TRAIL=NONE，CONNECT、STARTUP、SHUTDOWN操作仍会通过syslog记录；</li>\n<li>未说明与AUDIT_SYS_OPERATIONS的协同作用——两者结合时，SYSDBA/SYSOPER特权用户的所有SQL/PLSQL操作都会被审计；</li>\n<li>未明确设备与优先级的有效组合，无效组合会触发ORA-28错误并阻止实例启动。</li>\n</ul>\n<h4 id=\"实战配置示例\">实战配置示例</h4>\n<ol>\n<li><strong>UNIX系统配置</strong>：\n<ul>\n<li>编辑syslog.conf文件，添加日志输出规则：<code>user.notice /var/log/oracle_dbms</code>；</li>\n<li>重启syslogd服务：<code>kill -HUP $(cat /var/run/syslogd.pid)</code>；</li>\n<li>设置数据库参数：<code>ALTER SYSTEM SET audit_syslog_level='user.notice' SCOPE=SPFILE;</code>（需重启实例生效）。</li>\n</ul>\n</li>\n<li><strong>Windows系统配置</strong>：\n<ul>\n<li>无需额外配置syslog，参数会自动将日志写入“应用程序”类别的Windows事件日志；</li>\n<li>启用特权操作审计：<code>ALTER SYSTEM SET audit_sys_operations=TRUE;</code>。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"关键注意事项\">关键注意事项</h4>\n<ul>\n<li>非特权用户审计优先使用AUDIT_TRAIL=DB，审计记录存储于SYS.AUD$，便于通过数据字典视图查询；</li>\n<li>维护操作（如数据库升级）时可临时设置AUDIT_SYS_OPERATIONS=FALSE，避免生成大量冗余日志。</li>\n</ul>\n<h3 id=\"12-pga_aggregate_target自动pga内存管理的底层逻辑\">1.2 PGA_AGGREGATE_TARGET：自动PGA内存管理的底层逻辑</h3>\n<h4 id=\"核心功能-1\">核心功能</h4>\n<p>PGA_AGGREGATE_TARGET是自动PGA内存管理的核心参数，指定所有服务器进程PGA内存的总目标值，用于优化排序、哈希连接等操作的内存分配。</p>\n<h4 id=\"文档未说明的关键机制\">文档未说明的关键机制</h4>\n<p>官方文档未披露三个隐藏参数对PGA分配的限制，这是导致实际内存使用与预期不符的核心原因：</p>\n<ul>\n<li>_PGA_MAX_SIZE：单个进程可使用的最大PGA内存（字节），默认值随PGA_AGGREGATE_TARGET动态调整（如PAT&lt;1GB时默认200MB）；</li>\n<li>_SMM_MAX_SIZE：单个串行操作的最大工作区大小（千字节），默认值为PGA_AGGREGATE_TARGET的20%（PAT&lt;512MB时）；</li>\n<li>_SMM_PX_MAX_SIZE：并行执行的最大工作区大小（千字节），默认值为PGA_AGGREGATE_TARGET的50%。</li>\n</ul>\n<h4 id=\"实战优化示例\">实战优化示例</h4>\n<ol>\n<li><strong>查询隐藏参数当前值</strong>：<pre><code class=\"language-sql\">SELECT x.ksppinm name,\n       CASE WHEN x.ksppinm LIKE '%pga%' THEN to_number(y.ksppstvl)/1024 ELSE to_number(y.ksppstvl) END AS value,\n       x.ksppdesc description\nFROM x$ksppi x, x$ksppcv y\nWHERE x.inst_id = userenv('Instance')\n  AND y.inst_id = userenv('Instance')\n  AND x.indx = y.indx\n  AND x.ksppinm IN ('_pga_max_size', '_smm_max_size', '_smm_px_max_size');\n</code></pre>\n</li>\n<li><strong>调整并行执行内存限制</strong>：\n<ul>\n<li>若并行排序频繁溢出到磁盘，可手动增大_SMM_PX_MAX_SIZE：<br>\n<code>ALTER SYSTEM SET \"_smm_px_max_size\"=2097152 SCOPE=SPFILE;</code>（2GB，需重启实例）。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"关键注意事项-1\">关键注意事项</h4>\n<ul>\n<li>PGA_AGGREGATE_TARGET是“目标值”而非“硬限制”，高负载下实际内存使用可能临时超出；</li>\n<li>共享服务器模式下，Oracle 10g及以上支持自动PGA管理，Oracle 9i需手动配置SORT_AREA_SIZE等参数。</li>\n</ul>\n<h3 id=\"13-event实例级事件配置的灵活运用\">1.3 EVENT：实例级事件配置的灵活运用</h3>\n<h4 id=\"核心功能-2\">核心功能</h4>\n<p>EVENT参数用于在实例级别设置事件，适用于故障诊断、功能启用/禁用、性能数据收集等场景，配置在实例生命周期内持续有效。</p>\n<h4 id=\"文档未说明的关键内容\">文档未说明的关键内容</h4>\n<ul>\n<li>事件语法：支持多事件配置（分号分隔），语法为<code>event='event_number trace name context forever,level event_level'</code>；</li>\n<li>有效事件范围：多数事件编号在10000-10999之间，可通过<code>oerr ora &lt;事件号&gt;</code>查询描述；</li>\n<li>实例级事件的适用场景：需在进程启动时生效的事件（如RMAN备份相关事件）、全实例范围的跟踪（如SQL跟踪）。</li>\n</ul>\n<h4 id=\"实战配置示例-1\">实战配置示例</h4>\n<ol>\n<li><strong>启用死锁诊断事件</strong>：\n<ul>\n<li>设置事件10027（控制死锁跟踪信息级别）：<code>ALTER SYSTEM SET events='10027 trace name context forever,level 2' SCOPE=SPFILE;</code></li>\n<li>级别2会包含系统状态转储，便于定位死锁根源。</li>\n</ul>\n</li>\n<li><strong>临时禁用某优化器特性</strong>：\n<ul>\n<li>关闭索引跳跃扫描：<code>ALTER SYSTEM SET events='10196 trace name context forever,level 1';</code></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"关键注意事项-2\">关键注意事项</h4>\n<ul>\n<li>避免在实例级别设置事件10046（SQL跟踪），会产生大量跟踪文件，建议使用会话级或DBMS_MONITOR包；</li>\n<li>事件配置需在Oracle Support指导下进行，部分事件可能影响数据库稳定性。</li>\n</ul>\n<h3 id=\"14-os_authent_prefix操作系统与密码文件认证的结合\">1.4 OS_AUTHENT_PREFIX：操作系统与密码文件认证的结合</h3>\n<h4 id=\"核心功能-3\">核心功能</h4>\n<p>OS_AUTHENT_PREFIX指定操作系统身份认证的用户名前缀，默认值为“ops$”，文档未说明其支持“操作系统认证+密码文件认证”的混合模式。</p>\n<h4 id=\"文档未说明的关键特性\">文档未说明的关键特性</h4>\n<p>当OS_AUTHENT_PREFIX为默认值“ops$”时，以“ops$”为前缀的数据库用户（如ops$ndebes）可：</p>\n<ul>\n<li>本地连接时无需密码（操作系统身份认证）；</li>\n<li>远程连接时使用密码文件认证（需设置REMOTE_OS_AUTHENT=FALSE）；</li>\n<li>被授予SYSDBA/SYSOPER特权，无需加入操作系统DBA/OPER用户组。</li>\n</ul>\n<h4 id=\"实战配置示例-2\">实战配置示例</h4>\n<ol>\n<li><strong>创建混合模式用户</strong>：<pre><code class=\"language-sql\">CREATE USER ops$ndebes IDENTIFIED BY secret;\nGRANT CONNECT, SYSOPER TO ops$ndebes;\n</code></pre>\n</li>\n<li><strong>本地无密码连接</strong>：\n<ul>\n<li>操作系统用户ndebes执行：<code>sqlplus /</code>，自动以ops$ndebes身份登录；</li>\n</ul>\n</li>\n<li><strong>远程密码连接</strong>：\n<ul>\n<li><code>sqlplus ops$ndebes/secret@ten.oradbpro.com</code>。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"关键注意事项-3\">关键注意事项</h4>\n<ul>\n<li>安全敏感环境可修改前缀（如<code>ALTER SYSTEM SET os_authent_prefix='' SCOPE=SPFILE;</code>），禁用混合认证；</li>\n<li>外部验证用户（IDENTIFIED EXTERNALLY）无法使用密码文件认证，需根据需求选择认证方式。</li>\n</ul>\n<h2 id=\"二隐藏的初始化参数\">二、隐藏的初始化参数</h2>\n<h3 id=\"21-_trace_files_public跟踪文件权限控制\">2.1 _TRACE_FILES_PUBLIC：跟踪文件权限控制</h3>\n<h4 id=\"核心功能-4\">核心功能</h4>\n<p>_TRACE_FILES_PUBLIC参数控制新生成的SQL跟踪文件的访问权限，默认值为FALSE（仅Oracle安装用户和所属组可读取）。</p>\n<h4 id=\"实战应用场景\">实战应用场景</h4>\n<p>测试环境中，开发人员需自行分析SQL跟踪文件（如使用TKPROF），可通过以下配置开放权限：</p>\n<ol>\n<li>设置参数：<code>ALTER SYSTEM SET \"_trace_files_public\"=TRUE SCOPE=SPFILE;</code></li>\n<li>重启实例后，新生成的跟踪文件权限为“rw-r--r--”，所有系统用户均可读取。</li>\n</ol>\n<h4 id=\"关键注意事项-4\">关键注意事项</h4>\n<ul>\n<li>生产环境不建议启用，避免跟踪文件中的敏感信息（如绑定变量值）泄露；</li>\n<li>仅影响新生成的跟踪文件，历史文件权限需手动修改。</li>\n</ul>\n<h3 id=\"22-_asm_allow_only_raw_disksasm测试环境搭建\">2.2 _ASM_ALLOW_ONLY_RAW_DISKS：ASM测试环境搭建</h3>\n<h4 id=\"核心功能-5\">核心功能</h4>\n<p>_ASM_ALLOW_ONLY_RAW_DISKS参数控制ASM是否仅支持裸设备，默认值为TRUE，文档未说明其可禁用该限制，便于在无裸设备的环境中搭建ASM测试环境。</p>\n<h4 id=\"实战配置步骤\">实战配置步骤</h4>\n<ol>\n<li><strong>创建模拟磁盘文件</strong>（Windows系统）：\n<ul>\n<li>使用asmtool工具：<code>asmtool -create C:\\oradata\\ARRAY1_DISK1 512</code>（创建512MB的模拟磁盘）；</li>\n</ul>\n</li>\n<li><strong>配置ASM实例参数文件</strong>（pfile+ASM.ora）：<pre><code>instance_type=ASM\nasm_diskstring='c:\\oradata\\*'\n_asm_allow_only_raw_disks=FALSE\n</code></pre>\n</li>\n<li><strong>启动ASM实例并创建磁盘组</strong>：<pre><code class=\"language-sql\">STARTUP NOMOUNT PFILE='C:\\ORACLE\\PRODUCT\\DB10.2\\DATABASE\\pfile+ASM.ora';\nCREATE DISKGROUP cooked_dg NORMAL REDUNDANCY\nFAILGROUP array1 DISK 'C:\\ORADATA\\ARRAY1_DISK1' NAME array1_disk1,\nFAILGROUP array2 DISK 'C:\\ORADATA\\ARRAY2_DISK1' NAME array2_disk1;\n</code></pre>\n</li>\n</ol>\n<h4 id=\"关键注意事项-5\">关键注意事项</h4>\n<ul>\n<li>仅适用于测试环境，生产环境建议使用裸设备或SAN存储，确保性能与稳定性；</li>\n<li>可通过该环境模拟磁盘失效（如拔掉USB存储设备），测试ASM故障恢复能力。</li>\n</ul>\n<h2 id=\"三总结与最佳实践\">三、总结与最佳实践</h2>\n<p>Oracle数据库的部分说明参数与隐藏参数是解决复杂问题的“利器”，但使用时需遵循以下原则：</p>\n<ol>\n<li><strong>安全优先</strong>：涉及审计、认证的参数（如AUDIT_SYSLOG_LEVEL、OS_AUTHENT_PREFIX）需结合企业安全策略配置，避免权限泄露；</li>\n<li><strong>性能可控</strong>：PGA相关隐藏参数的调整需通过测试验证，避免盲目增大内存导致系统分页；</li>\n<li><strong>环境区分</strong>：隐藏参数（如_TRACE_FILES_PUBLIC、_ASM_ALLOW_ONLY_RAW_DISKS）优先在测试环境使用，生产环境需谨慎评估；</li>\n<li><strong>文档补充</strong>：配置参数前需结合官方Metalink文档与实际测试，避免依赖未公开特性导致升级风险。</li>\n</ol>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t<p class=\"postfoot\">\n\t\t\tposted on \n<span id=\"post-date\" data-last-update-days=\"0\" data-date-updated=\"2025-12-23 15:03\">2025-12-23 15:02</span>&nbsp;\n<a href=\"https://www.cnblogs.com/liuziyi1\">刘子毅</a>&nbsp;\n阅读(<span id=\"post_view_count\">43</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19387152);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19387152', targetLink: 'https://www.cnblogs.com/liuziyi1/p/19387152', title: 'Oracle数据库初始化参数深度解析：部分说明与隐藏参数实战' })\">举报</a>\n\n\t\t</p>","guid":{"value":"65d88f29a3074b712d45532a623387a8"}},{"title":"论索引的重要性","link":"https://www.cnblogs.com/zhuancloud/p/19386304","description":"<h1 class=\"postTitle\">\n                <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zhuancloud/p/19386304\" title=\"发布于 2025-12-23 12:14\">\n    <span role=\"heading\" aria-level=\"2\">论索引的重要性</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div id=\"cnblogs_post_body\" class=\"blogpost-body blogpost-body-html\">\n<h1>开篇小测验</h1>\n<p>下面这样一个小SQL 你该怎么样添加最优索引</p>\n<p>两个表上现在只有聚集索引</p>\n<p>bigproduct 表上已经有聚集索引 ProductID</p>\n<p>bigtransactionhistory 表上已经有聚集索引 TransactionID</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/980582/202512/980582-20251223120456999-725818889.png\" alt=\"b44130128656738d3f4b780d89ab2eac\" loading=\"lazy\"></p>\n<p>&nbsp;</p>\n<p>你是否一眼就能看出来呢？</p>\n<p>答案将在文章中逐步揭晓~~~</p>\n<p><span style=\"font-size: 18px; color: rgba(128, 0, 128, 1)\">简单粗暴的添加索引</span></p>\n<p>首先我们看一下没有优化前的执行计划</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/980582/202512/980582-20251223120641375-577465385.png\" alt=\"ca7e2b86cd792b5d4d254d5f5d94ad86\" loading=\"lazy\"></p>\n<p>&nbsp;</p>\n<p>clustered index scan 这其实就是表扫描，不是table scan 只是因为表上有聚集索引<br><br></p>\n<p>可以看出这个查询俩表都使用了表扫描！</p>\n<p><strong>where </strong><strong>条件添加索引</strong></p>\n<p>首先大多数人都知道 where 条件中的字段需要添加索引! 我们添加一下看看效果创建</p>\n<p>在 bigproduct 表上创建 name 列索引，在bigtransactionhistory表上创建TransactionDate 列索引。</p>\n<p>再次执行语句看一下效果！</p>\n<p>&nbsp;</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/980582/202512/980582-20251223120724790-1339715259.jpg\" alt=\"530d49249ae3bf15365abcf4643f1f8c\" loading=\"lazy\"></p>\n<p>&nbsp;</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/980582/202512/980582-20251223120744822-2049170817.png\" alt=\"fabf0aadf5ac5e8beb9fac5fc3003a45\" loading=\"lazy\"></p>\n<p>&nbsp;</p>\n<p>添加where索引以后可以看到以下几个现象</p>\n<ul class=\"list-paddingleft-1\">\n<li>\n<p>bigproduct 从原来的clustered index scan 变成 index seek</p>\n</li>\n<li>\n<p>另外多出来个KEY Lookup(clustered)</p>\n</li>\n<li>\n<p>bigproduct 上添加的索引起了作用，逻辑读bigproduct 由 601 变成10。</p>\n</li>\n<li>\n<p>bigtransactionhistory 没啥变化啊还是clustered index scan</p>\n</li>\n</ul>\n<p>解释一下出现的现象 ：首先一点bigproduct 边添加的where条件索引，起到了作用，执行的时候不是全表扫描了，逻辑读有明显的下降，出现的 KEY Lookup 是因为选择（select）的列，在索引中没有，而需要通过聚集索引再查找一次，再找一次也意味着多一部分开销！那么同样添加了where 条件索引的bigtransactionhistory表为什么没起作用呢？那是因为SQL优化器在选择计划的时候认为，不使用TransactionDate 列索引查找效率会更好!</p>\n<p>真的么？我们来验证一下，通过指定选择索引，来让优化器选择索引查找！</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/980582/202512/980582-20251223120817365-1926397905.jpg\" alt=\"a27b79c2f98f8e77339b6c2820691ba2\" loading=\"lazy\"></p>\n<p>&nbsp;</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/980582/202512/980582-20251223120831833-1982298943.png\" alt=\"f05e632e55f36c304b12af2bd3444c92\" loading=\"lazy\"></p>\n<p>&nbsp;强制使用索引以后，可以看出逻辑读由 14W 变成1961W，语句时间也变得很长，这就是优化器为什么不选用你加的索引！优化器还是很智能的吧。</p>\n<p>高能预警：优化器可不是什么时候都这么智能的...由于缓存计划或优化器抽风等原因，也会出现优化器用了这种索引，导致你的语句奇慢，读飙升直接影响到你的内存、磁盘、CPU资源！另外如果这样一条语句是系统中一条很频繁运行的语句，你的系统就挂了！没错就挂了！这就是开篇抛出的问题就是因为一条语句！</p>\n<p><strong>消灭</strong><strong>Key Lookup </strong><strong>添加</strong><strong>select </strong><strong>字段</strong></p>\n<p>这就是传说中的覆盖索引！</p>\n<p>看到执行计划中存在Key Lookup　而且消耗占比很高，如上面强制索引的计划，那么我们就要想到的 在索引中包含那些SELECT 的列！如果消耗低，逻辑读少，如上面bigproduct 表中的Key Lookup 就可以忽略（如果你追求完美，也一样优化就可以了）。</p>\n<p>包含列的图形化创建：@秋仙 特意给你的说明</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/980582/202512/980582-20251223120901669-431129901.png\" alt=\"d3e35652e888862bf5ce375e2a02fb82\" loading=\"lazy\"></p>\n<p>语句创建就是：</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/980582/202512/980582-20251223120924631-188723058.png\" alt=\"bbe701c20ca02bfb982aa5c37db8cfd8\" loading=\"lazy\"></p>\n<p>下面我们添加一下看看效果：</p>\n<p>&nbsp;</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/980582/202512/980582-20251223121001485-1463459080.jpg\" alt=\"90d3a313bebda1b8554337aa18862e91\" loading=\"lazy\"></p>\n<p>&nbsp;</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/980582/202512/980582-20251223121015442-2136458470.png\" alt=\"f27448095c8648b6a608a7eb6c3dd77e\" loading=\"lazy\"></p>\n<p>&nbsp;</p>\n<p>添加select 索引字段后可以看出的现象：</p>\n<ul class=\"list-paddingleft-1\">\n<li>\n<p>优化器自己选择了index seek</p>\n</li>\n<li>\n<p>bigtransactionhistory占比最高的Key Lookup消失了</p>\n</li>\n<li>\n<p>逻辑读由原来无索引的14W变成1W</p>\n</li>\n<li>\n<p>bigtransactionhistory表还提示缺少索引？</p>\n</li>\n</ul>\n<p>通过优化索引添加select 字段，我们看出语句又一次得到了提升bigtransactionhistory 从表扫描变成索引查找，逻辑读由14W变成 1W！这是一个质的飞跃啊！</p>\n<p>CREATE NONCLUSTERED INDEXTransactionDate包含ProductID_QuantityON[dbo].[bigTransactionHistory] ([TransactionDate])------INCLUDE 就是包含列INCLUDE ([ProductID],[Quantity])GO</p>\n<p>那为什么还提示缺少索引呢？创建一下试试吧！</p>\n<p><strong>索引再优化加入表关联列</strong></p>\n<p>按照提示我们创建索引：和上一个索引的不同 ProductID 列由包含列变成了索引列！</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/980582/202512/980582-20251223121101411-980327210.png\" alt=\"287b334380012753900062827964990f\" loading=\"lazy\"></p>\n<p>&nbsp;</p>\n<p>我们看一下效果：</p>\n<p>&nbsp;</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/980582/202512/980582-20251223121123047-1821728972.png\" alt=\"88760d389647159b33b8e1ce933c2fa0\" loading=\"lazy\"></p>\n<p>&nbsp;</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/980582/202512/980582-20251223121135989-2002256099.png\" alt=\"aa14f00db9b127ff440e7e6ae7713bba\" loading=\"lazy\"></p>\n<p>&nbsp;</p>\n<p>再次优化索引以后可以看到以下几个现象</p>\n<ul class=\"list-paddingleft-1\">\n<li>\n<p>bigtransactionhistory表还是索引查找index seek</p>\n</li>\n<li>\n<p>bigtransactionhistory依然没有了Key Lookup</p>\n</li>\n<li>\n<p>两表关联的hash join 变成了nested loops</p>\n</li>\n<li>\n<p>并行计划变成了串行</p>\n</li>\n<li>\n<p>逻辑读又从1W 变成18</p>\n</li>\n</ul>\n<p>又一次质的飞跃！读从原来的14W 变成1W 又变成18，这样大大减少了内存和IO的消耗，另外并行计划也变成了串行，无疑又减少了大量CPU的消耗！语句时间，我想这里就不用多说了吧？</p>\n<p>高能预警：这里所说的hash join，并行变串行，不懂的朋友可以在百度自行学习，这里只是针对当前语句的情况，不能一概而论！</p>\n<p><strong>精简你的索引</strong></p>\n<p>大家都知道，索引会导致update、insert、delete操作变慢！那么尽量精简你的索引就是一个很重要的话题了！</p>\n<p>上面的优化过程中我们创建了几个索引，以bigTransactionHistory为例来看一下：</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/980582/202512/980582-20251223121217953-1004101723.png\" alt=\"a10260f123cbe86d9d08f309403aa708\" loading=\"lazy\"></p>\n<p>&nbsp;</p>\n<p>脚本这里就不贴了，其实我们最后创建的索引 ProductID_TransactionDate包含Quantity 已经包含了前两个索引，而且可以说无论任何类似语句都使用ProductID_TransactionDate包含Quantity 就可以了！</p>\n<p>那么我们就可以清除前两个索引！</p>\n<p>至此语句的优化算是结束了，留下的就是bigproduct 依然有一个Key Lookup可以优化，可以仿照上面的继续优化，这里就不细说了。</p>\n<p>这就是索引的重要性！</p>\n<p>开篇小测试你做对了么？如果没做对那么这么请你自行模拟一个场景再现本篇的话题吧！</p>\n<h1>总结</h1>\n<p>数据库整体缓慢往往都是因为索引问题导致的，不要小看一条语句的威力，一条高频的语句足可以让你的数据库彻底无法工作。在和大量的运维人员交流的过程中发现，对于索引的重要性恰恰没有足够的重视，一提到优化就是修改SQL语句、读写分离、分布式数据库等舍近求远的方案，优化索引才是对数据库最高性价比的优化。</p>\n<p>&nbsp;</p>\n<p>北京格瑞趋势科技有限公司是聚焦于数据服务的高新技术企业，成立于2008年，创始团队及核心技术人员来自微软和雅虎。微软数据平台长期合作伙伴，卫宁健康数据平台战略合作伙伴。通过产品+服务双轮驱动的业务模式，14年间累计服务4000+客户，覆盖互联网、市政、交通、电信、医疗、教育、电力、制造业等各个领域。</p>\n<p>&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\" data-last-update-days=\"0\" data-date-updated=\"2025-12-23 12:14\">2025-12-23 12:14</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zhuancloud\">格瑞趋势技术团队</a>&nbsp;\n阅读(<span id=\"post_view_count\">161</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19386304);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19386304', targetLink: 'https://www.cnblogs.com/zhuancloud/p/19386304', title: '论索引的重要性' })\">举报</a>\n</div>","guid":{"value":"979c570a7d233b63a5c1ee0612e35918"}},{"title":"反向传播","link":"https://www.cnblogs.com/tokepson/p/19364232","description":"<h1 class=\"postTitle\">\n                <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/tokepson/p/19364232\" title=\"发布于 2025-12-23 11:31\">\n    <span role=\"heading\" aria-level=\"2\">反向传播</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\n<blockquote>\n<p>懂了懂了，还是这样好理解。。。。那么反向传播的计算呢？通过y1, y2, y3 求出x1 ?</p>\n</blockquote>\n<hr>\n<p>太好了！现在我们来推导<strong>反向传播</strong>的计算。这是深度学习中最核心的部分！</p>\n<hr>\n<h2 id=\"1-问题设定\"><strong>1. 问题设定</strong></h2>\n<p>我们有一个简单的三层结构：</p>\n<pre><code>输入 x → 线性层（得 z）→ softmax → 交叉熵损失 L\n</code></pre>\n<p>其中：</p>\n<ul>\n<li>$ z = Wx + b $（为了简化，我们先只考虑从 z 开始的反向传播）</li>\n<li>$ p = \\text{softmax}(z) $</li>\n<li>$ L = -\\sum y_i \\log p_i $</li>\n</ul>\n<p>我们要求 $ \\frac{\\partial L}{\\partial z_j} $，也就是损失对<strong>原始输出 z</strong> 的梯度。</p>\n<hr>\n<h2 id=\"2-已知关系\"><strong>2. 已知关系</strong></h2>\n<p>设类别数 $ C = 3 $，则：</p>\n<p></p><div class=\"math display\">\\[p_i = \\frac{e^{z_i}}{\\sum_{k=1}^C e^{z_k}}\n\\]</div><p></p><p></p><div class=\"math display\">\\[L = -\\sum_{i=1}^C y_i \\log p_i\n\\]</div><p></p><hr>\n<h2 id=\"3-计算梯度-\"><strong>3. 计算梯度</strong> <span class=\"math inline\">\\(\\frac{\\partial L}{\\partial z_j}\\)</span></h2>\n<p>这是一个<strong>非常重要的结果</strong>，也是 softmax 与交叉熵结合的美妙之处。</p>\n<p><strong>推导过程</strong>：</p>\n<p></p><div class=\"math display\">\\[\\frac{\\partial L}{\\partial z_j} = \\sum_{i=1}^C \\frac{\\partial L}{\\partial p_i} \\cdot \\frac{\\partial p_i}{\\partial z_j}\n\\]</div><p></p><p>第一步：<span class=\"math inline\">\\(\\frac{\\partial L}{\\partial p_i} = -\\frac{y_i}{p_i}\\)</span></p>\n<p>第二步：需要计算 <span class=\"math inline\">\\(\\frac{\\partial p_i}{\\partial z_j}\\)</span>，分两种情况：</p>\n<ul>\n<li><strong>当 $ i = j $时</strong>：</li>\n</ul>\n<p></p><div class=\"math display\">\\[\\frac{\\partial p_i}{\\partial z_i} = p_i(1 - p_i)\n\\]</div><p></p><ul>\n<li><strong>当 $ i \\neq j $时</strong>：</li>\n</ul>\n<p></p><div class=\"math display\">\\[\\frac{\\partial p_i}{\\partial z_j} = -p_i p_j\n\\]</div><p></p><p>现在代入：</p>\n<p></p><div class=\"math display\">\\[\\frac{\\partial L}{\\partial z_j} = \\sum_{i=1}^C \\left( -\\frac{y_i}{p_i} \\right) \\cdot \\frac{\\partial p_i}{\\partial z_j}\n\\]</div><p></p><p>分开求和：</p>\n<ol>\n<li>当 <span class=\"math inline\">\\(i = j\\)</span> 时：项为 <span class=\"math inline\">\\(-\\frac{y_j}{p_j} \\cdot p_j(1-p_j) = -y_j(1-p_j)\\)</span></li>\n<li>当 <span class=\"math inline\">\\(i \\neq j\\)</span> 时：项为 <span class=\"math inline\">\\(-\\frac{y_i}{p_i} \\cdot (-p_i p_j) = y_i p_j\\)</span></li>\n</ol>\n<p>所以：</p>\n<p></p><div class=\"math display\">\\[\\frac{\\partial L}{\\partial z_j} = -y_j(1-p_j) + \\sum_{i \\neq j} y_i p_j\n\\]</div><p></p><p>注意 <span class=\"math inline\">\\(\\sum_{i \\neq j} y_i = 1 - y_j\\)</span>（因为 y 是 one-hot，总和为1）</p>\n<p>因此：</p>\n<p></p><div class=\"math display\">\\[\\frac{\\partial L}{\\partial z_j} = -y_j + y_j p_j + p_j(1 - y_j)\n\\]</div><p></p><p></p><div class=\"math display\">\\[= -y_j + p_j(y_j + 1 - y_j)\n\\]</div><p></p><p></p><div class=\"math display\">\\[= p_j - y_j\n\\]</div><p></p><hr>\n<h2 id=\"4-最终简洁结果\"><strong>4. 最终简洁结果</strong></h2>\n<p></p><div class=\"math display\">\\[\\boxed{\\frac{\\partial L}{\\partial z_j} = p_j - y_j}\n\\]</div><p></p><p><strong>太漂亮了！</strong> 这个结果意味着：</p>\n<ul>\n<li>梯度 = <strong>预测概率 - 真实标签</strong></li>\n<li>对于真实类别（<span class=\"math inline\">\\(y_j=1\\)</span>）：梯度 = <span class=\"math inline\">\\(p_j - 1\\)</span>（负数，需要增大 <span class=\"math inline\">\\(z_j\\)</span>）</li>\n<li>对于其他类别（<span class=\"math inline\">\\(y_j=0\\)</span>）：梯度 = <span class=\"math inline\">\\(p_j - 0 = p_j\\)</span>（正数，需要减小 <span class=\"math inline\">\\(z_j\\)</span>）</li>\n</ul>\n<hr>\n<h2 id=\"5-例子验证\"><strong>5. 例子验证</strong></h2>\n<p>用我们刚才的例子：</p>\n<ul>\n<li>$ z = [3.0, 1.0, -1.0] $</li>\n<li>$ y = [1, 0, 0] $</li>\n<li>$ p = [0.88, 0.12, 0.00] $</li>\n</ul>\n<p>梯度：</p>\n<p></p><div class=\"math display\">\\[\\frac{\\partial L}{\\partial z} = p - y = [0.88-1, 0.12-0, 0.00-0] = [-0.12, 0.12, 0.00]\n\\]</div><p></p><p><strong>解释</strong>：</p>\n<ul>\n<li>对真实类别（猫）：梯度 -0.12 → 需要稍微增大 <span class=\"math inline\">\\(z_0\\)</span></li>\n<li>对其他类别（狗）：梯度 +0.12 → 需要减小 <span class=\"math inline\">\\(z_1\\)</span></li>\n<li>对鸟：梯度 0 → 不需要改变</li>\n</ul>\n<hr>\n<h2 id=\"6-扩展到-x-的梯度\"><strong>6. 扩展到 x 的梯度</strong></h2>\n<p>如果我们有 $ z = Wx + b $，那么：</p>\n<p></p><div class=\"math display\">\\[\\frac{\\partial L}{\\partial x} = W^T \\cdot \\frac{\\partial L}{\\partial z}\n\\]</div><p></p><p>因为 $ \\frac{\\partial z}{\\partial x} = W^T $。</p>\n<hr>\n<h2 id=\"总结反向传播流程\"><strong>总结反向传播流程</strong>：</h2>\n<ol>\n<li>前向计算：$ z → softmax → p → L = -\\sum y_i \\log p_i $</li>\n<li>反向传播：\n<ul>\n<li>$ \\frac{\\partial L}{\\partial z} = p - y $（极其简洁！）</li>\n<li>然后继续向后传播到 $ W, b, x $</li>\n</ul>\n</li>\n</ol>\n<p>这就是为什么 softmax + 交叉熵在深度学习中被广泛使用——梯度计算既简洁又数值稳定！</p>\n<hr>\n<h2 id=\"相关参考\">相关参考：</h2>\n<ul>\n<li><a href=\"http://neuralnetworksanddeeplearning.com/chap2.html\" target=\"_blank\" rel=\"noopener nofollow\">How the backpropagation algorithm works</a></li>\n<li><a href=\"https://blog.csdn.net/qq_36803941/article/details/136191848?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EPaidSort-2-136191848-blog-107242858.235%5Ev43%5Epc_blog_bottom_relevance_base5&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EPaidSort-2-136191848-blog-107242858.235%5Ev43%5Epc_blog_bottom_relevance_base5&amp;utm_relevant_index=4\" target=\"_blank\" rel=\"noopener nofollow\">深度学习：完全理解反向传播算法（一）</a></li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\" data-last-update-days=\"0\" data-date-updated=\"2025-12-23 11:31\">2025-12-23 11:31</span>&nbsp;\n<a href=\"https://www.cnblogs.com/tokepson\">TokE648</a>&nbsp;\n阅读(<span id=\"post_view_count\">8</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19364232);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19364232', targetLink: 'https://www.cnblogs.com/tokepson/p/19364232', title: '反向传播' })\">举报</a>\n</div>","guid":{"value":"9582a51fcca2e442dfadaa0af5ec5026"}},{"title":"vite7+deepseek流式ai模板|vue3.5+deepseek3.2+markdown打字输出ai助手","link":"https://www.cnblogs.com/xiaoyan2017/p/19385909","description":"<h1 class=\"postTitle\">\n                <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaoyan2017/p/19385909\" title=\"发布于 2025-12-23 11:06\">\n    <span role=\"heading\" aria-level=\"2\">vite7+deepseek流式ai模板|vue3.5+deepseek3.2+markdown打字输出ai助手</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div id=\"cnblogs_post_body\" class=\"blogpost-body blogpost-body-html\">\n<p><span style=\"font-size: 18px; font-family: 宋体, &quot;Songti SC&quot;; color: rgba(149, 20, 234, 1)\">2026最新款爆肝<span style=\"background-color: rgba(251, 217, 250, 1)\">vite7.2+deepseek-v3.2+vant4+markdown</span>流式打字输出AI对话模板。</span></p>\n<p><span style=\"font-size: 12px\"><strong>vue3-mobile-deepseek</strong>：基于<span style=\"background-color: rgba(204, 255, 204, 1)\">vue3.5+vite7.2+vant4+markdown+openai</span>深度集成<strong>deepseek-v3.2</strong>聊天大模型。支持<span style=\"background-color: rgba(255, 255, 153, 1)\"><strong>浅色+深色主题、stream流式输出、代码高亮、复制代码、katex公式、mermaid图表</strong></span>等功能。</span></p>\n<p><img alt=\"未标题-2\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223095028752-606844753.png\" class=\"lazyload\"></p>\n<p><img alt=\"p2_2\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223095502103-480557904.gif\" class=\"lazyload\"></p>\n<h3>技术栈</h3>\n<ul>\n<li><span style=\"font-size: 12px\">编辑器：vscode</span></li>\n<li><span style=\"font-size: 12px\">技术框架：vite^7.2.4+vue^3.5.24+vue-router^4.6.4</span></li>\n<li><span style=\"font-size: 12px\">大模型框架：deepseek-v3.2 + openai</span></li>\n<li><span style=\"font-size: 12px\">UI组件库：vant^4.9.21 (有赞vue3移动端组件库)</span></li>\n<li><span style=\"font-size: 12px\">状态管理：pinia^3.0.4</span></li>\n<li><span style=\"font-size: 12px\">高亮插件：highlight.js^11.11.1</span></li>\n<li><span style=\"font-size: 12px\">markdown解析：markdown-it</span></li>\n<li><span style=\"font-size: 12px\">katex公式：@mdit/plugin-katex^0.24.1</span></li>\n<li><span style=\"font-size: 12px\">本地缓存：pinia-plugin-persistedstate^4.7.1</span></li>\n</ul>\n<p><img alt=\"p3\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223095301964-489954613.gif\" class=\"lazyload\"></p>\n<p><img alt=\"p5\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223100008878-2134758406.gif\" class=\"lazyload\"></p>\n<h3>功能性</h3>\n<ol>\n<li><span style=\"font-size: 12px\">Vue3.5+DeepSeek-V3.2流式打字输出效果</span></li>\n<li><span style=\"font-size: 12px\">基于Vite7.2构建，集成DeepSeek-Chat模型，性能更优，对话丝滑流畅</span></li>\n<li><span style=\"font-size: 12px\">支持各种代码高亮（<strong>复制代码+收缩功能</strong>），方便展示和分享代码片段</span></li>\n<li><span style=\"font-size: 12px\">支持输出<strong>Katex数学公式、Mermaid图表</strong></span></li>\n<li><span style=\"font-size: 12px\">使用vant4组件库，风格统一，时尚大气</span></li>\n<li><span style=\"font-size: 12px\">支持<strong>移动端+PC端750px像素</strong>适配</span></li>\n</ol>\n<p><img alt=\"未标题-4\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223100653751-1334957329.png\" class=\"lazyload\"></p>\n<blockquote>\n<h3><em>目前vue3-deepseek流式ai对话项目已经更新到我的原创作品集，欢迎下载使用。</em></h3>\n<p><span style=\"font-size: 12px\"><a href=\"https://mall.bilibili.com/neul-next/detailuniversal/detail.html?isMerchant=1&amp;page=detailuniversal_detail&amp;saleType=10&amp;itemsId=11721604&amp;loadingShow=1&amp;noTitleBar=1&amp;msource=merchant_share\" target=\"_blank\" rel=\"noopener nofollow\">Vue3+DeepSeek+Vant4智能聊天AI流式对话模板</a></span></p>\n</blockquote>\n<h3>项目框架结构</h3>\n<p><span style=\"font-size: 12px\">整个项目使用最新<strong>vite7.2</strong>搭建项目模板，遵循<span style=\"background-color: rgba(204, 255, 204, 1)\">vue3 setup</span>语法编码。</span></p>\n<p><img alt=\"360截图20251222233502584\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223101243748-1689844727.png\" class=\"lazyload\"></p>\n<h3>vue3环境变量.env配置</h3>\n<p><span style=\"font-size: 12px\">申请一个deepseek apikey，替换掉项目根目录下<strong>.env</strong>文件里的key即可畅快体验deepseek-v3.2流式输出功能。</span></p>\n<p><img alt=\"image\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223101608080-727506622.png\" class=\"lazyload\"></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1)\"># title\nVITE_APP_TITLE </span>= 'Vue3-DeepSeek-Chat'<span style=\"color: rgba(0, 0, 0, 1)\">\n\n# port 默认http:</span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">localhost:5173/</span>\nVITE_PORT = 3001<span style=\"color: rgba(0, 0, 0, 1)\">\n\n# 运行时自动打开浏览器\nVITE_OPEN </span>= <span style=\"color: rgba(0, 0, 255, 1)\">true</span><span style=\"color: rgba(0, 0, 0, 1)\">\n\n# 开启https\nVITE_HTTPS </span>= <span style=\"color: rgba(0, 0, 255, 1)\">false</span><span style=\"color: rgba(0, 0, 0, 1)\">\n\n# 是否删除生产环境 console\nVITE_DROP_CONSOLE </span>= <span style=\"color: rgba(0, 0, 255, 1)\">true</span><span style=\"color: rgba(0, 0, 0, 1)\">\n\n# DeepSeek API配置\nVITE_DEEPSEEK_API_KEY </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> 替换为你的 API Key\nVITE_DEEPSEEK_BASE_URL </span>= https:<span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">api.deepseek.com</span></pre>\n</div>\n<h3>项目入口main.js</h3>\n<div class=\"cnblogs_code\">\n<pre>import { createApp } from 'vue'<span style=\"color: rgba(0, 0, 0, 1)\">\nimport </span>'./style.scss'<span style=\"color: rgba(0, 0, 0, 1)\">\nimport App from </span>'./App.vue'\n\n<span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 引入路由/状态管理</span>\nimport Router from './router'<span style=\"color: rgba(0, 0, 0, 1)\">\nimport Pinia from </span>'./pinia'<span style=\"color: rgba(0, 0, 0, 1)\">\n\nimport Plugins from </span>'./plugins'<span style=\"color: rgba(0, 0, 0, 1)\">\n\nconst app </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> createApp(App)\n\napp\n.use(Router)\n.use(Pinia)\n.use(Plugins)\n.mount(</span>'#app')</pre>\n</div>\n<p><img alt=\"未标题-3\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223101727948-845129722.png\" class=\"lazyload\"></p>\n<p><img alt=\"015360截图20251222210330994\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223102137659-2062357504.png\" class=\"lazyload\"></p>\n<h3>项目布局结构</h3>\n<p><img alt=\"image\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223102355099-271621583.png\" class=\"lazyload\"></p>\n<p><span style=\"font-size: 12px\">整体项目结构分为<strong>顶部导航栏+聊天会话区+底部编辑栏</strong>三个模块。</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">template</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n  <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">div </span><span style=\"color: rgba(255, 0, 0, 1)\">class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"flexbox flex-col\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> style</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"height:100%;\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">Toolbar </span><span style=\"color: rgba(255, 0, 0, 1)\">:title</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"chatSession?.title\"</span> <span style=\"color: rgba(0, 0, 255, 1)\">/&gt;</span>\n\n    <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">div </span><span style=\"color: rgba(255, 0, 0, 1)\">class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"v3ai__scrollview flex1\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n      <span style=\"color: rgba(0, 128, 0, 1)\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1)\"> Chat对话 </span><span style=\"color: rgba(0, 128, 0, 1)\">--&gt;</span>\n      <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">div </span><span style=\"color: rgba(255, 0, 0, 1)\">v-if</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"chatSession &amp;&amp; !isEmpty(chatSession.data)\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"v3ai__chatbot\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> ref</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"scrollRef\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> @scroll</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"onScroll\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">div </span><span style=\"color: rgba(255, 0, 0, 1)\">class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"v3ai__chatbot-sessions\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span><span style=\"color: rgba(0, 0, 0, 1)\">\n          ...\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">div</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n        <span style=\"color: rgba(0, 128, 0, 1)\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1)\"> 滚动底部 </span><span style=\"color: rgba(0, 128, 0, 1)\">--&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">div </span><span style=\"color: rgba(255, 0, 0, 1)\">class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"v3ai__scrollbottom\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> :class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"{'is-bottom': reachBottom}\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> @click</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"scrollToBottom\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">i </span><span style=\"color: rgba(255, 0, 0, 1)\">class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"iconfont ai-arrD\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">i</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">div</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n      <span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">div</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n      <span style=\"color: rgba(0, 128, 0, 1)\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1)\"> 导语 </span><span style=\"color: rgba(0, 128, 0, 1)\">--&gt;</span>\n      <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">div </span><span style=\"color: rgba(255, 0, 0, 1)\">v-else class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"v3ai__chatbot-intro\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">i </span><span style=\"color: rgba(255, 0, 0, 1)\">class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"logo iconfont ai-deepseek\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">i</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">h3 </span><span style=\"color: rgba(255, 0, 0, 1)\">class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"name\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">span </span><span style=\"color: rgba(255, 0, 0, 1)\">class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"txt text-gradient\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>嗨~ Vue3-DeepSeek<span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">span</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">h3</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">p </span><span style=\"color: rgba(255, 0, 0, 1)\">class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"desc\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>你身边的智能小帮手，我可以帮你搜索、答疑、写作，请把你的任务交给我吧~<span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">p</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">div </span><span style=\"color: rgba(255, 0, 0, 1)\">class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"prompt\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n          <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">p </span><span style=\"color: rgba(255, 0, 0, 1)\">class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"tip\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">span</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>你可以这样问<span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">span</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">span</span><span style=\"color: rgba(255, 0, 0, 1)\"> @click</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"refreshPrompt\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>换一换<span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">i </span><span style=\"color: rgba(255, 0, 0, 1)\">class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"iconfont ai-shuaxin\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">i</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">span</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">p</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n          <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">ul </span><span style=\"color: rgba(255, 0, 0, 1)\">class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"list\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">li </span><span style=\"color: rgba(255, 0, 0, 1)\">v-for</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"(item,index) in promptList\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> :key</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"index\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n              <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">div </span><span style=\"color: rgba(255, 0, 0, 1)\">class</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"txt\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> @click</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"changePrompt(item.prompt)\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>{{item.emoji}} {{item.prompt}}<span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">div</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">li</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n          <span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">ul</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">div</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n      <span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">div</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">div</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n\n    <span style=\"color: rgba(0, 128, 0, 1)\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1)\"> 编辑器 </span><span style=\"color: rgba(0, 128, 0, 1)\">--&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">ChatEditor </span><span style=\"color: rgba(255, 0, 0, 1)\">ref</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"editorRef\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> :value</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"promptValue\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> :reachBottom</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"reachBottom\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> :scrollBottom</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"scrollToBottom\"</span> <span style=\"color: rgba(0, 0, 255, 1)\">/&gt;</span>\n  <span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">div</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n<span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">template</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span></pre>\n</div>\n<p><img alt=\"p4\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223102648231-1480552356.gif\" class=\"lazyload\"></p>\n<h3>自定义katex公式+mermaid图表</h3>\n<p><span style=\"font-size: 12px\">在页面引入katex和mermaid插件。</span></p>\n<div class=\"cnblogs_code\">\n<pre>import { imgSize } from '@mdit/plugin-img-size' <span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 支持带尺寸图片</span>\nimport { katex } from \"@mdit/plugin-katex\"; <span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 支持数学公式</span>\nimport 'katex/dist/katex.min.css'\n<span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 渲染mermaid图表</span>\nimport { markdownItMermaidPlugin } from '@/components/markdown/plugins/mermaidPlugin'</pre>\n</div>\n<p>渲染markdown流式</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">Markdown\n  </span><span style=\"color: rgba(255, 0, 0, 1)\">:source</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"item.content\"</span><span style=\"color: rgba(255, 0, 0, 1)\">\n  :html</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"true\"</span><span style=\"color: rgba(255, 0, 0, 1)\">\n  :linkify</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"true\"</span><span style=\"color: rgba(255, 0, 0, 1)\">\n  :typographer</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"true\"</span><span style=\"color: rgba(255, 0, 0, 1)\">\n  :plugins</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"[\n    imgSize,\n    [katex, {delimiters: 'all'}],\n    [markdownItMermaidPlugin, { ... }]\n  ]\"</span><span style=\"color: rgba(255, 0, 0, 1)\">\n  @copy</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"onCopy\"</span>\n<span style=\"color: rgba(0, 0, 255, 1)\">/&gt;</span></pre>\n</div>\n<p>封装一个mermaid图表解析插件</p>\n<div class=\"cnblogs_code\">\n<pre>export const markdownItMermaidPlugin = (md, options) =&gt;<span style=\"color: rgba(0, 0, 0, 1)\"> {\n  const defaultFence </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> md.renderer.rules.fence\n  md.renderer.rules.fence </span>= (...args) =&gt;<span style=\"color: rgba(0, 0, 0, 1)\"> {\n    const [tokens, idx] </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> args\n    const token </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> tokens[idx]\n    const lang </span>= token.info.replace(/\\[.*\\]/, '').trim() || ''\n\n    <span style=\"color: rgba(0, 0, 255, 1)\">if</span>(lang === 'mermaid'<span style=\"color: rgba(0, 0, 0, 1)\">) {\n      const code </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> token.content.trim()\n      const hash </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> generateHash(code)\n      const uuid </span>= `${hash}-${Date.now()}-${Math.random().toString(36).substring(2, 9<span style=\"color: rgba(0, 0, 0, 1)\">)}`\n\n      </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 如果有缓存，加载缓存图表</span>\n      <span style=\"color: rgba(0, 0, 255, 1)\">if</span><span style=\"color: rgba(0, 0, 0, 1)\">(renderCache.has(hash)) {\n        </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> console.log('加载缓存mermaid图表')</span>\n        <span style=\"color: rgba(0, 0, 255, 1)\">return</span><span style=\"color: rgba(0, 0, 0, 1)\"> `\n          ${ defaultFence(...args) }\n          </span>&lt;div class=\"mermaid-container\"&gt;${renderCache.get(hash)}&lt;/div&gt;\n<span style=\"color: rgba(0, 0, 0, 1)\">        `\n      }\n</span>\n<span style=\"color: rgba(0, 0, 0, 1)\">      nextTickRender(uuid)\n\n      </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span><span style=\"color: rgba(0, 0, 0, 1)\"> `\n        ${ defaultFence(...args) }\n        </span>&lt;div class=\"mermaid-container\" id=\"${uuid}\" data-mermaid-hash=\"${hash}\" data-mermaid-code=\"${encodeURIComponent(code)}\"&gt;\n          &lt;div class=\"mermaid-loading\"&gt;📊Mermaid 图表加载中...&lt;/div&gt;\n        &lt;/div&gt;\n<span style=\"color: rgba(0, 0, 0, 1)\">      `\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span><span style=\"color: rgba(0, 0, 0, 1)\"> defaultFence(...args)\n  }\n\n  </span><span style=\"color: rgba(0, 0, 255, 1)\">function</span><span style=\"color: rgba(0, 0, 0, 1)\"> nextTickRender(containerId) {\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 如果容器存在，直接渲染</span>\n    <span style=\"color: rgba(0, 0, 255, 1)\">if</span><span style=\"color: rgba(0, 0, 0, 1)\">(document.getElementById(containerId)) {\n      renderMermaidDiagram(containerId)\n      </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span><span style=\"color: rgba(0, 0, 0, 1)\">\n    }\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 使用MutationObserver监听DOM更新</span>\n    const observer = <span style=\"color: rgba(0, 0, 255, 1)\">new</span> MutationObserver((mutations, ob) =&gt;<span style=\"color: rgba(0, 0, 0, 1)\"> {\n      const container </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> document.getElementById(containerId)\n      </span><span style=\"color: rgba(0, 0, 255, 1)\">if</span><span style=\"color: rgba(0, 0, 0, 1)\">(container) {\n        ob.disconnect()\n        renderMermaidDiagram(containerId)\n      }\n    })\n    observer.observe(document.body, {\n      childList: </span><span style=\"color: rgba(0, 0, 255, 1)\">true</span><span style=\"color: rgba(0, 0, 0, 1)\">,\n      subtree: </span><span style=\"color: rgba(0, 0, 255, 1)\">true</span><span style=\"color: rgba(0, 0, 0, 1)\">\n    })\n  }\n  \n  async </span><span style=\"color: rgba(0, 0, 255, 1)\">function</span><span style=\"color: rgba(0, 0, 0, 1)\"> renderMermaidDiagram(containerId) {\n    const container </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> document.getElementById(containerId)\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1)\">container) {\n      console.warn(`Mermaid container #${containerId} not found`)\n      </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span><span style=\"color: rgba(0, 0, 0, 1)\">\n    }\n  \n    const code </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> decodeURIComponent(container.dataset.mermaidCode)\n    const hash </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> container.dataset.mermaidHash\n\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1)\">code) {\n      </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span><span style=\"color: rgba(0, 0, 0, 1)\">\n    }\n\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 检查 mermaid 是否可用</span>\n    <span style=\"color: rgba(0, 0, 255, 1)\">if</span> (<span style=\"color: rgba(0, 0, 255, 1)\">typeof</span> window.mermaid === 'undefined'<span style=\"color: rgba(0, 0, 0, 1)\">) {\n      showError(container, </span>'Mermaid 库未加载!'<span style=\"color: rgba(0, 0, 0, 1)\">)\n      </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span><span style=\"color: rgba(0, 0, 0, 1)\">\n    }\n  \n    </span><span style=\"color: rgba(0, 0, 255, 1)\">try</span><span style=\"color: rgba(0, 0, 0, 1)\"> {\n      </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 配置 mermaid（如果还未配置）</span>\n      <span style=\"color: rgba(0, 0, 255, 1)\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1)\">window.mermaid.initialized) {\n        window.mermaid.initialize({\n          startOnLoad: </span><span style=\"color: rgba(0, 0, 255, 1)\">false</span><span style=\"color: rgba(0, 0, 0, 1)\">,\n          theme: </span>'default'<span style=\"color: rgba(0, 0, 0, 1)\">,\n          securityLevel: </span>'loose'<span style=\"color: rgba(0, 0, 0, 1)\">,</span><span style=\"color: rgba(0, 0, 0, 1)\">\n        })\n        window.mermaid.initialized </span>= <span style=\"color: rgba(0, 0, 255, 1)\">true</span><span style=\"color: rgba(0, 0, 0, 1)\">\n      }\n  \n      let svg\n  \n      </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 检查缓存</span>\n      <span style=\"color: rgba(0, 0, 255, 1)\">if</span><span style=\"color: rgba(0, 0, 0, 1)\">(renderCache.has(hash)) {\n        svg </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> renderCache.get(hash)\n      }</span><span style=\"color: rgba(0, 0, 255, 1)\">else</span><span style=\"color: rgba(0, 0, 0, 1)\"> {\n        const { isValid } </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> await verifyMermaid(code)\n\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">if</span>(!<span style=\"color: rgba(0, 0, 0, 1)\">isValid) {\n          showError(container, `</span>&lt;pre&gt;渲染语法错误：\\n${ code }\\n&lt;/pre&gt;`)\n          <span style=\"color: rgba(0, 0, 255, 1)\">return</span><span style=\"color: rgba(0, 0, 0, 1)\">\n        }\n\n        </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 使用唯一ID渲染(避免图表冲突)</span>\n        const {svg: renderedSvg} = await window.mermaid.render(`mermaid-<span style=\"color: rgba(0, 0, 0, 1)\">${containerId}`, code)\n        svg </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> renderedSvg\n        renderCache.set(hash, svg)\n      }\n\n      </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 更新容器内容</span>\n      container.innerHTML =<span style=\"color: rgba(0, 0, 0, 1)\"> svg\n      container.removeAttribute(</span>'data-mermaid-hash'<span style=\"color: rgba(0, 0, 0, 1)\">)\n      container.removeAttribute(</span>'data-mermaid-code'<span style=\"color: rgba(0, 0, 0, 1)\">)\n\n      </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 触发回调</span>\n      <span style=\"color: rgba(0, 0, 255, 1)\">if</span>(options?<span style=\"color: rgba(0, 0, 0, 1)\">.reachBottom) {\n        options</span>?.onRender?<span style=\"color: rgba(0, 0, 0, 1)\">.()\n      }\n    } </span><span style=\"color: rgba(0, 0, 255, 1)\">catch</span><span style=\"color: rgba(0, 0, 0, 1)\"> (error) {\n      console.error(</span>'Mermaid 渲染失败:'<span style=\"color: rgba(0, 0, 0, 1)\">, error)\n      showError(container, `</span>&lt;pre&gt;渲染图表时出错: \\n ${error.message}\\n&lt;/pre&gt;`)\n<span style=\"color: rgba(0, 0, 0, 1)\">    }\n  }\n}</span></pre>\n</div>\n<p><img alt=\"001360截图20251222193621367\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223103538181-209659643.png\" class=\"lazyload\"></p>\n<p><img alt=\"001360截图20251222193715663\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223103552216-1545436278.png\" class=\"lazyload\"></p>\n<p><img alt=\"002360截图20251222193937688\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223103612440-1597186190.png\" class=\"lazyload\"></p>\n<p><img alt=\"004360截图20251222194733968\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223103703349-1708451451.png\" class=\"lazyload\"></p>\n<p><img alt=\"007360截图20251222201320598\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223103717238-1614729462.png\" class=\"lazyload\"></p>\n<p><img alt=\"005360截图20251222194921868\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223103756064-1584305930.png\" class=\"lazyload\"></p>\n<p><img alt=\"006360截图20251222195419077\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223103816759-904170540.png\" class=\"lazyload\"></p>\n<p><img alt=\"009360截图20251222202431855\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223103852560-1881261749.png\" class=\"lazyload\"></p>\n<p><img alt=\"010360截图20251222203811582\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223103906992-975747501.png\" class=\"lazyload\"></p>\n<p><img alt=\"012360截图20251222204251442\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223103919280-136041562.png\" class=\"lazyload\"></p>\n<p><img alt=\"013360截图20251222204308421\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223104000680-1481731266.png\" class=\"lazyload\"></p>\n<p><img alt=\"014360截图20251222204432469\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223103939973-1523425268.png\" class=\"lazyload\"></p>\n<p>支持运行到pc端以750px宽度显示页面布局。</p>\n<p><img alt=\"015360截图20251222205211925\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223104049841-876451429.png\" class=\"lazyload\"></p>\n<p><img alt=\"015360截图20251222210111883\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223104115293-1216317344.png\" class=\"lazyload\"></p>\n<p><img alt=\"015360截图20251222210330996\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223104139497-1047165356.png\" class=\"lazyload\"></p>\n<p><img alt=\"image\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223104354641-1844699074.png\" class=\"lazyload\"></p>\n<h3>vue3集成deepseek流式打字输出</h3>\n<p><strong>非流式请求输出</strong></p>\n<div class=\"cnblogs_code\">\n<pre>const completion =<span style=\"color: rgba(0, 0, 0, 1)\"> await openai.chat.completions.create({\n  messages: [\n    {role: </span>'user'<span style=\"color: rgba(0, 0, 0, 1)\">, content: editorValue}\n  ],\n  model: </span>'deepseek-chat', <span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> deepseek-chat对话模型 deepseek-reasoner推理模型</span>\n  stream: <span style=\"color: rgba(0, 0, 255, 1)\">false</span>, <span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 流式输出</span>\n  max_tokens: 8192, <span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 限制一次请求中模型生成 completion 的最大 token 数(默认使用 4096)</span>\n  temperature: 0.4, <span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 严谨采样 越低越严谨(默认1)</span>\n<span style=\"color: rgba(0, 0, 0, 1)\">})\n</span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 处理返回数据</span>\nconsole.log(completion.choices[0].message.content)</pre>\n</div>\n<p><strong>流式请求输出</strong></p>\n<p>上下文多轮会话。</p>\n<div class=\"cnblogs_code\">\n<pre>const completion =<span style=\"color: rgba(0, 0, 0, 1)\"> await openai.chat.completions.create({\n  </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 单一会话</span>\n  <span style=\"color: rgba(0, 128, 0, 1)\">/*</span><span style=\"color: rgba(0, 128, 0, 1)\"> messages: [\n    {role: 'user', content: editorValue}\n  ], </span><span style=\"color: rgba(0, 128, 0, 1)\">*/</span>\n  <span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 多轮会话</span>\n  messages: props.multiConversation ? historySession.value : [{role: 'user'<span style=\"color: rgba(0, 0, 0, 1)\">, content: editorValue}],\n  model: </span>'deepseek-chat', <span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> deepseek-chat对话模型 deepseek-reasoner推理模型</span>\n  stream: <span style=\"color: rgba(0, 0, 255, 1)\">true</span>, <span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 流式输出</span>\n  max_tokens: 8192, <span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 限制一次请求中模型生成 completion 的最大 token 数(默认使用 4096)</span>\n  temperature: 0.4, <span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 严谨采样 越低越严谨(默认1)</span>\n})</pre>\n</div>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 处理流式输出</span>\n<span style=\"color: rgba(0, 0, 255, 1)\">for</span><span style=\"color: rgba(0, 0, 0, 1)\"> await (const chunk of completion) {\n  </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 检查是否已终止</span>\n  <span style=\"color: rgba(0, 0, 255, 1)\">if</span>(chatState.aborted) <span style=\"color: rgba(0, 0, 255, 1)\">break</span><span style=\"color: rgba(0, 0, 0, 1)\">\n\n  const content </span>= chunk.choices[0]?.delta?<span style=\"color: rgba(0, 0, 0, 1)\">.content\n  </span><span style=\"color: rgba(0, 0, 255, 1)\">if</span><span style=\"color: rgba(0, 0, 0, 1)\">(content) {\n    streamText </span>+=<span style=\"color: rgba(0, 0, 0, 1)\"> content\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 限制更新频率：每100ms最多更新一次</span>\n    const now =<span style=\"color: rgba(0, 0, 0, 1)\"> Date.now()\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">if</span>(now - lastUpdate &gt; 100<span style=\"color: rgba(0, 0, 0, 1)\">) {\n      lastUpdate </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> now\n      requestAnimationFrame(() </span>=&gt;<span style=\"color: rgba(0, 0, 0, 1)\"> {\n        </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> ...</span>\n<span style=\"color: rgba(0, 0, 0, 1)\">      })\n    }\n  }\n  </span><span style=\"color: rgba(0, 0, 255, 1)\">if</span>(chunk.choices[0]?.finish_reason === 'stop'<span style=\"color: rgba(0, 0, 0, 1)\">) {\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 确保最终内容完整更新</span>\n    ...<span style=\"color: rgba(0, 0, 0, 1)\">\n  }\n}</span></pre>\n</div>\n<p>综上就是vite7.2+vue3对接deepseek实现流式ai对话的一些项目分享，希望对大家有点帮助！</p>\n<p><strong>附上几个最新项目实例</strong></p>\n<blockquote>\n<p><span style=\"font-size: 12px\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaoyan2017/p/18853514\" target=\"_blank\">Uniapp-DeepSeek跨三端AI助手|uniapp+vue3+deepseek-v3流式ai聊天模板</a></span></p>\n<p><span style=\"font-size: 12px\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaoyan2017/p/18795796\" target=\"_blank\">vue3-webseek网页版AI问答|Vite6+DeepSeek+Arco流式ai聊天打字效果</a></span></p>\n<p><span style=\"font-size: 12px\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaoyan2017/p/19313982\" target=\"_blank\">最新版Flutter3.38+Dart3.10仿写抖音APP直播+短视频+聊天应用程序</a></span></p>\n<p><span style=\"font-size: 12px\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaoyan2017/p/19235565\" target=\"_blank\">Tauri2.9+Vue3桌面版OS系统|vite7+tauri2+arcoDesign电脑端os后台模板</a></span></p>\n<p><span style=\"font-size: 12px\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaoyan2017/p/19116145\" target=\"_blank\">electron38-admin桌面端后台|Electron38+Vue3+ElementPlus管理系统</a></span></p>\n<p><span style=\"font-size: 12px\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaoyan2017/p/19088804\" target=\"_blank\">Electron38-Wechat电脑端聊天|vite7+electron38仿微信桌面端聊天系统</a></span></p>\n<p><span style=\"font-size: 12px\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaoyan2017/p/19136187\" target=\"_blank\">Electron38-Vue3OS客户端OS系统|vite7+electron38+arco桌面os后台管理</a></span></p>\n<p><span style=\"font-size: 12px\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaoyan2017/p/19181509\" target=\"_blank\">Tauri2-Vite7Admin客户端管理后台|tauri2.9+vue3+element-plus后台系统</a></span></p>\n<p><span style=\"font-size: 12px\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaoyan2017/p/19157445\" target=\"_blank\">Tauri2.8+Vue3聊天系统|vite7+tauri2+element-plus客户端仿微信聊天程序</a></span></p>\n<p><span style=\"font-size: 12px\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaoyan2017/p/18962574\" target=\"_blank\">最新版uniapp+vue3+uv-ui跨三端短视频+直播+聊天【H5+小程序+App端】</a></span></p>\n<p><span style=\"font-size: 12px\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaoyan2017/p/19031695\" target=\"_blank\">最新版uni-app+vue3+uv-ui跨三端仿微信app聊天应用【h5+小程序+app端】</a></span></p>\n<p><span style=\"font-size: 12px\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaoyan2017/p/19018641\" target=\"_blank\">Flutter3-MacOS桌面OS系统|flutter3.32+window_manager客户端OS模板</a></span></p>\n</blockquote>\n<p><img alt=\"20190422-204556-c922\" width=\"121\" height=\"121\" loading=\"lazy\" data-src=\"https://img2024.cnblogs.com/blog/1289798/202512/1289798-20251223105455421-2130771465.gif\" class=\"lazyload\"></p>\n<p>&nbsp;</p>\n</div>\n<div id=\"MySignature\" role=\"contentinfo\">\n    本文为博主原创文章，未经博主允许不得转载，欢迎大家一起交流 QQ（282310962） wx（xy190310）\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\" data-last-update-days=\"0\" data-date-updated=\"2025-12-23 11:06\">2025-12-23 11:06</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xiaoyan2017\">xiaoyan2017</a>&nbsp;\n阅读(<span id=\"post_view_count\">125</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19385909);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19385909', targetLink: 'https://www.cnblogs.com/xiaoyan2017/p/19385909', title: 'vite7+deepseek流式ai模板|vue3.5+deepseek3.2+markdown打字输出ai助手' })\">举报</a>\n</div>","guid":{"value":"bae9aa4667b7b08dfd6fd88728d55b79"}},{"title":"Lit 的响应式系统为什么这么轻？——从 ReactiveElement 的设计说起","link":"https://www.cnblogs.com/zxlh1529/p/19370810","description":"<h1 class=\"postTitle\">\n                <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zxlh1529/p/19370810\" title=\"发布于 2025-12-23 10:33\">\n    <span role=\"heading\" aria-level=\"2\">Lit 的响应式系统为什么这么轻？——从 ReactiveElement 的设计说起</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\n<p>在使用 Lit 时，很多人都会有一个直观感受：</p>\n<blockquote>\n<p><strong>“它居然没有状态管理系统？”</strong><br>\n<strong>“也没有复杂的依赖收集？”</strong></p>\n</blockquote>\n<p>但实际使用下来却发现：</p>\n<ul>\n<li>状态更新是正确的</li>\n<li>DOM 更新是精准的</li>\n<li>性能非常稳定</li>\n</ul>\n<p>那么问题来了：</p>\n<blockquote>\n<p><strong>Lit 的响应式系统到底是怎么工作的？</strong><br>\n<strong>它为什么可以这么轻？</strong></p>\n</blockquote>\n<p>本文将从 <strong>ReactiveElement 的设计目标、实现方式、与 Vue/React 的根本差异</strong> 三个角度来解释这个问题。</p>\n<hr>\n<h2 id=\"一先说结论important\">一、先说结论（Important）</h2>\n<p>在 Lit 中：</p>\n<blockquote>\n<p><strong>响应式系统的职责不是“计算依赖”，</strong><br>\n<strong>而是“调度更新”</strong></p>\n</blockquote>\n<p>这是理解 Lit 响应式系统的第一把钥匙。</p>\n<hr>\n<h2 id=\"二reactiveelement-在-lit-架构中的位置\">二、ReactiveElement 在 Lit 架构中的位置</h2>\n<p>先回顾 Lit 的继承链：</p>\n<pre><code class=\"language-text\">HTMLElement\n  └── ReactiveElement\n        └── LitElement\n              └── YourComponent\n</code></pre>\n<p>其中：</p>\n<ul>\n<li><strong>ReactiveElement</strong>：负责响应式属性 &amp; 更新调度</li>\n<li><strong>LitElement</strong>：负责生命周期 &amp; render 调用</li>\n<li><strong>lit-html</strong>：负责 DOM 更新</li>\n</ul>\n<blockquote>\n<p>ReactiveElement 不关心 DOM<br>\n它只关心：<strong>什么时候需要更新</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"三lit-的响应式系统到底响应了什么\">三、Lit 的响应式系统到底“响应”了什么？</h2>\n<h3 id=\"31-lit-的响应式单位是属性不是依赖\">3.1 Lit 的响应式单位是「属性」，不是「依赖」</h3>\n<p>在 Vue 中：</p>\n<pre><code class=\"language-ts\">effect(() =&gt; {\n  div.textContent = state.count\n})\n</code></pre>\n<ul>\n<li>响应的是 <strong>依赖关系</strong></li>\n<li>自动追踪 <code>state.count</code></li>\n</ul>\n<p>而在 Lit 中：</p>\n<pre><code class=\"language-ts\">@property()\ncount = 0\n</code></pre>\n<ul>\n<li>响应的是 <strong>属性赋值行为</strong></li>\n<li>不存在依赖收集</li>\n</ul>\n<hr>\n<h3 id=\"32-本质区别\">3.2 本质区别</h3>\n<table>\n<thead>\n<tr>\n<th>框架</th>\n<th>响应式关注点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Vue</td>\n<td>“谁用到了这个值”</td>\n</tr>\n<tr>\n<td>React</td>\n<td>“状态是否发生变化”</td>\n</tr>\n<tr>\n<td>Lit</td>\n<td>“属性是否被 set”</td>\n</tr>\n</tbody>\n</table>\n<p>Lit 的选择非常克制。</p>\n<hr>\n<h2 id=\"四reactiveelement-的核心机制\">四、ReactiveElement 的核心机制</h2>\n<h3 id=\"41-property-做了什么\">4.1 @property 做了什么</h3>\n<pre><code class=\"language-ts\">@property({ type: Number })\ncount = 0\n</code></pre>\n<p>背后本质是：</p>\n<ol>\n<li>把字段变成 getter / setter</li>\n<li>在 setter 中调用 <code>requestUpdate</code></li>\n</ol>\n<hr>\n<h3 id=\"42-伪代码示意\">4.2 伪代码示意</h3>\n<pre><code class=\"language-ts\">set count(value) {\n  const oldValue = this._count\n  this._count = value\n  this.requestUpdate('count', oldValue)\n}\n</code></pre>\n<p>没有 Proxy<br>\n没有依赖收集<br>\n没有 effect</p>\n<hr>\n<h2 id=\"五requestupdatelit-响应式系统的核心\">五、requestUpdate：Lit 响应式系统的核心</h2>\n<h3 id=\"51-requestupdate-并不立即更新\">5.1 requestUpdate 并不立即更新</h3>\n<pre><code class=\"language-ts\">this.requestUpdate()\n</code></pre>\n<p>它做的事情是：</p>\n<ul>\n<li>标记“需要更新”</li>\n<li>把更新放入 <strong>microtask 队列</strong></li>\n<li>合并多次更新</li>\n</ul>\n<hr>\n<h3 id=\"52-批量更新机制\">5.2 批量更新机制</h3>\n<pre><code class=\"language-ts\">this.count = 1\nthis.count = 2\nthis.count = 3\n</code></pre>\n<p>最终只会：</p>\n<pre><code class=\"language-text\">render 一次\n</code></pre>\n<p>这是 Lit 响应式系统<strong>最重要的性能保证</strong>。</p>\n<hr>\n<h3 id=\"53-更新调度流程\">5.3 更新调度流程</h3>\n<pre><code class=\"language-text\">property set\n  ↓\nrequestUpdate\n  ↓\nPromise.resolve().then()\n  ↓\nperformUpdate\n  ↓\nrender()\n</code></pre>\n<hr>\n<h2 id=\"六为什么-lit-不需要依赖收集\">六、为什么 Lit 不需要依赖收集？</h2>\n<p>答案非常关键：</p>\n<blockquote>\n<p><strong>因为 lit-html 已经知道“哪里会变”</strong></p>\n</blockquote>\n<p>在前一篇 Part 更新机制中讲过：</p>\n<ul>\n<li>DOM 更新是由 Part 精确定位的</li>\n<li>render() 每次都会重新执行</li>\n<li>但更新只发生在表达式对应位置</li>\n</ul>\n<p>因此：</p>\n<blockquote>\n<p><strong>Lit 不需要知道“你在模板中用了哪些属性”</strong></p>\n</blockquote>\n<p>它只需要保证：</p>\n<ul>\n<li>属性变化 → render 执行</li>\n<li>render 执行 → Part 精确更新</li>\n</ul>\n<hr>\n<h2 id=\"七shouldupdatelit-给你的唯一判断点\">七、shouldUpdate：Lit 给你的“唯一判断点”</h2>\n<pre><code class=\"language-ts\">shouldUpdate(changedProperties) {\n  return true\n}\n</code></pre>\n<ul>\n<li><code>changedProperties</code> 是一个 Map</li>\n<li>记录了哪些属性发生了变化</li>\n</ul>\n<p>你可以非常明确地控制：</p>\n<pre><code class=\"language-ts\">shouldUpdate(changed) {\n  return changed.has('count')\n}\n</code></pre>\n<p>这比 Vue/React 的依赖优化<strong>更显式、更可控</strong>。</p>\n<hr>\n<h2 id=\"八lit-的生命周期为什么这么少\">八、Lit 的生命周期为什么这么少？</h2>\n<p>Lit 的生命周期几乎完全围绕「更新」展开：</p>\n<pre><code class=\"language-ts\">connectedCallback()\nshouldUpdate()\nwillUpdate()\nrender()\nupdated()\n</code></pre>\n<p>没有：</p>\n<ul>\n<li>computed</li>\n<li>watch</li>\n<li>effect</li>\n<li>memo</li>\n</ul>\n<p>因为：</p>\n<blockquote>\n<p><strong>Lit 不试图管理你的状态<br>\n它只负责把状态变化“反映到 DOM”</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"九和-vue--react-的响应式系统对比\">九、和 Vue / React 的响应式系统对比</h2>\n<h3 id=\"91-架构层面对比\">9.1 架构层面对比</h3>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>Lit</th>\n<th>Vue</th>\n<th>React</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>响应式基础</td>\n<td>getter/setter</td>\n<td>Proxy</td>\n<td>setState</td>\n</tr>\n<tr>\n<td>依赖收集</td>\n<td>❌</td>\n<td>✅</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>更新调度</td>\n<td>microtask</td>\n<td>scheduler</td>\n<td>scheduler</td>\n</tr>\n<tr>\n<td>DOM 更新</td>\n<td>定点 Part</td>\n<td>Diff</td>\n<td>Diff</td>\n</tr>\n<tr>\n<td>系统复杂度</td>\n<td>极低</td>\n<td>高</td>\n<td>中</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"92-为什么-lit-可以这么简单\">9.2 为什么 Lit 可以这么“简单”</h3>\n<p>因为 Lit <strong>放弃了三件事</strong>：</p>\n<ol>\n<li>自动依赖追踪</li>\n<li>状态派生（computed）</li>\n<li>跨组件状态管理</li>\n</ol>\n<p>这些都不是组件底层必须解决的问题。</p>\n<hr>\n<h2 id=\"十lit-响应式系统的适用边界\">十、Lit 响应式系统的适用边界</h2>\n<h3 id=\"101-非常适合的场景\">10.1 非常适合的场景</h3>\n<ul>\n<li>UI 组件</li>\n<li>Design System</li>\n<li>跨框架组件</li>\n<li>微前端子模块</li>\n</ul>\n<hr>\n<h3 id=\"102-不适合的场景\">10.2 不适合的场景</h3>\n<ul>\n<li>大型应用状态管理</li>\n<li>复杂状态派生逻辑</li>\n<li>需要大量 computed / watch 的业务</li>\n</ul>\n<p>Lit 的哲学是：</p>\n<blockquote>\n<p><strong>把“状态复杂度”交给使用者或上层架构</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"十一a-very-important-总结\">十一、A Very Important 总结</h2>\n<blockquote>\n<p><strong>Lit 的响应式系统不是“弱”，<br>\n而是“目标非常明确”</strong></p>\n</blockquote>\n<p>它只做三件事：</p>\n<ol>\n<li>监听属性变化</li>\n<li>合并更新</li>\n<li>触发 render</li>\n</ol>\n<p>而剩下的一切，都交给：</p>\n<ul>\n<li>JavaScript 本身</li>\n<li>浏览器本身</li>\n<li>应用架构本身</li>\n</ul>\n<hr>\n<h2 id=\"十二最后\">十二、最后</h2>\n<p>到现在应该可以已经完整理解了：</p>\n<ol>\n<li>Lit 的整体架构</li>\n<li>为什么不需要 Virtual DOM</li>\n<li>lit-html 的 Part 更新机制</li>\n<li>ReactiveElement 的响应式设计</li>\n</ol>\n<p>如果把这些拼起来，you 会发现：</p>\n<blockquote>\n<p><strong>Lit 是一个“极端相信浏览器”的体系</strong></p>\n</blockquote>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\" data-last-update-days=\"0\" data-date-updated=\"2025-12-23 10:33\">2025-12-23 10:33</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zxlh1529\">幼儿园技术家</a>&nbsp;\n阅读(<span id=\"post_view_count\">72</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19370810);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19370810', targetLink: 'https://www.cnblogs.com/zxlh1529/p/19370810', title: 'Lit 的响应式系统为什么这么轻？——从 ReactiveElement 的设计说起' })\">举报</a>\n</div>","guid":{"value":"adc38fbb8be4193bc15835723afd4b18"}},{"title":"技术管理：产品经理PM和技术开发人员RD之间常见的矛盾有哪些","link":"https://www.cnblogs.com/jiujuan/p/19388306","description":"<h1 class=\"postTitle\">\n                <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/jiujuan/p/19388306\" title=\"发布于 2025-12-23 17:35\">\n    <span role=\"heading\" aria-level=\"2\">技术管理：产品经理PM和技术开发人员RD之间常见的矛盾有哪些</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\n<p>产品经理PM和技术开发人员RD之间常见的矛盾有哪些，及一些解决方法简介。</p>\n<h2 id=\"一需求频繁变更\">一：需求频繁变更</h2>\n<p>在软件产品开发过程中，变更一些需求是无法避免的，但频繁的需求变更，不仅让开发团队疲于应对不断变化的需求，严重影响项目完成的进度，还会影响开发团队人员的士气。</p>\n<p>在前面的<a href=\"https://www.cnblogs.com/jiujuan/p/18794416\" target=\"_blank\">文章</a>中也讨论过一些需求频繁变更的情况和处理的简要方法。</p>\n<p>下面进行需求频繁变更的原因详细分析。</p>\n<ol>\n<li><strong>需求管理混乱</strong></li>\n</ol>\n<p>产品经理对于需求的管理很混乱，没有一个统一的标准，集中管理需求的地方，比如用某一个软件或工具来建立需求池，并分门别类，重要程度等进行分类管理。</p>\n<ol start=\"2\">\n<li><strong>领导、老板想法变了</strong></li>\n</ol>\n<p>领导或老板的想法跳跃，早上看了一个 App 的功能觉得好，下午就让团队加上。或者老板直接干预细节：“这个按钮颜色我不喜欢，改一下”，加塞需求。</p>\n<p>或者，它们突然想到了一个好的想法或功能，要求马上实现。</p>\n<ol start=\"3\">\n<li><strong>市场竞争环境变了</strong></li>\n</ol>\n<p>公司突然发现竞争对手的产品上线了一个杀手级功能，或者改变了补贴策略，我司必须立即跟进，否则会流失大量用户。</p>\n<p>这种需求变更确实是紧急、优先级高的需求。</p>\n<p>还有探索型的项目，需求频繁变更不可避免。需要不断的探索来加深对用户、对市场的认知。有一个认知循环，不断加深的过程。</p>\n<p>这也是精益创业的一个过程。MVP -&gt; 度量 -&gt; 反馈，然后进行优化，然后循环。</p>\n<ol start=\"4\">\n<li><strong>用户反馈与数据验证</strong></li>\n</ol>\n<p>产品功能上线灰度测试后，发现数据惨淡，或者用户反馈极差。原来的假设被推翻，必须立即调整交互或逻辑。</p>\n<p>这种基于数据或用户反馈的需求变更，是有必要的。</p>\n<p>这种在创业公司初期 MVP 验证阶段用的很多，可能一个 APP 的方向要改很多次，才能找到合适的 PMF 。这种情况需求变更是无法避免的。</p>\n<p>其实，这也是敏捷开发的初心。</p>\n<ol start=\"5\">\n<li><strong>PM 考虑需求场景不全</strong></li>\n</ol>\n<p>产品经理在编写需求文档的时候，只考虑了部分场景需求，没有考虑全所有场景的需求。或者只考虑了正常的流程，没有考虑全异常的流程。</p>\n<p>当开发人员编写代码时候，可能会察觉需求文档描述需求不全。 等等这些都会导致需求变更。</p>\n<ol start=\"6\">\n<li><strong>业务或市场加需求</strong></li>\n</ol>\n<p>业务部门或市场部门时不时的加一些需求进来。</p>\n<h3 id=\"解决方法\">解决方法</h3>\n<ul>\n<li>\n<p>用可视化排期看板，让相关方看到需求变更的影响</p>\n</li>\n<li>\n<p>重要的需求变更，需要需求评审委员会评审，评审变更流程</p>\n</li>\n<li>\n<p>建立需求变更影响评估机制（时间 / 风险 / 成本 / 需要牺牲的利益）</p>\n</li>\n<li>\n<p>敏捷开发模式，比如 scrum ，kanban 等开发方法。</p>\n</li>\n<li>\n<p>产品经理多思考一下反流程怎么办，出现异常怎么办。 所有需求要经过产品经理过滤和优化。</p>\n</li>\n</ul>\n<p>可以用 scrum，kanban，精益产品开发方法来解决。</p>\n<h2 id=\"二需求模糊不清晰\">二：需求模糊、不清晰</h2>\n<p>产品经理可能用抽象描述代替具体规则（如“用户体验要流畅”“按钮要显眼”），或未明确边界条件（如“支付失败时的提示语”）。例如：<br>\n需求文档仅写“支持批量导入数据”，但未说明文件格式、大小限制、错误校验规则；</p>\n<p>需求描述不清晰，开发人员就需要反复追问细节，猜测产品经理的意图，最终实现效果可能与预期不符。</p>\n<p>下面进行详细原因分析。</p>\n<ol>\n<li><strong>一句话需求或产品经理没想清楚</strong></li>\n</ol>\n<p>一句话需求，老板、业务部门等等相关部门或人员提的一句话需求，比如 “大概就是这个意思”，“先做出来看看”，“需要一个统计功能” 等话语。</p>\n<p>老板或业务部门把这种一句话的模糊想法当成了开发人员能执行的开发需求。</p>\n<p>从需求到开发，这中间有一些步骤和流程，再怎么省略中间步骤，也要经过产品经理把这样的一句话需求写出一个可供开发执行的开发需求。</p>\n<blockquote>\n<p>用户需求（用户） -&gt; 产品功能需求（产品经理） -&gt; 可执行的开发需求（技术开发）。</p>\n</blockquote>\n<p>对于一个需求，产品经理要考虑：</p>\n<ul>\n<li>用户的本质问题是什么 - 分析本质问题</li>\n<li>产品目标 - 要解决用户什么问题</li>\n<li>实现方案 - 怎么解决</li>\n</ul>\n<ol start=\"2\">\n<li><strong>把用户说的方案或目标当成需求</strong></li>\n</ol>\n<p>最著名的一个例子就是福特造车的例子。在当时的时空环境下，问一个人更好的交通工具时是什么？用户会回答：更快的马车。用户为什么会这样回答？因为当时很多人没见过汽车，但是见过马车。</p>\n<p>“更快的马车”，其实是一个方案。这不是一个需求，如果当成了需求，那么福特就会去造更快的马车而不会造福特汽车。</p>\n<p>那用户的本质需求是什么？</p>\n<p>是从 A 地快速的移动到 B 地。是快速方便的到达目的地。马车只是其中一种交通工具，及是一种满足用户需求的方案。而汽车是一种创新的方案，更好的方案。</p>\n<p>我们要仔细思考用户的本质需求是什么？而不光听用户说。</p>\n<p>没有满足本质需求的好方案，可能会导致方案修改增多。</p>\n<ol start=\"3\">\n<li><strong>边界条件和异常情况未定义</strong></li>\n</ol>\n<p>产品经理只关注了主流程，对于一些异常情况或边界条件，未考虑到。</p>\n<p>产品经理的思维要养成好习惯，要考虑正常的流程，同时也要考虑异常情况的流程。</p>\n<h3 id=\"解决方法-1\">解决方法</h3>\n<ol>\n<li><strong>标准化需求结构或模板</strong></li>\n</ol>\n<p>标准化需求最小结构：1、目标&amp;背景 2、用户场景 3、核心规则 4、边界&amp;异常 5、验收标准</p>\n<ol start=\"2\">\n<li><strong>用户故事梳理需求</strong></li>\n</ol>\n<p>一个完整的用户故事，应该包含三部分内容：用户、功能、价值。</p>\n<ul>\n<li>用户：是谁要用这个功能；</li>\n<li>功能：具体是什么功能；</li>\n<li>价值：通过这个功能，用户能获得什么价值；</li>\n</ul>\n<p>最后用用户故事地图串联起来所有的用户故事。用用户故事地图帮助我们确定目标用户、需求的范围、产品价值和需求优先级。更深刻的理解用户需求。</p>\n<ol start=\"3\">\n<li><strong>用例（Use Case）分析需求</strong></li>\n</ol>\n<p>用例是一种描述需求的方法，用例描述了在不同的条件下，系统对参与者的请求做出的响应。用例通常通过一个参与者（Actor）（谁？）向系统做出请求（要做什么？），系统根据参与者的请求，在不同的条件下，执行某一行为序列（系统怎么满足？）。</p>\n<p>每一个行为序列可以称之为一个场景（Scenario），一个用例包含多个场景。场景也可以称之为用例的一个实例（Instance）。</p>\n<ol start=\"4\">\n<li><strong>需求评审</strong></li>\n</ol>\n<p>需求评审委员会对需求进行评审。</p>\n<p>上面2大类就是对需求的分类和怎么进行需求分析，才能获得用户本质的需求，进而给出好的产品解决方案。</p>\n<h2 id=\"三排期和进度评估分歧\">三：排期和进度评估分歧</h2>\n<p>产品经理和开发人员在排期与进度评估上的分歧是产品开发团队中最常见问题之一。核心原因是双方站的视角、关注的重点和承担的风险完全不同。</p>\n<p>在进行任务排期的时候，产品经理希望产品功能能够快速上线，抢占用户市场，倾向于压缩开发时间。</p>\n<p>而技术开发则是基于实际的开发任务、开发流程有多少个步骤来进行评估，比如技术架构设计、写代码、联调、测试、修复bug、优化代码等步骤。</p>\n<p>举个例子：</p>\n<p>比如产品经理要求 2 周内上线，但是开发评估实际上线时间需要 4 周，因为还开发流程所有步骤，还有其它依赖项。</p>\n<p>下面对各方面原因详细分析：</p>\n<table>\n<thead>\n<tr>\n<th>方面</th>\n<th>PM 的视角与动机</th>\n<th>RD 的视角与动机</th>\n<th>导致的分歧表现</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>目标导向</strong></td>\n<td>商业驱动：尽快上线抢占市场、满足高层期望、响应竞争。</td>\n<td>技术驱动：确保实现质量、可维护性、避免技术债、降低后期维护成本。</td>\n<td>PM 觉得 RD 估时太保守、拖进度；RD 觉得 PM 估时太乐观、不切实际。</td>\n</tr>\n<tr>\n<td><strong>信息不对称</strong></td>\n<td>更了解市场、用户反馈、竞品动态、业务价值，但对底层技术实现细节了解有限。</td>\n<td>更了解技术难度、潜在风险、历史遗留问题、第三方依赖，但对商业紧迫性和市场竞争激烈的感知较弱。</td>\n<td>PM 常低估技术复杂度；RD 常忽略商业压力。</td>\n</tr>\n<tr>\n<td><strong>风险认知</strong></td>\n<td>风险主要在“错过市场窗口”“用户流失”“高层问责”。</td>\n<td>风险主要在“系统崩溃”“技术债爆炸”“上线后加班修复”“被背锅”。</td>\n<td>PM 愿意承担一定技术风险换速度；RD 倾向保守避免过多的风险。</td>\n</tr>\n<tr>\n<td><strong>估时经验</strong></td>\n<td>估时多基于历史类似功能或直觉，容易遗漏边缘案例和技术细节。</td>\n<td>估时基于具体实现路径、代码量、测试覆盖、集成难度，常会预留缓冲（buffer）时间给突发情况。</td>\n<td>PM 给的 deadline 常比 RD 估时短 30%-100%。</td>\n</tr>\n<tr>\n<td><strong>激励机制</strong></td>\n<td>绩效常与“按时上线”“功能交付数量”挂钩。</td>\n<td>绩效常与“bug 率”“代码质量”“系统稳定性”挂钩。</td>\n<td>PM 有动力压缩时间，RD 有动力预留余地。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"解决方法-2\">解决方法</h3>\n<ol>\n<li><strong>三人估时法：PM+RD+TL/架构师共同估时</strong></li>\n</ol>\n<p>PM（产品经理）提供业务背景和需求优先级，RD（技术开发）详细拆解技术需求为更小的开发任务并估时，TL（Team Leader） 或架构师把关各种风险。三人讨论，达成共识后记录为正式估时，任何一方后期不得单方面修改。避免 PM 单方面拍脑袋决定项目 deadline，或 RD 单方面保守估时。</p>\n<ol start=\"2\">\n<li><strong>规划扑克</strong></li>\n</ol>\n<p>详细的扑克牌估时可以看这篇文章：<a href=\"https://www.cnblogs.com/jiujuan/p/18585259\" target=\"_blank\">敏捷开发：用户故事估算估时方法介绍</a></p>\n<ol start=\"3\">\n<li>\n<p><strong>工具与流程层面：用客观方法替代主观判断</strong></p>\n<ul>\n<li>任务拆解到颗粒度足够细：要求每个用户故事拆解到子任务不超过 1-2 人天，避免大任务导致估时偏差巨大。</li>\n<li>预留缓冲时间并显式化：在迭代计划中明确预留 20%-30% 的缓冲时间（Buffer），用于处理未知风险、bug 修复等。缓冲时间由团队共同决定，不计入单个任务估时。</li>\n<li>技术预研任务：对技术不确定性高的需求，先安排 1-3 天的技术预研任务进行技术验证和精准估时，再进入正式开发。大幅降低后期发现做不了或工时翻倍的情况。</li>\n<li>里程碑共同确认：设置功能里程碑（PM 关心）和技术里程碑（RD 关心），如“接口联调完成”“性能测试通过”等，双轨并行确认进度。这里 PM 看到功能进度，RD 看到技术风险被控制。</li>\n</ul>\n</li>\n<li>\n<p><strong>公开透明的进度看板</strong></p>\n<p>使用 Jira、Trello、TAPD 等敏捷或kanban工具实时展示任务状态、阻塞任务、剩余工时，所有人可见。PM 看到真实进度，RD 感受到被信任而非被催促。</p>\n</li>\n<li>\n<p><strong>进度偏差预警机制</strong></p>\n<p>每周的中间时间进行一次进度健康检查，如果某任务偏差 &gt;20%，立即复盘原因并解决，而不是等到迭代最后才暴漏出来，进而爆发冲突。</p>\n</li>\n</ol>\n<h2 id=\"四优先级频繁调整\">四：优先级频繁调整</h2>\n<p>需求开发优先级频繁调整是产品经理与技术开发之间最破坏开发节奏的矛盾点之一。这个矛盾点的本质原因之一是商业环境的不确定性与技术开发需要确定性之间的冲突，加上组织机制不成熟，导致调整成本最后全部转嫁到技术开发上。因为整个产品软件开发到落地，技术开发在最底层。</p>\n<p>下面进行详细原因分析。</p>\n<ol>\n<li><strong>商业环境高度不确定</strong></li>\n</ol>\n<p>根据前面的分析了解到，需求调整，有用户反馈数据和意见、竞争对手的动作、市场变化、高层的意见、监控数据指标波动等各种变化，这些组成了一个商业相关的环境。</p>\n<p>这些变化都会导致需求的变化，为了适应市场和商业环境的变化，会导致前期的需求优先级变化。</p>\n<ol start=\"2\">\n<li><strong>业务目标不稳定或不清晰</strong></li>\n</ol>\n<p>公司的战略不清晰，业务目标不清晰，觉得都是机会，需要频繁的修改需求来探索新机会。</p>\n<p>这个需要高层能给出清晰的战略方向，然后根据这个制定部门的业务方向。</p>\n<p>如果是探索型的项目，那么这个调整是不可避免的。因为产品方向不确定，所有要通过调整产品需求来探索，导致需求修改、优先级调整。</p>\n<ol start=\"3\">\n<li><strong>PM 眼里的调整成本认知偏差</strong></li>\n</ol>\n<p>产品经理的一句话：把这个功能往后放一放。PM 的任务就完成了。但到了技术开发这里，可能涉及代码回滚、分支合并、代码重构、测试用例废弃和重写等等。2 者调整的成本不一样。</p>\n<ol start=\"4\">\n<li><strong>PM 角色被动 不敢拒绝需求</strong></li>\n</ol>\n<p>面对老板、高层、销售等的需求，不敢拒绝不合理的需求，只能被动接受需求。</p>\n<p>这时产品经理能力要加强，不能只是个执行的角色，还需要加强学习，要能分析需求，懂得需求的重要程度，规划需求优先级的能力。</p>\n<h3 id=\"解决方法-3\">解决方法</h3>\n<ol>\n<li><strong>需求缓冲池</strong></li>\n</ol>\n<p>所有新想法、用户反馈、突发需求、老板需求等先进入需求缓冲池，定期（每周或双周）集体评审是否进入当前 Roadmap。避免所有人随时直接插入高优先级需求</p>\n<p>在 scrum 框架中有一个产品需求待办列表，这个就相当于需求缓冲池。这个产品需求待办列表还有需求优先级评估、需求详细说明等，这里存放所有来源的需求。</p>\n<p>Scrum 中的 Product Backlog(产品待办列表) 详细介绍可以看下面这篇文章：</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/jiujuan/p/18559611\" target=\"_blank\">敏捷开发：Scrum 中的 Product Backlog(产品待办列表) 详细介绍</a></li>\n</ul>\n<p>这个待办列表的特点：1、需求优先级排序 2、动态变化，随时更新列表内容 3、需求细节详情 4、透明性 5、工作集-实现产品目标所需完成的所有工作项的集合。</p>\n<ol start=\"2\">\n<li><strong>建立优先级治理机制</strong></li>\n</ol>\n<p>每季度（或每 2-4 周）由 PM + RD Leader + 高层共同评审并锁定 Roadmap，锁定后原则上不允许插入新需求或大幅调整优先级。</p>\n<p>还有敏捷框架 Scrum 开发方法里的 Sprint 计划会议来决定每一个 Sprint 开发周期（2 - 4 周）里的开发任务。</p>\n<p>优先级评估的方法可以看这篇文章： <a href=\"https://www.cnblogs.com/jiujuan/p/18559611\" target=\"_blank\">敏捷开发：Scrum 中的 Product Backlog(产品待办列表) 详细介绍</a></p>\n<ol start=\"3\">\n<li><strong>冻结窗口 + 例外通道</strong></li>\n</ol>\n<p>当前迭代前半段（例如 Sprint 前 60% 时间）不允许调整优先级，后半段只允许修复严重 bug 的调整。真正紧急需求走“例外通道”，需高层批准并补偿（如延长迭代或减少其他功能）。</p>\n<ol start=\"4\">\n<li><strong>留出弹性空间</strong></li>\n</ol>\n<p>每个迭代只规划 70%-80% 容量，剩余 20%-30% 作为弹性容量时间，专门用于处理突发高优先级需求或优先级调整。当真有紧急需求时，有空间容纳，而不打乱既有计划。</p>\n<ol start=\"5\">\n<li><strong>停车位机制</strong></li>\n</ol>\n<p>被暂停的功能统一放进停车位看板，</p>\n<ul>\n<li>记录暂停原因</li>\n<li>已投入工时</li>\n<li>预计恢复时间</li>\n</ul>\n<p>定期复盘是否恢复或彻底下线。避免功能无限期悬而未决，减少 RD 心理负担。</p>\n<ol start=\"6\">\n<li><strong>高层能想清楚公司战略方向</strong></li>\n</ol>\n<p>高层能给出清晰的战略方向，然后根据这个制定部门的业务方向。</p>\n<p>如果是探索型的项目，那么这个调整是不可避免的。</p>\n<h2 id=\"五开发资源冲突\">五：开发资源冲突</h2>\n<p>在一个软件产品开发公司，技术开发人员的数量在一定时间内是恒定的。产品经理可能同时推进多个项目或功能的开发，同时开发多个项目或功能需要更多的开发人员，但是开发人员的人力、时间却是有限的，开发的总产能是一定量的。这就导致了开发资源冲突。</p>\n<p>详细原因分析：</p>\n<p>在公司层面，缺少整体资源规划，高层不断立项新项目，却没有扩充技术开发团队人员数量。产品经理又被高层逼着，觉得哪个项目都很重要。并行项目过多超过了技术团队实际能承受的容量，就要求通过加班来弥补人员不足导致进度慢情况，长时间的话会不仅会拖慢项目进度，还会拖累开发团队的士气。</p>\n<p>在项目型的软件开发公司，销售或业务为了签单，向客户承诺过早的交付时间，而高层为了业绩指标不断接新项目。这样也会导致开发任务过多。</p>\n<p>还有公司的产品经理之间缺乏协调，都认为自己的项目重要，要求给到足够的开发资源。技术开发呢，被多个产品经理拉去干项目，这样导致开发人员任务过多。<br>\n公司层面缺乏项目优先级、重视程度的协调机制。</p>\n<p>一个开发人员同时并行开发多个任务，每天上下文切换，会导致任务生产力下降很多，有的研究显示多任务会导致生产力下降 40%。再加上每天被不同会议打断，专注时间碎片化，效率更低。</p>\n<h3 id=\"解决方法-4\">解决方法</h3>\n<ol>\n<li><strong>在公司层面建立资源规划与治理机制</strong></li>\n</ol>\n<p>每季度由技术负责人（CTO/技术VP）牵头，做一次开发资源容量盘点：统计所有技术开发的可用人天，扣除假期、培训、维护等（通常只算 70%-80% 有效容量），得出全公司总容量。再根据业务目标决定能同时支撑几个项目。超出容量的新项目必须推迟或拒绝</p>\n<ol start=\"2\">\n<li><strong>在公司层面建立项目立项审查委员会</strong></li>\n</ol>\n<p>新项目立项必须经过项目审查会（含 PM、RD Leader、财务、高层），评估所需资源、商业价值、优先级。只有在容量允许的情况下才能批准。</p>\n<ol start=\"3\">\n<li><strong>项目开发透明化和优先级统一</strong></li>\n</ol>\n<p>利用工具或方法，把项目的需求统一进入一个 Backlog，比如 scrum或kanban 的 product backlog 待办列表，优先级由多个人来评估。</p>\n<p>一个技术开发人员在一个迭代周期（2 - 4周）内，只分配一个主要项目，占比约为 ≥70%，少跨多个项目，小任务占比不要超过 ≥20%。</p>\n<ol start=\"4\">\n<li><strong>容量预留机制</strong></li>\n</ol>\n<p>每个团队/个人预留 10%-30% 容量用于：线上问题bug修复、技术债、突发任务。各种隐形任务有了合理时间来完成。</p>\n<ol start=\"5\">\n<li><strong>资源看板与负载预警</strong></li>\n</ol>\n<p>使用 Jira、Trello等工具实时展示每个人负载，设置阈值（如 &gt;100% 红色预警），自动通知领导。</p>\n<p>还有就是加速招聘或培养、外包合作。</p>\n<p>还可以在绩效指标上想办法。</p>\n<h2 id=\"总结\">总结</h2>\n<p>产品经理和技术开发人员，其实都有一个共同的目标，那就是把产品做好，只是各自的分工不同。</p>\n<p>他们之间的关系应是协作伙伴而非对立面，产品经理定义做什么和为什么做，技术开发人员用技术解决怎么做和具体做出来，共同为用户创造价值，为公司业务发展贡献力量。</p>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li>《有效需求分析》作者: 徐锋  <a href=\"https://book.douban.com/subject/26952983/\" target=\"_blank\" rel=\"noopener nofollow\">https://book.douban.com/subject/26952983/</a></li>\n<li>敏捷开发：用户故事估算估时方法介绍 <a href=\"https://www.cnblogs.com/jiujuan/p/18585259\" target=\"_blank\">https://www.cnblogs.com/jiujuan/p/18585259</a></li>\n<li>敏捷开发：Scrum 中的 Product Backlog(产品待办列表) 详细介绍-待办列表管理、用户故事、优先级评估等等 <a href=\"https://www.cnblogs.com/jiujuan/p/18559611\" target=\"_blank\">https://www.cnblogs.com/jiujuan/p/18559611</a></li>\n<li>《精益产品开发手册》<a href=\"https://book.douban.com/subject/36458020/\" target=\"_blank\" rel=\"noopener nofollow\">https://book.douban.com/subject/36458020/</a></li>\n</ul>\n\n</div>\n<div id=\"MySignature\" role=\"contentinfo\">\n    == just do it ==\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\" data-last-update-days=\"0.015277777777777777\" data-date-updated=\"2025-12-23 17:57\">2025-12-23 17:35</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jiujuan\">九卷</a>&nbsp;\n阅读(<span id=\"post_view_count\">25</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19388306);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19388306', targetLink: 'https://www.cnblogs.com/jiujuan/p/19388306', title: '技术管理：产品经理PM和技术开发人员RD之间常见的矛盾有哪些' })\">举报</a>\n</div>","guid":{"value":"5d55360566c0e669469b2b49ea69fd28"}},{"title":"告别“意大利面条”：FastAPI 生产级架构的最佳实践指南","link":"https://www.cnblogs.com/swizard/p/19388173","description":"<h1 class=\"postTitle\">\n                <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/swizard/p/19388173\" title=\"发布于 2025-12-23 17:18\">\n    <span role=\"heading\" aria-level=\"2\">告别“意大利面条”：FastAPI 生产级架构的最佳实践指南</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div id=\"cnblogs_post_body\" class=\"blogpost-body blogpost-body-html\">\n<h2 data-path-to-node=\"4\">1. 引言：由于“太快”而带来的烦恼</h2>\n<p data-path-to-node=\"5\">你是否经历过这样的场景？</p>\n<p data-path-to-node=\"6\">周五下午，你兴致勃勃地用 <code data-path-to-node=\"6\" data-index-in-node=\"13\">pip install fastapi</code> 开启了一个新项目。<code data-path-to-node=\"6\" data-index-in-node=\"42\">main.py</code> 里只有 20 行代码，一切都跑得飞快，你觉得自己像个风一样的男子。</p>\n<p data-path-to-node=\"7\">然而，两周后，情况变了。</p>\n<p data-path-to-node=\"8\">那个曾经清秀的 <code data-path-to-node=\"8\" data-index-in-node=\"8\">main.py</code> 膨胀到了 2000 行。数据库连接、Pydantic 模型、路由逻辑、鉴权代码全部纠缠在一起。你想修改一个用户的 API，结果不小心弄崩了商品的查询功能。此时的你，面对着屏幕上那一坨“意大利面条代码”（Spaghetti Code），只想把它关掉回家睡觉。</p>\n<p data-path-to-node=\"9\"><strong data-path-to-node=\"9\" data-index-in-node=\"0\">FastAPI 的“快”是双刃剑。</strong> 它不强制你遵循特定的结构，但这不代表你不需要结构。今天，我们就来谈谈如何通过<strong data-path-to-node=\"9\" data-index-in-node=\"56\">合理的架构模式</strong>和<strong data-path-to-node=\"9\" data-index-in-node=\"64\">最佳实践</strong>，将你的 FastAPI 项目打造成一座稳固、可扩展的摩天大楼。</p>\n<hr data-path-to-node=\"10\">\n<h2 data-path-to-node=\"11\">2. 概念拆解：如果你是公司的 CEO</h2>\n<p data-path-to-node=\"12\">为了理解为什么我们需要分层架构，我们来打个比方。</p>\n<p data-path-to-node=\"13\">想象你开了一家初创公司（这就是你的 App）。</p>\n<ul data-path-to-node=\"14\">\n<li>\n<p data-path-to-node=\"14,0,0\"><strong data-path-to-node=\"14,0,0\" data-index-in-node=\"0\">初创阶段（单文件模式）</strong>：整个公司只有你一个人。你是 CEO，也是销售，还是保洁阿姨。所有事情你都亲力亲为（所有逻辑都在 <code data-path-to-node=\"14,0,0\" data-index-in-node=\"60\">main.py</code>）。这在创业初期（Demo）没问题，效率极高。</p>\n</li>\n<li>\n<p data-path-to-node=\"14,1,0\"><strong data-path-to-node=\"14,1,0\" data-index-in-node=\"0\">扩张阶段（生产级架构）</strong>：业务做大了，你不能再自己扫地了。你需要组建部门：</p>\n<ul data-path-to-node=\"14,1,1\">\n<li>\n<p data-path-to-node=\"14,1,1,0,0\"><strong data-path-to-node=\"14,1,1,0,0\" data-index-in-node=\"0\">销售部</strong> 专门负责拉客（<code data-path-to-node=\"14,1,1,0,0\" data-index-in-node=\"11\">Routers</code>：处理路由请求）。</p>\n</li>\n<li>\n<p data-path-to-node=\"14,1,1,1,0\"><strong data-path-to-node=\"14,1,1,1,0\" data-index-in-node=\"0\">后勤部</strong> 专门负责物资（<code data-path-to-node=\"14,1,1,1,0\" data-index-in-node=\"11\">Schemas</code>：定义数据格式）。</p>\n</li>\n<li>\n<p data-path-to-node=\"14,1,1,2,0\"><strong data-path-to-node=\"14,1,1,2,0\" data-index-in-node=\"0\">技术部</strong> 专门负责底层设施（<code data-path-to-node=\"14,1,1,2,0\" data-index-in-node=\"13\">Database</code> / <code data-path-to-node=\"14,1,1,2,0\" data-index-in-node=\"24\">CRUD</code>：处理数据库交互）。</p>\n</li>\n<li>\n<p data-path-to-node=\"14,1,1,3,0\"><strong data-path-to-node=\"14,1,1,3,0\" data-index-in-node=\"0\">外包团队</strong> 随叫随到，按需服务（<code data-path-to-node=\"14,1,1,3,0\" data-index-in-node=\"15\">Dependencies</code>：依赖注入）。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p data-path-to-node=\"15\"><strong data-path-to-node=\"15\" data-index-in-node=\"0\">这就是我们今天要讲的核心：关注点分离（Separation of Concerns）。</strong></p>\n<p data-path-to-node=\"16\">FastAPI 提供了两个最强大的武器来实现这一目标：<strong data-path-to-node=\"16\" data-index-in-node=\"27\">APIRouter（部门拆分）</strong> 和 <strong data-path-to-node=\"16\" data-index-in-node=\"45\">Dependency Injection（按需服务）</strong>。</p>\n<hr data-path-to-node=\"17\">\n<h2 data-path-to-node=\"18\">3. 动手实战：重构你的 <code data-path-to-node=\"18\" data-index-in-node=\"13\">main.py</code></h2>\n<p data-path-to-node=\"19\">我们要做的第一件事，就是肢解那个臃肿的 <code data-path-to-node=\"19\" data-index-in-node=\"20\">main.py</code>。</p>\n<h3 data-path-to-node=\"20\">3.1 理想的文件结构</h3>\n<p data-path-to-node=\"21\">不要把鸡蛋放在一个篮子里。一个标准的生产级目录结构应该长这样：</p>\n<div class=\"code-block ng-tns-c3098535048-82 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\" data-hveid=\"0\" data-ved=\"0CAAQhtANahgKEwivp_eBq9ORAxUAAAAAHQAAAAAQgQE\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-82 ng-star-inserted\"><span class=\"ng-tns-c3098535048-82\">Plaintext</span>\n<div class=\"buttons ng-tns-c3098535048-82 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-82\">\n<div class=\"animated-opacity ng-tns-c3098535048-82\">\n<pre class=\"ng-tns-c3098535048-82 highlighter-hljs\"><code>/app\n    /routers      # 销售部：处理路径和请求\n        users.py\n        items.py\n    /schemas      # 后勤部：Pydantic 模型（数据契约）\n        user.py\n        item.py\n    /crud         # 技术部：数据库操作逻辑\n        user.py\n    /core         # 核心配置\n        config.py\n    main.py       # CEO：统筹全局</code></pre>\n</div>\n</div>\n</div>\n<h3 data-path-to-node=\"23\">3.2 路由拆分（APIRouter）</h3>\n<p data-path-to-node=\"24\">假设我们要把用户相关的逻辑拆出去。</p>\n<p data-path-to-node=\"25\"><strong data-path-to-node=\"25\" data-index-in-node=\"0\">第一步：创建分部（app/routers/users.py）</strong></p>\n<div class=\"code-block ng-tns-c3098535048-83 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\" data-hveid=\"0\" data-ved=\"0CAAQhtANahgKEwivp_eBq9ORAxUAAAAAHQAAAAAQggE\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-83 ng-star-inserted\"><span class=\"ng-tns-c3098535048-83\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-83 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-83\">\n<div class=\"animated-opacity ng-tns-c3098535048-83\">\n<pre class=\"ng-tns-c3098535048-83 highlighter-hljs\"><code>from fastapi import APIRouter\n\n# 这里的 prefix=\"/users\" 意味着所有在这个路由下的路径都会自动加上 /users 前缀\n# tags=[\"users\"] 用于在 Swagger UI 文档中分组\nrouter = APIRouter(prefix=\"/users\", tags=[\"users\"])\n\n@router.get(\"/\")\nasync def read_users():\n    return [{\"username\": \"Rick\"}, {\"username\": \"Morty\"}]\n\n@router.get(\"/me\")\nasync def read_user_me():\n    return {\"username\": \"fakecurrentuser\"}</code></pre>\n</div>\n</div>\n</div>\n<p data-path-to-node=\"27\"><strong data-path-to-node=\"27\" data-index-in-node=\"0\">第二步：总部汇报（app/main.py）</strong></p>\n<p data-path-to-node=\"28\">CEO 需要知道有哪些部门存在。</p>\n<div class=\"code-block ng-tns-c3098535048-84 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\" data-hveid=\"0\" data-ved=\"0CAAQhtANahgKEwivp_eBq9ORAxUAAAAAHQAAAAAQgwE\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-84 ng-star-inserted\"><span class=\"ng-tns-c3098535048-84\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-84 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-84\">\n<div class=\"animated-opacity ng-tns-c3098535048-84\">\n<pre class=\"ng-tns-c3098535048-84 highlighter-hljs\"><code>from fastapi import FastAPI\nfrom app.routers import users, items # 假设你也有 items\n\napp = FastAPI()\n\n# 将分部的路由注册到主应用中\napp.include_router(users.router)\n# app.include_router(items.router) \n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello World\"}</code></pre>\n</div>\n</div>\n</div>\n<p data-path-to-node=\"30\"><strong data-path-to-node=\"30\" data-index-in-node=\"0\">代码解析：</strong></p>\n<ul data-path-to-node=\"31\">\n<li>\n<p data-path-to-node=\"31,0,0\"><code data-path-to-node=\"31,0,0\" data-index-in-node=\"0\">APIRouter</code> 就像是一个微型的 <code data-path-to-node=\"31,0,0\" data-index-in-node=\"19\">FastAPI</code> 实例。</p>\n</li>\n<li>\n<p data-path-to-node=\"31,1,0\"><code data-path-to-node=\"31,1,0\" data-index-in-node=\"0\">app.include_router</code> 就像是插线板，把各个模块的插头插到主电源上。</p>\n</li>\n<li>\n<p data-path-to-node=\"31,2,0\"><strong data-path-to-node=\"31,2,0\" data-index-in-node=\"0\">为什么这么做？</strong> 你的 <code data-path-to-node=\"31,2,0\" data-index-in-node=\"11\">main.py</code> 再次变回了清爽的状态，而且多人协作时，你写 <code data-path-to-node=\"31,2,0\" data-index-in-node=\"41\">users</code>，我写 <code data-path-to-node=\"31,2,0\" data-index-in-node=\"50\">items</code>，互不冲突。</p>\n</li>\n</ul>\n<hr data-path-to-node=\"32\">\n<h2 data-path-to-node=\"33\">4. 进阶深潜：三个你必须遵守的“军规”</h2>\n<p data-path-to-node=\"34\">仅仅拆分文件还不够，这里有三个区分“新手”和“老鸟”的关键细节。</p>\n<h3 data-path-to-node=\"35\">军规一：输入与输出模型分离 (DTO Pattern)</h3>\n<p data-path-to-node=\"36\">很多新手会直接把数据库模型（ORM Model）返回给前端，这是<strong data-path-to-node=\"36\" data-index-in-node=\"32\">大忌</strong>！这会导致你把用户的密码哈希值也一并泄露出去。</p>\n<p data-path-to-node=\"37\"><strong data-path-to-node=\"37\" data-index-in-node=\"0\">最佳实践</strong>：使用不同的 Pydantic 模型分别对应“请求”和“响应”。</p>\n<div class=\"code-block ng-tns-c3098535048-85 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\" data-hveid=\"0\" data-ved=\"0CAAQhtANahgKEwivp_eBq9ORAxUAAAAAHQAAAAAQhAE\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-85 ng-star-inserted\"><span class=\"ng-tns-c3098535048-85\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-85 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-85\">\n<div class=\"animated-opacity ng-tns-c3098535048-85\">\n<pre class=\"ng-tns-c3098535048-85 highlighter-hljs\"><code># app/schemas/user.py\nfrom pydantic import BaseModel, EmailStr\n\n# 1. 用户注册时填写的（包含密码）\nclass UserCreate(BaseModel):\n    username: str\n    password: str \n    email: EmailStr\n\n# 2. 返回给前端展示的（绝对不能包含密码！）\nclass UserResponse(BaseModel):\n    id: int\n    username: str\n    email: EmailStr\n\n    class Config:\n        from_attributes = True # 允许从 ORM 模型读取数据</code></pre>\n</div>\n</div>\n</div>\n<p data-path-to-node=\"39\">在路由中使用：</p>\n<div class=\"code-block ng-tns-c3098535048-86 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\" data-hveid=\"0\" data-ved=\"0CAAQhtANahgKEwivp_eBq9ORAxUAAAAAHQAAAAAQhQE\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-86 ng-star-inserted\"><span class=\"ng-tns-c3098535048-86\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-86 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-86\">\n<div class=\"animated-opacity ng-tns-c3098535048-86\">\n<pre class=\"ng-tns-c3098535048-86 highlighter-hljs\"><code>@router.post(\"/\", response_model=UserResponse) # 明确告诉 FastAPI 使用哪个模型过滤返回值\nasync def create_user(user: UserCreate):\n    # 这里处理创建逻辑...\n    # return db_user_object \n    # FastAPI 会自动根据 UserResponse 过滤掉 db_user_object 中的 password 字段\n    pass</code></pre>\n</div>\n</div>\n</div>\n<h3 data-path-to-node=\"41\">军规二：依赖注入是你的救命稻草 (Dependency Injection)</h3>\n<p data-path-to-node=\"42\">不要在全局范围内初始化数据库连接或复杂的逻辑对象。使用 <code data-path-to-node=\"42\" data-index-in-node=\"28\">Depends</code>。</p>\n<p data-path-to-node=\"43\"><strong data-path-to-node=\"43\" data-index-in-node=\"0\">错误示范（全局变量）：</strong></p>\n<div class=\"code-block ng-tns-c3098535048-87 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\" data-hveid=\"0\" data-ved=\"0CAAQhtANahgKEwivp_eBq9ORAxUAAAAAHQAAAAAQhgE\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-87 ng-star-inserted\"><span class=\"ng-tns-c3098535048-87\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-87 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-87\">\n<div class=\"animated-opacity ng-tns-c3098535048-87\">\n<pre class=\"ng-tns-c3098535048-87 highlighter-hljs\"><code>db = SessionLocal() # 危险！连接可能断开，或者在并发时混乱\n\n@app.get(\"/users\")\ndef get_users():\n    return db.query(User).all()</code></pre>\n</div>\n</div>\n</div>\n<p data-path-to-node=\"45\"><strong data-path-to-node=\"45\" data-index-in-node=\"0\">正确示范（依赖注入）：</strong></p>\n<div class=\"code-block ng-tns-c3098535048-88 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\" data-hveid=\"0\" data-ved=\"0CAAQhtANahgKEwivp_eBq9ORAxUAAAAAHQAAAAAQhwE\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-88 ng-star-inserted\"><span class=\"ng-tns-c3098535048-88\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-88 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-88\">\n<div class=\"animated-opacity ng-tns-c3098535048-88\">\n<pre class=\"ng-tns-c3098535048-88 highlighter-hljs\"><code># app/dependencies.py\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close() # 确保请求结束后关闭连接\n\n# 在路由中使用\nfrom fastapi import Depends\nfrom sqlalchemy.orm import Session\n\n@router.get(\"/users\")\ndef get_users(db: Session = Depends(get_db)): # 只有在这个请求进来时，才会创建连接\n    return crud.get_users(db)</code></pre>\n</div>\n</div>\n</div>\n<p data-path-to-node=\"47\"><strong data-path-to-node=\"47\" data-index-in-node=\"0\">为什么？</strong></p>\n<ol start=\"1\" data-path-to-node=\"48\">\n<li>\n<p data-path-to-node=\"48,0,0\"><strong data-path-to-node=\"48,0,0\" data-index-in-node=\"0\">安全性</strong>：<code data-path-to-node=\"48,0,0\" data-index-in-node=\"4\">finally</code> 块确保了即使发生错误，数据库连接也能正确关闭。</p>\n</li>\n<li>\n<p data-path-to-node=\"48,1,0\"><strong data-path-to-node=\"48,1,0\" data-index-in-node=\"0\">可测试性</strong>：写单元测试时，你可以轻松地用 <code data-path-to-node=\"48,1,0\" data-index-in-node=\"20\">app.dependency_overrides</code> 把真实的数据库替换成 Mock 对象，而不需要去 hack 全局变量。</p>\n</li>\n</ol>\n<h3 data-path-to-node=\"49\">军规三：配置管理不要硬编码</h3>\n<p data-path-to-node=\"50\">不要把 <code data-path-to-node=\"50\" data-index-in-node=\"4\">SECRET_KEY</code> 或数据库 URL 写死在代码里。使用 <code data-path-to-node=\"50\" data-index-in-node=\"34\">pydantic-settings</code> 读取环境变量。</p>\n<div class=\"code-block ng-tns-c3098535048-89 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\" data-hveid=\"0\" data-ved=\"0CAAQhtANahgKEwivp_eBq9ORAxUAAAAAHQAAAAAQiAE\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-89 ng-star-inserted\"><span class=\"ng-tns-c3098535048-89\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-89 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-89\">\n<div class=\"animated-opacity ng-tns-c3098535048-89\">\n<pre class=\"ng-tns-c3098535048-89 highlighter-hljs\"><code># app/core/config.py\nfrom pydantic_settings import BaseSettings\n\nclass Settings(BaseSettings):\n    database_url: str\n    secret_key: str\n    debug: bool = False\n\n    class Config:\n        env_file = \".env\"\n\nsettings = Settings()</code></pre>\n</div>\n</div>\n</div>\n<p data-path-to-node=\"52\">这样，你的代码在开发环境、测试环境和生产环境之间切换时，只需要更换 <code data-path-to-node=\"52\" data-index-in-node=\"34\">.env</code> 文件，而不需要改动任何一行代码。</p>\n<hr data-path-to-node=\"53\">\n<h2 data-path-to-node=\"54\">5. 总结与延伸</h2>\n<h3 data-path-to-node=\"55\">总结</h3>\n<p data-path-to-node=\"56\">FastAPI 的最佳实践核心在于**“秩序”**：</p>\n<ol start=\"1\" data-path-to-node=\"57\">\n<li>\n<p data-path-to-node=\"57,0,0\">使用 <strong data-path-to-node=\"57,0,0\" data-index-in-node=\"3\">APIRouter</strong> 拆分业务逻辑，别让 <code data-path-to-node=\"57,0,0\" data-index-in-node=\"23\">main.py</code> 成为垃圾场。</p>\n</li>\n<li>\n<p data-path-to-node=\"57,1,0\">严格区分 <strong data-path-to-node=\"57,1,0\" data-index-in-node=\"5\">Pydantic Schemas</strong>（输入/输出）和 <strong data-path-to-node=\"57,1,0\" data-index-in-node=\"30\">ORM Models</strong>（数据库），保护数据安全。</p>\n</li>\n<li>\n<p data-path-to-node=\"57,2,0\">利用 <strong data-path-to-node=\"57,2,0\" data-index-in-node=\"3\">Dependency Injection</strong> 管理数据库会话和共享逻辑，提升可测试性。</p>\n</li>\n</ol>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\" data-last-update-days=\"0\" data-date-updated=\"2025-12-23 17:19\">2025-12-23 17:18</span>&nbsp;\n<a href=\"https://www.cnblogs.com/swizard\">Swizard</a>&nbsp;\n阅读(<span id=\"post_view_count\">48</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19388173);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19388173', targetLink: 'https://www.cnblogs.com/swizard/p/19388173', title: '告别“意大利面条”：FastAPI 生产级架构的最佳实践指南' })\">举报</a>\n</div>","guid":{"value":"3439f999b23080923284def43195200a"}},{"title":"糟糕，我实现的k8s informer好像是依托答辩","link":"https://www.cnblogs.com/JulianHuang/p/19388140","description":"<h1 class=\"postTitle\">\n                <a id=\"cb_post_title_url\" class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/JulianHuang/p/19388140\" title=\"发布于 2025-12-23 17:12\">\n    <span role=\"heading\" aria-level=\"2\">🚀糟糕，我实现的k8s informer好像是依托答辩</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\n<p>💡 糟糕，k8s informer我好像拉一坨大的</p>\n<p>近段时间在做云原生AI算力平台，之前提到使用k8s informer机制管控多渠道提交的训练任务。</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/587720/202512/587720-20251223171050915-2063071702.png\" alt=\"image\" loading=\"lazy\"></p>\n<p>上面第4点：</p>\n<p>informer会监听通过cli和网页portal提交的job， 回显到portal平台，并在job发生状态变更时通知用户。</p>\n<h2 id=\"1-informer是实现声明式controller设计的核心\">1. informer是实现声明式controller设计的核心</h2>\n<p>k8s采用声明式设计， 以结果为导向， 实现这一关键能力的组件是k8s各种controller：</p>\n<p>定义某对象的期望状态，实时监控并达成这个状态（调谐Reconcile） 就是控制器做的事情， No signal was sent. No webhook fired。</p>\n<p>informer是k8s client-go库的一部分：</p>\n<ul>\n<li>① 监听资源</li>\n<li>② 并本地缓存</li>\n<li>③ 通知上层应用发生了一些事件（job创建、job pending、job运行、job完成/失败）</li>\n</ul>\n<p>减少了apiserver的调用流量、优化性能、反应式自动化运维  （我当前的需求有点类似于反应式自动化运维😄）。</p>\n<h2 id=\"2-informer核心使用流程\">2. informer核心使用流程</h2>\n<p>运行一个完整的informer： list ---&gt; watch ---&gt; cache---&gt; react。</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/587720/202512/587720-20251223171110014-1231938720.png\" alt=\"image\" loading=\"lazy\"></p>\n<p>① 从apiserver拉取指定的gvr资源, 形成首次资源快照</p>\n<p>② 持续监听资源的变更事件进deltaFIFO队列，这里是通过HTTP/1.1 的<code>Chunked Transfer Encoding</code>（分块传输编码）来实现的</p>\n<p>③ 通过上述①②两步得到资源的最新状态并缓存，注意，缓存的是资源对象，而不是资源变更事件， 另外是线程安全的存储。</p>\n<p>④ 事件处理，应用在业务层面的动作，可以写日志，可以做controller的Reconcile动作。</p>\n<p>开发者主要考量在<code>react（EventHandler）</code>阶段，其余能力client-go sdk会提供。</p>\n<p>apiserver--&gt;reflector(拉取/监听)--&gt;DeltaFiFO(队列)--&gt; Process（处理）--&gt;Handler（用户代码）</p>\n<h3 id=\"21-watch机制-chunked-transfer-encoding\">2.1 Watch机制： chunked transfer encoding</h3>\n<p>分块传输能力是http1.1 常见功能，不需要像websocket那样升级协议到帧格式，http连接中每个事件是独立的，直到连接关闭。</p>\n<p>请求spiserver时查询参数加上<code>watch=true</code>, 会提示服务器本次是监听请求<br>\n响应核心特征是响应头包含<code>Transfer-Encoding: chunked</code></p>\n<p>验证</p>\n<pre><code>终端1：kubectl proxy --port=8081  ： 在主机上8081端口代理aiserver服务\n\n终端2： curl \"http://localhost:8081/api/v1/namespaces/team-a/pods?watch=true\"  --verbose\n</code></pre>\n<p><img src=\"https://img2024.cnblogs.com/blog/587720/202512/587720-20251223171121777-240153264.png\" alt=\"image\" loading=\"lazy\"></p>\n<p>在client-go sdk中会为informer watch建立稳定的长连接（断线重连、重试等）</p>\n<h2 id=\"3-一个常规的informer实践\">3. 一个常规的informer实践</h2>\n<p>利用kubeconfig创建informer（绑定gvr）， 启动informer（带终止信道）</p>\n<pre><code>package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\tv1 \"k8s.io/api/core/v1\"\n\t\"k8s.io/apimachinery/pkg/fields\"\n\t\"k8s.io/client-go/kubernetes\"\n\t\"k8s.io/client-go/tools/cache\"\n\t\"k8s.io/client-go/tools/clientcmd\"\n)\n\nfunc main() {\n\tconfig, _ := clientcmd.BuildConfigFromFlags(\"\", \"/home/user/.kube/config\")\n\tclientset, _ := kubernetes.NewForConfig(config)\n\n\tpodInformer := cache.NewSharedIndexInformer(\n\t\tcache.NewListWatchFromClient(\n\t\t\tclientset.CoreV1().RESTClient(),\n\t\t\t\"pods\",\n\t\t\tv1.NamespaceAll,\n\t\t\tfields.Everything(),\n\t\t),\n\t\t&amp;v1.Pod{},\n\t\ttime.Minute*10, // resync 周期\n\t\tcache.Indexers{ // cache上的快速过滤器\n\t\t\t\"byNode\": func(obj interface{}) ([]string, error) {\n\t\t\t\tpod := obj.(*v1.Pod)\n\t\t\t\treturn []string{pod.Spec.NodeName}, nil\n\t\t\t}},\n\t)\n\n\tpodInformer.AddEventHandler(cache.ResourceEventHandlerFuncs{\n\t\tDeleteFunc: func(obj interface{}) {\n\t\t\tpod := obj.(*v1.Pod)\n\t\t\tfmt.Printf(\"[DELETED] Pod: %s/%s\\n\", pod.Namespace, pod.Name)\n\t\t},\n\t})\n\n\t// 启动 informer (必须在独立goroutine中，因为Run方法是同步方法)\n\tstopCh := make(chan struct{})\n\tdefer close(stopCh)\n\tgo func() {\n\t\tfmt.Println(\"Starting PodInformer...\")\n\t\tpodInformer.Run(stopCh) // 同步方法，会阻塞直到 stopCh 关闭\n\t\tfmt.Println(\"PodInformer stopped\")\n\t}()\n\n\t//  等待缓存同步就绪\n\tif !cache.WaitForCacheSync(stopCh, podInformer.HasSynced) {\n\t\tpanic(\"failed to wait for cache sync\")\n\t}\n\t&lt;-stopCh\n}\n</code></pre>\n<ul>\n<li>\n<p>informer有<code>resync</code>机制： 周期性重放数据，目的是为业务提供补偿机会，上面设置了10分钟重放周期, =0或者不设置则不重放。</p>\n</li>\n<li>\n<p>使用<code>cache.NewListWatchFromClient</code>设置了informer的<code>local cache</code>， 开发者可以直接把<code>local cache</code>当成监听对象的集合,client-go会确保local cache正确反映当前的资源对象。</p>\n</li>\n<li>\n<p><code>informer.Run(stopCh)</code> 是一个同步的函数，持续执行list-watch-cache-react这个引擎， 在应用层面需要以子goroutine形式，client-go另有informer工厂，informerFactory.Start(stopCh) 内部也是启协程，这里也要认识到信道stopCh在golang中的通信作用。</p>\n</li>\n</ul>\n<blockquote>\n<p>为加快这个informer cache访问速度，还可以给这个cache加上索引器<code>Indexers</code>, 后面可直接使用索引器访问cache。</p>\n</blockquote>\n<h3 id=\"31-拉了一坨大的\">3.1 拉了一坨大的</h3>\n<p>如果把业务需求都做在EventHandler里面，长此以往会拉一坨大的。</p>\n<p>首先这是一个<strong>事件队列消费模型</strong>，Add/Update/Delete变更事件是从一个叫<code>deltaFIFO</code>队列中pop出来的， 既然是队列模型，那么队列消费的高可用、高性能、可扩展问题就避免不了：</p>\n<ul>\n<li>\n<p>事件需要同步挨个处理，否则控制器侧拿到的最终资源状态可能不对，那么这种挨个处理也就谈不上高性能。</p>\n</li>\n<li>\n<p>但是应用又是多实例部署， 多个informer都走同样的list-watch-cache-react流程， 客观上围绕informer deltaFIIO又形成多生产者=&gt;多消费者模型，这种局面EventHandler就要考量幂等和资源一致性问题。</p>\n</li>\n<li>\n<p>队列常规的高可用考量：① 消费者宕机时事件丢失  ② 消费失败如何重试（重试又有幂等性问题）</p>\n</li>\n<li>\n<p>informer有<code>resync</code>机制：会对<code>local cache</code>中的资源构造<code>onUpdate事件</code>，也会走EventHandler, 所以EventHandler做的很重，会很麻烦。</p>\n</li>\n</ul>\n<p>如果业务逻辑很重或者强依赖重试，推荐上<code>[workQueue](https://pkg.go.dev/k8s.io/client-go@v0.35.0/util/workqueue \"workQueue\")</code>, 支持以下功能：</p>\n<ul>\n<li>\n<p>公平：按添加顺序处理元素</p>\n</li>\n<li>\n<p>元素去重：单个item不会被并发消费多次；如果一个item在消费前被多次添加，它只会被消费一次</p>\n</li>\n<li>\n<p>多个消费者和生产者， 支持消费时重排</p>\n</li>\n<li>\n<p>关闭通知</p>\n</li>\n</ul>\n<h2 id=\"4-controller调谐设计\">4. <a href=\"https://medium.com/@dhruvbhl/informers-listers-workqueues-the-brain-behind-your-controller-f5b0967026de\" title=\"controller调谐设计\" target=\"_blank\" rel=\"noopener nofollow\">controller调谐设计</a></h2>\n<p>学习controller的设计：除了informer，还提供了额外的工具，帮助开发者高效感知最新的资源，执行调谐工作。</p>\n<table>\n<thead>\n<tr>\n<th>package</th>\n<th>role</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>informer</td>\n<td>Eyes(watch and cache them)</td>\n</tr>\n<tr>\n<td>lister</td>\n<td>Memory(read from lcoal cache)</td>\n</tr>\n<tr>\n<td>workQueue</td>\n<td>task list (reconcile work)</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"https://img2024.cnblogs.com/blog/587720/202512/587720-20251223171139498-1459677859.png\" alt=\"image\" loading=\"lazy\"></p>\n<pre><code>type PodController struct {\n\tclientset kubernetes.Interface\n\tqueue     workqueue.TypedRateLimitingInterface[string]\n\tinformer  cache.SharedIndexInformer\n\tindexer   cache.Indexer\n}\n\nfunc NewPodController(clientset kubernetes.Interface) *PodController {\n\t// 创建 Pod informer\n\tpodInformer := cache.NewSharedIndexInformer(\n\t\tcache.NewListWatchFromClient(\n\t\t\tclientset.CoreV1().RESTClient(),\n\t\t\t\"pods\",\n\t\t\tv1.NamespaceAll,\n\t\t\tfields.Everything(),\n\t\t),\n\t\t&amp;v1.Pod{},\n\t\ttime.Minute*10, // resync 周期\n\t\tcache.Indexers{\n\t\t\t\"byNode\": func(obj interface{}) ([]string, error) {\n\t\t\t\tpod := obj.(*v1.Pod)\n\t\t\t\treturn []string{pod.Spec.NodeName}, nil\n\t\t\t}},\n\t)\n\n\t// 创建控制器\n\tcontroller := &amp;PodController{\n\t\tclientset: clientset,\n\t\tqueue: workqueue.NewTypedRateLimitingQueue(\n\t\t\tworkqueue.DefaultTypedControllerRateLimiter[string]( \"string\"),\n\t\t),\n\t\tinformer: podInformer,\n\t\tindexer:  podInformer.GetIndexer(),\n\t}\n\n\t// 注册事件处理器\n\tpodInformer.AddEventHandler(cache.ResourceEventHandlerFuncs{\n\t\tAddFunc:    controller.handleAdd,\n\t\tUpdateFunc: controller.handleUpdate,\n\t\tDeleteFunc: controller.handleDelete,\n\t})\n\n\treturn controller\n}\n</code></pre>\n<h3 id=\"--informers-the-eyes-on-the-cluster\">①  Informers: The Eyes on the Cluster</h3>\n<p>informer是一个管道，当发生变化时，该informer管道可确保：</p>\n<ul>\n<li>本地缓存local cache已更新</li>\n<li>任何已注册的事件处理程序(add/update/delete)都会收到通知</li>\n</ul>\n<p>informer不会直接调用控制器的Reconcile方法，事件处理程序的唯一工作是将<code>key (namespace/name)</code>入队（workQueue）</p>\n<blockquote>\n<p>为什么使用key？<br>\n资源对象变化很快→键更稳定→更适合数据去重。</p>\n</blockquote>\n<pre><code>func (c *PodController) handleAdd(obj interface{}) {\n\tkey, err := cache.MetaNamespaceKeyFunc(obj)\n\tif err != nil {\n\t\tklog.Errorf(\"Couldn't get key for object %+v: %v\", obj, err)\n\t\treturn\n\t}\n\tc.queue.Add(key)\n}\n</code></pre>\n<h3 id=\"-key一旦入队就由workqueue接管\">② key一旦入队，就由workQueue接管</h3>\n<ul>\n<li>去重</li>\n<li>重试、出队消费失败重排： 队列行为增强系统可用性</li>\n<li>限速： 弹性设计，增强可用性和效率</li>\n</ul>\n<h3 id=\"-lister其实就是indexers索引器\">③ lister：其实就是Indexers索引器</h3>\n<p>使用lister从local cache 读取最新的资源状态（不需要从api server读取），</p>\n<p>最终执行控制器的<code>Reconcile</code>逻辑。</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/587720/202512/587720-20251223171158516-1068437746.png\" alt=\"image\" loading=\"lazy\"></p>\n<p>通过<code>workQueue</code>将架构从基于资源事件的队列转换为基于资源的队列 。</p>\n<p>注意：这个时候的workQueue有事件压缩的效果： 在被消费之前，如果该资源有多个变更事件，只会保留首次入队（更新时间戳）。</p>\n<p>这非常适合控制器的声明式设计：Controller不关心对象如何到达当前状态，只关心当前状态是否与期望状态一致，并采取行动使其一致。</p>\n<pre><code>func (c *PodController) Run(workers int, stopCh &lt;-chan struct{}) {\n\tdefer c.queue.ShutDown()\n\n\tklog.Info(\"Starting Pod controller\")\n\n\tgo c.informer.Run(stopCh)\n\n\tif !cache.WaitForCacheSync(stopCh, c.informer.HasSynced) {\n\t\tklog.Error(\"Timed out waiting for caches to sync\")\n\t\treturn\n\t}\n\n\tfor i := 0; i &lt; workers; i++ {\n\t\tgo wait.Until(c.runWorker, time.Second, stopCh)\n\t}\n\n\t&lt;-stopCh\n\tklog.Info(\"Stopping Pod controller\")\n}\n\nfunc (c *PodController) runWorker() {\n\tfor c.processNextWorkItem() {\n\t}\n}\n\nfunc (c *PodController) processNextWorkItem() bool {\n\tkey, quit := c.queue.Get()\n\tif quit {\n\t\treturn false\n\t}\n\n\tdefer c.queue.Done(key)\n\n\terr := c.syncPod(key)\n\tif err != nil {\n\t\tklog.Errorf(\"Error syncing pod %s: %v\", key, err)\n\t\tc.queue.AddRateLimited(key)\n\t\treturn true\n\t}\n\n\tc.queue.Forget(key)\n\treturn true\n}\n\nfunc main() {\n\t// 创建 clientset\n\t// config, _ := rest.InClusterConfig()\n\n\thomepath := homedir.HomeDir()\n\tkubeconfig := filepath.Join(homepath, \".kube\", \"config\")\n\tconfig, err := clientcmd.BuildConfigFromFlags(\"\", kubeconfig) // 集群外认证访问 apiserver\n\tif err != nil {\n\t\tklog.Errorf(\"Error building kubeconfig: %v\", err)\n\t}\n\tclientset, _ := kubernetes.NewForConfig(config)\n\n\tcontroller := NewPodController(clientset)\n\tstopCh := make(chan struct{})\n\tcontroller.Run(3, stopCh)\n}\n</code></pre>\n<hr>\n<h3 id=\"41--屎上雕花\">4.1  屎上雕花</h3>\n<p>上文产生的\"一坨大的\"是一个重度的事件处理行为：sync到mysql并做出通知。</p>\n<p>咱就缺一个队列，可以使用workQueue， 但是本次需求要跟踪每次状态变更，于是要规避workQueue的事件压缩效果。</p>\n<p>于是本次将(原资源key+ 资源版本+ 资源状态)整体作为入队元素。</p>\n<pre><code> item := QueueItem{\n        Key:     fmt.Sprintf(\"%s/%s\", pod.Namespace, pod.Name),\n        Version: pod.ResourceVersion,\n        Status ： pod.Status，\n    }\n</code></pre>\n<p>利用队列削峰填谷，满足了业务的需求和高可用、可扩展要求。</p>\n<p>注意出队消费时仍要保证幂等操作， 可采用（资源key+资源version) 作为幂等键实现幂等的判定。</p>\n<p>这就是某企业项目屎上雕花的经历， 老鸟轻喷。</p>\n<p>🤖 🚀 👑 🛠️ 💡 🌟 🤖 ☕ 🔗 📄 📖 🌏 💼 🗣️<br>\n🐳🚜👍🔎😄🌐</p>\n\n</div>\n<div id=\"MySignature\" role=\"contentinfo\">\n    <hr style=\"FILTER: alpha(opacity=100,finishopacity=0,style=3)\" width=\"80%\" color=\"#987cb9\" size=\"3\">\n<div style=\"text-align:center;\">\n<p>本文来自博客园，作者：{有态度的马甲}，转载请注明原文链接：<a href=\"https://www.cnblogs.com/JulianHuang/p/19388140\" target=\"_blank\">https://www.cnblogs.com/JulianHuang/p/19388140</a></p>\n<strong style=\"color: red; \">欢迎关注我的原创技术、职场公众号， 加好友谈天说地，一起进化</strong>\n<div><img style=\"width: 250px;height:250px;\" src=\"https://blog-static.cnblogs.com/files/JulianHuang/QR.gif\"> </div>\n\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\" data-last-update-days=\"0\" data-date-updated=\"2025-12-23 17:12\">2025-12-23 17:12</span>&nbsp;\n<a href=\"https://www.cnblogs.com/JulianHuang\">码甲哥不卷</a>&nbsp;\n阅读(<span id=\"post_view_count\">20</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"AddToWz(19388140);return false;\">收藏</a>&nbsp;\n<a href=\"javascript:void(0)\" onclick=\"reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19388140', targetLink: 'https://www.cnblogs.com/JulianHuang/p/19388140', title: '&amp;#128640;糟糕，我实现的k8s informer好像是依托答辩' })\">举报</a>\n</div>","guid":{"value":"0841d0a7a612c4f680ff9d6f90888af7"}}]}