{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "ROS1 noetic 中将 Unitree G1 基于 Gazebo/RViz 关节联动【使用一个launch文件启动】",
      "link": "https://www.cnblogs.com/zylyehuo/p/19498596",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zylyehuo/p/19498596\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 15:37\">\n    <span>ROS1 noetic 中将 Unitree G1 基于 Gazebo/RViz 关节联动【使用一个launch文件启动】</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>博客地址：<a href=\"https://www.cnblogs.com/zylyehuo/\" target=\"_blank\">https://www.cnblogs.com/zylyehuo/</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/unitreerobotics/unitree_ros/tree/master/robots/g1_description\" rel=\"noopener nofollow\" target=\"_blank\">Unitree G1 模型文件下载地址(挑选自己需要的部分，本教程基于 g1_29dof.urdf (以及 .xml 和 meshes 文件夹))</a></p>\n</blockquote>\n<blockquote>\n<p>有核心的 URDF 文件和 Meshes (STL 网格文件)</p>\n</blockquote>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202601/3071480-20260113204337327-270675226.png\" /></p>\n<h1 id=\"效果预览\">效果预览</h1>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202601/3071480-20260118152755660-1755629437.png\" /></p>\n<h1 id=\"工作空间结构\">工作空间结构</h1>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202601/3071480-20260118161444336-1800514403.png\" /></p>\n<h1 id=\"主要文件\">主要文件</h1>\n<h2 id=\"display_and_gazebolaunch\">display_and_gazebo.launch</h2>\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;launch&gt;\n  &lt;!-- 加载机器人URDF模型参数 --&gt;\n  &lt;param name=\"robot_description\" textfile=\"$(find g1_description)/urdf/g1_29dof.urdf\" /&gt;\n\n  &lt;!-- TF静态变换 --&gt;\n  &lt;node pkg=\"tf\" type=\"static_transform_publisher\" name=\"world_to_map\" args=\"0 0 0  0 0 0 1  world map 10\"/&gt;\n  &lt;!-- NOTE: removed static base_link-&gt;pelvis to avoid TF duplication; link_states_bridge publishes dynamic map-&gt;base_link --&gt;\n  &lt;node pkg=\"tf\" type=\"static_transform_publisher\" name=\"imu_in_torso2body_imu\" args=\"0.0  0.0  0.0   0.0 0.0 0.0 1  imu_in_torso body_imu 100\" /&gt;\n  &lt;!-- NOTE: keep base_link-&gt;pelvis as a static zero transform so pelvis and base_link coincide --&gt;\n  &lt;node pkg=\"tf\" type=\"static_transform_publisher\" name=\"base_link2pelvis\" args=\"0 0 0  0 0 0 1  base_link pelvis 100\" /&gt;\n\n  &lt;!-- 机器人状态发布器 --&gt;\n  &lt;node name=\"robot_state_publisher\" pkg=\"robot_state_publisher\" type=\"robot_state_publisher\" /&gt;\n\n  &lt;!-- LinkStates到JointState的桥接，同时发布动态TF和处理关节命令 --&gt;\n  &lt;node name=\"link_states_bridge\" pkg=\"g1_description\" type=\"link_states_bridge.py\" output=\"screen\" /&gt;\n\n  &lt;!-- RViz --&gt;\n  &lt;node name=\"rviz\" pkg=\"rviz\" type=\"rviz\" respawn=\"false\" output=\"screen\" /&gt;\n\n  &lt;!-- ============ Gazebo配置 ============ --&gt;\n  &lt;!-- 启动Gazebo --&gt;\n  &lt;include file=\"$(find gazebo_ros)/launch/empty_world.launch\"&gt;\n    &lt;arg name=\"paused\" value=\"false\"/&gt;\n    &lt;arg name=\"use_sim_time\" value=\"true\"/&gt;\n    &lt;arg name=\"gui\" value=\"true\"/&gt;\n    &lt;arg name=\"headless\" value=\"false\"/&gt;\n  &lt;/include&gt;\n\n  &lt;!-- 将机器人模型生成到Gazebo中 --&gt;\n  &lt;node name=\"spawn_urdf\" pkg=\"gazebo_ros\" type=\"spawn_model\" \n    args=\"-param robot_description -urdf -z 0.79 -model g1_robot\" \n    output=\"screen\" /&gt;\n\n  &lt;!-- NOTE: controller parameters loading removed to avoid conflicts; using bridge(set_model_configuration) instead --&gt;\n\n&lt;/launch&gt;\n\n</code></pre>\n<h2 id=\"link_states_bridgepy\">link_states_bridge.py</h2>\n<pre><code class=\"language-python\">#!/usr/bin/env python3\n\nimport rospy\nimport math\nfrom gazebo_msgs.msg import LinkStates\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Float64\nimport numpy as np\nfrom scipy.spatial.transform import Rotation\nimport threading\nimport tf\nfrom geometry_msgs.msg import TransformStamped\nfrom gazebo_msgs.srv import SetModelConfiguration\n\nclass LinkStatesToJointState:\n    def __init__(self):\n        rospy.init_node('link_states_to_joint_state')\n        \n        # 订阅Gazebo的链接状态\n        self.link_states_sub = rospy.Subscriber('/gazebo/link_states', LinkStates, self.link_states_callback, queue_size=1)\n        \n        # 订阅关节命令话题（用于控制Gazebo中的关节）\n        self.joint_cmd_sub = rospy.Subscriber('/joint_commands', JointState, self.joint_cmd_callback, queue_size=1)\n        \n        # 发布joint_states\n        self.joint_states_pub = rospy.Publisher('/joint_states', JointState, queue_size=1)\n        \n        # 发布TF变换\n        self.tf_broadcaster = tf.TransformBroadcaster()\n        \n        # 所有关节及其parent/child链接映射\n        self.joints_info = {\n            'left_hip_pitch_joint': ('pelvis', 'left_hip_pitch_link', [0, 1, 0]),\n            'left_hip_roll_joint': ('left_hip_pitch_link', 'left_hip_roll_link', [1, 0, 0]),\n            'left_hip_yaw_joint': ('left_hip_roll_link', 'left_hip_yaw_link', [0, 0, 1]),\n            'left_knee_joint': ('left_hip_yaw_link', 'left_knee_link', [0, 1, 0]),\n            'left_ankle_pitch_joint': ('left_knee_link', 'left_ankle_pitch_link', [0, 1, 0]),\n            'left_ankle_roll_joint': ('left_ankle_pitch_link', 'left_ankle_roll_link', [1, 0, 0]),\n            'right_hip_pitch_joint': ('pelvis', 'right_hip_pitch_link', [0, 1, 0]),\n            'right_hip_roll_joint': ('right_hip_pitch_link', 'right_hip_roll_link', [1, 0, 0]),\n            'right_hip_yaw_joint': ('right_hip_roll_link', 'right_hip_yaw_link', [0, 0, 1]),\n            'right_knee_joint': ('right_hip_yaw_link', 'right_knee_link', [0, 1, 0]),\n            'right_ankle_pitch_joint': ('right_knee_link', 'right_ankle_pitch_link', [0, 1, 0]),\n            'right_ankle_roll_joint': ('right_ankle_pitch_link', 'right_ankle_roll_link', [1, 0, 0]),\n            'waist_yaw_joint': ('pelvis', 'waist_yaw_link', [0, 0, 1]),\n            'waist_roll_joint': ('waist_yaw_link', 'waist_roll_link', [1, 0, 0]),\n            'waist_pitch_joint': ('waist_roll_link', 'torso_link', [0, 1, 0]),\n            'left_shoulder_pitch_joint': ('torso_link', 'left_shoulder_pitch_link', [0, 1, 0]),\n            'left_shoulder_roll_joint': ('left_shoulder_pitch_link', 'left_shoulder_roll_link', [1, 0, 0]),\n            'left_shoulder_yaw_joint': ('left_shoulder_roll_link', 'left_shoulder_yaw_link', [0, 0, 1]),\n            'left_elbow_joint': ('left_shoulder_yaw_link', 'left_elbow_link', [0, 1, 0]),\n            'left_wrist_roll_joint': ('left_elbow_link', 'left_wrist_roll_link', [1, 0, 0]),\n            'left_wrist_pitch_joint': ('left_wrist_roll_link', 'left_wrist_pitch_link', [0, 1, 0]),\n            'left_wrist_yaw_joint': ('left_wrist_pitch_link', 'left_wrist_yaw_link', [0, 0, 1]),\n            'right_shoulder_pitch_joint': ('torso_link', 'right_shoulder_pitch_link', [0, 1, 0]),\n            'right_shoulder_roll_joint': ('right_shoulder_pitch_link', 'right_shoulder_roll_link', [1, 0, 0]),\n            'right_shoulder_yaw_joint': ('right_shoulder_roll_link', 'right_shoulder_yaw_link', [0, 0, 1]),\n            'right_elbow_joint': ('right_shoulder_yaw_link', 'right_elbow_link', [0, 1, 0]),\n            'right_wrist_roll_joint': ('right_elbow_link', 'right_wrist_roll_link', [1, 0, 0]),\n            'right_wrist_pitch_joint': ('right_wrist_roll_link', 'right_wrist_pitch_link', [0, 1, 0]),\n            'right_wrist_yaw_joint': ('right_wrist_pitch_link', 'right_wrist_yaw_link', [0, 0, 1]),\n        }\n        \n        # Gazebo set_model_configuration 服务代理（用于直接设置关节位置，替代ros_control）\n        rospy.wait_for_service('/gazebo/set_model_configuration')\n        self.set_model_config = rospy.ServiceProxy('/gazebo/set_model_configuration', SetModelConfiguration)\n        \n        self.last_msg = None\n        self.lock = threading.Lock()\n        self.initial_pelvis_z = None  # 初始pelvis高度\n\n        # TF 发布节流参数\n        self.last_tf_time = rospy.Time(0)\n        self.tf_min_interval = rospy.Duration(0.05)  # 最小间隔 50ms\n        self.last_pelvis_pose = None\n        self.tf_pos_thresh = 0.005   # 5mm\n        self.tf_rot_thresh = 0.01    # ~0.57deg\n        \n        rospy.loginfo(\"Link States to Joint State Bridge initialized\")\n        rospy.loginfo(\"Now using /gazebo/set_model_configuration to apply joint commands\")\n        rospy.loginfo(\"Publish JointState to /joint_commands to control joints\")\n    \n    def link_states_callback(self, msg):\n        with self.lock:\n            self.last_msg = msg\n            self.publish_joint_states(msg)\n            self.publish_dynamic_tf(msg)\n    \n    def joint_cmd_callback(self, msg):\n        \"\"\"订阅关节命令话题，使用Gazebo服务设置关节位置（不依赖URDF transmission）\"\"\"\n        try:\n            if not msg.name or not msg.position:\n                rospy.logwarn(\"Received empty joint command\")\n                return\n            # 调用服务设置关节位置\n            model_name = 'g1_robot'\n            urdf_param_name = 'robot_description'\n            joint_names = list(msg.name)\n            joint_positions = list(msg.position)\n            rospy.loginfo(f\"Setting joints via service: {joint_names} -&gt; {joint_positions}\")\n            self.set_model_config(model_name, urdf_param_name, joint_names, joint_positions)\n        except Exception as e:\n            rospy.logerr(f\"Failed to call set_model_configuration: {e}\")\n    \n    def get_link_index(self, link_name, msg):\n        \"\"\"获取链接在LinkStates中的索引\"\"\"\n        full_name = f'g1_robot::{link_name}'\n        try:\n            return msg.name.index(full_name)\n        except ValueError:\n            return -1\n    \n    def get_relative_rotation(self, parent_pose, child_pose):\n        \"\"\"计算从parent到child的相对旋转（四元数）\"\"\"\n        p_quat = [parent_pose.orientation.x, parent_pose.orientation.y, \n                  parent_pose.orientation.z, parent_pose.orientation.w]\n        c_quat = [child_pose.orientation.x, child_pose.orientation.y, \n                  child_pose.orientation.z, child_pose.orientation.w]\n        \n        p_rot = Rotation.from_quat(p_quat)\n        c_rot = Rotation.from_quat(c_quat)\n        \n        rel_rot = p_rot.inv() * c_rot\n        \n        return rel_rot\n    \n    def rotation_to_angle_around_axis(self, rotation, axis):\n        angle = rotation.magnitude()\n        \n        if abs(angle) &lt; 1e-6:\n            return 0.0\n        \n        rotvec = rotation.as_rotvec()\n        rot_axis = rotvec / angle if angle &gt; 1e-6 else [0, 0, 1]\n        \n        axis_norm = np.array(axis) / np.linalg.norm(axis)\n        \n        if np.dot(rot_axis, axis_norm) &gt; 0.9:\n            return angle\n        elif np.dot(rot_axis, axis_norm) &lt; -0.9:\n            return -angle\n        else:\n            euler = rotation.as_euler('xyz')\n            if axis == [1, 0, 0]:\n                return euler[0]\n            elif axis == [0, 1, 0]:\n                return euler[1]\n            elif axis == [0, 0, 1]:\n                return euler[2]\n            else:\n                return 0.0\n    \n    def publish_joint_states(self, msg):\n        joint_state = JointState()\n        joint_state.header.stamp = rospy.Time.now()\n        joint_state.name = list(self.joints_info.keys())\n        joint_state.position = []\n        joint_state.velocity = [0.0] * len(joint_state.name)\n        joint_state.effort = [0.0] * len(joint_state.name)\n        \n        for joint_name, (parent_name, child_name, axis) in self.joints_info.items():\n            parent_idx = self.get_link_index(parent_name, msg)\n            child_idx = self.get_link_index(child_name, msg)\n            \n            if parent_idx &lt; 0 or child_idx &lt; 0:\n                joint_state.position.append(0.0)\n                continue\n            \n            rel_rot = self.get_relative_rotation(msg.pose[parent_idx], msg.pose[child_idx])\n            angle = self.rotation_to_angle_around_axis(rel_rot, axis)\n            \n            joint_state.position.append(angle)\n        \n        self.joint_states_pub.publish(joint_state)\n    \n    def publish_dynamic_tf(self, msg):\n        pelvis_idx = self.get_link_index('pelvis', msg)\n\n        if pelvis_idx &lt; 0:\n            return\n\n        pelvis_pose = msg.pose[pelvis_idx]\n\n        # 节流逻辑\n        now = rospy.Time.now()\n        if self.last_pelvis_pose is not None:\n            pos_diff = np.linalg.norm([\n                pelvis_pose.position.x - self.last_pelvis_pose.position.x,\n                pelvis_pose.position.y - self.last_pelvis_pose.position.y,\n                pelvis_pose.position.z - self.last_pelvis_pose.position.z\n            ])\n            rot_diff = Rotation.from_quat([\n                pelvis_pose.orientation.x, pelvis_pose.orientation.y,\n                pelvis_pose.orientation.z, pelvis_pose.orientation.w\n            ]).inv() * Rotation.from_quat([\n                self.last_pelvis_pose.orientation.x, self.last_pelvis_pose.orientation.y,\n                self.last_pelvis_pose.orientation.z, self.last_pelvis_pose.orientation.w\n            ])\n            rot_diff_angle = rot_diff.magnitude()\n\n            if pos_diff &lt; self.tf_pos_thresh and rot_diff_angle &lt; self.tf_rot_thresh and (now - self.last_tf_time) &lt; self.tf_min_interval:\n                return\n\n        self.last_tf_time = now\n        self.last_pelvis_pose = pelvis_pose\n\n        translation = (pelvis_pose.position.x, pelvis_pose.position.y, pelvis_pose.position.z)\n        rotation_q = (pelvis_pose.orientation.x, pelvis_pose.orientation.y, pelvis_pose.orientation.z, pelvis_pose.orientation.w)\n\n        # 只发布 map -&gt; base_link，让 base_link-&gt;pelvis 由静态发布器（launch）处理\n        self.tf_broadcaster.sendTransform(\n            translation=translation,\n            rotation=rotation_q,\n            time=rospy.Time.now(),\n            child='base_link',\n            parent='map'\n        )\n\nif __name__ == '__main__':\n    try:\n        node = LinkStatesToJointState()\n        rospy.spin()\n    except rospy.ROSInterruptException:\n        pass\n\n</code></pre>\n<h1 id=\"运行步骤\">运行步骤</h1>\n<pre><code>cd ~/g1_test_ws\n</code></pre>\n<pre><code>catkin_make\n</code></pre>\n<pre><code>source ./devel/setup.bash\n</code></pre>\n<pre><code>roslaunch g1_description display_and_gazebo.launch\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 15:37</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zylyehuo\">zylyehuo</a>&nbsp;\n阅读(<span id=\"post_view_count\">3</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "教你白嫖一年谷歌Gemini Pro会员",
      "link": "https://www.cnblogs.com/dnboy/p/19498587",
      "published": "",
      "description": "<div class=\"postTitle\">\n\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/dnboy/p/19498587\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 15:29\">\n    <span>教你白嫖一年谷歌Gemini Pro会员</span>\n    \n\n</a>\n\n\t</div>\n\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"1效果\">1.效果</h2>\n<p>下面是开通成功的截图，已经可以用上一年的Gemini Pro了</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"2准备工作\">2.准备工作</h2>\n<ul>\n<li>能访问谷歌的网络</li>\n<li>一个Google账号</li>\n<li>一个Visa全币种卡</li>\n</ul>\n<h2 id=\"3网络\">3.网络</h2>\n<p>注意网络节点需要切换美国节点，否则会有不通过的风险</p>\n<h2 id=\"4学生认证\">4.学生认证</h2>\n<p>登录：<a href=\"https://gemini.google/students/\" rel=\"noopener nofollow\" target=\"_blank\">https://gemini.google/students/</a></p>\n<p>点击<code>Get Offer</code></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"5-认证\">5. 认证</h3>\n<p>这一步因为我的谷歌账号是老号，点击之后提示已经不支持这个学生认证方案了</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>不过不要紧，我们可以从某鱼上去买Gemini Pro的学生认证服务，消费大概30元左右就行了，小卷用了不到10分钟就完成了认证</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>收到这个邮件，还是很激动的，毕竟花点小钱就可以用到1年的Gemini3和Nano banana了，非常划算。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>大家也快去尝试吧，新号应该不需要这么麻烦的</p>\n<p>不知道google这个“bug”会释放多久，说不定哪一天就被堵上啦</p>\n\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-01-18 15:29</span>&nbsp;\n<a href=\"https://www.cnblogs.com/dnboy\">卷福同学</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "打破堆积困局：优化堆积条形图的对比效果",
      "link": "https://www.cnblogs.com/wang_yb/p/19498573",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wang_yb/p/19498573\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 15:25\">\n    <span>打破堆积困局：优化堆积条形图的对比效果</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在数据可视化中，<strong>堆积条形图</strong> 擅长展示 <strong>“整体与构成”</strong> 的关系，但当每个柱子内的分段超过4个时，读者很难同时追踪各段的长度、位置与颜色映射， <strong>误读概率显著上升</strong>。</p>\n<p>更糟的是，若不同类别的总量差异很大，堆积结构会放大视觉错觉，导致“看起来差不多”的结论失真。</p>\n<p>今天，本文将尝试探索一下改进堆积条形图的呈现方式，让复杂数据对比变得一目了然。</p>\n<p>如果大家有更好的方式，也欢迎指教，交流。<strong>完整的代码</strong>会在文末提供共享的地址。</p>\n<h1 id=\"1-堆积条形图的困境\">1. 堆积条形图的困境</h1>\n<p><strong>堆积条形图</strong>就像一道精心摆盘的多层蛋糕，当层数不多时，我们能轻松分辨每层的高度差异。</p>\n<p>但当蛋糕层数超过4层，要比较某一特定口味在多个蛋糕中的含量就变得异常困难。</p>\n<p>下面我们用<code>Python</code>模拟一个常见的堆积条形图场景：调查某产品5个功能模块的用户满意度（5个维度），共收集了4个季度的数据。</p>\n<pre><code class=\"language-python\"># 模拟数据：4个季度，5个满意度维度（强烈反对、反对、中立、同意、坚决同意）\nquarters = [\"第一季度\", \"第二季度\", \"第三季度\", \"第四季度\"]\ncategories = [\"强烈反对\", \"反对\", \"中立\", \"同意\", \"坚决同意\"]\ncolors = [\"#FF6B6B\", \"#FF9F6B\", \"#D6CBCB\", \"#6BCF7F\", \"#4D96FF\"]\n\n# 每个季度的满意度分布（百分比）\ndata = np.array(\n    [\n        [5, 10, 25, 40, 20],  # 第一季度\n        [3, 8, 20, 45, 24],  # 第二季度\n        [4, 12, 18, 43, 23],  # 第三季度\n        [2, 6, 15, 50, 27],  # 第四季度\n    ]\n)\n\n# 传统横向堆积条形图\nfig, ax = plt.subplots(1, 2, figsize=(14, 4), gridspec_kw={\"width_ratios\": [1, 1]})\n\n# 左图：传统横向堆积条形图\n# ... 省略 ...\n\n# 右图：横向堆叠条形图的改进版，添加分隔线\n# ... 省略 ...\n\nplt.tight_layout()\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260118152231940-1462391798.png\" /></p>\n<p>这个横向堆积条形图展示了每个季度用户满意度的完整分布，随便右边的图稍微做了一些改进，</p>\n<p>但如果我们想回答以下问题就会遇到困难：</p>\n<ul>\n<li><strong>\"坚决同意\"</strong> 的比例在哪个季度最高？</li>\n<li><strong>\"反对\"</strong> 和 <strong>\"强烈反对\"</strong> 的比例如何随时间变化？</li>\n</ul>\n<h1 id=\"2-拆解重构--多个子图\">2. 拆解重构--多个子图</h1>\n<p>与其把所有食材炖在一锅里，不如将它们分盘摆放。</p>\n<p>我们将<strong>堆积条形图</strong>拆解为5个小图，每个小图只关注一个满意度维度的季度变化。</p>\n<pre><code class=\"language-python\">import matplotlib.gridspec as gridspec\n\nfig = plt.figure(figsize=(12, 6))\ngs = gridspec.GridSpec(2, 5, figure=fig, hspace=0.3, wspace=0.4)\n# 拆解堆积条形图：为每个类别创建单独的横向子图\naxes = []\nfor i in range(5):\n    axes.append(fig.add_subplot(gs[0, i]))\n\n# 为每个满意度维度创建一个横向条形图\nfor i, (category, color, ax) in enumerate(zip(categories, colors, axes)):\n    # ... 省略 ...\n\nax = fig.add_subplot(gs[1, :]) # 第1行，所有列 (等同于 gs[1, 0:5])\n# ... 省略 ...\n\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260118152232008-1859050466.png\" /></p>\n<p>拆解后的图表确实提升了单一维度的对比效果，但仍有一个明显问题：我们的视线需要在多个图表间来回跳跃，无法形成统一的视觉印象。</p>\n<p>这就像阅读一本分散在多个页面的表格，需要不断翻页对照。</p>\n<h1 id=\"3-双向对比--蝴蝶图\">3. 双向对比--蝴蝶图</h1>\n<p><strong>蝴蝶图</strong>（也称为人口金字塔图或双向条形图）是数据可视化的\"瑞士军刀\"，特别适合展示对立或双向比较的数据。</p>\n<p>它的设计哲学是：让对比在中心轴两侧自然展开，就像蝴蝶展开双翅。</p>\n<pre><code class=\"language-python\"># 4. 创建画布\nfig, ax = plt.subplots(2, 1,figsize=(10, 6))\ny_pos = np.arange(len(quarters))\n# 拆分数据列\nstrongly_disagree = data[:, 0]\ndisagree          = data[:, 1]\nneutral           = data[:, 2]\nagree             = data[:, 3]\nstrongly_agree    = data[:, 4]\n\n# ==========================================\n# 核心逻辑修改：以中立(Neutral)的中心为0点\n# ==========================================\n# 1. 绘制中立 (灰色)：跨越 0 轴\n# left 从 -width/2 开始，这样 0 就在正中间\n\n# 2. 绘制左侧 (负面情绪)：向左堆叠\n# 反对 (Green)：起始位置在 -neutral/2 的左边\n\n# 强烈反对 (Purple)：起始位置在 反对 的左边\n\n# 3. 绘制右侧 (正面情绪)：向右堆叠\n# 同意 (Orange)：起始位置在 neutral/2\n\n# 强烈同意 (Red)：起始位置在 同意 的右边\n\n# 5. 美化图表\n# 添加中间的基准线 (穿过中立条形)\n# ... 省略 ...\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260118152232037-237677572.png\" /></p>\n<p><strong>蝴蝶图</strong>和一般的堆积条形图放在一起，可以明显看出两者在数据展示逻辑和视觉重心上有显著区别。</p>\n<p><strong>蝴蝶图</strong>侧重于展示 <strong>“对立态度的对比”</strong>，适合看正反两面的力量悬殊以及整体的情绪倾向，而且也便于比较同侧的数据。</p>\n<h1 id=\"4-总结\">4. 总结</h1>\n<p>总之，<strong>堆积条形图</strong>像一锅大杂烩，当食材（数据维度）过多时，我们很难品尝（分析）到每种食材的原味。</p>\n<p>通过拆解和重构，我们获得了更清晰的视角。而蝴蝶图则像一位优雅的舞者，将对比数据以对称的方式展开，既保留了整体视野，又强化了局部对比。</p>\n<p>优秀的数据可视化不在于展示所有信息，而在于以最少的认知成本传达最多的洞察。</p>\n<p>下次当我们面对多维数据对比的挑战时，不妨试试横向蝴蝶图这把\"瑞士军刀\"，它可能会给你带来意想不到的清晰与美感。</p>\n<p>绘制文中图像的完整代码共享在：<a href=\"https://url11.ctfile.com/f/45455611-8606783265-a93d12?p=6872\" rel=\"noopener nofollow\" target=\"_blank\">优化堆积条形图.ipynb</a> (访问密码: 6872)</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 15:25</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wang_yb\">wang_yb</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "金额计算字段类型用Long，还是BigDecimal更好？",
      "link": "https://www.cnblogs.com/12lisu/p/19498493",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/12lisu/p/19498493\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 14:33\">\n    <span>金额计算字段类型用Long，还是BigDecimal更好？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>对于从事后端开发的小伙伴来说，可能会遇到金额计算字段的类型，到底该用Long，还是BigDecimal的困扰。</p>\n<p>甚至有些公司的架构师跟DBA，有时也会为了金额计算字段的类型而PK。</p>\n<p>今天这篇文章专门跟大家一起聊聊这个话题，希望对你会有所帮助。</p>\n<h2 id=\"一案发现场\">一、案发现场</h2>\n<p>有些小伙伴在工作中可能遇到过这样的场景：新来的开发小明负责公司电商平台的优惠券计算功能。</p>\n<p>按照产品需求，满100减20的优惠券，用户下单金额是98.5元时，应该无法使用这张优惠券。</p>\n<p>小明心想：这太简单了！</p>\n<p>不到5分钟就写完了代码：</p>\n<pre><code class=\"language-java\">public class CouponService {\n    public boolean canUseCoupon(double orderAmount, double couponThreshold) {\n        return orderAmount &gt;= couponThreshold;\n    }\n    \n    public static void main(String[] args) {\n        CouponService service = new CouponService();\n        double orderAmount = 98.5;\n        double couponThreshold = 100.0;\n        \n        boolean canUse = service.canUseCoupon(orderAmount, couponThreshold);\n        System.out.println(\"订单金额\" + orderAmount + \"元，能否使用\" + \n                         couponThreshold + \"元门槛优惠券：\" + canUse);\n        // 输出：订单金额98.5元，能否使用100.0元门槛优惠券：true\n    }\n}\n</code></pre>\n<p>结果上线第一天，财务就炸锅了：大量本不该享受优惠的订单都被系统通过了，一天下来公司损失了3万多元！</p>\n<p>小明百思不得其解：98.5明明小于100，为什么条件判断会出错呢？</p>\n<h2 id=\"二浮点数的陷阱计算机的小秘密\">二、浮点数的陷阱：计算机的小秘密</h2>\n<p>要理解这个问题，我们需要知道计算机是如何存储小数的。</p>\n<h3 id=\"21-二进制世界的局限\">2.1 二进制世界的局限</h3>\n<pre><code class=\"language-java\">public class FloatProblemDemo {\n    public static void main(String[] args) {\n        // 看似简单的计算，却有问题\n        double a = 0.1;\n        double b = 0.2;\n        double c = a + b;\n        \n        System.out.println(\"0.1 + 0.2 = \" + c);\n        System.out.println(\"0.1 + 0.2 == 0.3 ? \" + (c == 0.3));\n        \n        // 让我们看看实际存储的值\n        System.out.println(\"0.1的实际值: \" + new BigDecimal(a));\n        System.out.println(\"0.2的实际值: \" + new BigDecimal(b));\n        System.out.println(\"0.1+0.2的实际值: \" + new BigDecimal(c));\n    }\n}\n</code></pre>\n<p>运行结果会让你震惊：</p>\n<pre><code>0.1 + 0.2 = 0.30000000000000004\n0.1 + 0.2 == 0.3 ? false\n0.1的实际值: 0.1000000000000000055511151231257827021181583404541015625\n0.2的实际值: 0.200000000000000011102230246251565404236316680908203125\n0.1+0.2的实际值: 0.3000000000000000444089209850062616169452667236328125\n</code></pre>\n<h3 id=\"22-为什么会出现精度问题\">2.2 为什么会出现精度问题？</h3>\n<p>用一张图来理解浮点数的存储原理：<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<p>如何出现的问题？<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<p>这就好比用1/3 ≈ 0.333333来表示三分之一，永远无法精确。</p>\n<p>计算机的二进制系统也无法精确表示某些十进制小数。</p>\n<h2 id=\"三两种解决方案的深度pk\">三、两种解决方案的深度PK</h2>\n<p>面对金额计算的精度问题，Java开发者主要有两种选择。</p>\n<p>让我们深入剖析每种方案的实现和原理。</p>\n<h3 id=\"31-方案一货币使用long\">3.1 方案一：货币使用Long</h3>\n<p>这种方法的核心思想：<strong>用分来计算，不用元</strong>。</p>\n<pre><code class=\"language-java\">public class MoneyWithLong {\n    // 所有金额都以分为单位存储\n    private Long amountInCents;\n    \n    public MoneyWithLong(Long amountInCents) {\n        this.amountInCents = amountInCents;\n    }\n    \n    // 加法\n    public MoneyWithLong add(MoneyWithLong other) {\n        return new MoneyWithLong(this.amountInCents + other.amountInCents);\n    }\n    \n    // 减法\n    public MoneyWithLong subtract(MoneyWithLong other) {\n        return new MoneyWithLong(this.amountInCents - other.amountInCents);\n    }\n    \n    // 乘法（处理折扣等场景）\n    public MoneyWithLong multiply(double multiplier) {\n        // 先将double转为整数分计算\n        BigDecimal bd = BigDecimal.valueOf(multiplier)\n            .multiply(BigDecimal.valueOf(this.amountInCents));\n        return new MoneyWithLong(bd.longValue());\n    }\n    \n    // 格式化显示\n    public String display() {\n        double yuan = amountInCents / 100.0;\n        return String.format(\"%.2f元\", yuan);\n    }\n    \n    // 小明问题的正确解法\n    public static boolean canUseCoupon(Long orderAmountInCents, Long thresholdInCents) {\n        return orderAmountInCents &gt;= thresholdInCents;\n    }\n}\n</code></pre>\n<p><strong>实战场景</strong>：</p>\n<pre><code class=\"language-java\">public class LongSolutionDemo {\n    public static void main(String[] args) {\n        // 解决小明的问题\n        Long orderAmount = 9850L;  // 98.50元\n        Long threshold = 10000L;   // 100.00元\n        \n        boolean canUse = orderAmount &gt;= threshold;\n        System.out.println(\"订单98.5元能否使用100元门槛券: \" + canUse);\n        // 正确输出：false\n        \n        // 复杂计算示例\n        MoneyWithLong price1 = new MoneyWithLong(1999L);  // 19.99元\n        MoneyWithLong price2 = new MoneyWithLong(2999L);  // 29.99元\n        \n        MoneyWithLong total = price1.add(price2);\n        System.out.println(\"总价: \" + total.display());  // 49.98元\n        \n        // 折扣计算\n        MoneyWithLong discounted = total.multiply(0.8);  // 8折\n        System.out.println(\"8折后: \" + discounted.display());  // 39.98元\n    }\n}\n</code></pre>\n<h3 id=\"32-方案二bigdecimal精确计算\">3.2 方案二：BigDecimal精确计算</h3>\n<p>BigDecimal是Java提供的专门用于精确计算的类。</p>\n<pre><code class=\"language-java\">public class MoneyWithBigDecimal {\n    private BigDecimal amount;\n    private static final int SCALE = 2;  // 保留2位小数\n    private static final RoundingMode ROUNDING_MODE = RoundingMode.HALF_UP;\n    \n    public MoneyWithBigDecimal(String amount) {\n        this.amount = new BigDecimal(amount).setScale(SCALE, ROUNDING_MODE);\n    }\n    \n    public MoneyWithBigDecimal(BigDecimal amount) {\n        this.amount = amount.setScale(SCALE, ROUNDING_MODE);\n    }\n    \n    // 四则运算\n    public MoneyWithBigDecimal add(MoneyWithBigDecimal other) {\n        return new MoneyWithBigDecimal(this.amount.add(other.amount));\n    }\n    \n    public MoneyWithBigDecimal subtract(MoneyWithBigDecimal other) {\n        return new MoneyWithBigDecimal(this.amount.subtract(other.amount));\n    }\n    \n    public MoneyWithBigDecimal multiply(BigDecimal multiplier) {\n        return new MoneyWithBigDecimal(\n            this.amount.multiply(multiplier).setScale(SCALE, ROUNDING_MODE)\n        );\n    }\n    \n    public MoneyWithBigDecimal divide(BigDecimal divisor) {\n        return new MoneyWithBigDecimal(\n            this.amount.divide(divisor, SCALE, ROUNDING_MODE)\n        );\n    }\n    \n    // 比较\n    public int compareTo(MoneyWithBigDecimal other) {\n        return this.amount.compareTo(other.amount);\n    }\n}\n</code></pre>\n<p><strong>BigDecimal的陷阱与正确用法</strong>：</p>\n<pre><code class=\"language-java\">public class BigDecimalCorrectUsage {\n    public static void main(String[] args) {\n        // 错误用法：使用double构造\n        BigDecimal bad1 = new BigDecimal(0.1);\n        System.out.println(\"错误构造: \" + bad1);\n        // 输出：0.1000000000000000055511151231257827021181583404541015625\n        \n        // 正确用法1：使用String构造\n        BigDecimal good1 = new BigDecimal(\"0.1\");\n        System.out.println(\"String构造: \" + good1);\n        // 输出：0.1\n        \n        //正确用法2：使用valueOf方法\n        BigDecimal good2 = BigDecimal.valueOf(0.1);\n        System.out.println(\"valueOf构造: \" + good2);\n        // 输出：0.1\n        \n        // 除法的坑\n        BigDecimal a = new BigDecimal(\"10\");\n        BigDecimal b = new BigDecimal(\"3\");\n        \n        try {\n            // 不指定精度会抛异常\n            BigDecimal result = a.divide(b);\n        } catch (ArithmeticException e) {\n            System.out.println(\"必须指定精度: \" + e.getMessage());\n        }\n        \n        // 正确做法\n        BigDecimal correctResult = a.divide(b, 2, RoundingMode.HALF_UP);\n        System.out.println(\"10 ÷ 3 = \" + correctResult);  // 3.33\n    }\n}\n</code></pre>\n<h2 id=\"四性能与存储的深度对比\">四、性能与存储的深度对比</h2>\n<p>有些小伙伴在工作中可能会问：两种方案性能差别大吗？对数据库有什么影响？</p>\n<h3 id=\"41-性能基准测试\">4.1 性能基准测试</h3>\n<pre><code class=\"language-java\">public class PerformanceBenchmark {\n    private static final int ITERATIONS = 10_000_000;\n    \n    public static void main(String[] args) {\n        // Long方案性能\n        long longStart = System.currentTimeMillis();\n        long totalCents = 0L;\n        for (int i = 0; i &lt; ITERATIONS; i++) {\n            totalCents += 100L;  // 1元\n            totalCents -= 50L;   // 0.5元\n            totalCents *= 2;\n            totalCents /= 2;\n        }\n        long longEnd = System.currentTimeMillis();\n        System.out.println(\"Long方案耗时: \" + (longEnd - longStart) + \"ms\");\n        \n        // BigDecimal方案性能\n        long bdStart = System.currentTimeMillis();\n        BigDecimal total = BigDecimal.ZERO;\n        for (int i = 0; i &lt; ITERATIONS; i++) {\n            total = total.add(new BigDecimal(\"1.00\"));\n            total = total.subtract(new BigDecimal(\"0.50\"));\n            total = total.multiply(new BigDecimal(\"2\"));\n            total = total.divide(new BigDecimal(\"2\"), 2, RoundingMode.HALF_UP);\n        }\n        long bdEnd = System.currentTimeMillis();\n        System.out.println(\"BigDecimal方案耗时: \" + (bdEnd - bdStart) + \"ms\");\n        \n        System.out.println(\"性能差异倍数: \" + \n            (bdEnd - bdStart) * 1.0 / (longEnd - longStart));\n    }\n}\n</code></pre>\n<p>典型测试结果：</p>\n<pre><code>Long方案耗时: 25ms\nBigDecimal方案耗时: 1250ms\n性能差异倍数: 50.0\n</code></pre>\n<p>性能差距可达数十倍！这是为什么呢？</p>\n<h3 id=\"42-存储结构与原理分析\">4.2 存储结构与原理分析</h3>\n<p>下面用几张图对比两种方案的存储：</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h3 id=\"43-数据库层面的考虑\">4.3 数据库层面的考虑</h3>\n<pre><code class=\"language-sql\">-- Long方案对应的表结构\nCREATE TABLE orders_long (\n    id BIGINT PRIMARY KEY,\n    amount_cents BIGINT NOT NULL,  -- 以分为单位\n    INDEX idx_amount (amount_cents)  -- 索引效率高\n);\n\n-- BigDecimal方案对应的表结构\nCREATE TABLE orders_bd (\n    id BIGINT PRIMARY KEY,\n    amount DECIMAL(20, 2) NOT NULL,  -- 总共20位，2位小数\n    INDEX idx_amount (amount)  -- 索引相对较大\n);\n</code></pre>\n<p><strong>数据库层面的差异</strong>：</p>\n<ol>\n<li><strong>存储空间</strong>：BIGINT固定8字节，DECIMAL是变长的</li>\n<li><strong>索引效率</strong>：BIGINT比较更快</li>\n<li><strong>跨数据库兼容性</strong>：BIGINT几乎所有数据库都支持且行为一致</li>\n<li><strong>计算位置</strong>：DECIMAL可以在数据库层计算，但业务逻辑通常应在应用层</li>\n</ol>\n<h2 id=\"五真实业务场景深度分析\">五、真实业务场景深度分析</h2>\n<p><strong>没有银弹，只有适合场景的方案</strong>。</p>\n<h3 id=\"51-场景一金融交易系统推荐long\">5.1 场景一：金融交易系统（推荐Long）</h3>\n<pre><code class=\"language-java\">// 银行核心系统示例\npublic class BankTransactionSystem {\n    // 账户余额（单位：分）\n    private AtomicLong balanceInCents = new AtomicLong();\n    \n    // 存款（线程安全）\n    public boolean deposit(long cents) {\n        if (cents &lt;= 0) return false;\n        balanceInCents.addAndGet(cents);\n        return true;\n    }\n    \n    // 取款（防止超取）\n    public boolean withdraw(long cents) {\n        while (true) {\n            long current = balanceInCents.get();\n            if (current &lt; cents) return false;\n            if (balanceInCents.compareAndSet(current, current - cents)) {\n                return true;\n            }\n            // CAS失败，重试\n        }\n    }\n    \n    // 跨行转账（两阶段提交）\n    public boolean transfer(BankTransactionSystem target, long cents) {\n        if (!this.withdraw(cents)) {\n            return false;\n        }\n        \n        try {\n            if (!target.deposit(cents)) {\n                // 存款失败，回滚\n                this.deposit(cents);\n                return false;\n            }\n            return true;\n        } catch (Exception e) {\n            this.deposit(cents);  // 异常回滚\n            throw e;\n        }\n    }\n}\n</code></pre>\n<p><strong>为什么金融系统偏爱Long</strong>：</p>\n<ol>\n<li><strong>原子性操作</strong>：Java对long的原子操作支持完善（AtomicLong）</li>\n<li><strong>高性能</strong>：每秒数万笔交易必须考虑性能</li>\n<li><strong>精确无误差</strong>：分是最小单位，没有舍入问题</li>\n<li><strong>审计方便</strong>：所有操作都是整数，便于对账</li>\n</ol>\n<h3 id=\"52-场景二电商优惠计算bigdecimal更灵活\">5.2 场景二：电商优惠计算（BigDecimal更灵活）</h3>\n<pre><code class=\"language-java\">public class EcommercePriceEngine {\n    private BigDecimal price;\n    \n    // 复杂优惠计算\n    public BigDecimal calculateFinalPrice(\n        BigDecimal originalPrice,\n        BigDecimal discountRate,      // 折扣率\n        BigDecimal fullReduction,     // 满减\n        BigDecimal coupon,            // 优惠券\n        boolean isVIP                 // VIP折扣\n    ) {\n        BigDecimal result = originalPrice;\n        \n        // 折扣\n        if (discountRate != null) {\n            result = result.multiply(discountRate)\n                          .setScale(2, RoundingMode.HALF_UP);\n        }\n        \n        // 满减\n        if (fullReduction != null &amp;&amp; \n            result.compareTo(new BigDecimal(\"100\")) &gt;= 0) {\n            result = result.subtract(fullReduction);\n        }\n        \n        // 优惠券\n        if (coupon != null) {\n            result = result.subtract(coupon).max(BigDecimal.ZERO);\n        }\n        \n        // VIP额外95折\n        if (isVIP) {\n            result = result.multiply(new BigDecimal(\"0.95\"))\n                          .setScale(2, RoundingMode.HALF_UP);\n        }\n        \n        return result;\n    }\n    \n    // 分摊计算（如订单多个商品分摊优惠）\n    public Map&lt;String, BigDecimal&gt; allocateDiscount(\n        Map&lt;String, BigDecimal&gt; itemPrices,\n        BigDecimal totalDiscount\n    ) {\n        BigDecimal totalPrice = itemPrices.values().stream()\n            .reduce(BigDecimal.ZERO, BigDecimal::add);\n        \n        Map&lt;String, BigDecimal&gt; result = new HashMap&lt;&gt;();\n        BigDecimal allocated = BigDecimal.ZERO;\n        \n        List&lt;String&gt; keys = new ArrayList&lt;&gt;(itemPrices.keySet());\n        for (int i = 0; i &lt; keys.size(); i++) {\n            String key = keys.get(i);\n            BigDecimal price = itemPrices.get(key);\n            \n            // 按比例分摊\n            BigDecimal ratio = price.divide(totalPrice, 10, RoundingMode.HALF_UP);\n            BigDecimal itemDiscount = totalDiscount.multiply(ratio)\n                .setScale(2, RoundingMode.HALF_UP);\n            \n            // 最后一个商品承担剩余金额\n            if (i == keys.size() - 1) {\n                itemDiscount = totalDiscount.subtract(allocated);\n            }\n            \n            result.put(key, price.subtract(itemDiscount));\n            allocated = allocated.add(itemDiscount);\n        }\n        \n        return result;\n    }\n}\n</code></pre>\n<h3 id=\"53-混合方案鱼与熊掌兼得\">5.3 混合方案：鱼与熊掌兼得</h3>\n<p>有些复杂的系统会采用混合方案：</p>\n<pre><code class=\"language-java\">public class HybridMoneySystem {\n    // 核心账户系统用Long\n    private static class AccountCore {\n        private long balanceCents;  // 分单位\n        \n        public void transfer(AccountCore to, long cents) {\n            // 高性能的整数运算\n            this.balanceCents -= cents;\n            to.balanceCents += cents;\n        }\n    }\n    \n    // 营销计算用BigDecimal\n    private static class MarketingCalculator {\n        public BigDecimal calculateCampaignEffect(\n            BigDecimal budget,\n            BigDecimal conversionRate,\n            BigDecimal avgOrderValue\n        ) {\n            // 复杂的浮点计算\n            BigDecimal estimatedOrders = budget.multiply(conversionRate)\n                .divide(avgOrderValue, 4, RoundingMode.HALF_UP);\n            return estimatedOrders.setScale(0, RoundingMode.HALF_UP);\n        }\n    }\n    \n    // 转换层\n    public static long yuanToCents(BigDecimal yuan) {\n        return yuan.multiply(new BigDecimal(\"100\"))\n                  .setScale(0, RoundingMode.HALF_UP)\n                  .longValue();\n    }\n    \n    public static BigDecimal centsToYuan(long cents) {\n        return new BigDecimal(cents)\n                  .divide(new BigDecimal(\"100\"), 2, RoundingMode.UNNECESSARY);\n    }\n}\n</code></pre>\n<h2 id=\"六避坑指南\">六、避坑指南</h2>\n<h3 id=\"61-常见的坑\">6.1 常见的坑</h3>\n<p><strong>坑1：序列化问题</strong></p>\n<pre><code class=\"language-java\">public class SerializationBug {\n    // 使用默认序列化\n    private BigDecimal amount;\n    \n    // 正确做法\n    private transient BigDecimal amount;  // 不自动序列化\n    \n    public String getAmountForJson() {\n        return amount.toString();  // 明确转为String\n    }\n    \n    public void setAmountFromJson(String amountStr) {\n        this.amount = new BigDecimal(amountStr);  // 明确从String构造\n    }\n}\n</code></pre>\n<p><strong>坑2：等于判断的坑</strong></p>\n<pre><code class=\"language-java\">public class EqualityBug {\n    public static void main(String[] args) {\n        BigDecimal a = new BigDecimal(\"1.0\");\n        BigDecimal b = new BigDecimal(\"1.00\");\n        \n        System.out.println(\"a.equals(b): \" + a.equals(b));  // false!\n        System.out.println(\"a.compareTo(b): \" + a.compareTo(b));  // 0\n        \n        // BigDecimal的equals不仅比较值，还比较scale\n        System.out.println(\"a.scale(): \" + a.scale());  // 1\n        System.out.println(\"b.scale(): \" + b.scale());  // 2\n    }\n}\n</code></pre>\n<p><strong>坑3：溢出问题</strong></p>\n<pre><code class=\"language-java\">public class OverflowBug {\n    public static void main(String[] args) {\n        // Long的溢出\n        long max = Long.MAX_VALUE;\n        System.out.println(\"MAX: \" + max);\n        System.out.println(\"MAX + 1: \" + (max + 1));  // 变成负数！\n        \n        // BigDecimal没有溢出，但可能性能问题\n        BigDecimal huge = new BigDecimal(Long.MAX_VALUE);\n        System.out.println(\"BigDecimal MAX * 2: \" + \n            huge.multiply(new BigDecimal(\"2\")));  // 正确计算\n    }\n}\n</code></pre>\n<h3 id=\"62-代码规范建议\">6.2 代码规范建议</h3>\n<pre><code class=\"language-java\">// 金额处理的工具类\npublic final class MoneyUtils {\n    private MoneyUtils() {}  // 工具类私有构造\n    \n    // 全局统一的精度和舍入模式\n    public static final int DEFAULT_SCALE = 2;\n    public static final RoundingMode DEFAULT_ROUNDING = RoundingMode.HALF_UP;\n    \n    // 安全的创建方法\n    public static BigDecimal safeCreate(String amount) {\n        try {\n            return new BigDecimal(amount).setScale(DEFAULT_SCALE, DEFAULT_ROUNDING);\n        } catch (NumberFormatException e) {\n            throw new IllegalArgumentException(\"无效金额: \" + amount, e);\n        }\n    }\n    \n    // 转换方法\n    public static long yuanToCents(BigDecimal yuan) {\n        return yuan.multiply(new BigDecimal(\"100\"))\n                  .setScale(0, DEFAULT_ROUNDING)\n                  .longValueExact();  // 精确转换，溢出抛异常\n    }\n    \n    // 验证方法\n    public static boolean isValidAmount(BigDecimal amount) {\n        if (amount == null) return false;\n        if (amount.scale() &gt; DEFAULT_SCALE) return false;\n        return amount.compareTo(BigDecimal.ZERO) &gt;= 0;\n    }\n    \n    // 格式化显示\n    public static String format(BigDecimal amount) {\n        return String.format(\"¥%.2f\", amount);\n    }\n    \n    public static String format(long cents) {\n        return String.format(\"¥%.2f\", cents / 100.0);\n    }\n}\n</code></pre>\n<h2 id=\"七总结\">七、总结</h2>\n<p>文章最后跟大家总结一下。</p>\n<h3 id=\"71-选择原则\">7.1 选择原则</h3>\n<p>我画了一张图帮你做选择：<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<h3 id=\"72-终极建议\">7.2 终极建议</h3>\n<ol>\n<li>\n<p><strong>金融核心系统</strong>：优先使用<strong>Long方案</strong></p>\n<ul>\n<li>支付、清算、账户余额等</li>\n<li>理由：性能、原子性、一致性</li>\n</ul>\n</li>\n<li>\n<p><strong>电商营销系统</strong>：优先使用<strong>BigDecimal方案</strong></p>\n<ul>\n<li>优惠计算、价格引擎、促销活动</li>\n<li>理由：灵活性、计算精度、业务变化快</li>\n</ul>\n</li>\n<li>\n<p><strong>混合型系统</strong>：采用<strong>分层架构</strong></p>\n<ul>\n<li>核心层用Long保证性能</li>\n<li>计算层用BigDecimal保证精度</li>\n<li>表现层做好格式化显示</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"73-最后的建议\">7.3 最后的建议</h3>\n<p><strong>记住这三条铁律</strong>：</p>\n<ol>\n<li>金额计算无小事，必须严格测试</li>\n<li>选择适合业务的技术，而不是最新的技术</li>\n<li>保持一致性，一个系统内不要混用多种方案</li>\n</ol>\n<p>技术选型就像选工具，用对了事半功倍，用错了后患无穷。</p>\n<p>希望这篇文章能帮你在金额计算的路上少踩坑，走得更稳更远。</p>\n<p>更多项目实战在我的技术网站：<a href=\"http://www.susan.net.cn/project\" rel=\"noopener nofollow\" target=\"_blank\">http://www.susan.net.cn/project</a></p>\n<h2 id=\"最后说一句求关注别白嫖我\">最后说一句(求关注，别白嫖我)</h2>\n<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>\n<p>求一键三连：点赞、转发、在看。</p>\n<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 14:33</span>&nbsp;\n<a href=\"https://www.cnblogs.com/12lisu\">苏三说技术</a>&nbsp;\n阅读(<span id=\"post_view_count\">7</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "2026 年 PHP 函数式编程 优势与实际应用",
      "link": "https://www.cnblogs.com/catchadmin/p/19497758",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19497758\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 08:26\">\n    <span>2026 年 PHP 函数式编程 优势与实际应用</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"2026-年-php-函数式编程-优势与实际应用\">2026 年 PHP 函数式编程 优势与实际应用</h1>\n<p>函数式编程（FP）已经存在几十年了，但近年来在实际开发中用得越来越多。这篇文章整理一下 FP 的核心概念和实际应用场景。</p>\n<h2 id=\"什么是函数式编程\">什么是函数式编程</h2>\n<p>在深入优势和应用之前，先快速回顾一下函数式编程是什么。</p>\n<p>函数式编程的核心是把计算当作数学函数的求值。它是一种声明式编程风格，描述的是\"要什么\"，而不是\"怎么做\"。在 FP 中，函数是一等公民，可以作为参数传递给其他函数，可以从函数返回，也可以赋值给变量。</p>\n<p>FP 的一个核心原则是不可变性——一旦给变量赋值，就不能再改变。这消除了副作用，让代码更可预测、更容易调试。另一个基本概念是纯函数，对于相同的输入总是产生相同的输出，不会修改任何外部状态。</p>\n<p><a href=\"https://catchadmin.com/post/2026-01/functional-programming-paradigms-2026\" rel=\"noopener nofollow\" target=\"_blank\">原文 2026 年 PHP 函数式编程 优势与实际应用</a></p>\n<h2 id=\"为什么开发者应该关注函数式编程\">为什么开发者应该关注函数式编程</h2>\n<h3 id=\"更简洁更易维护的代码\">更简洁、更易维护的代码</h3>\n<p>函数式编程鼓励编写模块化、易于理解的代码。因为函数是纯的（不修改状态），意外行为的空间更小，代码库更干净。这让调试、测试和后续修改都更容易。</p>\n<p>假设你在做一个 PHP 项目。使用函数式技术可以减少副作用，确保应用逻辑被隔离成更小的、可复用的代码片段。这也让后续更新或重构更容易，因为函数式代码的依赖通常更少。</p>\n<h3 id=\"并发和并行\">并发和并行</h3>\n<p>现代软件的一个挑战是处理并发和并行。随着多核处理器和分布式系统的普及，编写能高效处理多任务的代码比以往更重要。</p>\n<p>函数式编程在这方面有明显优势：因为函数避免修改共享状态，它们天生是线程安全的。这让编写并发应用更容易，不用担心竞态条件或死锁。</p>\n<p>比如一个需要处理大数据集的 PHP 应用。使用不可变数据结构和并行处理技术，可以确保应用的不同部分并发运行而不互相干扰。</p>\n<h3 id=\"更好的抽象和复用\">更好的抽象和复用</h3>\n<p>函数式编程促进高层抽象的创建。函数可以轻松组合、传递，在应用的不同部分复用。</p>\n<p>比如在 PHP 中，与其写重复的代码处理某些操作，不如写小的纯函数，然后灵活地组合起来。这减少了代码重复，更好地遵循 DRY（Don't Repeat Yourself）原则。</p>\n<h3 id=\"php-中的函数式工具\">PHP 中的函数式工具</h3>\n<p>PHP 不是纯函数式语言，但内置的 <code>array_map()</code>、<code>array_filter()</code>、<code>array_reduce()</code> 等函数提供了基本的函数式操作能力。第三方库如 Ramda、Lodash 也可以用。</p>\n<h2 id=\"函数式编程的核心原则\">函数式编程的核心原则</h2>\n<p>下面探讨函数式编程的一些核心原则，以及它们在实际编程中的应用。</p>\n<h3 id=\"不可变性\">不可变性</h3>\n<p>在函数式编程中，数据是不可变的。一旦设置了值，就不能改变。这个概念减少了与可变状态变化相关的 bug，简化了对程序行为的理解。</p>\n<p>PHP 示例：</p>\n<pre><code class=\"language-php\">function addItemToList($list, $item) {\n    // 创建一个包含新元素的新列表\n    return array_merge($list, [$item]);\n}\n\n$list = [1, 2, 3];\n$newList = addItemToList($list, 4);\n\nprint_r($list);     // 输出: [1, 2, 3]（原列表不变）\nprint_r($newList);  // 输出: [1, 2, 3, 4]（包含新元素的新列表）\n</code></pre>\n<p>这个例子中，原始的 <code>$list</code> 保持不变，因为 PHP 数组是按值传递的。这展示了不可变性——原始数据结构被保留，返回的是包含新元素的新结构。</p>\n<h3 id=\"纯函数\">纯函数</h3>\n<p>纯函数对于相同的输入总是产生相同的输出，不会产生任何副作用。这让纯函数可预测且易于测试。</p>\n<p>PHP 示例：</p>\n<pre><code class=\"language-php\">function square($number) {\n    return $number * $number;\n}\n\necho square(4); // 输出: 16\n</code></pre>\n<p><code>square()</code> 函数是纯的，因为对于相同的输入（4）总是产生相同的输出（16），而且不修改任何外部状态。</p>\n<h3 id=\"高阶函数\">高阶函数</h3>\n<p>高阶函数是可以接受其他函数作为参数或返回函数的函数。这实现了强大的抽象和代码复用。</p>\n<p>PHP 示例：</p>\n<pre><code class=\"language-php\">function applyFunction($func, $value) {\n    return $func($value);\n}\n\nfunction double($x) {\n    return $x * 2;\n}\n\necho applyFunction('double', 5); // 输出: 10\n</code></pre>\n<p>这个例子中，<code>applyFunction()</code> 是一个高阶函数，因为它接受另一个函数（<code>double()</code>）作为参数并应用到一个值上。</p>\n<h3 id=\"函数组合\">函数组合</h3>\n<p>函数组合是把简单函数组合成更复杂函数的过程。这让你可以从更小的、可复用的组件构建复杂行为。</p>\n<p>PHP 示例：</p>\n<pre><code class=\"language-php\">function add($x, $y) {\n    return $x + $y;\n}\n\nfunction multiply($x, $y) {\n    return $x * $y;\n}\n\nfunction addThenMultiply($x, $y, $z) {\n    return multiply(add($x, $y), $z);\n}\n\necho addThenMultiply(2, 3, 4); // 输出: 20（add(2, 3) = 5, multiply(5, 4) = 20）\n</code></pre>\n<p>这里，<code>addThenMultiply()</code> 函数展示了如何把更小的函数组合起来创建新功能。这鼓励代码复用和模块化。</p>\n<h2 id=\"函数式编程的实际应用\">函数式编程的实际应用</h2>\n<p>函数式编程不只是理论概念——它正在实际应用中使用。下面看看函数式编程在不同领域的一些实际例子。</p>\n<h3 id=\"数据转换和-etl-流程\">数据转换和 ETL 流程</h3>\n<p>在数据密集型应用中，比如数据转换或 ETL（Extract, Transform, Load）流程，函数式编程表现出色。它让开发者可以不可变地操作大数据集，使用高层抽象进行转换。</p>\n<p>PHP 示例：</p>\n<pre><code class=\"language-php\">$data = [1, 2, 3, 4, 5];\n\n// 使用函数式方法处理数据\n$result = array_map(fn($x) =&gt; $x * 2, $data);  // 每个值翻倍\n$result = array_filter($result, fn($x) =&gt; $x &gt; 5); // 只保留大于 5 的值\n\nprint_r($result);  // 输出: [6, 8, 10]\n</code></pre>\n<p>这个例子中，我们使用 <code>array_map()</code> 和 <code>array_filter()</code> 不可变地转换和过滤数据集，这是函数式编程中的常见模式。</p>\n<h3 id=\"分布式系统中的并发\">分布式系统中的并发</h3>\n<p>函数式编程对不可变性和纯函数的强调，使它成为并发和并行处理任务的理想选择。你可以放心地编写并发应用，不用担心竞态条件。</p>\n<p>比如，在 PHP 中构建一个并发处理用户请求的分布式系统时，可以确保数据完整性，而不会引入与可变共享状态相关的 bug。</p>\n<h3 id=\"构建-api-端点和微服务\">构建 API 端点和微服务</h3>\n<p>构建微服务或 API 时，函数式编程可以帮助创建简洁、易维护的端点。通过确保每个函数处理特定任务且是纯的、确定性的，可以让每个微服务更容易测试和扩展。</p>\n<h2 id=\"小结\">小结</h2>\n<p>函数式编程的核心是不可变性、纯函数和高阶函数。这些概念在并发处理、数据转换等场景下比较实用。PHP 虽然不是纯函数式语言，但内置函数和第三方库已经提供了足够的支持。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 08:26</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">36</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "大数据技术领域发展与Spark的性能优化",
      "link": "https://www.cnblogs.com/zzq6032010/p/19497421",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zzq6032010/p/19497421\" id=\"cb_post_title_url\" title=\"发布于 2026-01-17 23:59\">\n    <span>大数据技术领域发展与Spark的性能优化</span>\n    \n\n</a>\n</h1>\n\t<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><strong><span style=\"font-size: 15px;\">一、大数据技术领域发展方向</span></strong></p>\n<p>随着AI时代的到来，大数据技术领域逐渐退居二线，再也没有了前些年的重视程度。博主近期结合从业多年经验，对大数据技术领域的技术演进路线做下梳理。</p>\n<p>当前大数据领域发展已经进入深水区，随着各种成熟大数据框架的应用普及，难点已经从存不下、算不出，变为了如何高质量、高效计算数据并增加数据与价值的转换率，这就涉及到针对价值变现场景的数据设计和全生命周期的管理。这部分根据具体业务场景的差异，设计实现千差万别，本文以Spark On Yarn经典大数据集群场景为例，讲一讲如何高效计算数据。</p>\n<p>&nbsp;</p>\n<p><strong><span style=\"font-size: 15px;\">二、Spark On Yarn性能优化思路</span></strong></p>\n<p><strong><span style=\"font-size: 14px;\">1、Spark调参</span></strong></p>\n<p>Spark开放了众多过程参数，来控制集群运行过程中各个维度的设置。常用来参数调优的有：</p>\n<p>spark.default.parallelism：并行度</p>\n<p>spark.sql.shuffle.partitions：shuffle分区数（常为集群Executor核心数的2-3倍）</p>\n<p>spark.executor.memoryOverhead：调节shuffle过程中内存溢出阈值</p>\n<p>spark.dynamicAllocation.enabled=true：启用动态资源分配，任务负载高时可自行增加对资源的申请</p>\n<p>spark.sql.adaptive.enabled=true：开启AQE，自动调节最优分区数，还可改善数据倾斜问题</p>\n<p>上面只是例举其中一小部分，参数调参配合SparkUI使用，方便观测调整效果。</p>\n<p><strong>2、代码端优化</strong></p>\n<p>手段很多，包括但不限于：增加缓存、减少udf的使用、走dataframe或sparksql最大化利用spark原生的引擎优化、使用broadcast等，核心原则是多利用spark优化机制，做好数据缓存。</p>\n<p><strong>3、数据端优化</strong></p>\n<p>数据端优化主要是两部分：</p>\n<p>第一是读取、存储时，采用高效存储格式，如parquet、ORC等，天然适配spark的分区计算模式，会减少很多无谓的操作。</p>\n<p>第二是采用高效序列化方式，减少shuffle过程中的序列化耗时，这部分时间可在SparkUI的Stage处查看task的timeline中的对应耗时。</p>\n<p><strong>4、架构层优化</strong></p>\n<p>上述措施都做完之后，基本就进入了性能优化的深水区，当前业界成熟做法有两大类，均能进一步突破数据计算瓶颈可带来较大幅度提升。</p>\n<p><span style=\"color: rgba(0, 0, 255, 1);\"><strong>第一是利用向量化技术，大幅提升计算效率。</strong></span></p>\n<p>向量化技术能有效果的基础，在于现代计算机对SIMD指令的支持。</p>\n<p>SIMD指令，即单指令流多数据流 Single Instruction Multiple Data，在计算机中可以使用一条指令，传递多个数据进去（即向量），而后CPU仅需对这一个向量进行一次运算（比如当前要进行加法运算），即可得到结果，相比传统CPU一个加法调用一次指令的方式，快了N（N为向量的长度）倍。</p>\n<p>所以向量化改造是一条理论上具备高效提效能力的技术方向。具体实操的话，开源组件推荐使用Gluten，小米技术团队去年做过实践分享，改造之后时间耗时平均降低30%。</p>\n<p><strong><span style=\"color: rgba(0, 0, 255, 1);\">第二是在并行计算路上继续狂奔，引入异构的GPU</span></strong>（注意不是NPU，NPU仅为支持AI训练推理加速，对通用数据计算增益效果并不好，且缺少配套）。</p>\n<p>在GPU计算提效这块，英伟达专门为Spark无缝使用开发了RAPIDS加速器插件。它可以以插件的方式集成到spark客户端中，通过参数开关指定启用。在spark的物理计划生成之后，会被该加速器插件拦截，将其中的CPU算子替换为GPU算子（若评估加速效果不好还可退回成CPU算子），而后在Task执行阶段，RAPIDS会接过该任务进行执行。</p>\n<p>大体，就这些了。单纯的大数据技术领域，可做的新技术演进已经不多了，后面更多的是如何精细化价值转换，给AI给行业赋能。</p>\n<p>后续将沿着AI的方向，进行博文的更新和学习。</p>\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-01-17 23:59</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zzq6032010\">淡墨痕</a>&nbsp;\n阅读(<span id=\"post_view_count\">52</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "最近遇到的两个技术问题记录",
      "link": "https://www.cnblogs.com/grey-wolf/p/19495709",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/grey-wolf/p/19495709\" id=\"cb_post_title_url\" title=\"发布于 2026-01-17 12:23\">\n    <span>最近遇到的两个技术问题记录</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"问题1\">问题1</h1>\n<h2 id=\"背景\">背景</h2>\n<p>有个供内部员工使用的后台管理系统，每天会从上游的一个oa系统的接口同步员工数据，oa系统侧维护了每个员工的id、名称、工作城市等等各类信息，接口响应如下：</p>\n<p><img alt=\"image-20260117104211631\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117104211631.png\" /></p>\n<p>这个id就算是员工的唯一标识，就像工号一样，不会变的那种。因此，我们把接口数据拿到后，就直接落地到我们本地数据库的表中，表的主键虽然设定为自增主键，但是在程序里，我们会直接用oa系统给我们的这个id来设置本地表id的值后再插入。</p>\n<p><img alt=\"image-20260117105119562\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117105119562.png\" /></p>\n<p>表结构：</p>\n<p><img alt=\"image-20260117122224831\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117122224831.png\" /></p>\n<p>sql如下：这个sql是自动生成的，默认生成出来的是不带id这种主键字段的，我们手动加了一下：</p>\n<p><img alt=\"image-20260117105019010\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117105019010.png\" /></p>\n<p>手动加上id字段：</p>\n<p><img alt=\"image-20260117104906664\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117104906664.png\" /></p>\n<p>结果，最近弄了一个员工报商业保险的活动，简单来说，就是存储一下数据：用户id 、对应的商业保险id。</p>\n<p>报保险的过程中，发现用户表缺了些数据没同步，如用户证件号（报保险需要）、城市等，所以就加了一下这几个字段。</p>\n<p><img alt=\"image-20260117105522469\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117105522469.png\" /></p>\n<p>新增完字段后，mapper.xml代码自动生成，也没仔细看，结果就把之前手动加的id字段给冲掉了：</p>\n<p><img alt=\"image-20260117105645320\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117105645320.png\" /></p>\n<p>这个上线后，由于在程序中没有指定id字段，就导致本地表中的id变成了使用自增的方式（postgresql，从序列中获取下一个id的值，类似mysql中自增）。</p>\n<p>而且，从oa系统同步员工信息到我方系统，每天都是靠一个定时任务在跑，每天跑的时候：</p>\n<pre><code class=\"language-shell\">1、从oa侧获取员工列表数据\n2、清空本地表\n3、批量插入从oa侧获取的员工数据\n</code></pre>\n<p>这就导致，员工的id，上线后，每天都在变，每天都在变。</p>\n<p>当时我查问题看到这个问题的时候，吓了一跳，当时员工报商业保险正如火如荼呢，我一想：难道得赶紧通知全公司的人，重新报了？而且，当时业务的人和保险公司约定的提供保险人员名单的时间也没几天了。。。</p>\n<p>后面我又仔细看了下，发现问题还没有那么大。</p>\n<p>就是在数据先落地到t_user_sync这个表（这个表和上游oa侧数据保持一模一样，只读不写，便于定位问题）后，还有个定时任务，将数据从t_user_sync转移到我们实际的用户表（sy_user），这个表我们会进行增删改查等等。</p>\n<p><img alt=\"image-20260117110408095\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117110408095.png\" /></p>\n<p>这个定时任务，在将t_user_sync转移到sy_user的过程中，是增量同步的。如，发现zhangsan这个用户时，先查一下sy_user里有没有，没有才插入，插入时，sy_user的id也是用的t_user_sync的id（也就是oa侧的id），有就更新。</p>\n<p>这个增量同步机制，救了我，导致的结果是，虽然t_user_sync中id错了，且每天都在变；但sy_user中的id虽然也是错的，但是不会每天变，而是用到第一次同步t_user_sync时的id。</p>\n<p>只要sy_user表中的id不变，错的也影响不大，至少员工报保险的相关表中的关联关系是没问题的：</p>\n<p>员工id          员工名称    保险名称</p>\n<p>11111(错的)  张三         xxx商业保险</p>\n<p>而我们这个系统中，其他地方也有用到这个用户id的，虽然由于用户id变化导致了关联关系错乱，但是影响毕竟业务影响没那么大，到时候再修复即可。</p>\n<h2 id=\"总结\">总结</h2>\n<p>其实，这个问题就是粗心造成的，当然，客观上，现在手里系统太多，精力分散也是一个原因。</p>\n<p>另外，这个自动生成代码的机制，后期看看这块是否可以优化吧，能把id字段一起生成到xml中是最好。</p>\n<p>如果实在不行的话，也应该考虑，这种表的id字段，就设置为非自增、非空，必须让程序手动设置，也能及时发现问题。</p>\n<h2 id=\"问题2\">问题2</h2>\n<h2 id=\"etl\">etl</h2>\n<p>介绍背景前，先讲讲etl吧：</p>\n<p>在我从业没几年的时候，当时由于接触的都是mysql这种oltp这类业务为主，有时候看到一些招聘岗位写etl，不知道是啥意思。也是这几年才大概了解：</p>\n<pre><code class=\"language-shell\">将企业中分散的数据，集中的输入到数据仓库中的过程，就是 ETL。\n\nExtract（提取）： 从多个异构数据源（如数据库、文件系统、API等）中提取原始数据。数据源可以是关系型数据库（如MySQL、PostgreSQL）、非关系型数据库（如MongoDB、Cassandra）、文件（如CSV、JSON）、API或流式数据源。\n\nTransform（转换）： 对提取的数据进行清洗、标准化、聚合、去重等操作，以满足业务需求或数据分析的要求。这一步可能涉及数据类型转换、格式转换、业务规则应用、数据聚合、数据质量校验等。\n\nLoad（加载）： 将转换后的数据加载到目标存储系统中，通常是数据仓库或数据湖中，供后续的数据分析、报表或机器学习等用途。加载的方式可以是全量加载、增量加载或实时加载。\n</code></pre>\n<p><img alt=\"image-20260117113327615\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117113327615.png\" /></p>\n<p>像我们公司，数据库种类又多（oracle、mysql、pg、国产），系统又多，好多系统还是买的，你想要某个系统的数据，要么走接口，要么通过人家的表。一方面，好多买的系统，不喜欢对外提供接口（商业上的考虑，毕竟数据是无价的，让你难以迁移，也就是这几年，感觉新的软件系统才开始注重对外提供api）；另一方面，有时候表很多，有些表也很大，自己写接口去每天同步，工作量也不小，还要申请api key/api secret，还要开通网络，也是挺麻烦的，最终就慢慢习惯了、妥协了，通过数仓etl同步，还是能省一些事吧。</p>\n<h2 id=\"背景-1\">背景</h2>\n<p>另一个c端系统，重要性比上面那个系统重要多了，这两天也出了一个问题。</p>\n<p>这个系统，本来是一个外包同事在维护，由于他所在的公司和我们公司不再合作了，他也就跟着离职了（其实可以和新外包公司签约，不过他说新外包公司不太喜欢）。他开发完成了最后一个功能并完成测试后，还没来得及系统上线，所以上线的事就我来弄。</p>\n<p>我整理了一下上线的各种变更，如sql、nacos配置、xxljob、版本jar包、前端包等等一大堆，写了个文档就提交变更流程了。</p>\n<p>其中一个sql，是给某个数仓同步表加id字段（并新建了序列，设置id字段通过序列来自增），我当时还专门研究了一下：</p>\n<p>我们有两个表，jy_sync_h_logasset （当前表）、jy_sync_h_logasset_history（历史表），两个表的结构类似，只是一个存储最近几个月的数据（jy_sync_h_logasset ），一个存储几个人前的数据（jy_sync_h_logasset_history）。系统会定期把几个月前的数据，从当前表，转移到历史表里去，保证当前表的数据量不要太大，影响查询速度。</p>\n<p>这两个表，有一个问题，就是表没有设置id这种主键，为啥没主键呢，因为jy_sync_h_logasset 这个表的数据，是通过数仓的etl操作，从其他上游数据库搬运过来的。</p>\n<p>jy_sync_h_logasset 对应的上游的话，不一定是一个表，可能是一个视图，或者是一个sql，比如select name,oa_account from employee这种，它的sql中，就没有查询id字段，或者是多表join那种（一对多），就是算有id，也会导致id重复。</p>\n<p>所以，我猜测是这个原因，导致我方的这个表，是没有id字段的，也没弄主键。</p>\n<p>一个表，没有主键，据我所知，在分页查询时，容易不稳定，某一条记录可能会在这一页出现，在下一页继续出现，一般我们解决这种分页查询不稳定的问题，都是会按照某个字段排序，而一般首选就是id字段。</p>\n<p>对于这个没有id字段的表来说，分页查询应该是容易出问题的，所以我猜测，这就是本次sql变更（加id字段，创建序列，设置id字段从序列取值）的原因。</p>\n<p><img alt=\"image-20260117115053690\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117115053690.png\" /></p>\n<p>我当时为啥注意这个sql呢，我发现他只建了一个序列，然后两个表都用了这个序列，我当时多看了两眼，只是有点奇怪，一般来说，每个表会设置一个自己的序列。后来我看到，在将jy_sync_h_logasset表中几个月前的数据转移到jy_sync_h_logasset_history的定时任务中，代码里设置了jy_sync_h_logasset_history的id就直接使用jy_sync_h_logasset中的id，也就是说，jy_sync_h_logasset_history实际并不会使用序列中的值作为id，我也就没管了。当然，出事的确实也不是这个问题。</p>\n<p>周四下午，和运维一块，看着他做完上线变更，想着又了了一个事。结果周五早上，8点多，就给我发消息，说有个xxljob的定时任务失败了。</p>\n<p>我赶紧吃完饭，抱着电脑去找他，看了下，发现报错的原因是：</p>\n<p>一个etl_status的表中，没有查到当天的记录，这个表的用途是：数仓在给我们推送完各个表的数据后，会在etl_status中写入一条成功记录。</p>\n<p>既然这次报错是没查到数仓写的成功记录，是不是数据推送失败了呢，我们赶紧联系了数仓的同事，数仓同事过了会告诉我们说，是数仓在往jy_sync_h_logasset写记录时，报错了，提示对jy_sync_h_logasset_pk这个序列的权限不足。然后我过去找他，仔细聊了下，比如，他那边的一次数仓etl任务，总共要推10个表过来，如果其中一个表失败了，就会导致：不写入etl_status成功记录。但已经推送成功的表（如这里成功了9个表）的数据并不会回退。</p>\n<p>问题是搞清楚了，还是粗心导致的，我当时完全没有想起来序列要给数仓用户授权这个事。</p>\n<p>但这个问题看起来小，导致的影响还是比较大的，由于我们定位这个问题及修复（给数仓用户增加权限，数仓重新推送）花了一些时间，修复时已经过了某个特定的时点了，导致我方已经没有时间再来跑xxljob了（某个xxljob任务由于下游系统的限制，要求必须在某个时点之前跑才行），只能是让业务同事去通知客户道歉。</p>\n<p>部门的领导也介入了这个事情，下周就得系统梳理下现状，再看看有没有在这种异常情况下进行补救的措施，当然，我们这边其实是可以补救的（数仓重新推送数据后，我方也重新执行xxljob相关任务），但是我们系统还有下游（现在就是下游系统不支持过了某个时间点后进行补救），这块还得再看看怎么弄。</p>\n<h2 id=\"总结-1\">总结</h2>\n<p>小小的问题，大大的影响，出了问题再来处理，一般成本是最高的，也会带来更多的工作，如事故汇报、针对事故的改进措施等。还是得防患于未然，治未病。</p>\n<p>当然，我简单看了下，希望postgresql可以做到：新增的序列，不用每次单独授权，而是在数据库级别进行授权。</p>\n<p><img alt=\"image-20260117122000029\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117122000029.png\" /></p>\n<p>下周再研究下吧，和dba沟通下，避免现在权限管的太细导致的问题。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-17 12:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/grey-wolf\">三国梦回</a>&nbsp;\n阅读(<span id=\"post_view_count\">182</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "FFmpeg开发笔记（九十九）基于Kotlin的国产开源播放器DKVideoPlayer",
      "link": "https://www.cnblogs.com/aqi00/p/19379646",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aqi00/p/19379646\" id=\"cb_post_title_url\" title=\"发布于 2026-01-17 12:15\">\n    <span>FFmpeg开发笔记（九十九）基于Kotlin的国产开源播放器DKVideoPlayer</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<span id=\"cke_bm_197S\">在Android平台上，基于FFmpeg的国产播放器开源框架也有很多了，前有哔哩哔哩的ijkplayer，后有小红书的RedPlayer，参见之前的文章《使用国产的ijkplayer播放器观看网络视频》和《使用国产的RedPlayer播放器观看网络视频》。</span>\n<p><span id=\"cke_bm_197S\"> 除此以外，DKVideoPlayer也是一款优秀的国产Android视频播放器，它基于Kotlin编写，不但集成了Android原生的MediaPlayer，还集成了Jetpack的ExoPlayer，甚至集成了国产的ijkplayer。DKVideoPlayer既支持播放本地视频，也支持播放网络视频，甚至支持播放直播链接，可谓功能强大。<br />\nDKVideoPlayer的源码托管地址为https://github.com/Doikki/DKVideoPlayer（星星数5.3k），国内的镜像地址为https://gitcode.com/gh_mirrors/dk/DKVideoPlayer，最新版本是2022年7月发布的v3.3.7，可见该框架的源码更新十分及时，该版本的源码下载地址为https://github.com/Doikki/DKVideoPlayer/archive/refs/tags/3.3.7.tar.gz。<br />\nDKVideoPlayer提供了两种集成方式，引用在线库、直接导入源码，分别说明如下：</span></p>\n<h1>一、引用DKVideoPlayer在线库</h1>\n<p>Android工程引用DKVideoPlayer在线库时，需要修改以下两个配置：<br />\n1、打开模块级别的build.gradle，给dependencies节点补充下面几行配置，表示引入3.3.7版本的DKVideoPlayer库：</p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected\">\n<pre class=\"cke_widget_element\"><code class=\"hljs\"># 必选，内部默认使用系统mediaplayer进行解码\nimplementation 'xyz.doikki.android.dkplayer:dkplayer-java:3.3.7'\n# 可选，包含StandardVideoController的实现\nimplementation 'xyz.doikki.android.dkplayer:dkplayer-ui:3.3.7'\n# 可选，使用exoplayer进行解码\nimplementation 'xyz.doikki.android.dkplayer:player-exo:3.3.7'\n# 可选，使用ijkplayer进行解码\nimplementation 'xyz.doikki.android.dkplayer:player-ijk:3.3.7'\n# 可选，如需要缓存或者抖音预加载功能请引入此库\nimplementation 'xyz.doikki.android.dkplayer:videocache:3.3.7'</code></pre>\n</div>\n<p>2、打开App模块的src/main/AndroidManifest.xml，给manifest节点补充下面几行权限配置，表示声明悬浮窗、存储空间和网络等权限：</p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected\">\n<pre class=\"cke_widget_element\"><code class=\"hljs\">&lt;uses-permission android:name=\"android.permission.SYSTEM_ALERT_WINDOW\" /&gt;\n&lt;uses-permission android:name=\"android.permission.SYSTEM_OVERLAY_WINDOW\" /&gt;\n&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt;\n&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;\n&lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/&gt;</code></pre>\n</div>\n<h1>二、直接导入DKVideoPlayer源码</h1>\n<p>DKVideoPlayer的源码已经适配Android Studio Dolphin（小海豚版本），仅需在项目级别的build.gradle补充国内仓库即可。也就是在repositories节点内部补充以下配置：</p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected\">\n<pre class=\"cke_widget_element\"><code class=\"hljs\">// 以下四行添加阿里云的仓库地址，方便国内开发者下载相关插件\nmaven { url = uri(\"https://maven.aliyun.com/repository/jcenter\") }\nmaven { url = uri(\"https://maven.aliyun.com/repository/google\")}\nmaven { url = uri(\"https://maven.aliyun.com/repository/gradle-plugin\")}\nmaven { url = uri(\"https://maven.aliyun.com/repository/public\")}\n// 以下添加清华大学的仓库地址\nmaven { url = uri(\"https://mirrors.tuna.tsinghua.edu.cn/repository/maven-central/\") }</code></pre>\n</div>\n<p>增加以上配置的目的是引入国内的仓库地址，以便加快相关依赖包的下载速度。</p>\n<p>等待DKVideoPlayer工程编译通过，把主入口的dkplayer-sample模块安装到手机上，启动之后的App界面如下图所示：</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"dkplayer1\" class=\"lazyload\" height=\"468\" width=\"410\" /></span></span></span></span></p>\n<p>点击【点播】按钮，打开网络视频的播放界面如下图所示：</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"dkplayer2\" class=\"lazyload\" height=\"609\" width=\"403\" /></span></span></span></span></p>\n<p>或者点击【直播】按钮，打开直播链接的播放界面如下图所示：</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"dkplayer3\" class=\"lazyload\" height=\"608\" width=\"403\" /></span></span></span></span></p>\n<p>可见DKVideoPlayer支持调整播放窗口大小、调整播放速度，以及旋转、截图、裁剪等功能，可谓将常见的播放操作一网打尽。</p>\n<p>更多详细的FFmpeg开发知识参见<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\"><a class=\"cke_widget_editable cke_widget_element\" href=\"https://item.jd.com/14020415.html\" rel=\"noopener nofollow\" title=\"《FFmpeg开发实战：从零基础到短视频上线》\">《FFmpeg开发实战：从零基础到短视频上线》</a>一书。</span></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-17 12:15</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aqi00\">aqi00</a>&nbsp;\n阅读(<span id=\"post_view_count\">123</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "大模型榜单周报（2026/1/17）",
      "link": "https://www.cnblogs.com/xjk15082/p/19495655",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xjk15082/p/19495655\" id=\"cb_post_title_url\" title=\"发布于 2026-01-17 12:01\">\n    <span>大模型榜单周报（2026/1/17）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h3 id=\"1-本周概览\">1. 本周概览</h3>\n<p>本周大模型领域继续保持快速发展态势，各大厂商在医疗AI、视频生成、代码能力等多个领域取得显著进展。OpenRouter模型调用量排名发生重要变化，Claude系列模型表现抢眼，百度新模型ERNIE-5.0-0110在全球LMArena文本排行榜上排名第八，展现了中国模型的强劲实力。</p>\n<h3 id=\"2-重点关注事件\">2. 重点关注事件</h3>\n<ul>\n<li>DeepSeek与北京大学合作发表关于条件记忆（conditional memory）的新论文，提出Engram模块，有望提升模型检索效率</li>\n<li>Anthropic推出工作场景智能体Claude Cowork，由Claude Code自主开发，体现了AGI在实际应用中的潜力</li>\n<li>谷歌发布新一代开源医疗AI模型MedGemma 1.5及MedASR语音识别模型，进一步扩展在医疗AI领域的布局</li>\n<li>谷歌Veo 3.1更新支持9:16竖屏视频和4K分辨率，视频生成能力持续提升</li>\n<li>智谱与华为合作开源图像生成模型GLM-Image，登顶复杂视觉文字生成和长文本渲染双榜首</li>\n<li>阿里千问APP上线超400项AI办事功能，接入阿里生态，成为全球首个能完成真实生活复杂任务的AI助手</li>\n<li>OpenAI推出独立翻译页面ChatGPT Translate，拓展应用场景</li>\n<li>百度ERNIE-5.0-0110在全球LMArena文本排行榜上排名第八，超越多个领先模型</li>\n</ul>\n<h3 id=\"3-榜单变化\">3. 榜单变化</h3>\n<ul>\n<li>\n<p><strong>OpenRouter模型调用量排名</strong>：</p>\n<ul>\n<li>整体调用量方面，Claude Opus 4.5超越上周榜首Claude Sonnet 4.5，位列第1；MiMo-V2-Flash(free)上升两名，排名第3；Gemini 3 Flash Preview由第4名下降至第5名</li>\n<li>模型市占率方面，Google保持第1；Anthropic市占率上升4.2%（17.2% → 21.5%），连续两周上升8.5%；OpenAI市占率上升3.1%（8.0% → 11.1%）；Qwen上升至第8名，替代了上周MiniMax的位置</li>\n<li>编程调用量方面，Claude Opus 4.5保持第1；Claude Sonnet 4.5排名上升2名，排名第3；DeepSeek V3.2重回前十，排名第8</li>\n</ul>\n</li>\n<li>\n<p><strong>大语言模型榜单</strong>：ERNIE-5.0-0110新上榜，排名第8，超过GPT-5.1（high），相比ERNIE-5.0-preview-1203版本上升了6名，该模型基于预发布测试，评分可能随着公开发布后的反馈而变化</p>\n</li>\n<li>\n<p><strong>图像编辑能力榜单</strong>：flux-2-max和flux-2-pro新上榜，分别排名第8、第9</p>\n</li>\n<li>\n<p><strong>文生图能力榜单</strong>：FLUX.2 [dev]Turbo新上榜，排名第10</p>\n</li>\n<li>\n<p><strong>GAIA榜单</strong>：JoinAI V2.2登顶榜首，得分达90.7%</p>\n</li>\n</ul>\n<h3 id=\"4-排行榜\">4. 排行榜</h3>\n<table>\n<thead>\n<tr>\n<th>测评类型</th>\n<th>第一名</th>\n<th>第二名</th>\n<th>第三名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>模型调用量</td>\n<td>Claude Opus 4.5</td>\n<td>Claude Sonnet 4.5</td>\n<td>MiMo-V2-Flash(free)</td>\n</tr>\n<tr>\n<td>公司市占率</td>\n<td>Google</td>\n<td>Anthropic</td>\n<td>OpenAI</td>\n</tr>\n<tr>\n<td>编程模型调用量</td>\n<td>Claude Opus 4.5</td>\n<td>Grok Code Fast 1</td>\n<td>Claude Sonnet 4.5</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"各公司按不同能力领域排名汇总\">各公司按不同能力领域排名汇总</h4>\n<table>\n<thead>\n<tr>\n<th>测评类型</th>\n<th>领先公司</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>大语言模型 Text Arena</td>\n<td>Google、xAI、Anthropic、百度、OpenAI、智谱、阿里巴巴、月之暗面</td>\n</tr>\n<tr>\n<td>编程能力 LMArena</td>\n<td>Anthropic、OpenAI、Google、智谱、MiniMax</td>\n</tr>\n<tr>\n<td>编程能力 LiveCodeBench</td>\n<td>OpenAI、Anthropic、Google</td>\n</tr>\n<tr>\n<td>代码工程任务能力 SWE-benchLite</td>\n<td>基于Claude、Gemini、GPT、Qwen、DeepSeek开发的开源系统</td>\n</tr>\n<tr>\n<td>图像编辑和生成能力 Image Edit Arena</td>\n<td>OpenAI、Google、字节、Black Forest Labs、Reve</td>\n</tr>\n<tr>\n<td>文生图能力 Text-to-Image Arena</td>\n<td>OpenAI、Google、Black Forest Labs、腾讯、字节</td>\n</tr>\n<tr>\n<td>文生图能力 Text to Image Leaderboard</td>\n<td>OpenAI、Google、Black Forest Labs、字节、ImagineArt</td>\n</tr>\n<tr>\n<td>GPQA</td>\n<td>OpenAI、Google、xAI、Anthropic、阿里巴巴</td>\n</tr>\n<tr>\n<td>FrontierMath</td>\n<td>OpenAI、Google、DeepSeek、月之暗面、Anthropic、xAI</td>\n</tr>\n<tr>\n<td>Humanity's Last Exam</td>\n<td>Google、OpenAI、Anthropic</td>\n</tr>\n<tr>\n<td>GAIA</td>\n<td>JoinAI、Nvidia、Suzhou AI Lab&amp;Shuqian Tech、Microsoft AI Asia -Ads</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<p>关注我，第一时间掌握更多AI前沿资讯！</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-17 12:01</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xjk15082\">KAI智习</a>&nbsp;\n阅读(<span id=\"post_view_count\">150</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "四边形不等式相关",
      "link": "https://www.cnblogs.com/rgw2010/p/19498451",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/rgw2010/p/19498451\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 14:15\">\n    <span>四边形不等式相关</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        四边形不等式相关\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"四边形不等式\">四边形不等式</h2>\n<p>我们称一个二元函数 <span class=\"math inline\">\\(w(i, j)\\)</span> 满足四边形不等式，当且仅当对于任意 <span class=\"math inline\">\\(a \\le b \\le c \\le d\\)</span> 满足：</p>\n<p></p><div class=\"math display\">\\[w(a, c) + w(b, d) \\le w(a, d) + w(b, c)\n\\]</div><p></p><p>即交叉小于包含。</p>\n<p>其可以用来对转移进行优化，具体的，设：</p>\n<p></p><div class=\"math display\">\\[f(i) = \\min_{j \\le i} w(j, i)\n\\]</div><p></p><p>定义 <span class=\"math inline\">\\(\\operatorname{opt}(i)\\)</span> 表示计算 <span class=\"math inline\">\\(f(i)\\)</span> 时最优的那个决策点 <span class=\"math inline\">\\(j\\)</span>，称其满足<strong>决策单调性</strong>当且仅当对于任意 <span class=\"math inline\">\\(i &lt; j\\)</span> 满足 <span class=\"math inline\">\\(\\operatorname{opt}(i) \\le \\operatorname{opt}(j)\\)</span>。</p>\n<p><strong>性质 <span class=\"math inline\">\\(1\\)</span>：</strong></p>\n<blockquote>\n<p>若 <span class=\"math inline\">\\(w(i, j)\\)</span> 满足四边形不等式，则 <span class=\"math inline\">\\(f(i)\\)</span> 满足决策单调性。</p>\n</blockquote>\n<p>考虑反证法，若存在 <span class=\"math inline\">\\(i &lt; j\\)</span> 且 <span class=\"math inline\">\\(x = \\operatorname{opt}(i) &gt; y = \\operatorname{opt}(j)\\)</span>，那么根据定义有 <span class=\"math inline\">\\(w(x, j) \\ge w(y, j), w(y, i) \\ge w(x, i)\\)</span>，于是 <span class=\"math inline\">\\(w(x, j) + w(y, i) \\ge w(y, j) + w(x, i)\\)</span>，违反了四边形不等式，于是得证。</p>\n<p><strong>性质 <span class=\"math inline\">\\(2\\)</span>：</strong></p>\n<blockquote>\n<p>如果对于任意 <span class=\"math inline\">\\(i, j\\)</span> 满足 <span class=\"math inline\">\\(w(i, j) + w(i + 1, j + 1) \\le w(i, j + 1) + w(i + 1, j)\\)</span>，那么 <span class=\"math inline\">\\(w\\)</span> 满足四边形不等式。</p>\n</blockquote>\n<p>证明比较显然，考虑 <span class=\"math inline\">\\(w(i + 1, j) + w(i, j + 1) - w(i, j) - w(i + 1, j + 1) \\ge 0\\)</span>，这表示 <span class=\"math inline\">\\(w\\)</span> 的二维差分矩阵非负；于是考察其二维差分矩阵上一个子矩阵 <span class=\"math inline\">\\((b + 1, d + 1), (a, c)\\)</span> 的和必然也非负，即 <span class=\"math inline\">\\(w(a, d) - w(a, c) - w(b, d) + w(b, c) \\ge 0\\)</span>，这是四边形不等式的定义。</p>\n<hr />\n<p>上面那个决策单调性太特殊了，只对 <span class=\"math inline\">\\(f(i) = \\min w(j, i)\\)</span> 生效，感觉没有什么实际用途，一般都是这种问题：将序列分段使得权值最小，即：</p>\n<p></p><div class=\"math display\">\\[f(i) = \\min_{j \\le i} f(j - 1) + w(j, i)\n\\]</div><p></p><p>这种怎么办？考虑：</p>\n<p><strong>性质 <span class=\"math inline\">\\(3\\)</span>：</strong></p>\n<blockquote>\n<p>若 <span class=\"math inline\">\\(w(i, j)\\)</span> 满足四边形不等式，则 <span class=\"math inline\">\\(w(i, j) = x_i + y_j\\)</span> 也满足。</p>\n</blockquote>\n<p>这是显然的，带入进去把 <span class=\"math inline\">\\(x, y\\)</span> 都消掉了。</p>\n<p>于是只需要 <span class=\"math inline\">\\(w(i, j)\\)</span> 满足四边形不等式，则上面 <span class=\"math inline\">\\(f(i)\\)</span> 的转移也满足决策单调性。</p>\n<p>如果强制钦定了要分 <span class=\"math inline\">\\(k\\)</span> 段，可以根据情况使用 wqs 二分或者多加一维解决。</p>\n<hr />\n<p>考虑 <span class=\"math inline\">\\(w(l, r)\\)</span> 可能是 <span class=\"math inline\">\\(\\sum_{l \\le i \\le j \\le r} c(i, j)\\)</span> 的形式：</p>\n<p><strong>性质 <span class=\"math inline\">\\(4\\)</span>：</strong></p>\n<blockquote>\n<p>若 <span class=\"math inline\">\\(c(i, j) \\ge 0\\)</span>，则 <span class=\"math inline\">\\(w(l, r) = \\sum_{l \\le i \\le j \\le r} c(i, j)\\)</span> 满足四边形不等式。</p>\n</blockquote>\n<p>考虑证明 <span class=\"math inline\">\\(w(x, y) + w(x + 1, y + 1) \\le w(x, y + 1) + w(x + 1, y)\\)</span>，考虑拆贡献 <span class=\"math inline\">\\(x + 1 \\le i \\le j \\le y\\)</span> 的 <span class=\"math inline\">\\((i, j)\\)</span> 对两边贡献是相同的，然后左边是 <span class=\"math inline\">\\(\\sum_{i = x, j \\in [x, y]} c_{i, j} + \\sum_{i \\in [x + 1, y + 1], j = y + 1} c_{i, j}\\)</span>，然后右边 <span class=\"math inline\">\\(w(x, y + 1)\\)</span> 去掉 <span class=\"math inline\">\\(x + 1 \\le i \\le j \\le y\\)</span> 的 <span class=\"math inline\">\\((i, j)\\)</span> 后是 <span class=\"math inline\">\\(\\sum_{i = x,j \\in [x, y + 1]} c(i, j) + \\sum_{i \\in [x, y + 1], j = y + 1} c(i, j)\\)</span>，于是右边多考虑了 <span class=\"math inline\">\\(c(x, y + 1)\\)</span>，得证。</p>\n<h3 id=\"例题\">例题</h3>\n<h3 id=\"p1880-noi1995-石子合并\"><a href=\"https://www.luogu.com.cn/problem/P1880\" rel=\"noopener nofollow\" target=\"_blank\">P1880 [NOI1995] 石子合并</a></h3>\n<p>考虑区间 dp，定义 <span class=\"math inline\">\\(dp(l, r)\\)</span> 表示将区间 <span class=\"math inline\">\\([l, r]\\)</span> 合并的最小代价，于是有转移：</p>\n<p></p><div class=\"math display\">\\[dp(l, r) = (s_r - s_{l - 1}) + \\min\\limits_{k = l}^{r - 1} (dp(l, k) + dp(k + 1, r))\n\\]</div><p></p><p>钦定 <span class=\"math inline\">\\(l\\)</span> 固定时，有 <span class=\"math inline\">\\(w(i, j) = dp(l, i) + dp(i + 1, j)\\)</span> ，考虑证明 <span class=\"math inline\">\\(w(i, j)\\)</span> 满足四边形不等式，你推下式子发现等价于证明 <span class=\"math inline\">\\(dp(i, j)\\)</span> 满足四边形不等式。</p>\n<p>这里 <span class=\"math inline\">\\(dp(i, j)\\)</span> 满足四边形不等式的充要条件是 <span class=\"math inline\">\\(h(i, j) = s_i - s_{j - 1}\\)</span> 也满足四边形不等式且满足区间包含单调性，可以对长度数学归纳发得到。</p>\n<p>然后你发现上面固定右端点 <span class=\"math inline\">\\(r\\)</span> 时也有决策单调性，于是有 <span class=\"math inline\">\\(\\operatorname{opt}(l, r) \\in [\\operatorname{opt}(l, r - 1), \\operatorname{opt}(l + 1, r)]\\)</span>，所以这样枚举决策点时间复杂度就是 <span class=\"math inline\">\\(O(n^2)\\)</span> 的。</p>\n<p><a href=\"https://www.luogu.com.cn/record/257701529\" rel=\"noopener nofollow\" target=\"_blank\">link</a></p>\n<p>于是可以得到<strong>性质 <span class=\"math inline\">\\(5\\)</span></strong>：</p>\n<blockquote>\n<p>设 <span class=\"math inline\">\\(w(l, r)\\)</span> 满足四边形不等式且满足区间包含单调性，若 <span class=\"math inline\">\\(dp(l, r) = w(l, r) + \\min\\limits_{k = l}^{r - 1} (dp(l, k) + dp(k + 1, r))\\)</span>，那么 <span class=\"math inline\">\\(dp(l, r)\\)</span> 也满足四边形不等式；且固定 <span class=\"math inline\">\\(l\\)</span> 或者固定 <span class=\"math inline\">\\(r\\)</span> 时都满足决策单调性，即 <span class=\"math inline\">\\(\\operatorname{opt}(l, r) \\in [\\operatorname{opt}(l, r - 1), \\operatorname{opt}(l + 1, r)]\\)</span>。</p>\n</blockquote>\n<p><a href=\"https://www.luogu.com.cn/problem/UVA10304\" rel=\"noopener nofollow\" target=\"_blank\">类似题目 UVA10304 Optimal Binary Search Tree</a>。</p>\n<h3 id=\"cf868f-yet-another-minimization-problem\"><a href=\"https://www.luogu.com.cn/problem/CF868F\" rel=\"noopener nofollow\" target=\"_blank\">CF868F Yet Another Minimization Problem</a></h3>\n<p>考虑 <span class=\"math inline\">\\(c(i, j) = [a_i = a_j]\\)</span>，那么 <span class=\"math inline\">\\(w(l, r) = \\sum_{l \\le i \\le j \\le r} c(i, j)\\)</span> 满足四边形不等式，于是 <span class=\"math inline\">\\(dp\\)</span> 时：</p>\n<p></p><div class=\"math display\">\\[dp_{i, j} = \\min_{k \\le i} dp_{k - 1, j - 1} + w(k, i)\n\\]</div><p></p><p>这个最优决策 <span class=\"math inline\">\\(k\\)</span> 具有单调性；考虑用分治与整体二分的思想解决。</p>\n<p>即我们定义 <span class=\"math inline\">\\(solve(l, r, kl, kr)\\)</span> 表示目前在转移 <span class=\"math inline\">\\([l, r]\\)</span> 内的点，其最优决策点在 <span class=\"math inline\">\\([kl, kr]\\)</span> 内；那么可以暴力算出 <span class=\"math inline\">\\(mid\\)</span> 的最优决策点 <span class=\"math inline\">\\(kmid\\)</span>，然后递归到 <span class=\"math inline\">\\(solve(l, mid - 1, kl, kmid), solvew(mid + 1, r, kmid, kr)\\)</span>；显然递归层数使用 <span class=\"math inline\">\\(\\log n\\)</span> 层，且每层 <span class=\"math inline\">\\([kl, kr]\\)</span> 的总长度是 <span class=\"math inline\">\\(O(n)\\)</span> 级别的，于是单次时间复杂度是 <span class=\"math inline\">\\(O(n \\log n)\\)</span>。</p>\n<p>现在问题在于如何快速算 <span class=\"math inline\">\\(w(l, r)\\)</span>，你考虑用类似莫队的走指针方式解决，你发现每次移动的长度是 <span class=\"math inline\">\\(O(len)\\)</span> 级别的，于是最终是 <span class=\"math inline\">\\(O(n \\log n)\\)</span> 次。</p>\n<p>总时间复杂度为 <span class=\"math inline\">\\(O(nk \\log n)\\)</span>。</p>\n<p><a href=\"https://codeforces.com/contest/868/submission/358031012\" rel=\"noopener nofollow\" target=\"_blank\">link</a></p>\n<h3 id=\"p3515-poi-2011-lightning-conductor\"><a href=\"https://www.luogu.com.cn/problem/P3515\" rel=\"noopener nofollow\" target=\"_blank\">P3515 [POI 2011] Lightning Conductor</a></h3>\n<p>这题你推一下式子，若对于 <span class=\"math inline\">\\(i\\)</span> 的答案是 <span class=\"math inline\">\\(k\\)</span>，那么要对于所有 <span class=\"math inline\">\\(j\\)</span> 满足：</p>\n<p></p><div class=\"math display\">\\[k + h_i \\ge h_j + \\sqrt{|i - j|}\n\\]</div><p></p><p></p><div class=\"math display\">\\[k \\ge h_j + \\sqrt{|i - j}| - h_i\n\\]</div><p></p><p>于是：</p>\n<p></p><div class=\"math display\">\\[k = \\lceil\\max_{j} h_j + \\sqrt{|i - j|} \\rceil - h_i\n\\]</div><p></p><p>考虑怎么算 <span class=\"math inline\">\\(h_j + \\sqrt{|i - j|}\\)</span>，这里分讨 <span class=\"math inline\">\\(j &lt; i\\)</span> 和 <span class=\"math inline\">\\(j &gt; i\\)</span> 两种情况算就可以去掉绝对值，然后 <span class=\"math inline\">\\(w(i, j) = \\sqrt{i - j}\\)</span>，容易发现 <span class=\"math inline\">\\(w\\)</span> 满足四边形不等式，于是有决策单调性。</p>\n<p>于是分治解决即可，时间复杂度为 <span class=\"math inline\">\\(O(n \\log n)\\)</span>。</p>\n<p><a href=\"https://www.luogu.com.cn/record/257708247\" rel=\"noopener nofollow\" target=\"_blank\">link</a></p>\n<h3 id=\"p4767-ioi-2000-邮局-加强版\"><a href=\"https://www.luogu.com.cn/problem/P4767\" rel=\"noopener nofollow\" target=\"_blank\">P4767 [IOI 2000] 邮局 加强版</a></h3>\n<p>显然对于每个设立的邮局，到其距离最近的村庄集合是集合，于是可以设立状态 <span class=\"math inline\">\\(dp_{i, j}\\)</span> 表示考虑前 <span class=\"math inline\">\\(i\\)</span> 个村庄放了 <span class=\"math inline\">\\(j\\)</span> 个邮局的最小代价：</p>\n<p></p><div class=\"math display\">\\[dp_{i, j} = \\min\\limits_{k &lt; i} dp_{k, j - 1} + w(k + 1, i)\n\\]</div><p></p><p>其中 <span class=\"math inline\">\\(w(l, r)\\)</span> 表示在区间 <span class=\"math inline\">\\([l, r]\\)</span> 内放一个邮局的最小代价，显然将邮局放在中位数位置最优，于是可以增量递推：</p>\n<p></p><div class=\"math display\">\\[w(l, r) = w(l, r - 1) + a_r - a_{\\frac{l + r}{2}}\n\\]</div><p></p><p>你发现 <span class=\"math inline\">\\(w\\)</span> 满足四边形不等式，于是我们按照 <span class=\"math inline\">\\(j\\)</span> 分层每层分治计算即可，时间复杂度为 <span class=\"math inline\">\\(O(nk \\log n)\\)</span>.</p>\n<p><a href=\"https://www.luogu.com.cn/record/257712110\" rel=\"noopener nofollow\" target=\"_blank\">link</a></p>\n<blockquote>\n<p>这里证明一下上面的 <span class=\"math inline\">\\(w\\)</span> 满足四边形不等式，即 <span class=\"math inline\">\\(w(i, j) + w(i + 1, j + 1) \\le w(i, j + 1) + w(i + 1, j)\\)</span>；首先注意到 <span class=\"math inline\">\\([i, j + 1]\\)</span> 与 <span class=\"math inline\">\\([i + 1, j]\\)</span> 的中位数一样，设为 <span class=\"math inline\">\\(k\\)</span>；</p>\n<p>那么 <span class=\"math inline\">\\(w(i, j + 1) = w(i + 1, j) + a_k - a_i + a_{j + 1} - a_k = w(i + 1, j) + a_{j + 1} - a_i\\)</span>，于是 <span class=\"math inline\">\\(w(i, j + 1) + w(i + 1, j) = 2w(i + 1, j) + a_{j + 1} - a_i\\)</span>。</p>\n<p>然后根据 <span class=\"math inline\">\\(w\\)</span> 的最小性的定义，可以得到 <span class=\"math inline\">\\(w(i, j) \\le w(i + 1, j) + a_k - a_i, w(i + 1, j + 1) \\le w(i + 1, j) + a_{j + 1} - a_k\\)</span>，于是 <span class=\"math inline\">\\(w(i, j) + w(i + 1, j + 1) \\le 2w(i + 1, j) + a_{j + 1} - a_i = w(i, j + 1) + w(i + 1, j)\\)</span> 得证。</p>\n</blockquote>\n<h3 id=\"p10861-hbcpc2024-macaron-likes-happy-endings\"><a href=\"https://www.luogu.com.cn/problem/P10861\" rel=\"noopener nofollow\" target=\"_blank\">P10861 [HBCPC2024] MACARON Likes Happy Endings</a></h3>\n<p><a href=\"https://www.luogu.com.cn/article/rp1evt7i\" rel=\"noopener nofollow\" target=\"_blank\"><strong>洛谷同步题解。</strong></a></p>\n<p>令 <span class=\"math inline\">\\(s\\)</span> 为前缀异或，那么 <span class=\"math inline\">\\(c(i, j) = [s_j \\oplus s_{i - 1} = d] \\ge 0\\)</span>，于是 <span class=\"math inline\">\\(w(l, r) = \\sum_{l \\le i \\le j \\le r}\\)</span> 满足四边形不等式，于是 <span class=\"math inline\">\\(dp\\)</span> 时：</p>\n<p></p><div class=\"math display\">\\[dp_{i, j} = \\min_{k \\le i} dp_{k - 1, j - 1} + w(k, i)\n\\]</div><p></p><p>然后分治去做，计算 <span class=\"math inline\">\\(w(k, i)\\)</span> 可以简单走指针计算，于是时间复杂度是 <span class=\"math inline\">\\(O(nk \\log n)\\)</span> 的。</p>\n<p><a href=\"https://www.luogu.com.cn/record/258048999\" rel=\"noopener nofollow\" target=\"_blank\">link</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 14:15</span>&nbsp;\n<a href=\"https://www.cnblogs.com/rgw2010\">rgw2010</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}