{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "构建基于 cc-switch 与 sdcb/chats 的AI 编程基础设施",
      "link": "https://www.cnblogs.com/shanyou/p/19527405",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/shanyou/p/19527405\" id=\"cb_post_title_url\" title=\"发布于 2026-01-25 09:24\">\n    <span>构建基于 cc-switch 与 sdcb/chats 的AI 编程基础设施</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        通过将&nbsp;cc-switch&nbsp;的客户端编排能力与&nbsp;sdcb/chats&nbsp;的网关处理能力相结合，我们构建了一个强大、灵活且安全可控的本地 AI 开发环境。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1>1. 摘要</h1>\n<p><span>在生成式人工智能（Generative AI）技术从实验室走向生产环境的过程中，企业与开发者面临着前所未有的基础设施挑战。随着大型语言模型（LLM）能力的指数级增长，特别是具备长上下文窗口和复杂推理能力的模型（如 Claude 4.5 Sonnet、GPT-5.2）的普及，传统的 API 直接调用模式已难以满足安全合规、成本控制及多环境管理的复杂需求。当前，一种“客户端-网关-模型”的三层架构正在成为业界构建本地化 AI 开发环境的标准范式。本文将深入剖析这一架构的具体实现，重点阐述如何利用 <strong>cc-switch</strong> 作为客户端配置编排中枢，通过统一的自定义协议连接至 <strong>sdcb/chats</strong> 这一高性能自托管 AI 网关，从而构建出一套既具备极高灵活性又能确保数据主权的完整生态系统。</span></p>\n<p><span>本文的核心价值在于解决了当前 AI 辅助编程（Agentic Coding）领域的一大痛点：工具链的碎片化。开发者常用的 CLI 工具（如 Claude Code、Codex）往往绑定特定的云端接入点，导致在内网环境、中转加速或多模型切换场景下配置繁琐且易出错。<strong>cc-switch</strong> 的出现，特别是其 v3.8.0 版本引入的 SQLite 持久化架构，为管理复杂的环境变量注入提供了原子级的稳定性保障。与此同时，<strong>sdcb/chats</strong> 在 v1.9.0 版本中对 Anthropic Messages API 的原生级支持（包括 Thinking 区块与签名验证），使其成为不仅是 UI 前端，更是企业级 API 网关的理想选择。 </span></p>\n<h1><span>2. 客户端架构深度解析：cc-switch 的演进与机制</span></h1>\n<p><span>作为整个链路的入口，客户端配置管理工具的稳定性直接决定了开发体验的流畅度。<strong>cc-switch</strong>（Claude Configuration Switch）并非简单的 Shell 脚本封装，而是一个基于 Rust 和 Tauri 构建的跨平台桌面应用，其设计哲学是在不侵入用户系统全局环境的前提下，实现应用级的上下文切换。</span></p>\n<h2><span>2.1 技术栈与架构选型</span></h2>\n<p><span><strong>cc-switch</strong> 采用了 Tauri 框架，这是一种追求极致轻量化和安全性的架构选择。与 Electron 动辄数百兆的内存占用不同，Tauri 利用操作系统的原生 WebView（macOS 上的 WebKit，Windows 上的 WebView2，Linux 上的 WebKitGTK）进行渲染，而后端逻辑则由高性能的 Rust 语言处理。这种架构使得 cc-switch 能够常驻系统托盘而几乎不消耗系统资源，这对于需要在后台静默监控环境变量冲突的工具至关重要。</span></p>\n<p><span>在 v3.8.0 版本之前，cc-switch 依赖于单一的 config.json 文件进行数据存储。随着用户对多端同步和复杂配置（如自定义 MCP 服务器、Prompt 模板）需求的增加，JSON 文件的局限性日益凸显——缺乏事务支持、并发写入风险以及查询效率低下。v3.8.0 引入的 <strong>SQLite + JSON 双层持久化架构</strong> 是其发展史上的重要里程碑 <sup>1</sup>。</span></p>\n<h6><span>表 2.1 cc-switch 双层持久化架构对比分析</span></h6>\n<table border=\"1\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody>\n<tr>\n<td valign=\"top\" width=\"104\">\n<p><strong><span>特性维度</span></strong></p>\n</td>\n<td valign=\"top\" width=\"158\">\n<p><span><strong>JSON </strong><strong>层 (Device-Level)</strong></span></p>\n</td>\n<td valign=\"top\" width=\"145\">\n<p><span><strong>SQLite </strong><strong>层 (Syncable Data)</strong></span></p>\n</td>\n<td valign=\"top\" width=\"217\">\n<p><strong><span>架构意义</span></strong></p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"104\">\n<p><strong><span>存储内容</span></strong></p>\n</td>\n<td valign=\"top\" width=\"158\">\n<p><span>窗口位置、本地路径覆盖、当前选中 ID</span></p>\n</td>\n<td valign=\"top\" width=\"145\">\n<p><span>供应商配置、MCP 服务器、Prompts、Skills</span></p>\n</td>\n<td valign=\"top\" width=\"217\">\n<p><span>实现“数据跟随账户，状态跟随设备”的分离策略</span></p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"104\">\n<p><strong><span>同步策略</span></strong></p>\n</td>\n<td valign=\"top\" width=\"158\">\n<p><span>本地保留，不参与云同步</span></p>\n</td>\n<td valign=\"top\" width=\"145\">\n<p><span>支持全量/增量同步（未来规划）</span></p>\n</td>\n<td valign=\"top\" width=\"217\">\n<p><span>解决多设备间路径不一致（如 Windows vs macOS）导致的配置冲突</span></p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"104\">\n<p><strong><span>事务支持</span></strong></p>\n</td>\n<td valign=\"top\" width=\"158\">\n<p><span>无（依赖文件锁）</span></p>\n</td>\n<td valign=\"top\" width=\"145\">\n<p><span>ACID 事务支持</span></p>\n</td>\n<td valign=\"top\" width=\"217\">\n<p><span>防止在配置切换过程中因进程崩溃导致的数据损坏</span></p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"104\">\n<p><strong><span>迁移机制</span></strong></p>\n</td>\n<td valign=\"top\" width=\"158\">\n<p><span>无</span></p>\n</td>\n<td valign=\"top\" width=\"145\">\n<p><span>自动迁移引擎 (Auto Migration)</span></p>\n</td>\n<td valign=\"top\" width=\"217\">\n<p><span>首次启动自动将旧版 config.json 数据导入 SQLite，保证无缝升级</span></p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"104\">\n<p><strong><span>查询性能</span></strong></p>\n</td>\n<td valign=\"top\" width=\"158\">\n<p><span>全量加载解析</span></p>\n</td>\n<td valign=\"top\" width=\"145\">\n<p><span>索引查询</span></p>\n</td>\n<td valign=\"top\" width=\"217\">\n<p><span>极大提升了在拥有数百个 Prompt 或几十个 Provider 时的加载速度</span></p>\n</td>\n</tr>\n</tbody>\n</table>\n<h2>2.2 环境变量注入与冲突检测机制</h2>\n<p><span>cc-switch 的核心职能是充当“配置代理”。当用户在 UI 中激活某个供应商（Provider）时，它并不会修改操作系统的全局环境变量（这需要管理员权限且不仅即时生效），而是通过修改目标应用（如 Claude Code CLI）特定的配置文件或钩子脚本来实现。</span></p>\n<p><span>对于 <strong>Claude Code</strong>，cc-switch 主要管控以下核心变量：</span></p>\n<p><span>● <strong>ANTHROPIC_BASE_URL</strong>：这是实现自定义网关连接的关键。默认情况下，Claude CLI 指向 https://api.anthropic.com。cc-switch 将此值覆写为用户配置的网关地址（例如 http://localhost:8080/v1）。</span></p>\n<p><span>● <strong>ANTHROPIC_API_KEY</strong>：注入由网关颁发或管理的 API 密钥。</span></p>\n<p><span>● <strong>ANTHROPIC_DEFAULT_MODEL</strong>：虽然 Claude Code 自身具备模型协商能力，但在某些企业场景下，管理员可能强制指定模型版本（如锁定为 claude-3-5-sonnet-20240620 以控制成本）。</span></p>\n<p><span>v3.6 版本引入了 <strong>环境变量冲突检测（Environment Variable Conflict Detection）</strong> 功能。由于开发者的机器上可能同时安装了 Codex、OpenCode 和 Gemini CLI，这些工具可能通过 .env 文件或 shell profile 设定了相互冲突的变量。cc-switch 能够扫描进程树和常见的配置文件路径，识别出可能导致路由失效的“影子配置”，并向用户发出可视化警告。这种防御性编程设计极大降低了排查网络连接问题的时间成本。</span></p>\n<h5><span>2.3 Deep Link 协议与配置分发</span></h5>\n<p><span>为了便于团队内部快速分发统一的网关配置，cc-switch 实现了自定义 URL Scheme 协议 ccswitch://。这一机制允许管理员生成一个包含网关地址、加密后的 API Key 占位符以及必要参数的链接。 当开发者点击该链接时，操作系统唤起 cc-switch，并自动触发 <strong>Import Provider</strong> 流程。这不仅简化了入职配置流程，还确保了所有团队成员连接的是同一个服务端点，避免了手动输入 URL 带来的拼写错误风险。结合 SQLite 的结构化存储，这些导入的配置被安全地存入 providers 表中，并通过 atomic writes 机制防止写入中断。</span></p>\n<h1>3. 服务端架构深度解析：sdcb/chats 的网关哲学</h1>\n<p><span>如果说 cc-switch 是精密的指挥官，那么 <strong>sdcb/chats</strong> 就是强大的重型机械。作为一个基于.NET 10 构建的自托管 AI 网关与前端，它在性能、兼容性和扩展性上展现出了企业级的水准。</span></p>\n<h2><span>3.1.NET 10 高性能运行时</span></h2>\n<p><span>选择.NET 10（及之前的.NET 8/9 迭代）作为运行时环境，赋予了 sdcb/chats 显著的性能优势。相较于 Python 编写的网关（受限于 GIL 全局解释器锁）或 Node.js 网关（在高计算密集型任务下的瓶颈），C# 的强类型系统和先进的 JIT（Just-In-Time）编译器使得 sdcb/chats 能够在处理大量并发 WebSocket 连接和流式（Server-Sent Events, SSE）转发时保持极低的延迟。</span></p>\n<p><span>特别是在处理 <strong>Token 计数</strong> 和 <strong>流式响应解析</strong> 时，sdcb/chats 利用了.NET 的 Span&lt;T&gt; 和 Memory&lt;T&gt; 等零拷贝技术，大幅减少了内存分配，这对于需要长时间维持会话状态的 AI Agent 场景至关重要。</span></p>\n<h2>3.2 协议兼容性：Anthropic Messages API 的逆向与重构</h2>\n<p><span>在 v1.9.0 版本之前，大多数开源网关仅支持 OpenAI 的 Chat Completions API (/v1/chat/completions)。然而，随着 Claude 3.5 的发布及其配套工具 Claude Code 的流行，仅支持 OpenAI 协议已无法满足需求。Claude Code 严格依赖 Anthropic 的原生协议格式，特别是其独特的 <strong>Messages API</strong> (/v1/messages)。</span></p>\n<p><span>sdcb/chats 在 v1.9.0 中实现了一个里程碑式的突破：<strong>全栈兼容 Anthropic 协议</strong>。这不仅仅是 URL 路由的映射，更涉及深层的数据结构转换 ：</span></p>\n<p><span>● <strong>Thinking Block</strong><strong>（思维链）支持</strong>：Claude 的推理模型（如 Claude 3.7 Sonnet）在输出最终代码前，会先输出一段 &lt;thinking&gt; 标签包裹的思维过程。普通的 OpenAI 兼容网关往往会将其视为普通文本直接返回，或者错误地截断。sdcb/chats 引入了 StepContentThink 数据库表，专门用于存储和结构化展示这一过程，确保客户端能正确渲染“思考中...”的状态，而不是展示一堆乱码。</span></p>\n<p><span>● <strong>Signature</strong><strong>（签名）验证</strong>：Anthropic 的 API 在某些高安全模式下会返回签名字段以验证内容的完整性。sdcb/chats 的后端架构重构了 ChatService，支持这一签名流的透传与存储，确保了与官方 API 的行为一致性。</span></p>\n<p><span>● <strong>原生 HttpClient 重写</strong>：为了适配 Claude 的流式传输特性，后端核心组件 AnthropicChatService 使用原生 HttpClient 进行了重写（涉及约 969 行代码变动），摒弃了可能存在兼容性问题的第三方 SDK 封装，从而支持了 JsonPolymorphic 属性来精确处理各种流式事件 <sup><ins datetime=\"2026-01-24T19:37\">3</ins></sup>。</span></p>\n<h2>3.3 数据持久化与多数据库支持</h2>\n<p><span>作为企业级网关，数据的可靠性是底线。sdcb/chats 提供了极其灵活的数据库适配方案：</span></p>\n<p><span>● <strong>SQLite</strong>：默认配置，适合个人开发者或小团队快速部署。无需安装额外服务，数据库仅为一个 .db 文件，备份极其方便 <sup>7</sup>。</span></p>\n<p><span>● <strong>PostgreSQL / SQL Server</strong>：针对需要高并发写入、读写分离或高级报表功能的企业环境。sdcb/chats 的 ORM 层设计允许通过简单的环境变量 DBType 切换底层存储引擎，而无需修改代码 <sup>8</sup>。 这种灵活性使得从个人笔记本上的验证原型（PoC）平滑迁移到基于 Kubernetes 的生产集群成为可能。</span></p>\n<h1><span>4. 集成实施指南：从部署到联调</span></h1>\n<p><span>本节将提供详尽的分步操作指南，指导如何将 cc-switch 连接到 sdcb/chats。我们将假设读者具备基本的 Docker 和命令行操作能力。</span></p>\n<h2>4.1 第一阶段：部署网关 (sdcb/chats)</h2>\n<p><span>由于 sdcb/chats 提供了官方 Docker 镜像，这是最推荐的部署方式，能够屏蔽不同操作系统（Linux/Windows/macOS）带来的环境差异。</span></p>\n<h3><span>4.1.1 Docker Compose 编排</span></h3>\n<p><span>为了确保配置的可维护性，建议使用 docker-compose.yml 而非单行 docker run 命令。以下是一个经过生产环境验证的配置模板：</span></p>\n<p><span>services:</span></p>\n<p><span>sqlserver:</span></p>\n<p><span>image: mcr.microsoft.com/mssql/server:2025-latest</span></p>\n<p><span>container_name: chats-sqlserver</span></p>\n<p><span>environment:</span></p>\n<p><span>ACCEPT_EULA: \"Y\"</span></p>\n<p><span>MSSQL_SA_PASSWORD: \"xxxxxx\"</span></p>\n<p><span>MSSQL_PID: \"Developer\"</span></p>\n<p><span>ports:</span></p>\n<p><span>- \"1433:1433\"</span></p>\n<p><span>volumes:</span></p>\n<p><span>- sqlserver_data:/var/opt/mssql</span></p>\n<p><span>restart: unless-stopped</span></p>\n<p><span>chats:</span></p>\n<p><span>image: sdcb/chats:1.10</span></p>\n<p><span>container_name: sdcb-chats</span></p>\n<p><span>depends_on:</span></p>\n<p><span>- sqlserver</span></p>\n<p><span>environment:</span></p>\n<p><span>DBType: \"sqlserver\"</span></p>\n<p><span>ConnectionStrings__ChatsDB: \"Server=sqlserver;Database=ChatsDB;User Id=sa;Password=xxxxxx;TrustServerCertificate=True;Encrypt=False\"</span></p>\n<p><span>ports:</span></p>\n<p><span>- \"8080:8080\"</span></p>\n<p><span>volumes:</span></p>\n<p><span>- ./AppData:/app/AppData</span></p>\n<p><span>restart: unless-stopped</span></p>\n<p><span>volumes:</span></p>\n<p><span>sqlserver_data:</span></p>\n<p><strong><span>关键配置解析：</span></strong></p>\n<p><span>● <strong>端口映射</strong>：80:8080。注意，容器内部通常监听 8080 端口，而我们将外部访问端口设为 8080。这个 <strong>8080</strong> 就是后续在 cc-switch 中配置的端口 。</span></p>\n<p><span>● <strong>数据卷</strong>：./app_data:/app/AppData。这是必须的配置。如果不挂载此卷，容器重启后，所有的 API Key、用户数据和聊天记录将全部丢失。</span></p>\n<p><span>● <strong>数据库类型</strong>：显式指定 DBType=sqlserver 能够避免程序在启动时猜测数据库类型，加快启动速度。</span></p>\n<p><span>启动服务：</span></p>\n<p><span>docker-compose up -d</span></p>\n<p><span>启动后，通过浏览器访问 http://localhost:8080，如果能看到登录界面，说明网关已正常运行。</span></p>\n<h3>4.1.2 API 密钥生成与权限管控</h3>\n<p><span>在将网关暴露给客户端之前，必须配置鉴权机制。sdcb/chats v1.9.0 引入了专门的 <strong>Build（开发者）</strong> 模块 。</span></p>\n<p><span>1. <strong>管理员登录</strong>：使用初始账号登录系统。</span></p>\n<p><span>2. <strong>进入开发者中心</strong>：点击导航栏的“API” 菜单。</span></p>\n<p><span>3. <strong>密钥管理</strong>：选择“API Key”。</span></p>\n<p><span>4. <strong>创建密钥</strong>：点击“Create New Key”。建议为每个客户端（如“Laptop-Claude-Code”）创建一个独立的 Key，并设置合理的过期时间（如 90 天）。</span></p>\n<p><span>5. <strong>复制密钥</strong>：系统生成的密钥（例如 sk-sdcb-8f7a...）仅在创建时显示一次，务必妥善保存。该密钥将用于 cc-switch 的鉴权。</span></p>\n<h2>4.2 第二阶段：配置客户端 (cc-switch)</h2>\n<p><span>回到客户端机器，我们将利用 cc-switch 的自定义提供商功能来接入刚刚搭建的网关。</span></p>\n<h3>4.2.1 添加自定义提供商 (Custom Provider)</h3>\n<p><span>打开 cc-switch 主界面：</span></p>\n<p><span>1. 点击右上角的 <strong>Add Provider (+)</strong> 按钮。</span></p>\n<p><span>2. 在弹出的配置窗口中，<strong>Schema</strong> 类型的选择至关重要。</span></p>\n<p><span>○ <strong>Provider Name</strong>: 输入易于识别的名称，例如 Local-Gateway 或 Sdcb-Dev。</span></p>\n<p><span>○ <strong>API Key</strong>: 粘贴在 4.1.2 步骤中生成的 sk-sdcb-... 密钥。</span></p>\n<p><span>○ <strong>API URL (Base URL)</strong>: 这是最容易出错的环节。</span></p>\n<p><span>■ 根据 sdcb/chats 的文档和 Anthropic SDK 的规范，Base URL 通常指向 API 的根路径。</span></p>\n<p><span>■ <strong>推荐配置</strong>: http://localhost:8080</span></p>\n<p><span>■ <strong>原理解析</strong>: Claude Code 的 SDK 会自动在 Base URL 后追加 /v1/messages。如果你配置成 http://localhost:8080/v1，SDK 可能会请求 http://localhost:8080/v1/v1/messages 导致 404 错误。反之，如果 SDK 较为“智能”地去除了末尾斜杠，配置为 http://localhost:8080/v1 也是可行的。建议先尝试根路径。</span></p>\n<p><span><del datetime=\"2026-01-24T19:37\"><img alt=\"表格\n\nAI 生成的内容可能不正确。\" height=\"341\" src=\"https://img2024.cnblogs.com/blog/510/202601/510-20260125092333153-1660708092.png\" width=\"624\" /></del><del datetime=\"2026-01-24T19:37\"></del></span></p>\n<h3>4.2.2 连通性测试 (Speed Test)</h3>\n<p><span>配置完成后，不要急于启用。在 Provider 列表中找到新建的 Local-Gateway：</span></p>\n<p><span>1. 点击条目右侧的 <strong>Speed Test（测速）</strong> 图标（通常是一个闪电或仪表盘图标）。</span></p>\n<p><span>2. cc-switch 会向该 URL 发送一个轻量级的 HEAD 或 GET 请求（通常是查询模型列表 /v1/models 或 /models）。</span></p>\n<p><span>3. <strong>绿色指标</strong>：表示 TCP 连接建立成功，且 HTTP 状态码正常（200 OK）。</span></p>\n<p><span>4. <strong>红色指标</strong>：表示连接失败。常见原因包括：</span></p>\n<p><span>○ Docker 容器未启动。</span></p>\n<p><span>○ 防火墙拦截了 8080 端口。</span></p>\n<p><span>○ URL 拼写错误（如多余的空格）。</span></p>\n<h2>4.3 第三阶段：全链路联调与验证</h2>\n<h6><span>4.3.1 激活与环境注入</span></h6>\n<p><span>在 cc-switch 中选中 Local-Gateway 并点击 <strong>Enable</strong>。此时，cc-switch 会将以下变量写入当前用户的 Shell 配置文件或临时的 session 变量中：<ins datetime=\"2026-01-24T19:37\"></ins></span></p>\n<p><span>export ANTHROPIC_BASE_URL=\"http://localhost:8080\"<br />export ANTHROPIC_API_KEY=\"sk-sdcb-...<ins datetime=\"2026-01-24T19:37\">\"</ins></span></p>\n<p><span><strong>注意</strong>：为了确保变量生效，建议重启终端窗口，或者在当前终端执行 source ~/.zshrc (或 .bashrc)。</span></p>\n<h6><span>4.3.2 运行 Claude Code</span></h6>\n<p><span>在终端中启动 Claude Code：<ins datetime=\"2026-01-24T19:37\"></ins></span></p>\n<p><span>claude</span></p>\n<p><span>或者使用诊断命令：<ins datetime=\"2026-01-24T19:37\"></ins></span></p>\n<p><span>claude doctor</span></p>\n<p><span>如果集成成功，doctor 命令的输出中应包含：</span></p>\n<p><span>● <strong>API Endpoint</strong>: http://localhost:8080 (Override detected)</span></p>\n<p><span>● <strong>Connection Status</strong>: OK</span></p>\n<p><span>尝试发送一个简单的指令，例如“Hello, who are you?”。</span></p>\n<p><span>● 请求路径：Claude CLI -&gt; cc-switch Env -&gt; http://localhost:8080/v1/messages</span></p>\n<p><span>● 处理逻辑：sdcb/chats 接收请求 -&gt; 鉴权通过 -&gt; 转发至后台配置的模型（如 OpenAI GPT-4o 经转换后） -&gt; 返回响应。</span></p>\n<p><span>● 响应路径：sdcb/chats 将响应转换为 Anthropic 格式（包含 content, role, id 等字段） -&gt; Claude CLI 渲染输出。</span></p>\n<h1>5. 高级特性与企业级应用场景</h1>\n<p><span>基础连接打通后，我们可以利用这一架构实现更多高级功能，充分发挥本地网关的潜力。</span></p>\n<h2>5.1 协议转换：用 OpenAI 模型驱动 Claude 工具链</h2>\n<p><span>这是一个极具吸引力的场景。由于 sdcb/chats 具备协议转换能力，我们可以在后端配置一个 OpenAI 的模型（如 gpt-4o-mini），但在前端（Claude Code）看来，它仍然是在与一个 Anthropic 模型对话。</span></p>\n<p><span><strong>实现原理</strong>：</span></p>\n<p><span>1. 在 sdcb/chats 后台，添加一个 OpenAI 提供商，并添加模型 gpt-5.2-chat，模型显示名称anthropic/claude-sonnet-4.5，让Claude Code 认为他调用的是claude-4-5-sonnet。</span></p>\n<p><span>2. 当 Claude Code 发出请求指定 model: </span><a name=\"OLE_LINK1\"></a><span>claude-</span><span>4-5-sonnet 时，网关拦截该请求，将其翻译为 OpenAI 的 Chat Completions 格式，发送给 OpenAI，收到回复后，再将 OpenAI 的 Delta 响应翻译回 Anthropic 的 Message Delta 格式。<br /><strong>价值</strong>：这允许开发者利用 Claude Code 优秀的代码交互体验（Agentic Workflow），同时利用 OpenAI 模型在某些特定任务上的优势或更低廉的价格。</span></p>\n<p><span><img alt=\"图形用户界面\n\nAI 生成的内容可能不正确。\" height=\"777\" src=\"https://img2024.cnblogs.com/blog/510/202601/510-20260125092333349-1800839900.png\" width=\"624\" /></span></p>\n<h2><span>5.2 集中化管理 MCP 服务器</span></h2>\n<p><span>Model Context Protocol (MCP) 是连接 AI 与本地数据的桥梁。在 cc-switch v3.8.0 的 SQLite 架构中，MCP 服务器的配置被集中管理 <sup>1</sup>。 <strong>工作流</strong>：</span></p>\n<p><span>1. 在 cc-switch 的 <strong>MCP Servers</strong> 标签页中，添加本地的数据库连接工具（如 sqlite-mcp）或文件系统工具。</span></p>\n<p><span>2. 这些配置被存储在 cc-switch.db 中。</span></p>\n<p><span>3. 当启用 Local-Gateway 时，cc-switch 不仅注入 API URL，还会生成对应的 claude_desktop_config.json 文件。</span></p>\n<p><span>4. <strong>关键点</strong>：sdcb/chats 网关本身<strong>不</strong>直接执行 MCP 工具。MCP 的执行仍然发生在客户端（Claude CLI）。网关的作用是传递 Tool Definition（工具定义）和 Tool Call（工具调用请求）。</span></p>\n<p><span>5. 这意味着，即使是通过网关连接，你依然可以安全地使用本地的 MCP 工具，网关只是负责文本推理，数据的实际读写由本地 CLI 进程控制，这在安全性上是一个巨大的优势。</span></p>\n<h2>5.3 审计与合规 (DLP)</h2>\n<p><span>对于企业而言，直接允许开发者连接公有云 API 存在数据泄露风险。通过 sdcb/chats 网关，企业可以实施：</span></p>\n<p><span>● <strong>敏感数据拦截</strong>：在网关层集成 PII（个人身份信息）扫描插件，阻止包含信用卡号或私钥的代码片段发送到上游模型。</span></p>\n<p><span>● <strong>成本配额</strong>：为不同部门设置不同的 Token 使用上限，防止意外的高额账单。</span></p>\n<h1>6. 故障排查与性能调优</h1>\n<p><span>在复杂的分布式系统中，故障在所难免。以下是针对该架构的深度故障排查指南。</span></p>\n<h2>6.1 常见错误代码解析</h2>\n<h6><span>404 Not Found</span></h6>\n<p><span>● <strong>现象</strong>：cc-switch 测速失败，或 Claude 提示 API 端点不可达。</span></p>\n<p><span>● <strong>原因分析</strong>：</span></p>\n<p><span>1. <strong>URL </strong><strong>路径错误</strong>：最常见。用户填写了 .../v1/messages，导致最终请求变成 .../v1/messages/v1/messages。</span></p>\n<p><span>2. <strong>网关未启动</strong>：Docker 容器挂了。</span></p>\n<p><span>● <strong>解决方案</strong>：</span></p>\n<p><span>○ 检查 cc-switch 中的 Base URL 是否精简为 http://host:port。</span></p>\n<p><span>○ 使用 docker logs sdcb-chats 查看容器日志，确认监听端口。</span></p>\n<h6><span>401 Unauthorized</span></h6>\n<p><span>● <strong>现象</strong>：连接成功，但请求被拒绝。</span></p>\n<p><span>● <strong>原因分析</strong>：</span></p>\n<p><span>1. <strong>API Key </strong><strong>错误</strong>：复制了错误的 Key，或 Key 已过期。</span></p>\n<p><span>2. <strong>Header </strong><strong>缺失</strong>：某些中间代理（Nginx）过滤掉了 x-api-key 或 anthropic-api-key 头。</span></p>\n<p><span>● <strong>解决方案</strong>：</span></p>\n<p><span>○ 在 sdcb/chats 后台重新生成 Key。</span></p>\n<p><span>○ 检查中间代理配置，确保透传所有自定义 Header。</span></p>\n<h6><span>Stream Interrupted / Thinking Block Missing</span></h6>\n<p><span>● <strong>现象</strong>：回复中断，或者明明使用的是推理模型，却看不到思考过程。</span></p>\n<p><span>● <strong>原因分析</strong>：</span></p>\n<p><span>1. <strong>网关版本过低</strong>：使用 v1.9.0 之前的版本，不支持 Thinking 字段解析。</span></p>\n<p><span>2. <strong>缓冲区配置</strong>：Nginx 等反向代理开启了 Response Buffering，导致流式数据无法实时到达客户端，直到超时。</span></p>\n<p><span>● <strong>解决方案</strong>：</span></p>\n<p><span>1. 升级 sdcb/chats 至最新版。</span></p>\n<p><span>2. 在 Nginx 配置中关闭缓冲：proxy_buffering off;。</span></p>\n<h2><span>6.2 性能调优建议</span></h2>\n<p><span>● <strong>数据库优化</strong>：如果使用 SQLite 且并发量较大，可能会遇到 database is locked 错误。建议迁移至 PostgreSQL/SQLServer。</span></p>\n<p><span>● <strong>网络延迟</strong>：尽量确保 cc-switch 和 sdcb/chats 部署在低延迟的网络环境中（如局域网）。每一毫秒的延迟在流式传输中都会被放大，影响“打字机”效果的流畅度。</span></p>\n<h4>&nbsp;</h4>\n<h1>7. 结论与展望</h1>\n<p><span>通过将 <strong>cc-switch</strong> 的客户端编排能力与 <strong>sdcb/chats</strong> 的网关处理能力相结合，我们构建了一个强大、灵活且安全可控的本地 AI 开发环境。这一架构不仅解决了 API 管理的碎片化问题，还通过中间层的引入，为未来的功能扩展（如私有模型微调接入、统一的知识库检索增强 RAG）预留了接口。</span></p>\n<p><span>随着 AI 技术的演进，<strong>“瘦客户端（CLI）+ 胖网关（Gateway）+ 强模型（Model）”</strong> 的架构将日益成为主流。<strong>cc-switch</strong> 和 <strong>sdcb/chats</strong> 作为各自领域的佼佼者，其深度集成不仅是技术上的互补，更是开源生态协作精神的体现。对于追求极致效率和数据安全的开发者与企业而言，这套方案无疑是当前最佳的实践路径之一。</span></p>\n<h2>引用的文章</h2>\n<p><span>1. cc-switch/docs/release-note-v3.8.0-en.md， </span><a href=\"https://github.com/farion1231/cc-switch/blob/main/docs/release-note-v3.8.0-en.md\" rel=\"noopener nofollow\"><span>https://github.com/farion1231/cc-switch/blob/main/docs/release-note-v3.8.0-en.md</span></a></p>\n<p><span>2. cc-switch/docs/release-note-v3.8.0-zh.md </span><a href=\"https://github.com/farion1231/cc-switch/blob/main/docs/release-note-v3.8.0-zh.md\" rel=\"noopener nofollow\"><span>https://github.com/farion1231/cc-switch/blob/main/docs/release-note-v3.8.0-zh.md</span></a></p>\n<p><span>3. chats/doc/en-US/release-notes/1.9.0.md at main， </span><a href=\"https://github.com/sdcb/chats/blob/main/doc/en-US/release-notes/1.9.0.md\" rel=\"noopener nofollow\"><span>https://github.com/sdcb/chats/blob/main/doc/en-US/release-notes/1.9.0.md</span></a></p>\n<p><span>4. README.md - farion1231/cc-switch  </span><a href=\"https://github.com/farion1231/cc-switch/blob/main/README.md\" rel=\"noopener nofollow\"><span>https://github.com/farion1231/cc-switch/blob/main/README.md</span></a></p>\n<p><span>5. CHANGELOG.md - farion1231/cc-switch， </span><a href=\"https://github.com/farion1231/cc-switch/blob/main/CHANGELOG.md\" rel=\"noopener nofollow\"><span>https://github.com/farion1231/cc-switch/blob/main/CHANGELOG.md</span></a></p>\n<p><span>6. I just released Sdcb.Chats v1.9.0, a major update to my open-source .NET AI Gateway: adds full support for Claude 4.5 (Opus/Sonnet), OpenAI Image APIs, and is now built on .NET 10 : r/dotnet - Reddit, </span><a href=\"https://www.reddit.com/r/dotnet/comments/1pc1nxd/i_just_released_sdcbchats_v190_a_major_update_to/\" rel=\"noopener nofollow\"><span>https://www.reddit.com/r/dotnet/comments/1pc1nxd/i_just_released_sdcbchats_v190_a_major_update_to/</span></a></p>\n<p><span>7. README.md - sdcb/chats， </span><a href=\"https://github.com/sdcb/chats/blob/main/README.md\" rel=\"noopener nofollow\"><span>https://github.com/sdcb/chats/blob/main/README.md</span></a></p>\n<p><span>8. sdcb/chats: User-friendly Enterprise Ready AI Interface (Supports Ollama, OpenAI API, DeepSeek...) </span><a href=\"https://github.com/sdcb/chats\" rel=\"noopener nofollow\"><span>https://github.com/sdcb/chats</span></a></p>\n<p><span>9. Publishing and exposing ports | Docker Docs </span><a href=\"https://docs.docker.com/get-started/docker-concepts/running-containers/publishing-ports/\" rel=\"noopener nofollow\"><span>https://docs.docker.com/get-started/docker-concepts/running-containers/publishing-ports/</span></a></p>\n<p><span>10. farion1231/cc-switch: A cross-platform desktop All-in-One .. </span><a href=\"https://github.com/farion1231/cc-switch\" rel=\"noopener nofollow\"><span>https://github.com/farion1231/cc-switch</span></a></p>\n<p><span>11. cc-switch/docs/release-note-v3.9.0-en.md at main </span><a href=\"https://github.com/farion1231/cc-switch/blob/main/docs/release-note-v3.9.0-en.md\" rel=\"noopener nofollow\"><span>https://github.com/farion1231/cc-switch/blob/main/docs/release-note-v3.9.0-en.md</span></a></p>\n</div>\n<div id=\"MySignature\">\n    <p>欢迎大家扫描下面二维码成为我的客户，扶你上云</p>\n<img src=\"https://images.cnblogs.com/cnblogs_com/shanyou/57459/o_220125090408_%E9%82%80%E8%AF%B7%E4%BA%8C%E7%BB%B4%E7%A0%81-258px.jpeg\" width=\"170\" />\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-25 09:24</span>&nbsp;\n<a href=\"https://www.cnblogs.com/shanyou\">张善友</a>&nbsp;\n阅读(<span id=\"post_view_count\">22</span>)&nbsp;\n评论(<span id=\"post_comment_count\">3</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "STM32之控制变量与函数的存储位置",
      "link": "https://www.cnblogs.com/lsksp/p/19527780",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lsksp/p/19527780\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 23:01\">\n    <span>STM32之控制变量与函数的存储位置</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        STM32 内存定位是优化系统性能、解决硬件兼容性问题的核心技巧，可解决 Cache 与 DMA 冲突、利用 ITCM/DTCM 提升访问速度、固定 DMA 缓冲区到合规的连续物理内存。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"stm32之控制变量与函数的存储位置\">STM32之控制变量与函数的存储位置</h1>\n<p>STM32 内存定位是优化系统性能、解决硬件兼容性问题的核心技巧，可解决 Cache 与 DMA 冲突、利用 ITCM/DTCM 提升访问速度、固定 DMA 缓冲区到合规的连续物理内存。</p>\n<h2 id=\"一变量定位方法\">一、变量定位方法</h2>\n<p>变量定位分两种方式，适配「单个变量精准定位」和「批量变量管理」场景。</p>\n<h3 id=\"方法-1attribute--内存地址单个变量\">方法 1：<strong>attribute</strong> + 内存地址（单个变量）</h3>\n<p>利用编译器<code>__attribute__((at(address)))</code>属性，直接绑定变量到指定地址，简单高效。</p>\n<pre><code class=\"language-c\">// 示例：uint32_t数组定位到0x20001000（4字节对齐）\n__ALIGNED(4) __attribute__((at(0x20001000))) uint32_t dma_buffer[1024] = {0};\n</code></pre>\n<p><strong>注意</strong>：</p>\n<ul>\n<li>地址需在芯片有效内存范围，否则触发硬件故障；</li>\n<li>满足数据对齐要求（char=1 字节、short=2 字节、int/float=4 字节、double=8 字节）；</li>\n<li>避免与系统变量 / 栈 / 堆地址重叠（可查.map 文件确认）。</li>\n</ul>\n<h3 id=\"方法-2attribute--段名--分散加载文件批量变量\">方法 2：<strong>attribute</strong> + 段名 + 分散加载文件（批量变量）</h3>\n<p>批量定位多变量时，通过「自定义段名 + 分散加载文件」实现统一管理。</p>\n<h4 id=\"1-定义带自定义段名的变量\">1. 定义带自定义段名的变量</h4>\n<pre><code class=\"language-c\">// 多DMA缓冲区归类到\"MY_DMA_BUFFER\"段\n__attribute__((section(\"MY_DMA_BUFFER\"))) uint32_t uart_dma_buf[512] = {0};\n__attribute__((section(\"MY_DMA_BUFFER\"))) uint8_t i2c_dma_buf[256] = {0};\n</code></pre>\n<h4 id=\"2-修改分散加载文件sct\">2. 修改分散加载文件（.sct）</h4>\n<pre><code class=\"language-assembly\">; STM32内存定位示例 - 分散加载文件\nLR_IROM1 0x08000000 0x00020000  {      ; Flash加载区：0x08000000~0x08020000\n    ER_IROM1 0x08000000 0x00020000  {  ; Flash执行区\n        *.o (RESET, +First)\n        *(InRoot$$Sections)\n        .ANY (+RO)\n        .ANY (+XO)\n    }\n    RW_IRAM1 0x20000000 0x00020000  {  ; 普通SRAM数据区：0x20000000~0x20020000\n        .ANY (+RW +ZI)\n    }\n    ; 自定义DMA缓冲区段：0x20005000~0x20008000（12KB）\n    RW_DMA_BUFFER 0x20005000 0x00003000  {\n        *.o (MY_DMA_BUFFER)            ; 映射MY_DMA_BUFFER段到该区域\n    }\n}\n</code></pre>\n<h2 id=\"二函数定位方法\">二、函数定位方法</h2>\n<p>核心是将高频函数放到 ITCM 等高速内存提升执行速度，逻辑与变量类似，需映射到「执行区域」。</p>\n<h3 id=\"1-单个函数定位\">1. 单个函数定位</h3>\n<p>通过<code>__attribute__((section(\"段名\")))</code>标注函数，修改分散加载文件映射到 ITCM（以 STM32H7 的 ITCM=0x00000000 为例）。</p>\n<h4 id=\"1定义带段名的函数\">（1）定义带段名的函数</h4>\n<pre><code class=\"language-c\">// PID函数归类到MY_FUNC_SECTION段\n__attribute__((section(\"MY_FUNC_SECTION\"))) float pid_calc(float target, float current)\n{\n    static float err = 0, err_last = 0;\n    float kp = 1.2, ki = 0.1, kd = 0.05;\n    err = target - current;\n    float output = kp*err + ki*(err+err_last) + kd*(err-err_last);\n    err_last = err;\n    return output;\n}\n</code></pre>\n<h4 id=\"2修改分散加载文件\">（2）修改分散加载文件</h4>\n<pre><code class=\"language-assembly\">; 含函数定位的分散加载文件\nLR_IROM1 0x08000000 0x00020000  {      ; Flash加载区\n    ER_IROM1 0x08000000 0x00020000  {  ; Flash执行区\n        *.o (RESET, +First)\n        *(InRoot$$Sections)\n        .ANY (+RO)\n        .ANY (+XO)\n    }\n    RW_IRAM1 0x20000000 0x00020000  {  ; 普通SRAM数据区\n        .ANY (+RW +ZI)\n    }\n    ; ITCM执行区：0x00000000~0x00010000（64KB）\n    ER_ITCM 0x00000000 0x00010000  {\n        *.o (MY_FUNC_SECTION)          ; 映射函数段到ITCM\n    }\n}\n</code></pre>\n<h3 id=\"2-批量函数定位\">2. 批量函数定位</h3>\n<p>将整个.c 文件的函数定位到指定区域，两种方式：</p>\n<ul>\n<li>\n<p>编译器选项（ARMCC）：添加<code>--section=.text:MY_FUNC_SECTION</code>；</p>\n</li>\n<li>\n<p>分散加载文件直接指定文件：</p>\n<pre><code class=\"language-assembly\">ER_ITCM 0x00000000 0x00010000  {\n    pid.o (+XO)  ; pid.c所有可执行代码放到ITCM\n}\n</code></pre>\n</li>\n</ul>\n<h3 id=\"3-验证方法\">3. 验证方法</h3>\n<p>编译后打开工程<code>Output</code>文件夹的.map 文件，搜索函数名（如<code>pid_calc</code>），查看<code>Base Address</code>是否为 ITCM 起始地址（如 0x00000000 开头），确认定位成功。</p>\n<h2 id=\"三实战技巧与注意事项\">三、实战技巧与注意事项</h2>\n<h3 id=\"1-内存区域选择策略\">1. 内存区域选择策略</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\">内存类型</th>\n<th style=\"text-align: center;\">适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\">DTCM</td>\n<td style=\"text-align: center;\">高频访问的全局变量（零等待周期）</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">ITCM</td>\n<td style=\"text-align: center;\">关键函数、中断服务程序</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">AXI SRAM</td>\n<td style=\"text-align: center;\">大容量 DMA 缓冲区</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">普通 SRAM</td>\n<td style=\"text-align: center;\">通用变量存储</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"2-缓存一致性处理\">2. 缓存一致性处理</h3>\n<p>使用 Cache 时，DMA 操作需保证缓存一致性：</p>\n<pre><code class=\"language-c\">// DMA发送前清理缓存\nSCB_CleanDCache_by_Addr(dma_buffer, sizeof(dma_buffer));\n\n// DMA接收后失效缓存\nSCB_InvalidateDCache_by_Addr(dma_buffer, sizeof(dma_buffer));\n</code></pre>\n<h3 id=\"3-核心注意事项\">3. 核心注意事项</h3>\n<ul>\n<li>地址越界：定位地址需匹配芯片内存范围，否则程序跑飞（核对芯片手册）；</li>\n<li>对齐错误：函数入口地址需 4 字节对齐，否则触发 HardFault 中断；</li>\n<li>Cache 一致性：Cache 区数据 / DMA 访问前需刷新缓存，避免数据错乱；</li>\n<li>段冲突：自定义段勿与系统段重叠，编译溢出需调整分散加载文件地址 / 大小。</li>\n</ul>\n<h2 id=\"总结\">总结</h2>\n<p>STM32 内存定位是解决性能与兼容性问题的关键技能：</p>\n<ol>\n<li>变量可通过<code>__attribute__((at(地址)))</code>（单个）或段名 + 分散加载文件（批量）定位；</li>\n<li>函数需标注自定义段名，映射到 ITCM 等高速内存，通过.map 文件验证；</li>\n<li>需规避地址越界、对齐错误等问题，合理选择内存区域并处理缓存一致性。</li>\n</ol>\n<p>掌握该技术可显著提升 STM32 系统性能与可靠性，是嵌入式开发者进阶的必备技能。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 23:01</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lsksp\">比特向阳</a>&nbsp;\n阅读(<span id=\"post_view_count\">23</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一天一个Python库：charset-normalizer - 自动化字符编码检测与规范化",
      "link": "https://www.cnblogs.com/min2k/p/19527462",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/min2k/p/19527462\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 20:28\">\n    <span>一天一个Python库：charset-normalizer - 自动化字符编码检测与规范化</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"charset-normalizer---自动化字符编码检测与规范化\">charset-normalizer - 自动化字符编码检测与规范化</h1>\n<h2 id=\"一什么是charset-normalizer\">一、什么是charset-normalizer？</h2>\n<p><strong>charset-normalizer</strong> 是一个用于可靠检测各种文本文件或数据块的字符编码的 Python 库。<br />\n它可以帮助你：</p>\n<ul>\n<li>自动识别未知编码的文本。</li>\n<li>规范化文本，使其在不同系统间或应用程序中保持一致，避免乱码问题。</li>\n<li>处理因编码错误导致的数据解析问题。</li>\n</ul>\n<h2 id=\"二应用场景\">二、应用场景</h2>\n<p><strong>charset-normalizer</strong> 广泛应用于以下实际场景：</p>\n<ul>\n<li><strong>数据清洗</strong>: 在处理从不同来源（如网页抓取、文件导入）获取的数据时，自动检测并统一字符编码，解决乱码问题。</li>\n<li><strong>文本处理工具</strong>: 开发文本编辑器、日志分析器或其他需要处理多种编码文本的工具时，提供强大的编码识别能力。</li>\n<li><strong>国际化应用</strong>: 确保应用程序能够正确处理和显示来自全球各地的用户输入和内容，避免因编码不兼容而出现乱码。</li>\n</ul>\n<h2 id=\"三如何安装\">三、如何安装</h2>\n<ol>\n<li>使用 pip 安装</li>\n</ol>\n<pre><code class=\"language-bash\">pip install charset-normalizer\n\n# 如果安装慢的话，推荐使用国内镜像源\npip install charset-normalizer -i https://www.python64.cn/pypi/simple/\n</code></pre>\n<ol start=\"2\">\n<li>使用 <a href=\"https://www.min2k.com/tools/python-run/\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a> 在线运行代码（无需本地安装）</li>\n</ol>\n<h2 id=\"四示例代码\">四、示例代码</h2>\n<p>检测一个未知编码的字符串的编码，并进行解码。</p>\n<pre><code class=\"language-python\">from charset_normalizer import from_bytes\n\n# 尝试检测这个可能是乱码的字节串\nunknown_bytes = b'\\xc3\\xa9l\\xc3\\xa9phant'  # 这是一个UTF-8编码的'éléphant'\n\n# 使用 from_bytes 进行编码检测和规范化\ndetection_result = from_bytes(unknown_bytes)\n\n# 获取最佳匹配的字符编码\nif detection_result:\n    best_encoding = detection_result.best().encoding\n    decoded_string = str(detection_result) # 转换为字符串，默认使用最佳编码\n    print(f\"检测到的最佳编码是: {best_encoding}\")\n    print(f\"解码后的字符串是: {decoded_string}\")\nelse:\n    print(\"未能检测到合适的编码。\")\n\n# 另外一个例子：一个简单的ASCII字符串\nascii_bytes = b'hello world'\nascii_detection = from_bytes(ascii_bytes)\n\nif ascii_detection:\n    print(f\"\\n'hello world' 的最佳编码是: {ascii_detection.best().encoding}\")\n    print(f\"'hello world' 解码后: {str(ascii_detection)}\")\nelse:\n    print(\"\\n未能检测到 'hello world' 的编码。\")\n</code></pre>\n<p>使用 <a href=\"https://www.min2k.com/tools/python-run/?code=from%20charset_normalizer%20import%20from_bytes%0A%0A%23%20%E5%B0%9D%E8%AF%95%E6%A3%80%E6%B5%8B%E8%BF%99%E4%B8%AA%E5%8F%AF%E8%83%BD%E6%98%AF%E4%B9%B1%E7%A0%81%E7%9A%84%E5%AD%97%E8%8A%82%E4%B8%B2%0Aunknown_bytes%20%3D%20b'%5Cxc3%5Cxa9l%5Cxc3%5Cxa9phant'%20%20%23%20%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AAUTF-8%E7%BC%96%E7%A0%81%E7%9A%84'%C3%A9l%C3%A9phant'%0A%0A%23%20%E4%BD%BF%E7%94%A8%20from_bytes%20%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A0%81%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%84%E8%8C%83%E5%8C%96%0Adetection_result%20%3D%20from_bytes%28unknown_bytes%29%0A%0A%23%20%E8%8E%B7%E5%8F%96%E6%9C%80%E4%BD%B3%E5%8C%B9%E9%85%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%0Aif%20detection_result%3A%0A%20%20%20%20best_encoding%20%3D%20detection_result.best%28%29.encoding%0A%20%20%20%20decoded_string%20%3D%20str%28detection_result%29%20%23%20%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E7%BC%96%E7%A0%81%0A%20%20%20%20print%28f%22%E6%A3%80%E6%B5%8B%E5%88%B0%E7%9A%84%E6%9C%80%E4%BD%B3%E7%BC%96%E7%A0%81%E6%98%AF%3A%20%7Bbest_encoding%7D%22%29%0A%20%20%20%20print%28f%22%E8%A7%A3%E7%A0%81%E5%90%8E%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%3A%20%7Bdecoded_string%7D%22%29%0Aelse%3A%0A%20%20%20%20print%28%22%E6%9C%AA%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%E5%90%88%E9%80%82%E7%9A%84%E7%BC%96%E7%A0%81%E3%80%82%22%29%0A%0A%23%20%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84ASCII%E5%AD%97%E7%AC%A6%E4%B8%B2%0Aascii_bytes%20%3D%20b'hello%20world'%0Aascii_detection%20%3D%20from_bytes%28ascii_bytes%29%0A%0Aif%20ascii_detection%3A%0A%20%20%20%20print%28f%22%5Cn'hello%20world'%20%E7%9A%84%E6%9C%80%E4%BD%B3%E7%BC%96%E7%A0%81%E6%98%AF%3A%20%7Bascii_detection.best%28%29.encoding%7D%22%29%0A%20%20%20%20print%28f%22'hello%20world'%20%E8%A7%A3%E7%A0%81%E5%90%8E%3A%20%7Bstr%28ascii_detection%29%7D%22%29%0Aelse%3A%0A%20%20%20%20print%28%22%5Cn%E6%9C%AA%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%20'hello%20world'%20%E7%9A%84%E7%BC%96%E7%A0%81%E3%80%82%22%29\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a> 在线运行这段代码，结果如下：</p>\n<pre><code class=\"language-text\">检测到的最佳编码是: utf_8\n解码后的字符串是: &lt;charset_normalizer.models.CharsetMatches object at 0x7fea543bdb40&gt;\n\n'hello world' 的最佳编码是: ascii\n'hello world' 解码后: &lt;charset_normalizer.models.CharsetMatches object at 0x7fea543bda80&gt;\n</code></pre>\n<p>使用 <a href=\"https://www.min2k.com/tools/mermaid/?code=flowchart%20TB%0A%20%20A%5B%E5%BC%80%E5%A7%8B%5D%20--%3E%20B%7B%E5%AE%9A%E4%B9%89%E5%AD%97%E8%8A%82%E4%B8%B2%20unknown_bytes%7D%3B%0A%20%20B%20--%3E%20C%5B%E8%B0%83%E7%94%A8%20from_bytes%28unknown_bytes%29%5D%3B%0A%20%20C%20--%3E%20D%7B%E6%A3%80%E6%B5%8B%E7%BB%93%E6%9E%9C%20detection_result%20%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%3F%7D%3B%0A%20%20D%20--%20%E6%98%AF%20--%3E%20E%5B%E8%8E%B7%E5%8F%96%E6%9C%80%E4%BD%B3%E7%BC%96%E7%A0%81%20best_encoding%5D%3B%0A%20%20E%20--%3E%20F%5B%E8%A7%A3%E7%A0%81%E5%AD%97%E7%AC%A6%E4%B8%B2%20decoded_string%5D%3B%0A%20%20F%20--%3E%20G%5B%E6%89%93%E5%8D%B0%E6%9C%80%E4%BD%B3%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E5%AD%97%E7%AC%A6%E4%B8%B2%5D%3B%0A%20%20D%20--%20%E5%90%A6%20--%3E%20H%5B%E6%89%93%E5%8D%B0%22%E6%9C%AA%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%E7%BC%96%E7%A0%81%22%E6%B6%88%E6%81%AF%5D%3B%0A%20%20G%20--%3E%20I%7B%E5%AE%9A%E4%B9%89%E5%AD%97%E8%8A%82%E4%B8%B2%20ascii_bytes%7D%3B%0A%20%20H%20--%3E%20I%3B%0A%20%20I%20--%3E%20J%5B%E8%B0%83%E7%94%A8%20from_bytes%28ascii_bytes%29%5D%3B%0A%20%20J%20--%3E%20K%7B%E6%A3%80%E6%B5%8B%E7%BB%93%E6%9E%9C%20ascii_detection%20%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%3F%7D%3B%0A%20%20K%20--%20%E6%98%AF%20--%3E%20L%5B%E6%89%93%E5%8D%B0%20ascii_bytes%20%E7%9A%84%E6%9C%80%E4%BD%B3%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E5%90%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%5D%3B%0A%20%20K%20--%20%E5%90%A6%20--%3E%20M%5B%E6%89%93%E5%8D%B0%22%E6%9C%AA%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%20'hello%20world'%20%E7%9A%84%E7%BC%96%E7%A0%81%22%E6%B6%88%E6%81%AF%5D%3B%0A%20%20L%20--%3E%20N%5B%E7%BB%93%E6%9D%9F%5D%3B%0A%20%20M%20--%3E%20N%3B%0A\" rel=\"noopener nofollow\" target=\"_blank\">MermaidGo</a> 绘制示例代码的流程图，结果如下：</p>\n<p><img alt=\"MermerGo的charset-normalize的流程图\" class=\"lazyload\" /></p>\n<h2 id=\"五学习资源\">五、学习资源</h2>\n<ol>\n<li>开源项目：<a href=\"https://github.com/Ousret/charset_normalizer\" rel=\"noopener nofollow\" target=\"_blank\">charset-normalizer</a></li>\n<li>中文自述：<a href=\"https://www.python64.cn/readme/charset-normalizer/\" rel=\"noopener nofollow\" target=\"_blank\">REMDME</a></li>\n<li>在线运行：<a href=\"https://www.min2k.com/tools/python-run/\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a></li>\n</ol>\n<blockquote>\n<p>如果这篇文章对你有帮助，欢迎点赞、收藏、转发！<br />\n学习过程中有任何问题，欢迎在评论区留言交流～</p>\n</blockquote>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 20:28</span>&nbsp;\n<a href=\"https://www.cnblogs.com/min2k\">敏编程</a>&nbsp;\n阅读(<span id=\"post_view_count\">42</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MAF快速入门（13）常见智能体编排模式",
      "link": "https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper13",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper13\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 19:53\">\n    <span>MAF快速入门（13）常见智能体编排模式</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"MAF快速入门（13）常见智能体编排模式\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/381412/202601/381412-20260124195158983-724601081.png\" />\n        事实上，在构建AI应用解决业务问题时，单个Agent往往无法胜任所有任务，常常需要我们将多个Agent组合起来系统工作。而这种组合与协调的方式，就被称为 Agent Orchestration 即 Agent编排。MAF支持多种多Agent编排流程模式，每个模式都针对不同的协作方案而设计。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><span><span>大家好，我是Edison。</span></span></p>\n<p><span><span>最近我一直在跟着圣杰的《<a class=\"normal_text_link mp_article_text_link\" href=\"https://mp.weixin.qq.com/s?__biz=MzA4NzQzNTg4Ng==&amp;mid=2651744458&amp;idx=1&amp;sn=139f7584e81aeecd0945133bdc2b4791&amp;scene=21#wechat_redirect\" rel=\"noopener nofollow\" target=\"_blank\"><span>.NET+AI智能体开发进阶</span></a><span>》课程学习MAF开发多智能体工作流，我强烈推荐你也上车跟我一起出发！</span></span></span></p>\n<p><span><a class=\"normal_text_link mp_article_text_link\" href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper12\" target=\"_blank\"><span>上一篇</span></a><span>，我们学习了MAF中如何进行子工作流<span>。本篇，我们来了解下在MAF中如何快速实现一些常见的智能体编排模式。</span></span></span></p>\n<h1><span><span><span><strong>1 智能体编排模式介绍</strong></span></span></span></h1>\n<p>传统的单Agent系统在处理复杂多面任务的能力方面受到较多限制，因此我们会有多Agent编排协作完成任务的需求。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202601/381412-20260124091613961-245103765.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>事实上，在构建AI应用解决业务问题时，单个Agent往往无法胜任所有任务，常常需要我们将多个Agent组合起来系统工作。而这种组合与协调的方式，就被称为&nbsp;<strong>Agent Orchestration</strong>&nbsp;即&nbsp;Agent编排。</p>\n<p>MAF支持多种多Agent编排流程模式，每个模式都针对不同的协作方案而设计。这些模式作为框架的一部分提供出来，我们可以自己扩展。</p>\n<p><span><span><span>在MAF中，常见的Agent编排模式如下：</span></span></span></p>\n<ul class=\"list-paddingleft-1\">\n<li><span><span><span>Sequential 顺序编排：<span>即各个Agent依次处理并传递给下一个Agent执行；</span></span></span></span></li>\n<li><span><span><span>Concurrent 并发编排：<span>即多个Agent并行处理同一个任务，然后汇聚结果；</span></span></span></span></li>\n<li><span><span><span>Handoffs 移交编排：<span>即每个Agent都可以将对话移交给另一个Agent，确保每个Agent处理任务的某个部分；</span></span></span></span></li>\n<li><span><span><span>GroupChat 群聊编排：<span>即多个Agent加入了同一个微信群，通过群聊对话形成一些决策；</span></span></span></span></li>\n</ul>\n<p><span><span><span>对应到MAF中，<span><span>AgentWorkflowBuilder&nbsp;<span>类提供了这些编排模式的具体实现，我们开发者可以直接使用对应的接口即可快速完成有一次编排 而无需 自行实现Edge连接。</span></span></span></span></span></span></p>\n<h1><strong><span>2&nbsp;<strong><span>智能体编排模式详解</span></strong></span></strong></h1>\n<h3><strong><span><span>2.1 顺序编排</span></span></strong></h3>\n<p>在顺序编排模式中，各个Agent被组成一个流程，每个Agent都会处理任务，并将执行结果输出传递给下一个待执行的Agent。可以看出，对于每个基于上一步骤构建的工作流<span>（Workflow）来说，这是比较适合的模式。</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202601/381412-20260124091657384-365298595.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>目前，像文档审阅、工作流、数据处理管道、多阶段推理等，是比较常见的应用场景。</p>\n<p>下面的代码展示了在MAF中的顺序编排实现：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> analyst = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> writer = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> editor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Build a Workflow</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> workflow =<span style=\"color: rgba(0, 0, 0, 1);\"> AgentWorkflowBuilder.BuildSequential(\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">content-team-workflow</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, \n    [analyst, writer, editor]);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Test the Workflow</span>\n......</pre>\n</div>\n<p>可以看到，通过BuildSequential方法即可快速完成一次顺序编排。</p>\n<h3><span><span>2.2 并发编排</span></span></h3>\n<p>并发模式使用多个Agent并行处理同一个任务，每个Agent都可以独立处理输入，并收集并聚合结果。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202601/381412-20260124194638071-182220484.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>此模式比较适合多种观点或解决方案很有价值的场景，比如集思广益、群体推理以及其他投票系统。</p>\n<p>下面的代码展示了在MAF中的代码实现：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step1. Create Agents</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> sensitiveWordAgent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> adDetectionAgent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> sentimentAgent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step2. Build a Workflow</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> workflow =<span style=\"color: rgba(0, 0, 0, 1);\"> AgentWorkflowBuilder.BuildConcurrent(\n    agents: </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\">[] { sensitiveWordAgent, adDetectionAgent, sentimentAgent },\n    aggregator: auditAggregator\n);\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step3. Test the workflow</span>\n......</pre>\n</div>\n<h3><span><span>2.3 移交编排</span></span></h3>\n<p>在移交（也可以叫做交接）编排模式中，允许各个Agent根据上下文或用户请求相互转移控制权，每个Agent都可以通过适当的专业知识将对话“移交”给另一个Agent，确保每个Agent处理任务的某个指定部分。</p>\n<p><img alt=\"image\" height=\"556\" src=\"https://img2024.cnblogs.com/blog/381412/202601/381412-20260124194802065-1054226946.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"707\" /></p>\n<p>这种模式非常适合于客户支持（客服）、专家系统或需要动态委派类型的任务场景。</p>\n<p><span>下面的代码展示了在MAF的代码实现</span>：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step1. Create Agents</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> triageAgent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> historyTutor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> mathTutor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step2. Build a Workflow</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> workflow =<span style=\"color: rgba(0, 0, 0, 1);\"> AgentWorkflowBuilder.CreateHandoffBuilderWith(triageAgent)\n    .WithHandoffs(triageAgent, [mathTutor, historyTutor]) </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Triage can route to either specialist</span>\n    .WithHandoffs([mathTutor, historyTutor], triageAgent) <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Math or History tutor can return to triage</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    .Build();\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step3. Test the workflow</span>\n.....</pre>\n</div>\n<h3><span><span>2.4 群聊编排</span></span></h3>\n<p>在群聊编排模式中，各个Agent就像加入了一个微信群，由群管理员协调进行群聊对话。这种模式非常适合于模拟会议、辩论或协作解决问题的会议类型场景。</p>\n<p>下图展示了一个讨论业务建议的用例，由一个Chat Manager负责主持对话，依次让三个参与对话的Agent进行建议发表。这个Chat Manager就像是群管理员，它不仅负责主持对话，也会在必要时引入人工干预。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202601/381412-20260124194919639-675664209.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p><span>下面的代码展示了在MAF的代码实现：</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step1. Create Agents</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> researchAgent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> writerAgent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> criticAgent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step2. Build a Workflow</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> workflow =<span style=\"color: rgba(0, 0, 0, 1);\"> AgentWorkflowBuilder.CreateGroupChatBuilderWith(\n  agents </span>=&gt; <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> RoundRobinGropuChatManager(agents))\n      .AddParticipants(researchAgent, writerAgent, criticAgent)\n      .Build();\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step3. Test the workflow</span>\n.....</pre>\n</div>\n<h1><strong><span>3 小结</span></strong></h1>\n<p>本文介绍了MAF中常见的Agent编排模式，并详细介绍了顺序编排、并发编排、移交编排 和 群聊编排 的适用场景 和 代码实现。</p>\n<p>这几种模式的对比分析如下：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202601/381412-20260124195004594-1977355623.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<h1>示例源码</h1>\n<p>GitHub:&nbsp;<a href=\"https://github.com/EdisonTalk/MAFD\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/EdisonTalk/MAFD</a></p>\n<h1>参考资料</h1>\n<p><span><span>圣杰，《<a href=\"https://www.cnblogs.com/sheng-jie/p/19200934\" target=\"_blank\">.NET + AI 智能体开发进阶</a>》（推荐指数：★★★★★）</span></span></p>\n<p><span><span>Microsoft Learn，<span>《<a href=\"https://learn.microsoft.com/en-us/agent-framework/overview/agent-framework-overview?wt.mc_id=MVP_397012\" rel=\"noopener nofollow\" target=\"_blank\">Agent Framework Tutorials</a>》</span></span></span></p>\n<div><span><span>&nbsp;</span></span></div>\n<p style=\"text-align: center;\"><img alt=\"\" src=\"https://images.cnblogs.com/cnblogs_com/edisonchou/1647700/o_200902144330EdisonTalk-Footer.jpg\" /></p>\n<div id=\"Copyright\">\n<p>作者：<span style=\"text-decoration: underline;\">爱迪生</span></p>\n<p>出处：<a href=\"https://edisontalk.cnblogs.com\" target=\"_blank\" title=\"from\">https://edisontalk.cnblogs.com</a></p>\n<p>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。</p>\n</div>\n</div>\n<div id=\"MySignature\">\n    <div align=\"center\"><a href=\"https://weibo.com/u/2068032061?s=6uyXnP\" target=\"_blank\"><img border=\"0\" src=\"http://service.t.sina.com.cn/widget/qmd/2068032061/d643d182/10.png\" /></a></div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 19:53</span>&nbsp;\n<a href=\"https://www.cnblogs.com/edisontalk\">EdisonZhou</a>&nbsp;\n阅读(<span id=\"post_view_count\">35</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Python 学习笔记：具体项目实践",
      "link": "https://www.cnblogs.com/owlman/p/19526745",
      "published": "",
      "description": "<h2 class=\"post-title\">\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/owlman/p/19526745\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 15:57\">\n    <span>Python 学习笔记：具体项目实践</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>[!NOTE] 笔记说明</p>\n<p>在阅读完了《[[基础语法学习|Python 学习笔记：基础语法学习]]》之后，相信读者已经初步体验到了 Python 社区所推崇的“优雅、明确、简单”的编码风格。在接下来的这篇笔记中，我们将会基于这些原则，逐步从脚本式代码过渡到结构清晰、依赖可控、可分发的 Python 项目。本篇将聚焦于：</p>\n<ul>\n<li>介绍如何遵循 PEP 规范（例如 PEP 8）来构建 Python 项目；</li>\n<li>介绍如何基于虚拟环境来安装并管理项目依赖（基于 uv 和 pip）；</li>\n<li>介绍将项目打包为可执行文件或可分发的扩展包（基于 uv）；</li>\n</ul>\n</blockquote>\n<h2 id=\"pep-规范与项目结构设计\">PEP 规范与项目结构设计</h2>\n<p>在我开始学习 Python 的那个年代，这门编程语言在大多数使用场景下仍然被当作一种用于编写单一脚本文件的工具，而非用于构建完整项目的开发语言。换言之，那时候所谓的 Python 程序往往都只是若干独立脚本的集合，并不构成严格意义上的“项目”，自然也谈不上系统化的项目结构设计。这并非偶然。Guido van Rossum 在最初设计 Python 时，其核心目标之一，正是用一种语法简洁、可读性良好的高级语言，来替代 Unix Shell 以完成常见的系统管理与自动化任务。在这样的设计初衷下，Python 更强调“快速完成一件事”，而非长期维护的大规模工程组织。</p>\n<p>然而，随着 Python 在近十余年间在科学计算、Web 开发、数据分析以及工程自动化等应用领域的蓬勃发展，人们对它的使用方式发生了根本性的变化。越来越多的开发者开始使用 Python 来构建功能复杂、生命周期较长的系统，这也使得代码的组织方式、模块边界以及项目结构设计逐渐成为一个无法回避的问题。因此，在讨论具体项目的实践之前，我们需要先解决一个经常被初学者忽视、但在真实工程中极其关键的问题：<strong>代码应该如何被组织，以及应当遵循怎样的规范来书写</strong>。</p>\n<p>在如今的 Python 社区中，人们针对工程化的项目结构设计已经形成了一整套的可遵循的规范文档，这些文档被统称为 <strong>Python Enhancement Proposals，简称 PEP</strong>。当然，PEP 中的大部分内容是用于规范语言设计或解释器实现的，而我们在这里要讨论的是面向项目工程化实践的那一小部分，其目的是在项目结构设计方面建立起统一的约定，以便显著降低项目被理解的成本。这可以使开发者之间无需反复适应不同的代码组织习惯，从而把注意力集中在<strong>业务逻辑本身</strong>。下面，就让我们以当前主流的 PEP 8 为例，来具体介绍一下 Python 项目结构设计的基本原则。</p>\n<h3 id=\"从脚本到项目结构上的转变\">从脚本到项目：结构上的转变</h3>\n<p>许多初学者在学习 Python 时，习惯于将所有代码写在单个 <code>.py</code> 文件中。这在学习阶段完全没有问题，但一旦进入真实而具体的项目，就会迅速暴露出可维护性上的瓶颈。而如果我们想要将自己的代码项目化，首先要做的就是安排好项目的目录结构。一个最基础、也是最常见的 Python 项目可以通过我们之前在《[[编程环境配置|Python 学习笔记：编程环境配置]]》一节中提到的 <code>uv</code> 项目管理工具来生成，其具体步骤如下：</p>\n<ol>\n<li>\n<p>在当前计算机的任意位置创建一个名为 <code>python_demo</code> 的目录，并使用命令行终端程序打开该目录。</p>\n</li>\n<li>\n<p>在命令行终端中执行 <code>uv init</code> 命令，这样就得到了一个初步符合 PEP 8 规范的 Python 项目，其项目结构通常如下所示：</p>\n<pre><code class=\"language-text\">python_demo\n├── .python-version # 用于指定 Python 解释器版本号的文件\n├── pyproject.toml  # 项目配置文件，用于填写一些项目元信息\n├── main.py         # 项目入口代码，现在是一个 Hello, World! 程序\n└── README.md       # 项目说明文件，用于填写项目简介\n</code></pre>\n</li>\n<li>\n<p>虽然上述项目结构已经足以应对一些小型的开发需求了，但如果我们想让它更贴近当前社区普遍认可的 PEP 实践，还需要进一步调整。为此，我们需要继续在 <code>python_demo</code> 目录下分别创建 <code>src</code> 和 <code>tests</code> 这两个子目录，并将之前位于项目根目录下的 <code>main.py</code> 文件移动到 <code>src</code> 目录中。调整后的项目结构如下所示：</p>\n<pre><code class=\"language-text\">python_demo\n├── .python-version        # 用于指定 Python 解释器版本号的文件\n├── pyproject.toml         # 项目配置文件，用于填写一些项目元信息\n├── README.md              # 项目说明文件，用于填写项目简介\n├── src                    # 用于存放项目代码的目录\n│   └── python_demo        # 用于存放模块代码的子目录\n│       ├── __init__.py    # 用于声明当前子目录为模块的空文件\n│       └── main.py        # 模块入口代码，现在是一个 Hello, World! 程序\n└── tests                  # 用于存放测试代码的目录\n</code></pre>\n<p>上述项目结构体现了几个重要的工程原则：</p>\n<ul>\n<li><strong>将项目配置与其实现分离</strong>：项目的配置文件（如 <code>pyproject.toml</code>）应被放置在根目录下，而项目的实现源码则被集中放置在 <code>src</code> 目录中。</li>\n<li><strong>将项目的测试代码与其实现分离</strong>：测试代码位于独立的 <code>tests</code> 目录中，避免与业务代码混杂。</li>\n<li><strong>项目结构的模块化</strong>：通过在特定的子目录中放置 <code>__init__.py</code> 文件，将其声明为模块，从而使得 Python 解释器能够正确识别该目录。例如，如果我们在这里希望将<code>src/python_demo</code>子目录声明为一个模块，并将<code>main.py</code>文件中的<code>hello</code>函数暴露给外部，那么就需要在该 <code>__init__.py</code> 文件中添加以下代码：</li>\n</ul>\n<pre><code class=\"language-python\">from .main import hello    \n</code></pre>\n</li>\n</ol>\n<p>当然，这里需要再次强调的是：PEP 8 中提出的这种项目结构设计规范不是强制标准，并不妨碍开发者们在组织项目方面的个性化发挥，但在生产环境中，它已经成为当前 Python 社区中被广泛认可的“最佳实践”之一。</p>\n<h3 id=\"为什么推荐使用-src-目录结构\">为什么推荐使用 <code>src</code> 目录结构</h3>\n<p>读者可能会觉得有点疑惑，为什么我们需要将程序的实现代码放置一个独立 <code>src</code> 目录中？这种做法在项目结构设计上的现实意义是什么？简而言之，它的直接目的是建立一个独立的、结构化的代码组织机制，以便有效地避免以下问题：</p>\n<ul>\n<li>意外导入当前目录下的同名模块；</li>\n<li>在未正确安装项目时，代码“看似可运行但并不规范”；</li>\n<li>部署或打包阶段出现路径相关的隐蔽错误。</li>\n</ul>\n<p>换句话说就是，设置 <code>src</code> 目录可以迫使我们<strong>以“已安装包”的方式来使用自己的项目代码</strong>，这与真实的部署和分发场景高度一致。另外，在拆分模块时，我们也要注意不要一味地“越细越好”，应遵循以下几个简单但实用的原则：</p>\n<ul>\n<li>每个模块只关注一类明确职责；</li>\n<li>模块名应反映其用途，而不是实现细节；</li>\n<li>避免在模块之间形成循环依赖；</li>\n<li>对外暴露的接口应尽量稳定，内部实现可以自由调整。</li>\n</ul>\n<p>总而言之，如果读者发现某个文件不断膨胀、同时承担多种职责时，往往就意味着它已经到了需要拆分的时刻。</p>\n<p>在这一节中，我们并没有编写任何“功能性代码”，但所做的工作却直接决定了项目未来的可维护性上限。通过遵循 PEP 规范，并在一开始就建立清晰的项目结构，我们为后续的依赖管理、测试、打包与分发打下了坚实基础。在下一节中，我们将从工程实践的角度出发，介绍如何基于虚拟环境来<strong>安装并管理项目依赖</strong>，并说明为什么在真实项目中，依赖管理应当被视为项目设计的一部分，而不是事后补救的步骤。</p>\n<h2 id=\"项目依赖的安装与管理\">项目依赖的安装与管理</h2>\n<p>在完成了上述项目结构设计的基本工作之后，我们接下来要解决的是另一个在具体项目实践中不可回避的问题：<strong>如何安装、隔离并稳定地管理项目依赖</strong>。对于 Python 项目而言，依赖管理不仅是要“能将项目所依赖的扩展包装上”，更重要的是要实现以下几个更本质的目标：</p>\n<ul>\n<li>确保不同项目之间所依赖的扩展包互不干扰；</li>\n<li>项目在不同机器、不同时间点上具有一致的运行环境；</li>\n<li>项目所依赖的这些扩展包在版本上是可追溯、可复现的。</li>\n</ul>\n<p>为了实现上述目标，Python 社区逐步形成了一套围绕虚拟环境（Virtual Environment）展开的通用实践。接下来，就让我们继续以 uv 这款项目管理工具为例，介绍现代 Python 项目中推荐的依赖管理方式。</p>\n<h3 id=\"使用-uv-来管理项目依赖\">使用 uv 来管理项目依赖</h3>\n<p>正如我之前在《[[编程环境配置|Python 学习笔记：编程环境配置]]》中所介绍的，在没有虚拟环境的情况下，Python 的第三方扩展通常会被安装到系统级解释器的 <code>site-packages</code> 目录中。这种做法在早期看似方便，但很快就会带来严重问题：</p>\n<ul>\n<li>不同项目对同一依赖的版本要求可能冲突；</li>\n<li>升级或卸载某个库可能意外破坏其他项目；</li>\n<li>很难准确还原某个历史版本项目的运行环境。</li>\n</ul>\n<p>虚拟环境的核心作用，就是为<strong>每个项目提供一个彼此独立的 Python 运行时环境</strong>，使解释器、第三方库以及相关工具只对当前项目可见。换言之，读者可以将虚拟环境理解为“项目的运行时沙箱”。但是，如果我们使用 Python 官方提供的解决方案，即先用<code>venv</code> 来创建虚拟环境，然后再用 pip 工具来安装并管理项目中的依赖，那么随着项目规模的扩大，我们很快就会遇到以下这些棘手问题：</p>\n<ul>\n<li>项目所依赖的扩展包在版本上并未被明确锁定，这会导致项目在不同时空环境中的行为不一致；</li>\n<li>不同机器上解析出的依赖树可能并不完全一致，这会导致项目在不同机器上的运行结果存在差异；</li>\n<li>随着项目依赖的变化，虚拟环境中会出现越来越多的“孤儿依赖”，这会导致项目体积的日益臃肿。</li>\n</ul>\n<p>为了更好地解决上述问题，在现代化的项目管理工具所提出的解决方案中，pip 工具通常不再被单独使用，而是用于充当“底层安装器”，配合 uv 这类更高层的依赖管理工具共同完成工作。在这里，我们可以将 uv 理解为一个集成了依赖解析、安装、锁文件生成等功能的工具链，它使得管理项目依赖的过程变得更加高效、稳定。除此之外，uv 在设计上也吸收了多种现有方案的优点，试着以更统一的方式解决依赖解析速度慢、环境复现不稳定、工具链分散、职责重叠等问题。</p>\n<p>在 uv 的工作流中，项目依赖的管理逻辑通常是围绕 <code>pyproject.toml</code> 文件展开的。例如在我们之前创建的 <code>python_demo</code> 项目中，<code>pyproject.toml</code> 文件的初始内容如下所示：</p>\n<pre><code class=\"language-toml\">[project]                                   # 项目元信息配置声明\nname = \"python-demo\"                        # 项目名称\nversion = \"0.1.0\"                           # 项目版本号\ndescription = \"Add your description here\"   # 项目简介\nreadme = \"README.md\"                        # 项目说明文件路径\nrequires.python = \"&gt;=3.13\"                  # 项目最低支持的 Python 版本\ndependencies = []                           # 项目的直接依赖列表\n</code></pre>\n<p>接下来，如果我们像之前在《[[编程环境配置|Python 学习笔记：编程环境配置]]》一文中所演示的那样，执行了 <code>uv add &lt;扩展包名&gt;</code> 这一用于安装依赖的命令，那么 uv 就会自动修改 <code>pyproject.toml</code> 文件，将我们安装的扩展包及其当前的版本信息添加到 <code>dependencies</code> 列表中，并同步生成一个名为 <code>uv.lock</code> 文件，用于锁定项目依赖的版本，如图 1 所示：</p>\n\n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 1</strong>: 使用 uv 安装依赖</p>\n<p>这时候，如果我们执行 <code>uv tree</code> 命令，就可以看到 uv 解析出的项目依赖树，如图 2 所示：</p>\n\n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 2</strong>: uv 解析出的项目依赖树</p>\n<p>从图 2 中可以看到，当前项目所安装的直接依赖是 <code>Flask</code>，而 <code>Flask</code> 又依赖了 <code>Werkzeug</code>、<code>Jinja2</code> 和 <code>itsdangerous</code> 等若干个扩展包，其中的诸如 <code>Werkzeug</code>、<code>Jinja2</code> 扩展包又继续依赖了 <code>MarkupSafe</code> 这个扩展包。这些信息被 uv 以树状结构展示出来，使得读者可以直观地了解项目依赖的层次关系，这比传统做法中使用 <code>pip list</code> 命令所获得的扁平化依赖列表要直观得多。</p>\n<p>更重要的是，当我们需要删除项目的某个直接依赖时，只需要执行 <code>uv remove &lt;扩展包名&gt;</code> 命令，uv 就会自动解析出该依赖所涉及的依赖树，并删除其中不再被其他依赖引用的间接依赖，这就解决了传统做法中使用 <code>pip uninstall &lt;扩展包名&gt;</code> 命令时，会产生的“孤儿依赖”问题，如图 3 所示：</p>\n\n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 3</strong>: 使用 uv 删除依赖</p>\n<h3 id=\"锁定依赖版本的重要性\">锁定依赖版本的重要性</h3>\n<p>当然了，在具体项目实践中，“能安装”并不等于“可复现”。为了确保项目在不同时间、不同环境中的行为一致，它所依赖的扩展包在版本上应当被明确锁定，而不是无限制地跟随最新版本更新。uv 在这方面通过创建 <code>uv.lock</code> 文件对版本锁定提供了原生支持，使依赖状态成为项目的一部分，而不是隐含在某台机器中。从工程化的角度来看，锁定依赖版本意味着项目的构建过程是可重复的，线上问题更容易回溯，协作成员的环境更加一致。这意味着，任何一个开发者只要完整地获得了一个项目的源码和配置文件，就可以通过执行 <code>uv sync</code> 这个命令，在本地完整地复现该项目的完整运行环境，如图 4 所示：</p>\n\n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 4</strong>: 使用 uv 复现项目运行环境</p>\n<p>现在，让我们再来系统地为读者总结一下 Python 项目中依赖管理的基本思路：</p>\n<ul>\n<li>虚拟环境是项目级隔离的基础设施；</li>\n<li>pip 负责执行安装，但并不擅长整体依赖管理；</li>\n<li>uv 提供了更现代、更稳定的依赖解析与管理能力；</li>\n<li>依赖版本应当被视为项目设计的一部分，而非临时决策。</li>\n</ul>\n<p>在下一节中，我们将进一步讨论：<strong>如何将一个已经结构清晰、依赖稳定的 Python 项目，打包为可执行文件或可分发的扩展包</strong>，并说明这些能力在具体项目实践中的意义。</p>\n<h2 id=\"项目的打包与分发\">项目的打包与分发</h2>\n<p>当一个 Python 项目完成了合理的目录结构设计，并且其依赖关系已经通过虚拟环境与锁文件得到了稳定的管理之后，我们接下来就该开始考虑项目的打包与分发问题了。请注意，“分发”这个词在工程化的语境中并不只是指把项目的源代码拷贝给别人，它通常还包含以下几种常见目标：</p>\n<ul>\n<li>作为 <strong>Python 扩展包</strong> 分发，供其他项目通过依赖方式引入；</li>\n<li>打包为 <strong>可执行命令行工具</strong>，供用户直接运行；</li>\n<li>在某些场景下，进一步打包为 <strong>独立可执行文件</strong>，以减少运行环境依赖。</li>\n</ul>\n<p>下面，我们将继续基于 uv 这款项目管理工具来为读者介绍当前 Python 社区所推荐的项目打包与分发方式。</p>\n<h3 id=\"使用-uv-来打包项目\">使用 uv 来打包项目</h3>\n<p>在早期，人们将 Python 项目打包成第三方扩展的方式是高度分散的。有的项目依赖与 <code>setup.py</code> 文件，有的项目通过自定义脚本发布，有的项目甚至完全没有明确的打包入口。这些做法在项目规模较小时尚可接受，但在多人协作、持续集成或长期维护场景中，我们就会遇到项目的构建流程不可复现、项目的成员之间使用的工具链难以统一、新成员难以上手等棘手的问题。为了解决这些问题，Python 社区逐步形成了一套围绕 <strong>PEP 517 / PEP 518 / PEP 621</strong> 的现代打包规范，其核心思想是：</p>\n<blockquote>\n<p><strong>将项目的元数据、构建方式与依赖声明集中到一个统一的配置入口中。</strong></p>\n</blockquote>\n<p>这个入口贯彻到如今具体的项目实践中就是 <code>pyproject.toml</code> 文件。换言之，如果想要顺利地完成项目的打包，我们首先需要确保 <code>pyproject.toml</code> 文件中包含了正确的配置。在上一节中，我们已经为读者介绍了如何在 <code>pyproject.toml</code> 文件中使用<code>[project]</code>配置项声明当前项目的基本元数据（包括项目的直接依赖列表）。接下来，让我们将目光转向与项目打包相关的<code>[build-system]</code>配置项，它用于声明项目打包所要使用的工具，先来看一个简单的示例：</p>\n<pre><code class=\"language-toml\">[project]                                    # 项目元信息配置声明\nname = \"python-demo\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nreadme = \"README.md\"\nrequires-python = \"&gt;=3.13\"\ndependencies = [\n    \"flask&gt;=3.1.0\",\n]\n\n[build-system]                               # 项目打包方式配置声明\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n</code></pre>\n<p>在上述文件的<code>[build-system]</code>部分，我们做了如下配置：</p>\n<ul>\n<li><code>requires</code> 列表声明了打包项目所依赖的构建工具；</li>\n<li><code>build-backend</code> 声明了打包项目时需要调用的后端工具；</li>\n</ul>\n<p>在这里，hatchling 是一个常用的构建后端工具，uv 会根据 build-backend 的配置来调用相应的底层后端工具来完成项目的打包。当然，uv 并不强制用户使用某一特定的底层后端工具，读者在这里也可以求选择使用 <code>setuptools</code>、<code>flit</code>、<code>poetry</code> 等来充当底层的后端工具，只需要将上述文件中的<code>[build-system]</code>部分修改为如下内容即可：</p>\n<pre><code class=\"language-toml\">requires = [\"setuptools&gt;=58.0.4\"]\nbuild-backend = \"setuptools.build_meta\"\n# 或者：\nrequires = [\"flit_core&gt;=3.2.0\"]\nbuild-backend = \"flit_core.build_backend\"\n# 或者：\nrequires = [\"poetry-core&gt;=1.0.0\"]\nbuild-backend = \"poetry.core.masonry.api\"\n</code></pre>\n<p>在完成配置之后，我们就可以通过执行 <code>uv build</code> 命令将项目打包成 Python 社区通用的扩展包文件（扩展名为 <code>.whl</code> 的 wheel 文件，以及扩展名为 <code>.tar.gz</code> 的源码包文件）。在执行该命令的过程中，uv 会依次执行以下步骤：</p>\n<ol>\n<li>读取 <code>pyproject.toml</code>；</li>\n<li>调用指定的底层后端工具；</li>\n<li>在项目根目录下生成 <code>dist</code> 目录；</li>\n<li>将项目打包的结果输出到其中。</li>\n</ol>\n<p>例如具体到<code>python_demo</code>项目中，在我们执行了 <code>uv build</code> 命令后，就可以在项目根目录下的 <code>dist</code> 目录中分别看到名为 <code>python_demo-0.1.0-py3-none-any.whl</code> 的 wheel 文件，和名为 <code>python_demo-0.1.0.tar.gz</code> 的源码包文件，如图 5 所示：</p>\n\n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 5</strong>: 使用 uv 打包项目</p>\n<p>接下来，我们就可以将这些打包的结果上传至私有或公共包仓库、又或者直接分享给其他人，让他们通过 <code>uv pip install</code> 命令以自定义扩展包的形式安装到自己所在的 Python 运行环境中。例如在这里，当我们执行 <code>uv pip install dist/python_demo-0.1.0-py3-none-any.whl</code> 命令时，uv 就会自动调用 pip 解析出该扩展包的元数据与依赖关系，并按照其中声明的版本号来安装它，如图 6 所示：</p>\n\n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 6</strong>: 使用 pip 安装扩展包</p>\n<p>如读者所见，在执行完安装命令之后，我们就可以在当前虚拟环境中运行的 Python Shell 中使用 <code>import</code> 语句来导入并使用该扩展包了。</p>\n<h3 id=\"使用-uv-来构建-cli\">使用 uv 来构建 CLI</h3>\n<p>除了将项目打包成可供他人使用的扩展包之外，我们更多时候还需要将 Python 项目分发成命令行工具（CLI）的形式，直接提供给用户使用。例如，如果我们现在想将之前的 <code>python_demo</code> 项目实现成一个基于<code>Flask</code> 框架的 Web 服务应用。那么，首先，我们需要将项目根目录下的<code>src/python_demo/main.py</code> 文件修改为如下内容：</p>\n<pre><code class=\"language-python\">from flask import Flask\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello():\n    return \"Hello, World!\"\n\ndef main() -&gt; None:\n    app.run()\n</code></pre>\n<p>然后，我们就只需要想办法将该项目打包成 CLI 的方式，让用户在命令行中直接运行这个 Web 服务即可。为了实现这个目标，我们需要在 <code>pyproject.toml</code> 文件中为这个项目配置一个 CLI 入口点，这可以通过 <code>[project.scripts]</code> 配置项来完成，下面是一个简单的演示：</p>\n<pre><code class=\"language-toml\">[project]                                    # 项目元信息配置声明\nname = \"python-demo\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nreadme = \"README.md\"\nrequires-python = \"&gt;=3.13\"\ndependencies = [\n    \"flask&gt;=3.1.0\",\n]\n\n[build-system]                               # 项目打包方式配置声明\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[project.scripts]                           # CLI 入口点配置声明\nweb-hello = \"python_demo.main:main\"\n</code></pre>\n<p>在上述配置文件中，<code>[project.scripts]</code> 配置项下面包含了以下信息：</p>\n<ul>\n<li>在安装了该项目的分发包之后，当前  Python 运行环境中会生成一个名为 <code>web-hello</code> 的命令；</li>\n<li>当用户在当前 Python 运行环境中执行 <code>web-hello</code> 命令时，Python 解释器会自动调用 <code>python_demo.main:main</code> 方法。</li>\n</ul>\n<p>在完成上述配置之后，我们就可以通过执行 <code>uv build</code> 命令将项目打包成 CLI 的形式，并使用 <code>uv pip install</code> 命令安装它。在安装完成之后，我们就可以在当前 Python 运行环境中执行 <code>web-hello</code> 命令来启动这个 Web 服务了，如图 7 所示：</p>\n\n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 7</strong>: 使用 uv 构建 CLI</p>\n<p>需要注意的是，由于在某些面向非开发者的场景中，要求用户事先安装 Python 并配置环境并不具备现实的可操作性。这时，我们确实可以适当考虑将项目打包为独立可执行文件。但这类方案通常会存在诸如项目构建体积较大、构建流程更复杂、与平台强绑定等问题，因此在实际项目中并不推荐作为默认选择。</p>\n<h3 id=\"从工程角度理解打包的意义\">从工程角度理解“打包”的意义</h3>\n<p>将项目打包，并不仅仅是为了发布，更重要的是它带来的工程约束：</p>\n<ul>\n<li>项目必须拥有清晰的入口；</li>\n<li>元数据必须完整且一致；</li>\n<li>构建过程必须是可重复的。</li>\n</ul>\n<p>这些约束反过来，会倒逼项目在设计阶段就保持良好的结构与边界。</p>\n<h2 id=\"本篇小结\">本篇小结</h2>\n<p>在这一篇笔记中，我们完成了从“会写 Python 代码”到“能交付 Python 项目”的过渡：</p>\n<ul>\n<li>\n<p>通过 PEP 规范约束项目结构与编码风格；</p>\n</li>\n<li>\n<p>通过虚拟环境与 uv 管理依赖；</p>\n</li>\n<li>\n<p>通过标准化打包流程实现可复现的构建与分发。</p>\n<p>从这一刻开始，Python 不再只是脚本语言，而成为了一种<strong>可以被工程化、产品化的开发工具</strong>。</p>\n</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\">2026-01-24 15:57</span>&nbsp;\n<a href=\"https://www.cnblogs.com/owlman\">凌杰</a>&nbsp;\n阅读(<span id=\"post_view_count\">89</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n        </p>"
    },
    {
      "title": "忆往昔--OI生涯回忆",
      "link": "https://www.cnblogs.com/hicode002/p/-/oi-memories",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/hicode002/p/-/oi-memories\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 11:45\">\n    <span>忆往昔--OI生涯回忆</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>突然大概明白了为什么这么失败了...其实我对OI/计算机的热情远没有那么高，至少不是那种特别喜欢写程序写项目的人，之前也只是用E语言/Python写各种小工具/爬虫，还研究过一段时间游戏开发（当然小学时候是不会英语用的中文编程），甚至那时候就会多线程并发（当然还是中文语言）那时候的确对写程序有很强的热情，至少说是一个自我满足的过程，得写了好几十个小工具而且思路也还比较清晰能坐在电脑面前很长时间，而且没有很强的炫耀思维。当然当时也是刷机爱好者，在那个年代感觉（小学时候）几乎没有很多的资源但是我那时候一直有个梦想就是给手机刷windows和手机双系统，（结果这个到今天也没实现emmm），然后刷坏了好几部手机，d当时还是Windows Phone时代，那时候我一直想着手机有一天也要有电脑的BIOS。（然后后来WOA项目真的做了）然后就是MC玩家还研究过命令方块（当时手机版刚出命令方块）（还是多玩我的世界盒子时代），当时体育课还把它都打印出来和同学讨论。<br />\n然后小学很早家里买了一堆操作系统安装和Dreamviewer/photoshop软件使用的书，当时还说要自己写一个博客，（谁知道现在前端都是vue+react，并且博客都是现成的模板），然后还有一本上世纪的VB编程（结果现在早淘汰了）。</p>\n<p>从这个意义上说我至少学OI前我的计算机学习的确是出于兴趣并且充满热情的，而且都是自学的。</p>\n<p>初二时候想着研究AI相关的（主要是流浪地球的MOSS吸引的），然后想着系统性的学python什么的正儿八经写一个自动化工具（当时也不懂AI的原理只知道要训练），然后一直没有好的自学资源（或者说当时我找不到），然后当时语文作文很差被家长勒令去上辅导班加上和老师/同学关系很差，所以说很难受。然后辅导班旁边有有一家新开的编程机构邀请我试听，然后去了，到那把我的情况一说，然后人家觉得我水平还可以跟我说了信息学竞赛和C++相关的，然后我一下子非常高兴，就跟家长说要学（在此之前所有兴趣班我都学不下去），然后刚好当时初中班主任对我态度很差，之前还说过我除了会点电脑啥都不会就是废物之类的话（确实我体育不好，谁叫她教体育的...),所以说就真让家长报班学了，当时还有另外一个骗子机构叫做童程童美，是教python的，用python写小游戏，但是我觉得有点水（事实证明这个机构后来的确暴雷了）。然后暑假2个月把C++语言基础学出来了，那时候突然一下子了解到自主招生，了解到一种神秘的东西叫做游记/退役记，然后才意识到，原来编程学的好可以保送/高考降分进入名校啊，突然意识到原来在有些地方他们的中学生活非常快乐而不是像我一样。然后当时翻到了很多NOIP考了好成绩被高中保送，然后高中在机房快乐的编程，感觉非常浪漫就像在童话的世界一样。还有一些学长高三提前降一本然后在学校爽玩然后在全校分享自己的经验，那种感觉就是一个从来没有见过的新世界呀！</p>\n<p>那时候我一下子意识到我也要像他们那样，那时候看到大佬们的游记里面提到的高大上听不懂名字的算法和数据结构，还有当时一个流行的话：暴力出奇迹，暴力进国集，想着只要我认真学习这些算法和数据结构，再有着良好的数学基础，再给我充足的时间，然后肯定可以拿到金牌进入国集!（而且看zyb大佬的博客大概的学习路线也确实是这样的）而且那时候整个西海岸连一个省一的都没有！所以说当时是我暗自就下定决心要把全部精力投入到这个上面，一定要拿到金牌，拿不到金牌拿一个银牌也行，那样到时候没有人会再嘲讽我！再也没有人会说我体育差/语文差!然后我想象着拿到牌子之后，我可以认识很多人，我可以有一天站在学校的讲台上讲着自己的经验，我保送/降分之后我可以弥补我之前没有做的事情，我可以做化学实验，我可以重新玩我喜欢的游戏，我可以有自己的游记下面也会有人评论！</p>\n<p>然后我那时候想着第一年先拿到普及组一等奖，那时候我虽然不理解很多算法连回溯都不太理解但是我代码能力还可以或者说心态很好，这些题都是直接上手写代码的。后来还配了NOI linux环境，还配置了GEDIT和VIM，当时还想着考场上是Linux环境,还担心会有一些编译错误，甚至默写头文件而不是使用万能头，然后还记着当时初中语文课（我语文课听不下去老师天天骂我，而且阅读题我从来不做因为总感觉自己的想法会被老师审阅是很不舒服的，只有考试才做因为阅卷老师是随机的），课上在课本的角落上在那边默写头文件/想题（当时都是一些模拟题）。然后到CSP考前我基本上刷完了历年所有普及组的前两题，这样说前两题根本没有什么难度，我拿个普及组省一没有任何问题。当时状态也是非常好，复赛的时候去日照那时候OI还是蒸蒸日上，疫情和强基计划还没有出台，日照的人很多，很多学校有庞大的队伍，当时的我也是感觉很羡慕</p>\n<p>然后是初三 自主招生 化学实验 CSP2020 自学记笔记（效率低的问题） 没有资源（不知道刷什么题） 想要有强校集训的氛围，但是这种快节奏的课容易走神，训练上面没有时间写代码，这是最严重的问题，中考超出50多分。 热情还是在的，当时会python还写过脚本学过爬虫 然后还在用e语言写窗口程序（当时不知道c#诶）</p>\n<p>中考结束后的暑假，那应该是状态前期比较好的一个暑假了吧...<br />\n暑假前期一中的自招班要提前去上一周课，当时是没有晚自习的，而且食堂特别好（后来才知道那段时间是特意那么搞的，平时食堂很烂），然后当时一中承诺学科竞赛要认真搞，我还想着联系教练（结果连教练都没有，笑，就是微机老师）。<br />\n印象最深的是当时一中的学姐学长回来宣讲，当时的我非常的心潮澎湃，看着他们描述的丰富多彩的大学生活，当然现实是从外表和言谈上已经完全看不出曾经是高中生了，所以确实应该有不错的大学生活。然后他们讲着在一中是怎么学习的，分享自己的经验，非常的从容。我当时就在想，假如有一天我进了省队拿了银牌或者以上，那么我也可以回来坐在那个讲台上，分享我学习OI的事情。那种激情确实很强的刺激我学习OI。</p>\n<p>我当时想法很简单要过完数据结构+图论的内容，然后后面再看DP。但是我当时只会照着OI-WIKI学，实际上学的太偏向模板了而且OIWIKI不是很通俗易懂。我当时列的计划不错，但是现实是我每天根本完不成，因为我看一会儿wiki然后看不懂就去搜搜了很多还是看不懂就浪费很多时间，再就是看一会儿经常往下翻总之还是有点静不下心。所以实际上我到8月份只学了线段树树状数组堆分块还有一些数论算法之类的，然后我就很急。这要开学可怎么办啊！我的想法是NOIP2021要拿高分然后冲省选的！然后第一次跟家长谈论停课。然后家长果然拒绝了还说了一些难听的话（大概就是以后我后悔了又要怪他之类的）（还有什么白养了之类的）。当然拒绝是理解的毕竟刚进入高中我对一中所谓的竞赛培养体系还抱有幻想。</p>\n<p>进入一中后，状态很好 然后最开始有教练，但是我想法太好了，有点飘了，然后意识到一个问题就是交流题目这种有刺激性的事会让我完全无法思考，所以晚自习做题效率很低。再就是代码能力还是差到后期头疼思维混乱了就只能出思路写不动代码。然后NOIP2021前实际上没学多少东西。 NOIP2021爆炸。接下来是复盘反思：数学基础薄弱，连方差的两种算法都不知道，概率期望不会算，排列组合水平差，所以恶补了很多数学，当然也是自学高中数学 然后实际上就偏离了对代码能力的培养：这和在学校没有电脑关系很大 再加上我对重点班的竞赛培养抱有幻想</p>\n<p>而且后来高一上几乎不怎么写作业然后期末级部30多名，然后被调进了所谓重点班。其实某种程度上说这也是噩梦的开始。我以为重点班老师会充分信任学生的能力，班里会有很多搞竞赛的，会有一个良好的氛围，即使压力很大，因为我之前也看过那些回忆录里面提到的竞赛班，很多都是长时间停课然后搞竞赛的，所以我的想法还是挺好的，所以那时候我都想好了要跟着学校进度走走看。然后就是高一下学期跟了一段时间文化课还去参加了SDOI2022，但是SDOI2022前没有任何准备，当时晚自习周末都没有去搞竞赛，就是偶尔跟着zgx搞一搞。但是只能说进入这个班之后压力骤增。老师并不是很信任这些学生，相反每周还要花很长的时间开班会来PUA。而且，这个班直接从普通班的楼搬出去了，某种意义上是物理隔离（当然你要主动去找也可以）。然后实际上老师和领导是有意鼓动这个班的内卷风气，而且PUA的内容就是清华北大。（其实我感觉去不去TP无所谓，华五好专业更好，真去TP可能就真抑郁了。。。）实际上班里并不支持学习竞赛，或者说学校是把竞赛看作是一种whk的补充或者说是为了强基校测准备的。（但是后来确实出了两个牌子一个PHO一个CHO，好像也没有额外的训练，当然我觉得CHO没有那么难）。在这样一个内卷的状态下实际上按照自己节奏学习WHK是一件很难的事情，实际上像物理，老师讲的很快而且实际上也讲不出什么，更多时间还是应该按照自己体系来进行学习（我高中物理跟这个老师成绩挺差的裸分有时候70多）（后来准备少创时候是按照小时百科重学了一遍相当于），然后真正的去理解一个题目。生物也是，后来我生物是看网课才得到比较大的提升。所以实际上这一个学期我是挺痛苦的，不仅没有学到OI上什么东西把SDOI2022浪费了，这可是我唯一去省选的机会啊。然后WHK上我又很痛苦，明明假期家长已经拉着我预习一遍了，我还要再学一遍干啥。所以实际上根本没办法静下心来，反而把时间都浪费了。这可能是最后悔的一件事。</p>\n<p>当时还有另外一个有趣的事情，就是5月时候，突然想把学生平板破解了，然后就和wk研究刷机，然后了解到华为的Bootloader，然后那时候有一个开源工具叫potatonv，但是不是很好用。后来我读了potatonv的源码手动复现了他的解锁原理。然后当时有一篇很著名的安全报告，或者说两篇描述的同一件事情：华为海思麒麟芯片上的安全启动漏洞，一个是taszk pdf的，一个是pangu的。然后当时看了，但是还有很多细节不理解，但是由于我的平板是麒麟659和论文对不起来再加上用不上，所以就放弃了，想着以后有什么时间再复现一下。结果拖了4年...（然后2025年上半年复现了，后果惨重）.然后当时我们两个研究了怎么解BL 刷TWRP，然后我们研究了好久双系统，最终找到了一种在SD卡上跑双系统的办法。当时，我突然看到一个项目叫做POSTMARKETOS，是在手机上面移植linux，但是当时一个是没时间再一个也不是很懂设备树什么的，但是就想着这件事，以后要研究怎么在手机上面移植Linux。另外当年最震撼的项目就算Renagade Project，在手机上安装Windows，这个可是我从小学开始的梦想啊！然后我就想着也许麒麟也可以移植UEFI（现在觉得这是不可能的我有点疯了）。另外一件事就是初二疫情的时候我入坑了Limbo模拟器吧，但是玩了一会儿发现手机模拟电脑架构速度太慢，所以就想着开KVM。当时KVM是圈子里面最高的神话。所以说我后来每次遇到一个手机/芯片，都想着在上面开KVM，但是到现在我还是没有研究清楚（现在状态毁了）。<br />\n从这件事来看，我当时还是有比较强烈的对计算机的热情的，虽然写不动算法竞赛题目的代码但是一些有趣的小项目工具我还是愿意写的，比如说yichafen爬虫，比如说谷歌小恐龙自动玩，还有写过OJ，虽然只是C++写的后端。还有当时我为什么还在用易语言写窗口程序！甚至和C语言结合起来！当时我为什么不想着学一门正经的窗口编程语言比如C#...但是我没有想过开发一个大型工程。当然当时更不会想着什么开发方向或者安全方向（虽然初二就研究过几次SQL注入但是发现大部分网站都修复了然后剩下的没有任何了解）。所以说这实际上也是埋下了一个伏笔。但是正常来说这样的状态大学接着系统的学习计算机或者打ICPC最后肯定看起来没什么问题，当然这是后话了。</p>\n<p>这种热情到NOIP前就已经消失殆尽了，当时为了停课都疯了，当时就好像一个失心魔，每天回家就要和父母大吵一架，大喊大叫(嗓子也喊坏了...)，然后在学校动不动早读的时候或者语文课的时候就砸桌子或者一个人跑出去然后开始哭，后来还写纸条给各科老师和主任希望只要有一个同意的。这样我的心态受到了很大的影响，本来想的是静下心思考认真训练，但是为了停课我的心态已经爆炸了心情已经很不好了，已经没有精力接着认真学习，而且这样我就感觉很急好像如果我NOIP考的不好所有人立马就会反对我，所以说实际上把所有希望都寄托在NOIP2022上了，这样自己一旦想不出题就特别焦虑，又不敢看题解，因为看题解之后我就感觉自己很傻然后心态更差了...所以那段时间每天投入大量的精力学习OI尤其是重心放在一些复杂的trick和思维题上面，当然也补了暑假zhengrui没学会的东西，但是收效甚微而且每天心情都很差经常大喊大叫然后很焦虑，然后基本上实际上一天什么也没干，而且我执行力差很多细节复杂的题的代码本来都没有写现在这个状态基本上就是只看题不写题了。<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3026852/202601/3026852-20260122000619030-1117947224.png\" /><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3026852/202601/3026852-20260122000629006-1193078129.png\" /><br />\n那时候的题单到后来也没写完...而且以前题目写错了尤其是思路错了我会心态很好的调试，然后换思路，但是从高中开始，我越来越惧怕这种失败了，这种浪费时间的失败，因为时间紧迫，所以说一旦想错了我就很自责，久而久之就害怕写代码调试了。所以说这可能是导致我代码能力下降的又一个重要原因。<br />\n所以说实际上这时候NOIP是注定要爆炸的，10月份开始就有很清晰的预感，只不过心里总是想着万一上天眷顾我一次呢！万一题目合我的胃口呢！<br />\n但是那时候我还有一丝希望，因为还有CSP！<br />\n当时是星期三，我那天又很生气，然后想着停课，毕竟马上CSP了，</p>\n<p>但是现在想想，其实OI的失败是必然的，我早就没有良好的心态了，而且我做事情的目的已经从纯粹的兴趣变成了我要被别人认可我要被别人承认我要拿到成绩，这种目的性太强了，而且我的执行能力比较差，虽然也尝试过很多比如列计划，整理笔记等方式但是效果只能说没什么用。而且我的精力严重不够，就像前面说的那样，看一会儿电脑就头疼，而且在电脑前思维非常的混乱，如果不借助草稿纸，甚至感觉不能正常的思考。（这个现在倒是好一点，但是就是效率太低）即使休息的很好第二天也是很累浑身乏力，更何况有时候我会陷入幻想根本睡不着。而且我总是有一种幻想就是我可以像淄博的那两位那样或者像lx那样从没有资源没有支持的地方逆袭翻盘，但是实际上我的天赋根本不支持如此，而且实际上那些大佬虽然在弱校但是却能够经常出去集训，也就是说能够把握一手的考试方向和主流的题目，而且有一个正常的人际交往，而且他们的天赋都比较厉害。而且OI也没有以前纯粹了，以前圈子的互帮互助分享交流变成了一种很奇怪的p话文化，不仅仅是卖弱这么简单，而是有时候感觉有一种强烈的歧视感，而且虽然资源现在是够多了但是主流的方向还是不好自己把握。而且，题目的难度正在变怪，从原来的考察代码能力+算法/数据结构积累能力+一定的思维能力 变成了 思维能力为主或者说是更加偏向于数竞这种启发性的考试了。这在工程意义上我觉得不是什么好事儿。但是，关键问题是，OI退役后，事情并没有好起来。</p>\n<p>NOIP出分之后，我还是不服气，当时疫情隔离结束之后返校了。结果，返校之后，老师把我桌子拖到了最后一排。返校之后课上当时还在继续学习准备省选知识点，那时候状态还可以，还想着省选还可以翻盘。但是，当时级部主任把我平板没收了，看我上课在看平板。然后我心情就挺差的。不过当时我还是有自信的毕竟我觉得NOIP的T3只要当时清醒一点把DP方程改对就一点问题没有了。但是后来，家长开始说我，让我开始补文化课，然后又拿期末考试说事儿。而且，当时，刚好疫情解封前最混乱的时期，在学校里面关了两个周。那时候我在想的一件事是，我到底有没有能力或者说有没有希望省选翻盘？我当时翻了Cmd2001大佬的博客（他是noip2017二等奖然后省选翻盘NOI2018Ag）的翻盘记录，看着充满希望。</p>\n<p>然后当时中午午休的时候没有宿舍住（因为我走读），就跑到二楼的那个据说是生物竞赛的活动室里面。里面有一台电脑。我中午就躲在里面把门反锁，打开电脑听歌，然后就在那里哭。<br />\n直到有一天，那天的中午我感觉很冷，别人都回去睡觉了，我吃完饭在教室里全身发冷，即使有暖气。然后我就怀揣着希望进了竞赛室。那天竞赛室还有别人，我就没有使用电脑，然后坐在那里。屋子里面开空调了，很暖和<br />\n。过了一会儿，生物竞赛教练进来了。我刚要开口，他就说：谁让你进来的？来着干什么？是不是来这玩电脑？ 然后我想了一会儿，硬生生地没有开口：我是信息竞赛生。然后想了想带上所有东西头也不回的走了。那一瞬间，有一种绝望感，就是一种被世界抛弃了。然后，哪天晚上我就发烧了，结果是感染新冠了。</p>\n<p>自从这件事之后，我突然有一种学不下去省选内容的感觉，而且有一种几乎命中注定的感觉：无论怎么努力省选也不可能翻盘。后来我就很少再跟别人提及OI。直到WC快报名的时候，zgx家长问我家长要不要报，我一看，WC竟然改成线上了，这让我感觉有一种走形式的感觉。我看到之前博客里面大家去WC然后互相交流面基的感觉很快乐，但是这种东西已经没有了。我意识到，WC很贵我要是报了我家长到时候一定拿掏钱这个事来PUA我，于是，我主动拒绝了。就这样，我OI就退役了。从这之后，上大学之前，我就再没有碰过一道算法竞赛题，没有学习任何一个新算法。</p>\n<p>然后，我意识到我回归不了WHK了。之前我设想的我能坦然回归whk至少是省选结束之后，然后按照我自己的节奏好好的学习一下WHK。但是现实是，回归之后，家长/老师对我期望很高，希望我回到扔whk搞OI之前的状态--就是高一下期末660+的状态。而且我根本没有理由向别人说我能自己做好这件事。因为很简单：我只是NOIP低分省一连省选都没打就退役了，也没有什么牌子。所以说实际上他们的期望更高了但是信任度更低了。所以说，我期末考的并不好。当时有点害怕，害怕到高三还是回不到之前的状态。（但是事实证明实际上就算不搞OI我可能也没有一个理想的状态，因为我的精力严重不够）然后寒假就是被家长拉去搞whk了。</p>\n<p>这时候，谁能想到一个东西即将再次撞击我的命运。</p>\n<p>考上少年班之后，当时其实我很高兴。我想到，三年前，我坐在阶梯教室里面，看着台上的学长热情洋溢地讲着自己的大学生活和高中的努力（而且真的看不出是高中生了，明显是适应了大学生活），我幻想着有一天也能像他们一样。但是现在，我的确做到了，甚至说比他们做的更好（毕竟是xha第一个去的），我利用自己的省一奖项，降一本线进入华东五校止一---USTC，这相当于我已经做到了自主招生时代所谓的一本约。我想着我终于可以拾起来我之前没有做的事情，我可以出去转一转，我要出去讲OI课，有一天我也要回学校宣讲。我希望有一天xha有自己的竞赛组织，能够请一些人讲课（就像那些学长博客里面提到的那样学校请他们回去讲课）（我看到一个重庆大学的都被邀请回去了）。我想着我终于能够被承认了，然后我就可以有我的自由，然后就可以有我自己的大学生活了。但是，现实里面有一种隐隐的不详的预感。那天出分之后第二天家长就不让我去学校了，当然说是保护我，我觉得有一点道理。但是我还想着回学校吹一手(bushi).然后问题来了，家长开始PUA我了。大概意思就是考上之后不能放松，要更努力，暑假要提前预习，然后说意思就是我没有这个能力就是运气好之类的...然后我就有一种失落感，总感觉这个不是自己考上的。然后我发现进入重点班之后我开始严重的缺乏安全感，每天都有一种被监视的感觉，当然不是因为重点班内卷，而是有一种刻意营造出来的感觉。所以说我开始缺乏自信。然后家长开始PUA我，所以我暑假也没有自己的自由干事情，而且我也没怎么自己出去，因为我发现自己出去在家里几乎是不可能的，家长总要找一个借口陪着我。客观的讲陪着我当然也很好，但是我还是喜欢和朋友（当然可能是初中朋友）或者是其他搞oi的同学出去。说实话。而且我根本不想预习大学的任何东西因为我OI欠下来的东西还没有填上。再者说我之前也自学过高数。当时我和家长提大学打ICPC，谁知道他们先说什么ICPC再好被退学了有什么用？然后又是开始吵架...然后我暑假去了之前我初二去的那个机构，虽然只学了一年实际上也就是语言入门但是还一直保持联系。结果去了之后我一点也不自在，本来是我考上好学校，而那个机构只有普及组教学的水平，按理来说我是完全有理由平等的过去交流甚至可以去那边讲课。但是现实是我家长去了然后就开始低声下气在那边问大学要准备什么？大学xxx怎么怎么样，然后又是听机构的创始人东扯西扯说一些大道理，但是现实是在那边听一个QDU和石油大学毕业的，而且大概率是计算机学的不怎么样的人的经验没什么参考价值(毕竟这个机构工资不高正经人谁去啊），跟我说的东西和USTC的现实实际上是一点对不上，然后又问ICPC怎么样，结果xxx竟然说什么ICPC对于这种大学没什么用。那我只能说没啥意思了，这就把我家长给忽悠住了，刚好他不想让我大学打ICPC。毕竟现实是USTC 2025 ICPC预选赛报名队伍数量是全国最多的。反正去了一下午感觉很不舒服，就好像在那边受罪一样，全程我都不怎么说话。这件事我就挺失望的。我感觉不管我做到多好都没有人真正认可我。但是为什么他们就能认可别的Oier呢?</p>\n<p>然后暑假家长还是不让我大学打游戏。其实说实话我不愿意打游戏，但是这样我感觉很不舒服，连手机横屏都不敢了。而且现实是我好像连网购都没有网购过。我好像自己买的东西都不敢往家带，因为家长会翻书包，然后就会说我。（之前停课写的纸条被翻出来还挨骂了...)</p>\n<p>暑假时候当时还是缺乏自信不敢找同学玩，但是当时也有人来主动找我，gxh当时来找我，然后本来我们两个玩玩就挺好的，我两个高一上是同班同学，关系也不差。但是非要也不知道为什么家长非要去。那就变成那种无聊的饭局了...然后说是我们两个随便聊，现实是我根本开不了口因为两个家长一直在那边谈什么教育（当然又是经典的那些了...），然后我就在那边看手机，然后家长又骂我一顿说我出去吃饭怎么不说话...</p>\n<p>然后暑假就闷在家里也不知道干什么，被勒令预习，但是肯定是学不下去的，然后别的事情又放松不下来不敢干。我感觉家里已经不是让我放松的地方了...出门就去一趟日照而且感觉挺没意思的...所以说那时候就有一种强烈的感觉，这个学校不是我自己考上的，是别人恩赐给我的...我的能力其实不配。然后一种失望的感觉。</p>\n<p>就这样这个暑假过得很失败，甚至没有调整好开学前的状态，就是我找不到那种我刚开始搞OI时候那种我为了一个美好的事物然后全力的投入尽可能每个方面都做的很好的状态了。</p>\n<p>开学之后，然后你就知道了，彻底的crash...<br />\n而且最重要的是心里一点安全感没有，有一种我所做的一切都在被监视的感觉，根本没法静下心来学习。而且，我又找不到我对计算机的热情了，我只看到了一种很茫然的内卷。然后就是一点点的crash、...</p>\n<p>所以说为什么会这样，还是因为我想要的东西不仅没有被满足反而越来越远了，而且严重的内卷导致曾经我认为很厉害的东西现在可能已经烂大街了，这就消磨了我的热情。更重要的是长久缺失正反馈，失去自信，失去那种自然而然地感觉，相反后来充满着警觉感，在家里不敢和朋友打电话，不敢提出去玩的事情，不敢在家里把手机横屏，在公共场合总感觉别人盯着我，外面手机亮度开到最低总感觉别人在看我的手机屏幕，上课不敢记笔记总感觉别人盯着我。感觉我失去了安全感，或者说我的自由 我的隐私空间 我想做的事情 以及支撑我学OI最大的目标/动力这些并没有随着我考上中科大少创而有所缓解，反而加重了。有一种全世界都在和我作对没有人认可我的感觉，有一种即使很尽力了但是没有人相信我的感觉，所以突然就不想再碰OI了。之前在OI时候立志要培养的良好习惯，包括坚持记笔记，坚持深度思考，提高自控力（因为我确实从小自控力差执行能力差拖延严重，现在我觉得有可能是ADHD？）这些我自己觉得我做的不错的事情没有人相信我，相反我好像就像坐在监牢里面一样，这就是一种深深的失望。而且我又一种我没办法检验我自己全部能力的感觉。我高中基本上不写作业语文英语从来不学，但是高考语文121英语128（平时能上130，毕竟是高二考），所以我认为停课一段时间之后再补WHK并不是很困难的事情，但是没有人相信我。当然也不要指望竞赛圈的人能理解我，毕竟我不混圈，或者说我当时并不想当什么圈子的网红，而且竞赛圈大把人小学开始学习竞赛在强校有着充足的资源进行停课训练，所以说他们都看不上我们这些弱校的。（毕竟我们这一届是第一个NOIP省一喵，当然第一个是zgx）</p>\n<p>为了OI我之前4年不打游戏（其实在学OI之前家里不让打但是偷偷打），然后初二自学初三数学初三自学高中数学离散的部分，然后每个暑假又被家长拉着预习了高中其他科目，高一自学高中数学剩下的部分。高中又自学高数，线代，组合数学的一部分，具体数学，甚至还有一点群论，目的都是为了OI，当时想着我要提高数学水平因为当年NOI2019考了一道具体数学原题，所以我认为OI需要很高的数学水平。虽然我自学时候效率确实很低，经常忍不住往后翻或者干别的，但是的确也学了不少内容。但是即使这样我还是不能停课，然后明明提前自学过还是要开学上课，那我说我寒暑假不要预习其他科目了，反正开学还要上课，但是家长拉着我预习而且还跟我说什么不然就考不上大学，什么竞赛影响文化课就不要弄了，反正我做什么都不会相信我的能力，所以说我久而久之也不知道自己到底有没有这个能力了。然后我的同学后来把我当成小丑看因为他们别的竞赛似乎从来不需要停课，老师也觉得我很菜没有那个水平还整天装。但是现实是我的确也没有那个能力，比如说我的执行能力差，以及容易分心，比如说网上很多的经验是把竞赛资料打印出来课上看，但是现实是课上我根本看不下去过一会儿就会被课程的声音吸引就走神了，自习课能好一点，但是有时候周边同学的打扰就会让我完全静不下心无法思考，甚至我在做题时候如果和机房的zgx交流一点解法（哪怕只是几句话，这就是为什么高中不和别人交流问题了）那么这一晚上基本上做不下去了（现在越看越像ADHD）。但是whk上却不是这样，whk的内容偏简单不需要深度思考，逻辑链很短，更多的是一个心态和熟练度的问题，也就是如何以高正确率保证考场答完题，所以来说，在whk上这些困扰没有体现出来。而且长时间的OI学习让我满脸长痘整天头疼，也完全没有心情打理任何东西，所以外貌和声音也没有以前那么可爱了（现在后悔了...),但是当时想着只要我在OI上拿到牌子那么一切都会好起来，别人就一定会承认我的，所以根本没有在意这些。我以为考上大学之后就能够重新拾起来这些东西看看自己到底有没有这个能力，谁知道那种不被认可的感觉那种失望感让我觉得我的确是废物我没有什么能力。更重要的是我有点失去了目标。而且更重要的是我有一种很强的挫败感，就是我自己想做的事情总是因为各种原因做不好或者达不成希望，这可能就是我执行力太差加上命中缺这一环吧，我好像什么也干不好。大学之后，我原来想要的东西并没有实现，可是，来到科大，我并没有很快开始学习熟悉的计算机，相反，学校的数理基础课程占满了我的时间，别人都在内卷、科研，我想象中一个计算机式的大学生活并没有出现。（至少在我的印象里或者我看到学长宣讲/大佬博客的印象里），而且实际上我好像很多事情都还不会做。<br />\n高中时候实际上和同学关系也不算太差，但是也没有特别好的朋友 ，实际上也没什么社交，对异性也没什么兴趣（甚至说对性行为没什么兴趣）。高中也没有手机也不看什么娱乐的，虽然我破解了学校的学习平板，但是只是在上面看数学书/oi题/知乎上的学习性文章。生活上面实际上我很希望自由甚至说某种意义上学OI本身就是为了追求某种自由，但是高中时候学校家长没有给我这些，当时我也不是很在意因为所有心思都在OI上面，但是现在当我真正需要这些东西的时候发现好像我做不好生活上面的一些小事（当然也许是有ADHD导致的？），而且就像前面说的那样我失去了安全感。</p>\n<p>然后现在好想放松一下。</p>\n\n</div>\n<div id=\"MySignature\">\n    <p>黄粱一梦，终是一空</p>\n\n<p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/hicode002/\" target=\"_blank\">hicode002</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/hicode002/p/-/oi-memories\" target=\"_blank\">https://www.cnblogs.com/hicode002/p/-/oi-memories</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 11:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/hicode002\">hicode002</a>&nbsp;\n阅读(<span id=\"post_view_count\">75</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Stern-Brocot 树",
      "link": "https://www.cnblogs.com/rgw2010/p/19525731",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/rgw2010/p/19525731\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 11:39\">\n    <span>Stern-Brocot 树</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"p1797-模板stern-brocot-树\"><a href=\"https://www.luogu.com.cn/problem/P1797\" rel=\"noopener nofollow\" target=\"_blank\">P1797 【模板】Stern-Brocot 树</a></h2>\n<p><a href=\"https://www.luogu.com.cn/article/dv07cla2\" rel=\"noopener nofollow\" target=\"_blank\"><strong>洛谷同步题解。</strong></a></p>\n<blockquote>\n<p>前置知识：<span class=\"math inline\">\\(a \\perp b\\)</span> 等价于存在 <span class=\"math inline\">\\(x, y\\)</span> 使得 <span class=\"math inline\">\\(ax + by = 1\\)</span>。</p>\n</blockquote>\n<p>Stern-Brocot 树是一个包含着所有 <span class=\"math inline\">\\(m \\perp n\\)</span> 的全部非负的分数 <span class=\"math inline\">\\(\\frac{m}{n}\\)</span> 的二叉树结构；其思想是从 <span class=\"math inline\">\\(0\\)</span> 阶 Stern-Brocot 序列 <span class=\"math inline\">\\(\\{\\frac{0}{1}, \\frac{1}{0} \\}\\)</span> 出发，高阶 Stern-Brocot 序列由以下递归操作定义：</p>\n<ul>\n<li>对于一个 <span class=\"math inline\">\\(k\\)</span> 阶 Stern-Brocot 序列，在其任意两个相邻分数 <span class=\"math inline\">\\(\\frac{m}{n}\\)</span> 与 <span class=\"math inline\">\\(\\frac{m'}{n'}\\)</span> 之间插入它们的<strong>中位分数</strong> <span class=\"math inline\">\\(\\frac{m + m'}{n + n'}\\)</span> 后形成的序列即为 <span class=\"math inline\">\\(k + 1\\)</span> 阶  Stern-Brocot 序列。</li>\n</ul>\n<p>例如：</p>\n<ul>\n<li>\n<p><span class=\"math inline\">\\(1\\)</span> 阶是 <span class=\"math inline\">\\(\\{ \\frac{0}{1}, \\frac{1}{1}, \\frac{1}{0} \\}\\)</span>。</p>\n</li>\n<li>\n<p><span class=\"math inline\">\\(2\\)</span> 阶是 <span class=\"math inline\">\\(\\{ \\frac{0}{1}, \\frac{1}{2}, \\frac{1}{1}, \\frac{2}{1}, \\frac{1}{0} \\}\\)</span>。</p>\n</li>\n<li>\n<p><span class=\"math inline\">\\(3\\)</span> 阶是 <span class=\"math inline\">\\(\\{ \\frac{0}{1}, \\frac{1}{3}, \\frac{1}{2}, \\frac{2}{3}, \\frac{1}{1}, \\frac{3}{2}, \\frac{2}{1}, \\frac{3}{1}, \\frac{1}{0} \\}\\)</span>。</p>\n</li>\n</ul>\n<p>容易看作二叉树的结构：</p>\n<ul>\n<li>每个分数都是 <span class=\"math inline\">\\(\\frac{m + m'}{n + n'}\\)</span> 的形式，其中 <span class=\"math inline\">\\(\\frac{m}{n}\\)</span> 是左上方离它最近的祖先，<span class=\"math inline\">\\(\\frac{m'}{n'}\\)</span> 是右上方离它最近的祖先。</li>\n</ul>\n<p>oi-wiki 上的图较为形象，大家可以看着理解下：</p>\n<p><img alt=\"\" src=\"https://oi-wiki.org/math/number-theory/images/stern-brocot-tree.svg\" /></p>\n<p>为什么树上的都是最简分数？为什么不会重复出现某个分数？为什么所有可能的非负的最简分数都会在树上出现？</p>\n<p>容易发现这样一个性质，如果 <span class=\"math inline\">\\(\\frac{m}{n}\\)</span> 和 <span class=\"math inline\">\\(\\frac{m'}{n'}\\)</span> 在某一阶的 Stern-Brocot 序列中相邻，那么必然满足：</p>\n<p></p><div class=\"math display\">\\[m'n - mn' = 1\n\\]</div><p></p><blockquote>\n<p>证明考虑数学归纳法，初始 <span class=\"math inline\">\\(0\\)</span> 阶时有 <span class=\"math inline\">\\(1 \\cdot 1 - 0 \\cdot 0 = 1\\)</span>；若当前 <span class=\"math inline\">\\(k\\)</span> 阶 Stern-Brocot 序列中满足条件，那么在 <span class=\"math inline\">\\(\\frac{m}{n}\\)</span> 与 <span class=\"math inline\">\\(\\frac{m'}{n'}\\)</span> 中间插入的 <span class=\"math inline\">\\(\\frac{m + m'}{n + n'}\\)</span>，相当于要证明：</p>\n<p></p><div class=\"math display\">\\[(m' + m)n - m(n + n') = 1\n\\]</div><p></p><p></p><div class=\"math display\">\\[m'(n + n') - (m + m') n' = 1\n\\]</div><p></p><p>第一个直接拆开 <span class=\"math inline\">\\(m'n + mn - mn - mn' = m'n - mn' = 1\\)</span>，第二个同理；于是得证。</p>\n</blockquote>\n<p>同时，上面 <span class=\"math inline\">\\(m'n - mn' = 1\\)</span> 这个式子也可以说明 <span class=\"math inline\">\\(m \\perp n, m' \\perp n'\\)</span>，那么可以得到树上的所有分数必然是<strong>最简分数</strong>。</p>\n<p>然后来考虑插入的分数的大小关系，显然有：</p>\n<p></p><div class=\"math display\">\\[\\frac{m}{n} &lt; \\frac{m + m'}{n + n'} &lt; \\frac{m'}{n}\n\\]</div><p></p><p>即一个中位分数在它原先两个值的中间，于是树上必然没有重复的分数。</p>\n<p>好，接下来要证所有正的最简分数 <span class=\"math inline\">\\(\\frac{a}{b}\\)</span> 都在树上出现，考虑反证法，初始显然：</p>\n<p></p><div class=\"math display\">\\[\\frac{m = 0}{n = 1} &lt; \\frac{a}{b} &lt; \\frac{m' = 1}{n' = 0}\n\\]</div><p></p><p>然后假设当前阶段有：</p>\n<p></p><div class=\"math display\">\\[\\frac{m}{n} &lt; \\frac{a}{b} &lt; \\frac{m'}{n'}\n\\]</div><p></p><p>考虑 <span class=\"math inline\">\\(\\frac{m + m'}{n + n'}\\)</span> 与 <span class=\"math inline\">\\(\\frac{a}{b}\\)</span> 的大小关系：</p>\n<ul>\n<li>\n<p>若 <span class=\"math inline\">\\(\\frac{m + m'}{n + n'} = \\frac{a}{b}\\)</span>，与命题矛盾，退出。</p>\n</li>\n<li>\n<p>若 <span class=\"math inline\">\\(\\frac{m + m'}{n + n'} &lt; \\frac{a}{b}\\)</span>，令 <span class=\"math inline\">\\(m \\gets m + m', n' + n\\)</span>。</p>\n</li>\n<li>\n<p>否则 <span class=\"math inline\">\\(\\frac{m + m'}{n + n'} &gt; \\frac{a}{b}\\)</span>，令 <span class=\"math inline\">\\(m' \\gets m + m', n' \\gets n + n'\\)</span>。</p>\n</li>\n</ul>\n<p>考虑证明这个过程不会无限进行下去，因为：</p>\n<p></p><div class=\"math display\">\\[\\begin{cases} \\frac{a}{b} - \\frac{m}{n} &gt; 0 \\\\ \\frac{m'}{n'} - \\frac{a}{b} &gt; 0 \\end{cases}\n\\]</div><p></p><p>即：</p>\n<p></p><div class=\"math display\">\\[\\begin{cases} an - mb &gt; 0 \\\\ m'b - n'a &gt; 0 \\end{cases}\n\\]</div><p></p><p>显然 <span class=\"math inline\">\\(an - mb, m'b - n'a\\)</span> 都是整数，于是：</p>\n<p></p><div class=\"math display\">\\[\\begin{cases} an - mb \\ge 1 \\\\ m'b - n'a \\ge 1 \\end{cases}\n\\]</div><p></p><p>然后必然有：</p>\n<p></p><div class=\"math display\">\\[(m' + n')(an - mb) + (m + n)(m'b - n'a) \\ge m' + n' + m + n\n\\]</div><p></p><p>前面把 <span class=\"math inline\">\\(a\\)</span> 和 <span class=\"math inline\">\\(b\\)</span> 专门提出来：</p>\n<p></p><div class=\"math display\">\\[a(n(m' + n') - n'(m + n)) + b(m'(m + n) - m(m' + n'))\n\\]</div><p></p><p>然后它们的系数可以根据 <span class=\"math inline\">\\(m'n - mn' = 1\\)</span> 化简成 <span class=\"math inline\">\\(1\\)</span>，于是：</p>\n<p></p><div class=\"math display\">\\[a + b \\ge m' + n' + m + n\n\\]</div><p></p><p>而上面每次操作中 <span class=\"math inline\">\\(m' + n' + m + n\\)</span> 都会增加，于是至多进行 <span class=\"math inline\">\\(a + b\\)</span> 次后就会退出，即找到 <span class=\"math inline\">\\(\\frac{a}{b}\\)</span>；于是证明了<strong>所有非负分数即正有理数</strong>都在树上，可以将 Stern-Brocot 树看作一个<strong>有理数的数系</strong>。</p>\n<p>因为每个正最简分数只出现一次，所以其与树上从根到它的路径是一一对应的，即我们可以用字母 <span class=\"math inline\">\\(L, R\\)</span> 来表示当前节点是往左右哪个儿子去走，一串 <span class=\"math inline\">\\(L, R\\)</span> 组成的序列就唯一的表示了一个位置；例如 <span class=\"math inline\">\\(LRRL\\)</span> 表示 <span class=\"math inline\">\\(\\frac{1}{1} \\to \\frac{1}{2} \\to \\frac{2}{3} \\to \\frac{3}{4} \\to \\frac{5}{7}\\)</span>；特别的，对于 <span class=\"math inline\">\\(\\frac{1}{1}\\)</span> 用 <span class=\"math inline\">\\(I\\)</span> 来表示。</p>\n<p>考虑这样一个问题，给出一组 <span class=\"math inline\">\\(L, R\\)</span> 组成的字符串 <span class=\"math inline\">\\(S\\)</span>，求出其对应的分数是什么？</p>\n<p>容易想到从初始 <span class=\"math inline\">\\(\\frac{1}{1}\\)</span> 开始，动态维护这个点是由左右哪两个节点合并的，初始是 <span class=\"math inline\">\\(\\frac{m = 0}{n = 1}, \\frac{m' = 1}{n' = 0}\\)</span>：</p>\n<ul>\n<li>\n<p>若 <span class=\"math inline\">\\(L\\)</span> 往左走：那么左祖先不会变，右祖先会变成当前节点；即 <span class=\"math inline\">\\(m' \\gets m + m', n' \\gets n + n'\\)</span>。</p>\n</li>\n<li>\n<p>若 <span class=\"math inline\">\\(R\\)</span> 往右左：同理，那么右祖先不会变，左祖先会变成当前节点；即 <span class=\"math inline\">\\(m \\gets m + m', n \\gets n + n'\\)</span>。</p>\n</li>\n</ul>\n<p>大家理解的时候可以看前面那个树的图来理解；然后我们就可以写下如下代码解决：</p>\n<pre><code class=\"language-cpp\">inline pair&lt;int, int&gt; getLR(string s){\n\tint len = s.size();\n\tint m = 0, n = 1, m_ = 1, n_ = 0;\n\tfor(int i = 0; i &lt; len; ++i){\n\t\tif(s[i] == 'L')\n\t\t  m_ = m + m_, n_ = n + n_;\n\t\telse\n\t\t  m = m + m_, n = n + n_;\n\t}\n\treturn mkp(m + m_, n + n_);\n}\n</code></pre>\n<p>当长度很长时，即给定是 <span class=\"math inline\">\\(L/R\\)</span> 每次走几次，也可以根据式子直接做：</p>\n<pre><code class=\"language-cpp\">inline pair&lt;int, int&gt; getLR(vector&lt;pair&lt;char, int&gt;&gt; s){\n\tint len = s.size();\n\tint m = 0, n = 1, m_ = 1, n_ = 0;\n\tfor(int i = 0; i &lt; len; ++i){\n\t\tif(s[i].fi == 'L')\n\t\t\tm_ = s[i].se * m + m_, n_ = s[i].se * n + n_;\n\t\telse\n\t\t\tm = m + s[i].se * m_, n = n + s[i].se * n_;\n\t}\n\treturn mkp(m + m_, n + n_);\n}\n</code></pre>\n<p>这种还是太程序性了，数学语言怎么表示？容易想到矩阵，即初始：</p>\n<p></p><div class=\"math display\">\\[M(S) = \\begin{pmatrix} n &amp; n' \\\\ m &amp; m' \\end{pmatrix}\n\\]</div><p></p><p>这里为啥不用像分数那样上面分子下面分母呢？主要是此时初始根节点的状态 <span class=\"math inline\">\\(M(I) =  \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 1 \\end{pmatrix}\\)</span> 这是一个单位矩阵，而用分数的表示形式的话不是单位矩阵要多乘一个矩阵，形式上也不那么清晰。</p>\n<p>然后考虑：</p>\n<p></p><div class=\"math display\">\\[M(SL) = \\begin{pmatrix} n &amp; n + n' \\\\ m &amp; m + m' \\end{pmatrix}\n\\]</div><p></p><p></p><div class=\"math display\">\\[M(SR) = \\begin{pmatrix} n + n' &amp; n' \\\\ m + m' &amp; m' \\end{pmatrix}\n\\]</div><p></p><p>那么可以推出 <span class=\"math inline\">\\(L, R\\)</span> 矩阵：</p>\n<p></p><div class=\"math display\">\\[L = \\begin{pmatrix} 1 &amp; 1 \\\\ 0 &amp; 1 \\end{pmatrix}\n\\]</div><p></p><p></p><div class=\"math display\">\\[R = \\begin{pmatrix} 1 &amp; 0 \\\\ 1 &amp; 1 \\end{pmatrix}\n\\]</div><p></p><p>即：</p>\n<p></p><div class=\"math display\">\\[M(SL) = M(S) L, M(SR) = M(S) R\n\\]</div><p></p><p>于是求 <span class=\"math inline\">\\(M(S)\\)</span> 时，可以看作是 <span class=\"math inline\">\\(S\\)</span> 中的 <span class=\"math inline\">\\(L, R\\)</span> 作矩阵乘法，例如 <span class=\"math inline\">\\(M(LRRL) = LRRL = \\begin{pmatrix} 1 &amp; 1 \\\\ 0 &amp; 1 \\end{pmatrix} \\begin{pmatrix} 1 &amp; 0 \\\\ 1 &amp; 1 \\end{pmatrix} \\begin{pmatrix} 1 &amp; 0 \\\\ 1 &amp; 1 \\end{pmatrix} \\begin{pmatrix} 1 &amp; 1 \\\\ 0 &amp; 1 \\end{pmatrix} = \\begin{pmatrix} 3 &amp; 4 \\\\ 2 &amp; 3 \\end{pmatrix}\\)</span>。</p>\n<p>于是求 <span class=\"math inline\">\\(S\\)</span> 所对应的分数只需要经过矩阵运算得到：</p>\n<p></p><div class=\"math display\">\\[f(S) = f(\\begin{pmatrix} n &amp; n' \\\\ m &amp; m' \\end{pmatrix}) = \\frac{m + m'}{n + n'}\n\\]</div><p></p><p>那么现在考虑给定一个分数 <span class=\"math inline\">\\(\\frac{m}{n}\\)</span>，求其唯一对应 <span class=\"math inline\">\\(LR\\)</span> 序列这个问题？这就比较简单了，根据生成规则，我们知道 Stern-Brocot 树是一颗二叉搜索树，即左子树的点都比它小，右子树的点都比它大，于是可以通过比较与当前位置的值来决定。</p>\n<p>那么可以写下如下代码：</p>\n<pre><code class=\"language-cpp\">inline string backLR(int m, int n){\n\tstring ans = \"\";\n\tMat S;\n\twhile(1){\n\t\tauto t = f(S);\n\t\tif(t == mkp(m, n))\n\t\t  break;\n\t\tif(mkp(m, n) &lt; t){\n\t\t\tS = S * L;\n\t\t\tans.push_back('L');\n\t\t}\n\t\telse{\n\t\t\tS = S * R;\n\t\t\tans.push_back('R');\n\t\t}\n\t}\n\treturn ans;\n}\n</code></pre>\n<p>显然，这个效率较为低下，且要进行矩阵运算；考虑怎么优化一下，注意到：</p>\n<p></p><div class=\"math display\">\\[RS = \\begin{pmatrix} n &amp; n' \\\\ m + n &amp; m'  + n'\\end{pmatrix}\n\\]</div><p></p><p></p><div class=\"math display\">\\[LS = \\begin{pmatrix} n + m&amp; n' + m' \\\\ m&amp; m'\\end{pmatrix}\n\\]</div><p></p><p>那么：</p>\n<p></p><div class=\"math display\">\\[f(RS) = \\frac{n + n'}{m + n + m' + n'} = f(S) + 1\n\\]</div><p></p><p></p><div class=\"math display\">\\[f(LS) = \\frac{n + m + n' + m'}{m + m'}\n\\]</div><p></p><p></p><div class=\"math display\">\\[\\frac{1}{f(LS)} = \\frac{1}{f(LS)} + 1\n\\]</div><p></p><p>设 <span class=\"math inline\">\\(F(\\frac{p}{q})\\)</span> 表示其对应的字符串；那么我们可以看出，若第一步为 <span class=\"math inline\">\\(R\\)</span>，则 <span class=\"math inline\">\\(\\frac{m}{n} &gt; 1\\)</span>，否则第一步为 <span class=\"math inline\">\\(L\\)</span>，则 <span class=\"math inline\">\\(\\frac{m}{n} &lt; 1\\)</span>，于是可以递归的去做：</p>\n<p></p><div class=\"math display\">\\[\\frac{m}{n} = f(RS) \\to \\frac{m - n}{n} = f(S)  (m &gt; n)\n\\]</div><p></p><p></p><div class=\"math display\">\\[F(\\frac{m}{n}) = R + F(\\frac{n}{m - n}) (m &gt; n)\n\\]</div><p></p><p></p><div class=\"math display\">\\[\\frac{m}{n} = f(LS) \\to \\frac{m}{n - m} = f(S) (m &lt; n)\n\\]</div><p></p><p></p><div class=\"math display\">\\[F(\\frac{m}{n}) = L + F(\\frac{m}{n - m}) (m &lt;n)\n\\]</div><p></p><p>那么可以写出如下代码：</p>\n<pre><code class=\"language-cpp\">inline string backLR(int m, int n){\n\tstring ans = \"\";\n\twhile(m != n){\n\t\tif(m &lt; n){\n\t\t\tans.push_back('L');\n\t\t\tn = n - m;\n\t\t}\n\t\telse{\n\t\t\tans.push_back('R');\n\t\t\tm = m - n;\n\t\t}\n\t}\n\treturn ans;\n}\n</code></pre>\n<p>你发现这特别像更像减损法，于是可以用辗转相除法类似的思路去优化，即：</p>\n<pre><code class=\"language-cpp\">inline vector&lt;pair&lt;char, int&gt;&gt; backLR(int m, int n){\n\tvector&lt;pair&lt;char, int&gt;&gt; ans;\n\twhile(m &amp;&amp; n &amp;&amp; m != n){\n\t\tif(m &lt; n){\n\t\t\tif(n % m == 0)\n\t\t\t  ans.push_back({'L', n / m - 1});\n\t\t\telse\n\t\t\t  ans.push_back({'L', n / m});\n\t\t\tn = n % m;\n\t\t}\n\t\telse{\n\t\t\tif(m % n == 0)\n\t\t\t  ans.push_back({'R', m / n - 1});\n\t\t\telse\n\t\t\t  ans.push_back({'R', m / n});\n\t\t\tm = m % n;\n\t\t}\n\t}\n\treturn ans;\n}\n</code></pre>\n<p>此时就可以做到 <span class=\"math inline\">\\(O(\\log n)\\)</span> 复杂度去找对应的路径。</p>\n<p>然后对于一个分数 <span class=\"math inline\">\\(\\frac{p}{q}\\)</span>，考虑其在树上一个子树 <span class=\"math inline\">\\(S\\)</span>，显然 <span class=\"math inline\">\\(S\\)</span> 是无限大的，但是显然其有界，在 <span class=\"math inline\">\\((\\frac{a}{b}, \\frac{c}{d})\\)</span> 之间，那么怎么求出 <span class=\"math inline\">\\(a, b, c, d\\)</span> 呢？回到前面每次插入的中位分数在两个值之间的性质，于是这只是换一个问法，显然只是在问合并出 <span class=\"math inline\">\\(\\frac{p = a + c}{q = b + d}\\)</span> 的是哪两个分数，比较简单，求出 <span class=\"math inline\">\\(\\frac{p}{q}\\)</span> 的 <span class=\"math inline\">\\(LR\\)</span> 串后模拟一下即可。</p>\n<p>对于树上问题，容易想到 LCA，那么考虑 Stern-Brocot 树上的两个点 <span class=\"math inline\">\\(\\frac{a}{b}, \\frac{c}{d}\\)</span>，怎么求出它们的 LCA？容易发现，找到 <span class=\"math inline\">\\(\\frac{a}{b}, \\frac{c}{d}\\)</span> 的 <span class=\"math inline\">\\(LR\\)</span> 串 <span class=\"math inline\">\\(F(\\frac{a}{c}), F(\\frac{c}{d})\\)</span>，它们 LCP 的长度就是它们 LCA 的深度；而这个长度是容易求的，然后它们的 LCA 就是这个 LCP 对应的节点，套用上面函数一下即可。</p>\n<p>同理，<span class=\"math inline\">\\(\\frac{p}{q}\\)</span> 的树上 <span class=\"math inline\">\\(k\\)</span> 级祖先也是可以算出 <span class=\"math inline\">\\(F(\\frac{p}{q})\\)</span> 后删掉末尾的 <span class=\"math inline\">\\(k\\)</span> 个字符后套用前面函数得出。</p>\n<p>显然单次时间复杂度都是 <span class=\"math inline\">\\(O(\\log w)\\)</span>，总时间复杂度为 <span class=\"math inline\">\\(O(T \\log w)\\)</span>。</p>\n<p><a href=\"https://www.luogu.com.cn/record/258759645\" rel=\"noopener nofollow\" target=\"_blank\">link</a></p>\n<h3 id=\"完整代码\">完整代码：</h3>\n<pre><code class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\n#define ls(k) k &lt;&lt; 1\n#define rs(k) k &lt;&lt; 1 | 1\n#define lowbit(x) x &amp; (-x)\n#define fi first\n#define se second\n#define popcnt(x) __builtin_popcount(x)\n#define open(s1, s2) freopen(s1, \"r\", stdin), freopen(s2, \"w\", stdout);\n#define mkp(x, y) make_pair(x, y)\nusing namespace std;\ntypedef __int128 __;\ntypedef long double lb;\ntypedef double db;\ntypedef unsigned long long ull;\ntypedef long long ll;\nbool Begin;\ninline ll read(){\n\tll x = 0, f = 1;\n\tchar c = getchar();\n\twhile(c &lt; '0' || c &gt; '9'){\n\t\tif(c == '-')\n\t\t\tf = -1;\n\t\tc = getchar();\n\t}\n\twhile(c &gt;= '0' &amp;&amp; c &lt;= '9'){\n\t\tx = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);\n\t\tc = getchar();\n\t}\n\treturn x * f;\n}\ninline void write(ll x){\n\tif(x &lt; 0){\n\t\tputchar('-');\n\t\tx = -x;\n\t}\n\tif(x &gt; 9)\n\t\twrite(x / 10);\n\tputchar(x % 10 + '0');\n}\ninline pair&lt;int, int&gt; getLR(vector&lt;pair&lt;char, int&gt;&gt; s){\n\tint len = s.size();\n\tint m = 0, n = 1, m_ = 1, n_ = 0;\n\tfor(int i = 0; i &lt; len; ++i){\n\t\tif(s[i].fi == 'L')\n\t\t\tm_ = s[i].se * m + m_, n_ = s[i].se * n + n_;\n\t\telse\n\t\t\tm = m + s[i].se * m_, n = n + s[i].se * n_;\n\t}\n\treturn mkp(m + m_, n + n_);\n}\ninline vector&lt;pair&lt;char, int&gt;&gt; backLR(int m, int n){\n\tvector&lt;pair&lt;char, int&gt;&gt; ans;\n\twhile(m &amp;&amp; n &amp;&amp; m != n){\n\t\tif(m &lt; n){\n\t\t\tif(n % m == 0)\n\t\t\t  ans.push_back({'L', n / m - 1});\n\t\t\telse\n\t\t\t  ans.push_back({'L', n / m});\n\t\t\tn = n % m;\n\t\t}\n\t\telse{\n\t\t\tif(m % n == 0)\n\t\t\t  ans.push_back({'R', m / n - 1});\n\t\t\telse\n\t\t\t  ans.push_back({'R', m / n});\n\t\t\tm = m % n;\n\t\t}\n\t}\n\treturn ans;\n}\ninline pair&lt;int, int&gt; getkfa(int m, int n, int k){\n\tauto V = backLR(m, n);\n\tint sum = 0, len = V.size();\n\tfor(int i = 0; i &lt; len; ++i)\n\t  sum += V[i].se;\n\tif(sum &lt; k)\n\t  return mkp(-1, -1);\n\tvector&lt;pair&lt;char, int&gt;&gt; fa;\n\tfor(int i = 0; i &lt; len; ++i){\n\t\tif(!k)\n\t\t  break;\n\t\tif(V[i].se &lt;= k){\n\t\t\tfa.push_back(V[i]);\n\t\t\tk -= V[i].se;\n\t\t}\n\t\telse{\n\t\t\tfa.push_back(mkp(V[i].fi, k));\n\t\t\tk = 0;\n\t\t}\n\t}\n\treturn getLR(fa);\n}\ninline pair&lt;pair&lt;int, int&gt;, pair&lt;int, int&gt;&gt; range(int p, int q){\n\tauto s = backLR(p, q);\n\tint len = s.size();\n\tint m = 0, n = 1, m_ = 1, n_ = 0;\n\tfor(int i = 0; i &lt; len; ++i){\n\t\tif(s[i].fi == 'L')\n\t\t\tm_ = s[i].se * m + m_, n_ = s[i].se * n + n_;\n\t\telse\n\t\t\tm = m + s[i].se * m_, n = n + s[i].se * n_;\n\t}\n\treturn mkp(mkp(m, n), mkp(m_, n_));\n}\ninline pair&lt;int, int&gt; getlca(int a, int b, int c, int d){\n\tauto A = backLR(a, b), B = backLR(c, d);\n\tint s1 = 0, s2 = 0;\n\tfor(auto v : A)\n\t  s1 += v.se;\n\tfor(auto v : B)\n\t  s2 += v.se;\n\tif(s1 &lt; s2){\n\t\tswap(a, c), swap(b, d);\n\t\tswap(A, B);\n\t}\n\tvector&lt;pair&lt;char, int&gt;&gt; lca;\n\tint j = 0;\n\tfor(int i = 0; i &lt; (int)A.size(); ++i){\n\t\tint s = A[i].se;\n\t\twhile(j &lt; (int)B.size() &amp;&amp; s){\n\t\t\tif(B[j].fi != A[i].fi)\n\t\t\t  break;\n\t\t\tif(B[j].se &lt;= s){\n\t\t\t\ts -= B[j].se;\n\t\t\t\t++j;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tB[j].se -= s;\n\t\t\t\ts = 0;\n\t\t\t}\n\t\t}\n\t\tif(j == (int)B.size() || s){\n\t\t\tlca.push_back(mkp(A[i].fi, A[i].se - s));\n\t\t\tbreak;\n\t\t}\n\t\tlca.push_back(A[i]);\n\t}\n\treturn getLR(lca);\n}\nint T, a, b, c, d, p, q, len, x, k;\nchar C;\nchar op[20];\nint main(){\n\tT = read();\n\twhile(T--){\n\t\tscanf(\"%s\", op);\n\t\tif(op[0] == 'E'){\n\t\t\tp = read(), q = read();\n\t\t\tauto V = backLR(p, q);\n\t\t\twrite(V.size());\n\t\t\tputchar(' ');\n\t\t\tfor(auto t : V){\n\t\t\t\tputchar(t.fi);\n\t\t\t\tputchar(' ');\n\t\t\t\twrite(t.se);\n\t\t\t\tputchar(' ');\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t\telse if(op[0] == 'D'){\n\t\t\tvector&lt;pair&lt;char, int&gt;&gt; V;\n\t\t\tlen = read();\n\t\t\twhile(len--){\n\t\t\t\tC = getchar();\n\t\t\t\tx = read();\n\t\t\t\tV.push_back({C, x});\n\t\t\t}\n\t\t\tauto t = getLR(V);\n\t\t\twrite(t.fi);\n\t\t\tputchar(' ');\n\t\t\twrite(t.se);\n\t\t\tputchar('\\n');\n\t\t}\n\t\telse if(op[0] == 'L'){\n\t\t\ta = read(), b = read(), c = read(), d = read();\n\t\t\tauto t = getlca(a, b, c, d);\n\t\t\twrite(t.fi);\n\t\t\tputchar(' ');\n\t\t\twrite(t.se);\n\t\t\tputchar('\\n');\n\t\t}\n\t\telse if(op[0] == 'A'){\n\t\t\tk = read(), a = read(), b = read();\n\t\t\tauto t = getkfa(a, b, k);\n\t\t\tif(t.fi &lt; 0){\n\t\t\t\tputs(\"-1\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twrite(t.fi);\n\t\t\tputchar(' ');\n\t\t\twrite(t.se);\n\t\t\tputchar('\\n');\t\t\t\n\t\t}\n\t\telse{\n\t\t\ta = read(), b = read();\n\t\t\tauto t = range(a, b);\n\t\t\twrite(t.fi.fi);\n\t\t\tputchar(' ');\n\t\t\twrite(t.fi.se);\n\t\t\tputchar(' ');\t\n\t\t\twrite(t.se.fi);\n\t\t\tputchar(' ');\n\t\t\twrite(t.se.se);\n\t\t\tputchar('\\n');\t\n\t\t}\n\t}\n\treturn 0;\n}\n</code></pre>\n<h3 id=\"uva11350-stern-brocot-tree\"><a href=\"https://www.luogu.com.cn/problem/UVA11350\" rel=\"noopener nofollow\" target=\"_blank\">UVA11350 Stern-Brocot Tree</a></h3>\n<p><a href=\"https://www.luogu.com.cn/article/ol2ri7ez\" rel=\"noopener nofollow\" target=\"_blank\"><strong>洛谷同步题解。</strong></a></p>\n<p>模版这有，使用 <code>getLR</code> 即可。</p>\n<p><a href=\"https://www.luogu.com.cn/record/258771627\" rel=\"noopener nofollow\" target=\"_blank\">link</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 11:39</span>&nbsp;\n<a href=\"https://www.cnblogs.com/rgw2010\">rgw2010</a>&nbsp;\n阅读(<span id=\"post_view_count\">34</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "新书《鸿蒙HarmonyOS 6应用开发：从零基础到App上线》出版啦",
      "link": "https://www.cnblogs.com/aqi00/p/19504825",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aqi00/p/19504825\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 11:23\">\n    <span>新书《鸿蒙HarmonyOS 6应用开发：从零基础到App上线》出版啦</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<span><span>​</span></span><span id=\"cke_bm_160S\">基于最新鸿蒙系统的技术书籍《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》上市啦，要知道 HarmonyOS 6 在一个多月前的10月22日才正式发布，因此这本鸿蒙教程可谓贴近最新的 HarmonyOS 6 系统。</span>\n<p><span id=\"cke_bm_160S\"> 当前 HarmonyOS 6 的装机量迅猛增长，有望在春节前突破5000万台大关，可见鸿蒙系统的应用开发将越来越流行，甚至借助国产化的浪潮，未来在国内移动操作系统领域一举夺魁也不是不可能。<br />\n有鉴于此，博主精心编撰了 HarmonyOS 6 的应用开发教程《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》，从基础到高级，从理论到实战，从 UI 到 AI ，仅需一本书籍，即可让读者掌握鸿蒙应用的常见开发技能。</span></p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"鸿蒙应用开发\" class=\"lazyload\" height=\"436\" width=\"436\" /></span></span></span></span></p>\n<p>鸿蒙应用开发与安卓应用开发同为App开发，比如鸿蒙版微信和安卓版微信都是即时通信App，二者在实现技术上并无多少本质区别。所以《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》一书以《Android Studio开发实战：从零基础到App上线(第3版)》为蓝本，把安卓系统的App教程改造为鸿蒙系统的App教程，以便安卓开发者能够按图索骥迅速上手。欣喜的是，《Android Studio开发实战：从零基础到App上线(第3版)》提到的安卓开发技术，绝大部分都能在鸿蒙系统找到对应的平替技术，而且还是更简单的代码实现。<br />\n作为《Android Studio开发实战：从零基础到App上线(第3版)》一书的鸿蒙姊妹篇，《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》仍然采取了由浅入深、循序渐进的章节体例，其中前8章是基础部分，主要讲解 DevEco Studio 的环境搭建、ArkTS语言编程基础、鸿蒙App开发的各种常用组件、鸿蒙App开发的页面转场和消息交互、鸿蒙App的几种数据存储方式等；后8章是进阶部分，主要讲解鸿蒙App开发的后台任务、手势交互、动画特效、网络通信、多媒体、感知定位、人工智能、多端部署等。</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"android第三版\" class=\"lazyload\" height=\"439\" width=\"439\" /></span></span></span></span></p>\n<p>曾经有老读者咨询“从零基础到App上线”系列书籍的第4版何时面世，现在博主终于可以说，“从零基础到App上线”的第4版已经出版啦，而且第4版是鸿蒙版本的“从零基础到App上线”，它就叫做《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》，该书把安卓版教程平替为鸿蒙版教程，也是一个勇敢的尝试。<br />\n《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》在讲解知识点的同时给出了大量实战范例，方便读者迅速将所学的知识运用到实际开发中。通过本书的学习，读者能够掌握3类主流App的基本开发技术，包括购物App（电子商务）、聊天App（即时通信）、娱乐App（短视频分享）。另外，能够学会开发一些趣味应用，包括计算器、录音笔、电子相册、打牌游戏、指南针、水平仪、卫星浑天仪、登山助手、附近交友、速记助手、人脸识别等等。可见《Android Studio开发实战：从零基础到App上线(第3版)》一书提到的实战项目，本书基本提供了对应的鸿蒙版App。</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"鸿蒙系统\" class=\"lazyload\" height=\"237\" width=\"558\" /></span></span></span></span></p>\n<p>《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》的随书源码包括客户端部分和服务端部分，其中客户端的App代码基于 DevEco Studio 6.0.0 Release 开发，并使用 API 20 的 SDK （HarmonyOS 6.0.0）编译与调试通过，测试机型包括 Mate 60 Pro 和 nova 12 Pro 。配套的服务端源码采用 Java WEB 框架，结合 MySQL 数据库，并基于 IDEA 开发。<br />\n为了便于读者学习鸿蒙应用编程，《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》同时提供了随书源码和课件PPT，这些下载资源可以扫描该书前言末尾的二维码获得。最新的随书源码也可访问我的码云主页，下载页面是 https://gitee.com/aqi00/harmony 。</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 11:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aqi00\">aqi00</a>&nbsp;\n阅读(<span id=\"post_view_count\">91</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Python中生成器表达式（generator expression）和列表推导式（list comprehension）的区别",
      "link": "https://www.cnblogs.com/xlcm/p/19528838",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xlcm/p/19528838\" id=\"cb_post_title_url\" title=\"发布于 2026-01-25 10:48\">\n    <span>Python中生成器表达式（generator expression）和列表推导式（list comprehension）的区别</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"python-列表推导式与生成器表达式区别\">Python 列表推导式与生成器表达式区别</h1>\n<p>列表推导式（List Comprehension）和生成器表达式（Generator Expression）是 Python 中创建可迭代对象的高效语法，二者语法相似但核心特性、内存模型、使用场景差异显著。</p>\n<h2 id=\"一基础认知定义与语法\">一、基础认知：定义与语法</h2>\n<h3 id=\"1-核心定义\">1. 核心定义</h3>\n<ul>\n<li><strong>列表推导式</strong>：以 <code>[]</code> 包裹表达式，<strong>立即生成完整的列表对象</strong>，所有元素一次性加载到内存中。</li>\n<li><strong>生成器表达式</strong>：以 <code>()</code> 包裹表达式，<strong>生成生成器对象（generator）</strong>，不立即生成元素，仅保存“生成逻辑”，按需生成（惰性求值）。</li>\n</ul>\n<h3 id=\"2-语法对比\">2. 语法对比</h3>\n<pre><code class=\"language-python\"># 列表推导式：生成[0, 1, 2]，直接返回列表\nlist_comp = [x for x in range(3)]\nprint(type(list_comp))  # &lt;class 'list'&gt;\n\n# 生成器表达式：返回生成器对象，无实际元素\ngen_exp = (x for x in range(3))\nprint(type(gen_exp))    # &lt;class 'generator'&gt;\n</code></pre>\n<h2 id=\"二核心区别最关键\">二、核心区别（最关键）</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>列表推导式</th>\n<th>生成器表达式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>内存使用</strong></td>\n<td>一次性占用全部内存（元素越多占用越大）</td>\n<td>内存占用极小（固定开销，与元素数量无关）</td>\n</tr>\n<tr>\n<td><strong>迭代次数</strong></td>\n<td>可重复遍历（元素常驻内存）</td>\n<td>仅能遍历一次（遍历后“耗尽”）</td>\n</tr>\n<tr>\n<td><strong>计算时机</strong></td>\n<td>定义时立即计算所有元素</td>\n<td>迭代时才计算（惰性求值）</td>\n</tr>\n<tr>\n<td><strong>数据访问</strong></td>\n<td>支持索引/切片（序列类型）</td>\n<td>不支持索引/切片（非序列类型）</td>\n</tr>\n<tr>\n<td><strong>返回类型</strong></td>\n<td>list 对象</td>\n<td>generator 对象</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"关键验证代码\">关键验证代码</h3>\n<pre><code class=\"language-python\">import sys\n\n# 1. 内存占用对比（100万个元素）\nbig_list = [x for x in range(1000000)]\nbig_gen = (x for x in range(1000000))\nprint(\"列表内存：\", sys.getsizeof(big_list))  # 约8MB\nprint(\"生成器内存：\", sys.getsizeof(big_gen)) # 约100字节\n\n# 2. 迭代次数对比\nprint(\"列表第一次遍历：\", [x for x in big_list[:2]])  # [0,1]\nprint(\"列表第二次遍历：\", [x for x in big_list[:2]])  # [0,1]\nprint(\"生成器第一次遍历：\", [x for x in big_gen][:2]) # [0,1]\nprint(\"生成器第二次遍历：\", [x for x in big_gen][:2]) # []（耗尽）\n\n# 3. 索引访问对比\nprint(\"列表索引访问：\", big_list[0])  # 0\n# print(\"生成器索引访问：\", big_gen[0])  # 报错：不支持索引\n</code></pre>\n<h2 id=\"三遍历方法通用专属\">三、遍历方法（通用+专属）</h2>\n<h3 id=\"1-通用遍历方法列表生成器都适用\">1. 通用遍历方法（列表/生成器都适用）</h3>\n<h4 id=\"1for-循环最推荐\">（1）for 循环（最推荐）</h4>\n<p>简洁、Pythonic，是遍历可迭代对象的标准方式：</p>\n<pre><code class=\"language-python\"># 遍历列表\nlist_comp = [x*2 for x in range(3)]\nfor num in list_comp:\n    print(num, end=\" \")  # 0 2 4（可重复遍历）\n\n# 遍历生成器\ngen_exp = (x*2 for x in range(3))\nfor num in gen_exp:\n    print(num, end=\" \")  # 0 2 4（仅一次有效）\n</code></pre>\n<h4 id=\"2转换为列表元组生成器会失去内存优势\">（2）转换为列表/元组（生成器会失去内存优势）</h4>\n<p>生成器可转为列表一次性获取所有元素，但会占用完整内存：</p>\n<pre><code class=\"language-python\">gen_exp = (x*3 for x in range(3))\ngen_to_list = list(gen_exp)  # [0, 3, 6]\nprint(\"生成器转列表：\", gen_to_list)\n</code></pre>\n<h4 id=\"3迭代工具enumeratezip\">（3）迭代工具（enumerate/zip）</h4>\n<p>增强遍历能力，支持带索引、多对象同步遍历：</p>\n<pre><code class=\"language-python\"># 带索引遍历\ngen_exp = (x for x in range(3))\nfor idx, num in enumerate(gen_exp):\n    print(f\"索引{idx}：{num}\")  # 索引0：0  索引1：1  索引2：2\n</code></pre>\n<h3 id=\"2-专属遍历方法\">2. 专属遍历方法</h3>\n<h4 id=\"1列表索引切片访问\">（1）列表：索引/切片访问</h4>\n<p>列表是序列类型，可直接通过索引定位元素：</p>\n<pre><code class=\"language-python\">list_comp = [x for x in range(3)]\nprint(list_comp[1])       # 1（直接索引）\nprint(list_comp[0:2])     # [0,1]（切片）\n</code></pre>\n<h4 id=\"2生成器next-函数手动逐个获取\">（2）生成器：next() 函数（手动逐个获取）</h4>\n<p>生成器是迭代器，可通过 <code>next()</code> 手动取元素，需处理 <code>StopIteration</code> 异常：</p>\n<pre><code class=\"language-python\">gen_exp = (x for x in range(2))\nprint(next(gen_exp))  # 0\nprint(next(gen_exp))  # 1\n# print(next(gen_exp))  # 报错：StopIteration（元素耗尽）\n</code></pre>\n<h2 id=\"四适用场景选对工具的关键\">四、适用场景（选对工具的关键）</h2>\n<h3 id=\"优先用列表推导式的场景\">优先用列表推导式的场景</h3>\n<ol>\n<li>元素数量少，内存占用无压力；</li>\n<li>需要多次遍历元素；</li>\n<li>需使用列表专属操作（索引、切片、append/sort 等）。</li>\n</ol>\n<h3 id=\"优先用生成器表达式的场景\">优先用生成器表达式的场景</h3>\n<ol>\n<li>处理超大数量元素（避免内存溢出）；</li>\n<li>仅需遍历一次元素（如逐个处理数据）；</li>\n<li>配合聚合函数（sum/max/min），无需存储所有元素：<pre><code class=\"language-python\"># 计算1000万个数的和，生成器更省内存\ntotal = sum(x for x in range(10000000))\n</code></pre>\n</li>\n</ol>\n<h2 id=\"五核心总结\">五、核心总结</h2>\n<ol>\n<li><strong>内存是核心差异</strong>：列表推导式“全量存储”占内存大，生成器表达式“按需生成”内存占用极小；</li>\n<li><strong>遍历特性不同</strong>：列表可重复遍历、支持索引，生成器仅能遍历一次、不支持索引；</li>\n<li><strong>场景选择原则</strong>：小数据/多次遍历用列表推导式，大数据/单次遍历用生成器表达式。</li>\n</ol>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-25 10:48</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xlcm\">夏了茶糜</a>&nbsp;\n阅读(<span id=\"post_view_count\">7</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Python 学习笔记：学习路线图规划",
      "link": "https://www.cnblogs.com/owlman/p/19528822",
      "published": "",
      "description": "<h2 class=\"post-title\">\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/owlman/p/19528822\" id=\"cb_post_title_url\" title=\"发布于 2026-01-25 10:46\">\n    <span>Python 学习笔记：学习路线图规划</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>[!NOTE] 笔记说明</p>\n<p>在这个系列笔记中，我将陆续整理自己在学习 Python 这门编程语言过程中所累积的心得与体会，它们将被存储在我个人的<a href=\"https://github.com/owlman/CS_Studynotes\" rel=\"noopener nofollow\" target=\"_blank\">计算机学习笔记库</a>中，并予以长期维护。</p>\n</blockquote>\n<h2 id=\"语言的来历与版本历史\">语言的来历与版本历史</h2>\n<p>1989 年的圣诞节期间，时任荷兰数学和计算机科学研究学会（CWI）研究员的 Guido van Rossum<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\" rel=\"noopener nofollow\">[1]</a></sup> 决定基于 ABC 语言设计并实现一门新的脚本编程语言，最初目的是用于替代 Unix shell 和部分 C 程序，以承担 Amoeba 分布式操作系统<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\" rel=\"noopener nofollow\">[2]</a></sup>中的系统管理、异常处理与交互任务。由于 Guido 本人是 BBC 电视剧《Monty Python 的飞行马戏团》（<em>Monty Python’s Flying Circus</em>）的爱好者，这门语言最终被命名为 Python。</p>\n<p>自 Python 项目创建以来，Guido van Rossum 长期担任该语言的主要设计者与决策者，并以 Python 社区公认的“终身仁慈独裁者”（Benevolent Dictator For Life，简称 BDFL）身份主导该语言的发展方向。2018 年 7 月 12 日，Guido 宣布从 BDFL 职位上“永久休假”。然后从 2018 年开始，Python 项目不再由单一的 BDFL 主导，而是由治理委员会（Steering Council）进行集体决策。治理委员会成员由社区定期选举产生，负责在各自任期内引导 Python 语言的整体发展方向。</p>\n<p>下面，让我们按时间顺序来简要回顾一下 Python 的主要版本演进历程。</p>\n<ul>\n<li>\n<p><strong>1991 年 2 月</strong>，Guido van Rossum 在 Usenet 新闻组 alt.sources 上发布了 Python 的最初实现（版本号为 0.9.0）。该版本已经支持类（含继承机制）、异常处理、函数定义，以及<code>list</code>、<code>dict</code>、<code>str</code>等核心内置数据类型。</p>\n<p><strong>1994 年 1 月</strong>，Python 1.0 发布，引入了<code>lambda</code>、<code>map</code>、<code>filter</code>和<code>reduce</code>等函数式编程特性。随后，Python 1.1 增加了参数默认值，Python 1.3 引入了关键字参数，Python 1.4 则加入了对复数类型的内置支持。</p>\n</li>\n<li>\n<p><strong>2000 年 10 月</strong>，Python 2.0 发布，引入了受函数式编程语言影响的列表推导式。Python 2.1 支持了静态嵌套作用域。Python 2.2 对对象模型进行了重大重构，将用 C 实现的内置类型与用 Python 实现的类统一为一致的对象体系，同时引入了迭代器、生成器以及描述器协议。随后，Python 2.3 加入了源自 Dylan 的方法解析顺序（MRO），Python 2.4 引入了集合类型与函数修饰器，Python 2.5 在官方实现中加入了抽象语法树支持。</p>\n</li>\n<li>\n<p><strong>2008 年 12 月</strong>，Python 3.0 发布。该版本对语言进行了大规模修订，因而无法与 Python 2 系列保持完全向后兼容。尽管官方提供了 <code>2to3</code> 自动转换工具，但大量既有代码仍难以迁移，因此 Python 2.7 的生命周期被多次延长，最终于<strong>2020 年 1 月 1 日</strong>正式结束支持。</p>\n<p>在 Python 3 系列中，Python 3.4 引入了异步 I/O 框架，Python 3.5 增加了类型提示（Type Hints）以及基于 <code>async/await</code> 语法的协程支持，Python 3.8 引入了赋值表达式（海象运算符）。</p>\n</li>\n<li>\n<p><strong>2020 年 10 月</strong>，Python 3.9 发布，引入了针对容器类型的泛化别名（<code>types.GenericAlias</code>），并在官方实现中逐步替换了旧的语法解析器。Python 3.10 加入了结构化模式匹配（借鉴自 Haskell、OCaml 等语言）以及内置的联合类型（<code>types.UnionType</code>）。Python 3.11 对解释器执行性能进行了大幅优化。Python 3.12 引入了类型参数语法，并移除了或废弃了一批历史遗留模块与功能。</p>\n</li>\n<li>\n<p><strong>2024 年 10 月</strong>，Python 3.13 发布，引入了多项实验性改进，包括可选的无全局解释器锁（free-threaded）构建方式、解释器内部结构的进一步重构，以及对交互体验和执行性能的探索性优化。</p>\n<p><strong>Python 3.14</strong>在此基础上继续推进无 GIL 解释器的官方支持，将其作为受支持的可选构建形态之一，但默认构建仍保留传统的 GIL 机制，以确保生态系统的兼容性与稳定性。</p>\n</li>\n</ul>\n<p>按照官方生命周期策略，每个 Python 版本在发布后通常会经历一段以缺陷修复（bugfix）为主的活跃维护期，随后进入以安全修复（security fixes）为主的长期支持阶段，整个生命周期一般持续约五年。</p>\n<h2 id=\"语言特质及其适用领域\">语言特质及其适用领域</h2>\n<p>如果仔细回顾一下近年来由人工智能技术所带来的这波热潮，我们就不难发现一个有趣的现象：当 DeepMind 的 AlphaGo 击败人类围棋冠军时，该应用中的系统集成与算法协调的角色主要是由 Python 来承担的；当 DeepSeek、ChatGPT 等 NLP 应用推动智能助手革命时，Python 也是其基础训练框架（例如 PyTorch、TensorFlow）的实现语言。根据 2023 年 IEEE Spectrum 编程语言排行榜，Python 已连年蝉联榜首。在我个人看来，该语言在 Ai 时代的这种强大统治力主要源于它的以下特质。</p>\n<h3 id=\"贴近人类思维的表达能力\">贴近人类思维的表达能力</h3>\n<p>诚如大家所知，Python 是当前在程序设计领域中最为热门的、解释型的高级编程语言之一。它支持函数式、指令式、结构化和面向对象编程等多种编程范型，且拥有强大的动态类型系统和垃圾回收功能，能够自动管理内存使用，并且其本身拥有一个巨大而广泛的标准库。这些特性可以帮助使用这门编程语言的程序员在参与各种规模的项目时编写出思路清晰的、合乎逻辑的代码。在使用 Python 编写代码时，开发者们通常会遵循“优雅、明确、简单”的核心准则，具体来说就是：</p>\n<blockquote>\n<p>优美优于丑陋。明了优于隐晦。<br />\n简单优于复杂。复杂优于凌乱。<br />\n扁平优于嵌套。稀疏优于稠密。<br />\n可读性很重要。<sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\" rel=\"noopener nofollow\">[3]</a></sup></p>\n</blockquote>\n<p>譬如，从下面与 Java 这类传统编程语言的语法比较中，读者应该可以体会到 Python 语言有着更贴近自然语言的表达方式，这有助于开发者们在执行编程任务时将注意力聚焦于表达计算思维本身，而不是纠结于各种语法细节。</p>\n<pre><code>```python\n# Java 的语法：\nfor(int i=0; i&lt;10; i++) { \n    System.out.println(i);\n} \n\n# Python 的语法：\nfor i in range(10):\n    print(i)\n```\n</code></pre>\n<h3 id=\"在科学计算领域的完善生态\">在科学计算领域的完善生态</h3>\n<p>关于 Python 语言在科学计算领域所建立的“完善生态”，我们可以分全栈式的完备工具链、跨语言生态的集成能力、跨学科生态的渗透能力、以及开源社区的强大凝聚力等几个不同的方面来进行介绍。</p>\n<ol>\n<li>\n<p><strong>全栈式的完备工具链</strong>：Python 以 NumPy（高性能多维数组）、SciPy（科学算法集成）和 Matplotlib（可视化）三大核心扩展库为基石，构建了覆盖数值计算、统计分析、机器学习、图像处理等全栈式的工具链生态。例如，SciPy 库中内置的 100 多种概率分布函数，可直接替代 MATLAB 来完成类似疫情传播建模这样的复杂分析任务，而 PyTorch/TensorFlow 等框架则依托 Python 接口成为 AI 训练的行业标准。</p>\n</li>\n<li>\n<p><strong>跨语言生态的集成能力</strong>：在 Python 开发环境中，我们会借助 Cython/f2py 等技术来无缝集成基于 Fortran/C++ 等语言构建的底层数学库（如BLAS/LAPACK），以便将计算密集型任务转移至编译语言执行，既保留开发效率又规避性能短板。这种“前端 Python + 后端 C”的模式，使开发者无需深入底层即可调用数十年积累的高性能代码，形成生态护城河。</p>\n</li>\n<li>\n<p><strong>跨学科生态的雪球效应</strong>：正如之前所说，Python 在 IEEE Spectrum 榜单中连年占据首位，如今已成为科学界撰写学术论文时默认工具之一。天文学、物理学期刊中 Python 代码占比显着提升，其简洁语法降低了非计算机专业研究者的使用门槛。而且，从金融量化（取代 R/MATLAB）到生物信息学，Python 的通用性促使其库生态滚雪球式扩张，例如 Pandas 在工程化数据处理、与 Python 生态的集成以及生产环境部署方面具有显著优势，而 scikit-learn 则大幅降低了传统机器学习方法的工程应用门槛。</p>\n</li>\n<li>\n<p><strong>社区驱动的自我强化</strong>：截止到目前，Python 的开源生态已经催生了近 50 万个的 PyPI项目（其2024年的官方数据），形成“需求-开发-反馈”闭环。例如，借助 CUDA Python 和 PyTorch/RAPIDS/CuPy 等扩展库，我们可以实现从高层 API 到 GPU 内核开发的平滑过渡，满足不同层级开发者需求。这种生态活力也让 Fortran 等传统科学语言因工程化开发效率不高而逐渐式微。</p>\n</li>\n</ol>\n<p>总而言之，Python 基于<strong>开发效率与执行性能的平衡策略</strong>，将科学计算从孤立工具（如 MATLAB）转变为可嵌入 Web、云计算、AI 工作流的“基础语言”，最终成为多学科交叉创新的最大公约数。在更为强大的 AI 应用即将来临之际，人类的核心价值在于“创造机器不可替代的创造力”。这本教材所要传授给读者的不仅是语法知识，更是以下三种程序员的未来素养：</p>\n<ul>\n<li><strong>计算思维</strong>：将混沌问题分解为可执行逻辑的能力。</li>\n<li><strong>算法直觉</strong>：洞察问题本质的建模智慧。</li>\n<li><strong>数字伦理</strong>：技术向善的价值罗盘。</li>\n</ul>\n<p>而且，除了基本语法之外，一个 Python 开发者的能力实际上就取决于如何根据自己面对的问题找到适用的框架，并在合理的时间内掌握该框架的使用方法，并用它快速地构建自己的项目。从这方面来说的话，该语言目前活跃的主要应用领域如下所示：</p>\n<ul>\n<li><strong>GUI 应用</strong>：在这一领域，我们可以选择引入 PyQT、WxPython 等框架来开发 GUI 应用。</li>\n<li><strong>Web 应用</strong>：在这一领域，我们可以选择引入 Django、Web2py、Bottle、Tornado、Flask 等框架来开发个人博客、线上论坛等 Web 应用程序以及基于 HTTP 协议的应用程序服务端；</li>\n<li><strong>网络编程</strong>：在这一领域，我们可以选择引入 Twisted 框架来开发基于多种网络协议的应用程序，该框架支持的协议既包括 UDP、TCP、TLS 等传输层协议，也包括 HTTP、FTP 等应用层协议；</li>\n<li><strong>网络爬虫</strong>：在这一领域，我们可以选择引入 Scrapy 这个轻量级的框架来从指定的网站中收集有用的数据；</li>\n<li><strong>科学计算</strong>：在这一领域，我们可以选择引入 Numpy、Scipy、pandas、matplotlib 等框架进行各种科学数值计算，并生成相关的数据报告或图表；</li>\n<li><strong>人工智能</strong>：在这一领域，我们可以选择引入 PyTorch、NLTK、tensorflow 等框架来数据挖掘、自然语言处理、机器学习等方向上的工作；</li>\n<li><strong>图形化游戏</strong>：在这一领域，我们可以选择引入 PyGame、PyOgre、Panda3D 等框架来开发俄罗斯方块、贪吃蛇这样的二维或三维的图形化游戏。</li>\n<li><strong>CI/CD 自动化</strong>：在这一领域，我们可以选择引入 Buildbot 框架来实现自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果；</li>\n<li><strong>自动化测试</strong>：在这一领域，我们可以选择引入 PyTest、Playwright、Selenium、Robot 等扩展库和框架来实现自动化的 UI 测试、接口测试、兼容性测试等；</li>\n</ul>\n<h2 id=\"学习路线图规划\">学习路线图规划</h2>\n<p>在了解 Python 语言的基本情况之后，接下来就可以来具体规划一下要如何学习这门语言的学习路线图了。大致上，我们可以将路线图划分为以下三个里程碑来进行。</p>\n<h3 id=\"能搭建属于自己的编程环境\">能搭建属于自己的编程环境</h3>\n<p>这一里程碑主要聚焦的是<em>编程环境的搭建能力</em>。具体到 Python 语言来说，编程环境包括我们使用这门编程语言时所基于的操作系统、语言运行时环境，以及编写代码所要使用的编辑器（或集成开发环境，即 IDE）。总而言之，所谓的“工欲善其事，必先利其器”，想要学好编程语言，首先必须学会从零开始搭建自己的编程环境。</p>\n<p><strong>参考书目</strong>：</p>\n<ul>\n<li><a href=\"https://book.douban.com/subject/35562032/\" rel=\"noopener nofollow\" target=\"_blank\">《Visual Studio Code for Python Programmer》</a></li>\n<li><a href=\"https://book.douban.com/subject/35125617/\" rel=\"noopener nofollow\" target=\"_blank\">《Visual Studio Code 权威指南》</a></li>\n</ul>\n<blockquote>\n<p>关联笔记：[[编程环境配置|Python 学习笔记：编程环境配置]] <a href=\"https://www.cnblogs.com/owlman/p/19501012\" target=\"_blank\">博客园链接</a></p>\n</blockquote>\n<h3 id=\"掌握编程语言的基础语法\">掌握编程语言的基础语法</h3>\n<p>这一里程碑主要聚焦的是<em>基于编程语言的表达能力</em>。编程语言归根结底是一种用于表达人类思维，并让计算机执行的工具，所以首先要做的就是掌握这门编程语言的基础语法以及它的标准库。然后，再初步了解如何使用这门语言实现一些基本的算法，完成一些基本的编程任务。</p>\n<p><strong>参考书目</strong>：</p>\n<ul>\n<li><a href=\"https://book.douban.com/subject/27662927/\" rel=\"noopener nofollow\" target=\"_blank\">《Python 程序设计》</a></li>\n<li><a href=\"https://book.douban.com/subject/27667375/\" rel=\"noopener nofollow\" target=\"_blank\">《Python 基础教程》</a></li>\n<li><a href=\"https://book.douban.com/subject/36365320/\" rel=\"noopener nofollow\" target=\"_blank\">《Python 编程：从入门到实践》</a></li>\n</ul>\n<blockquote>\n<p>关联笔记：[[基础语法学习|Python 学习笔记：基础语法学习]] <a href=\"https://www.cnblogs.com/owlman/p/19505712\" target=\"_blank\">博客园链接</a></p>\n</blockquote>\n<h3 id=\"能快速进入具体的项目开发\">能快速进入具体的项目开发</h3>\n<p>这一里程碑主要聚焦的是<em>面向具体开发需求的可持续学习能力</em>。众所周知，基于“不重复发明轮子”的基本原则，如今大部分的应用程序开发项目都是基于现有的第三方扩展（库和框架）来进行的，所以，面向具体的开发需求，我们的可持续学习能力实际上就是快速了解并掌握某个第三方扩展的能力。</p>\n<p>然而，在如今的 Python 社区中，第三方扩展的数量早已超过了 50 万个，而且还在不断增长。即使是面对某一具体的开发需求，它们也不仅琳琅满目，选择众多，而且新陈代谢还极为快速。这意味着，即使我们用一本书介绍了当前在面向某一具体开发需求时最为流行的第三方扩展及其使用方法，这些内容很有可能还没等到书出版就已经成了昨日黄花。所以，我们真正的学习目的应该是掌握“快速上手”的能力，这需要学习如何阅读这些扩展本身提供给开发者的官方文档和源代码，自行去了解它们的设计思路。从某种程度上来说，这也需要我们自己具备开发类似扩展的能力，一个优秀的工程师或设计师虽然不必重复发明轮子，但应该要能了解轮子是如何被发明的，这样才能清楚在怎么样的轮子上应该构建怎么样的车，以免闭门造车。</p>\n<blockquote>\n<p>关联笔记：[[具体项目实践|Python 学习笔记：具体项目实践]] <a href=\"https://www.cnblogs.com/owlman/p/19526745\" target=\"_blank\">博客园链接</a></p>\n</blockquote>\n<p>总而言之，对于如今的软件工程师来说，在一个月内快速掌握某个新框架的能力远比之前已经掌握了多少个框架重要得多，例如当开发团队的管理员在面试新成员时，如果这位面试者有五年 A 框架的使用经验，那固然是很好，但团队中很多人都有，未必需要再多一个同类型的人才、但如果该面试者能在一个礼拜快速上手基于 Python 的任意一种第三方扩展，那么这位人才的重要性就会被凸显出来。</p>\n\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li class=\"footnote-item\" id=\"fn1\"><p>吉多·范罗苏姆（荷兰语：Guido van Rossum，1956年1月31日—），生于荷兰哈勒姆，计算机程序员，为 Python 程序设计语言的最初设计者及主要架构师。关于他的生平事迹，读者可以参考<a href=\"https://zh.wikipedia.org/wiki/%E5%90%89%E5%A4%9A%C2%B7%E8%8C%83%E7%BD%97%E8%8B%8F%E5%A7%86\" rel=\"noopener nofollow\" target=\"_blank\">维基百科中的相关词条</a>。 <a class=\"footnote-backref\" href=\"#fnref1\" rel=\"noopener nofollow\">↩︎</a></p>\n</li>\n<li class=\"footnote-item\" id=\"fn2\"><p>Amoeba 是由阿姆斯特丹自由大学的 Andrew S. Tanenbaum 等人开发的分布式作系统 。Amoeba 项目的目标是构建一个分时系统，使整个计算机网络在用户眼中看起来像是一台机器。关于该系统的详细信息，读者可以参考<a href=\"https://en.wikipedia.org/wiki/Amoeba_(operating_system)\" rel=\"noopener nofollow\" target=\"_blank\">维基百科中的相关词条</a>。 <a class=\"footnote-backref\" href=\"#fnref2\" rel=\"noopener nofollow\">↩︎</a></p>\n</li>\n<li class=\"footnote-item\" id=\"fn3\"><p>这些准则出自<a href=\"https://www.python.org/dev/peps/pep-0020/\" rel=\"noopener nofollow\" target=\"_blank\">《the Zen of Python》</a>一文。 <a class=\"footnote-backref\" href=\"#fnref3\" rel=\"noopener nofollow\">↩︎</a></p>\n</li>\n</ol>\n</section>\n\n</div>\n<div class=\"clear\"></div>\n\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\">2026-01-25 10:46</span>&nbsp;\n<a href=\"https://www.cnblogs.com/owlman\">凌杰</a>&nbsp;\n阅读(<span id=\"post_view_count\">14</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n        </p>"
    }
  ]
}